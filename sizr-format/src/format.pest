// Pest (PEG) grammar for the sizr-format formatting language

// LANGUAGE FEATURES:
// commands:
// - literal command:
//   - "anything in quotes"
//   - whitespace is ignored, so good for capturing whitespace
// - wrap command: \
//   - where text is allowed to break
// - conditional command: 
//   - ?(cond) then : else
//   - ?(cond) : else
//   - ?(cond) then
//   - basically condition for the next command, with possible else
// - indentation:
//   - >| indent to same level?
//   - |> indent
//   - |>> indent twice (etc...)
//   - <| outdent
//   - >( indent to outer parenthesis
//   - >[ indent to outer bracket
//   - >{ indent to outer brace
//   - >" indent to outer quote
//   - >!" " custom post indent literal
// indents in some languages may be implied

// SCRIPT ENGINE:
// operators:
// - standard C bitwise, arithmetic, comparison operators
// - logical: &, |, ^, ~
// - set: &, |, ~, -
// - cast '@' e.g. 5@f
// - no assignment
// lambdas:
// - .property, .propery=
// - lambdas are cast to predicates implicitly when using set operators to
//   manipulate them
//   - i.e. .static&.private - .returns=double
// mapping slices/filters:
// - numeric: map[0..+1..10], map[0..10], map[0..], map[..]
//                   ^ explicit step
// - lambda: map[.static|.private] # predicate operations
// - pattern matching:
//   - map["r"]
//   - map["r"|"g"|"b"]
//   - map[/[rgb]/]
// - leftover: map[_]
// types:
// - number (n), bool (b), string (s), mapping (m), list (l)

ESCAPE = _{ "\\" }
QUOTE = _{ "\"" }
ESCAPED_QUOTE = _{ ESCAPE ~ QUOTE }

quote =
  @
  { QUOTE
  ~ (!( ESCAPED_QUOTE
      | QUOTE
    ) ~ ANY)*
  ~ QUOTE
  }

// might be better to separately captured escaped delimiter
regex =
  @
  { "/"
  ~ (!( "\\/"
    | !"/"
    ) ~ ANY)*
  ~ "/"
  }

ident = @{ ASCII_ALPHA ~ ( ASCII_ALPHANUMERIC | "_" )* }

lambda = @{ "." ~ ident }

natural = @{ ASCII_DIGIT+ }
integer = @{ "-"? ~ natural }

var = @{ "$" ~ ident }

expr = { logic_expr }

AND = _{ "&" }
OR  = _{ "|" }
XOR = _{ "^" }

logic_expr =
  { cmp_expr ~ AND ~ cmp_expr
  | cmp_expr ~ OR ~ cmp_expr
  | cmp_expr ~ XOR ~ cmp_expr
  }

GT  = _{ ">"  }
GTE = _{ ">=" }
EQ  = _{ "="  }
NEQ = _{ "!=" }
LTE = _{ "<=" }
LT  = _{ "<"  }

cmp_expr =
  { add_expr ~ GT  ~ add_expr
  | add_expr ~ GTE ~ add_expr
  | add_expr ~ EQ  ~ add_expr
  | add_expr ~ NEQ ~ add_expr
  | add_expr ~ LTE ~ add_expr
  | add_expr ~ LT  ~ add_expr
  }

PLUS  = _{ "+" }
MINUS = _{ "-" }

add_expr =
  { mult_expr ~ PLUS  ~ mult_expr
  | mult_expr ~ MINUS ~ mult_expr
  }

MULT   = _{ "*"  }
DIV    = _{ "/"  }
INTDIV = _{ "//" }
MOD    = _{ "%"  }

mult_expr =
  { pow_expr ~ MULT   ~ pow_expr
  | pow_expr ~ DIV    ~ pow_expr
  | pow_expr ~ INTDIV ~ pow_expr
  | pow_expr ~ MOD    ~ pow_expr
  }

POW = _{ "**" }

pow_expr =
  { slice_expr ~ POW ~ slice_expr
  }

range_slice = 
  { integer?
  ~ ".."
  ~ ( ("+"|"-")
      ~ natural
      ~ ".."
    )
  ?
  ~ integer?
  }

slice = { range_slice | atom_expr | "_" }

slice_block = { "[" ~ slice ~ "]" }

slice_expr = { unary_expr ~ slice_block }

unary_expr =
  { "-" ~ atom_expr
  | "~" ~ atom_expr
  | "!" ~ atom_expr
  }

atom_expr =
  { integer
  | quote
  | regex
  | var
  | "(" ~ expr ~ ")"
  | lambda
  }

wrap = @{ "\\" }
expr_cond =
  { "?"
  ~ "("
  ~ expr
  ~ ")"
  ~ expr?
  ~ (":" ~ expr)?
  }

wrap_cond =
  { "\\?" ~ expr
  | "\\:" ~ expr
  | "\\?" ~ expr ~ ":" ~ expr
  }

cond = { expr_cond | wrap_cond }

cmd =
  { expr
  | cond
  }
  

// PUSH individual single quotes to handle depth via the stack?
body_start = @{ "'''" }
body_end = @{ "'''" }

indent_ctx =
  { "|>"
  | "|>>" // TODO: use parse stack to allow any indent level
  | ">|"
  | ">("
  | ">["
  | ">{"
  | ">\""
  | ">!" ~ quote
  }

line =
  { indent_ctx?
  ~ ( !body_end ~ expr
    | !body_end ~ ANY
    )
  *
  }

node_body = { line* }

COLON = _{ ":" }
node_decl =
  { ident
  ~ COLON
  ~ body_start
  ~ node_body
  ~ body_end
  }

// will probably use YAML format instead of this
file =
  { SOI
  ~ node_decl*
  ~ EOI
  }

COMMENT =
  { ("#<>" | "#<" | "#>" )
  ~ (!NEWLINE ~ ANY)*
  }

WHITESPACE = _{ " " }
