// Pest (PEG) grammar for the sizr-format formatting language

// LANGUAGE FEATURES:
// commands:
// - literal command:
//   - "anything in quotes"
//   - whitespace is ignored, so good for capturing whitespace
// - wrap command: \
//   - where text is allowed to break
// - conditional command: 
//   - ?(cond) then : else
//   - ?(cond) : else
//   - ?(cond) then
//   - basically condition for the next command, with possible else
// - indentation:
//   - >| indent to same level?
//   - |> indent
//   - |>> indent twice (etc...)
//   - <| outdent
//   - >( indent to outer parenthesis
//   - >[ indent to outer bracket
//   - >{ indent to outer brace
//   - >" indent to outer quote
//   - >!" " custom post indent literal
// indents in some languages may be implied

// SCRIPT ENGINE:
// operators:
// - standard C bitwise, arithmetic, comparison operators
// - logical: &, |, ^, ~
// - set: &, |, ~, -
// - cast '@' e.g. 5@f
// - no assignment
// lambdas:
// - .property, .propery=
// - lambdas are cast to predicates implicitly when using set operators to
//   manipulate them
//   - i.e. .static&.private - .returns=double
// mapping slices/filters:
// - numeric: map[0..+1..10], map[0..10], map[0..], map[..]
//                   ^ explicit step
// - lambda: map[.static|.private] # predicate operations
// - pattern matching:
//   - map["r"]
//   - map["r"|"g"|"b"]
//   - map[/[rgb]/]
// - leftover: map[_]
// types:
// - number (n), bool (b), string (s), mapping (m), list (l)

QUOTE = _{ "\"" }
ESCAPE = _{ "\\" }
ESCAPED_QUOTE = _{ " }

quote = ${ QUOTE ~ str_content ~ QUOTE }
str_content = @{ str_char* }
str_char =
  { !(QUOTE | ESCAPE) ~ ANY
  | ESCAPE ~ (QUOTE | ESCAPE | "n" | "t" | "r")
  | ESCAPE ~ ("u" ~ ASCII_HEX_DIGIT{4})
  }

regex = ${ "/" ~ regex_content ~ "/" ~ ASCII_ALPHA{1,3} }
regex_content = @{ regex_char* }
regex_char =
  { !("/" | ESCAPE) ~ ANY
  | ESCAPE ~ ANY
  }

ident = @{ ASCII_ALPHA ~ ( ASCII_ALPHANUMERIC | "_" )* }

lambda = @{ "." ~ ident }

natural = @{ ASCII_DIGIT+ }
integer = @{ "-"? ~ natural }

var = @{ "$" ~ ident }

AND    = _{ "&" }
OR     = _{ "|" }
XOR    = _{ "^" }
GT     = _{ ">"  }
GTE    = _{ ">=" }
EQ     = _{ "="  }
NEQ    = _{ "!=" }
LTE    = _{ "<=" }
LT     = _{ "<"  }
PLUS   = _{ "+" }
MINUS  = _{ "-" }
MULT   = _{ "*" }
DIV    = _{ "/" }
INTDIV = _{ "//" }
MOD    = _{ "%" }
POW    = _{ "**" }
DOT    = _{ "." }

expr =
  { atom ~ AND ~ atom
  | atom ~ OR  ~ atom
  | atom ~ XOR ~ atom
  | atom ~ GT  ~ atom
  | atom ~ GTE ~ atom
  | atom ~ EQ  ~ atom
  | atom ~ NEQ ~ atom
  | atom ~ LTE ~ atom
  | atom ~ LT  ~ atom
  | atom ~ PLUS  ~ atom
  | atom ~ MINUS ~ atom
  | atom ~ MULT   ~ atom
  | atom ~ DIV    ~ atom
  | atom ~ INTDIV ~ atom
  | atom ~ MOD    ~ atom
  | atom ~ POW ~ atom
  | atom ~ slice_block
  | "-" ~ atom
  | "~" ~ atom
  | "!" ~ atom
  | atom ~ DOT ~ ident  //can't do x.y[]?
  }

atom =
  _
  { integer
  | quote
  | regex
  | "(" ~ expr ~ ")"
  | lambda
  }

RANGE_DELIMITER = _{ ".." }
range_slice = 
  { integer?
  ~ RANGE_DELIMITER
  ~ ( ("+"|"-")
    ~ natural
    ~ RANGE_DELIMITER
    )
  ?
  ~ integer?
  }

slice = { range_slice | atom | "_" }
slice_block = { "[" ~ slice ~ "]" }

wrap = @{ "\\" }

expr_cond =
  { "?"
  ~ "("
  ~ expr
  ~ ")"
  ~ expr?
  ~ (":" ~ expr)?
  }

wrap_cond =
  { "\\?" ~ expr
  | "\\:" ~ expr
  | "\\?" ~ expr ~ ":" ~ expr
  }

cond = { expr_cond | wrap_cond }

cmd =
  { expr
  | atom
  | cond
  | wrap
  }

// TODO: use parse stack to handle any-depth body delimiters
body_start = _{ "'''" }
body_end = _{ "'''" }

indent_ctx =
  { "|>"
  | "|>>" // TODO: use parse stack to allow any indent level
  | ">|"
  | ">("
  | ">["
  | ">{"
  | ">\""
  | ">!" ~ quote
  }

line =
  {
  ( indent_ctx?
  ~ cmd+
  )
  | NEWLINE
  }

node_body = { line* }

COLON = _{ ":" }
node_decl =
  { ident
  ~ COLON
  ~ body_start
  ~ node_body
  ~ body_end
  }

// will probably use YAML format instead of this
file =
  _
  { SOI
  ~ node_decl*
  ~ EOI
  }

COMMENT =
  _
  { ("#<>" | "#<" | "#>" | "#" )
  ~ (!NEWLINE ~ ANY)*
  }

WHITESPACE = _{ " " | NEWLINE | "\t" }
