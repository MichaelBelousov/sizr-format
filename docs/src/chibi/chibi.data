
(define-library (scheme text) (alias-for (srfi 135)))

(define-library (scheme write)
  (import (rename (chibi) (write write-simple) (display display-simple))
          (rename (srfi 38) (write/ss write-shared)))
  (export display write write-shared write-simple)
  (begin
    (define (display x . o)
      (apply (if (or (string? x) (char? x)) display-simple write) x o))
    (define (write x . o)
      (write-shared x (if (pair? o) (car o) (current-output-port)) #t))))

(define-library (scheme case-lambda) (alias-for (srfi 16)))

(define-library (scheme red)
  (import
   (scheme base)
   (scheme box)
   (scheme case-lambda)
   (scheme char)
   (scheme charset)
   (scheme comparator)
   (scheme complex)
   (scheme cxr)
   (scheme ephemeron)
   (scheme eval)
   (scheme file)
   (scheme generator)
   (scheme hash-table)
   (scheme ideque)
   (scheme ilist)
   (scheme inexact)
   (scheme lazy)
   (scheme list-queue)
   (scheme list)
   (scheme load)
   (scheme lseq)
   (scheme process-context)
   (scheme read)
   (scheme repl)
   (scheme rlist)
   (scheme set)
   (scheme sort)
   (scheme stream)
   (scheme text)
   (scheme time)
   (scheme vector)
   (scheme write))
  (export
    *                               +
    -                               ->char-set
    ...                             /
    <                               <=
    <=?                             <?
    =                               =>
    =?                              >
    >=                              >=?
    >?                              _
    abs                             acos
    alist->bag                      alist->hash-table
    alist-cons                      alist-copy
    alist-delete                    alist-delete!
    and                             angle
    any                             append
    append!                         append-map
    append-map!                     append-reverse
    append-reverse!                 apply
    asin                            assoc
    assq                            assv
    atan                            bag
    bag->alist                      bag->list
    bag->set                        bag->set
    bag-adjoin                      bag-adjoin!
    bag-any?                        bag-comparator
    bag-comparator                  bag-contains?
    bag-copy                        bag-count
    bag-decrement!                  bag-decrement!
    bag-delete                      bag-delete!
    bag-delete-all                  bag-delete-all!
    bag-difference                  bag-difference!
    bag-disjoint?                   bag-element-comparator
    bag-element-count               bag-element-count
    bag-empty?                      bag-every?
    bag-filter                      bag-filter!
    bag-find                        bag-fold
    bag-fold-unique                 bag-fold-unique
    bag-for-each                    bag-for-each-unique
    bag-for-each-unique             bag-increment!
    bag-increment!                  bag-intersection
    bag-intersection!               bag-map
    bag-member                      bag-partition
    bag-partition!                  bag-product
    bag-product                     bag-product!
    bag-product!                    bag-remove
    bag-remove!                     bag-replace
    bag-replace!                    bag-search!
    bag-size                        bag-sum
    bag-sum                         bag-sum!
    bag-sum!                        bag-unfold
    bag-union                       bag-union!
    bag-unique-size                 bag-xor
    bag-xor!                        bag<=?
    bag<?                           bag=?
    bag>=?                          bag>?
    bag?                            begin
    binary-port?                    boolean-hash
    boolean=?                       boolean?
    box                             box?
    break                           break!
    bytevector                      bytevector->generator
    bytevector-append               bytevector-copy
    bytevector-copy!                bytevector-length
    bytevector-u8-ref               bytevector-u8-set!
    bytevector?                     caaaar
    caaadr                          caaar
    caadar                          caaddr
    caadr                           caar
    cadaar                          cadadr
    cadar                           caddar
    cadddr                          caddr
    cadr                            call-with-current-continuation
    call-with-input-file            call-with-output-file
    call-with-port                  call-with-values
    call/cc                         car
    car+cdr                         case
    case-lambda                     cdaaar
    cdaadr                          cdaar
    cdadar                          cdaddr
    cdadr                           cdar
    cddaar                          cddadr
    cddar                           cdddar
    cddddr                          cdddr
    cddr                            cdr
    ceiling                         char->integer
    char-alphabetic?                char-ci-hash
    char-ci<=?                      char-ci<?
    char-ci=?                       char-ci>=?
    char-ci>?                       char-downcase
    char-foldcase                   char-hash
    char-lower-case?                char-numeric?
    char-ready?                     char-set
    char-set->list                  char-set->string
    char-set-adjoin                 char-set-adjoin!
    char-set-any                    char-set-complement
    char-set-complement!            char-set-contains?
    char-set-copy                   char-set-count
    char-set-cursor                 char-set-cursor-next
    char-set-delete                 char-set-delete!
    char-set-diff+intersection      char-set-diff+intersection!
    char-set-difference             char-set-difference!
    char-set-every                  char-set-filter
    char-set-filter!                char-set-fold
    char-set-for-each               char-set-hash
    char-set-intersection           char-set-intersection!
    char-set-map                    char-set-ref
    char-set-size                   char-set-unfold
    char-set-unfold!                char-set-union
    char-set-union!                 char-set-xor
    char-set-xor!                   char-set:ascii
    char-set:blank                  char-set:digit
    char-set:empty                  char-set:full
    char-set:graphic                char-set:hex-digit
    char-set:iso-control            char-set:letter
    char-set:letter+digit           char-set:lower-case
    char-set:printing               char-set:punctuation
    char-set:symbol                 char-set:title-case
    char-set:upper-case             char-set:whitespace
    char-set<=                      char-set=
    char-upcase                     char-upper-case?
    char-whitespace?                char<=?
    char<?                          char=?
    char>=?                         char>?
    char?                           circular-list
    circular-list?                  close-input-port
    close-output-port               close-port
    command-line                    comparator-check-type
    comparator-equality-predicate   comparator-hash
    comparator-hash-function        comparator-hashable?
    comparator-if<=>                comparator-ordered?
    comparator-ordering-predicate   comparator-register-default!
    comparator-test-type            comparator-type-test-predicate
    comparator?                     complex?
    concatenate                     concatenate!
    cond                            cond-expand
    cons                            cons*
    cos                             count
    current-error-port              current-input-port
    current-jiffy                   current-output-port
    current-second                  default-hash
    define                          define-record-type
    define-stream                   define-syntax
    define-values                   delay
    delay-force                     delete
    delete!                         delete-duplicates
    delete-duplicates!              delete-file
    denominator                     digit-value
    display                         do
    dotted-list?                    drop
    drop-right                      drop-right!
    drop-while                      dynamic-wind
    eighth                          else
    emergency-exit                  end-of-char-set?
    environment                     eof-object
    eof-object?                     ephemeron-broken?
    ephemeron-datum                 ephemeron-key
    ephemeron?                      eq?
    equal?                          eqv?
    error                           eval
    even?                           every
    exact                           exact-integer-sqrt
    exact-integer?                  exact?
    exit                            exp
    expt                            features
    fifth                           file-error?
    file-exists?                    filter
    filter!                         filter-map
    find                            find-tail
    finite?                         first
    floor                           floor-quotient
    floor-remainder                 floor/
    flush-output-port               fold
    fold-right                      for-each
    force                           fourth
    gappend                         gcd
    gcombine                        gcons*
    gdelete                         gdelete-neighbor-dups
    gdrop                           gdrop-while
    generator                       generator->ideque
    generator->list                 generator->lseq
    generator->reverse-list         generator->string
    generator->vector               generator->vector!
    generator-any                   generator-count
    generator-every                 generator-find
    generator-fold                  generator-for-each
    generator-unfold                get-environment-variable
    get-environment-variables       get-output-bytevector
    get-output-string               gfilter
    gindex                          gremove
    gselect                         gtake
    gtake-while                     gtree->itree
    gtree->tree                     guard
    hash                            hash-bound
    hash-by-identity                hash-salt
    hash-table                      hash-table->alist
    hash-table-clear!               hash-table-contains?
    hash-table-copy                 hash-table-count
    hash-table-delete!              hash-table-difference!
    hash-table-empty-copy           hash-table-empty?
    hash-table-entries              hash-table-equivalence-function
    hash-table-exists?              hash-table-find
    hash-table-fold                 hash-table-for-each
    hash-table-hash-function        hash-table-intern!
    hash-table-intersection!        hash-table-keys
    hash-table-map                  hash-table-map!
    hash-table-map->list            hash-table-merge!
    hash-table-mutable?             hash-table-pop!
    hash-table-prune!               hash-table-ref
    hash-table-ref/default          hash-table-set!
    hash-table-size                 hash-table-unfold
    hash-table-union!               hash-table-update!
    hash-table-update!/default      hash-table-values
    hash-table-walk                 hash-table-xor!
    hash-table=?                    hash-table?
    ideque                          ideque->generator
    ideque->list                    ideque-add-back
    ideque-add-front                ideque-any
    ideque-append                   ideque-append-map
    ideque-back                     ideque-break
    ideque-count                    ideque-drop
    ideque-drop-right               ideque-drop-while
    ideque-drop-while-right         ideque-empty?
    ideque-every                    ideque-filter
    ideque-filter-map               ideque-find
    ideque-find-right               ideque-fold
    ideque-fold-right               ideque-for-each
    ideque-for-each-right           ideque-front
    ideque-length                   ideque-map
    ideque-partition                ideque-ref
    ideque-remove                   ideque-remove-back
    ideque-remove-front             ideque-reverse
    ideque-span                     ideque-split-at
    ideque-tabulate                 ideque-take
    ideque-take-right               ideque-take-while
    ideque-take-while-right         ideque-unfold
    ideque-unfold-right             ideque-zip
    ideque=                         ideque?
    if                              ilist->list
    ilist-comparator                ilist-tail
    imag-part                       include
    include-ci                      inexact
    inexact?                        infinite?
    input-port-open?                input-port?
    integer->char                   integer?
    interaction-environment         iota
    ipair->pair                     ipair-comparator
    iq                              itree->tree
    jiffies-per-second              lambda
    last                            last-pair
    lcm                             length
    length+                         let
    let*                            let*-values
    let-syntax                      let-values
    letrec                          letrec*
    letrec-syntax                   list
    list->bag                       list->bag!
    list->char-set                  list->char-set!
    list->generator                 list->ideque
    list->ilist                     list->rlist
    list->set                       list->set
    list->set!                      list->set!
    list->stream                    list->string
    list->text                      list->vector
    list-copy                       list-delete-neighbor-dups
    list-delete-neighbor-dups!      list-index
    list-merge                      list-merge!
    list-queue                      list-queue-add-back!
    list-queue-add-front!           list-queue-append
    list-queue-append!              list-queue-back
    list-queue-concatenate          list-queue-copy
    list-queue-empty?               list-queue-first-last
    list-queue-for-each             list-queue-front
    list-queue-list                 list-queue-map
    list-queue-map!                 list-queue-remove-all!
    list-queue-remove-back!         list-queue-remove-front!
    list-queue-set-list!            list-queue-unfold
    list-queue-unfold-right         list-queue?
    list-ref                        list-set!
    list-sort                       list-sort!
    list-sorted?                    list-stable-sort
    list-stable-sort!               list-tabulate
    list-tail                       list=
    list?                           load
    log                             lseq->generator
    lseq-any                        lseq-append
    lseq-car                        lseq-cdr
    lseq-drop                       lseq-drop-while
    lseq-every                      lseq-filter
    lseq-find                       lseq-find-tail
    lseq-first                      lseq-for-each
    lseq-index                      lseq-length
    lseq-map                        lseq-member
    lseq-memq                       lseq-memv
    lseq-realize                    lseq-ref
    lseq-remove                     lseq-rest
    lseq-take                       lseq-take-while
    lseq-zip                        lseq=?
    lseq?                           lset-adjoin
    lset-diff+intersection          lset-diff+intersection!
    lset-difference                 lset-difference!
    lset-intersection               lset-intersection!
    lset-union                      lset-union!
    lset-xor                        lset-xor!
    lset<=                          lset=
    magnitude                       make-bytevector
    make-comparator                 make-coroutine-generator
    make-default-comparator         make-ephemeron
    make-eq-comparator              make-equal-comparator
    make-eqv-comparator             make-for-each-generator
    make-hash-table                 make-icar-comparator
    make-icdr-comparator            make-improper-ilist-comparator
    make-iota-generator             make-list
    make-list-comparator            make-list-queue
    make-pair-comparator            make-parameter
    make-polar                      make-promise
    make-range-generator            make-rectangular
    make-rlist                      make-string
    make-text                       make-unfold-generator
    make-vector                     make-vector-comparator
    map                             map!
    map-in-order                    max
    member                          memq
    memv                            min
    modulo                          nan?
    negative?                       newline
    ninth                           not
    not-ipair?                      not-pair?
    null-list?                      null?
    number->string                  number-hash
    number?                         numerator
    odd?                            open-binary-input-file
    open-binary-output-file         open-input-bytevector
    open-input-file                 open-input-string
    open-output-bytevector          open-output-file
    open-output-string              or
    output-port-open?               output-port?
    pair->ipair                     pair-fold
    pair-fold-right                 pair-for-each
    pair?                           parameterize
    partition                       partition!
    peek-char                       peek-u8
    port->stream                    port?
    positive?                       procedure?
    promise?                        proper-list?
    quasiquote                      quote
    quotient                        raise
    raise-continuable               rappend
    rational?                       rationalize
    rcaaaar                         rcaaadr
    rcaaar                          rcaadar
    rcaaddr                         rcaadr
    rcaar                           rcadaar
    rcadadr                         rcadar
    rcaddar                         rcadddr
    rcaddr                          rcadr
    rcar                            rcdaaar
    rcdaadr                         rcdaar
    rcdadar                         rcdaddr
    rcdadr                          rcdar
    rcddaar                         rcddadr
    rcddar                          rcdddar
    rcddddr                         rcdddr
    rcddr                           rcdr
    rcons                           read
    read-bytevector                 read-bytevector!
    read-char                       read-error?
    read-line                       read-string
    read-u8                         real-part
    real?                           reduce
    reduce-right                    remainder
    remove                          remove!
    replace-icar                    replace-icdr
    reverse                         reverse!
    reverse-list->text              reverse-list->vector
    reverse-vector->generator       reverse-vector->list
    rfor-each                       rlength
    rlist                           rlist->list
    rlist-ref                       rlist-ref/update
    rlist-set                       rlist-tail
    rlist?                          rmap
    rnull?                          round
    rpair?                          rquote
    rreverse                        second
    set                             set
    set!                            set->bag
    set->bag                        set->bag!
    set->bag!                       set->list
    set->list                       set-adjoin
    set-adjoin                      set-adjoin!
    set-adjoin!                     set-any?
    set-any?                        set-box!
    set-car!                        set-cdr!
    set-comparator                  set-comparator
    set-contains?                   set-contains?
    set-copy                        set-copy
    set-count                       set-count
    set-delete                      set-delete
    set-delete!                     set-delete!
    set-delete-all                  set-delete-all
    set-delete-all!                 set-delete-all!
    set-difference                  set-difference
    set-difference!                 set-difference!
    set-disjoint?                   set-disjoint?
    set-element-comparator          set-element-comparator
    set-empty?                      set-empty?
    set-every?                      set-every?
    set-filter                      set-filter
    set-filter!                     set-filter!
    set-find                        set-find
    set-fold                        set-fold
    set-for-each                    set-for-each
    set-intersection                set-intersection
    set-intersection!               set-intersection!
    set-map                         set-map
    set-member                      set-member
    set-partition                   set-partition
    set-partition!                  set-partition!
    set-remove                      set-remove
    set-remove!                     set-remove!
    set-replace                     set-replace
    set-replace!                    set-replace!
    set-search!                     set-search!
    set-size                        set-size
    set-unfold                      set-unfold
    set-union                       set-union
    set-union!                      set-union!
    set-xor                         set-xor
    set-xor!                        set-xor!
    set<=?                          set<=?
    set<?                           set<?
    set=?                           set=?
    set>=?                          set>=?
    set>?                           set>?
    set?                            set?
    seventh                         sin
    sixth                           span
    span!                           split-at
    split-at!                       sqrt
    square                          stream
    stream->list                    stream-append
    stream-car                      stream-cdr
    stream-concat                   stream-cons
    stream-constant                 stream-drop
    stream-drop-while               stream-filter
    stream-fold                     stream-for-each
    stream-from                     stream-iterate
    stream-lambda                   stream-length
    stream-let                      stream-map
    stream-match                    stream-null
    stream-null?                    stream-of
    stream-pair?                    stream-range
    stream-ref                      stream-reverse
    stream-scan                     stream-take
    stream-take-while               stream-unfold
    stream-unfolds                  stream-zip
    stream?                         string
    string->char-set                string->char-set!
    string->generator               string->list
    string->number                  string->symbol
    string->text                    string->utf8
    string->vector                  string-append
    string-ci-hash                  string-ci<=?
    string-ci<?                     string-ci=?
    string-ci>=?                    string-ci>?
    string-copy                     string-copy!
    string-downcase                 string-fill!
    string-foldcase                 string-for-each
    string-hash                     string-length
    string-map                      string-ref
    string-set!                     string-upcase
    string<=?                       string<?
    string=?                        string>=?
    string>?                        string?
    substring                       subtext
    subtextual                      symbol->string
    symbol-hash                     symbol=?
    symbol?                         syntax-error
    syntax-rules                    take
    take!                           take-right
    take-while                      take-while!
    tan                             tenth
    text                            text-length
    text-ref                        text-tabulate
    text-unfold                     text-unfold-right
    text?                           textual->list
    textual->string                 textual->text
    textual->utf16                  textual->utf16be
    textual->utf16le                textual->utf8
    textual->vector                 textual-any
    textual-append                  textual-ci<=?
    textual-ci<?                    textual-ci=?
    textual-ci>=?                   textual-ci>?
    textual-concatenate             textual-concatenate-reverse
    textual-contains                textual-contains-right
    textual-copy                    textual-count
    textual-downcase                textual-drop
    textual-drop-right              textual-every
    textual-filter                  textual-fold
    textual-fold-right              textual-foldcase
    textual-for-each                textual-for-each-index
    textual-index                   textual-index-right
    textual-join                    textual-length
    textual-map                     textual-map-index
    textual-null?                   textual-pad
    textual-pad-right               textual-port?
    textual-prefix-length           textual-prefix?
    textual-ref                     textual-remove
    textual-replace                 textual-replicate
    textual-skip                    textual-skip-right
    textual-split                   textual-suffix-length
    textual-suffix?                 textual-take
    textual-take-right              textual-titlecase
    textual-trim                    textual-trim-both
    textual-trim-right              textual-upcase
    textual<=?                      textual<?
    textual=?                       textual>=?
    textual>?                       textual?
    third                           tree->itree
    truncate                        truncate-quotient
    truncate-remainder              truncate/
    u8-ready?                       ucs-range->char-set
    ucs-range->char-set!            unbox
    unfold                          unfold-right
    unless                          unquote
    unquote-splicing                unzip1
    unzip2                          unzip3
    unzip4                          unzip5
    utf16->text                     utf16be->text
    utf16le->text                   utf8->string
    utf8->text                      values
    vector                          vector->generator
    vector->list                    vector->string
    vector->text                    vector-any
    vector-append                   vector-append-subvectors
    vector-binary-search            vector-concatenate
    vector-copy                     vector-copy!
    vector-count                    vector-cumulate
    vector-delete-neighbor-dups     vector-delete-neighbor-dups!
    vector-empty?                   vector-every
    vector-fill!                    vector-find-median
    vector-find-median!             vector-fold
    vector-fold-right               vector-for-each
    vector-index                    vector-index-right
    vector-length                   vector-map
    vector-map!                     vector-merge
    vector-merge!                   vector-partition
    vector-ref                      vector-reverse!
    vector-reverse-copy             vector-reverse-copy!
    vector-select!                  vector-separate!
    vector-set!                     vector-skip
    vector-skip-right               vector-sort
    vector-sort!                    vector-sorted?
    vector-stable-sort              vector-stable-sort!
    vector-swap!                    vector-unfold
    vector-unfold!                  vector-unfold-right
    vector-unfold-right!            vector=
    vector?                         when
    with-exception-handler          with-input-from-file
    with-output-to-file             write
    write-bytevector                write-char
    write-string                    write-u8
    xcons                           zero?
    zip
   ))

(define-library (scheme repl)
  (import (chibi))
  (export interaction-environment))

(define-library (scheme r5rs)
  (import
   (rename (scheme base)
           (exact inexact->exact)
           (inexact exact->inexact))
   (scheme cxr)
   (scheme char)
   (scheme inexact)
   (scheme complex)
   (scheme read)
   (scheme write)
   (scheme file)
   (scheme lazy)
   (scheme eval)
   (scheme repl)
   (scheme load)
   (only (chibi) null-environment scheme-report-environment))
  (export
   - ... * / + < <= = => > >= _ abs acos and angle append apply asin assoc assq
   assv atan begin boolean?
   caaaar caaadr caadar caaddr
   cadaar cadadr caddar cadddr
   cdaaar cdaadr cdadar cdaddr
   cddaar cddadr cdddar cddddr
   caaar caadr cadar caddr
   cdaar cdadr cddar cdddr
   caar cadr cdar cddr
   call-with-current-continuation call-with-input-file call-with-output-file
   call-with-values car case cdr ceiling char->integer char-alphabetic?
   char-ci<? char-ci<=? char-ci=? char-ci>? char-ci>=? char-downcase
   char-lower-case? char-numeric? char-ready? char-upcase
   char-upper-case? char-whitespace? char? char<? char<=? char=? char>?
   char>=? close-input-port close-output-port complex? cond cons cos
   current-input-port current-output-port define define-syntax delay
   denominator display do dynamic-wind else eof-object? eq? equal? eqv?
   eval even? exact->inexact exact? exp expt floor for-each force gcd if
   imag-part inexact->exact inexact? input-port? integer->char integer?
   interaction-environment lambda lcm length let let-syntax let* letrec
   letrec-syntax list list->string list->vector list-ref list-tail list?
   load log magnitude make-polar make-rectangular make-string make-vector
   map max member memq memv min modulo negative? newline not
   null-environment null? number->string number? numerator odd?
   open-input-file open-output-file or output-port? pair? peek-char
   positive? procedure? quasiquote quote quotient rational? rationalize
   read read-char real-part real? remainder reverse round
   scheme-report-environment set-car! set-cdr! set! sin sqrt string
   string->list string->number string->symbol string-append string-ci<?
   string-ci<=? string-ci=? string-ci>? string-ci>=? string-copy
   string-fill! string-length string-ref string-set! string? string<?
   string<=? string=? string>? string>=? substring symbol->string symbol?
   syntax-rules tan truncate values vector vector->list vector-fill!
   vector-length vector-ref vector-set! vector? with-input-from-file
   with-output-to-file write write-char zero?))

(define-library (scheme list) (alias-for (srfi 1)))
;; Copyright (c) 2012 Alan Watson. All rights reserved. BSD-style
;; license: http://synthcode.com/license.txt

;; This library implements TAI clocks with an epoch of 1970-01-01
;; 00:00:00 TAI.

(define-library (scheme time tai)
  
  (export make-tai-clock)
  
  (import (scheme base))
  (import (scheme time tai-to-utc-offset))
  
  (begin
    
    (define seconds-per-day (* 24.0 60.0 60.0))
    
    (define (make-tai-clock-from-tai-like-clock call-with-current-clock-values)
      (define (consumer second leap-second-indicator)
        second)
      (lambda ()
        (call-with-current-clock-values consumer)))
    
    (define (make-tai-clock-from-posix-like-clock call-with-current-clock-values)
      (define (consumer second leap-second-indicator)
        (+ second (tai-to-utc-offset-at-utc-day (/ second seconds-per-day))))
      (lambda ()
        (call-with-current-clock-values consumer)))
    
    (define (make-tai-clock-from-ntp-like-clock call-with-current-clock-values)
      (define (consumer second leap-second-indicator)
        (+ second
           (tai-to-utc-offset-at-utc-day (/ second seconds-per-day))
           (if leap-second-indicator 1.0 0.0)))
      (lambda ()
        (call-with-current-clock-values consumer)))
    
    ;; (make-tai-clock type call-with-current-clock-values)
    ;;
    ;; The make-tai-clock procedure returns a procedure that, when
    ;; called with no arguments, returns an estimate of the number of
    ;; TAI seconds since 1970-01-01 00:00:00 TAI.
    ;;
    ;; The type and call-with-current-clock-values argument should
    ;; conform to the descriptions in the documentation of the (clock
    ;; system-clock) library.
    
    (define (make-tai-clock type call-with-current-clock-values)
      (case type
        ((tai-like)
         (make-tai-clock-from-tai-like-clock call-with-current-clock-values))
        ((posix-like)
         (make-tai-clock-from-posix-like-clock call-with-current-clock-values))
        ((ntp-like)
         (make-tai-clock-from-ntp-like-clock call-with-current-clock-values))
        (else
         (error "invalid clock type" type))))))
;; Copyright (c) 2012 Alan Watson. All rights reserved. BSD-style
;; license: http://synthcode.com/license.txt

;; This library implements procedures that give the TAI to UTC offset a
;; specified instant in the UTC or TAI timescales.

(define-library (scheme time tai-to-utc-offset)
  
  (export tai-to-utc-offset-at-utc-day
          tai-to-utc-offset-at-tai-second
          set-open-leap-seconds-list-port!
          set-update-exception-handler!)
  
  (import (scheme base))
  (import (scheme file))
  (import (scheme read))
  (import (scheme process-context))
  
  (cond-expand
   (threads
    (import (srfi 18)))
   (else
    (begin
      (define (make-thread thunk name) #f)
      (define (thread-start! th) #f)
      (define (thread-sleep! secs) #f))))
  
  (cond-expand
   (chibi
    (begin
      (define *file-name-environment-variable* "SEXP_LEAP_SECONDS_LIST_FILE")))
   (else
    (begin
      (error "Need to define *file-name-environment-variable*."))))
  
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  
  (cond-expand
   
   ;; We ensure thread-safe atomic access to mutated bindings using
   ;; atomic boxes.
   
   (chibi
    (begin
      
      ;; This implementation relies on record accessors and mutators
      ;; being atomic in Chibi Scheme.
      
      (define-record-type atomic-box-record-type
        (make-atomic-box value)
        atomic-box?
        (value atomic-box-value atomic-box-value-set!))))
   
   (else
    (begin
      
      ;; This implementation uses SRFI-18 mutexes.
      
      (define (make-atomic-box value)
        (let ((mutex (make-mutex)))
          (mutex-specific-set! mutex value)
          mutex))
      
      (define atomic-box? mutex?)
      
      (define (atomic-box-value mutex)
        (mutex-lock! mutex)
        (let ((value (mutex-specific mutex)))
          (mutex-unlock! mutex)
          value))
      
      (define (atomic-box-value-set! mutex value)
        (mutex-lock! mutex)
        (mutex-specific-set! mutex value)
        (mutex-unlock! mutex)))))
  
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  
  (begin
    
    (define seconds-per-day 86400)
    
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    
    ;; First, a remark on timescales.
    ;;
    ;; The TAI timescale used in this library has an epoch of 1970-01-01
    ;; 00:00:00 TAI. The epoch used by the current-second procedure in
    ;; the draft R7RS (scheme time) library is the "TAI-10" timescale
    ;; with an epoch of 1970-01-01 00:00:10 TAI.
    
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    
    ;; The library maintains a cache of values derived from the leap
    ;; seconds list.
    ;;
    ;; The first cached value is the utc-day-alist. This is an alist
    ;; whose cars are the UTC days since 1970-01-01 00:00:00 UTC and
    ;; whose cdrs are the corresponding TAI to UTC offsets.
    ;;
    ;; The second cached value is the tai-second-alist. This is an alist
    ;; whose cars are the TAI seconds since 1970-01-01 00:00:00 TAI and
    ;; whose cdrs are the corresponding TAI to UTC offsets.
    
    (define-record-type cache-record-type
      (make-cache utc-day-alist tai-second-alist)
      cache?
      (utc-day-alist cache-utc-day-alist)
      (tai-second-alist cache-tai-second-alist))
    
    (define (make-cache-from-port port)
      (let ((utc-day-alist (read-leap-seconds-list port)))
        (make-cache utc-day-alist
                    (utc-day-alist->tai-second-alist utc-day-alist))))
    
    ;; The utc-day-alist->tai-second-alist procedure converts an alist
    ;; indexed by the number of UTC day since 1970-01-01 00:00:00 UTC
    ;; into an equivalent alist indexed by the number of TAI seconds
    ;; since 1970-01-01 00:00:00 TAI.
    ;;
    ;; This procedure does not have to worry about the complications of
    ;; transforming UTC dates prior to 1972-01-01 00:00:00 UTC to TAI,
    ;; since there were no leap seconds prior to this date.
    
    (define (utc-day-alist->tai-second-alist utc-day-alist)
      (map
       (lambda (p)
         (let* ((utc-day      (car p))
                (leap-seconds (cdr p))
                (tai-second   (+ (* utc-day seconds-per-day) leap-seconds)))
           (cons tai-second leap-seconds)))
       utc-day-alist))
    
    ;; The library updates the cache: when the library is loaded; when
    ;; the set-open-leap-seconds-list-port! is called; and once per day.
    ;; These automatic periodic updates are useful in long-running
    ;; programs.
    ;;
    ;; The choice of daily updates is motivated by the following
    ;; considerations. ITU-R TF.460-6, which contains the current
    ;; definition of UTC, requires that the IERS should announce leap
    ;; seconds with at least eight weeks in advance. However, NIST,
    ;; which maintains the leap-seconds.list file, only guarantees one
    ;; month. Recently the IERS and NIST have managed six months of
    ;; notice, but we should not rely on this.
    ;;
    ;; During updates, we install the update-exception-handler.
    
    (define *cache-lifetime* (* 1 seconds-per-day))
    
    (define (update-cache! open-port)
      (with-exception-handler
          (update-exception-handler)
        (lambda ()
          (let ((port (open-port)))
            (when port
              (set-cache! (make-cache-from-port port))
              (close-input-port port))))))
    
    (when (get-environment-variable *file-name-environment-variable*)
      (thread-start!
       (make-thread
        (lambda ()
          (let loop ()
            (thread-sleep! *cache-lifetime*)
            (update-cache! (open-leap-seconds-list-port))
            (loop)))
        "leap-second-update-poll")))
    
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    
    ;; The read-leap-seconds-list procedure reads text from the port
    ;; argument. The text must follow the format of a NIST leap seconds
    ;; file, for example,
    ;;
    ;;   ftp://time.nist.gov/pub/leap-seconds.list
    ;;
    ;; The procedure returns an alist. The cars of the pairs are the
    ;; number of whole UTC days since 1970-01-01 00:00:00 UTC and the
    ;; cdrs of the pairs are the corresponding TAI to UTC offset. The
    ;; alist is ordered by decreasing car. The cars and cdrs are exact
    ;; integers.
    ;;
    ;; TODO: Do not rely on the input file being correctly ordered. Do
    ;; not rely on the input data being exact integers.
    ;;
    ;; TODO: Check known leap seconds.
    
    (define (read-leap-seconds-list port)
      
      (define (ntp-second->utc-day ntp-second)
        ;; The NTP initial epoch is 1900-01-01 00:00:00 UTC. The UTC
        ;; initial epoch is 1970-01-01 00:00:00 UTC. There are 70 years,
        ;; containing 17 leap days, between these epochs.
        (- (quotient ntp-second seconds-per-day) (* 70 365) 17))
      
      (define (leap-seconds-line->pair line)
        (let* ((line-port         (open-input-string line))
               (ntp-second        (read line-port))
               (tai-to-utc-offset (read line-port))
               (utc-day           (ntp-second->utc-day ntp-second))
               (leap-seconds      tai-to-utc-offset))
          (cons utc-day leap-seconds)))
      
      (define (leap-seconds-comment-line? line)
        (char=? #\# (string-ref line 0)))
      
      (define (read-leap-seconds-line port)
        (let ((line (read-line port)))
          (cond
           ((eof-object? line) line)
           ((leap-seconds-comment-line? line) (read-leap-seconds-line port))
           (else line))))
      
      (let loop ((alist '()))
        (let ((line (read-leap-seconds-line port)))
          (if (eof-object? line)
            alist
            (loop (cons (leap-seconds-line->pair line) alist))))))
    
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    
    ;; (set-open-leap-seconds-list-port! p)
    ;;
    ;; The set-open-leap-seconds-list-port! procedure sets the value of
    ;; procedure called to obtain the leap second list is read to its
    ;; argument p and then performs a cache update. The procedure should
    ;; return either #f, signifying that no leap second list is
    ;; available, or an input port, from which a leap-second list,
    ;; following the format of the NIST leap-second list, will be read.
    ;; The NIST leap-second file can be found here:
    ;;
    ;;   ftp://time.nist.gov/pub/leap-seconds.list
    ;;
    ;; The default procedure attempts to open the file named by the
    ;; environment variable SEXP_LEAP_SECOND_LIST_FILE and returns the
    ;; port. If the environment variable is not set or if the file does
    ;; not exist, it return #f.
    
    (define *open-leap-seconds-list-port*
      (make-atomic-box
       (lambda ()
         (when *file-name-environment-variable*
           (let ((file-name
                  (get-environment-variable *file-name-environment-variable*)))
             (if file-name
                 (open-input-file file-name)
                 #f))))))
    
    (define (open-leap-seconds-list-port)
      (atomic-box-value *open-leap-seconds-list-port*))
    
    (define (set-open-leap-seconds-list-port! p)
      (atomic-box-value-set! *open-leap-seconds-list-port* p)
      (update-cache! (open-leap-seconds-list-port)))
    
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    
    ;; (set-update-exception-handler! p)
    ;;
    ;; The set-update-exception-handler! procedure sets the value of the
    ;; error handler installed during cache updates. The default error
    ;; handler simply raises the exception again.
    
    (define *update-exception-handler*
      (make-atomic-box raise))
    
    (define (update-exception-handler)
      (atomic-box-value *update-exception-handler*))
    
    (define (set-update-exception-handler! p)
      (atomic-box-value-set! *update-exception-handler* p))
    
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    
    (define *cache*
      (make-atomic-box #f))
    
    (define (cache)
      (atomic-box-value *cache*))
    
    (define (set-cache! value)
      (atomic-box-value-set! *cache* value))
    
    (update-cache!
     (lambda ()
       (open-input-string
        (string-append
         
         ;; These strings are lines extracted from:
         ;;
         ;;   ftp://time.nist.gov/pub/leap-seconds.3676924800
         ;;
         ;; The original file contains extensive comments on the format
         ;; and provenance of the data, which have been removed from
         ;; this version.
         
         "2272060800 10  # 1 Jan 1972\n"
         "2287785600 11  # 1 Jul 1972\n"
         "2303683200 12  # 1 Jan 1973\n"
         "2335219200 13  # 1 Jan 1974\n"
         "2366755200 14  # 1 Jan 1975\n"
         "2398291200 15  # 1 Jan 1976\n"
         "2429913600 16  # 1 Jan 1977\n"
         "2461449600 17  # 1 Jan 1978\n"
         "2492985600 18  # 1 Jan 1979\n"
         "2524521600 19  # 1 Jan 1980\n"
         "2571782400 20  # 1 Jul 1981\n"
         "2603318400 21  # 1 Jul 1982\n"
         "2634854400 22  # 1 Jul 1983\n"
         "2698012800 23  # 1 Jul 1985\n"
         "2776982400 24  # 1 Jan 1988\n"
         "2840140800 25  # 1 Jan 1990\n"
         "2871676800 26  # 1 Jan 1991\n"
         "2918937600 27  # 1 Jul 1992\n"
         "2950473600 28  # 1 Jul 1993\n"
         "2982009600 29  # 1 Jul 1994\n"
         "3029443200 30  # 1 Jan 1996\n"
         "3076704000 31  # 1 Jul 1997\n"
         "3124137600 32  # 1 Jan 1999\n"
         "3345062400 33  # 1 Jan 2006\n"
         "3439756800 34  # 1 Jan 2009\n"
         "3550089600 35  # 1 Jul 2012\n"
         "3644697600 36  # 1 Jul 2015\n"
         "3692217600 37  # 1 Jan 2017\n"))))
    
    (update-cache! (open-leap-seconds-list-port))
    
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    
    ;; (tai-to-utc-offset-at-utc-day utc-day)
    ;;
    ;; The tai-to-utc-offset-at-utc-day procedure returns the TAI to UTC
    ;; offset at the instant specified by its argument utc-day. The
    ;; instant is specified by the number of UTC days since 1970-01-01
    ;; 00:00:00 UTC.
    ;;
    ;; To convert a UTC time since 1972-01-01 00:00:00 UTC to number of
    ;; TAI seconds since 1972-01-01 00:00:00 TAI, first find the number
    ;; of whole UTC days D since 1970-01-01 00:00:00 UTC and the number
    ;; of UTC seconds S since the start of the current day. The number
    ;; of TAI seconds since 1972-01-01 00:00:00 TAI is then
    ;;
    ;;   (+ (* D 86400) S (tai-to-utc-offset-at-utc-day D))
    ;;
    ;; This implementation does not return the correct result for
    ;; instants prior to 1972-01-01 00:00:00 UTC.
    ;;
    ;; Converting a UTC time prior to 1972-01-01 00:00:00 UTC to TAI is
    ;; more involved, since prior to this date UTC and TAI seconds were
    ;; not equal. See,
    ;;
    ;;   http://hpiers.obspm.fr/eop-pc/index.php?index=TAI-UTC_tab
    
    (define (tai-to-utc-offset-at-utc-day-loop utc-day alist)
      (cond ((null? alist) 10)
            ((>= utc-day (caar alist)) (cdar alist))
            (else (tai-to-utc-offset-at-utc-day-loop utc-day (cdr alist)))))
    
    (define (tai-to-utc-offset-at-utc-day utc-day)
      (tai-to-utc-offset-at-utc-day-loop
       utc-day
       (cache-utc-day-alist (cache))))
    
    ;; (tai-to-utc-offset-at-tai-second tai-second)
    ;;
    ;; The tai-to-utc-offset-at-tai-second procedure returns TAI to UTC
    ;; offset at the instant specified by its argument tai-second. The
    ;; instant is specified by the number of TAI seconds since
    ;; 1970-01-01 00:00:00 TAI.
    ;;
    ;; This implementation does not return the correct result for
    ;; instants prior to 1972-01-01 00:00:00 UTC.
    
    (define (tai-to-utc-offset-at-tai-second-loop tai-second alist)
      (cond
       ((null? alist) 10)
       ((>= tai-second (caar alist)) (cdar alist))
       (else (tai-to-utc-offset-at-tai-second-loop tai-second (cdr alist)))))
    
    (define (tai-to-utc-offset-at-tai-second tai-second)
      (tai-to-utc-offset-at-tai-second-loop
       tai-second
       (cache-tai-second-alist (cache))))))

(define-library (scheme lseq) (alias-for (srfi 127)))

(define-syntax define-values
  (syntax-rules ()
    ((define-values () expr)
     (define dummy
       (call-with-values (lambda () expr)
         (lambda args #f))))
    ((define-values (var) expr)
     (define var expr))
    ((define-values (var0 var1 ... varn) expr)
     (begin
       (define var0
         (call-with-values (lambda () expr) list))
       (define var1
         (let ((v (cadr var0)))
           (set-cdr! var0 (cddr var0))
           v))
       ...
       (define varn
         (let ((v (cadr var0)))
           (set! var0 (car var0))
           v))))
    ((define-values (var0 var1 ... . var-dot) expr)
     (begin
       (define var0
         (call-with-values (lambda () expr) list))
       (define var1
         (let ((v (cadr var0)))
           (set-cdr! var0 (cddr var0))
           v))
       ...
       (define var-dot
         (let ((v (cdr var0)))
           (set! var0 (car var0))
           v))))
    ((define-values var expr)
     (define var
       (call-with-values (lambda () expr) list)))))

(define-library (scheme generator) (alias-for (srfi 121)))

(define-library (scheme mapping hash) (alias-for (srfi 146 hash)))

(define-library (scheme cxr)
  (import (chibi))
  (export
   caaar caadr cadar caddr cdaar cdadr cddar cdddr
   caaaar caaadr caadar caaddr cadaar cadadr caddar cadddr
   cdaaar cdaadr cdadar cdaddr cddaar cddadr cdddar cddddr)
  (include "cxr.scm"))

(define-library (scheme rlist)
  (import (srfi 101))
  (export (rename quote rquote)
          (rename pair? rpair?)
          (rename cons rcons)
          (rename car rcar)
          (rename cdr rcdr)
          (rename caar rcaar)
          (rename cadr rcadr)
          (rename cddr rcddr)
          (rename cdar rcdar)
          (rename caaar rcaaar)
          (rename caadr rcaadr)
          (rename caddr rcaddr)
          (rename cadar rcadar)
          (rename cdaar rcdaar)
          (rename cdadr rcdadr)
          (rename cdddr rcdddr)
          (rename cddar rcddar)
          (rename caaaar rcaaaar)
          (rename caaadr rcaaadr)
          (rename caaddr rcaaddr)
          (rename caadar rcaadar)
          (rename cadaar rcadaar)
          (rename cadadr rcadadr)
          (rename cadddr rcadddr)
          (rename caddar rcaddar)
          (rename cdaaar rcdaaar)
          (rename cdaadr rcdaadr)
          (rename cdaddr rcdaddr)
          (rename cdadar rcdadar)
          (rename cddaar rcddaar)
          (rename cddadr rcddadr)
          (rename cddddr rcddddr)
          (rename cdddar rcdddar)
          (rename null? rnull?)
          (rename list? rlist?)
          (rename list rlist)
          (rename make-list make-rlist)
          (rename length rlength)
          (rename length<=? rlength<=?)
          (rename append rappend)
          (rename reverse rreverse)
          (rename list-tail rlist-tail)
          (rename list-ref rlist-ref)
          (rename list-set rlist-set)
          (rename list-ref/update rlist-ref/update)
          (rename map rmap)
          (rename for-each rfor-each)
          (rename random-access-list->linear-access-list
                  rlist->list)
          (rename linear-access-list->random-access-list
                  list->rlist)))

(define (read-sexps file . o)
  (let ((in (open-input-file file)))
    (if (and (pair? o) (car o))
        (set-port-fold-case! in #t))
    (let lp ((res '()))
      (let ((x (read in)))
        (if (eof-object? x)
            (reverse res)
            (lp (cons x res)))))))

(define current-includes
  '())

(define-syntax push-includes!
  (er-macro-transformer
   (lambda (expr rename compare)
     (set! current-includes (cons (cadr expr) current-includes))
     #f)))

(define-syntax pop-includes!
  (er-macro-transformer
   (lambda (expr rename compare)
     (set! current-includes (cdr current-includes))
     #f)))

(define-syntax include/aux
  (er-macro-transformer
   (lambda (expr rename compare)
     (let ((ci? (cadr expr)))
       (let lp ((files (cddr expr)) (res '()))
         (cond
          ((null? files)
           (cons (rename 'begin) (reverse res)))
          ((not (string? (car files)))
           (error "include requires a string"))
          ((member (car files) current-includes)
           (error "recursive include" (car files)))
          (else
           (let ((includes current-includes))
             (lp (cdr files)
                 (cons `(,(rename 'begin)
                         (,(rename 'push-includes!) ,(car files))
                         ,@(read-sexps (car files) ci?)
                         (,(rename 'pop-includes!)))
                       res))))))))))

(define-syntax include
  (syntax-rules ()
    ((include file ...)
     (include/aux #f file ...))))

(define-syntax include-ci
  (syntax-rules ()
    ((include file ...)
     (include/aux #t file ...))))

(define (read-error? x)
  (and (error-object? x) (memq (exception-kind x) '(read read-incomplete)) #t))

(define (file-error? x)
  (and (error-object? x) (eq? 'file (exception-kind x))))

(define (features) *features*)

(define exact inexact->exact)
(define inexact exact->inexact)

(define (boolean=? x y . o)
  (if (not (boolean? x))
      (error "not a boolean" x)
      (and (eq? x y) (if (pair? o) (apply boolean=? y o) #t))))
(define (symbol=? x y . o)
  (if (not (symbol? x))
      (error "not a symbol" x)
      (and (eq? x y) (if (pair? o) (apply symbol=? y o) #t))))

(define call/cc call-with-current-continuation)

(define truncate-quotient quotient)
(define truncate-remainder remainder)
(define (truncate/ n m)
  (values (truncate-quotient n m) (truncate-remainder n m)))

(define (floor-quotient n m)
  (let ((res (floor (/ n m))))
    (if (and (exact? n) (exact? m))
        (inexact->exact res)
        res)))
(define (floor-remainder n m)
  (- n (* m (floor-quotient n m))))
(define (floor/ n m)
  (values (floor-quotient n m) (floor-remainder n m)))

(define (exact-integer-sqrt x)
  (let ((res (exact-sqrt x)))
    (values (car res) (cdr res))))

;; Adapted from Bawden's algorithm.
(define (rationalize x e)
  (define (sr x y return)
    (let ((fx (floor x)) (fy (floor y)))
      (cond
       ((>= fx x)
        (return fx 1))
       ((= fx fy)
        (sr (/ (- y fy)) (/ (- x fx)) (lambda (n d) (return (+ d (* fx n)) n))))
       (else
        (return (+ fx 1) 1)))))
  (let ((return (if (negative? x) (lambda (num den) (/ (- num) den)) /))
        (x (abs x))
        (e (abs e)))
    (sr (- x e) (+ x e) return)))

(define (square x) (* x x))

(define flush-output-port flush-output)

(define input-port-open? port-open?)
(define output-port-open? port-open?)

(define (close-port port)
  ((if (input-port? port) close-input-port close-output-port) port))

(define (u8-ready? port) (char-ready? port))

(define (call-with-port port proc)
  (let ((res (proc port)))
    (close-port port)
    res))

(define (eof-object) (read-char (open-input-string "")))

(define (read-bytevector n . o)
  (if (zero? n)
      #u8()
      (let ((in (if (pair? o) (car o) (current-input-port)))
            (res (make-bytevector n)))
        (let lp ((i 0))
          (if (>= i n)
              res
              (let ((x (read-u8 in)))
                (cond ((eof-object? x)
                       (if (zero? i) x (subbytes res 0 i)))
                      (else
                       (bytevector-u8-set! res i x)
                       (lp (+ i 1))))))))))

(define (read-bytevector! vec . o)
  (let* ((in (if (pair? o) (car o) (current-input-port)))
         (o (if (pair? o) (cdr o) o))
         (start (if (pair? o) (car o) 0))
         (end (if (and (pair? o) (pair? (cdr o)))
                  (cadr o)
                  (bytevector-length vec))))
    (if (>= start end)
        0
        (let ((res (read-bytevector (- end start) in)))
          (cond
           ((eof-object? res)
            res)
           (else
            (let ((len (bytevector-length res)))
              (do ((i 0 (+ i 1)))
                  ((>= i len) len)
                (bytevector-u8-set! vec (+ i start) (bytevector-u8-ref res i))
                ))))))))

(define (write-bytevector vec . o)
  (let* ((out (if (pair? o) (car o) (current-output-port)))
         (o (if (pair? o) (cdr o) '()))
         (start (if (pair? o) (car o) 0))
         (o (if (pair? o) (cdr o) '()))
         (end (if (pair? o) (car o) (bytevector-length vec))))
    (do ((i start (+ i 1)))
        ((>= i end))
      (write-u8 (bytevector-u8-ref vec i) out))))

(define (list-set! ls k x)
  (cond ((null? ls) (error "invalid list index"))
        ((zero? k) (set-car! ls x))
        (else (list-set! (cdr ls) (- k 1) x))))

(define (vector-append . vecs)
  (let* ((len (apply + (map vector-length vecs)))
         (res (make-vector len)))
    (let lp ((ls vecs) (i 0))
      (if (null? ls)
          res
          (let ((v-len (vector-length (car ls))))
            (vector-copy! res i (car ls))
            (lp (cdr ls) (+ i v-len)))))))

(define (vector-map proc vec . lov)
  (if (null? lov)
      (let lp ((i (vector-length vec)) (res '()))
        (if (zero? i)
            (list->vector res)
            (lp (- i 1) (cons (proc (vector-ref vec (- i 1))) res))))
      (list->vector (apply map proc (map vector->list (cons vec lov))))))

(define (vector-for-each proc vec . lov)
  (if (null? lov)
      (let ((len (vector-length vec)))
        (let lp ((i 0))
          (cond ((< i len)
                 (proc (vector-ref vec i))
                 (lp (+ i 1))))))
      (apply for-each proc (map vector->list (cons vec lov)))))

(define (vector-copy! to at from . o)
  (let* ((start (if (pair? o) (car o) 0))
         (end (if (and (pair? o) (pair? (cdr o))) (cadr o) (vector-length from)))
         (limit (min end (+ start (- (vector-length to) at)))))
    (if (<= at start)
        (do ((i at (+ i 1)) (j start (+ j 1)))
            ((>= j limit))
          (vector-set! to i (vector-ref from j)))
        (do ((i (+ at (- end start 1)) (- i 1)) (j (- limit 1) (- j 1)))
            ((< j start))
          (vector-set! to i (vector-ref from j))))))

(define (vector->string vec . o)
  (list->string (apply vector->list vec o)))

(define (string->vector vec . o)
  (list->vector (apply string->list vec o)))

(define (bytevector . args)
  (let* ((len (length args))
         (res (make-bytevector len)))
    (do ((i 0 (+ i 1)) (ls args (cdr ls)))
        ((null? ls) res)
      (bytevector-u8-set! res i (car ls)))))

(define (bytevector-copy! to at from . o)
  (let* ((start (if (pair? o) (car o) 0))
         (end (if (and (pair? o) (pair? (cdr o)))
                  (cadr o)
                  (bytevector-length from)))
         (limit (min end (+ start (- (bytevector-length to) at)))))
    (if (<= at start)
        (do ((i at (+ i 1)) (j start (+ j 1)))
            ((>= j limit))
          (bytevector-u8-set! to i (bytevector-u8-ref from j)))
        (do ((i (+ at (- end start 1)) (- i 1)) (j (- limit 1) (- j 1)))
            ((< j start))
          (bytevector-u8-set! to i (bytevector-u8-ref from j))))))

(define (bytevector-copy vec . o)
  (if (null? o)
      (subbytes vec 0)
      (apply subbytes vec o)))

(define (bytevector-append . vecs)
  (let* ((len (apply + (map bytevector-length vecs)))
         (res (make-bytevector len)))
    (let lp ((ls vecs) (i 0))
      (if (null? ls)
          res
          (let ((v-len (bytevector-length (car ls))))
            (bytevector-copy! res i (car ls))
            (lp (cdr ls) (+ i v-len)))))))

;; Never use this!
(define (string-copy! to at from . o)
  (let* ((start (if (pair? o) (car o) 0))
         (end (if (and (pair? o) (pair? (cdr o))) (cadr o) (string-length from)))
         (limit (min end (+ start (- (string-length to) at)))))
    (if (<= at start)
        (do ((i at (+ i 1)) (j start (+ j 1)))
            ((>= j limit))
          (string-set! to i (string-ref from j)))
        (do ((i (+ at (- end start 1)) (- i 1)) (j (- limit 1) (- j 1)))
            ((< j start))
          (string-set! to i (string-ref from j))))))

(define truncate-quotient quotient)
(define truncate-remainder remainder)
(define (truncate/ n m)
  (values (truncate-quotient n m) (truncate-remainder n m)))

(cond-expand
 (ratios
  (define (floor-quotient n m)
    (floor (/ n m))))
 (else
  (define (floor-quotient n m)
    (let ((res (floor (/ n m))))
      (if (and (exact? n) (exact? m))
          (exact res)
          res)))))
(define (floor-remainder n m)
  (- n (* m (floor-quotient n m))))
(define (floor/ n m)
  (values (floor-quotient n m) (floor-remainder n m)))

(define-library (scheme stream) (alias-for (srfi 41)))

(define-library (scheme inexact)
  (import (chibi))
  (export acos asin atan cos exp finite? infinite? log nan? sin sqrt tan)
  (include "inexact.scm"))

(define-library (scheme ideque) (alias-for (srfi 134)))

(define-library (scheme comparator) (alias-for (srfi 128)))
(define-library (scheme small)
  (import (scheme base) (scheme char) (scheme complex) (scheme cxr)
          (scheme eval) (scheme file) (scheme inexact) (scheme lazy)
          (scheme load) (scheme process-context) (scheme read)
          (scheme repl) (scheme time) (scheme write))
  (export
   ;; base
   * + - ... / < <= = => > >= _ abs and append apply assoc assq assv begin
   binary-port?  boolean?  boolean=?  bytevector bytevector-append
   bytevector-copy bytevector-copy! bytevector-length
   bytevector-u8-ref bytevector-u8-set!  bytevector?  caar cadr
   call-with-current-continuation call-with-port call-with-values
   call/cc car case cdr cdar cddr ceiling char->integer
   char-ready? char<=?  char<?  char=?  char>=?  char>?  char?
   close-input-port close-output-port close-port complex?  cond cond-expand
   cons current-error-port current-input-port current-output-port define
   define-record-type define-syntax define-values denominator do
   dynamic-wind else eof-object? eof-object  eq?  equal?  eqv?  error
   error-object-irritants error-object-message error-object?  even?
   exact exact-integer-sqrt exact-integer?  exact?  expt features
   file-error? floor
   flush-output-port for-each gcd get-output-bytevector get-output-string
   guard if include include-ci inexact inexact?  input-port?
   integer->char
   integer?  lambda lcm length let let* let*-values let-syntax let-values
   letrec letrec* letrec-syntax list list->string list->vector list-copy
   list-ref list-set!  list-tail list?  make-bytevector make-list
   make-parameter make-string make-vector map max member memq memv min
   modulo negative?  newline not null?  number->string number?  numerator
   odd?  open-input-bytevector open-input-string open-output-bytevector
   open-output-string or output-port?  pair?  parameterize peek-char
   peek-u8 input-port-open? output-port-open?  port?  positive?
   procedure?  quasiquote quote
   quotient raise raise-continuable rational?  rationalize read-bytevector
   read-bytevector!  read-char read-error? read-line read-string read-u8
   real?  remainder
   reverse round set!  set-car!  set-cdr!  square string string->list
   string->number string->symbol string->utf8 string->vector string-append
   string-copy string-copy! string-fill!  string-for-each string-length
   string-map
   string-ref string-set!  string<=?  string<?  string=?  string>=?
   string>?  string?  substring symbol->string symbol?  symbol=?  syntax-error
   syntax-rules textual-port?  truncate u8-ready?  unless unquote
   unquote-splicing utf8->string values vector vector-append
   vector->list vector->string
   vector-copy vector-copy! vector-fill!  vector-for-each vector-length
   vector-map vector-ref vector-set!  vector?  when with-exception-handler
   write-bytevector write-char write-string write-u8 zero?
   truncate-quotient truncate-remainder truncate/
   floor-quotient floor-remainder floor/
   ;; char
   char-alphabetic? char-ci<=? char-ci<? char-ci=? char-ci>=? char-ci>?
   char-downcase char-foldcase char-lower-case? char-numeric?
   char-upcase char-upper-case? char-whitespace? digit-value
   string-ci<=? string-ci<? string-ci=? string-ci>=? string-ci>?
   string-downcase string-foldcase string-upcase
   ;; complex
   angle imag-part magnitude make-polar make-rectangular real-part
   ;; cxr
   caaar caadr cadar caddr cdaar cdadr cddar cdddr
   caaaar caaadr caadar caaddr cadaar cadadr caddar cadddr
   cdaaar cdaadr cdadar cdaddr cddaar cddadr cdddar cddddr
   ;; eval
   eval environment
   ;; file
   call-with-input-file call-with-output-file
   delete-file file-exists?
   open-binary-input-file open-binary-output-file
   open-input-file open-output-file
   with-input-from-file with-output-to-file
   ;; inexact
   acos asin atan cos exp finite? infinite? log nan? sin sqrt tan
   ;; lazy
   delay force delay-force make-promise promise?
   ;; load
   load
   ;; process-context
   get-environment-variable get-environment-variables
   command-line exit emergency-exit
   ;; read
   read
   ;; repl
   interaction-environment
   ;; time
   current-second current-jiffy jiffies-per-second
   ;; write
   display write write-shared write-simple
   ))

(define-library (scheme eval)
  (import (chibi) (meta)) ; (chibi compiler analyze)
  (export eval environment))

(define-library (scheme file)
  (import (chibi) (only (chibi filesystem) delete-file file-exists?))
  (export
   call-with-input-file call-with-output-file
   delete-file file-exists?
   open-binary-input-file open-binary-output-file
   open-input-file open-output-file
   with-input-from-file with-output-to-file))

(define-library (scheme box) (alias-for (srfi 111)))

(define-library (scheme char)
  (import (scheme base))
  (cond-expand
   (full-unicode
    (import (chibi char-set full)
            (chibi char-set base)
            (chibi iset base))
    (include "char/full.scm")
    (include "char/special-casing.scm")
    (include "char/case-offsets.scm"))
   (else
    (include "char/ascii.scm")
    (import
     (only (chibi)
           string-ci<=? string-ci<? string-ci=? string-ci>=? string-ci>?
           char-ci<=? char-ci<? char-ci=? char-ci>=? char-ci>?
           char-alphabetic?  char-lower-case? char-numeric?
           char-upper-case? char-whitespace? digit-value
           char-upcase char-downcase))))
  (include "digit-value.scm")
  (export
   char-alphabetic? char-ci<=? char-ci<? char-ci=? char-ci>=? char-ci>?
   char-downcase char-foldcase char-lower-case? char-numeric?
   char-upcase char-upper-case? char-whitespace? digit-value
   string-ci<=? string-ci<? string-ci=? string-ci>=? string-ci>?
   char-get-special-case
   string-downcase string-foldcase string-upcase))

(cond-expand
 (full-unicode
  (define zeros
    '#(#\x0030                ;DIGIT ZERO
       #\x0660                ;ARABIC-INDIC DIGIT ZERO
       #\x06F0                ;EXTENDED ARABIC-INDIC DIGIT ZERO
       #\x07C0                ;NKO DIGIT ZERO
       #\x0966                ;DEVANAGARI DIGIT ZERO
       #\x09E6                ;BENGALI DIGIT ZERO
       #\x0A66                ;GURMUKHI DIGIT ZERO
       #\x0AE6                ;GUJARATI DIGIT ZERO
       #\x0B66                ;ORIYA DIGIT ZERO
       #\x0BE6                ;TAMIL DIGIT ZERO
       #\x0C66                ;TELUGU DIGIT ZERO
       #\x0CE6                ;KANNADA DIGIT ZERO
       #\x0D66                ;MALAYALAM DIGIT ZERO
       #\x0E50                ;THAI DIGIT ZERO
       #\x0ED0                ;LAO DIGIT ZERO
       #\x0F20                ;TIBETAN DIGIT ZERO
       #\x1040                ;MYANMAR DIGIT ZERO
       #\x1090                ;MYANMAR SHAN DIGIT ZERO
       #\x17E0                ;KHMER DIGIT ZERO
       #\x1810                ;MONGOLIAN DIGIT ZERO
       #\x1946                ;LIMBU DIGIT ZERO
       #\x19D0                ;NEW TAI LUE DIGIT ZERO
       #\x1A80                ;TAI THAM HORA DIGIT ZERO
       #\x1A90                ;TAI THAM THAM DIGIT ZERO
       #\x1B50                ;BALINESE DIGIT ZERO
       #\x1BB0                ;SUNDANESE DIGIT ZERO
       #\x1C40                ;LEPCHA DIGIT ZERO
       #\x1C50                ;OL CHIKI DIGIT ZERO
       #\xA620                ;VAI DIGIT ZERO
       #\xA8D0                ;SAURASHTRA DIGIT ZERO
       #\xA900                ;KAYAH LI DIGIT ZERO
       #\xA9D0                ;JAVANESE DIGIT ZERO
       #\xAA50                ;CHAM DIGIT ZERO
       #\xABF0                ;MEETEI MAYEK DIGIT ZERO
       #\xFF10                ;FULLWIDTH DIGIT ZERO
       #\x104A0               ;OSMANYA DIGIT ZERO
       #\x11066               ;BRAHMI DIGIT ZERO
       #\x1D7CE               ;MATHEMATICAL BOLD DIGIT ZERO
       #\x1D7D8               ;MATHEMATICAL DOUBLE-STRUCK DIGIT ZERO
       #\x1D7E2               ;MATHEMATICAL SANS-SERIF DIGIT ZERO
       #\x1D7EC               ;MATHEMATICAL SANS-SERIF BOLD DIGIT ZERO
       #\x1D7F6               ;MATHEMATICAL MONOSPACE DIGIT ZERO
       )))
 (else
  (define zeros #(#\0))))

(define (digit-value ch)
  (let ((n (char->integer ch)))
    (let lp ((lo 0) (hi (- (vector-length zeros) 1)))
      (if (> lo hi)
          #f
          (let* ((mid (+ lo (quotient (- hi lo) 2)))
                 (mid-zero (char->integer (vector-ref zeros mid))))
            (cond
             ((<= mid-zero n (+ mid-zero 9))
              (- n mid-zero))
             ((< n mid-zero)
              (lp lo (- mid 1)))
             (else
              (lp (+ mid 1) hi))))))))

(define-library (scheme complex)
  (import (chibi))
  (export angle imag-part magnitude make-polar make-rectangular real-part))

;; adapted from guile bytevectors.test by Ludovic Courts

(define-library (scheme bytevector-test)
  (import (except (scheme base) bytevector-copy!)
          (scheme bytevector)
          (scheme list)
          (chibi test))
  (export run-tests)
  (begin
    (define (run-tests)
      (test-begin "scheme bytevector")
      ;; (test 258 (bytevector-uint-ref #u8(0 1 2 0) 1 (endianness big) 2))
      ;; (test 513 (bytevector-uint-ref #u8(0 1 2 0) 1 (endianness little) 2))
      ;; (test -65281
      ;;     (bytevector-sint-ref #u8(0 #xFF 1 0) 1 (endianness big) 2))
      ;; (test -65281
      ;;     (bytevector-sint-ref #u8(0 1 #xFF 0) 1 (endianness little) 2))
      (test-begin "2.2 General Operations")
      (test-assert "native-endianness"
        (not (not (memq (native-endianness) '(big little)))))

      (test-assert "make-bytevector"
        (and (bytevector? (make-bytevector 20))
             (bytevector? (make-bytevector 20 3))))

      (test-assert "bytevector-length"
        (= (bytevector-length (make-bytevector 20)) 20))

      (test-assert "bytevector=?"
        (and (bytevector=? (make-bytevector 20 7)
                           (make-bytevector 20 7))
             (not (bytevector=? (make-bytevector 20 7)
                                (make-bytevector 20 0)))))

      (test "bytevector-fill! with fill 255"
          #u8(255 255 255 255)
          (let ((bv (make-bytevector 4)))
            (bytevector-fill! bv 255)
            bv))

      (test "bytevector-copy! overlapping"
          #u8(1 2 3 1 2 3 4 8)
          (let ((b (u8-list->bytevector '(1 2 3 4 5 6 7 8))))
            (bytevector-copy! b 0 b 3 4)
            b))
      (test-end)

      (test-begin "2.3 Operations on Bytes and Octets")

      (test "bytevector-{u8,s8}-ref"
          '(-127 129 -1 255)
        (let ((b1 (make-bytevector 16 -127))
              (b2 (make-bytevector 16 255)))
          (list (bytevector-s8-ref b1 0)
                (bytevector-u8-ref b1 0)
                (bytevector-s8-ref b2 0)
                (bytevector-u8-ref b2 0))))

      (test "bytevector-{u8,s8}-set!"
          '(-126 130 -10 246)
        (let ((b (make-bytevector 16 -127)))
          (bytevector-s8-set! b 0 -126)
          (bytevector-u8-set! b 1 246)
          (list (bytevector-s8-ref b 0)
                (bytevector-u8-ref b 0)
                (bytevector-s8-ref b 1)
                (bytevector-u8-ref b 1))))

      (test-assert "bytevector->u8-list"
        (let ((lst '(1 2 3 128 150 255)))
          (equal? lst
                  (bytevector->u8-list
                   (let ((b (make-bytevector 6)))
                     (for-each (lambda (i v)
                                 (bytevector-u8-set! b i v))
                               (iota 6)
                               lst)
                     b)))))

      (test-assert "u8-list->bytevector"
        (let ((lst '(1 2 3 128 150 255)))
          (equal? lst
                  (bytevector->u8-list (u8-list->bytevector lst)))))

      (test-error "u8-list->bytevector [invalid argument type]"
                  (u8-list->bytevector 'not-a-list))

      (test-error "u8-list->bytevector [circular list]"
                  (u8-list->bytevector (circular-list 1 2 3)))

      (test "bytevector-uint-{ref,set!} [small]"
          #x3412
        (let ((b (make-bytevector 15)))
          (bytevector-uint-set! b 0 #x1234 (endianness little) 2)
          (bytevector-uint-ref b 0 (endianness big) 2)))

      (test "bytevector-uint-set! [large]"
          '(253 255 255 255 255 255 255 255
                255 255 255 255 255 255 255 255)
        (let ((b (make-bytevector 16)))
          (bytevector-uint-set! b 0 (- (expt 2 128) 3) (endianness little) 16)
          (bytevector->u8-list b)))

      (test "bytevector-uint-{ref,set!} [large]"
          #xfffffffffffffffffffffffffffffffd
        (let ((b (make-bytevector 120)))
          (bytevector-uint-set! b 0 (- (expt 2 128) 3)
                                (endianness little) 16)
          (bytevector-uint-ref b 0 (endianness little) 16)))

      (test "bytevector-sint-ref big [small]"
          -16
        (let ((b (u8-list->bytevector '(#xff #xf0 #xff))))
          (bytevector-sint-ref b 0 (endianness big) 2)))

      (test "bytevector-sint-ref little [small]"
          -16
        (let ((b (u8-list->bytevector '(#xff #xf0 #xff))))
          (bytevector-sint-ref b 1 (endianness little) 2)))

      (test "bytevector-sint-ref [large]"
          -3
        (let ((b (make-bytevector 50)))
          (bytevector-uint-set! b 0 (- (expt 2 128) 3) (endianness little) 16)
          (bytevector-sint-ref b 0 (endianness little) 16)))

      (test "bytevector-sint-set! [small]"
          '(#xff #xf0 #xff)
        (let ((b (make-bytevector 3)))
          (bytevector-sint-set! b 0 -16 (endianness big) 2)
          (bytevector-sint-set! b 1 -16 (endianness little) 2)
          (bytevector->u8-list b)))

      (test-assert "equal?"
        (let ((bv1 (u8-list->bytevector (iota 123)))
              (bv2 (u8-list->bytevector (iota 123))))
          (equal? bv1 bv2)))
      (test-end)

      (test-begin "2.4 Operations on Integers of Arbitrary Size")

      (test '(513 -253 513 513)
          (bytevector->sint-list #u8(1 2 3 255 1 2 1 2) (endianness little) 2))

      (test "bytevector->uint-list"
          '(513 65283 513 513)
        (let ((b (u8-list->bytevector '(2 1 255 3 2 1 2 1))))
          (bytevector->uint-list b (endianness big) 2)))

      (test "bytevector->uint-list [empty]"
          '()
        (let ((b (make-bytevector 0)))
          (bytevector->uint-list b (endianness big) 2)))

      (test-error "bytevector->sint-list [out-of-range]"
                  (bytevector->sint-list (make-bytevector 6) (endianness little) -1))

      (test-error "bytevector->uint-list [out-of-range]"
                  (bytevector->uint-list (make-bytevector 6) (endianness little) 0))

      (test-error "bytevector->uint-list [word size doesn't divide length]"
                  (bytevector->uint-list (make-bytevector 6) (endianness little) 4))

      (test-assert "{sint,uint}-list->bytevector"
        (let ((b1 (sint-list->bytevector '(513 -253 513 513)
                                         (endianness little) 2))
              (b2 (uint-list->bytevector '(513 65283 513 513)
                                         (endianness little) 2))
              (b3 (u8-list->bytevector '(1 2 3 255 1 2 1 2))))
          (and (bytevector=? b1 b2)
               (bytevector=? b2 b3))))

      (test-assert "sint-list->bytevector [limits]"
        (bytevector=? (sint-list->bytevector '(-32768 32767)
                                             (endianness big) 2)
                      (let ((bv (make-bytevector 4)))
                        (bytevector-u8-set! bv 0 #x80)
                        (bytevector-u8-set! bv 1 #x00)
                        (bytevector-u8-set! bv 2 #x7f)
                        (bytevector-u8-set! bv 3 #xff)
                        bv)))

      (test-error "sint-list->bytevector [invalid argument type]"
                  (sint-list->bytevector 'not-a-list (endianness big) 2))

      (test-error "uint-list->bytevector [invalid argument type]"
                  (uint-list->bytevector 'not-a-list (endianness big) 2))

      (test-error "sint-list->bytevector [circular list]"
                  (sint-list->bytevector (circular-list 1 2 3) (endianness big)
                                         2))

      (test-error "uint-list->bytevector [circular list]"
                  (uint-list->bytevector (circular-list 1 2 3) (endianness big)
                                         2))

      (test-error "sint-list->bytevector [out-of-range]"
                  (sint-list->bytevector (list 0 0 (expt 2 16)) (endianness big)
                                         2))

      (test-error "uint-list->bytevector [out-of-range]"
                  (uint-list->bytevector '(0 -1) (endianness big) 2))
      (test-end)

      (test-begin "2.5 Operations on 16-Bit Integers")

      (let ((b #u8(255 255 255 255 255 255 255 255
                       255 255 255 255 255 255 255 253)))
        (test #xfdff (bytevector-u16-ref b 14 (endianness little)))
        (test #xfffd (bytevector-u16-ref b 14 (endianness big))))

      (let ((b #u8(255 255 255 255 255 255 255 255
                       255 255 255 255 255 255 255 253)))
        (test -513 (bytevector-s16-ref b 14 (endianness little)))
        (test -3 (bytevector-s16-ref b 14 (endianness big))))

      (let ((b (u8-list->bytevector '(#xff #xf0 #xff))))
        (test -16 (bytevector-s16-ref b 1 (endianness little))))

      (test-assert "bytevector-{u16,s16}-ref"
        (let ((b (make-bytevector 2)))
          (bytevector-u16-set! b 0 44444 (endianness little))
          (and (equal? (bytevector-u16-ref b 0 (endianness little))
                       44444)
               (equal? (bytevector-s16-ref b 0 (endianness little))
                       (- 44444 65536)))))

      (test-assert "bytevector-native-{u16,s16}-{ref,set!}"
        (let ((b (make-bytevector 2)))
          (bytevector-u16-native-set! b 0 44444)
          (and (equal? (bytevector-u16-native-ref b 0)
                       44444)
               (equal? (bytevector-s16-native-ref b 0)
                       (- 44444 65536)))))

      (test-assert "bytevector-{u16,s16}-{ref,set!} [unaligned]"
        (let ((b (make-bytevector 5)))
          (bytevector-s16-set! b 1 -77 (endianness little))
          (bytevector-s16-set! b 3 -77 (endianness big))
          (and (equal? (bytevector-s16-ref b 1 (endianness little))
                       -77)
               (equal? (bytevector-u16-ref b 1 (endianness little))
                       (- 65536 77))
               (equal? (bytevector-s16-ref b 3 (endianness big))
                       -77)
               (equal? (bytevector-u16-ref b 3 (endianness big))
                       (- 65536 77)))))
      (test-end)

      (test-begin "2.6 Operations on 32-bit Integers")

      (test-assert "bytevector-u32-ref"
        (let ((b (u8-list->bytevector
                  '(255 255 255 255 255 255 255 255
                        255 255 255 255 255 255 255 253))))
          (and (equal? (bytevector-u32-ref b 12 (endianness little))
                       #xfdffffff)
               (equal? (bytevector-u32-ref b 12 (endianness big))
                       #xfffffffd))))

      (test-assert "bytevector-s32-ref"
        (let ((b (u8-list->bytevector
                  '(255 255 255 255 255 255 255 255
                        255 255 255 255 255 255 255 253))))
          (and (equal? (bytevector-s32-ref b 12 (endianness little))
                       -33554433)
               (equal? (bytevector-s32-ref b 12 (endianness big))
                       -3))))

      (test-assert "bytevector-{u32,s32}-ref"
        (let ((b (make-bytevector 4)))
          (bytevector-u32-set! b 0 2222222222 (endianness little))
          (and (equal? (bytevector-u32-ref b 0 (endianness little))
                       2222222222)
               (equal? (bytevector-s32-ref b 0 (endianness little))
                       (- 2222222222 (expt 2 32))))))

      (test-assert "bytevector-{u32,s32}-native-{ref,set!}"
        (let ((b (make-bytevector 4)))
          (bytevector-u32-native-set! b 0 2222222222)
          (and (equal? (bytevector-u32-native-ref b 0)
                       2222222222)
               (equal? (bytevector-s32-native-ref b 0)
                       (- 2222222222 (expt 2 32))))))

      (test-assert "bytevector-{u32,s32}-{ref,set!} [unaligned]"
        (let ((b (make-bytevector 9)))
          (bytevector-s32-set! b 1 -77777 (endianness little))
          (bytevector-s32-set! b 5 -77777 (endianness big))
          (and (equal? (bytevector-s32-ref b 1 (endianness little))
                       -77777)
               (equal? (bytevector-u32-ref b 1 (endianness little))
                       (- (expt 2 32) 77777))
               (equal? (bytevector-s32-ref b 5 (endianness big))
                       -77777)
               (equal? (bytevector-u32-ref b 5 (endianness big))
                       (- (expt 2 32) 77777)))))
      (test-end)

      (test-begin "2.7 Operations on 64-bit Integers")

      (let ((b (u8-list->bytevector
                '(255 255 255 255 255 255 255 255
                      255 255 255 255 255 255 255 253))))
        (test #xfdffffffffffffff
            (bytevector-u64-ref b 8 (endianness little)))
        (test #xfffffffffffffffd
            (bytevector-u64-ref b 8 (endianness big)))
        (test -144115188075855873
            (bytevector-s64-ref b 8 (endianness little)))
        (test -3
            (bytevector-s64-ref b 8 (endianness big))))

      (let ((b (make-bytevector 8))
            (big 9333333333333333333))
        (bytevector-u64-set! b 0 big (endianness little))
        (test big
            (bytevector-u64-ref b 0 (endianness little)))
        (test (- big (expt 2 64))
            (bytevector-s64-ref b 0 (endianness little))))

      (let ((b (make-bytevector 8))
            (big 9333333333333333333))
        (bytevector-u64-native-set! b 0 big)
        (test big
            (bytevector-u64-native-ref b 0))
        (test (- big (expt 2 64))
            (bytevector-s64-native-ref b 0)))

      (test-assert "ref/set! with zero"
        (let ((b (make-bytevector 8)))
          (bytevector-s64-set! b 0 -1 (endianness big))
          (bytevector-u64-set! b 0  0 (endianness big))
          (= 0 (bytevector-u64-ref b 0 (endianness big)))))

      (test-assert "bytevector-{u64,s64}-{ref,set!} [unaligned]"
        (let ((b (make-bytevector 17)))
          (bytevector-s64-set! b 1 -7777777777 (endianness little))
          (bytevector-s64-set! b 9 -7777777777 (endianness big))
          (and (equal? (bytevector-s64-ref b 1 (endianness little))
                       -7777777777)
               (equal? (bytevector-u64-ref b 1 (endianness little))
                       (- (expt 2 64) 7777777777))
               (equal? (bytevector-s64-ref b 9 (endianness big))
                       -7777777777)
               (equal? (bytevector-u64-ref b 9 (endianness big))
                       (- (expt 2 64) 7777777777)))))
      (test-end)

      (test-begin "2.8 Operations on IEEE-754 Representations")

      (test-assert "single, little endian"
        (let ((b (make-bytevector 4)))
          (bytevector-ieee-single-set! b 0 1.0 (endianness little))
          (equal? #u8(0 0 128 63) b)))

      (test-assert "single, big endian"
        (let ((b (make-bytevector 4)))
          (bytevector-ieee-single-set! b 0 1.0 (endianness big))
          (equal? #u8(63 128 0 0) b)))

      (test-assert "bytevector-ieee-single-native-{ref,set!}"
        (let ((b (make-bytevector 4))
              (number 3.00))
          (bytevector-ieee-single-native-set! b 0 number)
          (equal? (bytevector-ieee-single-native-ref b 0)
                  number)))

      (test-assert "bytevector-ieee-single-{ref,set!}"
        (let ((b (make-bytevector 8))
              (number 3.14))
          (bytevector-ieee-single-set! b 0 number (endianness little))
          (bytevector-ieee-single-set! b 4 number (endianness big))
          (equal? (bytevector-ieee-single-ref b 0 (endianness little))
                  (bytevector-ieee-single-ref b 4 (endianness big)))))

      (test-assert "bytevector-ieee-single-{ref,set!} [unaligned]"
        (let ((b (make-bytevector 9))
              (number 3.14))
          (bytevector-ieee-single-set! b 1 number (endianness little))
          (bytevector-ieee-single-set! b 5 number (endianness big))
          (equal? (bytevector-ieee-single-ref b 1 (endianness little))
                  (bytevector-ieee-single-ref b 5 (endianness big)))))

      (test-assert "double, little endian"
        (let ((b (make-bytevector 8)))
          (bytevector-ieee-double-set! b 0 1.0 (endianness little))
          (equal? #u8(0 0 0 0 0 0 240 63) b)))

      (test-assert "double, big endian"
        (let ((b (make-bytevector 8)))
          (bytevector-ieee-double-set! b 0 1.0 (endianness big))
          (equal? #u8(63 240 0 0 0 0 0 0) b)))

      (test-assert "bytevector-ieee-double-native-{ref,set!}"
        (let ((b (make-bytevector 8))
              (number 3.14))
          (bytevector-ieee-double-native-set! b 0 number)
          (equal? (bytevector-ieee-double-native-ref b 0)
                  number)))

      (test-assert "bytevector-ieee-double-{ref,set!}"
        (let ((b (make-bytevector 16))
              (number 3.14))
          (bytevector-ieee-double-set! b 0 number (endianness little))
          (bytevector-ieee-double-set! b 8 number (endianness big))
          (equal? (bytevector-ieee-double-ref b 0 (endianness little))
                  (bytevector-ieee-double-ref b 8 (endianness big)))))

      (test-assert "bytevector-ieee-double-{ref,set!} [unaligned]"
        (let ((b (make-bytevector 17))
              (number 3.14))
          (bytevector-ieee-double-set! b 1 number (endianness little))
          (bytevector-ieee-double-set! b 9 number (endianness big))
          (equal? (bytevector-ieee-double-ref b 1 (endianness little))
                  (bytevector-ieee-double-ref b 9 (endianness big)))))
      (test-end)


      (test-begin "2.9 Operations on Strings")

      (test-assert "string->utf8"
        (let* ((str  "hello, world")
               (utf8 (string->utf8 str)))
          (and (bytevector? utf8)
               (= (bytevector-length utf8)
                  (string-length str))
               (equal? (string->list str)
                       (map integer->char (bytevector->u8-list utf8))))))

      (test-assert "string->utf8 [latin-1]"
        (let* ((str  "h, a va bien ?")
               (utf8 (string->utf8 str)))
          (and (bytevector? utf8)
               (= (bytevector-length utf8)
                  (+ 2 (string-length str))))))

      (test-assert "string->utf16"
        (let* ((str   "hello, world")
               (utf16 (string->utf16 str)))
          (and (bytevector? utf16)
               (= (bytevector-length utf16)
                  (* 2 (string-length str)))
               (equal? (string->list str)
                       (map integer->char
                            (bytevector->uint-list utf16
                                                   (endianness big) 2))))))

      (test-assert "string->utf16 [little]"
        (let* ((str   "hello, world")
               (utf16 (string->utf16 str (endianness little))))
          (and (bytevector? utf16)
               (= (bytevector-length utf16)
                  (* 2 (string-length str)))
               (equal? (string->list str)
                       (map integer->char
                            (bytevector->uint-list utf16
                                                   (endianness little) 2))))))


      (test-assert "string->utf32"
        (let* ((str   "hello, world")
               (utf32 (string->utf32 str)))
          (and (bytevector? utf32)
               (= (bytevector-length utf32)
                  (* 4 (string-length str)))
               (equal? (string->list str)
                       (map integer->char
                            (bytevector->uint-list utf32
                                                   (endianness big) 4))))))

      (test-assert "string->utf32 [Greek]"
        (let* ((str   "")
               (utf32 (string->utf32 str)))
          (and (bytevector? utf32)
               (equal? (bytevector->uint-list utf32 (endianness big) 4)
                       '(#x1f0c #x3bd #x3b5 #x3bc #x3bf #x3b9)))))

      (test-assert "string->utf32 [little]"
        (let* ((str   "hello, world")
               (utf32 (string->utf32 str (endianness little))))
          (and (bytevector? utf32)
               (= (bytevector-length utf32)
                  (* 4 (string-length str)))
               (equal? (string->list str)
                       (map integer->char
                            (bytevector->uint-list utf32
                                                   (endianness little) 4))))))

      (test-assert "utf8->string"
        (let* ((utf8  (u8-list->bytevector (map char->integer
                                                (string->list "hello, world"))))
               (str   (utf8->string utf8)))
          (and (string? str)
               (= (string-length str)
                  (bytevector-length utf8))
               (equal? (string->list str)
                       (map integer->char (bytevector->u8-list utf8))))))

      (test-assert "utf8->string [latin-1]"
        (let* ((utf8  (string->utf8 "h, a va bien ?"))
               (str   (utf8->string utf8)))
          (and (string? str)
               (= (string-length str)
                  (- (bytevector-length utf8) 2)))))

      (test "utf8->string [replacement character]"
          '(104 105 65533)
        (map char->integer
             (string->list (utf8->string #u8(104 105 239 191 189)))))

      (test-assert "utf16->string"
        (let* ((utf16  (uint-list->bytevector (map char->integer
                                                   (string->list "hello, world"))
                                              (endianness big) 2))
               (str   (utf16->string utf16)))
          (and (string? str)
               (= (* 2 (string-length str))
                  (bytevector-length utf16))
               (equal? (string->list str)
                       (map integer->char
                            (bytevector->uint-list utf16 (endianness big)
                                                   2))))))

      (test-assert "utf16->string [little]"
        (let* ((utf16  (uint-list->bytevector (map char->integer
                                                   (string->list "hello, world"))
                                              (endianness little) 2))
               (str   (utf16->string utf16 (endianness little))))
          (and (string? str)
               (= (* 2 (string-length str))
                  (bytevector-length utf16))
               (equal? (string->list str)
                       (map integer->char
                            (bytevector->uint-list utf16 (endianness little)
                                                   2))))))
      (test-assert "utf32->string"
        (let* ((utf32  (uint-list->bytevector (map char->integer
                                                   (string->list "hello, world"))
                                              (endianness big) 4))
               (str   (utf32->string utf32)))
          (and (string? str)
               (= (* 4 (string-length str))
                  (bytevector-length utf32))
               (equal? (string->list str)
                       (map integer->char
                            (bytevector->uint-list utf32 (endianness big)
                                                   4))))))

      (test-assert "utf32->string [little]"
        (let* ((utf32  (uint-list->bytevector (map char->integer
                                                   (string->list "hello, world"))
                                              (endianness little) 4))
               (str   (utf32->string utf32 (endianness little))))
          (and (string? str)
               (= (* 4 (string-length str))
                  (bytevector-length utf32))
               (equal? (string->list str)
                       (map integer->char
                            (bytevector->uint-list utf32 (endianness little)
                                                   4))))))
      (test-end)

      (test-end))))

(define-library (scheme mapping) (alias-for (srfi 146)))

(define-library (scheme hash-table) (alias-for (srfi 125)))

(define-library (scheme load)
  (import (chibi))
  (export load))

(define-library (scheme show) (alias-for (srfi 166)))

(define-library (scheme vector) (alias-for (srfi 133)))

(define-library (scheme set) (alias-for (srfi 113)))

(define-library (scheme lazy)
  (import (chibi))
  (export delay force delay-force make-promise promise?)
  (begin
    (define (make-promise x)
      (if (promise? x) x (delay x)))))

(define-library (scheme vector s64) (alias-for (srfi 160 s64)))

(define-library (scheme vector u8) (alias-for (srfi 160 u8)))

(define-library (scheme vector c64) (alias-for (srfi 160 c64)))

(define-library (scheme vector s8) (alias-for (srfi 160 s8)))

(define-library (scheme vector s16) (alias-for (srfi 160 s16)))

(define-library (scheme vector f64) (alias-for (srfi 160 f64)))

(define-library (scheme vector u32) (alias-for (srfi 160 u32)))

(define-library (scheme vector u16) (alias-for (srfi 160 u16)))

(define-library (scheme vector s32) (alias-for (srfi 160 s32)))

(define-library (scheme vector u64) (alias-for (srfi 160 u64)))

(define-library (scheme vector c128) (alias-for (srfi 160 c128)))

(define-library (scheme vector base) (alias-for (srfi 160 base)))

(define-library (scheme vector f32) (alias-for (srfi 160 f32)))
;; time.sld - (scheme time) library definition
;;
;; Copyright (c) 2012 Alex Shinn. All rights reserved.
;; Copyright (c) 2012 Alan Watson. All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

(define-library (scheme time)
  (export current-second current-jiffy jiffies-per-second)
  (import (chibi))
  (import (scheme process-context))
  (import (scheme time tai))
  (include-shared "time")
  ;; If the environment variable SEXP_CLOCK_TYPE is set, its value
  ;; is used for the system clock type. If the environment variable
  ;; SEXP_CLOCK_TYPE is not set, then the system clock is ntp-like
  ;; if current-ntp-clock-values is a procedure and is posix-like
  ;; otherwise.
  (cond-expand
   (ntp
    (begin
      (define clock-type
        (cond
         ((get-environment-variable "SEXP_CLOCK_TYPE")
          => (lambda (x)
               (let ((type (string->symbol x)))
                 (case type
                   ((posix-like tai-like ntp-like) type)
                   (else
                    (display "invalid value for SEXP_CLOCK_TYPE: " (current-error-port))
                    (write x (current-error-port))
                    (display " - expected \"ntp-like\", \"posix-like\" or \"tai-like\"\n" (current-error-port))
                    'ntp-like)))))
         (else 'ntp-like)))))
   (else
    (begin (define clock-type 'posix-like))))
  (begin
    ;; The value of the environment variable SEXP_CLOCK_EPOCH_OFFSET
    ;; specifies the offset of the system clock relative to the
    ;; standard epoch (1970-01-01 00:00:00 UTC for posix-like and
    ;; ntp-like clocks and 1970-01-01 00:00:00 TAI for tai-like system
    ;; clocks). If it not set, the offset is assumed to be zero. In
    ;; call-with-current-clock-values, the offset is added to the
    ;; current seconds before calling the procedure argument.
    (define epoch-offset
      (exact->inexact
       (string->number
        (or (get-environment-variable "SEXP_CLOCK_EPOCH_OFFSET")
            "0"))))

    ;; Normally, one does not need to specify either the clock type or
    ;; clock epoch explicitly. One case where it might be necessary is
    ;; if the system clock runs on the TAI-10 timescale. In this case,
    ;; one should set SEXP_CLOCK_TYPE to "tai-like" and
    ;; SEXP_CLOCK_EPOCH_OFFSET to -10.
    ;;
    ;; The call-with-current-clock-values obtains the clock values
    ;; from the current-ntp-clock-values procedure, if the system
    ;; clock is ntp-like, and from the current-clock-second procedure
    ;; otherwise.
    (define call-with-current-clock-values
      (cond-expand
       (ntp
        (case clock-type
          ((ntp-like)
           (lambda (p)
             (let ((values-pair (current-ntp-clock-values)))
               (p (+ (car values-pair) epoch-offset) (cdr values-pair)))))
          (else
           (lambda (p) (p (+ (current-clock-second) epoch-offset) #f)))))
       (else
        (lambda (p) (p (+ (current-clock-second) epoch-offset) #f)))))

    ;; Exported interface.
    (define current-second
      (make-tai-clock clock-type call-with-current-clock-values))
    (define (current-jiffy)
      (inexact->exact (round (* (current-second) (jiffies-per-second)))))
    (define (jiffies-per-second) 1000)))

(define-library (scheme regex) (alias-for (srfi 115)))

;; provide c[ad]{3,4}r

(define (caaar x) (car (car (car x))))
(define (caadr x) (car (car (cdr x))))
(define (cadar x) (car (cdr (car x))))
(define (caddr x) (car (cdr (cdr x))))
(define (cdaar x) (cdr (car (car x))))
(define (cdadr x) (cdr (car (cdr x))))
(define (cddar x) (cdr (cdr (car x))))
(define (cdddr x) (cdr (cdr (cdr x))))
(define (caaaar x) (car (car (car (car x)))))
(define (caaadr x) (car (car (car (cdr x)))))
(define (caadar x) (car (car (cdr (car x)))))
(define (caaddr x) (car (car (cdr (cdr x)))))
(define (cadaar x) (car (cdr (car (car x)))))
(define (cadadr x) (car (cdr (car (cdr x)))))
(define (caddar x) (car (cdr (cdr (car x)))))
(define (cadddr x) (car (cdr (cdr (cdr x)))))
(define (cdaaar x) (cdr (car (car (car x)))))
(define (cdaadr x) (cdr (car (car (cdr x)))))
(define (cdadar x) (cdr (car (cdr (car x)))))
(define (cdaddr x) (cdr (car (cdr (cdr x)))))
(define (cddaar x) (cdr (cdr (car (car x)))))
(define (cddadr x) (cdr (cdr (car (cdr x)))))
(define (cdddar x) (cdr (cdr (cdr (car x)))))
(define (cddddr x) (cdr (cdr (cdr (cdr x)))))

(define-library (scheme bytevector)
  (import (rename (scheme base)
                  (bytevector-copy! %bytevector-copy!))
          (scheme bitwise)
          (only (chibi)
                er-macro-transformer
                strip-syntactic-closures))
  (export
   endianness native-endianness bytevector? make-bytevector
   bytevector-length bytevector=? bytevector-fill! bytevector-copy!
   bytevector-u8-ref bytevector-s8-ref
   bytevector-u8-set! bytevector-s8-set!
   bytevector->u8-list u8-list->bytevector
   bytevector-uint-ref bytevector-sint-ref
   bytevector-uint-set! bytevector-sint-set!
   bytevector->uint-list uint-list->bytevector
   bytevector->sint-list sint-list->bytevector
   bytevector-u16-ref bytevector-s16-ref
   bytevector-u16-set! bytevector-s16-set!
   bytevector-u16-native-ref bytevector-s16-native-ref
   bytevector-u16-native-set! bytevector-s16-native-set!
   bytevector-u32-ref bytevector-s32-ref
   bytevector-u32-set! bytevector-s32-set!
   bytevector-u32-native-ref bytevector-s32-native-ref
   bytevector-u32-native-set! bytevector-s32-native-set!
   bytevector-u64-ref bytevector-s64-ref
   bytevector-u64-set! bytevector-s64-set!
   bytevector-u64-native-ref bytevector-s64-native-ref
   bytevector-u64-native-set! bytevector-s64-native-set!
   bytevector-ieee-single-native-ref
   bytevector-ieee-single-ref
   bytevector-ieee-double-native-ref
   bytevector-ieee-double-ref
   bytevector-ieee-single-native-set!
   bytevector-ieee-single-set!
   bytevector-ieee-double-native-set!
   bytevector-ieee-double-set!
   string->utf8
   string->utf16
   string->utf32
   utf8->string
   utf16->string
   utf32->string
   )
  (cond-expand
   (big-endian (begin (define (native-endianness) 'big)))
   (else (begin (define (native-endianness) 'little))))
  (begin
    (define-syntax endianness
      (er-macro-transformer
       (lambda (expr rename compare)
         (if (not (and (pair? (cdr expr))
                       (null? (cddr expr))
                       (memq (strip-syntactic-closures (cadr expr))
                             '(big little))))
             (error "endianness must be 'big or 'little" expr))
         `(,(rename 'quote) ,(cadr expr)))))
    (define (bytevector=? a b)
      (if (not (and (bytevector? a) (bytevector? b)))
          (error "bytevector expected" a b))
      (equal? a b))
    (define (bytevector-fill! bv elt)
      (do ((i (- (bytevector-length bv) 1) (- i 1)))
          ((< i 0))
        (bytevector-u8-set! bv i elt)))
    (define (bytevector-copy! from start to . o)
      (let* ((at (if (pair? o) (car o) 0))
             (len (if (and (pair? o) (pair? (cdr o)))
                      (cadr o)
                      (- (bytevector-length to) at)))
             (end (+ start len)))
        (%bytevector-copy! to at from start end)))
    (define (bytevector->u8-list bv)
      (do ((i (- (bytevector-length bv) 1) (- i 1))
           (res '() (cons (bytevector-u8-ref bv i) res)))
          ((< i 0) res)))
    (define (u8-list->bytevector ls)
      (let* ((len (length ls))
             (res (make-bytevector len)))
        (do ((ls ls (cdr ls))
             (i 0 (+ i 1)))
            ((null? ls) res)
          (bytevector-u8-set! res i (car ls))))))
  (include-shared "bytevector")
  (begin
    (define (string->utf16 str . o)
      (%string->utf16 str (if (pair? o) (car o) (endianness big))))
    (define (string->utf32 str . o)
      (%string->utf32 str (if (pair? o) (car o) (endianness big))))
    (define (utf16->string bv . o)
      (let ((endianness (if (pair? o) (car o) (endianness big)))
            (endianness-mandatory? (and (pair? o) (pair? (cdr o)) (cadr o))))
        (%utf16->string bv endianness endianness-mandatory?)))
    (define (utf32->string bv . o)
      (let ((endianness (if (pair? o) (car o) (endianness big)))
            (endianness-mandatory? (and (pair? o) (pair? (cdr o)) (cadr o))))
        (%utf32->string bv endianness endianness-mandatory?)))
    (define (bytevector-uint-ref bv k endianness size)
      (unless (positive? size) (error "size must be positive" size))
      (if (eq? endianness 'big)
          (do ((i 0 (+ i 1))
               (res 0 (+ (* res 256) (bytevector-u8-ref bv (+ k i)))))
              ((>= i size) res))
          (do ((i (- size 1) (- i 1))
               (res 0 (+ (* res 256) (bytevector-u8-ref bv (+ k i)))))
              ((< i 0) res))))
    (define (bytevector-sint-ref bv k endianness size)
      (unless (positive? size) (error "size must be positive" size))
      (let ((n (bytevector-uint-ref bv k endianness size))
            (mask (expt 2 (- (* 8 size) 1))))
        (- (bitwise-and n (bitwise-not mask))
           (bitwise-and n mask))))
    (define (bytevector-uint-set! bv k n endianness size)
      (unless (positive? size) (error "size must be positive" size))
      (if (eq? endianness 'big)
          (do ((i (- size 1) (- i 1))
               (n n (arithmetic-shift n -8)))
              ((< i 0))
            (bytevector-u8-set! bv (+ k i) (bitwise-and n #xFF)))
          (do ((i 0 (+ i 1))
               (n n (arithmetic-shift n -8)))
              ((>= i size))
            (bytevector-u8-set! bv (+ k i) (bitwise-and n #xFF)))))
    (define (bytevector-sint-set! bv k n endianness size)
      (bytevector-uint-set! bv k (+ (expt 2 (* 8 size)) n) endianness size))
    (define (bytevector->uint-list bv endianness size)
      (unless (positive? size) (error "size must be positive" size))
      (unless (zero? (modulo (bytevector-length bv) size))
        (error "size must divide length" (bytevector-length bv) size))
      (do ((i 0 (+ i size))
           (res '() (cons (bytevector-uint-ref bv i endianness size) res)))
          ((> (+ i size) (bytevector-length bv)) (reverse res))))
    (define (bytevector->sint-list bv endianness size)
      (unless (positive? size) (error "size must be positive" size))
      (unless (zero? (modulo (bytevector-length bv) size))
        (error "size must divide length" (bytevector-length bv) size))
      (do ((i 0 (+ i size))
           (res '() (cons (bytevector-sint-ref bv i endianness size) res)))
          ((> (+ i size) (bytevector-length bv)) (reverse res))))
    (define (uint-list->bytevector ls endianness size)
      (unless (positive? size) (error "size must be positive" size))
      (let ((res (make-bytevector (* (length ls) size) 0))
            (limit (expt 2 (* size 8))))
        (do ((ls ls (cdr ls))
             (i 0 (+ i size)))
            ((null? ls) res)
          (unless (<= 0 (car ls) limit)
            (error "out of range" (car ls) limit))
          (bytevector-uint-set! res i (car ls) endianness size))))
    (define (sint-list->bytevector ls endianness size)
      (unless (positive? size) (error "size must be positive" size))
      (let* ((res (make-bytevector (* (length ls) size) 0))
             (lo (- (expt 2 (- (* size 8) 1))))
             (hi (- -1 lo)))
        (do ((ls ls (cdr ls))
             (i 0 (+ i size)))
            ((null? ls) res)
          (unless (<= lo (car ls) hi)
            (error "out of range" (car ls) lo hi))
          (bytevector-sint-set! res i (car ls) endianness size))))
    ))

(define-library (scheme ephemeron) (alias-for (srfi 124)))

(define-library (scheme process-context)
  (import (chibi) (srfi 98))
  (cond-expand (windows (import (only (chibi win32 process-win32) exit)))
               (else (import (only (chibi process) exit))))
  (export get-environment-variable get-environment-variables
          command-line exit emergency-exit)
  ;; TODO: Make exit unwind and finalize properly.
  (begin (define emergency-exit exit)))

(define-library (scheme charset) (alias-for (srfi 14)))

(define-library (scheme fixnum) (alias-for (srfi 143)))

(define-library (scheme flonum) (alias-for (srfi 144)))

(define-library (scheme division)
  (import (scheme base))
  (export ceiling-quotient ceiling-remainder ceiling/
          euclidean-quotient euclidean-remainder euclidean/
          round-quotient round-remainder round/
          balanced-quotient balanced-remainder balanced/)
  ;; The second definition is always valid, but the first is simpler
  ;; and faster if exact ratios are supported and handled correctly
  ;; but floor/ceil/round.
  (cond-expand
   (ratios
    (begin
      (define-syntax copy-exactness2
        (syntax-rules ()
          ((copy-exactness2 src1 src2 expr)
           expr)))))
   (else
    (begin
      (define-syntax copy-exactness2
        (syntax-rules ()
          ((copy-exactness2 src1 src2 expr)
           (let ((tmp expr))
             (if (and (exact? src1) (exact? src2))
                 (inexact->exact tmp)
                 tmp))))))))
  (include "division.scm"))

(define char-foldcase char-downcase)

(define (string-downcase str)
  (string-map char-downcase str))

(define (string-upcase str)
  (string-map char-upcase str))

(define (string-foldcase str)
  (string-map char-foldcase str))

(define (char-alphabetic? ch) (char-set-contains? char-set:letter ch))
(define (char-lower-case? ch) (char-set-contains? char-set:lower-case ch))
(define (char-upper-case? ch) (char-set-contains? char-set:upper-case ch))
(define (char-numeric? ch) (char-set-contains? char-set:digit ch))
(define (char-whitespace? ch) (char-set-contains? char-set:whitespace ch))

(define (bsearch-kv vec n lo hi)
  (and (<= lo hi)
       (let* ((mid (+ lo (* (quotient (- hi lo) 4) 2)))
              (m (vector-ref vec mid)))
         (cond
          ((= n m)
           (integer->char (vector-ref vec (+ mid 1))))
          ((< n m)
           (bsearch-kv vec n lo (- mid 2)))
          (else
           (bsearch-kv vec n (+ mid 2) hi))))))

(define (char-downcase ch)
  (let ((n (char->integer ch)))
    (let lp ((ls char-downcase-offsets))
      (cond
       ((null? ls)
        (or (bsearch-kv char-downcase-map n 0
                        (- (vector-length char-downcase-map) 2))
            ch))
       ((iset-contains? (caar ls) n)
        (integer->char (+ n (cdar ls))))
       (else (lp (cdr ls)))))))

(define (char-upcase ch)
  (let ((n (char->integer ch)))
    (let lp ((ls char-downcase-offsets))
      (cond
       ((null? ls)
        (or (bsearch-kv char-upcase-map n 0
                        (- (vector-length char-upcase-map) 2))
            ch))
       ((iset-contains? (caar ls) (- n (cdar ls)))
        (integer->char (- n (cdar ls))))
       (else (lp (cdr ls)))))))

(define (char-foldcase ch)
  (or (bsearch-kv char-foldcase-map (char->integer ch) 0
                  (- (vector-length char-foldcase-map) 2))
      ch))

(define (char-cmp-ci op a ls)
  (let lp ((op op) (a (char->integer (char-foldcase a))) (ls ls))
    (if (null? ls)
        #t
        (let ((b (char->integer (char-downcase (car ls)))))
          (and (op a b) (lp op b (cdr ls)))))))

(define (char-ci=? a . ls) (char-cmp-ci = a ls))
(define (char-ci<? a . ls) (char-cmp-ci < a ls))
(define (char-ci>? a . ls) (char-cmp-ci > a ls))
(define (char-ci<=? a . ls) (char-cmp-ci <= a ls))
(define (char-ci>=? a . ls) (char-cmp-ci >= a ls))

(define (char-get-special-case ch off)
  (let ((i (char->integer ch)))
    (let lp ((a 0) (b (vector-length special-cases)))
      (let* ((mid (+ a (quotient (- b a) 2)))
             (vec (vector-ref special-cases mid))
             (val (vector-ref vec 0)))
        (cond ((< i val) (and (< mid b) (lp a mid)))
              ((> i val) (and (> mid a) (lp mid b)))
              (else
               (vector-ref vec (if (>= off (vector-length vec)) 1 off))))))))

(define (call-with-output-string proc)
  (let ((out (open-output-string)))
    (proc out)
    (get-output-string out)))

(define (string-down-or-fold-case str fold?)
  (call-with-output-string
    (lambda (out)
      (let ((in (open-input-string str)))
        (let lp ()
          (let ((ch (read-char in)))
            (cond
             ((not (eof-object? ch))
              (cond
               ((and (not fold?) (eqv? ch #\x03A3)) ;; sigma
                (let ((ch2 (peek-char in)))
                  (write-char
                   (if (or (eof-object? ch2)
                           (not (char-set-contains? char-set:letter ch2)))
                       #\x03C2
                       #\x03C3)
                   out)))
               ((char-get-special-case ch (if fold? 4 1))
                => (lambda (s) (write-string s out)))
               (else
                (write-char (if fold? (char-foldcase ch) (char-downcase ch))
                            out)))
              (lp)))))))))

(define (string-downcase str) (string-down-or-fold-case str #f))
(define (string-foldcase str) (string-down-or-fold-case str #t))

(define (string-upcase str)
  (call-with-output-string
    (lambda (out)
      (string-for-each
       (lambda (ch)
         (write-string (if (memv ch '(#\x03C2 #\x03C3))
                           #\x03A3
                           (or (char-get-special-case ch 3)
                               (char-upcase ch)))
                       out))
       str))))

(define (string-cmp-ci op a ls)
  (let lp ((op op) (a (string-foldcase a)) (ls ls))
    (if (null? ls)
        #t
        (let ((b (string-foldcase (car ls))))
          (and (op a b) (lp op b (cdr ls)))))))

(define (string-ci=? a . ls) (string-cmp-ci string=? a ls))
(define (string-ci<? a . ls) (string-cmp-ci string<? a ls))
(define (string-ci>? a . ls) (string-cmp-ci string>? a ls))
(define (string-ci<=? a . ls) (string-cmp-ci string<=? a ls))
(define (string-ci>=? a . ls) (string-cmp-ci string>=? a ls))
;; This library is deprecated, occurring in early R7RS drafts before
;; being removed.

(define-library (scheme char normalization)
  (import (rename (chibi)
                  (string=? string-ni=?)
                  (string<? string-ni<?)
                  (string>? string-ni>?)
                  (string<=? string-ni<=?)
                  (string>=? string-ni>=?)))
  (export string-ni=? string-ni<? string-ni>? string-ni<=? string-ni>=?))
;; auto-generated by extract-special-casing.scm

(define special-cases
  ;; <code> <lower> <title> <upper> [<fold>]
  '#(#(#xdf "" "Ss" "SS" "ss")
     #(#x130 "i" "" "" "i")
     #(#x149 "" "N" "N" "n")
     #(#x1f0 "" "J" "J" "j")
     #(#x390 "" "" "" "")
     #(#x3b0 "" "" "" "")
     #(#x587 "" "" "" "")
     #(#x1e96 "" "H" "H" "h")
     #(#x1e97 "" "T" "T" "t")
     #(#x1e98 "" "W" "W" "w")
     #(#x1e99 "" "Y" "Y" "y")
     #(#x1e9a "" "A" "A" "a")
     #(#x1e9e "" "Ss" "SS" "ss")  ;; TODO: this had to be added by hand
     #(#x1f50 "" "" "" "")
     #(#x1f52 "" "" "" "")
     #(#x1f54 "" "" "" "")
     #(#x1f56 "" "" "" "")
     #(#x1f80 "" "" "" "")
     #(#x1f81 "" "" "" "")
     #(#x1f82 "" "" "" "")
     #(#x1f83 "" "" "" "")
     #(#x1f84 "" "" "" "")
     #(#x1f85 "" "" "" "")
     #(#x1f86 "" "" "" "")
     #(#x1f87 "" "" "" "")
     #(#x1f88 "" "" "" "")
     #(#x1f89 "" "" "" "")
     #(#x1f8a "" "" "" "")
     #(#x1f8b "" "" "" "")
     #(#x1f8c "" "" "" "")
     #(#x1f8d "" "" "" "")
     #(#x1f8e "" "" "" "")
     #(#x1f8f "" "" "" "")
     #(#x1f90 "" "" "" "")
     #(#x1f91 "" "" "" "")
     #(#x1f92 "" "" "" "")
     #(#x1f93 "" "" "" "")
     #(#x1f94 "" "" "" "")
     #(#x1f95 "" "" "" "")
     #(#x1f96 "" "" "" "")
     #(#x1f97 "" "" "" "")
     #(#x1f98 "" "" "" "")
     #(#x1f99 "" "" "" "")
     #(#x1f9a "" "" "" "")
     #(#x1f9b "" "" "" "")
     #(#x1f9c "" "" "" "")
     #(#x1f9d "" "" "" "")
     #(#x1f9e "" "" "" "")
     #(#x1f9f "" "" "" "")
     #(#x1fa0 "" "" "" "")
     #(#x1fa1 "" "" "" "")
     #(#x1fa2 "" "" "" "")
     #(#x1fa3 "" "" "" "")
     #(#x1fa4 "" "" "" "")
     #(#x1fa5 "" "" "" "")
     #(#x1fa6 "" "" "" "")
     #(#x1fa7 "" "" "" "")
     #(#x1fa8 "" "" "" "")
     #(#x1fa9 "" "" "" "")
     #(#x1faa "" "" "" "")
     #(#x1fab "" "" "" "")
     #(#x1fac "" "" "" "")
     #(#x1fad "" "" "" "")
     #(#x1fae "" "" "" "")
     #(#x1faf "" "" "" "")
     #(#x1fb2 "" "" "" "")
     #(#x1fb3 "" "" "" "")
     #(#x1fb4 "" "" "" "")
     #(#x1fb6 "" "" "" "")
     #(#x1fb7 "" "" "" "")
     #(#x1fbc "" "" "" "")
     #(#x1fc2 "" "" "" "")
     #(#x1fc3 "" "" "" "")
     #(#x1fc4 "" "" "" "")
     #(#x1fc6 "" "" "" "")
     #(#x1fc7 "" "" "" "")
     #(#x1fcc "" "" "" "")
     #(#x1fd2 "" "" "" "")
     #(#x1fd3 "" "" "" "")
     #(#x1fd6 "" "" "" "")
     #(#x1fd7 "" "" "" "")
     #(#x1fe2 "" "" "" "")
     #(#x1fe3 "" "" "" "")
     #(#x1fe4 "" "" "" "")
     #(#x1fe6 "" "" "" "")
     #(#x1fe7 "" "" "" "")
     #(#x1ff2 "" "" "" "")
     #(#x1ff3 "" "" "" "")
     #(#x1ff4 "" "" "" "")
     #(#x1ff6 "" "" "" "")
     #(#x1ff7 "" "" "" "")
     #(#x1ffc "" "" "" "")
     #(#xfb00 "" "Ff" "FF" "ff")
     #(#xfb01 "" "Fi" "FI" "fi")
     #(#xfb02 "" "Fl" "FL" "fl")
     #(#xfb03 "" "Ffi" "FFI" "ffi")
     #(#xfb04 "" "Ffl" "FFL" "ffl")
     #(#xfb05 "" "St" "ST" "st")
     #(#xfb06 "" "St" "ST" "st")
     #(#xfb13 "" "" "" "")
     #(#xfb14 "" "" "" "")
     #(#xfb15 "" "" "" "")
     #(#xfb16 "" "" "" "")
     #(#xfb17 "" "" "" "")
  ))
;; auto-generated by extract-case-offsets.scm

(define char-downcase-offsets (list (cons (%make-iset 8579 8579 #f (%make-iset 880 1326 242279574765202296849774602627805799045871610517108506109792008705054922007599484790559595901393133839376706840989092433857043480182853 (%make-iset 256 590 46620119969431228644100221389637723687450896370752335113822859777025626952209321538335201863828591957 #f #f) (%make-iset 7680 7934 38597363079105398474523661669075944487877262569105979164236916827797859947861 #f #f)) (%make-iset 42560 42650 1650586712898282464877040981 (%make-iset 11360 11506 92689287070683147437146300401934387177065089 #f #f) (%make-iset 42786 42997 3291009114642647507835646461869218451394993306947919553183946069 #f #f))) 1) (cons (%make-iset 65313 65338 #f (%make-iset 913 1071 730750818495310275641373184626454206112216252415 (%make-iset 65 222 363948161469878586209393690477933956061783392255 #f #f) #f) (%make-iset 93760 93791 #f (%make-iset 71840 71871 #f #f #f) #f)) 32) (cons (%make-iset 11264 11310 #f (%make-iset 1329 1366 #f #f #f) #f) 48) (cons (%make-iset 5024 5103 #f #f #f) 38864) (cons (%make-iset 7944 8169 80881074129870198004135178138284625259741180096154048608512860160255 #f #f) -8) (cons (%make-iset 66736 66771 #f (%make-iset 66560 66599 #f #f #f) #f) 40) (cons (%make-iset 68736 68786 #f (%make-iset 908 908 #f #f #f) #f) 64) (cons (%make-iset 7312 7359 255086697644031 #f #f) -3008) (cons (%make-iset 4256 4301 36009005809663 #f #f) 7264) (cons (%make-iset 125184 125217 #f #f #f) 34) (cons (%make-iset 9398 9423 #f #f #f) 26)))

(define char-downcase-map
  '#(#x49 #x131 #x53 #x17f #x130 #x69 #x178 #xff #x181 #x253 #x186 #x254 #x189 #x256 #x18a #x257 #x18e #x1dd #x18f #x259 #x190 #x25b #x193 #x260 #x194 #x263 #x196 #x269 #x197 #x268 #x19c #x26f #x19d #x272 #x19f #x275 #x1a6 #x280 #x1a9 #x283 #x1ae #x288 #x1b1 #x28a #x1b2 #x28b #x1b7 #x292 #x1c4 #x1c6 #x1c5 #x1c6 #x1c7 #x1c9 #x1c8 #x1c9 #x1ca #x1cc #x1cb #x1cc #x1f1 #x1f3 #x1f2 #x1f3 #x1f6 #x195 #x1f7 #x1bf #x220 #x19e #x23a #x2c65 #x23d #x19a #x23e #x2c66 #x243 #x180 #x244 #x289 #x245 #x28c #x37f #x3f3 #x386 #x3ac #x388 #x3ad #x389 #x3ae #x38a #x3af #x38e #x3cd #x38f #x3ce #x392 #x3d0 #x395 #x3f5 #x398 #x3d1 #x399 #x345 #x399 #x1fbe #x39a #x3f0 #x39c #xb5 #x3a0 #x3d6 #x3a1 #x3f1 #x3a3 #x3c2 #x3a6 #x3d5 #x3cf #x3d7 #x3f4 #x3b8 #x3f9 #x3f2 #x3fd #x37b #x3fe #x37c #x3ff #x37d #x400 #x450 #x401 #x451 #x402 #x452 #x403 #x453 #x404 #x454 #x405 #x455 #x406 #x456 #x407 #x457 #x408 #x458 #x409 #x459 #x40a #x45a #x40b #x45b #x40c #x45c #x40d #x45d #x40e #x45e #x40f #x45f #x412 #x1c80 #x414 #x1c81 #x41e #x1c82 #x421 #x1c83 #x422 #x1c84 #x422 #x1c85 #x42a #x1c86 #x462 #x1c87 #x4c0 #x4cf #x13f0 #x13f8 #x13f1 #x13f9 #x13f2 #x13fa #x13f3 #x13fb #x13f4 #x13fc #x13f5 #x13fd #x1e60 #x1e9b #x1e9e #xdf #x1f88 #x1f80 #x1f89 #x1f81 #x1f8a #x1f82 #x1f8b #x1f83 #x1f8c #x1f84 #x1f8d #x1f85 #x1f8e #x1f86 #x1f8f #x1f87 #x1f98 #x1f90 #x1f99 #x1f91 #x1f9a #x1f92 #x1f9b #x1f93 #x1f9c #x1f94 #x1f9d #x1f95 #x1f9e #x1f96 #x1f9f #x1f97 #x1fa8 #x1fa0 #x1fa9 #x1fa1 #x1faa #x1fa2 #x1fab #x1fa3 #x1fac #x1fa4 #x1fad #x1fa5 #x1fae #x1fa6 #x1faf #x1fa7 #x1fba #x1f70 #x1fbb #x1f71 #x1fbc #x1fb3 #x1fbc #x1fb3 #x1fc8 #x1f72 #x1fc9 #x1f73 #x1fca #x1f74 #x1fcb #x1f75 #x1fcc #x1fc3 #x1fcc #x1fc3 #x1fda #x1f76 #x1fdb #x1f77 #x1fea #x1f7a #x1feb #x1f7b #x1fec #x1fe5 #x1ff8 #x1f78 #x1ff9 #x1f79 #x1ffa #x1f7c #x1ffb #x1f7d #x1ffc #x1ff3 #x1ffc #x1ff3 #x2126 #x3c9 #x212a #x6b #x212b #xe5 #x2132 #x214e #x2160 #x2170 #x2161 #x2171 #x2162 #x2172 #x2163 #x2173 #x2164 #x2174 #x2165 #x2175 #x2166 #x2176 #x2167 #x2177 #x2168 #x2178 #x2169 #x2179 #x216a #x217a #x216b #x217b #x216c #x217c #x216d #x217d #x216e #x217e #x216f #x217f #x2c62 #x26b #x2c63 #x1d7d #x2c64 #x27d #x2c6d #x251 #x2c6e #x271 #x2c6f #x250 #x2c70 #x252 #x2c7e #x23f #x2c7f #x240 #xa64a #x1c88 #xa77d #x1d79 #xa78d #x265 #xa7aa #x266 #xa7ab #x25c #xa7ac #x261 #xa7ad #x26c #xa7ae #x26a #xa7b0 #x29e #xa7b1 #x287 #xa7b2 #x29d #xa7b3 #xab53 #xa7c4 #xa794 #xa7c5 #x282 #xa7c6 #x1d8e))

(define char-upcase-map
  '#(#x69 #x130 #x6b #x212a #xb5 #x39c #xdf #x1e9e #xe5 #x212b #xff #x178 #x131 #x49 #x17f #x53 #x180 #x243 #x195 #x1f6 #x19a #x23d #x19e #x220 #x1bf #x1f7 #x1c5 #x1c4 #x1c6 #x1c4 #x1c8 #x1c7 #x1c9 #x1c7 #x1cb #x1ca #x1cc #x1ca #x1dd #x18e #x1f2 #x1f1 #x1f3 #x1f1 #x23f #x2c7e #x240 #x2c7f #x250 #x2c6f #x251 #x2c6d #x252 #x2c70 #x253 #x181 #x254 #x186 #x256 #x189 #x257 #x18a #x259 #x18f #x25b #x190 #x25c #xa7ab #x260 #x193 #x261 #xa7ac #x263 #x194 #x265 #xa78d #x266 #xa7aa #x268 #x197 #x269 #x196 #x26a #xa7ae #x26b #x2c62 #x26c #xa7ad #x26f #x19c #x271 #x2c6e #x272 #x19d #x275 #x19f #x27d #x2c64 #x280 #x1a6 #x282 #xa7c5 #x283 #x1a9 #x287 #xa7b1 #x288 #x1ae #x289 #x244 #x28a #x1b1 #x28b #x1b2 #x28c #x245 #x292 #x1b7 #x29d #xa7b2 #x29e #xa7b0 #x345 #x399 #x37b #x3fd #x37c #x3fe #x37d #x3ff #x3ac #x386 #x3ad #x388 #x3ae #x389 #x3af #x38a #x3b8 #x3f4 #x3c2 #x3a3 #x3c9 #x2126 #x3cd #x38e #x3ce #x38f #x3d0 #x392 #x3d1 #x398 #x3d5 #x3a6 #x3d6 #x3a0 #x3d7 #x3cf #x3f0 #x39a #x3f1 #x3a1 #x3f2 #x3f9 #x3f3 #x37f #x3f5 #x395 #x450 #x400 #x451 #x401 #x452 #x402 #x453 #x403 #x454 #x404 #x455 #x405 #x456 #x406 #x457 #x407 #x458 #x408 #x459 #x409 #x45a #x40a #x45b #x40b #x45c #x40c #x45d #x40d #x45e #x40e #x45f #x40f #x4cf #x4c0 #x13f8 #x13f0 #x13f9 #x13f1 #x13fa #x13f2 #x13fb #x13f3 #x13fc #x13f4 #x13fd #x13f5 #x1c80 #x412 #x1c81 #x414 #x1c82 #x41e #x1c83 #x421 #x1c84 #x422 #x1c85 #x422 #x1c86 #x42a #x1c87 #x462 #x1c88 #xa64a #x1d79 #xa77d #x1d7d #x2c63 #x1d8e #xa7c6 #x1e9b #x1e60 #x1f70 #x1fba #x1f71 #x1fbb #x1f72 #x1fc8 #x1f73 #x1fc9 #x1f74 #x1fca #x1f75 #x1fcb #x1f76 #x1fda #x1f77 #x1fdb #x1f78 #x1ff8 #x1f79 #x1ff9 #x1f7a #x1fea #x1f7b #x1feb #x1f7c #x1ffa #x1f7d #x1ffb #x1fb3 #x1fbc #x1fbe #x399 #x1fc3 #x1fcc #x1fe5 #x1fec #x1ff3 #x1ffc #x214e #x2132 #x2170 #x2160 #x2171 #x2161 #x2172 #x2162 #x2173 #x2163 #x2174 #x2164 #x2175 #x2165 #x2176 #x2166 #x2177 #x2167 #x2178 #x2168 #x2179 #x2169 #x217a #x216a #x217b #x216b #x217c #x216c #x217d #x216d #x217e #x216e #x217f #x216f #x2c65 #x23a #x2c66 #x23e #xa794 #xa7c4 #xab53 #xa7b3))

(define char-foldcase-map
  '#(#x41 #x61 #x42 #x62 #x43 #x63 #x44 #x64 #x45 #x65 #x46 #x66 #x47 #x67 #x48 #x68 #x49 #x69 #x4a #x6a #x4b #x6b #x4c #x6c #x4d #x6d #x4e #x6e #x4f #x6f #x50 #x70 #x51 #x71 #x52 #x72 #x53 #x73 #x54 #x74 #x55 #x75 #x56 #x76 #x57 #x77 #x58 #x78 #x59 #x79 #x5a #x7a #xb5 #x3bc #xc0 #xe0 #xc1 #xe1 #xc2 #xe2 #xc3 #xe3 #xc4 #xe4 #xc5 #xe5 #xc6 #xe6 #xc7 #xe7 #xc8 #xe8 #xc9 #xe9 #xca #xea #xcb #xeb #xcc #xec #xcd #xed #xce #xee #xcf #xef #xd0 #xf0 #xd1 #xf1 #xd2 #xf2 #xd3 #xf3 #xd4 #xf4 #xd5 #xf5 #xd6 #xf6 #xd8 #xf8 #xd9 #xf9 #xda #xfa #xdb #xfb #xdc #xfc #xdd #xfd #xde #xfe #x100 #x101 #x102 #x103 #x104 #x105 #x106 #x107 #x108 #x109 #x10a #x10b #x10c #x10d #x10e #x10f #x110 #x111 #x112 #x113 #x114 #x115 #x116 #x117 #x118 #x119 #x11a #x11b #x11c #x11d #x11e #x11f #x120 #x121 #x122 #x123 #x124 #x125 #x126 #x127 #x128 #x129 #x12a #x12b #x12c #x12d #x12e #x12f #x132 #x133 #x134 #x135 #x136 #x137 #x139 #x13a #x13b #x13c #x13d #x13e #x13f #x140 #x141 #x142 #x143 #x144 #x145 #x146 #x147 #x148 #x14a #x14b #x14c #x14d #x14e #x14f #x150 #x151 #x152 #x153 #x154 #x155 #x156 #x157 #x158 #x159 #x15a #x15b #x15c #x15d #x15e #x15f #x160 #x161 #x162 #x163 #x164 #x165 #x166 #x167 #x168 #x169 #x16a #x16b #x16c #x16d #x16e #x16f #x170 #x171 #x172 #x173 #x174 #x175 #x176 #x177 #x178 #xff #x179 #x17a #x17b #x17c #x17d #x17e #x17f #x73 #x181 #x253 #x182 #x183 #x184 #x185 #x186 #x254 #x187 #x188 #x189 #x256 #x18a #x257 #x18b #x18c #x18e #x1dd #x18f #x259 #x190 #x25b #x191 #x192 #x193 #x260 #x194 #x263 #x196 #x269 #x197 #x268 #x198 #x199 #x19c #x26f #x19d #x272 #x19f #x275 #x1a0 #x1a1 #x1a2 #x1a3 #x1a4 #x1a5 #x1a6 #x280 #x1a7 #x1a8 #x1a9 #x283 #x1ac #x1ad #x1ae #x288 #x1af #x1b0 #x1b1 #x28a #x1b2 #x28b #x1b3 #x1b4 #x1b5 #x1b6 #x1b7 #x292 #x1b8 #x1b9 #x1bc #x1bd #x1c4 #x1c6 #x1c5 #x1c6 #x1c7 #x1c9 #x1c8 #x1c9 #x1ca #x1cc #x1cb #x1cc #x1cd #x1ce #x1cf #x1d0 #x1d1 #x1d2 #x1d3 #x1d4 #x1d5 #x1d6 #x1d7 #x1d8 #x1d9 #x1da #x1db #x1dc #x1de #x1df #x1e0 #x1e1 #x1e2 #x1e3 #x1e4 #x1e5 #x1e6 #x1e7 #x1e8 #x1e9 #x1ea #x1eb #x1ec #x1ed #x1ee #x1ef #x1f1 #x1f3 #x1f2 #x1f3 #x1f4 #x1f5 #x1f6 #x195 #x1f7 #x1bf #x1f8 #x1f9 #x1fa #x1fb #x1fc #x1fd #x1fe #x1ff #x200 #x201 #x202 #x203 #x204 #x205 #x206 #x207 #x208 #x209 #x20a #x20b #x20c #x20d #x20e #x20f #x210 #x211 #x212 #x213 #x214 #x215 #x216 #x217 #x218 #x219 #x21a #x21b #x21c #x21d #x21e #x21f #x220 #x19e #x222 #x223 #x224 #x225 #x226 #x227 #x228 #x229 #x22a #x22b #x22c #x22d #x22e #x22f #x230 #x231 #x232 #x233 #x23a #x2c65 #x23b #x23c #x23d #x19a #x23e #x2c66 #x241 #x242 #x243 #x180 #x244 #x289 #x245 #x28c #x246 #x247 #x248 #x249 #x24a #x24b #x24c #x24d #x24e #x24f #x345 #x3b9 #x370 #x371 #x372 #x373 #x376 #x377 #x37f #x3f3 #x386 #x3ac #x388 #x3ad #x389 #x3ae #x38a #x3af #x38c #x3cc #x38e #x3cd #x38f #x3ce #x391 #x3b1 #x392 #x3b2 #x393 #x3b3 #x394 #x3b4 #x395 #x3b5 #x396 #x3b6 #x397 #x3b7 #x398 #x3b8 #x399 #x3b9 #x39a #x3ba #x39b #x3bb #x39c #x3bc #x39d #x3bd #x39e #x3be #x39f #x3bf #x3a0 #x3c0 #x3a1 #x3c1 #x3a3 #x3c3 #x3a4 #x3c4 #x3a5 #x3c5 #x3a6 #x3c6 #x3a7 #x3c7 #x3a8 #x3c8 #x3a9 #x3c9 #x3aa #x3ca #x3ab #x3cb #x3c2 #x3c3 #x3cf #x3d7 #x3d0 #x3b2 #x3d1 #x3b8 #x3d5 #x3c6 #x3d6 #x3c0 #x3d8 #x3d9 #x3da #x3db #x3dc #x3dd #x3de #x3df #x3e0 #x3e1 #x3e2 #x3e3 #x3e4 #x3e5 #x3e6 #x3e7 #x3e8 #x3e9 #x3ea #x3eb #x3ec #x3ed #x3ee #x3ef #x3f0 #x3ba #x3f1 #x3c1 #x3f4 #x3b8 #x3f5 #x3b5 #x3f7 #x3f8 #x3f9 #x3f2 #x3fa #x3fb #x3fd #x37b #x3fe #x37c #x3ff #x37d #x400 #x450 #x401 #x451 #x402 #x452 #x403 #x453 #x404 #x454 #x405 #x455 #x406 #x456 #x407 #x457 #x408 #x458 #x409 #x459 #x40a #x45a #x40b #x45b #x40c #x45c #x40d #x45d #x40e #x45e #x40f #x45f #x410 #x430 #x411 #x431 #x412 #x432 #x413 #x433 #x414 #x434 #x415 #x435 #x416 #x436 #x417 #x437 #x418 #x438 #x419 #x439 #x41a #x43a #x41b #x43b #x41c #x43c #x41d #x43d #x41e #x43e #x41f #x43f #x420 #x440 #x421 #x441 #x422 #x442 #x423 #x443 #x424 #x444 #x425 #x445 #x426 #x446 #x427 #x447 #x428 #x448 #x429 #x449 #x42a #x44a #x42b #x44b #x42c #x44c #x42d #x44d #x42e #x44e #x42f #x44f #x460 #x461 #x462 #x463 #x464 #x465 #x466 #x467 #x468 #x469 #x46a #x46b #x46c #x46d #x46e #x46f #x470 #x471 #x472 #x473 #x474 #x475 #x476 #x477 #x478 #x479 #x47a #x47b #x47c #x47d #x47e #x47f #x480 #x481 #x48a #x48b #x48c #x48d #x48e #x48f #x490 #x491 #x492 #x493 #x494 #x495 #x496 #x497 #x498 #x499 #x49a #x49b #x49c #x49d #x49e #x49f #x4a0 #x4a1 #x4a2 #x4a3 #x4a4 #x4a5 #x4a6 #x4a7 #x4a8 #x4a9 #x4aa #x4ab #x4ac #x4ad #x4ae #x4af #x4b0 #x4b1 #x4b2 #x4b3 #x4b4 #x4b5 #x4b6 #x4b7 #x4b8 #x4b9 #x4ba #x4bb #x4bc #x4bd #x4be #x4bf #x4c0 #x4cf #x4c1 #x4c2 #x4c3 #x4c4 #x4c5 #x4c6 #x4c7 #x4c8 #x4c9 #x4ca #x4cb #x4cc #x4cd #x4ce #x4d0 #x4d1 #x4d2 #x4d3 #x4d4 #x4d5 #x4d6 #x4d7 #x4d8 #x4d9 #x4da #x4db #x4dc #x4dd #x4de #x4df #x4e0 #x4e1 #x4e2 #x4e3 #x4e4 #x4e5 #x4e6 #x4e7 #x4e8 #x4e9 #x4ea #x4eb #x4ec #x4ed #x4ee #x4ef #x4f0 #x4f1 #x4f2 #x4f3 #x4f4 #x4f5 #x4f6 #x4f7 #x4f8 #x4f9 #x4fa #x4fb #x4fc #x4fd #x4fe #x4ff #x500 #x501 #x502 #x503 #x504 #x505 #x506 #x507 #x508 #x509 #x50a #x50b #x50c #x50d #x50e #x50f #x510 #x511 #x512 #x513 #x514 #x515 #x516 #x517 #x518 #x519 #x51a #x51b #x51c #x51d #x51e #x51f #x520 #x521 #x522 #x523 #x524 #x525 #x526 #x527 #x528 #x529 #x52a #x52b #x52c #x52d #x52e #x52f #x531 #x561 #x532 #x562 #x533 #x563 #x534 #x564 #x535 #x565 #x536 #x566 #x537 #x567 #x538 #x568 #x539 #x569 #x53a #x56a #x53b #x56b #x53c #x56c #x53d #x56d #x53e #x56e #x53f #x56f #x540 #x570 #x541 #x571 #x542 #x572 #x543 #x573 #x544 #x574 #x545 #x575 #x546 #x576 #x547 #x577 #x548 #x578 #x549 #x579 #x54a #x57a #x54b #x57b #x54c #x57c #x54d #x57d #x54e #x57e #x54f #x57f #x550 #x580 #x551 #x581 #x552 #x582 #x553 #x583 #x554 #x584 #x555 #x585 #x556 #x586 #x10a0 #x2d00 #x10a1 #x2d01 #x10a2 #x2d02 #x10a3 #x2d03 #x10a4 #x2d04 #x10a5 #x2d05 #x10a6 #x2d06 #x10a7 #x2d07 #x10a8 #x2d08 #x10a9 #x2d09 #x10aa #x2d0a #x10ab #x2d0b #x10ac #x2d0c #x10ad #x2d0d #x10ae #x2d0e #x10af #x2d0f #x10b0 #x2d10 #x10b1 #x2d11 #x10b2 #x2d12 #x10b3 #x2d13 #x10b4 #x2d14 #x10b5 #x2d15 #x10b6 #x2d16 #x10b7 #x2d17 #x10b8 #x2d18 #x10b9 #x2d19 #x10ba #x2d1a #x10bb #x2d1b #x10bc #x2d1c #x10bd #x2d1d #x10be #x2d1e #x10bf #x2d1f #x10c0 #x2d20 #x10c1 #x2d21 #x10c2 #x2d22 #x10c3 #x2d23 #x10c4 #x2d24 #x10c5 #x2d25 #x10c7 #x2d27 #x10cd #x2d2d #x13f8 #x13f0 #x13f9 #x13f1 #x13fa #x13f2 #x13fb #x13f3 #x13fc #x13f4 #x13fd #x13f5 #x1c80 #x432 #x1c81 #x434 #x1c82 #x43e #x1c83 #x441 #x1c84 #x442 #x1c85 #x442 #x1c86 #x44a #x1c87 #x463 #x1c88 #xa64b #x1c90 #x10d0 #x1c91 #x10d1 #x1c92 #x10d2 #x1c93 #x10d3 #x1c94 #x10d4 #x1c95 #x10d5 #x1c96 #x10d6 #x1c97 #x10d7 #x1c98 #x10d8 #x1c99 #x10d9 #x1c9a #x10da #x1c9b #x10db #x1c9c #x10dc #x1c9d #x10dd #x1c9e #x10de #x1c9f #x10df #x1ca0 #x10e0 #x1ca1 #x10e1 #x1ca2 #x10e2 #x1ca3 #x10e3 #x1ca4 #x10e4 #x1ca5 #x10e5 #x1ca6 #x10e6 #x1ca7 #x10e7 #x1ca8 #x10e8 #x1ca9 #x10e9 #x1caa #x10ea #x1cab #x10eb #x1cac #x10ec #x1cad #x10ed #x1cae #x10ee #x1caf #x10ef #x1cb0 #x10f0 #x1cb1 #x10f1 #x1cb2 #x10f2 #x1cb3 #x10f3 #x1cb4 #x10f4 #x1cb5 #x10f5 #x1cb6 #x10f6 #x1cb7 #x10f7 #x1cb8 #x10f8 #x1cb9 #x10f9 #x1cba #x10fa #x1cbd #x10fd #x1cbe #x10fe #x1cbf #x10ff #x1e00 #x1e01 #x1e02 #x1e03 #x1e04 #x1e05 #x1e06 #x1e07 #x1e08 #x1e09 #x1e0a #x1e0b #x1e0c #x1e0d #x1e0e #x1e0f #x1e10 #x1e11 #x1e12 #x1e13 #x1e14 #x1e15 #x1e16 #x1e17 #x1e18 #x1e19 #x1e1a #x1e1b #x1e1c #x1e1d #x1e1e #x1e1f #x1e20 #x1e21 #x1e22 #x1e23 #x1e24 #x1e25 #x1e26 #x1e27 #x1e28 #x1e29 #x1e2a #x1e2b #x1e2c #x1e2d #x1e2e #x1e2f #x1e30 #x1e31 #x1e32 #x1e33 #x1e34 #x1e35 #x1e36 #x1e37 #x1e38 #x1e39 #x1e3a #x1e3b #x1e3c #x1e3d #x1e3e #x1e3f #x1e40 #x1e41 #x1e42 #x1e43 #x1e44 #x1e45 #x1e46 #x1e47 #x1e48 #x1e49 #x1e4a #x1e4b #x1e4c #x1e4d #x1e4e #x1e4f #x1e50 #x1e51 #x1e52 #x1e53 #x1e54 #x1e55 #x1e56 #x1e57 #x1e58 #x1e59 #x1e5a #x1e5b #x1e5c #x1e5d #x1e5e #x1e5f #x1e60 #x1e61 #x1e62 #x1e63 #x1e64 #x1e65 #x1e66 #x1e67 #x1e68 #x1e69 #x1e6a #x1e6b #x1e6c #x1e6d #x1e6e #x1e6f #x1e70 #x1e71 #x1e72 #x1e73 #x1e74 #x1e75 #x1e76 #x1e77 #x1e78 #x1e79 #x1e7a #x1e7b #x1e7c #x1e7d #x1e7e #x1e7f #x1e80 #x1e81 #x1e82 #x1e83 #x1e84 #x1e85 #x1e86 #x1e87 #x1e88 #x1e89 #x1e8a #x1e8b #x1e8c #x1e8d #x1e8e #x1e8f #x1e90 #x1e91 #x1e92 #x1e93 #x1e94 #x1e95 #x1e9b #x1e61 #x1e9e #xdf #x1ea0 #x1ea1 #x1ea2 #x1ea3 #x1ea4 #x1ea5 #x1ea6 #x1ea7 #x1ea8 #x1ea9 #x1eaa #x1eab #x1eac #x1ead #x1eae #x1eaf #x1eb0 #x1eb1 #x1eb2 #x1eb3 #x1eb4 #x1eb5 #x1eb6 #x1eb7 #x1eb8 #x1eb9 #x1eba #x1ebb #x1ebc #x1ebd #x1ebe #x1ebf #x1ec0 #x1ec1 #x1ec2 #x1ec3 #x1ec4 #x1ec5 #x1ec6 #x1ec7 #x1ec8 #x1ec9 #x1eca #x1ecb #x1ecc #x1ecd #x1ece #x1ecf #x1ed0 #x1ed1 #x1ed2 #x1ed3 #x1ed4 #x1ed5 #x1ed6 #x1ed7 #x1ed8 #x1ed9 #x1eda #x1edb #x1edc #x1edd #x1ede #x1edf #x1ee0 #x1ee1 #x1ee2 #x1ee3 #x1ee4 #x1ee5 #x1ee6 #x1ee7 #x1ee8 #x1ee9 #x1eea #x1eeb #x1eec #x1eed #x1eee #x1eef #x1ef0 #x1ef1 #x1ef2 #x1ef3 #x1ef4 #x1ef5 #x1ef6 #x1ef7 #x1ef8 #x1ef9 #x1efa #x1efb #x1efc #x1efd #x1efe #x1eff #x1f08 #x1f00 #x1f09 #x1f01 #x1f0a #x1f02 #x1f0b #x1f03 #x1f0c #x1f04 #x1f0d #x1f05 #x1f0e #x1f06 #x1f0f #x1f07 #x1f18 #x1f10 #x1f19 #x1f11 #x1f1a #x1f12 #x1f1b #x1f13 #x1f1c #x1f14 #x1f1d #x1f15 #x1f28 #x1f20 #x1f29 #x1f21 #x1f2a #x1f22 #x1f2b #x1f23 #x1f2c #x1f24 #x1f2d #x1f25 #x1f2e #x1f26 #x1f2f #x1f27 #x1f38 #x1f30 #x1f39 #x1f31 #x1f3a #x1f32 #x1f3b #x1f33 #x1f3c #x1f34 #x1f3d #x1f35 #x1f3e #x1f36 #x1f3f #x1f37 #x1f48 #x1f40 #x1f49 #x1f41 #x1f4a #x1f42 #x1f4b #x1f43 #x1f4c #x1f44 #x1f4d #x1f45 #x1f59 #x1f51 #x1f5b #x1f53 #x1f5d #x1f55 #x1f5f #x1f57 #x1f68 #x1f60 #x1f69 #x1f61 #x1f6a #x1f62 #x1f6b #x1f63 #x1f6c #x1f64 #x1f6d #x1f65 #x1f6e #x1f66 #x1f6f #x1f67 #x1f88 #x1f80 #x1f89 #x1f81 #x1f8a #x1f82 #x1f8b #x1f83 #x1f8c #x1f84 #x1f8d #x1f85 #x1f8e #x1f86 #x1f8f #x1f87 #x1f98 #x1f90 #x1f99 #x1f91 #x1f9a #x1f92 #x1f9b #x1f93 #x1f9c #x1f94 #x1f9d #x1f95 #x1f9e #x1f96 #x1f9f #x1f97 #x1fa8 #x1fa0 #x1fa9 #x1fa1 #x1faa #x1fa2 #x1fab #x1fa3 #x1fac #x1fa4 #x1fad #x1fa5 #x1fae #x1fa6 #x1faf #x1fa7 #x1fb8 #x1fb0 #x1fb9 #x1fb1 #x1fba #x1f70 #x1fbb #x1f71 #x1fbc #x1fb3 #x1fbe #x3b9 #x1fc8 #x1f72 #x1fc9 #x1f73 #x1fca #x1f74 #x1fcb #x1f75 #x1fcc #x1fc3 #x1fd8 #x1fd0 #x1fd9 #x1fd1 #x1fda #x1f76 #x1fdb #x1f77 #x1fe8 #x1fe0 #x1fe9 #x1fe1 #x1fea #x1f7a #x1feb #x1f7b #x1fec #x1fe5 #x1ff8 #x1f78 #x1ff9 #x1f79 #x1ffa #x1f7c #x1ffb #x1f7d #x1ffc #x1ff3 #x2126 #x3c9 #x212a #x6b #x212b #xe5 #x2132 #x214e #x2160 #x2170 #x2161 #x2171 #x2162 #x2172 #x2163 #x2173 #x2164 #x2174 #x2165 #x2175 #x2166 #x2176 #x2167 #x2177 #x2168 #x2178 #x2169 #x2179 #x216a #x217a #x216b #x217b #x216c #x217c #x216d #x217d #x216e #x217e #x216f #x217f #x2183 #x2184 #x24b6 #x24d0 #x24b7 #x24d1 #x24b8 #x24d2 #x24b9 #x24d3 #x24ba #x24d4 #x24bb #x24d5 #x24bc #x24d6 #x24bd #x24d7 #x24be #x24d8 #x24bf #x24d9 #x24c0 #x24da #x24c1 #x24db #x24c2 #x24dc #x24c3 #x24dd #x24c4 #x24de #x24c5 #x24df #x24c6 #x24e0 #x24c7 #x24e1 #x24c8 #x24e2 #x24c9 #x24e3 #x24ca #x24e4 #x24cb #x24e5 #x24cc #x24e6 #x24cd #x24e7 #x24ce #x24e8 #x24cf #x24e9 #x2c00 #x2c30 #x2c01 #x2c31 #x2c02 #x2c32 #x2c03 #x2c33 #x2c04 #x2c34 #x2c05 #x2c35 #x2c06 #x2c36 #x2c07 #x2c37 #x2c08 #x2c38 #x2c09 #x2c39 #x2c0a #x2c3a #x2c0b #x2c3b #x2c0c #x2c3c #x2c0d #x2c3d #x2c0e #x2c3e #x2c0f #x2c3f #x2c10 #x2c40 #x2c11 #x2c41 #x2c12 #x2c42 #x2c13 #x2c43 #x2c14 #x2c44 #x2c15 #x2c45 #x2c16 #x2c46 #x2c17 #x2c47 #x2c18 #x2c48 #x2c19 #x2c49 #x2c1a #x2c4a #x2c1b #x2c4b #x2c1c #x2c4c #x2c1d #x2c4d #x2c1e #x2c4e #x2c1f #x2c4f #x2c20 #x2c50 #x2c21 #x2c51 #x2c22 #x2c52 #x2c23 #x2c53 #x2c24 #x2c54 #x2c25 #x2c55 #x2c26 #x2c56 #x2c27 #x2c57 #x2c28 #x2c58 #x2c29 #x2c59 #x2c2a #x2c5a #x2c2b #x2c5b #x2c2c #x2c5c #x2c2d #x2c5d #x2c2e #x2c5e #x2c60 #x2c61 #x2c62 #x26b #x2c63 #x1d7d #x2c64 #x27d #x2c67 #x2c68 #x2c69 #x2c6a #x2c6b #x2c6c #x2c6d #x251 #x2c6e #x271 #x2c6f #x250 #x2c70 #x252 #x2c72 #x2c73 #x2c75 #x2c76 #x2c7e #x23f #x2c7f #x240 #x2c80 #x2c81 #x2c82 #x2c83 #x2c84 #x2c85 #x2c86 #x2c87 #x2c88 #x2c89 #x2c8a #x2c8b #x2c8c #x2c8d #x2c8e #x2c8f #x2c90 #x2c91 #x2c92 #x2c93 #x2c94 #x2c95 #x2c96 #x2c97 #x2c98 #x2c99 #x2c9a #x2c9b #x2c9c #x2c9d #x2c9e #x2c9f #x2ca0 #x2ca1 #x2ca2 #x2ca3 #x2ca4 #x2ca5 #x2ca6 #x2ca7 #x2ca8 #x2ca9 #x2caa #x2cab #x2cac #x2cad #x2cae #x2caf #x2cb0 #x2cb1 #x2cb2 #x2cb3 #x2cb4 #x2cb5 #x2cb6 #x2cb7 #x2cb8 #x2cb9 #x2cba #x2cbb #x2cbc #x2cbd #x2cbe #x2cbf #x2cc0 #x2cc1 #x2cc2 #x2cc3 #x2cc4 #x2cc5 #x2cc6 #x2cc7 #x2cc8 #x2cc9 #x2cca #x2ccb #x2ccc #x2ccd #x2cce #x2ccf #x2cd0 #x2cd1 #x2cd2 #x2cd3 #x2cd4 #x2cd5 #x2cd6 #x2cd7 #x2cd8 #x2cd9 #x2cda #x2cdb #x2cdc #x2cdd #x2cde #x2cdf #x2ce0 #x2ce1 #x2ce2 #x2ce3 #x2ceb #x2cec #x2ced #x2cee #x2cf2 #x2cf3 #xa640 #xa641 #xa642 #xa643 #xa644 #xa645 #xa646 #xa647 #xa648 #xa649 #xa64a #xa64b #xa64c #xa64d #xa64e #xa64f #xa650 #xa651 #xa652 #xa653 #xa654 #xa655 #xa656 #xa657 #xa658 #xa659 #xa65a #xa65b #xa65c #xa65d #xa65e #xa65f #xa660 #xa661 #xa662 #xa663 #xa664 #xa665 #xa666 #xa667 #xa668 #xa669 #xa66a #xa66b #xa66c #xa66d #xa680 #xa681 #xa682 #xa683 #xa684 #xa685 #xa686 #xa687 #xa688 #xa689 #xa68a #xa68b #xa68c #xa68d #xa68e #xa68f #xa690 #xa691 #xa692 #xa693 #xa694 #xa695 #xa696 #xa697 #xa698 #xa699 #xa69a #xa69b #xa722 #xa723 #xa724 #xa725 #xa726 #xa727 #xa728 #xa729 #xa72a #xa72b #xa72c #xa72d #xa72e #xa72f #xa732 #xa733 #xa734 #xa735 #xa736 #xa737 #xa738 #xa739 #xa73a #xa73b #xa73c #xa73d #xa73e #xa73f #xa740 #xa741 #xa742 #xa743 #xa744 #xa745 #xa746 #xa747 #xa748 #xa749 #xa74a #xa74b #xa74c #xa74d #xa74e #xa74f #xa750 #xa751 #xa752 #xa753 #xa754 #xa755 #xa756 #xa757 #xa758 #xa759 #xa75a #xa75b #xa75c #xa75d #xa75e #xa75f #xa760 #xa761 #xa762 #xa763 #xa764 #xa765 #xa766 #xa767 #xa768 #xa769 #xa76a #xa76b #xa76c #xa76d #xa76e #xa76f #xa779 #xa77a #xa77b #xa77c #xa77d #x1d79 #xa77e #xa77f #xa780 #xa781 #xa782 #xa783 #xa784 #xa785 #xa786 #xa787 #xa78b #xa78c #xa78d #x265 #xa790 #xa791 #xa792 #xa793 #xa796 #xa797 #xa798 #xa799 #xa79a #xa79b #xa79c #xa79d #xa79e #xa79f #xa7a0 #xa7a1 #xa7a2 #xa7a3 #xa7a4 #xa7a5 #xa7a6 #xa7a7 #xa7a8 #xa7a9 #xa7aa #x266 #xa7ab #x25c #xa7ac #x261 #xa7ad #x26c #xa7ae #x26a #xa7b0 #x29e #xa7b1 #x287 #xa7b2 #x29d #xa7b3 #xab53 #xa7b4 #xa7b5 #xa7b6 #xa7b7 #xa7b8 #xa7b9 #xa7ba #xa7bb #xa7bc #xa7bd #xa7be #xa7bf #xa7c2 #xa7c3 #xa7c4 #xa794 #xa7c5 #x282 #xa7c6 #x1d8e #xa7c7 #xa7c8 #xa7c9 #xa7ca #xa7f5 #xa7f6 #xab70 #x13a0 #xab71 #x13a1 #xab72 #x13a2 #xab73 #x13a3 #xab74 #x13a4 #xab75 #x13a5 #xab76 #x13a6 #xab77 #x13a7 #xab78 #x13a8 #xab79 #x13a9 #xab7a #x13aa #xab7b #x13ab #xab7c #x13ac #xab7d #x13ad #xab7e #x13ae #xab7f #x13af #xab80 #x13b0 #xab81 #x13b1 #xab82 #x13b2 #xab83 #x13b3 #xab84 #x13b4 #xab85 #x13b5 #xab86 #x13b6 #xab87 #x13b7 #xab88 #x13b8 #xab89 #x13b9 #xab8a #x13ba #xab8b #x13bb #xab8c #x13bc #xab8d #x13bd #xab8e #x13be #xab8f #x13bf #xab90 #x13c0 #xab91 #x13c1 #xab92 #x13c2 #xab93 #x13c3 #xab94 #x13c4 #xab95 #x13c5 #xab96 #x13c6 #xab97 #x13c7 #xab98 #x13c8 #xab99 #x13c9 #xab9a #x13ca #xab9b #x13cb #xab9c #x13cc #xab9d #x13cd #xab9e #x13ce #xab9f #x13cf #xaba0 #x13d0 #xaba1 #x13d1 #xaba2 #x13d2 #xaba3 #x13d3 #xaba4 #x13d4 #xaba5 #x13d5 #xaba6 #x13d6 #xaba7 #x13d7 #xaba8 #x13d8 #xaba9 #x13d9 #xabaa #x13da #xabab #x13db #xabac #x13dc #xabad #x13dd #xabae #x13de #xabaf #x13df #xabb0 #x13e0 #xabb1 #x13e1 #xabb2 #x13e2 #xabb3 #x13e3 #xabb4 #x13e4 #xabb5 #x13e5 #xabb6 #x13e6 #xabb7 #x13e7 #xabb8 #x13e8 #xabb9 #x13e9 #xabba #x13ea #xabbb #x13eb #xabbc #x13ec #xabbd #x13ed #xabbe #x13ee #xabbf #x13ef #xff21 #xff41 #xff22 #xff42 #xff23 #xff43 #xff24 #xff44 #xff25 #xff45 #xff26 #xff46 #xff27 #xff47 #xff28 #xff48 #xff29 #xff49 #xff2a #xff4a #xff2b #xff4b #xff2c #xff4c #xff2d #xff4d #xff2e #xff4e #xff2f #xff4f #xff30 #xff50 #xff31 #xff51 #xff32 #xff52 #xff33 #xff53 #xff34 #xff54 #xff35 #xff55 #xff36 #xff56 #xff37 #xff57 #xff38 #xff58 #xff39 #xff59 #xff3a #xff5a #x10400 #x10428 #x10401 #x10429 #x10402 #x1042a #x10403 #x1042b #x10404 #x1042c #x10405 #x1042d #x10406 #x1042e #x10407 #x1042f #x10408 #x10430 #x10409 #x10431 #x1040a #x10432 #x1040b #x10433 #x1040c #x10434 #x1040d #x10435 #x1040e #x10436 #x1040f #x10437 #x10410 #x10438 #x10411 #x10439 #x10412 #x1043a #x10413 #x1043b #x10414 #x1043c #x10415 #x1043d #x10416 #x1043e #x10417 #x1043f #x10418 #x10440 #x10419 #x10441 #x1041a #x10442 #x1041b #x10443 #x1041c #x10444 #x1041d #x10445 #x1041e #x10446 #x1041f #x10447 #x10420 #x10448 #x10421 #x10449 #x10422 #x1044a #x10423 #x1044b #x10424 #x1044c #x10425 #x1044d #x10426 #x1044e #x10427 #x1044f #x104b0 #x104d8 #x104b1 #x104d9 #x104b2 #x104da #x104b3 #x104db #x104b4 #x104dc #x104b5 #x104dd #x104b6 #x104de #x104b7 #x104df #x104b8 #x104e0 #x104b9 #x104e1 #x104ba #x104e2 #x104bb #x104e3 #x104bc #x104e4 #x104bd #x104e5 #x104be #x104e6 #x104bf #x104e7 #x104c0 #x104e8 #x104c1 #x104e9 #x104c2 #x104ea #x104c3 #x104eb #x104c4 #x104ec #x104c5 #x104ed #x104c6 #x104ee #x104c7 #x104ef #x104c8 #x104f0 #x104c9 #x104f1 #x104ca #x104f2 #x104cb #x104f3 #x104cc #x104f4 #x104cd #x104f5 #x104ce #x104f6 #x104cf #x104f7 #x104d0 #x104f8 #x104d1 #x104f9 #x104d2 #x104fa #x104d3 #x104fb #x10c80 #x10cc0 #x10c81 #x10cc1 #x10c82 #x10cc2 #x10c83 #x10cc3 #x10c84 #x10cc4 #x10c85 #x10cc5 #x10c86 #x10cc6 #x10c87 #x10cc7 #x10c88 #x10cc8 #x10c89 #x10cc9 #x10c8a #x10cca #x10c8b #x10ccb #x10c8c #x10ccc #x10c8d #x10ccd #x10c8e #x10cce #x10c8f #x10ccf #x10c90 #x10cd0 #x10c91 #x10cd1 #x10c92 #x10cd2 #x10c93 #x10cd3 #x10c94 #x10cd4 #x10c95 #x10cd5 #x10c96 #x10cd6 #x10c97 #x10cd7 #x10c98 #x10cd8 #x10c99 #x10cd9 #x10c9a #x10cda #x10c9b #x10cdb #x10c9c #x10cdc #x10c9d #x10cdd #x10c9e #x10cde #x10c9f #x10cdf #x10ca0 #x10ce0 #x10ca1 #x10ce1 #x10ca2 #x10ce2 #x10ca3 #x10ce3 #x10ca4 #x10ce4 #x10ca5 #x10ce5 #x10ca6 #x10ce6 #x10ca7 #x10ce7 #x10ca8 #x10ce8 #x10ca9 #x10ce9 #x10caa #x10cea #x10cab #x10ceb #x10cac #x10cec #x10cad #x10ced #x10cae #x10cee #x10caf #x10cef #x10cb0 #x10cf0 #x10cb1 #x10cf1 #x10cb2 #x10cf2 #x118a0 #x118c0 #x118a1 #x118c1 #x118a2 #x118c2 #x118a3 #x118c3 #x118a4 #x118c4 #x118a5 #x118c5 #x118a6 #x118c6 #x118a7 #x118c7 #x118a8 #x118c8 #x118a9 #x118c9 #x118aa #x118ca #x118ab #x118cb #x118ac #x118cc #x118ad #x118cd #x118ae #x118ce #x118af #x118cf #x118b0 #x118d0 #x118b1 #x118d1 #x118b2 #x118d2 #x118b3 #x118d3 #x118b4 #x118d4 #x118b5 #x118d5 #x118b6 #x118d6 #x118b7 #x118d7 #x118b8 #x118d8 #x118b9 #x118d9 #x118ba #x118da #x118bb #x118db #x118bc #x118dc #x118bd #x118dd #x118be #x118de #x118bf #x118df #x16e40 #x16e60 #x16e41 #x16e61 #x16e42 #x16e62 #x16e43 #x16e63 #x16e44 #x16e64 #x16e45 #x16e65 #x16e46 #x16e66 #x16e47 #x16e67 #x16e48 #x16e68 #x16e49 #x16e69 #x16e4a #x16e6a #x16e4b #x16e6b #x16e4c #x16e6c #x16e4d #x16e6d #x16e4e #x16e6e #x16e4f #x16e6f #x16e50 #x16e70 #x16e51 #x16e71 #x16e52 #x16e72 #x16e53 #x16e73 #x16e54 #x16e74 #x16e55 #x16e75 #x16e56 #x16e76 #x16e57 #x16e77 #x16e58 #x16e78 #x16e59 #x16e79 #x16e5a #x16e7a #x16e5b #x16e7b #x16e5c #x16e7c #x16e5d #x16e7d #x16e5e #x16e7e #x16e5f #x16e7f #x1e900 #x1e922 #x1e901 #x1e923 #x1e902 #x1e924 #x1e903 #x1e925 #x1e904 #x1e926 #x1e905 #x1e927 #x1e906 #x1e928 #x1e907 #x1e929 #x1e908 #x1e92a #x1e909 #x1e92b #x1e90a #x1e92c #x1e90b #x1e92d #x1e90c #x1e92e #x1e90d #x1e92f #x1e90e #x1e930 #x1e90f #x1e931 #x1e910 #x1e932 #x1e911 #x1e933 #x1e912 #x1e934 #x1e913 #x1e935 #x1e914 #x1e936 #x1e915 #x1e937 #x1e916 #x1e938 #x1e917 #x1e939 #x1e918 #x1e93a #x1e919 #x1e93b #x1e91a #x1e93c #x1e91b #x1e93d #x1e91c #x1e93e #x1e91d #x1e93f #x1e91e #x1e940 #x1e91f #x1e941 #x1e920 #x1e942 #x1e921 #x1e943))
;;;; division.scm -- portable R7RS (scheme division) implementation
;;
;; This code is written by Alex Shinn and placed in the
;; Public Domain.  All warranties are disclaimed.
;;
;; This is basically the simplest possible implementation.  Note the
;; code below assumes that either 1) exact ratios are supported and
;; are handled correctly by floor, ceiling and round, or 2) that
;; you're using a simple implementation with only fixnums and flonums.
;; In the intermediate case where you have bignums but no ratios there
;; will be a loss of precision for large values.
;;
;; We handle both cases by the use of the cond-expand form in
;; division.sld to conditionally define copy-exactness2.  In case 1,
;; no adjustment is needed, whereas in case 2 we want to convert the
;; intermediate result back to exact if both inputs were exact.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Floor, ceiling and round just compose their corresponding function
;; with division to determine the quotient, and compute the remainder
;; from that.

(define (ceiling-quotient n m)
  (copy-exactness2 n m (ceiling (/ n m))))
(define (ceiling-remainder n m)
  (- n (* m (ceiling-quotient n m))))
(define (ceiling/ n m)
  (values (ceiling-quotient n m) (ceiling-remainder n m)))

(define (round-quotient n m)
  (copy-exactness2 n m (round (/ n m))))
(define (round-remainder n m)
  (- n (* m (round-quotient n m))))
(define (round/ n m)
  (values (round-quotient n m) (round-remainder n m)))

;; Euclidean is defined as floor if the divisor is negative, and
;; ceiling otherwise.

(define (euclidean-quotient n m)
  (if (> m 0) (floor-quotient n m) (ceiling-quotient n m)))
(define (euclidean-remainder n m)
  (- n (* m (euclidean-quotient n m))))
(define (euclidean/ n m)
  (values (euclidean-quotient n m) (euclidean-remainder n m)))

;; Balanced places the remainder in the half-open interval
;; [-m/2, m/2).

(define (balanced-remainder n m)
  (let ((r (euclidean-remainder n m))
        (m/2 (abs (/ m 2))))
    (cond ((< r (- m/2)) (+ r (abs m)))
          ((>= r m/2) (- r (abs m)))
          (else r))))
(define (balanced-quotient n m)
  (quotient (- n (balanced-remainder n m)) m))
(define (balanced/ n m)
  (values (balanced-quotient n m) (balanced-remainder n m)))

(define-library (scheme read)
  (import (rename (srfi 38) (read/ss read)))
  (export read))

(define (nan? x)
  (and (real? x) (not (= x x))))

(define (finite? x)
  (if (real? x)
      (and (not (nan? x)) (not (= x +inf.0)) (not (= x -inf.0)))
      (and (complex? x) (finite? (real-part x)) (finite? (imag-part x)))))

(define (infinite? x)
  (and (number? x) (not (finite? x)) (not (nan? x))))

(define-library (scheme bitwise) (alias-for (srfi 151)))

(define-library (scheme sort) (alias-for (srfi 132)))

(define-library (scheme base)
  (import (rename (except (chibi) equal?)
                  (let-syntax let-syntax/splicing)
                  (letrec-syntax letrec-syntax/splicing))
          (rename (chibi equiv) (equiv? equal?))
          (only (chibi string) string-map string-for-each)
          (chibi io)
          (rename (only (chibi ast)
                        exception? exception-message exception-irritants)
                  (exception? error-object?)
                  (exception-message error-object-message)
                  (exception-irritants error-object-irritants))
          (srfi 9) (srfi 11) (srfi 39))
  (export
   * + - ... / < <= = => > >= _ abs and append apply assoc assq assv begin
   binary-port?  boolean?  boolean=?  bytevector bytevector-append
   bytevector-copy bytevector-copy! bytevector-length
   bytevector-u8-ref bytevector-u8-set!  bytevector?  caar cadr
   call-with-current-continuation call-with-port call-with-values
   call/cc car case cdr cdar cddr ceiling char->integer
   char-ready? char<=?  char<?  char=?  char>=?  char>?  char?
   close-input-port close-output-port close-port complex?  cond cond-expand
   cons current-error-port current-input-port current-output-port define
   define-record-type define-syntax define-values denominator do
   dynamic-wind else eof-object? eof-object  eq?  equal?  eqv?  error
   error-object-irritants error-object-message error-object?  even?
   exact exact-integer-sqrt exact-integer?  exact?  expt features
   file-error? floor
   flush-output-port for-each gcd get-output-bytevector get-output-string
   guard if include include-ci inexact inexact?  input-port?
   integer->char
   integer?  lambda lcm length let let* let*-values let-syntax let-values
   letrec letrec* letrec-syntax list list->string list->vector list-copy
   list-ref list-set!  list-tail list?  make-bytevector make-list
   make-parameter make-string make-vector map max member memq memv min
   modulo negative?  newline not null?  number->string number?  numerator
   odd?  open-input-bytevector open-input-string open-output-bytevector
   open-output-string or output-port?  pair?  parameterize peek-char
   peek-u8 input-port-open? output-port-open?  port?  positive?
   procedure?  quasiquote quote
   quotient raise raise-continuable rational?  rationalize read-bytevector
   read-bytevector!  read-char read-error? read-line read-string read-u8
   real?  remainder
   reverse round set!  set-car!  set-cdr!  square string string->list
   string->number string->symbol string->utf8 string->vector string-append
   string-copy string-copy! string-fill!  string-for-each string-length
   string-map
   string-ref string-set!  string<=?  string<?  string=?  string>=?
   string>?  string?  substring symbol->string symbol?  symbol=?  syntax-error
   syntax-rules textual-port?  truncate u8-ready?  unless unquote
   unquote-splicing utf8->string values vector vector-append
   vector->list vector->string
   vector-copy vector-copy! vector-fill!  vector-for-each vector-length
   vector-map vector-ref vector-set!  vector?  when with-exception-handler
   write-bytevector write-char write-string write-u8 zero?
   truncate-quotient truncate-remainder truncate/
   floor-quotient floor-remainder floor/)
  (include "define-values.scm"
           "extras.scm"
           "misc-macros.scm"))

(define-syntax let-syntax
  (syntax-rules ()
    ((let-syntax . x)
     (let () (let-syntax/splicing . x)))))

(define-syntax letrec-syntax
  (syntax-rules ()
    ((letrec-syntax . x)
     (let () (letrec-syntax/splicing . x)))))

(define-syntax when
  (syntax-rules ()
    ((when test . body)
     (if test (begin . body)))))

(define-syntax unless
  (syntax-rules ()
    ((unless test . body)
     (when (not test) . body))))

(define-syntax guard
  (syntax-rules ()
    ((guard (var clause ...) e1 e2 ...)
     ((call-with-current-continuation
       (lambda (guard-k)
         (with-exception-handler
          (lambda (condition)
            ((call-with-current-continuation
              (lambda (handler-k)
                (guard-k
                 (lambda ()
                   (let ((var condition))      ; clauses may SET! var
                     (guard-aux (handler-k (lambda ()
                                             ;; must be raise-continuable
                                             ;; in case the original
                                             ;; exception was continuable
                                             (raise-continuable condition)))
                                clause ...))))))))
          (lambda ()
            (let ((res (let () e1 e2 ...)))
              (guard-k (lambda () res)))))))))))

(define-syntax guard-aux
  (syntax-rules (else =>)
    ((guard-aux reraise (else result1 result2 ...))
     (begin result1 result2 ...))
    ((guard-aux reraise (test => result))
     (let ((temp test))
       (if temp (result temp) reraise)))
    ((guard-aux reraise (test => result) clause1 clause2 ...)
     (let ((temp test))
       (if temp (result temp) (guard-aux reraise clause1 clause2 ...))))
    ((guard-aux reraise (test))
     (or test reraise))
    ((guard-aux reraise (test) clause1 clause2 ...)
     (or test (guard-aux reraise clause1 clause2 ...)))
    ((guard-aux reraise (test result1 result2 ...))
     (if test (begin result1 result2 ...) reraise))
    ((guard-aux reraise (test result1 result2 ...) clause1 clause2 ...)
     (if test
         (begin result1 result2 ...)
         (guard-aux reraise clause1 clause2 ...)))))

(define-library (scheme list-queue) (alias-for (srfi 117)))

(define-library (scheme ilist) (alias-for (srfi 116)))
;; meta.scm -- meta language for describing modules
;; Copyright (c) 2009-2014 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; modules

(define *this-module* '())
(define *this-path* '())

(define (make-module exports env meta) (vector exports env meta #f))
(define (%module-exports mod) (vector-ref mod 0))
(define (module-env mod) (vector-ref mod 1))
(define (module-env-set! mod env) (vector-set! mod 1 env))
(define (module-meta-data mod) (vector-ref mod 2))
(define (module-meta-data-set! mod x) (vector-set! mod 2 x))

(define (module-exports mod)
  (or (%module-exports mod)
      (if (module-env mod)
          (env-exports (module-env mod))
          '())))

(define (module-name->strings ls res)
  (if (null? ls)
      res
      (let ((str (cond ((symbol? (car ls)) (symbol->string (car ls)))
                       ((number? (car ls)) (number->string (car ls)))
                       ((string? (car ls)) (car ls))
                       (else (error "invalid module name" (car ls))))))
        (module-name->strings (cdr ls) (cons "/" (cons str res))))))

(define (module-name->file name)
  (string-concatenate
   (reverse (cons ".sld" (cdr (module-name->strings name '()))))))

(define (module-name-prefix name)
  (string-concatenate (reverse (cdr (cdr (module-name->strings name '()))))))

(define load-module-definition
  (let ((meta-env (current-environment)))
    (lambda (name)
      (let* ((file (module-name->file name))
             (path (find-module-file file)))
        (if path (load path meta-env))))))

(define (find-module name)
  (cond
   ((assoc name *modules*) => cdr)
   (else
    (load-module-definition name)
    (cond ((assoc name *modules*) => cdr)
          (else #f)))))

(define (add-module! name module)
  (set! *modules* (cons (cons name module) *modules*)))

(define (delete-module! name)
  (let lp ((ls *modules*) (prev #f))
    (cond ((null? ls))
          ((equal? name (car (car ls)))
           (if prev
               (set-cdr! prev (cdr ls))
               (set! *modules* (cdr ls))))
          (else (lp (cdr ls) ls)))))

(define (symbol-append a b)
  (string->symbol (string-append (symbol->string a) (symbol->string b))))

(define (symbol-drop a b)
  (let ((as (symbol->string a))
        (bs (symbol->string b)))
    (if (and (> (string-length bs) (string-length as))
             (string=? as (substring bs 0 (string-length as))))
        (string->symbol (substring bs (string-length as)))
        b)))

(define (warn msg . args)
  (display msg (current-error-port))
  (display ":" (current-error-port))
  (for-each (lambda (a)
              (display " " (current-error-port))
              (write a (current-error-port)))
            args)
  (newline (current-error-port)))

(define (to-id id) (if (pair? id) (car id) id))
(define (from-id id) (if (pair? id) (cdr id) id))
(define (id-filter pred ls)
  (cond ((null? ls) '())
        ((pred (to-id (car ls))) (cons (car ls) (id-filter pred (cdr ls))))
        (else (id-filter pred (cdr ls)))))

(define (%resolve-import x)
  (cond
   ((not (and (pair? x) (list? x)))
    (error "invalid import syntax" x))
   ((and (memq (car x) '(prefix drop-prefix))
         (symbol? (car (cddr x))) (list? (cadr x)))
    (let ((mod-name+imports (%resolve-import (cadr x))))
      (cons (car mod-name+imports)
            (map (lambda (i)
                   (cons ((if (eq? (car x) 'drop-prefix)
                              symbol-drop
                              symbol-append)
                          (car (cddr x))
                          (to-id i))
                         (from-id i)))
                 (or (cdr mod-name+imports)
                     (module-exports (find-module (car mod-name+imports))))))))
   ((and (pair? (cdr x)) (pair? (cadr x)))
    (if (memq (car x) '(only except rename))
        (let* ((mod-name+imports (%resolve-import (cadr x)))
               (imp-ids (or (cdr mod-name+imports)
                            (module-exports (find-module (car mod-name+imports))))))
          (cons (car mod-name+imports)
                (case (car x)
                  ((only)
                   (map (lambda (imp)
                          (if (or (boolean? imp-ids) (memq imp imp-ids))
                              imp
                              (error "importing unknown binding" imp imp-ids)))
                        (cddr x)))
                  ((except)
                   (id-filter (lambda (i) (not (memq i (cddr x)))) imp-ids))
                  ((rename)
                   ;; TODO: warn about renaming an unimported id
                   (map (lambda (i)
                          (let ((rename (assq (to-id i) (cddr x))))
                            (if rename (cons (cadr rename) (from-id i)) i)))
                        imp-ids)))))
        (error "invalid import modifier" x)))
   ((find-module x)
    => (lambda (mod) (cons x (%module-exports mod))))
   (else
    (error "couldn't find import" x))))

;; slightly roundabout, using eval since we don't have env-define! here
(define (auto-generate-bindings ls)
  (let ((bound (env-exports *auto-env*))
        (def-aux
          (make-syntactic-closure *chibi-env* '() 'define-auxiliary-syntax)))
    (let lp ((ls ls) (new '()))
      (cond
       ((null? ls)
        (if (pair? new)
            (eval `(,(make-syntactic-closure *chibi-env* '() 'begin) ,@new)
                  *auto-env*)))
       (else
        (let ((from-id (if (pair? (car ls)) (cdar ls) (car ls))))
          (if (memq from-id bound)
              (lp (cdr ls) new)
              (lp (cdr ls) `((,def-aux ,from-id) ,@new)))))))))

(define (resolve-import x)
  (let ((x (%resolve-import x)))
    (if (equal? '(auto) (car x))
        (auto-generate-bindings (cdr x)))
    x))

(define (resolve-module-imports env meta)
  (for-each
   (lambda (x)
     (case (and (pair? x) (car x))
       ((import import-immutable)
        (for-each
         (lambda (m)
           (let* ((mod2-name+imports (resolve-import m))
                  (mod2 (load-module (car mod2-name+imports))))
             (%import env (module-env mod2) (cdr mod2-name+imports) #t)))
         (cdr x)))))
   meta))

(define (eval-module name mod . o)
  (let ((env (if (pair? o) (car o) (make-environment)))
        (meta (module-meta-data mod))
        (dir (module-name-prefix name)))
    (define (load-modules files extension fold? . o)
      (for-each
       (lambda (f)
         (let ((f (string-append dir f extension)))
           (cond
            ((find-module-file f)
             => (lambda (path)
                  (cond (fold?
                         (let ((in (open-input-file path)))
                           (set-port-fold-case! in #t)
                           (load in env)))
                        (else
                         (load path env)))))
            ((and (pair? o) (car o)) ((car o)))
            (else (error "couldn't find include" f)))))
       files))
    ;; catch cyclic references
    (cond
     ((procedure? meta)
      (meta env))
     (else
      (module-meta-data-set!
       mod
       `((error "module attempted to reference itself while loading" ,name)))
      (resolve-module-imports env meta)
      (protect
          (exn (else
                (module-meta-data-set! mod meta)
                (if (not (any (lambda (x)
                                (and (pair? x)
                                     (memq (car x) '(import import-immutable))))
                              meta))
                    (warn "WARNING: exception inside module with no imports - did you forget to (import (scheme base)) in" name))
                (raise-continuable exn)))
        (for-each
         (lambda (x)
           (case (and (pair? x) (car x))
             ((include)
              (load-modules (cdr x) "" #f))
             ((include-ci)
              (load-modules (cdr x) "" #t))
             ((include-shared)
              (load-modules (cdr x) *shared-object-extension* #f))
             ((include-shared-optionally)
              (load-modules (list (cadr x)) *shared-object-extension* #f
                            (lambda () (load-modules (cddr x) "" #f))))
             ((body begin)
              (for-each (lambda (expr) (eval expr env)) (cdr x)))
             ((error)
              (apply error (cdr x)))))
         meta))
      (module-meta-data-set! mod meta)
      (warn-undefs env #f)
      env))))

(define (mutable-environment . ls)
  (let ((env (make-environment)))
    (for-each
     (lambda (m)
       (let* ((mod2-name+imports (resolve-import m))
              (mod2 (load-module (car mod2-name+imports))))
         (%import env (module-env mod2) (cdr mod2-name+imports) #t)))
     ls)
    env))

(define (environment . ls)
  (let ((env (apply mutable-environment ls)))
    (make-immutable! env)
    env))

(define (load-module name)
  (let ((mod (find-module name)))
    (if (and mod (not (module-env mod)))
        (module-env-set! mod (eval-module name mod)))
    mod))

(define-syntax meta-begin begin)
(define-syntax meta-define define)

(define define-library-transformer
  (er-macro-transformer
   (lambda (expr rename compare)
     (cond
      ((find (lambda (x) (and (pair? x) (compare (car x) (rename 'alias-for))))
             (cddr expr))
       => (lambda (alias)
            (if (not (= 1 (length (cddr expr))))
                (error "alias must be the only library declaration" expr))
            ;; we need to load the original module first, not just find it,
            ;; or else the includes would happen relative to the alias
            (let ((name (cadr expr))
                  (orig (load-module (cadr alias))))
              (if (not orig)
                  (error "couldn't find library to alias" (cadr alias))
                  `(,(rename 'add-module!) (,(rename 'quote) ,name)
                    (,(rename 'quote) ,orig))))))
      (else
       (let ((name (cadr expr))
             (body (cddr expr))
             (tmp (rename 'tmp))
             (this-module (rename '*this-module*))
             (_add-module! (rename 'add-module!))
             (_make-module (rename 'make-module))
             (_define (rename 'meta-define))
             (_lambda (rename 'lambda))
             (_let (rename 'let))
             (_map (rename 'map))
             (_if (rename 'if))
             (_cond (rename 'cond))
             (_set! (rename 'set!))
             (_quote (rename 'quote))
             (_and (rename 'and))
             (_= (rename '=))
             (_eq? (rename 'eq?))
             (_pair? (rename 'pair?))
             (_null? (rename 'null?))
             (_reverse (rename 'reverse))
             (_append (rename 'append))
             (_assq (rename 'assq))
             (_=> (rename '=>))
             (_else (rename 'else))
             (_length (rename 'length))
             (_identifier->symbol (rename 'identifier->symbol))
             (_error (rename 'error))
             (_cons (rename 'cons))
             (_car (rename 'car))
             (_cdr (rename 'cdr))
             (_caar (rename 'caar))
             (_cadr (rename 'cadr))
             (_cdar (rename 'cdar))
             (_cddr (rename 'cddr)))
         ;; Check for suspicious defines.
         (for-each
          (lambda (x)
            (if (and (pair? x) (memq (strip-syntactic-closures (car x))
                                     '(define define-syntax)))
                (warn "suspicious use of define in library declarations - did you forget to wrap it in begin?" x)))
          (cdr expr))
         ;; Generate the library wrapper.
         (set! *this-path*
               (cons (string-concatenate
                      (module-name->strings (cdr (reverse name)) '()))
                     *this-path*))
         `(,_let ((,tmp ,this-module))
            (,_define (rewrite-export x)
              (,_if (,_pair? x)
                  (,_if (,_and (,_= 3 (,_length x))
                               (,_eq? (,_quote rename)
                                      (,_identifier->symbol (,_car x))))
                      (,_cons (,_car (,_cddr x)) (,_cadr x))
                      (,_error "invalid module export" x))
                  x))
            (,_define (extract-exports)
              (,_cond
               ((,_assq (,_quote export-all) ,this-module)
                ,_=> (,_lambda (x)
                       (,_if (,_pair? (,_cdr x))
                           (,_error "export-all takes no parameters" x))
                       #f))
               (,_else
                (,_let lp ((ls ,this-module) (res (,_quote ())))
                  (,_cond
                   ((,_null? ls) res)
                   ((,_and (,_pair? (,_car ls))
                           (,_eq? (,_quote export) (,_caar ls)))
                    (lp (,_cdr ls)
                        (,_append (,_map rewrite-export (,_cdar ls)) res)))
                   (,_else (lp (,_cdr ls) res)))))))
            (,_set! ,this-module (,_quote ()))
            ,@body
            (,_add-module! (,_quote ,name)
                           (,_make-module (extract-exports)
                                          #f
                                          (,_reverse ,this-module)))
            (,_set! ,this-module ,tmp)
            (,(rename 'pop-this-path)))))))))

(define-syntax define-library define-library-transformer)
(define-syntax module define-library-transformer)

(define-syntax pop-this-path
  (er-macro-transformer
   (lambda (expr rename compare)
     (if (pair? *this-path*)
         (set! *this-path* (cdr *this-path*)))
     #f)))

(define-syntax include-library-declarations
  (er-macro-transformer
   (lambda (expr rename compare)
     (let lp1 ((ls (cdr expr)) (res '()))
       (cond
        ((pair? ls)
         (let* ((file (car ls))
                (rel-path (if (pair? *this-path*)
                              (string-append (car *this-path*) "/" file)
                              file)))
           (cond
            ((find-module-file rel-path)
             => (lambda (path)
                  (call-with-input-file path
                    (lambda (in)
                      (let lp2 ((res res))
                        (let ((x (read in)))
                          (if (eof-object? x)
                              (lp1 (cdr ls) res)
                              (lp2 (cons x res)))))))))
            (else
             (error "couldn't find include-library-declarations file" file)))))
        (else
         `(,(rename 'meta-begin)
           ,@(reverse res)
           (,(rename 'set!) ,(rename '*this-module*)
            (,(rename 'cons) (,(rename 'quote)
                              ,(cons 'include-library-declarations (cdr expr)))
             ,(rename '*this-module*))))))))))

(define-syntax define-meta-primitive
  (er-macro-transformer
   (lambda (expr rename compare)
     (let ((name (cadr expr)))
       `(define-syntax ,name
          (er-macro-transformer
           (lambda (expr rename compare)
             (let ((this-module (rename '*this-module*))
                   (_set! (rename 'set!))
                   (_cons (rename 'cons))
                   (_quote (rename 'syntax-quote)))
               `(,_set! ,this-module
                        (,_cons (,_quote ,(cons ',name (cdr expr)))
                                ,this-module))))))))))

(define-meta-primitive import)
(define-meta-primitive import-immutable)
(define-meta-primitive export)
(define-meta-primitive export-all)
(define-meta-primitive include)
(define-meta-primitive include-ci)
(define-meta-primitive include-shared)
(define-meta-primitive include-shared-optionally)
(define-meta-primitive body)
(define-meta-primitive begin)

;; The `import' binding used by (chibi) and (scheme base), etc.
(define-syntax repl-import
  (er-macro-transformer
   (let ((meta-env (current-environment)))
     (lambda (expr rename compare)
       (let lp ((ls (cdr expr)) (res '()))
         (cond
          ((null? ls)
           (cons (rename 'meta-begin) (reverse res)))
          (else
           (let ((mod+imps (resolve-import (car ls))))
             (cond
              ((pair? mod+imps)
               (lp (cdr ls)
                   (cons `(,(rename '%import)
                           #f
                           (,(rename 'module-env)
                            (,(rename 'load-module)
                             (,(rename 'quote) ,(car mod+imps))))
                           (,(rename 'quote) ,(cdr mod+imps))
                           #f)
                         res)))
              (else
               (error "couldn't find module" (car ls))))))))))))

;; This will be redefined in main.c.
(define raw-script-file #f)

;; capture a static copy of the current environment to serve
;; as the (chibi) module
(define *chibi-env*
  (let ((env (make-environment)))
    (%import env (interaction-environment) #f #t)
    (env-parent env)))

(define *auto-env*
  (let ((env (make-environment)))
    (%import env (interaction-environment)
             '(_ => ... else unquote unquote-splicing) #t)
    (env-parent env)))

(define *modules*
  (list
   (cons '(chibi)
         (make-module #f *chibi-env* '((include "init-7.scm"))))
   (cons '(chibi primitive)
         (make-module #f #f (lambda (env) (primitive-environment 7))))
   (cons '(meta)
         (make-module #f (current-environment) '((include "meta-7.scm"))))
   (cons '(auto)
         (make-module #f *auto-env* '()))
   (cons '(srfi 0)
         (make-module (list 'cond-expand)
                      (current-environment)
                      (list (list 'export 'cond-expand))))))
;; init-7.scm -- core library procedures for R7RS
;; Copyright (c) 2009-2021 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

(define (caar x) (car (car x)))
(define (cadr x) (car (cdr x)))
(define (cdar x) (cdr (car x)))
(define (cddr x) (cdr (cdr x)))

(define (cons-source kar kdr source)
  ((lambda (pair source)
     (if (pair? source)
         (pair-source-set! pair (pair-source source)))
     pair)
   (cons kar kdr)
   (strip-syntactic-closures source)))

(define (not x) (if x #f #t))
(define (boolean? x) (if (eq? x #t) #t (eq? x #f)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; basic utils

(define (procedure? x) (if (closure? x) #t (opcode? x)))

(define (length ls)
  (if (list? ls) (length* ls) (error "length: not a list" ls)))

(define (list . args) args)

(define (list-tail ls k)
  (if (eq? k 0)
      ls
      (list-tail (cdr ls) (- k 1))))

(define (list-ref ls k) (car (list-tail ls k)))

(define (append-helper ls res)
  (if (null? ls)
      res
      (append-helper (cdr ls) (append2 (car ls) res))))

(define (append . o)
  (if (null? o)
      '()
      ((lambda (lol)
         (append-helper (cdr lol) (car lol)))
       (reverse o))))

(define (apply proc arg1 . args)
  (if (null? args)
      (apply1 proc arg1)
      ((lambda (lol)
         (apply1 proc (append2 (reverse (cdr lol)) (car lol))))
       (reverse (cons arg1 args)))))

;; map with a fast-path for single lists

(define (map proc ls . lol)
  (define (map1 proc ls res)
    (if (pair? ls)
        (map1 proc (cdr ls) (cons (proc (car ls)) res))
        (if (null? ls)
            (reverse res)
            (error "map: improper list" ls))))
  (define (mapn proc lol res)
    (if (every pair? lol)
        (mapn proc
              (map1 cdr lol '())
              (cons (apply proc (map1 car lol '())) res))
        (if (every (lambda (x) (if (null? x) #t (pair? x))) lol)
            (reverse res)
            (error "map: improper list in list" lol))))
  (if (null? lol)
      (map1 proc ls '())
      (mapn proc (cons ls lol) '())))

(define (for-each f ls . lol)
  (define (for1 f ls)
    (if (pair? ls)
        (begin (f (car ls)) (for1 f (cdr ls)))
        (if (not (null? ls))
            (error "for-each: improper list" ls))))
  (if (null? lol) (for1 f ls) (begin (apply map f ls lol) (if #f #f))))

(define (any pred ls . lol)
  (define (any1 pred ls)
    (if (pair? (cdr ls))
        ((lambda (x) (if x x (any1 pred (cdr ls)))) (pred (car ls)))
        (pred (car ls))))
  (define (anyn pred lol)
    (if (every pair? lol)
        ((lambda (x) (if x x (anyn pred (map cdr lol))))
         (apply pred (map car lol)))
        #f))
  (if (null? lol) (if (pair? ls) (any1 pred ls) #f) (anyn pred (cons ls lol))))

(define (every pred ls . lol)
  (define (every1 pred ls)
    (if (null? (cdr ls))
        (pred (car ls))
        (if (pred (car ls)) (every1 pred (cdr ls)) #f)))
  (if (null? lol)
      (if (pair? ls) (every1 pred ls) #t)
      (not (apply any (lambda xs (not (apply pred xs))) ls lol))))

(define (error msg . args)
  (raise (make-exception 'user msg args #f #f)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; syntax

(define close-syntax
  (lambda (form env)
    (make-syntactic-closure env '() form)))

(define make-renamer
  (lambda (mac-env)
    (define rename
      ((lambda (renames)
         (lambda (identifier)
           ((lambda (cell)
              (if cell
                  (cdr cell)
                  ((lambda (name)
                     (set! renames (cons (cons identifier name) renames))
                     name)
                   ((lambda (id)
                      (syntactic-closure-set-rename! id rename)
                      id)
                    (close-syntax identifier mac-env)))))
            (assq identifier renames))))
       '()))
    rename))

(define sc-macro-transformer
  (lambda (f)
    (lambda (expr use-env mac-env)
      (close-syntax (f expr use-env) mac-env))))

(define rsc-macro-transformer
  (lambda (f)
    (lambda (expr use-env mac-env)
      (f expr mac-env))))

(define er-macro-transformer
  (lambda (f)
    (lambda (expr use-env mac-env)
      (f expr
         (make-renamer mac-env)
         (lambda (x y) (identifier=? use-env x use-env y))))))

(define-syntax cond
  (er-macro-transformer
   (lambda (expr rename compare)
     (if (null? (cdr expr))
         (if #f #f)
         ((lambda (cl)
            (if (compare (rename 'else) (car cl))
                (if (pair? (cddr expr))
                    (error "non-final else in cond" expr)
                    (cons (rename 'begin) (cdr cl)))
                (if (if (null? (cdr cl)) #t (compare (rename '=>) (cadr cl)))
                    (list (list (rename 'lambda) (list (rename 'tmp))
                                (list (rename 'if) (rename 'tmp)
                                      (if (null? (cdr cl))
                                          (rename 'tmp)
                                          (list (car (cddr cl)) (rename 'tmp)))
                                      (cons (rename 'cond) (cddr expr))))
                          (car cl))
                    (list (rename 'if)
                          (car cl)
                          (cons (rename 'begin) (cdr cl))
                          (cons (rename 'cond) (cddr expr))))))
          (cadr expr))))))

(define-syntax or
  (er-macro-transformer
   (lambda (expr rename compare)
     (cond ((null? (cdr expr)) #f)
           ((null? (cddr expr)) (cadr expr))
           (else
            (list (rename 'let) (list (list (rename 'tmp) (cadr expr)))
                  (list (rename 'if) (rename 'tmp)
                        (rename 'tmp)
                        (cons (rename 'or) (cddr expr)))))))))

(define-syntax and
  (er-macro-transformer
   (lambda (expr rename compare)
     (cond ((null? (cdr expr)))
           ((null? (cddr expr)) (cadr expr))
           (else (list (rename 'if) (cadr expr)
                       (cons (rename 'and) (cddr expr))
                       #f))))))

(define-syntax quasiquote
  (er-macro-transformer
   (lambda (expr rename compare)
     (define (qq x d)
       (cond
        ((pair? x)
         (cond
          ((compare (rename 'unquote) (car x))
           (if (<= d 0)
               (cadr x)
               (list (rename 'list) (list (rename 'quote) 'unquote)
                     (qq (cadr x) (- d 1)))))
          ((compare (rename 'unquote-splicing) (car x))
           (if (<= d 0)
               (list (rename 'cons-source) (qq (car x) d) (qq (cdr x) d)
                     (list (rename 'quote) x))
               (list (rename 'list) (list (rename 'quote) 'unquote-splicing)
                     (qq (cadr x) (- d 1)))))
          ((compare (rename 'quasiquote) (car x))
           (list (rename 'list) (list (rename 'quote) 'quasiquote)
                 (qq (cadr x) (+ d 1))))
          ((and (<= d 0) (pair? (car x))
                (compare (rename 'unquote-splicing) (caar x)))
           (if (null? (cdr x))
               (cadr (car x))
               (list (rename 'append) (cadr (car x)) (qq (cdr x) d))))
          (else
           (list (rename 'cons-source) (qq (car x) d) (qq (cdr x) d)
                 (list (rename 'quote) x)))))
        ((vector? x) (list (rename 'list->vector) (qq (vector->list x) d)))
        ((if (identifier? x) #t (null? x)) (list (rename 'quote) x))
        (else x)))
     (qq (cadr expr) 0))))

(define-syntax letrec
  (er-macro-transformer
   (lambda (expr rename compare)
     ((lambda (defs)
        `((,(rename 'lambda) () ,@defs ,@(cddr expr))))
      (map (lambda (x) (cons (rename 'define) x)) (cadr expr))))))

(define-syntax let
  (er-macro-transformer
   (lambda (expr rename compare)
     (if (null? (cdr expr)) (error "empty let" expr))
     (if (null? (cddr expr)) (error "no let body" expr))
     ((lambda (bindings)
        (if (list? bindings) #f (error "bad let bindings"))
        (if (every (lambda (x)
                     (if (pair? x) (if (pair? (cdr x)) (null? (cddr x)) #f) #f))
                   bindings)
            ((lambda (vars vals)
               (if (identifier? (cadr expr))
                   `((,(rename 'lambda) ,vars
                      (,(rename 'letrec) ((,(cadr expr)
                                           (,(rename 'lambda) ,vars
                                            ,@(cdr (cddr expr)))))
                       (,(cadr expr) ,@vars)))
                     ,@vals)
                   ((lambda (res)
                      (pair-source-set! res (pair-source expr))
                      res)
                    `((,(rename 'lambda) ,vars ,@(cddr expr)) ,@vals))))
             (map car bindings)
             (map cadr bindings))
            (error "bad let syntax" expr)))
      (if (identifier? (cadr expr)) (car (cddr expr)) (cadr expr))))))

(define-syntax let*
  (er-macro-transformer
   (lambda (expr rename compare)
     (if (null? (cdr expr)) (error "empty let*" expr))
     (if (null? (cddr expr)) (error "no let* body" expr))
     (if (null? (cadr expr))
         `(,(rename 'let) () ,@(cddr expr))
         (if (if (list? (cadr expr))
                 (every
                  (lambda (x)
                    (if (pair? x) (if (pair? (cdr x)) (null? (cddr x)) #f) #f))
                  (cadr expr))
                 #f)
             `(,(rename 'let) (,(caar (cdr expr)))
               (,(rename 'let*) ,(cdar (cdr expr)) ,@(cddr expr)))
             (error "bad let* syntax"))))))

(define-syntax case
  (er-macro-transformer
   (lambda (expr rename compare)
     (define (body exprs)
       (cond
        ((null? exprs)
         (rename 'tmp))
        ((compare (rename '=>) (car exprs))
         `(,(cadr exprs) ,(rename 'tmp)))
        (else
         `(,(rename 'begin) ,@exprs))))
     (define (clause ls)
       (cond
        ((null? ls) #f)
        ((compare (rename 'else) (caar ls))
         (body (cdar ls)))
        ((and (pair? (car (car ls))) (null? (cdr (car (car ls)))))
         `(,(rename 'if) (,(rename 'eqv?) ,(rename 'tmp)
                          (,(rename 'quote) ,(car (caar ls))))
           ,(body (cdar ls))
           ,(clause (cdr ls))))
        (else
         `(,(rename 'if) (,(rename 'memv) ,(rename 'tmp)
                          (,(rename 'quote) ,(caar ls)))
           ,(body (cdar ls))
           ,(clause (cdr ls))))))
     `(,(rename 'let) ((,(rename 'tmp) ,(cadr expr)))
        ,(clause (cddr expr))))))

(define-syntax do
  (er-macro-transformer
   (lambda (expr rename compare)
     (let* ((body
             `(,(rename 'begin)
               ,@(cdr (cddr expr))
               (,(rename 'lp)
                ,@(map (lambda (x)
                         (if (pair? (cddr x))
                             (if (pair? (cdr (cddr x)))
                                 (error "too many forms in do iterator" x)
                                 (car (cddr x)))
                             (car x)))
                       (cadr expr)))))
            (check (car (cddr expr)))
            (wrap
             (if (null? (cdr check))
                 `(,(rename 'let) ((,(rename 'tmp) ,(car check)))
                   (,(rename 'if) ,(rename 'tmp)
                    ,(rename 'tmp)
                    ,body))
                 `(,(rename 'if) ,(car check)
                   (,(rename 'begin) ,@(cdr check))
                   ,body))))
       `(,(rename 'let) ,(rename 'lp)
         ,(map (lambda (x) (list (car x) (cadr x))) (cadr expr))
         ,wrap)))))

(define-syntax delay-force
  (er-macro-transformer
   (lambda (expr rename compare)
     (if (null? (cdr expr)) (error "not enough args" expr))
     (if (not (null? (cddr expr))) (error "too many args" expr))
     `(,(rename 'promise) #f (,(rename 'lambda) () ,(cadr expr))))))

(define-syntax delay
  (er-macro-transformer
   (lambda (expr rename compare)
     (if (null? (cdr expr)) (error "not enough args" expr))
     (if (not (null? (cddr expr))) (error "too many args" expr))
     `(,(rename 'delay-force) (,(rename 'promise) #t ,(cadr expr))))))

(define-syntax define-auxiliary-syntax
  (er-macro-transformer
   (lambda (expr rename compare)
     `(,(rename 'define-syntax) ,(cadr expr)
       (,(rename 'er-macro-transformer)
        (,(rename 'lambda) (expr rename compare)
         (,(rename 'error) "invalid use of auxiliary syntax" ',(cadr expr))))))))

(define-auxiliary-syntax _)
(define-auxiliary-syntax =>)
(define-auxiliary-syntax ...)
(define-auxiliary-syntax else)
(define-auxiliary-syntax unquote)
(define-auxiliary-syntax unquote-splicing)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; SRFI-0

(define-syntax cond-expand
  (er-macro-transformer
   (lambda (expr rename compare)
     (define (check x)
       (if (pair? x)
           (case (car x)
             ((and) (every check (cdr x)))
             ((or) (any check (cdr x)))
             ((not) (not (check (cadr x))))
             ((library) (eval `(find-module ',(cadr x)) (%meta-env)))
             (else (error "cond-expand: bad feature" x)))
           (memq (identifier->symbol x) *features*)))
     (let expand ((ls (cdr expr)))
       (cond
        ((null? ls))  ; (error "cond-expand: no expansions" expr)
        ((not (pair? (car ls))) (error "cond-expand: bad clause" (car ls)))
        ((eq? 'else (identifier->symbol (caar ls)))
         (if (pair? (cdr ls))
             (error "cond-expand: else in non-final position")
             `(,(rename 'begin) ,@(cdar ls))))
        ((check (caar ls)) `(,(rename 'begin) ,@(cdar ls)))
        (else (expand (cdr ls))))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; string cursors

(define (string-copy str . o)
  (apply substring str (if (pair? o) o '(0))))

(cond-expand
 (safe-string-cursors
  (define Safe-String-Cursor
    (register-simple-type "Safe-String-Cursor" #f '(string where size)))
  (define %make-string-cursor
    (make-constructor "%make-string-cursor" Safe-String-Cursor))
  (set! string-cursor?
    (make-type-predicate "string-cursor?" Safe-String-Cursor))
  (define string-cursor-string
    (make-getter "string-cursor-string" Safe-String-Cursor 0))
  (define string-cursor-string-set!
    (make-setter "string-cursor-string-set!" Safe-String-Cursor 0))
  (define string-cursor-where
    (make-getter "string-cursor-where" Safe-String-Cursor 1))
  (define string-cursor-where-set!
    (make-setter "string-cursor-where-set!" Safe-String-Cursor 1))
  (define string-cursor-size
    (make-getter "string-cursor-size" Safe-String-Cursor 2))
  (define string-cursor-size-set!
    (make-setter "string-cursor-size-set!" Safe-String-Cursor 2))
  (define (make-string-cursor string where size)
    (let ((res (%make-string-cursor)))
      (string-cursor-string-set! res string)
      (string-cursor-where-set! res where)
      (string-cursor-size-set! res size)
      res))
  (define (validate-cursor str sc)
    (cond
     ((not (eq? str (string-cursor-string sc)))
      (error "attempt to use string cursor on different string" str sc))
     ((not (= (string-size str) (string-cursor-size sc)))
      (error "string has mutated since cursor was created" str sc))))
  (define orig-string-cursor-offset string-cursor-offset)
  (define orig-string-cursor->index string-cursor->index)
  (define orig-string-index->cursor string-index->cursor)
  (define orig-substring-cursor substring-cursor)
  (define orig-string-cursor-end string-cursor-end)
  (set! string-cursor-offset
        (lambda (sc) (orig-string-cursor-offset (string-cursor-where sc))))
  (set! string-cursor->index
        (lambda (str sc) (orig-string-cursor->index str (string-cursor-where sc))))
  (set! string-index->cursor
        (lambda (str i)
          (make-string-cursor str
                              (orig-string-index->cursor str i)
                              (string-size str))))
  (set! substring-cursor
        (lambda (str start . o)
          (validate-cursor str start)
          (cond
           ((pair? o)
            (validate-cursor str (car o))
            (orig-substring-cursor str (string-cursor-where start) (string-cursor-where (car o))))
           (else
            (orig-substring-cursor str (string-cursor-where start))))))
  (define (string-cursor=? sc1 sc2 . o)
    (and (equal? ((values string-cursor-offset) sc1) ((values string-cursor-offset) sc2))
         (or (null? o) (apply string-cursor=? sc2 o))))
  (define (string-cursor<? sc1 sc2 . o)
    (and (< ((values string-cursor-offset) sc1) ((values string-cursor-offset) sc2))
         (or (null? o) (apply string-cursor<? sc2 o))))
  (define (string-cursor<=? sc1 sc2 . o)
    (and (<= ((values string-cursor-offset) sc1) ((values string-cursor-offset) sc2))
         (or (null? o) (apply string-cursor<=? sc2 o))))
  (define (string-cursor>? sc1 sc2 . o)
    (and (> ((values string-cursor-offset) sc1) ((values string-cursor-offset) sc2))
         (or (null? o) (apply string-cursor>? sc2 o))))
  (define (string-cursor>=? sc1 sc2 . o)
    (and (>= ((values string-cursor-offset) sc1) ((values string-cursor-offset) sc2))
         (or (null? o) (apply string-cursor>=? sc2 o))))
  (define string-cursor-start
    (let ((start (string-index->cursor "" 0)))
      (lambda (s) (make-string-cursor s start (string-size s)))))
  (set! string-cursor-end
        (lambda (s)
          (let ((end (orig-string-cursor-end s)))
            (make-string-cursor s end (string-size s)))))
  (define (string-size s)
    (orig-string-cursor-offset (orig-string-cursor-end s)))
  (define orig-string-cursor-ref string-cursor-ref)
  (define orig-string-cursor-next string-cursor-next)
  (define orig-string-cursor-prev string-cursor-prev)
  (set! string-cursor-ref
        (lambda (str sc)
          (validate-cursor str sc)
          (orig-string-cursor-ref str (string-cursor-where sc))))
  (set! string-cursor-next
        (lambda (str sc)
          (validate-cursor str sc)
          (make-string-cursor
           str
           (orig-string-cursor-next str (string-cursor-where sc))
           (string-cursor-size sc))))
  (set! string-cursor-prev
        (lambda (str sc)
          (validate-cursor str sc)
          (make-string-cursor
           str
           (orig-string-cursor-prev str (string-cursor-where sc))
           (string-cursor-size sc)))))
 (full-unicode
  (define string-cursor=? eq?)
  (define string-cursor-start
    (let ((start (string-index->cursor "" 0)))
      (lambda (s) start)))
  (define (string-size s)
    (string-cursor-offset (string-cursor-end s))))
 (else
  (define string-cursor? fixnum?)
  (define string-cursor=? eq?)
  (define string-cursor<? <)
  (define string-cursor<=? <=)
  (define string-cursor>? >)
  (define string-cursor>=? >=)
  (define (string-index->cursor str i) i)
  (define (string-cursor->index str off) off)
  (define (string-cursor-offset str off) off)
  (define string-size string-length)
  (define substring-cursor substring)
  (define (string-cursor-start s) 0)
  (define string-cursor-end string-length)
  (define string-cursor-ref string-ref)
  (define (string-cursor-next s i) (+ i 1))
  (define (string-cursor-prev s i) (- i 1))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; library functions

;; char utils

(define (char-alphabetic? ch) (<= 65 (char->integer (char-upcase ch)) 90))
(define (char-numeric? ch) (<= 48 (char->integer ch) 57))
(define (char-whitespace? ch)
  (if (eq? ch #\space)
      #t
      (if (eq? ch #\tab) #t (if (eq? ch #\newline)
                                #t
                                (if (eq? ch #\xC0) #f (eq? ch #\return))))))
(define (char-upper-case? ch) (<= 65 (char->integer ch) 90))
(define (char-lower-case? ch) (<= 97 (char->integer ch) 122))

(define (char-cmp op a ls)
  (let lp ((op op) (a (char->integer a)) (ls ls))
    (if (null? ls)
        #t
        (let ((b (char->integer (car ls))))
          (and (op a b) (lp op b (cdr ls)))))))

(define (char=? a . ls) (char-cmp = a ls))
(define (char<? a . ls) (char-cmp < a ls))
(define (char>? a . ls) (char-cmp > a ls))
(define (char<=? a . ls) (char-cmp <= a ls))
(define (char>=? a . ls) (char-cmp >= a ls))

(define (char-cmp-ci op a ls)
  (let lp ((op op) (a (char->integer (char-downcase a))) (ls ls))
    (if (null? ls)
        #t
        (let ((b (char->integer (char-downcase (car ls)))))
          (and (op a b) (lp op b (cdr ls)))))))

(define (char-ci=? a . ls) (char-cmp-ci = a ls))
(define (char-ci<? a . ls) (char-cmp-ci < a ls))
(define (char-ci>? a . ls) (char-cmp-ci > a ls))
(define (char-ci<=? a . ls) (char-cmp-ci <= a ls))
(define (char-ci>=? a . ls) (char-cmp-ci >= a ls))

;; string utils

(define (digit-char n)
  (if (<= n 9)
      (integer->char (+ n (char->integer #\0)))
      (integer->char (+ (- n 10) (char->integer #\a)))))

(define (%number->string num)
  (call-with-output-string (lambda (out) (write num out))))

(define (number->string num . o)
  (cond
   ((not (number? num))
    (error "not a number" num))
   ((if (null? o) #t (eq? 10 (car o)))
    (%number->string num))
   (else
    (let ((d (car o)))
      (cond
       ((%complex? num)
        (let ((real (real-part num))
              (imag (imag-part num)))
          (string-append (number->string real d) (if (negative? imag) "-" "+")
                         (number->string imag d) "i")))
       ((inexact? num)
        (string-append "#i" (number->string (inexact->exact num) d)))
       ((ratio? num)
        (string-append (number->string (numerator num) d) "/"
                       (number->string (denominator num) d)))
       (else
        (let lp ((n (abs num)) (res '()))
          (cond
           ((> n 0)
            (lp (quotient n d) (cons (digit-char (remainder n d)) res)))
           ((null? res)
            "0")
           (else
            (list->string (if (negative? num) (cons #\- res) res)))))))))))

(define (list->string ls)
  (call-with-output-string
    (lambda (out) (for-each (lambda (ch) (write-char ch out)) ls))))

(define (string->list str . o)
  (cond
   ((null? o)
    (let ((start (string-cursor-start str)))
      (let lp ((i (string-cursor-prev str (string-cursor-end str))) (res '()))
        (if (string-cursor<? i start)
            res
            (lp (string-cursor-prev str i) (cons (string-cursor-ref str i) res))))))
   (else
    (string->list (apply substring str o)))))

(define (string-fill! str ch . o)
  (let ((start (if (pair? o) (car o) 0))
        (end (if (and (pair? o) (pair? (cdr o))) (cadr o) (string-length str))))
    (let lp ((i (- end 1)))
      (if (>= i start) (begin (string-set! str i ch) (lp (- i 1)))))))

(define (string . args) (list->string args))
(define (string-append . args) (string-concatenate args))

(define (string-cmp-ls op ci? s ls)
  (if (null? ls)
      #t
      (and (op (string-cmp s (car ls) ci?) 0)
           (string-cmp-ls op ci? (car ls) (cdr ls)))))

(define (string=? s . ls) (string-cmp-ls eq? #f s ls))
(define (string<? s . ls) (string-cmp-ls < #f s ls))
(define (string>? s . ls) (string-cmp-ls > #f s ls))
(define (string<=? s . ls) (string-cmp-ls <= #f s ls))
(define (string>=? s . ls) (string-cmp-ls >= #f s ls))

(define (string-ci=? s . ls) (string-cmp-ls eq? #t s ls))
(define (string-ci<? s . ls) (string-cmp-ls < #t s ls))
(define (string-ci>? s . ls) (string-cmp-ls > #t s ls))
(define (string-ci<=? s . ls) (string-cmp-ls <= #t s ls))
(define (string-ci>=? s . ls) (string-cmp-ls >= #t s ls))

;; list utils

(define (make-list n . o)
  (let ((default (if (pair? o) (car o))))
    (let lp ((n n) (res '()))
      (if (<= n 0) res (lp (- n 1) (cons default res))))))

(define (list-copy ls)
  (let lp ((ls ls) (res '()))
    (if (pair? ls)
        (lp (cdr ls) (cons (car ls) res))
        (append (reverse res) ls))))

(define (member obj ls . o)
  (let ((eq (if (pair? o) (car o) equal?)))
    (let lp ((ls ls))
      (and (pair? ls) (if (eq obj (car ls)) ls (lp (cdr ls)))))))

(define (memv obj ls) (member obj ls eqv?))

(define (assoc obj ls . o)
  (let ((eq (if (pair? o) (car o) equal?)))
    (let assoc ((ls ls))
      (cond ((null? ls) #f)
            ((eq obj (caar ls)) (car ls))
            (else (assoc (cdr ls)))))))

(define (assv obj ls) (assoc obj ls eqv?))

(define (find-tail pred ls)
  (and (pair? ls) (if (pred (car ls)) ls (find-tail pred (cdr ls)))))

(define (find pred ls)
  (cond ((find-tail pred ls) => car) (else #f)))

;; vector utils

(define (vector-copy vec . o)
  (let* ((start (if (pair? o) (car o) 0))
         (end (if (and (pair? o) (pair? (cdr o))) (cadr o) (vector-length vec)))
         (res (make-vector (- end start))))
    (do ((i 0 (+ i 1)) (j start (+ j 1))) ((>= j end) res)
      (vector-set! res i (vector-ref vec j)))))

(define (list->vector ls)
  (let ((vec (make-vector (length ls) #f)))
    (let lp ((ls ls) (i 0))
      (if (pair? ls)
          (begin
            (vector-set! vec i (car ls))
            (lp (cdr ls) (+ i 1)))))
    vec))

(define (vector->list vec . o)
  (let ((start (if (pair? o) (car o) 0))
        (end (if (and (pair? o) (pair? (cdr o))) (cadr o) (vector-length vec))))
    (let lp ((i (- end 1)) (res '()))
      (if (< i start) res (lp (- i 1) (cons (vector-ref vec i) res))))))

(define (vector-fill! vec ch . o)
  (let ((start (if (pair? o) (car o) 0))
        (end (if (and (pair? o) (pair? (cdr o))) (cadr o) (vector-length vec))))
    (let lp ((i (- end 1)))
      (if (>= i start) (begin (vector-set! vec i ch) (lp (- i 1)))))))

(define (vector . args) (list->vector args))

;; I/O utils

(define (display x . o)
  (let ((out (if (pair? o) (car o) (current-output-port))))
    (cond ((char? x) (write-char x out))
          ((string? x) (%write-string x #t out))
          (else (write x out)))))

(define (newline . o)
  (write-char #\newline (if (pair? o) (car o) (current-output-port))))

(define (port? x) (or (input-port? x) (output-port? x)))

(define textual-port? port?)

(define (call-with-input-string str proc)
  (let* ((in (open-input-string str))
         (res (proc in)))
    (close-input-port in)
    res))

(define (call-with-output-string proc)
  (let ((out (open-output-string)))
    (proc out)
    (let ((res (get-output-string out)))
      (close-output-port out)
      res)))

(define (call-with-input-file file proc)
  (let* ((in (open-input-file file))
         (res (proc in)))
    (close-input-port in)
    res))

(define (call-with-output-file file proc)
  (let* ((out (open-output-file file))
         (res (proc out)))
    (close-output-port out)
    res))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; values

(define *values-tag* (list 'values))

(define (%values ls)
  (if (and (pair? ls) (null? (cdr ls)))
      (car ls)
      (cons *values-tag* ls)))

(define (values . ls) (%values ls))

(define (call-with-values producer consumer)
  (let ((res (producer)))
    (if (and (pair? res) (eq? *values-tag* (car res)))
        (apply consumer (cdr res))
        (consumer res))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; dynamic-wind

(define %make-point vector)
(define (%point-depth point) (vector-ref point 0))
(define (%point-in point) (vector-ref point 1))
(define (%point-out point) (vector-ref point 2))
(define (%point-parent point) (vector-ref point 3))

(define root-point  ; Shared among all state spaces
  (%make-point 0
               (lambda () (error "winding in to root!"))
               (lambda () (error "winding out of root!"))
               #f))

(cond-expand
 (threads)
 (else
  (define %dk
    (let ((dk root-point))
      (lambda o (if (pair? o) (set! dk (car o)) dk))))))

(%dk root-point)

(define (dynamic-wind in body out)
  (in)
  (let ((here (%dk)))
    (%dk (%make-point (+ (%point-depth here) 1)
                     in
                     out
                     here))
    (let ((res (body)))
      (%dk here)
      (out)
      res)))

(define (travel-to-point! here target)
  (cond
   ((eq? here target)
    'done)
   ((< (%point-depth here) (%point-depth target))
    (travel-to-point! here (%point-parent target))
    ((%point-in target)))
   (else
    ((%point-out here))
    (travel-to-point! (%point-parent here) target))))

(define (continuation->procedure cont point)
  (lambda res
    (travel-to-point! (%dk) point)
    (%dk point)
    (cont (%values res))))

(define (call-with-current-continuation proc)
  (%call/cc
   (lambda (cont)
     (proc (continuation->procedure cont (%dk))))))

(define (with-input-from-file file thunk)
  (let ((old-in (current-input-port))
        (tmp-in (open-input-file file)))
    (dynamic-wind
      (lambda () (current-input-port tmp-in))
      (lambda () (let ((res (thunk))) (close-input-port tmp-in) res))
      (lambda () (current-input-port old-in)))))

(define (with-output-to-file file thunk)
  (let ((old-out (current-output-port))
        (tmp-out (open-output-file file)))
    (dynamic-wind
      (lambda () (current-output-port tmp-out))
      (lambda () (let ((res (thunk))) (close-output-port tmp-out) res))
      (lambda () (current-output-port old-out)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; syntax-rules

(define (syntax-rules-transformer expr rename compare)
  (let ((ellipsis-specified? (identifier? (cadr expr)))
        (count 0)
        (_er-macro-transformer (rename 'er-macro-transformer))
        (_lambda (rename 'lambda))      (_let (rename 'let))
        (_begin (rename 'begin))        (_if (rename 'if))
        (_and (rename 'and))            (_or (rename 'or))
        (_eq? (rename 'eq?))            (_equal? (rename 'equal?))
        (_car (rename 'car))            (_cdr (rename 'cdr))
        (_cons (rename 'cons))          (_pair? (rename 'pair?))
        (_null? (rename 'null?))        (_expr (rename 'expr))
        (_rename (rename 'rename))      (_compare (rename 'compare))
        (_quote (rename 'syntax-quote)) (_apply (rename 'apply))
        (_append (rename 'append))      (_map (rename 'map))
        (_vector? (rename 'vector?))    (_list? (rename 'list?))
        (_len (rename 'len))            (_length (rename 'length*))
        (_- (rename '-))   (_>= (rename '>=))   (_error (rename 'error))
        (_ls (rename 'ls)) (_res (rename 'res)) (_i (rename 'i))
        (_reverse (rename 'reverse))
        (_vector->list (rename 'vector->list))
        (_list->vector (rename 'list->vector))
        (_cons3 (rename 'cons-source))
        (_underscore (rename '_)))
    (define ellipsis (if ellipsis-specified? (cadr expr) (rename '...)))
    (define lits (if ellipsis-specified? (car (cddr expr)) (cadr expr)))
    (define forms (if ellipsis-specified? (cdr (cddr expr)) (cddr expr)))
    (define full-match? (any (lambda (x) (not (pair? (car x)))) forms))
    (define (next-symbol s)
      (set! count (+ count 1))
      (rename (string->symbol (string-append s (%number->string count)))))
    (define (expand-pattern pat tmpl)
      (let lp ((p (if full-match? pat (cdr pat)))
               (x (if full-match? _expr (list _cdr _expr)))
               (dim 0)
               (vars '())
               (k (lambda (vars)
                    (list _cons (expand-template tmpl vars) #f))))
        (let ((v (next-symbol "v.")))
          (list
           _let (list (list v x))
           (cond
            ((identifier? p)
             (cond
              ((ellipsis-mark? p)
               (error "bad ellipsis" p))
              ((memq p lits)
               (list _and
                     (list _compare v (list _rename (list _quote p)))
                     (k vars)))
              ((compare p _underscore)
               (k vars))
              (else
               (list _let (list (list p v)) (k (cons (cons p dim) vars))))))
            ((ellipsis? p)
             (cond
              ((not (null? (cdr (cdr p))))
               (cond
                ((any (lambda (x) (and (identifier? x) (ellipsis-mark? x)))
                      (cddr p))
                 (error "multiple ellipses" p))
                (else
                 (let ((len (length* (cdr (cdr p))))
                       (_lp (next-symbol "lp.")))
                   `(,_let ((,_len (,_length ,v)))
                      (,_and (,_>= ,_len ,len)
                             (,_let ,_lp ((,_ls ,v)
                                          (,_i (,_- ,_len ,len))
                                          (,_res (,_quote ())))
                                    (,_if (,_>= 0 ,_i)
                                        ,(lp `(,(cddr p)
                                               (,(car p) ,(car (cdr p))))
                                             `(,_cons ,_ls
                                                      (,_cons (,_reverse ,_res)
                                                              (,_quote ())))
                                             dim
                                             vars
                                             k)
                                        (,_lp (,_cdr ,_ls)
                                              (,_- ,_i 1)
                                              (,_cons3 (,_car ,_ls)
                                                       ,_res
                                                       ,_ls))))))))))
              ((identifier? (car p))
               (list _and (list _list? v)
                     (list _let (list (list (car p) v))
                           (k (cons (cons (car p) (+ 1 dim)) vars)))))
              (else
               (let* ((w (next-symbol "w."))
                      (_lp (next-symbol "lp."))
                      (new-vars (all-vars (car p) (+ dim 1)))
                      (ls-vars (map (lambda (x)
                                      (next-symbol
                                       (string-append
                                        (symbol->string
                                         (identifier->symbol (car x)))
                                        "-ls")))
                                    new-vars))
                      (once
                       (lp (car p) (list _car w) (+ dim 1) '()
                           (lambda (_)
                             (cons
                              _lp
                              (cons
                               (list _cdr w)
                               (map (lambda (x l)
                                      (list _cons (car x) l))
                                    new-vars
                                    ls-vars)))))))
                 (list
                  _let
                  _lp (cons (list w v)
                            (map (lambda (x) (list x (list _quote '()))) ls-vars))
                  (list _if (list _null? w)
                        (list _let (map (lambda (x l)
                                          (list (car x) (list _reverse l)))
                                        new-vars
                                        ls-vars)
                              (k (append new-vars vars)))
                        (list _and (list _pair? w) once)))))))
            ((pair? p)
             (list _and (list _pair? v)
                   (lp (car p)
                       (list _car v)
                       dim
                       vars
                       (lambda (vars)
                         (lp (cdr p) (list _cdr v) dim vars k)))))
            ((vector? p)
             (list _and
                   (list _vector? v)
                   (lp (vector->list p) (list _vector->list v) dim vars k)))
            ((null? p) (list _and (list _null? v) (k vars)))
            (else (list _and (list _equal? v p) (k vars))))))))
    (define ellipsis-mark?
      (if (if ellipsis-specified?
              (memq ellipsis lits)
              (any (lambda (x) (compare ellipsis x)) lits))
          (lambda (x) #f)
          (if ellipsis-specified?
              (lambda (x) (eq? ellipsis x))
              (lambda (x) (compare ellipsis x)))))
    (define (ellipsis-escape? x) (and (pair? x) (ellipsis-mark? (car x))))
    (define (ellipsis? x)
      (and (pair? x) (pair? (cdr x)) (ellipsis-mark? (cadr x))))
    (define (ellipsis-depth x)
      (if (ellipsis? x)
          (+ 1 (ellipsis-depth (cdr x)))
          0))
    (define (ellipsis-tail x)
      (if (ellipsis? x)
          (ellipsis-tail (cdr x))
          (cdr x)))
    (define (all-vars x dim)
      (let lp ((x x) (dim dim) (vars '()))
        (cond ((identifier? x)
               (if (or (memq x lits)
                       (compare x _underscore))
                   vars
                   (cons (cons x dim) vars)))
              ((ellipsis? x) (lp (car x) (+ dim 1) (lp (cddr x) dim vars)))
              ((pair? x) (lp (car x) dim (lp (cdr x) dim vars)))
              ((vector? x) (lp (vector->list x) dim vars))
              (else vars))))
    (define (free-vars x vars dim)
      (let lp ((x x) (free '()))
        (cond
         ((identifier? x)
          (if (and (not (memq x free))
                   (cond ((assq x vars) => (lambda (cell) (>= (cdr cell) dim)))
                         (else #f)))
              (cons x free)
              free))
         ((pair? x) (lp (car x) (lp (cdr x) free)))
         ((vector? x) (lp (vector->list x) free))
         (else free))))
    (define (expand-template tmpl vars)
      (let lp ((t tmpl) (dim 0) (ell-esc #f))
        (cond
         ((identifier? t)
          (cond
           ((find (lambda (v) (eq? t (car v))) vars)
            => (lambda (cell)
                 (if (<= (cdr cell) dim)
                     t
                     (error "too few ...'s"))))
           (else
            (list _rename (list _quote t)))))
         ((pair? t)
          (cond
           ((and (ellipsis-escape? t) (not ell-esc))
            (lp (if (and (pair? (cdr t)) (null? (cddr t))) (cadr t) (cdr t)) dim #t))
           ((and (ellipsis? t) (not ell-esc))
            (let* ((depth (ellipsis-depth t))
                   (ell-dim (+ dim depth))
                   (ell-vars (free-vars (car t) vars ell-dim)))
              (cond
               ((null? ell-vars)
                (error "too many ...'s"))
               ((and (null? (cdr (cdr t))) (identifier? (car t)))
                ;; shortcut for (var ...)
                (lp (car t) ell-dim ell-esc))
               (else
                (let* ((once (lp (car t) ell-dim ell-esc))
                       (nest (if (and (null? (cdr ell-vars))
                                      (identifier? once)
                                      (eq? once (car vars)))
                                 once ;; shortcut
                                 (cons _map
                                       (cons (list _lambda ell-vars once)
                                             ell-vars))))
                       (many (do ((d depth (- d 1))
                                  (many nest
                                        (list _apply _append many)))
                                 ((= d 1) many))))
                  (if (null? (ellipsis-tail t))
                      many ;; shortcut
                      (list _append many (lp (ellipsis-tail t) dim ell-esc))))))))
           (else (list _cons3 (lp (car t) dim ell-esc) (lp (cdr t) dim ell-esc) (list _quote t)))))
         ((vector? t) (list _list->vector (lp (vector->list t) dim ell-esc)))
         ((null? t) (list _quote '()))
         (else t))))
    (list
     _er-macro-transformer
     (list _lambda (list _expr _rename _compare)
           (list
            _car
            (cons
             _or
             (append
              (map
               (lambda (clause)
                 (if (and (list? clause) (= (length clause) 2))
                     (expand-pattern (car clause) (cadr clause))
                     (error "invalid syntax-rules clause, which must be of the form (pattern template) (note fenders are not supported)"
                            clause)))
               forms)
              (list
               (list _cons
                     (list _error "no expansion for"
                           (list (rename 'strip-syntactic-closures) _expr))
                     #f)))))))))

(define-syntax syntax-rules
  (er-macro-transformer
   (lambda (expr rename compare)
     (syntax-rules-transformer expr rename compare))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; let(rec)-syntax and datum->syntax

(define (symbol->identifier id symbol)
  (cond
   ((symbol? id)
    symbol)
   ((syntactic-closure-rename id)
    => (lambda (renamer)
         (renamer symbol)))
   (else
    symbol)))

;; TODO: Handle cycles in datum.
(define (datum->syntax id datum)
  (let loop ((datum datum))
    (cond ((pair? datum)
           (cons (loop (car datum))
                 (loop (cdr datum))))
          ((vector? datum)
           (do ((res (make-vector (vector-length datum)))
                (i 0 (+ i 1)))
               ((= i (vector-length datum)) res)
             (vector-set! res i (loop (vector-ref datum i)))))
          ((symbol? datum)
           (symbol->identifier id datum))
          (else
           datum))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; additional syntax

(define-syntax syntax-error
  (er-macro-transformer
   (lambda (expr rename compare)
     (apply error (cdr expr)))))

(define-syntax letrec*
  (syntax-rules ()
    ((letrec* ((var val) ...) . body)
     (let () (define var val) ... . body))))

(define-syntax let-optionals*
  (syntax-rules ()
    ((let-optionals* opt-ls () . body)
     (begin . body))
    ((let-optionals* (op . args) vars . body)
     (let ((tmp (op . args)))
       (let-optionals* tmp vars . body)))
    ((let-optionals* tmp ((var default) . rest) . body)
     (let ((var (if (pair? tmp) (car tmp) default))
           (tmp2 (if (pair? tmp) (cdr tmp) '())))
       (let-optionals* tmp2 rest . body)))
    ((let-optionals* tmp (var . rest) . body)
     (let ((var (car tmp)))
       (let-optionals* (cdr tmp) rest . body)))
    ((let-optionals* tmp tail . body)
     (let ((tail (list-copy tmp))) . body))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; exceptions

;; We wrap continuable objects in specially marked exceptions.
(define (raise-continuable exn)
  (raise (make-exception 'continuable "" exn #f #f)))

(cond-expand
 (threads
  (define (%with-exception-handler handler thunk)
    (let* ((old (thread-parameters))
           (new (cons (cons current-exception-handler handler) old)))
      (dynamic-wind
        (lambda () (thread-parameters-set! new))
        thunk
        (lambda () (thread-parameters-set! old))))))
 (else
  (define (%with-exception-handler handler thunk)
    (let ((old (current-exception-handler)))
      (dynamic-wind
        (lambda () (current-exception-handler handler))
        thunk
        (lambda () (current-exception-handler old)))))))

(define (with-exception-handler handler thunk)
  (letrec ((orig-handler (current-exception-handler))
           (self (lambda (exn)
                   (%with-exception-handler orig-handler
                     (lambda ()
                       (cond
                        ((and (exception? exn)
                              (eq? 'continuable (exception-kind exn)))
                         (handler (exception-irritants exn)))
                        (else
                         (handler exn)
                         (error "exception handler returned"))))))))
    (%with-exception-handler self thunk)))

(define-syntax protect
  (syntax-rules ()
    ((protect (var clause ...) e1 e2 ...)
     (let ((orig-handler (current-exception-handler)))
       (call-with-current-continuation
        (lambda (protect-k)
          (with-exception-handler
           (lambda (condition)
             (let ((var condition))  ; clauses may set! var
               (protect-k
                (protect-aux (raise-continuable condition) clause ...))))
           (lambda () e1 e2 ...))))))))

(define-syntax protect-aux
  (syntax-rules (else =>)
    ((protect-aux reraise (else result1 result2 ...))
     (begin result1 result2 ...))
    ((protect-aux reraise (test => result))
     (let ((temp test))
       (if temp (result temp) reraise)))
    ((protect-aux reraise (test => result) clause1 clause2 ...)
     (let ((temp test))
       (if temp (result temp) (protect-aux reraise clause1 clause2 ...))))
    ((protect-aux reraise (test))
     (or test reraise))
    ((protect-aux reraise (test) clause1 clause2 ...)
     (or test (protect-aux reraise clause1 clause2 ...)))
    ((protect-aux reraise (test result1 result2 ...))
     (if test (begin result1 result2 ...) reraise))
    ((protect-aux reraise (test result1 result2 ...) clause1 clause2 ...)
     (if test
         (begin result1 result2 ...)
         (protect-aux reraise clause1 clause2 ...)))))

;; Similar to unwind-protect, but allows escape via continuations
;; assuming they'll return, whereas exceptions are assumed to not return.
(define (with-exception-protect thunk final)
  (let* ((finalized? #f)
         (run-finalize
          (lambda ()
            (cond ((not finalized?)
                   (set! finalized? #t)
                   (final))))))
    (protect (exn (else (run-finalize) (raise exn)))
      (let ((res (thunk)))
        (run-finalize)
        res))))

(define-syntax exception-protect
  (syntax-rules ()
    ((exception-protect expr final)
     (with-exception-protect (lambda () expr)  (lambda () final)))))

(define (eval x . o)
  (let ((thunk (compile x (if (pair? o) (car o) (interaction-environment)))))
    (if (procedure? thunk) (thunk) (raise thunk))))

(define (load file . o)
  (let* ((env (if (pair? o) (car o) (interaction-environment)))
         (len (if (port? file) 0 (string-length file)))
         (ext *shared-object-extension*)
         (ext-len (string-length ext)))
    (cond
     ((and (> len ext-len 0) (equal? ext (substring file (- len ext-len))))
      (%load file env))
     (else
      (let ((old-env (current-environment)))
        (dynamic-wind
          (lambda () (set-current-environment! env))
          (lambda ()
            (let ((in (if (port? file) file (open-input-file file))))
              (set-port-line! in 1)
              (let lp ((res (if #f #f)))
                (let ((x (read in)))
                  (cond
                   ((eof-object? x)
                    (if (not (port? file))
                        (close-input-port in)))
                   (else
                    (lp (eval x env))))))))
          (lambda () (set-current-environment! old-env))))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; promises

(cond-expand
 (auto-force
  )
 (else
  (define *promise-tag* (list 'promise))
  (define (promise done? proc)
    (cons (cons done? proc) *promise-tag*))
  (define (promise? x)
    (and (pair? x) (eq? *promise-tag* (cdr x))))
  (define (promise-done? x) (car (car x)))
  (define (promise-value x) (cdr (car x)))
  (define (promise-update! new old)
    (set-car! (car old) (promise-done? new))
    (set-cdr! (car old) (promise-value new))
    (set-car! new (car old)))
  (define (force promise)
    (if (promise-done? promise)
        (promise-value promise)
        (let ((promise* ((promise-value promise))))
          (if (not (promise-done? promise))
            (promise-update! promise* promise))
          (force promise))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; math utils

(cond-expand
 (complex
  (define (exact-complex? x)
    (and (%complex? x) (exact? (complex-real x)) (exact? (complex-imag x)))))
 (else
  (define (%complex? x) #f)
  (define (exact-complex? x) #f)))

(cond-expand
 (ratios
  (cond-expand
   (complex
    (define (exact? x)
      (if (fixnum? x)
          #t
          (if (bignum? x) #t (if (ratio? x) #t (exact-complex? x))))))
   (else
    (define (exact? x) (if (fixnum? x) #t (if (bignum? x) #t (ratio? x))))))
  (define (numerator x)
    (if (ratio? x)
        (ratio-numerator x)
        (if (inexact? x)
            (exact->inexact (numerator (inexact->exact x)))
            x)))
  (define (denominator x)
    (if (exact? x)
        (if (ratio? x) (ratio-denominator x) 1)
        (if (integer? x)
            1.0
            (exact->inexact (denominator (inexact->exact x)))))))
 (else
  (define (ratio? x) #f)
  (cond-expand
   (complex
    (define (exact? x)
      (if (fixnum? x) #t (if (bignum? x) #t (exact-complex? x)))))
   (else
    (define (exact? x) (if (fixnum? x) #t (bignum? x)))))
  (define (numerator x)
    (if (integer? x) x (numerator (* x 10))))
  (define (denominator x)
    (if (exact? x)
        1
        (let lp ((x x) (r 1.0)) (if (integer? x) r (lp (* x 10) (* r 10))))))))

(cond-expand
 (complex
  (define (inexact? x)
    (if (flonum? x) #t (and (%complex? x) (not (exact-complex? x))))))
 (else (define inexact? flonum?)))
(define (exact-integer? x) (if (fixnum? x) #t (bignum? x)))
(define (integer? x)
  (if (exact-integer? x) #t (and (flonum? x) (= x (truncate x)))))
(define (number? x) (if (inexact? x) #t (exact? x)))
(define complex? number?)
(cond-expand
 (complex (define (real? x) (and (number? x) (not (%complex? x)))))
 (else (define real? number?)))
(define (rational? x)
  (and (real? x)
       (= x x)
       (if (or (> x 1) (< x -1))
           (not (= x (/ x 2)))
           (<= -1 x 1))))

(define (eqv? a b) (if (eq? a b) #t (and (number? a) (equal? a b))))

(define (zero? x) (= x 0))
(define (positive? x) (> x 0))
(define (negative? x) (< x 0))
(define (even? n) (= (remainder n 2) 0))
(define (odd? n) (not (= (remainder n 2) 0)))

(define (abs x) (if (< x 0) (- x) x))

(define (modulo a b)
  (let ((res (remainder a b)))
    (if (< b 0)
        (if (<= res 0) res (+ res b))
        (if (>= res 0) res (+ res b)))))

(define (gcd2 a b)
  (if (= b 0)
      (abs a)
      (gcd b (remainder a b))))

(define (gcd . args)
  (if (null? args)
      0
      (let lp ((x (car args)) (ls (cdr args)))
        (if (null? ls) x (lp (gcd2 x (car ls)) (cdr ls))))))

(define (lcm2 a b)
  (abs (quotient (* a b) (gcd a b))))

(define (lcm . args)
  (if (null? args)
      1
      (let lp ((x (car args)) (ls (cdr args)))
        (if (null? ls) x (lp (lcm2 x (car ls)) (cdr ls))))))

(define (max x . rest)
  (define (~max hi ls)
    (if (null? ls)
        (exact->inexact hi)
        (~max (if (> (car ls) hi) (car ls) hi) (cdr ls))))
  (if (inexact? x)
      (~max x rest)
      (let lp ((hi x) (ls rest))
        (cond ((null? ls) hi)
              ((inexact? (car ls)) (~max hi ls))
              (else (lp (if (> (car ls) hi) (car ls) hi) (cdr ls)))))))

(define (min x . rest)
  (define (~min lo ls)
    (if (null? ls)
        (exact->inexact lo)
        (~min (if (< (car ls) lo) (car ls) lo) (cdr ls))))
  (if (inexact? x)
      (~min x rest)
      (let lp ((lo x) (ls rest))
        (cond ((null? ls) lo)
              ((inexact? (car ls)) (~min lo ls))
              (else (lp (if (< (car ls) lo) (car ls) lo) (cdr ls)))))))

(cond-expand
 (complex
  (define (real-part z) (if (%complex? z) (complex-real z) z))
  (define (imag-part z) (if (%complex? z) (complex-imag z) 0))
  (define (magnitude z)
    (sqrt (+ (* (real-part z) (real-part z))
             (* (imag-part z) (imag-part z)))))
  (define (angle z) (atan (imag-part z) (real-part z)))
  (define (make-rectangular x y)
    (+ x (* y (sqrt -1))))
  (define (make-polar r phi)
    (make-rectangular (* r (cos phi)) (* r (sin phi)))))
 (else
  (define (real-part z) z)
  (define (imag-part z) 0.0)
  (define magnitude abs)
  (define (angle z) (if (< z 0) 3.141592653589793 0))))

(define (log x . o)
  (if (pair? o) (/ (ln x) (ln (car o))) (ln x)))

(define (atan y . o)
  (define (inf? z) (if (= +inf.0 z) #t (= -inf.0 z)))
  (if (null? o)
      (atan1 y)
      (let ((x (exact->inexact (car o))))
        (if (and (inf? x) (inf? y))
            (* (if (< y 0) -1 1) (if (= x -inf.0) 3 1) 0.7853981633974483)
            (if (negative? x)
                (if (or (negative? y) (eqv? y -0.0))
                    (- (atan1 (/ y x)) 3.141592653589793)
                    (- 3.141592653589793 (atan1 (/ y (- x)))))
                (if (and (zero? x) (zero? y))
                    (* (if (eqv? y -0.0) -1 1)
                       (if (eqv? x -0.0) 3.141592653589793 x))
                    (atan1 (/ y x))))))))
(define-library (chibi apropos)
  (export apropos apropos-list)
  (import (scheme base) (chibi) (chibi string) (srfi 1) (srfi 95))
  (include "apropos.scm"))

(define (optimize-rest ast)
  (cond
   ((and (lambda? ast)
         (not (list? (lambda-params ast)))
         (rest-parameter-cdrs ast))
    => (lambda (cdrs)
         (replace-rest-destructuring-with-stack-references
          (length* (lambda-params ast))
          ast
          cdrs)))
   (else
    ast)))

(define safe-primitives (list car cdr null? pair?))

(define (adjust-cdrs cdrs f params args)
  (filter-map
   (lambda (p a)
     (match a
       (((? (lambda (op) (eq? op cdr))) ($ Ref name (_ . (? lambda? lam))))
        (let ((x (find (lambda (r)
                         (and (eq? name (car r)) (eq? lam (cadr r))))
                       cdrs)))
          (and x (list p f (+ (car (cddr x)) 1)))))
       (($ Cnd
           ((? (lambda (op) (eq? op pair?))) ($ Ref name (_ . (? lambda? lam))))
           ((? (lambda (op) (eq? op cdr))) ($ Ref name (_ . (? lambda? lam))))
           (or () ($ Lit ())))
        (let ((x (find (lambda (r)
                         (and (eq? name (car r)) (eq? lam (cadr r))))
                       cdrs)))
          (and x (list p f (+ (car (cddr x)) 1.0)))))
       (else #f)))
   params
   args))

(define (rest-parameter-cdrs ast)
  (let analyze ((x (lambda-body ast))
                (cdrs (list (list (dotted-tail (lambda-params ast)) ast 0)))
                (safe? #t))
    (define (recurse x cdrs) (analyze x cdrs safe?))
    (match x
      (($ Ref name (_ . (? lambda? f)))
       (and (not (any (lambda (r) (and (eq? name (car r)) (eq? f (cadr r)))) cdrs))
            cdrs))
      (($ Set ref value)
       (and (recurse ref cdrs) (recurse value cdrs)))
      (($ Cnd test pass fail)
       (fold-every recurse cdrs (list test pass fail)))
      (($ Seq ls)
       (fold-every recurse cdrs ls))
      (($ Lam name params body)
       (analyze body cdrs #f))
      (((and ($ Lam _ (params ...) body) f) args ...)
       (let ((cdrs (fold-every recurse cdrs args)))
         (and (equal? (length params) (length args))
              (recurse body (append (adjust-cdrs cdrs f params args) cdrs)))))
      (((? opcode? op) ($ Ref _ (_ . (? lambda?))))
       (if (and safe? (memq op safe-primitives))
           cdrs
           (recurse (cadr x) cdrs)))
      ((app ...)
       (fold-every recurse cdrs app))
      (else
       cdrs))))

(define (replace-rest-destructuring-with-stack-references base ast cdrs)
  (define (rename p)
    (make-syntactic-closure
     (current-environment) '() (strip-syntactic-closures p)))
  (define (replace-param x)
    (match x
      (($ Cnd test pass fail)
       (make-cnd (replace-param test)
                 (replace-param pass)
                 (replace-param fail)))
      (($ Seq ls)
       (let ((ls (map replace-param ls)))
         (and ls (make-seq ls))))
      (((? opcode? op) ($ Ref name (_ . (? lambda? f))))
       (let ((r (and (memq op safe-primitives)
                     (find (lambda (r) (and (eq? name (car r)) (eq? f (cadr r))))
                           cdrs))))
         (cond
          ((not r)
           x)
          ((eq? op car)
           `(,local-ref ,(+ 1 (inexact->exact (car (cddr r))))))
          ((eq? op cdr)
           (make-lit '()))
          ((eq? op pair?)
           `(,> (,num-parameters) ,(+ base (inexact->exact (car (cddr r))))))
          ((eq? op null?)
           `(,<= (,num-parameters) ,(+ base (inexact->exact (car (cddr r))))))
          (else
           x))))
      (($ Set ref value)
       #f)
      (($ Lam name params body)
       #f)
      ((app ...)
       #f)
      (else
       x)))
  (lambda-body-set!
   ast
   (let replace ((x (lambda-body ast)))
     (match x
       ((($ Lam name (params ...) body) args ...)
        (let* ((locals (map replace-param args))
               (names (map rename params))
               (refs (map (lambda (name) (make-ref name (cons name ast))) names)))
          (let ((res (fold (lambda (p new res)
                             (replace-references res p (car x) new))
                           (replace body)
                           params
                           refs)))
            (lambda-locals-set! ast (append names (lambda-locals ast)))
            (join-seq (make-seq (map make-set refs locals))
                      res))))
       (else
        x))))
  ast)

(register-lambda-optimization! optimize-rest)

(define-library (chibi optimize rest)
  (export optimize-rest rest-parameter-cdrs num-parameters local-ref)
  (import (chibi) (srfi 1) (chibi ast) (chibi match) (chibi optimize))
  (include-shared "rest")
  (include "rest.scm"))

(define-library (chibi optimize profile)
  (export optimize-profile increment-cdr! profile-reset profile-report)
  (import (chibi) (srfi 1) (srfi 69) (srfi 95)
          (chibi ast) (chibi match) (chibi optimize))
  (include-shared "profile")
  (include "profile.scm"))

(define (ref=? a b)
  (or (eq? a b)
      (and (ref? a) (ref? b)
           (eq? (ref-name a) (ref-name b))
           (eq? (car (ref-cell a)) (car (ref-cell b)))
           (eq? (cdr (ref-cell a)) (cdr (ref-cell b))))))

(define profile-cells '())

(define (profile-get-cell f)
  (or (assoc f profile-cells ref=?)
      (let ((cell (cons f 0)))
        (set! profile-cells (cons cell profile-cells))
        cell)))

(define (profile-reset)
  (for-each (lambda (x) (set-cdr! x 0)) profile-cells))

(define (profile-report)
  (define (report-op op)
    (match op
      (($ Ref name (p . (and ($ Lam lam-name) f)))
       (write name)
       (cond
        ((not (eq? p name))
         (display " ")
         (write p)))
       (cond
        ((lambda-source f)
         (display " [") (write (lambda-source f)) (display "]"))))
      (($ Ref name (_ . f))
       (write name) (display " (") (write f) (display ")"))
      (else
       (write op))))
  (let ((ls (filter (lambda (x) (> (cdr x) 0))
                    profile-cells)))
    (for-each (lambda (x)
                (write (cdr x)) (display ": ")
                (report-op (car x)) (newline))
              (sort ls > cdr))))

(define (optimize-profile ast)
  (let-syntax ((opt (syntax-rules () ((opt x) (optimize-profile x)))))
    (match ast
      (($ Set ref value)
       (set-value-set! ast (opt value))
       ast)
      (($ Cnd test pass fail)
       (make-cnd (opt test) (opt pass) (opt fail)))
      (($ Seq ls)
       (make-seq (map optimize-profile ls)))
      (($ Lam name params body)
       (lambda-body-set! ast (opt body))
       ast)
      ((($ Ref name cell) args ...)
       (make-seq (list (list increment-cdr!
                             (make-lit (profile-get-cell (car ast))))
                       (cons (car ast) (map optimize-profile args)))))
      ((app ...)
       (map optimize-profile app))
      (else
       ast))))

(register-lambda-optimization! optimize-profile)
(define-library (chibi numeric-test)
  (export run-tests)
  (import (scheme base) (scheme inexact) (chibi test))
  (begin
    (define (integer-neighborhoods x)
      (list x (+ 1 x) (+ -1 x) (- x) (- 1 x) (- -1 x)))
    (define (factorial n) (if (= n 0) 1 (* n (factorial (- n 1)))))
    (define (atanh z) (/ (- (log (+ 1 z)) (log (- 1 z))) 2))
    (define (integer-arithmetic-combinations a b)
      (list (+ a b) (- a b) (* a b) (quotient a b) (remainder a b)))
    (define (sign-combinations a b)
      (list (integer-arithmetic-combinations a b)
            (integer-arithmetic-combinations (- a) b)
            (integer-arithmetic-combinations a (- b))
            (integer-arithmetic-combinations (- a) (- b))))
    (define (run-tests)
      (test-begin "numbers")

      (test 0 (expt 0 1))
      (test 1 (expt 3 0))
      (test 3 (expt 3 1))
      (test 1/3 (expt 3 -1))
      (test 1/300000000000000000000 (expt 300000000000000000000 -1))
      (test 16384.0 (expt 2 14.0))

      (test '(536870912 536870913 536870911 -536870912 -536870911 -536870913)
          (integer-neighborhoods (expt 2 29)))

      (test '(1073741824 1073741825 1073741823
                         -1073741824 -1073741823 -1073741825)
          (integer-neighborhoods (expt 2 30)))

      (test '(2147483648 2147483649 2147483647
                         -2147483648 -2147483647 -2147483649)
          (integer-neighborhoods (expt 2 31)))

      (test '(4294967296 4294967297 4294967295
                         -4294967296 -4294967295 -4294967297)
          (integer-neighborhoods (expt 2 32)))

      (test '(4611686018427387904 4611686018427387905 4611686018427387903
                                  -4611686018427387904 -4611686018427387903 -4611686018427387905)
          (integer-neighborhoods (expt 2 62)))

      (test '(9223372036854775808 9223372036854775809 9223372036854775807
                                  -9223372036854775808 -9223372036854775807 -9223372036854775809)
          (integer-neighborhoods (expt 2 63)))

      (test '(18446744073709551616 18446744073709551617 18446744073709551615
                                   -18446744073709551616 -18446744073709551615 -18446744073709551617)
          (integer-neighborhoods (expt 2 64)))

      (test '(85070591730234615865843651857942052864
              85070591730234615865843651857942052865
              85070591730234615865843651857942052863
              -85070591730234615865843651857942052864
              -85070591730234615865843651857942052863
              -85070591730234615865843651857942052865)
          (integer-neighborhoods (expt 2 126)))

      (test '(170141183460469231731687303715884105728
              170141183460469231731687303715884105729
              170141183460469231731687303715884105727
              -170141183460469231731687303715884105728
              -170141183460469231731687303715884105727
              -170141183460469231731687303715884105729)
          (integer-neighborhoods (expt 2 127)))

      (test '(340282366920938463463374607431768211456
              340282366920938463463374607431768211457
              340282366920938463463374607431768211455
              -340282366920938463463374607431768211456
              -340282366920938463463374607431768211455
              -340282366920938463463374607431768211457)
          (integer-neighborhoods (expt 2 128)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

      ;; fix x fix
      (test '((1 -1 0 0 0) (1 -1 0 0 0) (-1 1 0 0 0) (-1 1 0 0 0))
          (sign-combinations 0 1))
      (test '((2 0 1 1 0) (0 -2 -1 -1 0) (0 2 -1 -1 0) (-2 0 1 1 0))
          (sign-combinations 1 1))
      (test '((59 25 714 2 8) (-25 -59 -714 -2 -8)
              (25 59 -714 -2 8) (-59 -25 714 2 -8))
          (sign-combinations 42 17))

      ;; fix x big
      (test '((4294967338 -4294967254 180388626432 0 42)
              (4294967254 -4294967338 -180388626432 0 -42)
              (-4294967254 4294967338 -180388626432 0 42)
              (-4294967338 4294967254 180388626432 0 -42))
          (sign-combinations 42 (expt 2 32)))

      ;; big x fix
      (test '((4294967338 4294967254 180388626432 102261126 4)
              (-4294967254 -4294967338 -180388626432 -102261126 -4)
              (4294967254 4294967338 -180388626432 -102261126 4)
              (-4294967338 -4294967254 180388626432 102261126 -4))
          (sign-combinations (expt 2 32) 42))

      ;; big x bigger
      (test '((12884901889 -4294967297 36893488151714070528 0 4294967296)
              (4294967297 -12884901889 -36893488151714070528 0 -4294967296)
              (-4294967297 12884901889 -36893488151714070528 0 4294967296)
              (-12884901889 4294967297 36893488151714070528 0 -4294967296))
          (sign-combinations (expt 2 32) (+ 1 (expt 2 33))))

      (test '((18446744078004518913 -18446744069414584321
                                    79228162514264337597838917632
                                    0 4294967296)
              (18446744069414584321 -18446744078004518913
                                    -79228162514264337597838917632
                                    0 -4294967296)
              (-18446744069414584321 18446744078004518913
                                     -79228162514264337597838917632
                                     0 4294967296)
              (-18446744078004518913 18446744069414584321
                                     79228162514264337597838917632
                                     0 -4294967296))
          (sign-combinations (expt 2 32) (+ 1 (expt 2 64))))

      ;; bigger x big
      (test '((12884901889 4294967297 36893488151714070528 2 1)
              (-4294967297 -12884901889 -36893488151714070528 -2 -1)
              (4294967297 12884901889 -36893488151714070528 -2 1)
              (-12884901889 -4294967297 36893488151714070528 2 -1))
          (sign-combinations (+ 1 (expt 2 33)) (expt 2 32)))

      (test '((18446744078004518913 18446744069414584321
                                    79228162514264337597838917632
                                    4294967296 1)
              (-18446744069414584321 -18446744078004518913
                                     -79228162514264337597838917632
                                     -4294967296 -1)
              (18446744069414584321 18446744078004518913
                                    -79228162514264337597838917632
                                    -4294967296 1)
              (-18446744078004518913 -18446744069414584321
                                     79228162514264337597838917632
                                     4294967296 -1))
          (sign-combinations (+ 1 (expt 2 64)) (expt 2 32)))

      (test '((170141183460469231750134047789593657344
               170141183460469231713240559642174554110
               3138550867693340382088035895064302439764418281874191810559
               9223372036854775807
               9223372036854775808)
              (-170141183460469231713240559642174554110
               -170141183460469231750134047789593657344
               -3138550867693340382088035895064302439764418281874191810559
               -9223372036854775807
               -9223372036854775808)
              (170141183460469231713240559642174554110
               170141183460469231750134047789593657344
               -3138550867693340382088035895064302439764418281874191810559
               -9223372036854775807
               9223372036854775808)
              (-170141183460469231750134047789593657344
               -170141183460469231713240559642174554110
               3138550867693340382088035895064302439764418281874191810559
               9223372036854775807
               -9223372036854775808))
          (sign-combinations (- (expt 2 127) 1) (+ 1 (expt 2 64))))

      ;; fixnum-bignum boundaries (machine word - 1 bit for sign - 2
      ;; bits for tag)

      (test 8191 (- -8191))
      (test 8192 (- -8192))
      (test 8193 (- -8193))

      (test 536870911 (- -536870911))
      (test 536870912 (- -536870912))
      (test 536870913 (- -536870913))

      (test 2305843009213693951 (- -2305843009213693951))
      (test 2305843009213693952 (- -2305843009213693952))
      (test 2305843009213693953 (- -2305843009213693953))

      (test 42535295865117307932921825928971026431
          (- -42535295865117307932921825928971026431))
      (test 42535295865117307932921825928971026432
          (- -42535295865117307932921825928971026432))
      (test 42535295865117307932921825928971026433
          (- -42535295865117307932921825928971026433))

      (test '((536879104 -536862720 4398046511104 0 8192)
              (536862720 -536879104 -4398046511104 0 -8192)
              (-536862720 536879104 -4398046511104 0 8192)
              (-536879104 536862720 4398046511104 0 -8192))
          (sign-combinations (expt 2 13) (expt 2 29)))

      (test '((536879104 536862720 4398046511104 65536 0)
              (-536862720 -536879104 -4398046511104 -65536 0)
              (536862720 536879104 -4398046511104 -65536 0)
              (-536879104 -536862720 4398046511104 65536 0))
          (sign-combinations (expt 2 29) (expt 2 13)))

      (test '((2305843009750564864 -2305843008676823040
                                   1237940039285380274899124224 0 536870912)
              (2305843008676823040 -2305843009750564864
                                   -1237940039285380274899124224 0 -536870912)
              (-2305843008676823040 2305843009750564864
                                    -1237940039285380274899124224 0 536870912)
              (-2305843009750564864 2305843008676823040
                                    1237940039285380274899124224 0 -536870912))
          (sign-combinations (expt 2 29) (expt 2 61)))

      (test '((2305843009750564864 2305843008676823040
                                   1237940039285380274899124224 4294967296 0)
              (-2305843008676823040 -2305843009750564864
                                    -1237940039285380274899124224 -4294967296 0)
              (2305843008676823040 2305843009750564864
                                   -1237940039285380274899124224 -4294967296 0)
              (-2305843009750564864 -2305843008676823040
                                    1237940039285380274899124224 4294967296 0))
          (sign-combinations (expt 2 61) (expt 2 29)))

      (test '((42535295865117307935227668938184720384
               -42535295865117307930615982919757332480
               98079714615416886934934209737619787751599303819750539264
               0
               2305843009213693952)
              (42535295865117307930615982919757332480
               -42535295865117307935227668938184720384
               -98079714615416886934934209737619787751599303819750539264
               0
               -2305843009213693952)
              (-42535295865117307930615982919757332480
               42535295865117307935227668938184720384
               -98079714615416886934934209737619787751599303819750539264
               0
               2305843009213693952)
              (-42535295865117307935227668938184720384
               42535295865117307930615982919757332480
               98079714615416886934934209737619787751599303819750539264
               0
               -2305843009213693952))
          (sign-combinations (expt 2 61) (expt 2 125)))

      (test '((42535295865117307935227668938184720384
               42535295865117307930615982919757332480
               98079714615416886934934209737619787751599303819750539264
               18446744073709551616
               0)
              (-42535295865117307930615982919757332480
               -42535295865117307935227668938184720384
               -98079714615416886934934209737619787751599303819750539264
               -18446744073709551616
               0)
              (42535295865117307930615982919757332480
               42535295865117307935227668938184720384
               -98079714615416886934934209737619787751599303819750539264
               -18446744073709551616
               0)
              (-42535295865117307935227668938184720384
               -42535295865117307930615982919757332480
               98079714615416886934934209737619787751599303819750539264
               18446744073709551616
               0))
          (sign-combinations (expt 2 125) (expt 2 61)))

      ;; Regression tests for an overflow in bignum addition
      (test 8589869056
          (+ 4294934528 4294934528))
      (test 36893488143124135936
          (+ 18446744071562067968 18446744071562067968))
      (test 680564733841876926908302470789826871296
          (+ 340282366920938463454151235394913435648
             340282366920938463454151235394913435648))
      (test 231584178474632390847141970017375815706199686964360189615451793408394491068416
          (+ 115792089237316195423570985008687907853099843482180094807725896704197245534208
             115792089237316195423570985008687907853099843482180094807725896704197245534208))

      (let ((smallest-s64 -9223372036854775808)
            (small-bignum -100000000000000000000000000))
        (test-assert (> smallest-s64 small-bignum))
        (test-assert (< small-bignum smallest-s64)))

      (test #f (< +nan.0 +nan.0))
      (test #f (<= +nan.0 +nan.0))
      (test #f (= +nan.0 +nan.0))
      (test #f (>= +nan.0 +nan.0))
      (test #f (> +nan.0 +nan.0))

      (test #f (< +inf.0 +inf.0))
      (test #t (<= +inf.0 +inf.0))
      (test #t (= +inf.0 +inf.0))
      (test #t (>= +inf.0 +inf.0))
      (test #f (> +inf.0 +inf.0))

      (test #f (< -inf.0 -inf.0))
      (test #t (<= -inf.0 -inf.0))
      (test #t (= -inf.0 -inf.0))
      (test #t (>= -inf.0 -inf.0))
      (test #f (> -inf.0 -inf.0))

      (test #t (< -inf.0 +inf.0))
      (test #t (<= -inf.0 +inf.0))
      (test #f (= -inf.0 +inf.0))
      (test #f (>= -inf.0 +inf.0))
      (test #f (> -inf.0 +inf.0))

      (test 88962710306127702866241727433142015
          (string->number "#x00112233445566778899aabbccddeeff"))

      (test (expt 10 154) (sqrt (expt 10 308)))

      (test 36893488147419103231
          (- 340282366920938463463374607431768211456
             340282366920938463426481119284349108225))

      (test '(2147483647 4294967294)
          (call-with-values (lambda () (exact-integer-sqrt (- (expt 2 62) 1)))
            list))
      (test '(10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 0)
          (call-with-values (lambda () (exact-integer-sqrt (expt 10 308)))
            list))
      (test '(31622776601683793319988935444327185337195551393252168268575048527925944386392382213442481083793002951873472841528400551485488560304538800146905195967001539 2115514206302273599980766398157920200790560418205865231071804946360990550570367022991069288361418688781500755061112588417520206827470474760717813571631479)
          (call-with-values (lambda () (exact-integer-sqrt (expt 10 309)))
            list))

      ;; Steele's three-part test.
      (test #t #t)
      (test 100 (/ (factorial 100) (factorial 99)))
      (test -0.549306144334055+1.5707963267949i (atanh -2))

      ;; ... and variants
      (test -9900 (/ (- (factorial 100)) (factorial 98)))
      (test -10100 (/ (factorial 101) (- (factorial 99))))
      (test 100 (/ (- (factorial 100)) (- (factorial 98)) 99))

      (test 100000000000000000000000
          (string->number "100000000000000000000e3"))
      (test 1/100+8i
          (string->number "10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e-102+8i"))

      (test #t (< 1/2 1.0))
      (test #t (< 1.0 3/2))
      (test #t (< 1/2 1.5))
      (test #t (< 1/2 2.0))
      (test 1.0 (max 1/2 1.0))
      (test 18446744073709551617 (numerator (/ 18446744073709551617 2)))
      (test "18446744073709551617/2" (number->string (/ 18446744073709551617 2)))
      (let ((a 1000000000000000000000000000000000000000)
            (b 31622776601683794000))
        (test 31622776601683792639 (quotient a b))
        (test 30922992657207634000 (remainder a b)))
      (let ((g 18446744073709551616/6148914691236517205))
        (test 36893488147419103231/113427455640312821148309287786019553280
            (- g (/ 9 g))))
      (parameterize ((current-test-epsilon 1e-2))
        (test 0.011459
            (inexact 12017605191576564605523818479699032725649277767474470915174336170848732393575453450735711300329008209389459924841495413846951496975780183380894605321251029061627519460167494925074778514559449442501939557451941024018468063387066190930414864151964948746353911701589822769165039062500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000/1048736796801977873293967427489899791695438298067922611215197702964142873750784860800028103241622682379099257583628328311596508052097172881170612593367688231078402334012314961284218456715145088673704198639789178608986339123909192734212369587774017431294143287678378871830938194004625162192783829580954040802482154686468390982830152927306297304746125796640118510663301998101921329795871645487301048602221374988871811684449297195367)))
      (let ((r  (/ (expt 2 61) 3)))
        (test 0 (- r r))
        (test 2305843009213693952/3 r))
      (let ((x (+ (expt 2 32) +2))
            (y (+ (expt 2 32) -1)))
        (test 0(remainder (* x y) y))
        (test 0(remainder (* x y) x)))
      (let ((x (+ (expt 2 64) +2))
            (y (+ (expt 2 64) -1)))
        (test 0(remainder (* x y) y))
        (test 0(remainder (* x y) x)))

      (test-end))))

;;> A regular expression engine implementing SRFI 115 using a
;;> non-backtracking Thompson NFA algorithm.

(define-library (chibi regexp)
  (export regexp regexp? valid-sre? rx regexp->sre char-set->sre
          regexp-matches regexp-matches? regexp-search
          regexp-replace regexp-replace-all
          regexp-fold regexp-extract regexp-split regexp-partition
          regexp-match? regexp-match-count
          regexp-match-submatch regexp-match-submatch/list
          regexp-match-submatch-start regexp-match-submatch-end
          regexp-match->list regexp-match->sexp)
  (import (srfi 69))
  ;; Chibi's char-set library is more factored than SRFI-14.
  (cond-expand
   (chibi
    (import (rename (chibi)
                    (protect guard)
                    (char-downcase %char-downcase)
                    (char-upcase %char-upcase))
            (only (scheme char) char-downcase char-upcase)
            (srfi 9)
            (chibi char-set)
            (chibi char-set full)
            (prefix (chibi char-set ascii) %))
    (begin
      (define char-set:title-case
        (char-set-union
         (ucs-range->char-set #x1F88 #x1F90)
         (ucs-range->char-set #x1F98 #x1FA0)
         (ucs-range->char-set #x1FA8 #x1FB0)
         (char-set #\x01C5 #\x01C8 #\x01CB #\x01F2 #\x1FBC #\x1FCC #\x1FFC)))))
   (else
    (import (scheme base) (scheme char) (srfi 1) (srfi 14))
    (begin
      (define %char-set:letter
        (char-set-intersection char-set:ascii char-set:letter))
      (define %char-set:lower-case
        (char-set-intersection char-set:ascii char-set:lower-case))
      (define %char-set:upper-case
        (char-set-intersection char-set:ascii char-set:upper-case))
      (define %char-set:digit
        (char-set-intersection char-set:ascii char-set:digit))
      (define %char-set:letter+digit
        (char-set-intersection char-set:ascii char-set:letter+digit))
      (define %char-set:punctuation
        (char-set-intersection char-set:ascii char-set:punctuation))
      (define %char-set:symbol
        (char-set-intersection char-set:ascii char-set:symbol))
      (define %char-set:graphic
        (char-set-intersection char-set:ascii char-set:graphic))
      (define %char-set:whitespace
        (char-set-intersection char-set:ascii char-set:whitespace))
      (define %char-set:printing
        (char-set-intersection char-set:ascii char-set:printing))
      (define %char-set:iso-control
        (char-set-intersection char-set:ascii char-set:iso-control)))))
  (cond-expand
   ((library (srfi 151)) (import (srfi 151)))
   ((library (srfi 33)) (import (srfi 33)))
   (else (import (srfi 60))))
  (import (chibi char-set boundary))
  ;; Use string-cursors where available.
  (cond-expand
   (chibi
    (begin
      (define (string-start-arg s o)
        (if (pair? o) (string-index->cursor s (car o)) (string-cursor-start s)))
      (define (string-end-arg s o)
        (if (pair? o) (string-index->cursor s (car o)) (string-cursor-end s)))
      (define (string-concatenate-reverse ls)
        (string-concatenate (reverse ls)))))
   (else
    (begin
      (define (string-start-arg s o)
        (if (pair? o) (string-index->cursor s (car o)) 0))
      (define (string-end-arg s o)
        (if (pair? o) (string-index->cursor s (car o)) (string-length s)))
      (define string-cursor? integer?)
      (define string-cursor=? =)
      (define string-cursor<? <)
      (define string-cursor<=? <=)
      (define string-cursor>? >)
      (define string-cursor>=? >=)
      (define string-cursor-ref string-ref)
      (define (string-cursor-next s i) (+ i 1))
      (define (string-cursor-prev s i) (- i 1))
      (define substring-cursor substring)
      (define (string-cursor->index str off) off)
      (define (string-index->cursor str i) i)
      (define (string-concatenate ls) (apply string-append ls))
      (define (string-concatenate-reverse ls)
        (string-concatenate (reverse ls))))))
  (include "regexp.scm"))

;;> \section{Process Combinators}
;;>
;;> Running a command in a subprocess basically amounts to fork+exec.
;;> What becomes interesting is combining together multiple commands,
;;> conditionally based on exit codes and/or connecting their inputs
;;> and outputs.  More generally a variety of parameters or resources
;;> of the subprocess may be configured before the command is executed,
;;> including:
;;>
;;> \itemlist[
;;> \item{fileno configuration }
;;> \item{environment variables }
;;> \item{signal masks }
;;> \item{running user }
;;> \item{process groups }
;;> \item{resource limits (CPU, memory, disk I/O, network) }
;;> \item{prioritization }
;;> \item{namespace isolation }
;;> \item{virtual filesystems }
;;> ]
;;>
;;> Some of these can be specified by posix_spawn(3), but the more
;;> general features come from cgroups.
;;>
;;> We can build process combinators by abstracting this configuration
;;> from the execution.  The most basic case is a single command:
;;>
;;> \scheme{(shell-command (list <command> <args> ...))}
;;>
;;> This returns a procedure of two arguments, both thunks to run in
;;> the child process after the fork but before exec (one for input and
;;> one for output).  For example,
;;>
;;> \scheme{((shell-command '("ls")) (lambda () #t) (lambda () #t))}
;;>
;;> would run the ls command in a subprocess with no changes from the
;;> parent process, i.e. it would write to the parent process' stdout.
;;>
;;> Redirecting stdio to or from files is achieved by opening the file
;;> in the child process and calling dup() to match to the appropriate
;;> stdio fileno:
;;>
;;> \schemeblock{
;;> ((shell-command '("ls"))
;;>  (lambda () #t)
;;>  (lambda ()
;;>    (duplicate-file-descriptor-to
;;>     (open "out" (bitwise-ior open/write open/create open/truncate))
;;>     1)))}
;;>
;;> \schemeblock{
;;> ((shell-command '("grep" "define"))
;;>  (lambda ()
;;>    (duplicate-file-descriptor-to
;;>     (open "shell.scm" open/read)
;;>     0))
;;>  (lambda () #t))}
;;>
;;> This looks like a common pattern, so let's provide some utilities:
;;>
;;> \schemeblock{
;;> (define (redirect file mode fileno)
;;>   (duplicate-file-descriptor-to (open file mode) fileno))}
;;>
;;> \schemeblock{
;;> (define (in< file) (redirect file open/read 0))
;;> (define (out> file)
;;>   (redirect file (bitwise-ior open/write open/create open/truncate) 1))
;;> (define (err> file)
;;>   (redirect file (bitwise-ior open/write open/create open/truncate) 2))}
;;>
;;> so we can rewrite the examples as:
;;>
;;> \schemeblock{
;;> ((shell-command '("ls")) (lambda () #t) (lambda () (out> "out")))
;;> ((shell-command '("grep" "define"))
;;>  (lambda () (in< "shell.scm")) (lambda () #t))}
;;>
;;> We can use these combinators for more than I/O redirection.  For
;;> example, we can change the current working directory.  The
;;> semantics of many commands depends on the current working
;;> directory, so much so that some commands provide options to change
;;> the directory on startup (e.g. -C for git and make).  For commands
;;> which don't offer this convenience we can use process combinators
;;> to change directory only in the child without invoking extra
;;> processes:
;;>
;;> \schemeblock{
;;> ((shell-command '("cmake"))
;;>  (lambda () (change-directory project-dir))
;;>  (lambda () #t))}
;;>
;;> Another resource we may want to change is the user, e.g. via
;;> setuid.  Since we control the order of resource changes we can do
;;> things like the following example.  Here we run as root, providing
;;> access to the secret data in /etc/shadow, but extract only the row
;;> relevant to a specific user and write to a file owned by them:
;;>
;;> \schemeblock{
;;> (let ((user "alice"))
;;>   ((shell-command (list "grep" (string-append "^" user ":")))
;;>    (lambda ()
;;>      (in< "/etc/shadow")   ; read as root
;;>      (set-current-user-id! (user-id (user-information user))))
;;>    (lambda ()
;;>      (out> "my-shadow")))) ; written as user}
;;>
;;> This is already something not possible in bash (or posix_spawn)
;;> without resorting to additional subprocesses.
;;>
;;> We can in a similar manner also modify priority with nice, the
;;> filesystem with chroot, and change the cgroup, which otherwise is
;;> generally done with a wrapper script.
;;>
;;> Things get more interesting when we want to combine multiple
;;> commands.  We can connect the output of one process as the input
;;> to another with a pipe.  The following pipes the output of echo to
;;> tr, outputting "HELLO" to stdout:
;;>
;;> \schemeblock{
;;> ((shell-pipe (shell-command '(echo "hello"))
;;>              (shell-command '(tr "a-z" "A-Z")))
;;>  (lambda () #t)
;;>  (lambda () #t))}
;;>
;;> We can continue to build on these combinators, but for practical
;;> use a concise syntax is handy.  We provide the syntax
;;> \scheme{shell}, similar to SCSH's \scheme{run}, except that a
;;> single top-level pipe is implied.  The above becomes:
;;>
;;> \schemeblock{(shell (echo "hello") (tr "a-z" "A-Z"))}
;;>
;;> A command without any arguments can be written as a single symbol
;;> without a list:
;;>
;;> \schemeblock{(shell (echo "hello") rev)} => "olleh\n"
;;>
;;> You can chain together any number of commands, implicitly joined
;;> in a pipe.  I/O redirection works by putting the redirection
;;> operator after the command it modifies:
;;>
;;> \schemeblock{(shell cat (< "input.txt") (tr "a-z" "A-Z") (> "out"))}
;;>
;;> for the following operators:
;;>
;;> \itemlist[
;;> \item{ \scheme{(< input)}: redirect stdin from the file input }
;;> \item{ \scheme{(<< obj)}: redirect stdin from the displayed output of obj }
;;> \item{ \scheme{(> output)}: redirect stdout to the file output }
;;> \item{ \scheme{(>> output)}: append stdout to the file output }
;;> \item{ \scheme{(err> output)}: redirect stderr to the file output }
;;> \item{ \scheme{(err>> output)}: append stderr to the file output }
;;>  ]
;;>
;;> Commands can also be combined logically with several operators:
;;>
;;> \itemlist[
;;> \item{ \scheme{(do cmd1 cmd2 ...)}: run the commands in sequence }
;;> \item{ \scheme{(and cmd1 cmd2 ...)}: run the commands in sequence until the first fails }
;;> \item{ \scheme{(or cmd1 cmd2 ...)}: run the commands in sequence until the first succeeds }
;;> \item{ \scheme{(>< cmd1 cmd2 ...)}: pipe the output of each command to the input of the next }
;;> \item{ \scheme{(if test pass fail)}: if test succeeds run pass, else fail }
;;>  ]
;;>
;;> Note although piping is implicit in the \scheme{shell} syntax
;;> itself, the \scheme{><} operator can be useful for nested
;;> pipelines, or to structure a pipeline in one expression so you can
;;> group all I/O modifiers for it as a whole, e.g.
;;>
;;> \schemeblock{(shell (< x) cat rev (> y))}
;;>
;;> could also be written as
;;>
;;> \schemeblock{(shell (>< cat rev) (< x) (> y))}
;;>
;;> As a convenience, to collect the output to a string we have
;;> \scheme{shell->string};
;;>
;;> \schemeblock{(shell->string (echo "hello") (tr "a-z" "A-Z")) => "HELLO"}
;;>
;;> Similarly, the following variants are provided:
;;>
;;> \scheme{shell->string-list}: returns a list of one string per line
;;> \scheme{shell->sexp}: returns the output parsed as a sexp
;;> \scheme{shell->sexp-list}: returns a list of one sexp per line

(define-auxiliary-syntax ><)
(define-auxiliary-syntax <<)
(define-auxiliary-syntax >>)

(define (call-with-output-string proc)
  (let ((out (open-output-string)))
    (proc out)
    (get-output-string out)))

(define (close-file-descriptors-in-range lo hi)
  (cond
   ((find file-directory? '("/proc/self/fd" "/dev/fd"))
    => (lambda (dir)
         (for-each
          (lambda (file)
            (cond ((string->number file)
                   => (lambda (fd)
                        (when (<= lo fd hi)
                          (close-file-descriptor fd))))))
          (directory-files dir))))))

(define (shell-object->string x)
  (if (string? x) x (call-with-output-string (lambda (out) (display x out)))))

(define (shell-command cmd)
  (cond
   ((procedure? cmd)
    cmd)
   ((not (pair? cmd))
    (shell-command (list cmd)))
   (else
    (lambda (child-in child-out)
      (let ((pid (shell-fork)))
        (cond
         ((not pid)
          (error "couldn't fork"))
         ((zero? pid)                   ; child
          (child-in)
          (child-out)
          (let ((ls (map shell-object->string cmd)))
            (shell-exec (car ls) ls)
            (exit 0)))
         (else                          ; parent
          (list pid))))))))

(define (shell-scheme-command proc)
  (lambda (child-in child-out)
    (let ((pid (shell-fork)))
      (cond
       ((not pid)
        (error "couldn't fork"))
       ((zero? pid)                     ; child
        (child-in)
        (child-out)
        (proc)
        (exit 0))
       (else                            ; parent
        (list pid))))))

(define (shell-stdout-to-pipe pipe . o)
  (let ((fileno (if (pair? o) (car o) 1)))
    (close-file-descriptor (car pipe))
    (duplicate-file-descriptor-to (cdr pipe) fileno)
    (close-file-descriptor (cdr pipe))))

(define (shell-stderr-to-pipe pipe . o)
  (let ((fileno (if (pair? o) (car o) 2)))
    (close-file-descriptor (car pipe))
    (duplicate-file-descriptor-to (cdr pipe) fileno)
    (close-file-descriptor (cdr pipe))))

(define (shell-stdin-from-pipe pipe . o)
  (let ((fileno (if (pair? o) (car o) 0)))
    (close-file-descriptor (cdr pipe))
    (duplicate-file-descriptor-to (car pipe) fileno)
    (close-file-descriptor (car pipe))))

(define (shell-pipe cmd . cmds)
  (let ((cmd1 (shell-command cmd)))
    (if (null? cmds)
        cmd1
        (let ((cmd2 (apply shell-pipe cmds)))
          (lambda (child-in child-out)
            (cmd2
             (lambda ()
               (let ((pipe (shell-create-pipe)))
                 (let* ((pids
                         (cmd1
                          child-in
                          (lambda ()
                            (shell-stdout-to-pipe pipe)
                            (close-file-descriptors-in-range 3 +inf.0)))))
                   (shell-stdin-from-pipe pipe))))
             (lambda ()
               (child-out)
               (close-file-descriptors-in-range 3 +inf.0))))))))

;;;; variant starting the input process first
;; (define (shell-pipe cmd1 . cmds)
;;   (let ((cmd1 (shell-command cmd1)))
;;     (if (null? cmds)
;;         cmd1
;;         (let ((cmd2 (apply shell-pipe cmds)))
;;           (lambda (child-in child-out)
;;             (cmd1
;;              child-in
;;              (lambda ()
;;                (let ((pipe (shell-create-pipe)))
;;                  (let* ((pids
;;                          (cmd2
;;                           (lambda () (shell-stdin-from-pipe pipe))
;;                           (lambda ()
;;                             (child-out)
;;                             (close-file-descriptors-in-range 3 +inf.0)))))
;;                    (shell-stdout-to-pipe pipe)
;;                    (close-file-descriptors-in-range 3 +inf.0))))))))))

;;;; variant creating the pipe in the parent
;; (define (shell-pipe cmd1 . cmds)
;;   (let ((cmd1 (shell-command cmd1)))
;;     (if (null? cmds)
;;         cmd1
;;         (let ((cmd2 (apply shell-pipe cmds)))
;;           (lambda (child-in child-out)
;;             (let* ((pipe (shell-create-pipe))
;;                    (pid1
;;                     (cmd1 child-in
;;                           (lambda ()
;;                             (shell-stdout-to-pipe pipe)
;;                             (close-file-descriptors-in-range 3 +inf.0))))
;;                    (pid2
;;                     (cmd2 (lambda ()
;;                             (shell-stdin-from-pipe pipe))
;;                           (lambda ()
;;                             (child-out)
;;                             (close-file-descriptors-in-range 3 +inf.0)))))
;;               (close-file-descriptor (car pipe))
;;               (close-file-descriptor (cdr pipe))
;;               (append pid1 pid2)))))))

(define (shell-wait pid)
  (waitpid pid 0))

(define (shell-if test pass . o)
  (let ((fail (and (pair? o) (shell-command (car o)))))
    (lambda (child-in child-out)
      (let ((pids ((shell-command test) child-in child-out)))
        (if (every (lambda (pid) (zero? (cadr (shell-wait pid)))) pids)
            ((shell-command pass) child-in child-out)
            (if fail (fail child-in child-out) '()))))))

(define (shell-seq pred cmd . cmds)
  (lambda (child-in child-out)
    (let lp ((cmds (map shell-command (cons cmd cmds))))
      (cond
       ((null? cmds)
        '())
       ((null? (cdr cmds))
        ((car cmds) child-in child-out))
       (else
        (let ((pids ((car cmds) child-in child-out)))
          (if (pred (every (lambda (pid) (zero? (cadr (shell-wait pid)))) pids))
              (lp (cdr cmds))
              '())))))))

(define (shell-and cmd . cmds)
  (apply shell-seq values cmd cmds))

(define (shell-or cmd . cmds)
  (apply shell-seq not cmd cmds))

(define (shell-do cmd . cmds)
  (apply shell-seq (lambda (res) #t) cmd cmds))

(define (redirect file mode fileno)
  (duplicate-file-descriptor-to (open file mode) fileno))

(define (in< file) (redirect file open/read 0))
(define (out> file)
  (redirect file (bitwise-ior open/write open/create open/truncate) 1))
(define (out>> file)
  (redirect file (bitwise-ior open/write open/create open/append) 1))
(define (err> file)
  (redirect file (bitwise-ior open/write open/create open/truncate) 2))
(define (err>> file)
  (redirect file (bitwise-ior open/write open/create open/append) 2))

(define (with-in< file cmd)
  (lambda (in out)
    (cmd (lambda () (in) (in< file)) out)))
(define (with-out> file cmd)
  (lambda (in out)
    (cmd in (lambda () (out) (out> file)))))
(define (with-out>> file cmd)
  (lambda (in out)
    (cmd in (lambda () (out) (out>> file)))))
(define (with-err> file cmd)
  (lambda (in out)
    (cmd in (lambda () (out) (err> file)))))
(define (with-err>> file cmd)
  (lambda (in out)
    (cmd in (lambda () (out) (err>> file)))))

(define (shell&* cmd)
  ((shell-command cmd) (lambda () #f) (lambda () #f)))

(define (call-with-shell-io cmd proc)
  (let ((cmd (if (procedure? cmd) cmd (apply shell-command cmd)))
        (in-pipe (shell-create-pipe))
        (out-pipe (shell-create-pipe))
        (err-pipe (shell-create-pipe)))
    (let ((pids
           (cmd (lambda ()
                  (shell-stdin-from-pipe in-pipe))
                (lambda ()
                  (shell-stdout-to-pipe out-pipe)
                  (shell-stderr-to-pipe err-pipe)))))
      (close-file-descriptor (car in-pipe))
      (close-file-descriptor (cdr out-pipe))
      (close-file-descriptor (cdr err-pipe))
      (let ((res (proc pids
                       (open-output-file-descriptor (cdr in-pipe))
                       (open-input-file-descriptor (car out-pipe))
                       (open-input-file-descriptor (car err-pipe)))))
        (for-each shell-wait pids)
        res))))

(define (shell-with-output cmd proc)
  (call-with-shell-io cmd (lambda (pids in out err) (proc out))))

(define-syntax shell-analyze
  (syntax-rules (< << > >> err> err>>)
    ;; I/O operators before any commands - accumulate in cur.
    ((shell-analyze join ((< file) . rest) () (cur ...))
     (shell-analyze join rest () (cur ... (< file))))
    ((shell-analyze join ((<< str) . rest) () (cur ...))
     (shell-analyze join rest () (cur ... (<< str))))
    ((shell-analyze join ((> file) . rest) () (cur ...))
     (shell-analyze join rest () (cur ... (> file))))
    ((shell-analyze join ((>> file) . rest) () (cur ...))
     (shell-analyze join rest () (cur ... (>> file))))
    ((shell-analyze join ((err> file) . rest) () (cur ...))
     (shell-analyze join rest () (cur ... (err> file))))
    ((shell-analyze join ((err>> file) . rest) () (cur ...))
     (shell-analyze join rest () (cur ... (err>> file))))

    ;; I/O operators after a command - append to the last command.
    ((shell-analyze join ((< file) . rest) (cmds ... (cmd ...)) x)
     (shell-analyze join rest (cmds ... (cmd ... (< file))) x))
    ((shell-analyze join ((<< str) . rest) (cmds ... cmd) x)
     (shell-analyze join rest (cmds ... ((apply (lambda () (display `str)))) cmd) x))
    ((shell-analyze join ((> file) . rest) (cmds ... (cmd ...)) x)
     (shell-analyze join rest (cmds ... (cmd ... (> file))) x))
    ((shell-analyze join ((>> file) . rest) (cmds ... (cmd ...)) x)
     (shell-analyze join rest (cmds ... (cmd ... (>> file))) x))
    ((shell-analyze join ((err> file) . rest) (cmds ... (cmd ...)) x)
     (shell-analyze join rest (cmds ... (cmd ... (err> file))) x))
    ((shell-analyze join ((err>> file) . rest) (cmds ... (cmd ...)) x)
     (shell-analyze join rest (cmds ... (cmd ... (err>> file))) x))

    ;; Anything but an I/O operator is a normal command.
    ((shell-analyze join (cmd . rest) (cmds ...) (cur ...))
     (shell-analyze join rest (cmds ... (cmd cur ...)) ()))

    ;; Join the analyzed results.
    ((shell-analyze join () ((cmd . ops) ...) x)
     (join (shell-analyze-io (shell-analyze-one cmd) ops) ...))
    ))

(define-syntax shell-analyze-one
  (syntax-rules (>< do and or if apply)
    ((shell-analyze-one (do cmds ...))
     (shell-analyze shell-do (cmds ...) () ()))
    ((shell-analyze-one (if cmds ...))
     (shell-analyze shell-if (cmds ...) () ()))
    ((shell-analyze-one (and cmds ...))
     (shell-analyze shell-and (cmds ...) () ()))
    ((shell-analyze-one (or cmds ...))
     (shell-analyze shell-or (cmds ...) () ()))
    ((shell-analyze-one (>< cmds ...))
     (shell-analyze shell-pipe (cmds ...) () ()))
    ((shell-analyze-one (apply proc))
     (shell-scheme-command proc))
    ((shell-analyze-one cmd)
     (shell-command `cmd))
    ))

(define-syntax shell-analyze-io
  (syntax-rules (< > >> err> err>>)
    ((shell-analyze-io cmd ((< file) . rest))
     (shell-analyze-io (with-in< (shell-object->string `file) cmd) rest))
    ((shell-analyze-io cmd ((> file) . rest))
     (shell-analyze-io (with-out> (shell-object->string `file) cmd) rest))
    ((shell-analyze-io cmd ((>> file) . rest))
     (shell-analyze-io (with-out>> (shell-object->string `file) cmd) rest))
    ((shell-analyze-io cmd ((err> file) . rest))
     (shell-analyze-io (with-err> (shell-object->string `file) cmd) rest))
    ((shell-analyze-io cmd ((err>> file) . rest))
     (shell-analyze-io (with-err>> (shell-object->string `file) cmd) rest))
    ((shell-analyze-io cmd ())
     cmd)))

(define-syntax shell&
  (syntax-rules ()
    ((shell& cmd ...)
     ((shell-analyze shell-pipe (cmd ...) () ())
      (lambda () #f)
      (lambda () #f)))))

;;> Returns the exit status of the last command in the pipeline.
(define-syntax shell
  (syntax-rules ()
    ((shell cmd ...)
     (map shell-wait (shell& cmd ...)))))

(define-syntax shell->string
  (syntax-rules ()
    ((shell->string cmd ...)
     (shell-with-output (shell-analyze shell-pipe (cmd ...) () ())
                        port->string))))

(define-syntax shell->string-list
  (syntax-rules ()
    ((shell->string cmd ...)
     (shell-with-output (shell-analyze shell-pipe (cmd ...) () ())
                        port->string-list))))

(define-syntax shell->sexp
  (syntax-rules ()
    ((shell->string cmd ...)
     (shell-with-output (shell-analyze shell-pipe (cmd ...) () ())
                        read))))

(define-syntax shell->sexp-list
  (syntax-rules ()
    ((shell->string cmd ...)
     (shell-with-output (shell-analyze shell-pipe (cmd ...) () ())
                        port->sexp-list))))
(define-library (chibi weak-test)
  (export run-tests)
  (import (chibi) (chibi weak) (chibi ast) (chibi test))
  (begin
    (define (run-tests)
      (test-begin "weak pointers")

      (test "preserved key and value" '("key1" "value1" #f)
        (let ((key (string-append "key" "1"))
              (value (string-append "value" "1")))
          (let ((eph (make-ephemeron key value)))
            (gc)
            (list key (ephemeron-value eph) (ephemeron-broken? eph)))))

      (test "unpreserved key and value" '(#f #f #t)
        (let ((eph (make-ephemeron (string-append "key" "2")
                                   (string-append "value" "2"))))
          (gc)
          (list (ephemeron-key eph)
                (ephemeron-value eph)
                (ephemeron-broken? eph))))

      (test "unpreserved key and preserved value" '(#f "value3" #t)
        (let ((value (string-append "value" "3")))
          (let ((eph (make-ephemeron (string-append "key" "3") value)))
            (gc)
            (list (ephemeron-key eph) value (ephemeron-broken? eph)))))

      (test "unpreserved value references unpreserved key" '(#f #f #t)
        (let ((key (string-append "key")))
          (let ((eph (make-ephemeron key (cons (string-append "value") key))))
            (gc)
            (list (ephemeron-key eph)
                  (ephemeron-value eph)
                  (ephemeron-broken? eph)))))

      ;; disabled - we support weak keys, but not proper ephemerons

      '(test "preserved key and unpreserved value" '("key" "value" #f)
         (let ((key (string-append "key")))
           (let ((eph (make-ephemeron key (string-append "value"))))
             (gc)
             (list key (ephemeron-value eph) (ephemeron-broken? eph)))))

      '(test "preserved value references unpreserved key" '(#f #f #t)
         (let* ((key (string-append "key"))
                (value (cons (string-append "value") key)))
           (let ((eph (make-ephemeron key value)))
             (gc)
             (list (ephemeron-key eph) value (ephemeron-broken? eph)))))

      (test-end))))

;; PCRE parsing, adapted from IrRegex.

(define ~none 0)
(define ~save? 1)
(define ~case-insensitive? 2)
(define ~multi-line? 4)
(define ~single-line? 8)
(define ~ignore-space? 16)

(define (flag-set? flags i)
  (= i (bitwise-and flags i)))
(define (flag-join a b)
  (if b (bitwise-ior a b) a))
(define (flag-clear a b)
  (bitwise-and a (bitwise-not b)))

(define (symbol-list->flags ls)
  (let lp ((ls ls) (res ~none))
    (cond
     ((null? ls)
      res)
     ((not (pair? ls))
      (lp (list ls) res))
     (else
      (lp (cdr ls)
          (flag-join
           res
           (case (car ls)
             ((i ci case-insensitive) ~case-insensitive?)
             ((m multi-line) ~multi-line?)
             ((s single-line) ~single-line?)
             ((x ignore-space) ~ignore-space?)
             (else #f))))))))

(define posix-escape-sequences
  `((#\n . #\newline)
    (#\r . #\return)
    (#\t . #\tab)
    (#\a . #\alarm)
    (#\e . #\escape)))

(define (char-altcase c)
  (if (char-upper-case? c) (char-downcase c) (char-upcase c)))

(define (char-mirror c)
  (case c ((#\<) #\>) ((#\{) #\}) ((#\() #\)) ((#\[) #\]) (else c)))

(define (string-scan-char-escape str c . o)
  (let ((end (string-length str)))
    (let scan ((i (if (pair? o) (car o) 0)))
      (cond ((= i end) #f)
            ((eqv? c (string-ref str i)) i)
            ((eqv? c #\\) (scan (+ i 2)))
            (else (scan (+ i 1)))))))

(define (string-find/index str ch start . o)
  (let* ((end (if (pair? o) (car o) (string-length str)))
         (i (string-find str ch (string-index->cursor str start)
                         (string-index->cursor str end))))
    (string-cursor->index str i)))

(define (string-parse-hex-escape str i end)
  (cond
   ((>= i end)
    (error "incomplete hex escape" str i))
   ((eqv? #\{ (string-ref str i))
    (let ((j (string-scan-char-escape str #\} (+ i 1))))
      (if (not j)
          (error "incomplete hex brace escape" str i)
          (let* ((s (substring str (+ i 1) j))
                 (n (string->number s 16)))
            (if n
                (list (integer->char n) j)
                (error "bad hex brace escape" s))))))
   ((>= (+ i 1) end)
    (error "incomplete hex escape" str i))
   (else
    (let* ((s (substring str i (+ i 2)))
           (n (string->number s 16)))
      (if n
          (list (integer->char n) (+ i 2))
          (error "bad hex escape" s))))))

(define (string-parse-cset str start flags)
  (let* ((end (string-length str))
         (invert? (and (< start end) (eqv? #\^ (string-ref str start)))))
    (define (cset-union a b)
      (cond ((not a) b)
            ((not b) a)
            ((and (pair? a) (eq? 'or (car a))) `(,@a ,b))
            (else `(or ,a ,b))))
    (define (go i prev-char ones pairs classes)
      (if (>= i end)
          (error "incomplete char set" str i end))
      (case (string-ref str i)
        ((#\])
         (if (and (null? ones) (null? pairs))
             (go (+ i 1) #\] (cons #\] ones) pairs classes)
             (list
              (let ((res
                     (cset-union
                      (cset-union
                       (and (pair? classes)
                            `(or ,@classes))
                       (and (pair? ones)
                            `(,(list->string (reverse ones)))))
                      (and (pair? pairs)
                           `(/ ,(list->string (reverse pairs)))))))
                (if invert? `(~ ,res) res))
              i)))
        ((#\-)
         (cond
          ((or (= i start)
               (and (= i (+ start 1)) invert?)
               (eqv? #\] (string-ref str (+ i 1))))
           (go (+ i 1) #\- (cons #\- ones) pairs classes))
          ;; alternately permissively allow this as a -
          ((not prev-char)
           (error "bad pcre char-set, unexpected -" str))
          (else
           (let ((ch (string-ref str (+ i 1))))
             (apply
              (lambda (c j)
                (if (char<? c prev-char)
                    (error "inverted range in pcre char-set" prev-char c)
                    (go j #f (cdr ones) (cons c (cons prev-char pairs))
                        classes)))
              (cond
               ((and (eqv? #\\ ch)
                     (assv (string-ref str (+ i 2)) posix-escape-sequences))
                => (lambda (x) (list (cdr x) (+ i 3))))
               ((and (eqv? #\\ ch)
                     (eqv? (string-ref str (+ i 2)) #\x))
                (string-parse-hex-escape str (+ i 3) end))
               (else
                (list ch (+ i 2)))))))))
        ((#\[)
         (let* ((inv? (eqv? #\^ (string-ref str (+ i 1))))
                (i2 (if inv? (+ i 2) (+ i 1))))
           (case (string-ref str i2)
             ((#\:)
              (let ((j (string-find/index str #\: (+ i2 1) end)))
                (if (or (>= (+ j 1) end)
                        (not (eqv? #\] (string-ref str (+ j 1)))))
                    (error "incomplete character class" str)
                    (let* ((class (string->symbol (substring str (+ i2 1) j)))
                           (class (if inv? `(~ ,class) class)))
                      (go (+ j 2) #f ones pairs (cons class classes))))))
             ((#\= #\.)
              (error "collating sequences not supported" str))
             (else
              (go (+ i 1) #\[ (cons #\[ ones) pairs classes)))))
        ((#\\)
         (let ((c (string-ref str (+ i 1))))
           (case c
             ((#\d #\D #\s #\S #\w #\W)
              (go (+ i 2) #f ones pairs
                  (cons (pcre->sre (string #\\ c)) classes)))
             ((#\x)
              (apply
               (lambda (c j) (go j c (cons c ones) pairs classes))
               (string-parse-hex-escape str (+ i 2) end)))
             (else
              (let ((c (cond ((assv c posix-escape-sequences) => cdr)
                             (else c))))
                (go (+ i 2) c (cons c ones) pairs classes))))))
        (else
         => (lambda (c) (go (+ i 1) c (cons c ones) pairs classes)))))
    (if invert?
        (let ((ones (if (flag-set? flags ~multi-line?) '(#\newline) '())))
          (go (+ start 1) #f ones '() '()))
        (go start #f '() '() '()))))

;; build a (seq ls ...) sre from a list
(define (sre-sequence ls)
  (cond
   ((null? ls) 'epsilon)
   ((null? (cdr ls)) (car ls))
   (else (cons 'seq ls))))

;; build a (or ls ...) sre from a list
(define (sre-alternate ls)
  (cond
   ((null? ls) '(or))
   ((null? (cdr ls)) (car ls))
   (else (cons 'or ls))))

;; returns #t if the sre can ever be empty
(define (sre-empty? sre)
  (if (pair? sre)
      (case (car sre)
        ((* ? look-ahead look-behind neg-look-ahead neg-look-behind) #t)
        ((**) (or (not (number? (cadr sre))) (zero? (cadr sre))))
        ((or) (any sre-empty? (cdr sre)))
        ((: seq $ submatch => submatch-named + atomic)
         (every sre-empty? (cdr sre)))
        (else #f))
      (memq sre '(epsilon bos eos bol eol bow eow commit))))

;; returns #t if the sre is a */+ repetition
(define (sre-repeater? sre)
  (and (pair? sre)
       (or (memq (car sre) '(* +))
           (and (memq (car sre) '($ submatch => submatch-named seq :))
                (pair? (cdr sre))
                (null? (cddr sre))
                (sre-repeater? (cadr sre))))))

(define (pcre->sre str . o)
  (if (not (string? str))
      (error "pcre->sre: expected a string" str))
  (let ((end (string-length str))
        (orig-flags (if (pair? o) (symbol-list->flags (car o)) ~none)))
    (let lp ((i 0) (from 0) (flags orig-flags) (res '()) (st '()))
      ;; accumulate the substring from..i as literal text
      (define (collect)
        (if (= i from) res (cons (substring str from i) res)))
      ;; like collect but breaks off the last single character when
      ;; collecting literal data, as the argument to ?/*/+ etc.
      (define (collect/single)
        (let ((j (- i 1)))
          (cond
           ((< j from)
            res)
           (else
            (let ((c (string-ref str j)))
              (cond
               ((= j from)
                (cons c res))
               (else
                (cons c (cons (substring str from j) res)))))))))
      ;; collects for use as a result, reversing and grouping OR
      ;; terms, and some ugly tweaking of `function-like' groups and
      ;; conditionals
      (define (collect/terms)
        (let* ((ls (collect))
               (func
                (and (pair? ls)
                     (memq (last ls)
                           '(atomic if look-ahead neg-look-ahead
                                    look-behind neg-look-behind
                                    => submatch-named))))
               (prefix (if (and func (memq (car func) '(=> submatch-named)))
                           (list 'submatch-named (cadr (reverse ls)))
                           (and func (list (car func)))))
               (ls (if func
                       (if (memq (car func) '(=> submatch-named))
                           (reverse (cddr (reverse ls)))
                           (reverse (cdr (reverse ls))))
                       ls)))
          (let lp ((ls ls) (term '()) (res '()))
            (define (shift)
              (cons (sre-sequence term) res))
            (cond
             ((null? ls)
              (let* ((res (sre-alternate (shift)))
                     (res (if (flag-set? flags ~save?)
                              (list 'submatch res)
                              res)))
                (if prefix
                    (if (eq? 'if (car prefix))
                        (cond
                         ((not (pair? res))
                          'epsilon)
                         ((memq (car res)
                                '(look-ahead neg-look-ahead
                                             look-behind neg-look-behind))
                          res)
                         ((eq? 'seq (car res))
                          `(if ,(cadr res)
                               ,(sre-sequence (cddr res))))
                         (else
                          `(if ,(cadadr res)
                               ,(sre-sequence (cddadr res))
                               ,(sre-alternate (cddr res)))))
                        `(,@prefix ,res))
                    res)))
             ((eq? 'or (car ls)) (lp (cdr ls) '() (shift)))
             (else (lp (cdr ls) (cons (car ls) term) res))))))
      (define (save)
        (cons (cons flags (collect)) st))
      ;; main parsing
      (cond
       ((>= i end)
        (if (pair? st)
            (error "unterminated parenthesis in regexp" str)
            (collect/terms)))
       (else
        (case (string-ref str i)
          ((#\.)
           (lp (+ i 1) (+ i 1) flags
               (cons (if (flag-set? flags ~single-line?) 'any 'nonl)
                     (collect))
               st))
          ((#\?)
           (let ((res (collect/single)))
             (if (null? res)
                 (error "? can't follow empty pattern" str res)
                 (let ((x (car res)))
                   (lp (+ i 1)
                       (+ i 1)
                       flags
                       (cons
                        (if (pair? x)
                            (case (car x)
                              ((*)  `(*? ,@(cdr x)))
                              ((+)  `(**? 1 #f ,@(cdr x)))
                              ((?)  `(?? ,@(cdr x)))
                              ((**) `(**? ,@(cdr x)))
                              ((=)  `(**? ,(cadr x) ,@(cdr x)))
                              ((>=)  `(**? ,(cadr x) #f ,@(cddr x)))
                              (else `(? ,x)))
                            `(? ,x))
                        (cdr res))
                       st)))))
          ((#\+ #\*)
           (let* ((res (collect/single))
                  (x (if (pair? res) (car res) 'epsilon))
                  (op (string->symbol (string (string-ref str i)))))
             (cond
              ((sre-repeater? x)
               (error "duplicate repetition (e.g. **) in pattern" str res))
              ((sre-empty? x)
               (error "can't repeat empty pattern (e.g. ()*)" str res))
              (else
               (lp (+ i 1) (+ i 1) flags
                   (cons (list op x) (cdr res))
                   st)))))
          ((#\()
           (cond
            ((>= (+ i 1) end)
             (error "unterminated parenthesis in regexp" str))
            ((not (memv (string-ref str (+ i 1)) '(#\? #\*))) ; normal case
             (lp (+ i 1) (+ i 1) (flag-join flags ~save?) '() (save)))
            ((>= (+ i 2) end)
             (error "unterminated parenthesis in regexp" str))
            ((eqv? (string-ref str (+ i 1)) #\*)
             (error "bad regexp syntax: (*FOO) not supported" str))
            (else ;; (?...) case
             (case (string-ref str (+ i 2))
               ((#\#)
                (let ((j (string-find/index str #\) (+ i 3))))
                  (lp (+ j i) (min (+ j 1) end) flags (collect) st)))
               ((#\:)
                (lp (+ i 3) (+ i 3) (flag-clear flags ~save?) '() (save)))
               ((#\=)
                (lp (+ i 3) (+ i 3) (flag-clear flags ~save?)
                    '(look-ahead) (save)))
               ((#\!)
                (lp (+ i 3) (+ i 3) (flag-clear flags ~save?)
                    '(neg-look-ahead) (save)))
               ((#\<)
                (cond
                 ((>= (+ i 3) end)
                  (error "unterminated parenthesis in regexp" str))
                 (else
                  (case (string-ref str (+ i 3))
                    ((#\=)
                     (lp (+ i 4) (+ i 4) (flag-clear flags ~save?)
                         '(look-behind) (save)))
                    ((#\!)
                     (lp (+ i 4) (+ i 4) (flag-clear flags ~save?)
                         '(neg-look-behind) (save)))
                    (else
                     (let ((j (and (char-alphabetic?
                                    (string-ref str (+ i 3)))
                                   (string-find/index str #\> (+ i 4)))))
                       (if (< j end)
                           (lp (+ j 1) (+ j 1) (flag-clear flags ~save?)
                               `(,(string->symbol (substring str (+ i 3) j))
                                 submatch-named)
                               (save))
                           (error "invalid (?< sequence" str))))))))
               ((#\>)
                (lp (+ i 3) (+ i 3) (flag-clear flags ~save?)
                    '(atomic) (save)))
               ;;((#\' #\P) ; named subpatterns
               ;; )
               ;;((#\R) ; recursion
               ;; )
               ((#\()
                (cond
                 ((>= (+ i 3) end)
                  (error "unterminated parenthesis in regexp" str))
                 ((char-numeric? (string-ref str (+ i 3)))
                  (let* ((j (string-find/index str #\) (+ i 3)))
                         (n (string->number (substring str (+ i 3) j))))
                    (if (or (= j end) (not n))
                        (error "invalid conditional reference" str)
                        (lp (+ j 1) (+ j 1) (flag-clear flags ~save?)
                            `(,n if) (save)))))
                 ((char-alphabetic? (string-ref str (+ i 3)))
                  (let ((j (string-find/index str #\) (+ i 3))))
                    (if (= j end)
                        (error "invalid named conditional reference" str)
                        (lp (+ j 1) (+ j 1) (flag-clear flags ~save?)
                            `(,(string->symbol (substring str (+ i 3) j)) if)
                            (save)))))
                 (else
                  (lp (+ i 2) (+ i 2) (flag-clear flags ~save?)
                      '(if) (save)))))
               ((#\{)
                (error "unsupported Perl-style cluster" str))
               (else
                (let ((old-flags flags))
                  (let lp2 ((j (+ i 2)) (flags flags) (invert? #f))
                    (define (join x)
                      ((if invert? flag-clear flag-join) flags x))
                    (cond
                     ((>= j end)
                      (error "incomplete cluster" str i))
                     (else
                      (case (string-ref str j)
                        ((#\i)
                         (lp2 (+ j 1) (join ~case-insensitive?) invert?))
                        ((#\m)
                         (lp2 (+ j 1) (join ~multi-line?) invert?))
                        ((#\x)
                         (lp2 (+ j 1) (join ~ignore-space?) invert?))
                        ((#\-)
                         (lp2 (+ j 1) flags (not invert?)))
                        ((#\))
                         (lp (+ j 1) (+ j 1) flags (collect)
                             st))
                        ((#\:)
                         (lp (+ j 1) (+ j 1) flags '()
                             (cons (cons old-flags (collect)) st)))
                        (else
                         (error "unknown regex cluster modifier" str)
                         )))))))))))
          ((#\))
           (if (null? st)
               (error "too many )'s in regexp" str)
               (lp (+ i 1)
                   (+ i 1)
                   (caar st)
                   (cons (collect/terms) (cdar st))
                   (cdr st))))
          ((#\[)
           (apply
            (lambda (sre j)
              (lp (+ j 1) (+ j 1) flags (cons sre (collect)) st))
            (string-parse-cset str (+ i 1) flags)))
          ((#\{)
           (cond
            ((or (>= (+ i 1) end)
                 (not (or (char-numeric? (string-ref str (+ i 1)))
                          (eqv? #\, (string-ref str (+ i 1))))))
             (lp (+ i 1) from flags res st))
            (else
             (let ((res (collect/single)))
               (cond
                ((null? res)
                 (error "{ can't follow empty pattern"))
                (else
                 (let* ((x (car res))
                        (tail (cdr res))
                        (j (string-find/index str #\} (+ i 1)))
                        (s2 (string-split (substring str (+ i 1) j) #\,))
                        (n (string->number (car s2)))
                        (m (and (pair? (cdr s2))
                                (string->number (cadr s2)))))
                   (cond
                    ((or (= j end)
                         (not n)
                         (and (pair? (cdr s2))
                              (not (equal? "" (cadr s2)))
                              (not m)))
                     (error "invalid {n} repetition syntax" s2))
                    ((null? (cdr s2))
                     (lp (+ j 1) (+ j 1) flags `((= ,n ,x) ,@tail) st))
                    (m
                     (lp (+ j 1) (+ j 1) flags `((** ,n ,m ,x) ,@tail) st))
                    (else
                     (lp (+ j 1) (+ j 1) flags `((>= ,n ,x) ,@tail) st)
                     )))))))))
          ((#\\)
           (cond
            ((>= (+ i 1) end)
             (error "incomplete escape sequence" str))
            (else
             (let ((c (string-ref str (+ i 1))))
               (case c
                 ((#\d)
                  (lp (+ i 2) (+ i 2) flags `(numeric ,@(collect)) st))
                 ((#\D)
                  (lp (+ i 2) (+ i 2) flags `((~ numeric) ,@(collect)) st))
                 ((#\s)
                  (lp (+ i 2) (+ i 2) flags `(space ,@(collect)) st))
                 ((#\S)
                  (lp (+ i 2) (+ i 2) flags `((~ space) ,@(collect)) st))
                 ((#\w)
                  (lp (+ i 2) (+ i 2) flags
                      `((or alphanumeric ("_")) ,@(collect)) st))
                 ((#\W)
                  (lp (+ i 2) (+ i 2) flags
                      `((~ (or alphanumeric ("_"))) ,@(collect)) st))
                 ((#\b)
                  (lp (+ i 2) (+ i 2) flags
                      `((or bow eow) ,@(collect)) st))
                 ((#\B)
                  (lp (+ i 2) (+ i 2) flags `(nwb ,@(collect)) st))
                 ((#\A)
                  (lp (+ i 2) (+ i 2) flags `(bos ,@(collect)) st))
                 ((#\Z)
                  (lp (+ i 2) (+ i 2) flags
                      `((? #\newline) eos ,@(collect)) st))
                 ((#\z)
                  (lp (+ i 2) (+ i 2) flags `(eos ,@(collect)) st))
                 ((#\R)
                  (lp (+ i 2) (+ i 2) flags `(newline ,@(collect)) st))
                 ((#\K)
                  (lp (+ i 2) (+ i 2) flags `(reset ,@(collect)) st))
                 ;; these two are from Emacs and TRE, but not in PCRE
                 ((#\<)
                  (lp (+ i 2) (+ i 2) flags `(bow ,@(collect)) st))
                 ((#\>)
                  (lp (+ i 2) (+ i 2) flags `(eow ,@(collect)) st))
                 ((#\x)
                  (apply
                   (lambda (ch j)
                     (lp (+ j 1) (+ j 1) flags `(,ch ,@(collect)) st))
                   (string-parse-hex-escape str (+ i 2) end)))
                 ((#\k)
                  (let ((c (string-ref str (+ i 2))))
                    (if (not (memv c '(#\< #\{ #\')))
                        (error "bad \\k usage, expected \\k<...>" str)
                        (let* ((terminal (char-mirror c))
                               (j (string-find/index str terminal (+ i 2)))
                               (s (substring str (+ i 3) j))
                               (backref
                                (if (flag-set? flags ~case-insensitive?)
                                    'backref-ci
                                    'backref)))
                          (if (= j end)
                              (error "unterminated named backref" str)
                              (lp (+ j 1) (+ j 1) flags
                                  `((,backref ,(string->symbol s))
                                    ,@(collect))
                                  st))))))
                 ((#\Q) ;; \Q..\E escapes
                  (let ((res (collect)))
                    (let lp2 ((j (+ i 2)))
                      (cond
                       ((>= j end)
                        (lp j (+ i 2) flags res st))
                       ((eqv? #\\ (string-ref str j))
                        (cond
                         ((>= (+ j 1) end)
                          (lp (+ j 1) (+ i 2) flags res st))
                         ((eqv? #\E (string-ref str (+ j 1)))
                          (lp (+ j 2) (+ j 2) flags
                              (cons (substring str (+ i 2) j) res) st))
                         (else
                          (lp2 (+ j 2)))))
                       (else
                        (lp2 (+ j 1)))))))
                 ;;((#\p)  ; XXXX unicode properties
                 ;; )
                 ;;((#\P)
                 ;; )
                 (else
                  (cond
                   ((char-numeric? c)
                    (let* ((j (string-skip str char-numeric? (+ i 2)))
                           (backref
                            (if (flag-set? flags ~case-insensitive?)
                                'backref-ci
                                'backref))
                           (res `((,backref ,(string->number
                                              (substring str (+ i 1) j)))
                                  ,@(collect))))
                      (lp j j flags res st)))
                   ((char-alphabetic? c)
                    (let ((cell (assv c posix-escape-sequences)))
                      (if cell
                          (lp (+ i 2) (+ i 2) flags
                              (cons (cdr cell) (collect)) st)
                          (error "unknown escape sequence" str c))))
                   (else
                    (lp (+ i 2) (+ i 1) flags (collect) st)))))))))
          ((#\|)
           (lp (+ i 1) (+ i 1) flags (cons 'or (collect)) st))
          ((#\^)
           (let ((sym (if (flag-set? flags ~multi-line?) 'bol 'bos)))
             (lp (+ i 1) (+ i 1) flags (cons sym (collect)) st)))
          ((#\$)
           (let ((sym (if (flag-set? flags ~multi-line?) 'eol 'eos)))
             (lp (+ i 1) (+ i 1) flags (cons sym (collect)) st)))
          ((#\space)
           (if (flag-set? flags ~ignore-space?)
               (lp (+ i 1) (+ i 1) flags (collect) st)
               (lp (+ i 1) from flags res st)))
          ((#\#)
           (if (flag-set? flags ~ignore-space?)
               (let ((j (string-find/index str #\newline (+ i 1))))
                 (lp (+ j 1) (min (+ j 1) end) flags (collect) st))
               (lp (+ i 1) from flags res st)))
          (else
           (lp (+ i 1) from flags res st))))))))

(define (pcre->regexp pcre . o)
  (regexp (apply pcre->sre pcre o)))

(define-library (chibi regexp pcre)
  (export pcre->sre pcre->regexp)
  (import (scheme base) (scheme char) (scheme cxr)
          (srfi 1)
          (chibi string) (chibi regexp))
  (cond-expand
   ((library (srfi 151)) (import (srfi 151)))
   ((library (srfi 33)) (import (srfi 33)))
   (else (import (srfi 60))))
  (include "pcre.scm"))
;; Copyright (c) 2010-2011 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

;;> General type-inference library.

(define (typed? x)
  (and (lambda? x)
       (lambda-return-type x)))

(define (union-type? a)
  (and (pair? a) (equal? (car a) 'or)))

(define (intersection-type? a)
  (and (pair? a) (equal? (car a) 'and)))

(define (unfinalized-type? a)
  (and (pair? a)
       (or (memq (car a) '(return-type param-type))
           (and (memq (car a) '(and or))
                (any unfinalized-type? (cdr a))))))

(define (finalized-type? a)
  (not (unfinalized-type? a)))

(define (numeric-type? a)
  (or (eq? a Number) (eq? a Flonum) (eq? a Integer)))

(define (procedure-type? a)
  (or (eq? a Opcode)
      (eq? a Procedure)
      (and (pair? a) (eq? (car a) 'lambda))))

(define (type=? a b)
  (cond
   ((and (pair? a) (eq? (car a) 'param-type))
    (and (pair? b) (eq? (car b) 'param-type)
         (eq? (cadr a) (cadr b))
         (eq? (car (cddr a)) (car (cddr b)))))
   ((and (pair? a) (eq? (car a) 'return-type))
    (and (pair? b) (eq? (car b) 'return-type)
         (eq? (cadr a) (cadr b))))
   (else
    (equal? a b))))

(define (type-subset? a b)
  (or (type=? a b)
      (eq? a Object)
      (eq? b Object)
      (and (numeric-type? a) (numeric-type? b))
      (and (procedure-type? a) (procedure-type? b))
      (if (union-type? a)
          (if (union-type? b)
              (lset<= type=? (cdr a) (cdr b))
              (member b (cdr a) type=?))
          (and (union-type? b) (member a (cdr b) type=?)))))

(define (type-not a)
  (match a
    (('not b) b)
    (else (list 'not a))))

;; XXXX check for type hierarchies
(define (type-union a b)
  (cond
   ((type=? a b) a)
   ((or (eq? a Object) (eq? b Object)) Object)
   ((union-type? a)
    (if (union-type? b)
        (cons (car a) (lset-union type=? (cdr a) (cdr b)))
        (cons (car a) (lset-adjoin type=? (cdr a) b))))
   ((union-type? b)
    (cons (car b) (lset-adjoin type=? (cdr b) a)))
   (else (list 'or a b))))

;; XXXX check for conflicts
(define (type-intersection a b)
  (cond
   ((type=? a b) a)
   ((or (eq? a Object) (unfinalized-type? a)) b)
   ((or (eq? b Object) (unfinalized-type? b)) a)
   ((intersection-type? a)
    (if (intersection-type? b)
        (lset-intersection type=? (cdr a) (cdr b))
        (cons (car a) (lset-adjoin type=? (cdr a) b))))
   (else (list 'and a b))))

(define (lambda-param-types-initialize! f)
  (lambda-param-types-set! f (map (lambda (p) (list 'param-type f p))
                                  (lambda-params f))))

(define (lambda-param-type-memq f x)
  (let lp ((p (lambda-params f))
           (t (lambda-param-types f)))
    (and (pair? p)
         (pair? t)
         (if (eq? x (car p))
             t
             (lp (cdr p) (cdr t))))))

(define (lambda-param-type-ref f x)
  (cond ((lambda-param-type-memq f x) => car)
        (else #f)))

(define (lambda-param-type-set! f x y)
  (if (not (pair? (lambda-param-types f)))
      (lambda-param-types-initialize! f))
  (cond ((lambda-param-type-memq f x)
         => (lambda (cell) (set-car! cell y)))))

(define (type-assert x true?)
  (match x
    (((? opcode? f) ($ Ref name (_ . (? lambda? g))))
     (cond
      ((eq? (opcode-class f) (opcode-class pair?))
       (let ((t (type-intersection
                 (lambda-param-type-ref g name)
                 (if true? (opcode-data f) (type-not (opcode-data f))))))
         (lambda-param-type-set! g name t)))))
    ((($ Ref _ ('not . (? procedure? f))) expr)
     (if (eq? f not)
         (type-assert expr (not true?))))
    (else #f)))

(define (type-analyze-expr x)
  (match x
    (($ Lam name params body defs)
     (cond
      ((not (lambda-return-type x))
       (lambda-return-type-set! x (list 'return-type x))
       (lambda-param-types-initialize! x)
       (let ((ret-type (type-analyze-expr body)))
         (lambda-return-type-set! x ret-type)
         (cons 'lambda (cons ret-type (lambda-param-types x)))))))
    (($ Set ref value)
     (type-analyze-expr value)
     (if #f #f))
    (($ Ref name (value . loc))
     (cond
      ((lambda? loc) (lambda-param-type-ref loc name))
      ((procedure? loc)
       (let ((sig (procedure-signature loc)))
         (if (and (pair? sig) (car sig))
             (cons 'lambda sig)
             (list 'return-type (procedure-analysis loc)))))
      (else Object)))
    (($ Cnd test pass fail)
     (let ((test-type (type-analyze-expr test))
           (pass-type (type-analyze-expr pass))
           (fail-type (type-analyze-expr fail)))
       (cond
        ((equal? '(error) pass-type)
         (type-assert test #f)
         fail-type)
        ((equal? '(error) fail-type)
         (type-assert test #t)
         pass-type)
        (else
         (type-union pass-type fail-type)))))
    (($ Seq ls)
     (let lp ((ls ls))
       (cond ((null? (cdr ls))
              (type-analyze-expr (car ls)))
             (else
              (type-analyze-expr (car ls))
              (lp (cdr ls))))))
    (((? opcode? f) args ...)
     (let lp ((p (opcode-param-types f))
              (a args))
       (cond
        ((pair? a)
         (cond
          ((or (pair? p) (opcode-variadic? f))
           (let ((p-type
                  (if (pair? p)
                      (car p)
                      (opcode-param-type f (opcode-num-params f)))))
             (match (car a)
               (($ Ref name (_ . (and g ($ Lam))))
                (let ((t (type-intersection (lambda-param-type-ref g name)
                                            p-type)))
                  (lambda-param-type-set! g name t)))
               (else
                (let ((t (type-analyze-expr (car a))))
                  (cond
                   ((and t p-type
                         (finalized-type? t)
                         (finalized-type? p-type)
                         (not (type-subset? t p-type)))
                    (display "WARNING: incompatible type: "
                             (current-error-port))
                    (write/ss (list x t p-type) (current-error-port))
                    (newline (current-error-port))))
                  t))))
           (lp (and (pair? p) (cdr p)) (cdr a)))
          (else
           (for-each type-analyze-expr a))))))
     (opcode-return-type f))
    ((f args ...)
     (let ((f-type (type-analyze-expr f)))
       ;; XXXX apply f-type to params
       (for-each type-analyze-expr args)
       (cond
        ((and (pair? f-type) (eq? (car f-type) 'lambda))
         (cadr f-type))
        ((and (pair? f-type) (memq (car f-type) '(return-type param-type)))
         f-type)
        (else
         Object))))
    (($ Lit value)
     (type-of value))
    (else
     (type-of x))))

(define (resolve-delayed-type x)
  (let lp ((x x) (seen '()) (default Object))
    (match x
      (('return-type (? lambda? f))
       (if (memq f seen)
           default
           (lp (lambda-return-type f) (cons f seen) default)))
      (('param-type f p)
       (if (member x seen)
           default
           (lp (lambda-param-type-ref f p) (cons x seen) default)))
      (('or y ...)
       (let ((z (find finalized-type? y)))
         (if z
             (let ((default (if (eq? default Object)
                                (lp z seen default)
                                (type-union (lp z seen default) default))))
               (fold type-union
                     default
                     (map (lambda (y1) (lp y1 seen default)) (delete z y))))
             (fold type-union default (map (lambda (y1) (lp y1 seen default)) y)))))
      (('and y ...)
       (fold type-intersection default (map (lambda (y1) (lp y1 seen default)) y)))
      (('not y)
       (list 'not (lp y seen default)))
      (else
       x))))

(define (type-resolve-circularities x)
  (match x
    (($ Lam name params body defs)
     (if (unfinalized-type? (lambda-return-type x))
         (lambda-return-type-set! x (resolve-delayed-type
                                     (lambda-return-type x))))
     (for-each
      (lambda (p t)
        (if (unfinalized-type? t)
            (lambda-param-type-set! x p (resolve-delayed-type t))))
      params
      (lambda-param-types x))
     (type-resolve-circularities (lambda-body x)))
    (($ Set ref value)
     (type-resolve-circularities value))
    (($ Cnd test pass fail)
     (type-resolve-circularities test)
     (type-resolve-circularities pass)
     (type-resolve-circularities fail))
    (($ Seq ls)
     (for-each type-resolve-circularities ls))
    ((app ...)
     (for-each type-resolve-circularities app))
    (else #f)))

(define (type-analyze-module-body name ls)
  (for-each type-analyze-expr ls)
  (for-each type-resolve-circularities ls))

;;> Analyze the types of all bindings in the module \var{name}.

(define (type-analyze-module name)
  (let* ((mod (analyze-module name))
         (ls (and (module? mod) (module-ast mod))))
    (and ls
         (let ((x (let lp ((ls ls))  ;; first lambda
                    (and (pair? ls)
                         (if (and (set? (car ls))
                                  (lambda? (set-value (car ls))))
                             (set-value (car ls))
                             (lp (cdr ls)))))))
           (if (and x (not (typed? x)))
               (type-analyze-module-body name ls))
           ls))))

;;> Return the type signature for a given source
;;> code expression.

(define (type-analyze sexp . o)
  (type-analyze-expr (apply analyze sexp o)))

(define (opcode-param-types x)
  (let lp ((n (- (opcode-num-params x) 1)) (res '()))
    (if (< n 0)
        res
        (lp (- n 1) (cons (opcode-param-type x n) res)))))

(define (opcode-type x)
  (cons 'lambda (cons (opcode-return-type x) (opcode-param-types x))))

(define (lambda-type x)
  (cons 'lambda (cons (lambda-return-type x) (lambda-param-types x))))

;;> Return the type signature for the procedure \var{x} as
;;> a list whose first element is the return type and whose
;;> remaining arguments are the parameter types.

(define (procedure-signature x . o)
  (define (map* f ls)
    (cond ((pair? ls) (cons (f (car ls)) (map* f (cdr ls))))
          ((null? ls) '())
          (else (f ls))))
  (define (ast-sig x)
    (cond
     ((lambda? x)
      (cons (lambda-return-type x)
            (if (pair? (lambda-param-types x))
                (lambda-param-types x)
                (map* identifier->symbol (lambda-params x)))))
     ((seq? x) (ast-sig (last (seq-ls x))))
     ((and (pair? x) (lambda? (car x))) (ast-sig (lambda-body (car x))))
     ;; TODO: improve the type inference so this isn't needed
     ((and (pair? x) (ref? (car x))
           (pair? o) (apply procedure-analysis (ref-name (car x)) o))
      => (lambda (lam)
           (and (lambda? lam)
                (or (lambda-return-type lam)
                    (ast-sig (lambda-body lam))))))
     (else #f)))
  (cond
   ((opcode? x)
    (cdr (opcode-type x)))
   ((macro? x)
    (procedure-signature (macro-procedure x)))
   (else
    (let lp ((count 0))
      (let ((lam (apply procedure-analysis x o)))
        (cond
         ((and lam (not (typed? lam)) (zero? count)
               (containing-module x))
          => (lambda (mod)
               (and (type-analyze-module (car mod))
                    (lp (+ count 1)))))
         (else
          (ast-sig lam))))))))

;;> Simple generic function interface.

(define-library (chibi generic)
  (export define-generic define-method make-generic generic-add!)
  (import (chibi))
  (include "generic.scm"))

(define-library (chibi memoize)
  (import (chibi optional) (chibi pathname) (chibi string)
          (srfi 9) (srfi 38) (srfi 69) (srfi 98))
  (cond-expand
   (chibi
    (import (chibi) (chibi ast) (chibi system) (chibi filesystem))
    (begin
      (define (i-am-root?)
        (zero? (current-user-id)))))
   (else
    (import (scheme base) (scheme char) (scheme file))
    (begin
      (define (i-am-root?)
        (equal? "root" (get-environment-variable "USER")))
      (define (procedure-name x) #f)
      (define (procedure-arity x) #f)
      (define (procedure-variadic? x) #f))))
  (export define-memoized memoize memoize-to-file memoize-file-loader
          make-lru-cache lru-cache? lru-ref lru-ref! lru-set!
          hash-table-ref!)
  (include "memoize.scm"))

(define-library (chibi system)
  (export get-host-name
          user? user-name user-password
          user-id user-group-id user-gecos user-home user-shell
          group? group-name group-password group-id
          current-user-id current-group-id
          current-effective-user-id current-effective-group-id
          set-current-user-id! set-current-effective-user-id!
          set-current-group-id! set-current-effective-group-id!
          current-session-id create-session
          set-root-directory!)
  (import (chibi))
  (include-shared "system")
  (cond-expand
   (emscripten)
   (else
    (export user-information group-information)
    (body
     (define (user-information user)
       (car (if (string? user)
                (getpwnam_r user (make-string 1024))
                (getpwuid_r user (make-string 1024)))))
     (define (group-information group)
       (car (if (string? group)
                (getgrnam_r group (make-string 1024))
                (getgrgid_r group (make-string 1024)))))))))
;; scribble.scm - scribble parsing
;; Copyright (c) 2011 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

;;> A library used for parsing "scribble" format, introduced by
;;> \hyperlink["http://www.racket-lang.org/"]{Racket} and the format
;;> used to write this manual.  The default escape character is
;;> backslash as in TeX instead of @ as in Racket, though this can be
;;> overridden.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; general character utils

(define (char-mirror ch)
  (case ch ((#\() #\)) ((#\[) #\]) ((#\{) #\}) ((#\<) #\>) (else ch)))

(define (char-delimiter? ch)
  (or (eof-object? ch) (char-whitespace? ch)
      (memv ch '(#\( #\) #\[ #\] #\{ #\} #\" #\|))))

(define (char-punctuation? ch)
  (memv ch '(#\- #\+ #\! #\< #\> #\[ #\] #\|)))

(define (char-digit ch) (- (char->integer ch) (char->integer #\0)))

(define default-ecape-char #\\)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; list utils

(define (drop ls n) (if (<= n 0) ls (drop (cdr ls) (- n 1))))

(define (drop-while pred ls)
  (if (or (null? ls) (not (pred (car ls)))) ls (drop-while pred (cdr ls))))

(define (list-prefix? prefix ls)
  (cond ((null? prefix) #t)
        ((null? ls) #f)
        ((equal? (car prefix) (car ls)) (list-prefix? (cdr prefix) (cdr ls)))
        (else #f)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; scribble reader (standalone, don't use the native reader)

(define scribble-dot (list "."))
(define scribble-close (list ")"))

(define (if-peek-char ch in pass fail)
  (cond ((eqv? ch (peek-char in)) (read-char in) pass) (else fail)))

(define (skip-line in)
  (do ((c #f (read-char in))) ((or (eof-object? c) (eqv? c #\newline)))))

(define (read-float-tail in acc)
  (let lp ((res acc) (k 0.1))
    (let ((ch (read-char in)))
      (cond ((or (eof-object? ch) (char-delimiter? ch)) res)
            ((char-numeric? ch) (lp (+ res (* k (char-digit ch))) (* k 0.1)))
            (else (error "invalid numeric syntax"))))))

(define (read-number in acc base)
  (let lp ((acc acc))
    (let ((ch (peek-char in)))
      (cond
       ((or (eof-object? ch) (char-delimiter? ch)) acc)
       ((char-numeric? ch) (read-char in) (lp (+ (* acc base) (char-digit ch))))
       ((eqv? #\. ch)
        (read-char in)
        (if (= base 10)
            (begin (read-char in) (read-float-tail in (inexact acc)))
            (error "non-base-10 floating point")))
       (else (error "invalid numeric syntax"))))))

(define (read-escaped in terminal)
  (let lp ((ls '()))
    (let ((ch (read-char in)))
      (cond
       ((or (eof-object? ch) (eqv? ch terminal)) (list->string (reverse ls)))
       ((eqv? ch #\\) (lp (cons (read-char in) ls)))
       (else (lp (cons ch ls)))))))

(define (read-symbol in ls)
  (do ((ls ls (cons c ls)) (c (peek-char in) (peek-char in)))
      ((char-delimiter? c) (string->symbol (list->string (reverse ls))))
    (read-char in)))

(define (scrib-read in . o)
  (define ch (read-char in))
  (define ec (if (pair? o) (car o) default-ecape-char))
  (cond
   ((eof-object? ch) ch)
   ((char-whitespace? ch) (scrib-read in))
   ((eqv? ch ec)
    (scribble-parse-escape in ec))
   (else
    (case ch
      ((#\( #\[ #\{)
       (let lp ((res '()))
         (let ((x (scrib-read in)))
           (cond ((eof-object? x) (error "unterminated list" x))
                 ((eq? x scribble-close) (reverse res))
                 ((eq? x scribble-dot)
                  (let ((y (scrib-read in)))
                    (if (or (eof-object? y) (eq? y scribble-close))
                        (error "unterminated dotted list")
                        (let ((z (scrib-read in)))
                          (if (not (eq? z scribble-close))
                              (error "dot in non-terminal position in list" y z)
                              (append (reverse res) y))))))
                 (else (lp (cons x res)))))))
      ((#\} #\] #\)) scribble-close)
      ((#\.) (if (char-delimiter? (peek-char in)) scribble-dot (read-float-tail in 0.0)))
      ((#\') (list 'quote (scrib-read in)))
      ((#\`) (list 'quasiquote (scrib-read in)))
      ((#\,) (list (if-peek-char #\@ in 'unquote-splicing 'unquote) (scrib-read in)))
      ((#\;) (skip-line in) (scrib-read in))
      ((#\|) (string->symbol (read-escaped in #\|)))
      ((#\") (read-escaped in #\"))
      ((#\+ #\-)
       (cond ((char-numeric? (peek-char in))
              ((if (eqv? ch #\+) + -) 0 (read-number in 0 10)))
             (else (read-symbol in (list ch)))))
      ((#\#)
       (case (peek-char in)
         ((#\t #\f) (eqv? (read-char in) #\t))
         ((#\() (list->vector (scrib-read in)))
         ((#\\)
          (read-char in)
          (if (char-alphabetic? (peek-char in))
              (let ((name (scrib-read in)))
                (case name
                  ((space) #\space) ((newline) #\newline)
                  (else (string-ref (symbol->string name) 0))))
              (read-char in)))
         (else (error "unknown # syntax"))))
      (else
       (if (char-numeric? ch)
           (read-number in (char-digit ch) 10)
           (read-symbol in (list ch))))))))

(define (scribble-read in . o)
  (let ((res (scrib-read in (if (pair? o) (car o) default-ecape-char))))
    (cond ((eq? res scribble-dot) (error "invalid . in source"))
          ((eq? res scribble-close) (error "too many )'s"))
          (else res))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; scribble parser

(define (read-punctuation in)
  (if (not (eqv? #\| (peek-char in)))
      '()
      (let lp ((ls '()))
        (let ((c (peek-char in)))
          (cond ((or (eof-object? c) (not(char-punctuation? c))) ls)
                (else (lp (cons (char-mirror (read-char in)) ls))))))))

(define (read-prefix-wrapper in)
  (let lp ((wrap (lambda (x) x)))
    (case (peek-char in)
      ((#\') (read-char in) (lp (lambda (x) (wrap (list 'quote x)))))
      ((#\`) (read-char in) (lp (lambda (x) (wrap (list 'quasiquote x)))))
      ((#\,)
       (read-char in)
       (cond ((eqv? #\@ (peek-char in))
              (read-char in)
              (lp (lambda (x) (wrap (list 'unquote-splicing x)))))
             (else (lp (lambda (x) (wrap (list 'unquote x)))))))
      (else wrap))))

(define (scribble-parse-escape in ec)
  (define bracket-char #\[)
  (define brace-char #\{)
  (cond
   ((eqv? #\" (peek-char in))
    (scribble-read in))
   ((eqv? #\\ (peek-char in))
    ;; not compatible with racket
    (read-char in)
    "\\")
   (else
    (let* ((wrap (read-prefix-wrapper in))
           (c (peek-char in))
           (cmd (if (or (eqv? c bracket-char) (eqv? c brace-char)) '() (list (scribble-read in ec))))
           (data? (eqv? (peek-char in) bracket-char))
           (data (if data? (scribble-read in ec) '()))
           (punc (read-punctuation in))
           (body? (eqv? (peek-char in) brace-char))
           (body (cond (body? (read-char in) (scribble-parse in punc ec)) (else '()))))
      (wrap (if (or data? body?) (append cmd data body) (car cmd)))))))

(define (scribble-parse in . o)
  (define init-punc (if (pair? o) (car o) '()))
  (define escape-char
    (if (and (pair? o) (pair? (cdr o))) (cadr o) default-ecape-char))
  (define comment-char #\;)
  (define bracket-char #\[)
  (define brace-char #\{)
  (define close-bracket-char (char-mirror bracket-char))
  (define close-brace-char (char-mirror brace-char))
  (define (collect str res)
    (if (pair? str) (cons (list->string (reverse str)) res) res))
  (define (skip-space in)
    (let ((ch (peek-char in)))
      (cond ((char-whitespace? ch) (read-char in) (skip-space in))
            ((eqv? ch #\;) (skip-line in) (skip-space in)))))
  (define (tok str res punc depth)
    (let ((c (read-char in)))
      (cond
        ((eof-object? c)
         (if (zero? depth)
             (reverse (collect str res))
             (error "unterminated expression" punc)))
        ((and (eqv? c escape-char) (list-prefix? punc str))
         (let ((c (peek-char in)))
           (cond
            ((eof-object? c)
             (tok str res punc depth))
            ((char-whitespace? c)
             (tok (cons c str) res punc depth))
            ((eqv? c comment-char)
             (read-char in)
             (cond ((eqv? brace-char (peek-char in))
                    (scribble-parse-escape in escape-char))
                   (else
                    (skip-line in)
                    ;; (let lp ()
                    ;;   (cond ((char-whitespace? (peek-char in)) (read-char in) (lp))))
                    ))
             (tok str res punc depth))
            ((eqv? c #\|)
             (read-char in)
             (let lp ((ls (collect str res)))
               (skip-space in)
               (cond ((eqv? #\| (peek-char in)) (read-char in) (tok '() ls punc depth))
                     (else (lp (cons (scribble-read in) ls))))))
            (else
             (let ((str (drop str (length punc)))
                   (x (scribble-parse-escape in escape-char)))
               (if (string? x)
                   (tok (append (reverse (string->list x)) str) res punc depth)
                   (tok '() (cons x (collect str res)) punc depth)))))))
        ((eqv? c brace-char)
         (tok (cons c str) res punc (+ depth 1)))
        ((eqv? c close-brace-char)
         (cond
          ((zero? depth)
           (let lp ((p punc) (ls '()))
             (cond ((null? p)
                    (reverse (collect str res)))
                   ((not (eqv? (car p) (peek-char in)))
                    (tok (append ls (cons c str)) res punc (- depth 1)))
                   (else
                    (lp (cdr p) (cons (read-char in) ls))))))
          (else (tok (cons c str) res punc (- depth 1)))))
        ((eqv? c #\newline)
         (let* ((res (collect str res))
                (res (if (and (null? res) (null? str))
                         res
                         (cons "\n" res))))
           (tok '() res punc depth)))
        (else
         (tok (cons c str) res punc depth)))))
  ;; begin
  (tok '() '() init-punc 0))

(define-library (chibi json-test)
  (import (scheme base) (chibi json) (chibi test))
  (export run-tests)
  (begin
    (define (run-tests)
      (test-begin "json")
      (test-begin "string->json")
      (test 1 (string->json "1"))
      (test 1.5 (string->json "1.5"))
      (test 1000.0 (string->json "1e3"))
      (test 'null (string->json "null"))
      (test '((null . 3)) (string->json "{\"null\": 3}"))
      (test "" (string->json "\"\\u00e1\""))
      (test "" (string->json "\"\\uD801\\uDC37\""))
      (test "" (string->json "\"\\uD83D\\uDE10\""))
      (test '((glossary
               (title . "example glossary")
               (GlossDiv
                (title . "S")
                (GlossList
                 (GlossEntry
                  (ID . "SGML")
                  (SortAs . "SGML")
                  (GlossTerm . "Standard Generalized Markup Language")
                  (Acronym . "SGML")
                  (Abbrev . "ISO 8879:1986")
                  (GlossDef
                   (para . "A meta-markup language, used to create markup languages such as DocBook.")
                   (GlossSeeAlso . #("GML" "XML")))
                  (GlossSee . "markup"))))))
          (string->json "{
    \"glossary\": {
        \"title\": \"example glossary\",
        \"GlossDiv\": {
            \"title\": \"S\",
            \"GlossList\": {
                \"GlossEntry\": {
                    \"ID\": \"SGML\",
                    \"SortAs\": \"SGML\",
                    \"GlossTerm\": \"Standard Generalized Markup Language\",
                    \"Acronym\": \"SGML\",
                    \"Abbrev\": \"ISO 8879:1986\",
                    \"GlossDef\": {
                        \"para\": \"A meta-markup language, used to create markup languages such as DocBook.\",
                        \"GlossSeeAlso\": [\"GML\", \"XML\"]
                    },
                    \"GlossSee\": \"markup\"
                }
            }
        }
    }
}"))
      (test '((menu
               (id . "file")
               (value . "File")
               (popup
                (menuitem
                 . #(((value . "New") (onclick . "CreateNewDoc()"))
                     ((value . "Open") (onclick . "OpenDoc()"))
                     ((value . "Close") (onclick . "CloseDoc()")))))))
          (string->json "{\"menu\": {
  \"id\": \"file\",
  \"value\": \"File\",
  \"popup\": {
    \"menuitem\": [
      {\"value\": \"New\", \"onclick\": \"CreateNewDoc()\"},
      {\"value\": \"Open\", \"onclick\": \"OpenDoc()\"},
      {\"value\": \"Close\", \"onclick\": \"CloseDoc()\"}
    ]
  }
}}"))
      (test-end)
      (test-begin "make-json-reader")
      (let ()
        (define-record-type Employee
          (make-employee name id title department)
          employee?
          (name employee-name)
          (id employee-id)
          (title employee-title)
          (department employee-department))
        (define-record-type Team
          (make-team name lead devs)
          team?
          (name team-name)
          (lead team-lead)
          (devs team-devs))
        (define read-employee (make-json-reader Employee))
        (define read-team
          (make-json-reader
           `(,Team
             (lead . ,Employee)
             (name . ,string?)
             (devs . #(,Employee)))))
        (define (string->employee str)
          (read-employee (open-input-string str)))
        (define (string->team str)
          (read-team (open-input-string str)))
        (let ((emp1 (string->employee
                     "{\"name\": \"Bob\", \"id\": 3, \"title\": \"CEO\"}")))
          (test-assert (employee? emp1))
          (test "Bob" (employee-name emp1))
          (test 3 (employee-id emp1))
          (test "CEO" (employee-title emp1)))
        (test-assert (employee? (string->employee "{\"unknown\": \"foo\"}")))
        (test-error ((make-json-reader Employee #t)
                     (open-input-string "{\"unknown\": \"foo\"}")))
        (test-error (string->team "{\"name\": 3}"))
        (let ((team1 (string->team
                      "{\"name\": \"Tiger Cats\", \"lead\": {\"name\": \"House\", \"id\": 321}, \"devs\": [{\"name\": \"Cameron\", \"id\": 7}, {\"name\": \"Thirteen\", \"id\": 13}]}")))
          (test-assert (team? team1))
          (test-assert (employee? (team-lead team1)))
          (test "House" (employee-name (team-lead team1)))
          (test-assert (vector? (team-devs team1)))
          (test 2 (vector-length (team-devs team1)))
          (test "Cameron" (employee-name (vector-ref (team-devs team1) 0)))
          (test "Thirteen" (employee-name (vector-ref (team-devs team1) 1)))))
      (test-end)
      (test-begin "json->string")
      (test "1" (json->string 1))
      (test "1.5" (json->string 1.5))
      (test "1000" (json->string 1E3))
      (test "null" (json->string 'null))
      (test "{\"null\":3}" (json->string  '((null . 3))))
      (test  "\"\\u00E1\"" (json->string ""))
      (test  "\"\\uD801\\uDC37\"" (json->string ""))
      (test  "\"\\uD83D\\uDE10\"" (json->string ""))
      (test "{\"menu\":{\"id\":\"file\",\"value\":\"File\",\"popup\":{\"menuitem\":[{\"value\":\"New\",\"onclick\":\"CreateNewDoc()\"},{\"value\":\"Open\",\"onclick\":\"OpenDoc()\"},{\"value\":\"Close\",\"onclick\":\"CloseDoc()\"}]}}}"
          (json->string '((menu
                           (id . "file")
                           (value . "File")
                           (popup
                            (menuitem
                             . #(((value . "New") (onclick . "CreateNewDoc()"))
                                 ((value . "Open") (onclick . "OpenDoc()"))
                                 ((value . "Close") (onclick . "CloseDoc()")))))))))
      (test "{\"glossary\":{\"title\":\"example glossary\",\"GlossDiv\":{\"title\":\"S\",\"GlossList\":{\"GlossEntry\":{\"ID\":\"SGML\",\"SortAs\":\"SGML\",\"GlossTerm\":\"Standard Generalized Markup Language\",\"Acronym\":\"SGML\",\"Abbrev\":\"ISO 8879:1986\",\"GlossDef\":{\"para\":\"A meta-markup language, used to create markup languages such as DocBook.\",\"GlossSeeAlso\":[\"GML\",\"XML\"]},\"GlossSee\":\"markup\"}}}}}"
          (json->string '((glossary
                           (title . "example glossary")
                           (GlossDiv
                            (title . "S")
                            (GlossList
                             (GlossEntry
                              (ID . "SGML")
                              (SortAs . "SGML")
                              (GlossTerm . "Standard Generalized Markup Language")
                              (Acronym . "SGML")
                              (Abbrev . "ISO 8879:1986")
                              (GlossDef
                               (para . "A meta-markup language, used to create markup languages such as DocBook.")
                               (GlossSeeAlso . #("GML" "XML")))
                              (GlossSee . "markup"))))))))
      (test-end)
      (test-end)
      )))


(define-library (chibi repl)
  (export repl $0 $1 $2 $3 $4 $5 $6 $7 $8 $9)
  (import (chibi) (only (meta) load-module module-name->file)
          (chibi ast) (chibi modules) (chibi doc)
          (chibi string) (chibi io) (chibi optional)
          (chibi process) (chibi term edit-line)
          (srfi 1)
          (srfi 9)
          (only (srfi 18) current-thread)
          (srfi 38)
          (srfi 95)
          (srfi 98))
  (include "repl.scm"))
;; quoted-printable.scm -- RFC2045 implementation
;; Copyright (c) 2005-2014 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

;;> RFC 2045 quoted printable encoding and decoding utilities.  This
;;> API is backwards compatible with the Gauche library
;;> rfc.quoted-printable.

;;> \schemeblock{
;;> (define (mime-encode-header header value charset)
;;>   (let ((prefix (string-append header ": "))
;;>         (str (ces-convert value "UTF8" charset)))
;;>     (string-append
;;>      prefix
;;>      (quoted-printable-encode-header charset str (string-length prefix)))))
;;> }

(define *default-max-col* 76)

;; Allow for RFC1522 quoting for headers by always escaping ? and _
(define (qp-encode bv start-col max-col separator)
  (define (hex i) (+ i (if (<= i 9) 48 55)))
  (let ((end (bytevector-length bv))
        (buf (make-bytevector max-col))
        (out (open-output-bytevector)))
    (let lp ((i 0) (col start-col))
      (cond
       ((= i end)
        (write-bytevector (bytevector-copy buf 0 col) out)
        (get-output-bytevector out))
       ((>= col (- max-col 3))
        (write-bytevector (bytevector-copy buf 0 col) out)
        (lp i 0))
       (else
        (let ((c (bytevector-u8-ref bv i)))
          (cond
           ((and (<= 33 c 126) (not (memq c '(61 63 95))))
            (bytevector-u8-set! buf col c)
            (lp (+ i 1) (+ col 1)))
           (else
            (bytevector-u8-set! buf col (char->integer #\=))
            (bytevector-u8-set! buf (+ col 1) (hex (arithmetic-shift c -4)))
            (bytevector-u8-set! buf (+ col 2) (hex (bitwise-and c #b1111)))
            (lp (+ i 1) (+ col 3))))))))))

;;> Return a quoted-printable encoded representation of the input
;;> according to the official standard as described in RFC2045.
;;>
;;> ? and _ are always encoded for compatibility with RFC1522
;;> encoding, and soft newlines are inserted as necessary to keep each
;;> lines length less than \var{max-col} (default 76).  The starting
;;> column may be overridden with \var{start-col} (default 0).

(define (quoted-printable-encode-string src . o)
  (if (string? src)
      (utf8->string
       (apply quoted-printable-encode-bytevector
              (string->utf8 src)
              o))
      (apply quoted-printable-encode-bytevector src o)))

(define (quoted-printable-encode-bytevector . o)
  (let* ((src (if (pair? o) (car o) (current-input-port)))
         (o (if (pair? o) (cdr o) '()))
         (start-col (if (pair? o) (car o) 0))
         (o (if (pair? o) (cdr o) '()))
         (max-col (if (pair? o) (car o) *default-max-col*))
         (o (if (pair? o) (cdr o) '()))
         (sep (if (pair? o) (car o) (string->utf8 "=\r\n"))))
    (qp-encode (if (bytevector? src) src (read-bytevector 1000000000 src))
               start-col max-col sep)))

;;> Variation of the above to read and write to ports.

(define (quoted-printable-encode . o)
  (write-string (apply quoted-printable-encode-string o)))

;;> Return a quoted-printable encoded representation of string as
;;> above, wrapped in =?ENC?Q?...?= as per RFC1522, split across
;;> multiple MIME-header lines as needed to keep each lines length
;;> less than \var{max-col}.  The string is encoded as is, and the
;;> encoding \var{enc} is just used for the prefix, i.e. you are
;;> responsible for ensuring \var{str} is already encoded according to
;;> \var{enc}.

(define (quoted-printable-encode-header encoding . o)
  (let* ((src (if (pair? o) (car o) (current-input-port)))
         (o (if (pair? o) (cdr o) '()))
         (start-col (if (pair? o) (car o) 0))
         (o (if (pair? o) (cdr o) '()))
         (max-col (if (pair? o) (car o) *default-max-col*))
         (o (if (pair? o) (cdr o) '()))
         (nl (if (pair? o) (car o) "\r\n")))
    (let* ((prefix (string-append "=?" encoding "?Q?"))
           (prefix-length (+ 2 (string-length prefix)))
           (separator (string->utf8 (string-append "?=" nl "\t" prefix)))
           (effective-max-col (- max-col prefix-length)))
      (bytevector-append
       (string->utf8 prefix)
       (qp-encode (if (string? src) src (port->string src))
                  start-col effective-max-col separator)
       (string->utf8 "?=")))))

;;> Return a quoted-printable decoded representation of \var{str}.  If
;;> \var{mime-header?} is specified and true, _ will be decoded as as
;;> space in accordance with RFC1522.  No errors will be raised on
;;> invalid input.

(define (quoted-printable-decode-string src . o)
  (if (string? src)
      (utf8->string
       (apply quoted-printable-decode-bytevector
              (string->utf8 src)
              o))
      (apply quoted-printable-decode-bytevector src o)))

(define (quoted-printable-decode-bytevector  . o)
  (define (hex? c)
    (or (char<=? #\0 (integer->char c) #\9)
        (char<=? #\A (integer->char c) #\F)))
  (define (unhex1 i)
    (if (>= i 65) (- i 55) (- i 48)))
  (define (unhex c1 c2)
    (+ (arithmetic-shift (unhex1 c1) 4) (unhex1 c2)))
  (let ((src (if (pair? o) (car o) (current-input-port)))
        (mime-header? (and (pair? o) (pair? (cdr o)) (car (cdr o)))))
    (let* ((bv (if (bytevector? src) src (read-bytevector 1000000000 src)))
           (end (bytevector-length bv))
           (out (open-output-bytevector)))
      (let lp ((i 0))
        (cond
         ((>= i end)
          (get-output-bytevector out))
         (else
          (let ((c (bytevector-u8-ref bv i)))
            (case c
              ((61)                    ; = escapes
               (cond
                ((< (+ i 2) end)
                 (let ((c2 (bytevector-u8-ref bv (+ i 1))))
                   (cond
                    ((eq? c2 10) (lp (+ i 2)))
                    ((eq? c2 13)
                     (lp (if (eq? 10 (bytevector-u8-ref bv (+ i 2)))
                             (+ i 3)
                             (+ i 2))))
                    ((hex? c2)
                     (let ((c3 (bytevector-u8-ref bv (+ i 2))))
                       (if (hex? c3) (write-u8 (unhex c2 c3) out))
                       (lp (+ i 3))))
                    (else (lp (+ i 3))))))))
              ((95)                    ; maybe translate _ to space
               (write-u8 (if mime-header? 32 c) out)
               (lp (+ i 1)))
              ((32 9)          ; strip trailing whitespace
               (let lp2 ((j (+ i 1)))
                 (cond
                  ((not (= j end))
                   (case (bytevector-u8-ref bv j)
                     ((32 9) (lp2 (+ j 1)))
                     ((10)
                      (lp (+ j 1)))
                     ((13)
                      (let ((k (+ j 1)))
                        (lp (if (and (< k end)
                                     (eq? 10 (bytevector-u8-ref bv k)))
                                (+ k 1) k))))
                     (else
                      (write-bytevector (bytevector-copy bv i j) out)
                      (lp j)))))))
              (else                     ; a literal char
               (write-u8 c out)
               (lp (+ i 1)))))))))))

;;> Variation of the above to read and write to ports.

(define (quoted-printable-decode . o)
  (write-string (apply quoted-printable-decode-string o)))
;; modules.scm -- module introspection utilities
;; Copyright (c) 2011-2013 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

;;> Module introspection library.

(define (file->sexp-list file)
  (call-with-input-file file
    (lambda (in)
      (port-source?-set! in #t)
      (let lp ((res '()))
        (let ((x (read in)))
          (if (eof-object? x)
              (reverse res)
              (lp (cons x res))))))))

(define (module? x)
  (and (vector? x)
       (>= (vector-length x) 4)
       (or (list? (vector-ref x 0)) (not (vector-ref x 0)))))

(define (module-ast mod) (vector-ref mod 3))
(define (module-ast-set! mod x) (vector-set! mod 3 x))

(define (module-name mod)
  (if (pair? mod)
      (car mod)
      (let lp ((ls *modules*))
        (and (pair? ls)
             (if (eq? mod (cdar ls))
                 (caar ls)
                 (lp (cdr ls)))))))

(define (module-dir mod)
  (let ((name (module-name mod)))
    (if (member name '((chibi) (meta)))
        ""
        (module-name-prefix name))))

;; assuming mod-name was found in file, resolves to the containing lib dir
(define (module-lib-dir file mod-name)
  (let lp ((ls (map (lambda (x)
                      (if (number? x) (number->string x) (symbol->string x)))
                    (reverse mod-name)))
           (path (reverse (string-split (path-strip-extension file) #\/))))
    (if (and (pair? ls) (pair? path) (equal? (car ls) (car path)))
        (lp (cdr ls) (cdr path))
        (if (null? path)
            "."
            (string-join (reverse path) "/")))))

(define (module-metas mod metas . o)
  (let* ((mod (if (module? mod) mod (find-module mod)))
         (dir (if (pair? o) (car o) (module-dir mod))))
    (let lp ((ls (module-meta-data mod)) (res '()))
      (cond
       ((not (pair? ls)) (reverse res))
       ((and (pair? (car ls)) (memq (caar ls) metas))
        (lp (cdr ls) (append (reverse (cdar ls)) res)))
       (else (lp (cdr ls) res))))))

(define (module-extract-declaration-files mod decls)
  (let* ((mod (if (module? mod) mod (find-module mod)))
         (dir (module-dir mod)))
    (define (module-file f)
      (find-module-file (string-append dir f)))
    (map module-file (reverse (module-metas mod decls dir)))))

(define (module-includes mod)
  (module-extract-declaration-files mod '(include)))

(define (module-include-library-declarations mod)
  (module-extract-declaration-files mod '(include-library-declarations)))

(define (module-shared-includes mod)
  (let* ((mod (if (module? mod) mod (find-module mod)))
         (dir (module-dir mod)))
    (define (module-file f)
      (find-module-file (string-append dir f ".stub")))
    (let lp ((ls (reverse (module-metas mod '(include-shared)))) (res '()))
      (cond ((null? ls) (reverse res))
            ((module-file (car ls)) => (lambda (x) (lp (cdr ls) (cons x res))))
            (else (lp (cdr ls) res))))))

(define (analyze-module-source name mod recursive?)
  (let ((env (make-environment))
        (dir (module-dir mod)))
    (define (resolve-file file)
      (find-module-file (string-append dir file)))
    (define (include-source file)
      (cond ((resolve-file file)
             => (lambda (x) (cons 'begin (file->sexp-list x))))
            (else (error "couldn't find include" file))))
    (cond
     ((equal? '(chibi) name)
      (env-define! env '*features* *features*)
      (env-define! env '*shared-object-extension* *shared-object-extension*)
      (%import env (primitive-environment 7) #f #t))
     (else
      (resolve-module-imports env (module-meta-data mod))))
    (let lp ((ls (module-meta-data mod)) (res '()))
      (cond
       ((not (pair? ls))
        (reverse res))
       (else
        (case (and (pair? (car ls)) (caar ls))
          ((import import-immutable)
           (for-each
            (lambda (m)
              (let* ((mod2-name+imports (resolve-import m))
                     (mod2-name (car mod2-name+imports)))
                (if recursive?
                    (analyze-module mod2-name #t))))
            (cdar ls))
           (lp (cdr ls) res))
          ((include include-ci)
           (lp (append (map include-source (cdar ls)) (cdr ls)) res))
          ((include-library-declarations)
           (lp (append (append-map file->sexp-list (map resolve-file (cdar ls))) (cdr ls)) res))
          ((include-shared include-shared-optionally)
           (for-each
            (lambda (file)
              (let ((f (string-append file *shared-object-extension*)))
                (cond ((find-module-file f) => (lambda (path) (load path env))))))
            (cdar ls)))
          ((begin body)
           (let lp2 ((ls2 (cdar ls)) (res res))
             (cond
              ((pair? ls2)
               (let ((x (analyze (car ls2) env)))
                 (eval (car ls2) env)
                 (lp2 (cdr ls2) (cons x res))))
              (else
               (lp (cdr ls) res)))))
          (else
           (lp (cdr ls) res))))))))

(define (analyze-module name . o)
  (let ((recursive? (and (pair? o) (car o)))
        (mod (load-module name)))
    (cond
     ((not (module-ast mod))
      (module-ast-set! mod '())       ; break cycles, just in case
      (module-ast-set! mod (analyze-module-source name mod recursive?))))
    mod))

(define (module-ref mod var-name . o)
  (let ((cell (env-cell (module-env (if (module? mod) mod (load-module mod)))
                        var-name)))
    (if cell
        (cdr cell)
        (if (pair? o) (car o) (error "no binding in module" mod var-name)))))

(define (module-contains? mod var-name)
  (and (env-cell (module-env (if (module? mod) mod (load-module mod))) var-name)
       #t))

(define (module-defines? name mod var-name)
  (let lp ((ls (module-ast (analyze-module name))))
    (cond
     ((null? ls) #f)
     ((and (set? (car ls))
           (eq? var-name (ref-name (set-var (car ls))))))
     ((seq? (car ls)) (lp (append (seq-ls (car ls)) (cdr ls))))
     (else (lp (cdr ls))))))

(define (containing-module x)
  (let lp1 ((ls (reverse *modules*)))
    (and (pair? ls)
         (let ((env (module-env (cdar ls))))
           (let lp2 ((e-ls (if (environment? env) (env-exports env) '())))
             (if (null? e-ls)
                 (lp1 (cdr ls))
                 (let ((cell (env-cell env (car e-ls))))
                   (if (and (eq? x (cdr cell))
                            (or (opcode? x)
                                (module-defines? (caar ls) (cdar ls) (car cell))))
                       (car ls)
                       (lp2 (cdr e-ls))))))))))

(define (procedure-analysis x . o)
  (cond
   ((opcode? x)
    #f)
   (else
    (let ((name (if (procedure? x) (procedure-name x) x))
          (mod (or (and (pair? o) (car o))
                   (containing-module x))))
      (and mod
           (let lp ((ls (module-ast (analyze-module (module-name mod)))))
             (and (pair? ls)
                  (cond
                   ((and (set? (car ls))
                         (eq? name (ref-name (set-var (car ls)))))
                    (set-value (car ls)))
                   ((seq? (car ls))
                    (lp (append (seq-ls (car ls)) (cdr ls))))
                   (else
                    (lp (cdr ls)))))))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; finding all available modules

(define (module-file? file)
  (let ((len (string-length file)))
    (and (> len 4) (equal? ".sld" (substring file (- len 4))))))

(define (read-static-modules file)
  (protect (exn (else '()))
    (call-with-input-file file
      (lambda (in)
        (let lp ((res '()))
          (let ((expr (read in)))
            (cond
             ((eof-object? expr)
              res)
             ((and (pair? expr) (eq? 'define-library (car expr)))
              (let ((name (cadr expr))
                    (exports (cond ((assq 'export (cddr expr)) => cdr)
                                   (else '()))))
                (lp (cons (cons name (make-module exports #f #f)) res))))
             (else
              (lp res)))))))))

(define no-module-depth-limit 2)

(define (available-modules-in-directory dir depth res)
  (call-with-values
      (lambda ()
        (partition file-directory?
                   (map (lambda (f) (string-append dir "/" f))
                        (remove (lambda (f) (member f '("." "..")))
                                (directory-files dir)))))
    (lambda (dirs files)
      (let ((mods (append-map read-static-modules
                              (filter module-file? files))))
        (if (and (null? mods) (>= depth no-module-depth-limit))
            res
            (let ((depth (if (pair? mods) 0 (+ 1 depth))))
              (let lp ((ls dirs) (res (append mods res)))
                (if (null? ls)
                    res
                    (lp (cdr ls)
                        (available-modules-in-directory (car ls) depth res)
                        )))))))))

(define (available-modules)
  (let lp ((ls (current-module-path)) (res *modules*))
    (if (null? ls)
        res
        (lp (cdr ls)
            (available-modules-in-directory (car ls) 0 res)))))

(define (modules-exporting-identifier name)
  (let lp ((ls (available-modules))
           (res '()))
    (cond
     ((null? ls) (reverse res))
     ((and (memq name (module-exports (cdar ls)))
           (not (assoc (caar ls) res)))
      (lp (cdr ls) (cons (car ls) res)))
     (else (lp (cdr ls) res)))))

(define-binary-record-type tar
  (make: make-tar/full)
  (pred: tar?)
  (read: read-tar)
  (write: write-tar/raw)
  (block:
   (path (padded-string 100) tar-path-raw tar-path-raw-set!)
   (mode (octal 8) tar-mode tar-mode-set!)
   (uid (octal 8) tar-uid tar-uid-set!)
   (gid (octal 8) tar-gid tar-gid-set!)
   (size (octal 12) tar-size tar-size-set!)
   (time (octal 12) tar-time tar-time-set!)
   (checksum (octal 8) tar-checksum tar-checksum-set!)
   (type (fixed-string 1) tar-type tar-type-set!)
   (link-name (padded-string 100) tar-link-name tar-link-name-set!)
   (ustar (padded-string 6) tar-ustar tar-ustar-set!)
   (ustar-version (padded-string 2) tar-ustar-version)
   (owner (padded-string 32) tar-owner tar-owner-set!)
   (group (padded-string 32) tar-group tar-group-set!)
   (device-major (octal 8) tar-device-major tar-device-major-set!)
   (device-minor (octal 8) tar-device-minor tar-device-minor-set!)
   (path-prefix (padded-string 155) tar-path-prefix tar-path-prefix-set!)
   #u8(0 0 0 0 0 0 0 0 0 0 0 0)))

(define (file-owner-or-nobody uid)
  (or (user-name (user-information uid)) "nobody"))
(define (file-group-or-nobody gid)
  (or (group-name (group-information gid)) "nobody"))

(define (make-tar file mode uid gid size mod-time type . o)
  (let* ((link (if (pair? o) (car o) ""))
         (raw-path (tar-normalize-path file (equal? "5" type)))
         (len (string-length raw-path))
         (path
          (if (< len 100) raw-path (substring raw-path (- len 100))))
         (path-prefix
          (if (< len 100) "" (substring raw-path 0 (- len 100)))))
    (if (>= len 255)
        (error "path name too long" raw-path))
    (make-tar/full path (bitwise-and #o7777 mode) uid gid size
                   mod-time 0 type link "ustar" "00"
                   (file-owner-or-nobody uid) (file-group-or-nobody gid)
                   0 0 path-prefix)))

(define (tar-compute-checksum tar)
  (let ((tmp-out (open-output-bytevector)))
    (write-tar/raw tar tmp-out)
    (let ((bv (get-output-bytevector tmp-out)))
      (do ((i 0 (+ i 1))
           (sum 0 (+ sum (if (<= 148 i 155)  ; checksum itself is spaces
                             32
                             (bytevector-u8-ref bv i)))))
          ((= i 512) sum)))))

;; wrap the writer to automatically compute the checksum
(define (write-tar tar out)
  (tar-checksum-set! tar (tar-compute-checksum tar))
  (write-tar/raw tar out))

;; wrap the path to use the prefix
(define (tar-path tar)
  (string-append (tar-path-prefix tar) (tar-path-raw tar)))

(define (tar-normalize-path path . o)
  (cond ((string-suffix? "/." path) (string-trim-right path #\.))
        ((and (not (string-suffix? "/" path)) (and (pair? o) (car o)))
         (string-append path "/"))
        (else path)))

(define (tar-path-set! tar path)
  (let* ((path (tar-normalize-path path (equal? "5" (tar-type tar))))
         (len (string-length path)))
    (cond ((< len 100)
           (tar-path-raw-set! tar path)
           (tar-path-prefix-set! tar ""))
          ((< len 255)
           (tar-path-raw-set! tar (substring path (- len 100)))
           (tar-path-prefix-set! tar (substring path 0 (- len 100))))
          (else (error "path name too long")))))

;; utilities

(define (read-modulo-bytevector in len mod)
  (let ((res (read-bytevector len in))
        (rem (modulo len mod)))
    (if (positive? rem)
        (read-bytevector (- mod rem) in))
    res))

(define (write-modulo-file out file mod)
  (let ((in (open-binary-input-file file)))
    (let lp ()
      (let ((bv (read-bytevector mod in)))
        (cond
         ((eof-object? bv))
         (else
          (write-bytevector bv out)
          (let ((len (bytevector-length bv)))
            (if (< len mod)
                (write-bytevector (make-bytevector (- mod len) 0) out)
                (lp)))))))))

;; fundamental iterator
(define (tar-fold src kons knil)
  (let ((in (cond ((string? src) (open-binary-input-file src))
                  ((bytevector? src) (open-input-bytevector src))
                  (else src))))
    (let lp ((acc knil) (empty 0))
      (cond
       ((or (eof-object? (peek-u8 in)) (>= empty 2))
        (close-input-port in)
        acc)
       (else
        (let ((tar (read-tar in)))
          (if (and (equal? "" (tar-path tar)) (zero? (tar-size tar)))
              (lp acc (+ empty 1))
              (let ((bv (read-modulo-bytevector in (tar-size tar) 512)))
                (lp (kons tar bv acc) 0)))))))))

;; not a tar-bomb and no absolute paths
(define (tar-safe? tarball)
  (define (path-top path)
    (substring-cursor path (string-cursor-start path) (string-find path #\/)))
  (let ((files (map path-normalize (tar-files tarball))))
    (and (every path-relative? files)
         (or (< (length files) 2)
             (let ((dir (path-top (car files))))
               (every (lambda (f) (equal? dir (path-top f))) (cdr files)))))))

(define (tar-for-each tarball proc)
  (tar-fold tarball (lambda (tar bv acc) (proc tar bv)) #f))

;; list the files in the archive
(define (tar-files tarball)
  (reverse (tar-fold tarball (lambda (tar bv acc) (cons (tar-path tar) acc)) '())))

;; extract to the current filesystem
(define (tar-extract tarball . o)
  (define (safe-path path)
    (string-trim-left
     (path-strip-leading-parents (path-normalize path))
     #\/))
  (let ((rename (if (pair? o) (car o) safe-path)))
    (tar-for-each
     tarball
     (lambda (tar bv)
       (let ((path (rename (tar-path tar))))
         (case (string-ref (tar-type tar) 0)
           ((#\0 #\null)
            (let ((out (open-output-file-descriptor
                        (open path
                              (bitwise-ior open/write
                                           open/create
                                           open/non-block)
                              (tar-mode tar)))))
              (write-bytevector bv out)
              (close-output-port out)))
           ((#\1) (link-file (rename (tar-link-name tar)) path))
           ((#\2) (symbolic-link-file (rename (tar-link-name tar)) path))
           ((#\5) (create-directory* path (tar-mode tar)))
           ((#\g #\x))                   ;; meta data
           ((#\3 #\4 #\6) (error "devices not supported" (tar-type tar)))
           (else (error "invalid tar type" (tar-type tar)))))))))

(define (tar-extract-file tarball file)
  (call-with-current-continuation
   (lambda (return)
     (tar-for-each
      tarball
      (lambda (tar bv) (if (equal? (tar-path tar) file) (return bv))))
     #f)))

(define (file->tar file)
  (let* ((st (file-link-status file))
         (type (cond ((file-link? st) "2")
                     ((file-character? st) "3")
                     ((file-block? st) "4")
                     ((file-directory? st) "5")
                     (else "0"))))
    (make-tar file
              (file-mode st)
              (file-owner st)
              (file-group st)
              (if (equal? "0" type) (file-size st) 0)
              (file-modification-time st)
              type
              (if (file-link? st) (read-link file) ""))))

(define (inline->tar file content . o)
  (make-tar file
            (if (pair? o) (car o) #o644)
            (current-user-id)
            (current-group-id)
            (bytevector-length content)
            (exact (round (current-second)))
            "0"))

(define (tar-add-directories tar out acc)
  (let lp ((dir (path-directory (tar-path tar))) (acc acc))
    (let ((dir/ (if (string-suffix? "/" dir) dir (string-append dir "/"))))
      (cond
       ((member dir '("" "." "/")) acc)
       ((assoc dir/ acc) (lp (path-directory dir) acc))
       (else
        (let ((acc (lp (path-directory dir) (cons (cons dir/ #f) acc))))
          (let ((tar2 (make-tar dir/
                                (bitwise-ior #o111 (tar-mode tar))
                                (tar-uid tar)
                                (tar-gid tar)
                                0
                                (tar-time tar)
                                "5")))
            (write-tar tar2 out)
            acc)))))))

;; create an archive for a given file list
(define (tar-create tarball files . o)
  (let* ((rename (if (pair? o) (car o) (lambda (f) f)))
         (no-recurse? (and (pair? o) (pair? (cdr o)) (cadr o)))
         (get-src
          (lambda (x) (if (pair? x) (and (eq? 'rename (car x)) (cadr x)) x)))
         (get-dest
          (lambda (x)
            (rename (if (pair? x)
                        (if (eq? 'rename (car x))
                            (car (cddr x))
                            (cadr x))
                        x))))
         (get-content
          (lambda (x) (and (pair? x) (eq? 'inline (car x))
                       (let ((c (car (cddr x))))
                         (if (string? c) (string->utf8 c) c))))))
    (let ((out (cond ((eq? #t tarball) (current-output-port))
                     ((eq? #f tarball) (open-output-bytevector))
                     (else (open-binary-output-file tarball)))))
      (fold
       (lambda (file acc)
         (let ((src0 (get-src file))
               (dest0 (get-dest file))
               (content0 (get-content file)))
           (define (kons x acc)
             (let* ((src (get-src x))
                    (dest (if (equal? x src0) dest0 (get-dest x)))
                    (content (if (equal? x src0) content0 (get-content x)))
                    (tar (if content
                             (inline->tar dest content)
                             (file->tar src))))
               (tar-path-set! tar dest)
               (cond
                ((assoc (tar-path tar) acc)
                 => (lambda (prev)
                      (if (not (and (file-directory? src)
                                    (file-directory? (cdr prev))))
                          (write-string
                           (string-append "tar-create: duplicate file: "
                                          dest "\n")
                           (current-error-port)))
                      acc))
                (else
                 (let ((acc (tar-add-directories tar out acc)))
                   (write-tar tar out)
                   (cond
                    ((and (string? src) (equal? "0" (tar-type tar)))
                     (write-modulo-file out src 512))
                    (content
                     (write-bytevector content out)
                     (let ((rem (modulo (bytevector-length content) 512)))
                       (if (positive? rem)
                           (write-bytevector
                            (make-bytevector (- 512 rem) 0) out)))))
                   (cons (cons (tar-path tar) src) acc))))))
           (if (and src0 (not no-recurse?))
               (directory-fold-tree src0 #f #f kons acc)
               (kons src0 acc))))
       '() files)
      (write-bytevector (make-bytevector 1024 0) out)
      (let ((res (if (eq? #f tarball) (get-output-bytevector out))))
        (close-output-port out)
        res))))

(define (main args)
  (let ((args (cdr args)))
    (cond
     ((equal? "t" (car args))
      (for-each (lambda (f) (write-string f) (newline)) (tar-files (cadr args))))
     ((equal? "x" (car args))
      (if (tar-safe? (cadr args))
          (tar-extract (cadr args))
          (error "tar file not a single relative directory" (cadr args))))
     ((equal? "c" (car args))
      (tar-create (cadr args) (cddr args)))
     ((equal? "f" (car args))
      (write-string
       (utf8->string (tar-extract-file (cadr args) (car (cddr args))))))
     (else
      (error "unknown tar command" (car args))))))

(define-library (chibi diff)
  (import (scheme base) (srfi 1) (chibi optional) (chibi term ansi))
  (export lcs lcs-with-positions
          diff write-diff diff->string
          write-edits edits->string edits->string/color
          write-line-diffs
          write-line-diffs/color
          write-char-diffs
          write-char-diffs/color)
  (cond-expand
   (chibi (import (only (chibi io) port->list)))
   (else
    (begin
      (define (port->list reader port)
        (let lp ((res '()))
          (let ((x (reader port)))
            (if (eof-object? x)
                (reverse res)
                (lp (cons x res)))))))))
  (include "diff.scm"))

;;> A parser combinator library with optional memoization and
;;> convenient syntax.

(define-library (chibi parse)
  (export grammar grammar/unmemoized define-grammar define-grammar/unmemoized
          call-with-parse parse parse-fully parse-fold parse-failure
          parse->list parse-fully->list
          file->parse-stream string->parse-stream parse-stream-substring
          parse-stream-start? parse-stream-end? parse-stream-ref
          parse-anything parse-nothing parse-epsilon
          parse-seq parse-and parse-or parse-not list->parse-seq
          parse-repeat parse-repeat+ parse-optional
          parse-map parse-map-substring parse-ignore parse-assert
          parse-atomic parse-commit parse-memoize
          parse-char parse-not-char
          parse-string parse-token parse-sre
          parse-beginning parse-end
          parse-beginning-of-line parse-end-of-line
          parse-beginning-of-word parse-end-of-word
          parse-word parse-word+
          parse-with-failure-reason
          make-parse-stream)
  (cond-expand
   (chibi
    (import (chibi) (chibi char-set) (srfi 9))
    (begin
      (define-syntax grammar-bind
        (er-macro-transformer
         (lambda (expr rename compare)
           (let ((name (cadr expr))
                 (k (car (cddr expr)))
                 (f (cadr (cddr expr)))
                 (bindings (car (cddr (cddr expr)))))
             (if (and (identifier? name)
                      (not (assq name bindings)))
                 (let ((new-tmp (rename 'new-tmp))
                       (save-tmp (rename 'save-tmp))
                       (lambda_ (rename 'lambda))
                       (set!_ (rename 'set!))
                       (s (rename 's))
                       (i (rename 'i))
                       (sk (rename 'sk))
                       (fk (rename 'fk))
                       (r (rename 'r)))
                   (append
                    k
                    (list
                     `(,lambda_
                       (,s ,i ,sk ,fk)
                       ((,lambda_ (,save-tmp)
                                  (,f ,s ,i
                                      (,lambda_ (,r ,s ,i ,fk)
                                                (,set!_ ,new-tmp ,r)
                                                (,sk ,r ,s ,i ,fk))
                                      (,lambda_ (,s ,i ,r)
                                                (,set!_ ,new-tmp ,save-tmp)
                                                (,fk ,s ,i ,r))))
                        ,new-tmp))
                     (cons (list name new-tmp) bindings))))
                 (append k (list f bindings)))))))))
   (else
    (import (scheme base) (scheme char) (scheme file) (srfi 14))
    (begin
      (define-syntax grammar-bind
        (syntax-rules ()
          ((grammar-bind name (k ...) f ((var tmp) ...))
           (let-syntax ((new-symbol?
                         (syntax-rules (var ...)
                           ((new-symbol? name sk fk) sk)
                           ((new-symbol? _ sk fk) fk))))
             ;; Bind the name only to the first instance in the pattern.
             (new-symbol?
              random-symbol-to-match
              (k ...
                 (lambda (s i sk fk)
                   (let ((save-tmp new-tmp))
                     (f s i
                        (lambda (r s i fk) (set! new-tmp r) (sk r s i fk))
                        (lambda (s i r) (set! new-tmp save-tmp) (fk s i r)))))
                 ((var tmp) ... (name new-tmp)))
              (k ... f ((var tmp) ...))))))))))
  (include "parse/parse.scm"))

(define-library (chibi pty-test)
  (import (scheme base) (scheme file) (scheme write)
          (chibi io) (chibi pty) (chibi stty) (chibi test))
  (export run-tests)
  (begin
    (define (run-tests . o)
      (when (file-exists? "/usr/bin/units")
        (test-begin "pty")
        (test '("\t* 3.2808399" "\t/ 0.3048")
            (call-with-pty-process-io
             '("/usr/bin/units" "-q")
             (lambda (pid in out name)
               (with-raw-io
                out
                (lambda ()
                  ;; input with tab completion
                  (display "mete\t" out) (newline out)
                  (display "fee\t" out) (newline out)
                  (display (integer->char 4) out)
                  (flush-output-port out)
                  ;; result
                  (let* ((l1 (read-line in))
                         (l2 (read-line in)))
                    (list l1 l2)))))))
        (test-end)))))
;; Written by Marc Nieper-Wikirchen

;; TODO: make-synthetic-identifier should return a truly unique (that
;; is not free-identifier=? to any other) identifier.

;; TODO: Consecutive ellipses in syntax templates.

;; TODO: Write many more tests.

(define current-renamer (make-parameter (lambda (x) x)))
(define current-usage-environment (make-parameter (current-environment)))

(define (free-identifier=? x y)
  (let ((env (or (current-usage-environment) (current-environment))))
    (identifier=? env x env y)))

(define (%make-transformer transformer)
  (cond
   ((and (= 1 (procedure-arity transformer))
         (not (procedure-variadic? transformer)))
    (lambda (expr use-env mac-env)
      (let ((old-use-env (current-usage-environment))
            (old-renamer (current-renamer)))
        (current-usage-environment use-env)
        (current-renamer (make-renamer mac-env))
        (let ((result (transformer expr)))
          (current-usage-environment old-use-env)
          (current-renamer old-renamer)
          result))))
   (else
    (lambda (expr use-env mac-env)
      (let ((old-use-env (current-usage-environment))
            (old-renamer (current-renamer)))
        (current-usage-environment use-env)
        (current-renamer (make-renamer mac-env))
        (let ((result (transformer expr use-env mac-env)))
          (current-usage-environment old-use-env)
          (current-renamer old-renamer)
          result))))))

(define (make-transformer base-transformer)
  (let ((wrapped-transformer (%make-transformer base-transformer)))
    (if (procedure-variable-transformer? base-transformer)
        (make-variable-transformer wrapped-transformer)
        wrapped-transformer)))

(%define-syntax define-syntax
  (lambda (expr use-env mac-env)
    (list (close-syntax '%define-syntax mac-env)
          (cadr expr)
          (list (close-syntax 'make-transformer mac-env)
                (car (cddr expr))))))

(define-syntax let-syntax
  (syntax-rules ()
    ((let-syntax ((keyword transformer) ...) . body)
     (%let-syntax ((keyword (make-transformer transformer)) ...) . body))))

(define-syntax letrec-syntax
  (syntax-rules ()
    ((letrec-syntax ((keyword transformer) ...) . body)
     (%letrec-syntax ((keyword (make-transformer transformer)) ...) . body))))

(define-record-type Pattern-Cell
  (make-pattern-cell val) pattern-cell?
  (val pattern-cell-value))

(define-syntax define-pattern-variable
  (er-macro-transformer
   (lambda (expr rename compare)
     (let ((id (cadr expr))
           (binding (cddr expr)))
       (let ((cell (env-cell (current-usage-environment) id)))
         (if cell
             (macro-aux-set! (cdr cell) (make-pattern-cell binding))))
       (rename '(begin))))))

(define (make-pattern-variable pvar)
  (lambda (expr)
    (error "reference to pattern variable outside syntax" pvar)))

(define (pattern-variable x)
  (and-let*
      ((cell (env-cell (current-usage-environment) x))
       (cell-ref (cdr cell))
       ((macro? cell-ref))
       (aux (macro-aux cell-ref))
       ((pattern-cell? aux)))
    (pattern-cell-value aux)))

(define (rename id)
  ((current-renamer) id))

(define current-ellipsis-id
  (make-syntactic-closure (current-environment) '() 'current-ellipsis))

(define (ellipsis-identifier? id)
  (let* ((cell (env-cell (current-usage-environment) current-ellipsis-id))
         (ellipsis (if cell
                       (macro-aux (cdr cell))
                       (rename '...))))
    (free-identifier=? id ellipsis)))

(define bound-identifier=?
  (lambda (x y)
    (eq? x y)))

(define (syntax-transformer level)
  (er-macro-transformer
   (lambda (expr rename compare)
     (let*-values (((out envs)
                    (gen-template (cadr expr) '() ellipsis-identifier? level)))
       out))))

(define (syntax->datum stx)
  (strip-syntactic-closures stx))

(define-syntax syntax (syntax-transformer #f))
(define-syntax quasisyntax (syntax-transformer 0))
(define-auxiliary-syntax unsyntax)
(define-auxiliary-syntax unsyntax-splicing)

(define (gen-template tmpl envs ell? level)
  (cond
   ((pair? tmpl)
    (cond
     ((and (identifier? (car tmpl))
           (free-identifier=? (car tmpl) (rename 'unsyntax)))
      (if (and level (zero? level))
          (values (cadr tmpl) envs)
          (let*-values (((out envs) (gen-template (cadr tmpl) envs ell? (and level (- level 1)))))
            (values `(,(rename 'list) ,(gen-data (car tmpl)) ,out) envs))))
     ((and (identifier? (car tmpl))
           (free-identifier=? (car tmpl) (rename 'quasisyntax)))
      (let*-values (((out envs) (gen-template (cadr tmpl) envs ell? (and level (+ level 1)))))
        (values `(,(rename 'list) ,(gen-data (car tmpl)) ,out) envs)))
     ((and (pair? (car tmpl))
           (free-identifier=? (caar tmpl) (rename 'unsyntax)))
      (if (and level (zero? level))
          (let*-values (((out envs) (gen-template (cdr tmpl) envs ell? level)))
            (values `(,(rename 'cons*) ,@(cdar tmpl) ,out) envs))
          (let*-values (((out1 envs) (gen-template (cdar tmpl) envs ell? (and level (- level 1))))
                        ((out2 envs) (gen-template (cdr tmpl) envs ell? level)))
            (values `(,(rename 'cons) (,(rename 'cons) ,(gen-data (caar tmpl)) ,out1)
                      ,out2) envs))))
     ((and (pair? (car tmpl))
           (free-identifier=? (caar tmpl) (rename 'unsyntax-splicing)))
      (if (and level (zero? level))
          (let*-values (((out envs) (gen-template (cdr tmpl) envs ell? level)))
            (values `(,(rename 'append) ,@(cdar tmpl) ,out) envs))
          (let*-values (((out1 envs) (gen-template (cdar tmpl) envs ell? (and level (- level 1))))
                        ((out2 envs) (gen-template (cdr tmpl) envs ell? level)))
            (values `(,(rename 'cons) (,(rename 'cons) ,(gen-data (caar tmpl)) ,out1)
                      ,out2) envs))))
     ((and (identifier? (car tmpl))
           (ell? (car tmpl)))
      (gen-template (cadr tmpl) envs (lambda (id) #f) level))
     ((and (pair? (cdr tmpl))
           (identifier? (cadr tmpl))
           (ell? (cadr tmpl)))
      (let*-values (((out* envs)
                     (gen-template (cddr tmpl) envs ell? level))
                    ((out envs)
                     (gen-template (car tmpl) (cons '() envs) ell? level)))
        (if (null? (car envs))
            (error "too many ellipses following syntax template" (car tmpl)))
        (values `(,(rename 'fold-right) (,(rename 'lambda) (,@(car envs) ,(rename 'stx))
                                         (,(rename 'cons) ,out ,(rename 'stx)))
                  ,out* ,@(car envs))
                (cdr envs))))
     (else
      (let*-values (((out1 envs)
                     (gen-template (car tmpl) envs ell? level))
                    ((out2 envs)
                     (gen-template (cdr tmpl) envs ell? level)))
        (values `(,(rename 'cons) ,out1 ,out2) envs)))))
   ((vector? tmpl)
    (let*-values (((out envs)
                   (gen-template (vector->list tmpl) envs ell? level)))
      (values `(,(rename 'list->vector) ,out) envs)))
   ((identifier? tmpl)
    (cond ((ell? tmpl)
           (error "misplaced ellipsis in syntax template" tmpl))
          ((pattern-variable tmpl) =>
           (lambda (binding)
             (values (car binding)
                     (update-envs tmpl (car binding) (cadr binding) envs))))
          (else
           (values (gen-data tmpl) envs))))
   (else
    (values `(,(rename 'quote) ,tmpl) envs))))

(define (gen-data id)
  `((,(rename 'current-renamer))
    (,(rename 'syntax-quote) ,id)))

(define (update-envs id x level envs)
  (let loop ((level level) (envs envs))
    (cond ((zero? level)
           envs)
          ((null? envs)
           (error "too few ellipses following syntax template" id))
          (else
           (let ((outer-envs (loop (- level 1) (cdr envs))))
             (cond ((member x (car envs) bound-identifier=?)
                    envs)
                   (else
                    (cons (cons x (car envs))
                          outer-envs))))))))

(define-syntax syntax-case
  (er-macro-transformer
   (lambda (expr rename compare)
     (let ((expr (cadr expr))
           (lit* (car (cddr expr)))
           (clause* (reverse (cdr (cddr expr))))
           (error #'(error "syntax error" e)))
       #`(let ((e #,expr))
           #,(if (null? clause*)
                 error
                 #`(let ((fail (lambda () #,error)))
                     #,(let loop ((clause (car clause*))
                                  (clause* (cdr clause*)))
                         (if (null? clause*)
                             (gen-clause lit* clause)
                             #`(let ((fail (lambda ()
                                             #,(gen-clause lit* clause))))
                                 #,(loop (car clause*) (cdr clause*))))))))))))

(define (gen-clause lit* clause)
  (if (= 3 (length clause))
      (gen-output lit* (car clause) (cadr clause) (car (cddr clause)))
      (gen-output lit* (car clause) #t (cadr clause))))

(define (gen-output lit* pattern fender output-expr)
  (let*-values (((matcher vars)
                 (gen-matcher #'e lit* pattern '())))
    (matcher
     (lambda ()
       #`(let-syntax
             #,(map (lambda (var)
                      #`(#,(car var)
                         (make-pattern-variable (syntax-quote #,(car var)))))
                    vars)
           #,@(map (lambda (var)
                     #`(define-pattern-variable . #,var))
                   vars)
           (if #,fender
               #,output-expr
               (fail)))))))

(define (gen-matcher e lit* pattern vars)
  (cond
   ((pair? pattern)
    (cond
     ((and (pair? (cdr pattern))
           (identifier? (cadr pattern))
           (ellipsis-identifier? (cadr pattern)))
      (let* ((l (length+ (cddr pattern)))
             (h (car (generate-temporaries '(#f))))
             (t (car (generate-temporaries '(#f)))))
        (let*-values (((head-matcher vars)
                       (gen-map h lit* (car pattern) vars))
                      ((tail-matcher vars)
                       (gen-matcher* t lit* (cddr pattern) vars)))
          (values (lambda (k)
                    #`(let ((n (length+ #,e)))
                        (if (and n (>= n #,l))
                            (let*-values (((#,h #,t) (split-at #,e (- n #,l))))
                              #,(head-matcher (lambda ()
                                                (tail-matcher k))))
                            (fail))))
                  vars))))
     (else
      (let ((e1 (car (generate-temporaries '(#f))))
            (e2 (car (generate-temporaries '(#f)))))
        (let*-values (((car-matcher vars)
                       (gen-matcher e1 lit* (car pattern) vars))
                      ((cdr-matcher vars)
                       (gen-matcher e2 lit* (cdr pattern) vars)))
          (values (lambda (k)
                    #`(if (pair? #,e)
                          (let ((#,e1 (car #,e))
                                (#,e2 (cdr #,e)))
                            #,(car-matcher (lambda ()
                                             (cdr-matcher k))))
                          (fail)))
                  vars))))))
   ((identifier? pattern)
    (cond ((member pattern lit* free-identifier=?)
           (values (lambda (k)
                     #`(if (free-identifier=? #'#,pattern #,e)
                           #,(k)
                           (fail)))
                   vars))
          ((ellipsis-identifier? pattern)
           (error "misplaced ellipsis" pattern))
          ((free-identifier=? pattern #'_)
           (values (lambda (k)
                     (k))
                   vars))
          (else
           (values (lambda (k)
                     (k))
                   (alist-cons pattern (list e 0) vars)))))
   (else
    (values (lambda (k)
              #`(if (equal? (syntax->datum #,e) '#,pattern)
                    #,(k)
                    (fail)))
            vars))))

(define (gen-map h lit* pattern vars)
  (let*-values (((matcher inner-vars) (gen-matcher #'g lit* pattern '())))
    (let ((loop (car (generate-temporaries '(#f))))
          (g* (generate-temporaries inner-vars)))
      (values
       (lambda (k)
         #`(let #,loop ((#,h (reverse #,h))
                        #,@(map (lambda (g)
                                  #`(#,g '()))
                                g*))
                (if (null? #,h)
                    #,(k)
                    (let ((g (car #,h)))
                      #,(matcher
                         (lambda ()
                           #`(#,loop (cdr #,h)
                                     #,@(map (lambda (var g)
                                               #`(cons #,(cadr var) #,g))
                                             inner-vars g*))))))))
       (fold (lambda (g var vars)
               (alist-cons (car var) (list g (+ (cadr (cdr var)) 1)) vars))
             vars g* inner-vars)))))

(define (gen-matcher* e lit* pattern* vars)
  (let loop ((e e) (pattern* pattern*) (vars vars))
    (cond ((null? pattern*)
           (values (lambda (k)
                     #`(if (null? #,e)
                           #,(k)
                           (fail)))
                   vars))
          ((pair? pattern*)
           (let ((e1 (car (generate-temporaries '(#f))))
                 (e2 (car (generate-temporaries '(#f)))))
             (let*-values (((car-matcher vars)
                            (gen-matcher e1 lit* (car pattern*) vars))
                           ((cdr-matcher vars)
                            (loop e2 (cdr pattern*) vars)))
               (values (lambda (k)
                         #`(let ((#,e1 (car #,e))
                                 (#,e2 (cdr #,e)))
                             #,(car-matcher (lambda ()
                                              (cdr-matcher k)))))
                       vars))))
          (else
           (gen-matcher e lit* pattern* vars)))))

(define (make-synthetic-identifier id)
  (close-syntax id (environment)))

(define (generate-temporaries l)
  (map (lambda (x) (make-synthetic-identifier 't)) l))

(define-syntax with-syntax
  (lambda (x)
    (syntax-case x ()
      ((_ ((p e0) ...) e1 e2 ...)
       #'(syntax-case (list e0 ...) ()
           ((p ...) (let () e1 e2 ...)))))))

(define (syntax-violation who message . form*)
  (apply error message form*))

(define-syntax define-current-ellipsis
  (lambda (stx)
    (syntax-case stx ()
      ((_ ellipsis)
       (let ((mac (cdr (env-cell (current-usage-environment) current-ellipsis-id))))
         (macro-aux-set! mac #'ellipsis))
       #'(begin)))))

(define-syntax with-ellipsis
  (lambda (stx)
    (syntax-case stx ()
      ((_ ellipsis . body)
       (with-syntax ((current-ellipsis current-ellipsis-id))
         #'(let-syntax ((current-ellipsis (syntax-rules ())))
             (define-current-ellipsis ellipsis)
             . body))))))

;; Local variables:
;; eval: (put '%define-syntax 'scheme-indent-function 1)
;; End:

;;> Define a new generic function named \var{name}.

(define-syntax define-generic
  (syntax-rules ()
    ((define-generic name)
     (define name (make-generic 'name)))))

;; call-next-method needs to be unhygienic
'(define-syntax define-method
  (syntax-rules ()
    ((define-method (name (param type) ...) . body)
     (generic-add! name
                   (list type ...)
                   (lambda (next param ...)
                     (let-syntax ((call))
                       . body))))))

;;> \macro{(define-method (name params ...) body ...)}

;;> Each parameter should be either a single identifier or a list of the form
;;> \scheme{(param type)} where \var{param} is the parameter name and
;;> \var{type} is a predicate which returns true if it's argument is of the
;;> correct type.
;;> Parameters without a predicate will always match.

;;> If multiple methods satisfy the arguments, the most recent method
;;> will be used.  The special form \scheme{(call-next-method)} can be
;;> invoked to call the next most recent method with the same arguments.

(define-syntax define-method
  (er-macro-transformer
   (lambda (e r c)
     (let ((name (car (cadr e)))
           (params (map (lambda (param)
                          (if (identifier? param)
                              `(,param (lambda _ #t))
                              param))
                        (cdr (cadr e))))
           (body (cddr e)))
       `(,(r 'generic-add!) ,name
         (,(r 'list) ,@(map cadr params))
         (,(r 'lambda) (,(r 'next) ,@(map car params))
          (,(r 'let-syntax) ((call-next-method
                              (,(r 'syntax-rules) ()
                               ((_) (,(r 'next))))))
           ,@body)))))))

(define (no-applicable-method-error name args)
  (error "no applicable method" name args))

(define (satisfied? preds args)
  (cond ((null? preds) (null? args))
        ((null? args) #f)
        (((car preds) (car args)) (satisfied? (cdr preds) (cdr args)))
        (else #f)))

(define add-method-tag (list 'add-method-tag))

;;> Create a new first-class generic function named \var{name}.

(define (make-generic name)
  (let ((name name)
        (methods (make-vector 6 '())))
    (vector-set! methods
                 3
                 (list (cons (list (lambda (x) (eq? x add-method-tag))
                                   (lambda (x) (list? x))
                                   procedure?)
                             (lambda (next t p f)
                               (set! methods (insert-method! methods p f))))))
    (lambda args
      (let ((len (length args)))
        (cond
         ((>= len (vector-length methods))
          (no-applicable-method-error name args))
         (else
          (let lp ((ls (vector-ref methods len)))
            (cond
             ((null? ls)
              (no-applicable-method-error name args))
             ((satisfied? (car (car ls)) args)
              (apply (cdr (car ls)) (lambda () (lp (cdr ls))) args))
             (else
              (lp (cdr ls)))))))))))

(define (insert-method! vec preds f)
  (let ((vlen (vector-length vec))
        (plen (length preds)))
    (let ((res (if (>= plen vlen)
                   (let ((r (make-vector (+ vlen 1) '())))
                     (do ((i 0 (+ i 1)))
                         ((>= i vlen) r)
                       (vector-set! r i (vector-ref vec i))))
                   vec)))
      (vector-set! res plen (cons (cons preds f) (vector-ref res plen)))
      res)))

;;> Extend the generic \var{g} with a new method \var{f}
;;> that applies when all parameters match the given list
;;> of predicates \var{preds}.

(define (generic-add! g preds f)
  (g add-method-tag preds f))

(define-library (chibi shell-test)
  (import (scheme base) (chibi shell) (chibi test))
  (export run-tests)
  (begin
    (define (run-tests)
      (test-begin "(chibi shell)")
      (test "hello\n"
          (shell->string (echo "hello")))
      (test "world\n"
          (shell->string (echo "world")))
      (test "HELLO\n"
          (shell->string
           ,(shell-pipe
             '(echo "hello")
             '(tr "a-z" "A-Z"))))
      (test "OLLEH\n"
          (shell->string
           ,(shell-pipe
             '(echo "hello")
             '(tr "a-z" "A-Z")
             'rev)))
      (test "OLLEH\n"
          (shell->string (echo "hello") (tr "a-z" "A-Z") rev))
      (test "pass\n"
          (shell->string ,(shell-if 'true '(echo "pass") '(echo "fail"))))
      (test "fail\n"
          (shell->string ,(shell-if 'false '(echo "pass") '(echo "fail"))))
      (test "hello\nworld\n"
          (shell->string ,(shell-do '(echo "hello") '(echo "world"))))
      (test "hello\n"
          (shell->string
           ,(shell-and 'true '(echo "hello") 'false '(echo "world"))))
      (test "hello\n"
          (shell->string
           ,(shell-or 'false '(echo "hello") '(echo "world"))))
      (test "hello\n"
          (shell->string (or false (echo "hello") (echo "world"))))
      (test '("hello" "world")
          (shell->string-list (do (echo "hello") (echo "world"))))
      (test '(hello world)
          (shell->sexp-list (do (echo "hello") (echo "world"))))
      (test "HELLO"
          (shell->string (cat) (<< hello) (tr "a-z" "A-Z")))
      (test "HELLO"
          (shell->string (>< (cat) (tr "a-z" "A-Z")) (<< hello)))
      (test-end))))
;; io.scm -- various input/output utilities
;; Copyright (c) 2010-2012 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; utilities

(define eof
  (call-with-input-string " "
    (lambda (in) (read-char in) (read-char in))))

;; Copy whole characters from the given cursor positions.
;; Return the src cursor position of the next unwritten char,
;; which may be before `to' if the char would overflow.
;; Now provided as a primitive from (chibi ast).
;; (define (string-cursor-copy! dst start src from to)
;;   (let lp ((i from)
;;            (j (string-cursor->index dst start)))
;;     (let ((i2 (string-cursor-next src i)))
;;       (cond ((> i2 to) i)
;;             (else
;;              (string-set! dst j (string-cursor-ref src i))
;;              (lp i2 (+ j 1)))))))

(define (utf8->string vec . o)
  (if (pair? o)
      (let ((start (car o))
            (end (if (pair? (cdr o)) (cadr o) (bytevector-length vec))))
        (utf8->string (subbytes vec start end)))
      (string-copy (utf8->string! vec))))

(define (string->utf8 str . o)
  (if (pair? o)
      (let ((start (car o))
            (end (if (pair? (cdr o)) (cadr o) (string-length str))))
        (string->utf8 (substring str start end)))
      (%string->utf8 str)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; reading and writing

;; Display \var{str} to the given output port, defaulting to
;; \scheme{(current-output-port)}, followed by a newline.

(define (write-line str . o)
  (let ((out (if (pair? o) (car o) (current-output-port))))
    (display str out)
    (newline out)))

;;> \procedure{(write-string str [out [start [end]]])}

;;> Writes the characters from \var{start} to \var{end} of string
;;> \var{str} to output port \var{out}, where \var{start} defaults
;;> to 0 and \var{end} defaults to \scheme{(string-length \var{str})}.

(define (write-string str . o)
  (let ((out (if (pair? o) (car o) (current-output-port)))
        (o (if (pair? o) (cdr o) o)))
    (if (pair? o)
        (let ((start (car o))
              (end (if (pair? (cdr o)) (cadr o) (string-length str))))
          (cond-expand
           (string-streams
            (if (zero? start)
                (%write-string str end out)
                (display (substring str start end) out)))
           (else
            (display (substring str start end) out))))
        (display str out))))

;;> \procedure{(read-line [in [n]])}

;;> Read a line from the input port \var{in}, defaulting to
;;> \scheme{(current-input-port)}, and return the result as
;;> a string not including the newline.  Reads at most \var{n}
;;> characters, defaulting to 8192.

(define (%read-line n in)
  (cond
   ((stream-port? in) ;;(port-fileno in)
    (port-line-set! in (+ 1 (port-line in)))
    (%%read-line n in))
   (else
    (let ((out (open-output-string)))
      (let lp ((i 0))
        (let ((ch (peek-char in)))
          (cond
           ((eof-object? ch)
            (let ((res (get-output-string out)))
              (and (not (equal? res "")) res)))
           ((eqv? ch #\newline)
            (read-char in)
            (get-output-string out))
           ((eqv? ch #\return)
            (read-char in)
            (if (eqv? #\newline (peek-char in))
                (read-char in))
            (get-output-string out))
           ((>= i n)
            (get-output-string out))
           (else
            (write-char (read-char in) out)
            (lp (+ i 1))))))))))

(define (read-line . o)
  (let ((in (if (pair? o) (car o) (current-input-port)))
        (n (if (and (pair? o) (pair? (cdr o))) (car (cdr o)) 8192)))
    (let ((res (%read-line n in)))
      (if (not res)
          eof
          (let ((len (string-length res)))
            (cond  ;; strip crlf
             ((and (> len 0) (eqv? #\newline (string-ref res (- len 1))))
              (if (and (> len 1) (eqv? #\return (string-ref res (- len 2))))
                  (substring res 0 (- len 2))
                  (substring res 0 (- len 1))))
             ((and (> len 0) (eqv? #\return (string-ref res (- len 1))))
              (substring res 0 (- len 1)))
             (else
              res)))))))

;;> \procedure{(read-string n [in])}

;;> Reads \var{n} characters from input-port \var{in},
;;> defaulting to \scheme{(current-input-port)}, and
;;> returns the result as a string.  Returns \scheme{""}
;;> if \var{n} is zero.  May return a string with fewer
;;> than \var{n} characters if the end of file is reached,
;;> or the eof-object if no characters are available.

(define (%read-string n in)
  (cond
   ;;((port-fileno in)
   ;; (%%read-string n in))
   (else
    (let ((out (open-output-string)))
      (let lp ((i 0))
        (cond ((or (= i n) (eof-object? (peek-char in)))
               (list i (get-output-string out)))
              (else (write-char (read-char in) out) (lp (+ i 1)))))))))

(define (read-string n . o)
  (if (zero? n)
      ""
      (let ((in (if (pair? o) (car o) (current-input-port))))
        (let ((res (%read-string n in)))
          (cond
           ((if (pair? res) (= 0 (car res)) #t)
            eof)
           (else
            (port-line-set! in (+ (string-count-chars #\newline (cadr res) 0)
                                  (port-line in)))
            (cadr res)))))))

;;> \procedure{(read-string! str n [in])}

;;> Reads \var{n} characters from port \var{in}, which
;;> defaults to \scheme{(current-input-port)}, and writes
;;> them into the string \var{str} starting at index 0.
;;> Returns the number of characters read.
;;> An error is signalled if the length of \var{str} is smaller
;;> than \var{n}.

(define (%read-string! str n in)
  (cond
   ;;((port-fileno in)
   ;; (%%read-string! str n in))
   (else
    (let lp ((i 0))
      (cond ((or (= i n) (eof-object? (peek-char in))) i)
            (else (string-set! str i (read-char in)) (lp (+ i 1))))))))

(define (read-string! str n . o)
  (if (> n (string-length str))
      (error "string to small to read chars" str n))
  (let* ((in (if (pair? o) (car o) (current-input-port)))
         (res (%read-string! str n in)))
    (port-line-set! in (+ (string-count-chars #\newline str 0 n) (port-line in)))
    res))

;;> Sends the entire contents of a file or input port to an output port.

(define (send-file fd-port-or-filename . o)
  (let* ((in (if (string? fd-port-or-filename)
                 (open-input-file fd-port-or-filename)
                 fd-port-or-filename))
         (out (if (pair? o) (car o) (current-output-port)))
         (fd (if (port? in) (port-fileno in) in))
         (sock (if (port? out) (port-fileno out) out)))
    (define (copy-bytes)
      (let ((b (read-u8 in)))
        (cond ((not (eof-object? b))
               (write-u8 b out)
               (copy-bytes)))))
    (if (and fd sock (is-a-socket? sock))
        (let lp ((start 0))
          (let ((res (%send-file fd sock start)))
            (cond
             ((not res) (copy-bytes))
             ((not (zero? res)) (lp (+ start res))))))
        (copy-bytes))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; higher order port operations

;;> The fundamental port iterator.

(define (port-fold kons knil . o)
  (let ((read (if (pair? o) (car o) read))
        (in (if (and (pair? o) (pair? (cdr o)))
                (car (cdr o))
                (current-input-port))))
    (let lp ((acc knil))
      (let ((x (read in)))
        (if (eof-object? x) acc (lp (kons x acc)))))))

(define (port-fold-right kons knil . o)
  (let ((read (if (pair? o) (car o) read))
        (in (if (and (pair? o) (pair? (cdr o)))
                (car (cdr o))
                (current-input-port))))
    (let lp ()
      (let ((x (read in)))
        (if (eof-object? x) knil (kons x (lp)))))))

(define (port-map fn . o)
  (reverse (apply port-fold (lambda (x ls) (cons (fn x) ls)) '() o)))

(define (port->list read in)
  (port-map (lambda (x) x) read in))

(define (port->sexp-list in)
  (port->list read in))

(define (port->string-list in)
  (port->list read-line in))

(define (port->string in)
  (string-concatenate (port->list (lambda (in) (read-string 1024 in)) in)))

(define (port->bytevector in)
  (let ((out (open-output-bytevector)))
    (do ((c (read-u8 in) (read-u8 in)))
        ((eof-object? c) (get-output-bytevector out))
      (write-u8 c out))))

(define (file->string path)
  (call-with-input-file path port->string))

(define (file->bytevector path)
  (call-with-input-file path port->bytevector))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; custom port utilities

;;> \var{read} is a procedure of three arguments:
;;> \scheme{(lambda (str start end) ...)} which should fill \var{str} from
;;> \var{start} to \var{end} with bytes, returning the actual number
;;> of bytes filled.

(define (make-custom-input-port read . o)
  (let ((seek (and (pair? o) (car o)))
        (close (and (pair? o) (pair? (cdr o)) (car (cdr o)))))
    (%make-custom-input-port read seek close)))

;;> \var{write} is a procedure of three arguments:
;;> \scheme{(lambda (str start end) ...)} which should write the bytes of
;;> \var{str} from \var{start} to \var{end}, returning the actual
;;> number of bytes written.

(define (make-custom-output-port write . o)
  (let ((seek (and (pair? o) (car o)))
        (close (and (pair? o) (pair? (cdr o)) (car (cdr o)))))
    (%make-custom-output-port write seek close)))

;;> Similar to \scheme{make-custom-input-port} but returns a binary
;;> port, and \var{read} receives a bytevector to fill instead of a
;;> string.

(define (make-custom-binary-input-port read . o)
  (let ((seek (and (pair? o) (car o)))
        (close (and (pair? o) (pair? (cdr o)) (car (cdr o)))))
    (%make-custom-binary-input-port read seek close)))

;;> Similar to \scheme{make-custom-output-port} but returns a binary
;;> port, and \var{write} receives data from a bytevector instead of a
;;> string.

(define (make-custom-binary-output-port write . o)
  (let ((seek (and (pair? o) (car o)))
        (close (and (pair? o) (pair? (cdr o)) (car (cdr o)))))
    (%make-custom-binary-output-port write seek close)))

;;> A simple /dev/null port which accepts and does nothing with any
;;> data written to it.

(define (make-null-output-port)
  (make-custom-output-port (lambda (str start end) 0)))

;;> A port to broadcast everything written to it to multiple output
;;> ports.

(define (make-broadcast-port . ports)
  (make-custom-output-port
   (lambda (str start end)
     (let ((str (if (zero? start) str (substring str start)))
           (n (- end start)))
       (for-each (lambda (p) (%write-string str n p)) ports)
       n))))

;;> An output port which runs all output (in arbitrary string chunks)
;;> through the \var{filter} procedure.

(define (make-filtered-output-port filter out)
  (make-custom-output-port
   (lambda (str start end)
     (let* ((len (string-length str))
            (s1 (if (and (zero? start) (= end len)) str (substring str start end)))
            (s2 (filter s1)))
       (if (string? s2)
           (%write-string s2 (string-length s2) out))))))

;;> An input port which acts as all of the \var{ports} concatenated
;;> together in order.

(define (make-concatenated-port . ports)
  (make-custom-input-port
   (lambda (str start end)
     (if (null? ports)
         0
         (let ((str (if (zero? start) str (substring str start)))
               (n (- end start)))
           (let lp ((i (read-string! str n (car ports))))
             (cond
              ((>= i n)
               i)
              (else
               (set! ports (cdr ports))
               (cond
                ((null? ports)
                 i)
                (else
                 (let* ((s (read-string (- n i) (car ports)))
                        (len (if (string? s) (string-length s) 0)))
                   (if (and (string? str) (> len 0))
                       (string-cursor-copy! str i s 0 len))
                   (lp (+ i len)))))))))))))

;;> A /dev/null input port which always returns \scheme{eof-object}.

(define (make-null-input-port)
  (make-concatenated-port))

;;> A utility to represent a port generated in chunks by the thunk
;;> \var{generator}, which should return a single string representing
;;> the next input to buffer, or \scheme{#f} when there is no more
;;> input.

(define (make-generated-input-port generator)
  (let ((buf "")
        (len 0)
        (offset 0))
    (make-custom-input-port
     (lambda (str start end)
       (let ((n (- end start)))
         (cond
          ((>= (- len offset) n)
           ;; buf contains enough to fill str
           (let* ((offset2
                   (string-cursor-copy! str start buf offset (+ offset n)))
                  (end2 (+ (- offset2 offset) start)))
             (set! offset offset2)
             end2))
          (else
           ;; copy the rest of buf into str
           (string-cursor-copy! str start buf offset len)
           ;; i is the position to copy into str, from start to end
           (let lp ((i (+ start (- len offset))))
             (set! buf (generator))
             (cond
              ((not (string? buf))
               (set! buf "")
               (set! len 0)
               (set! offset 0)
               i)
              (else
               (set! len (string-size buf))
               (cond
                ((>= len (- n i))
                 (let* ((offset2 (string-cursor-copy! str i buf 0 (- n i)))
                        (end2 (+ i offset2)))
                   (set! offset offset2)
                   end2))
                (else
                 (let ((offset2 (string-cursor-copy! str i buf 0 len)))
                   (lp (+ i offset2)))))))))))))))

(define (%bytevector-copy! to at from start end) ; simplified
  (do ((i at (+ i 1)) (j start (+ j 1)))
      ((>= j end))
    (bytevector-u8-set! to i (bytevector-u8-ref from j))))

;;> Equivalent to \scheme{make-generated-input-port}, but produces a
;;> binary port, and \var{generator} should return a bytevector or
;;> \scheme{#f} when there is no more input.

(define (make-generated-binary-input-port generator)
  (let ((buf #u8())
        (len 0)
        (offset 0))
    (make-custom-binary-input-port
     (lambda (bv start end)
       (let ((n (- end start)))
         (cond
          ((>= (- len offset) n)
           (%bytevector-copy! bv start buf offset (+ offset n))
           (set! offset (+ offset n))
           (+ start n))
          (else
           (%bytevector-copy! bv start buf offset len)
           (let lp ((i (+ start (- len offset))))
             (set! buf (generator))
             (set! offset 0)
             (cond
              ((not (bytevector? buf))
               (set! buf #u8())
               (set! len 0)
               i)
              (else
               (set! len (bytevector-length buf))
               (cond
                ((>= len (- n i))
                 (%bytevector-copy! bv i buf 0 (- n i))
                 (set! offset (- n i))
                 n)
                (else
                 (%bytevector-copy! bv i buf 0 len)
                 (lp (+ i len))))))))))))))

;;> An input port which runs all input (in arbitrary string chunks)
;;> through the \var{filter} procedure.

(define (make-filtered-input-port filter in)
  (make-generated-input-port
   (lambda ()
     (let ((res (read-string 1024 in)))
       (if (string? res) (filter res) res)))))

(define-library (chibi mime)
  (export assq-ref mime-header-fold mime-headers->list
          mime-parse-content-type mime-decode-header
          mime-message-fold mime-message->sxml mime-write-headers
          mime-type-from-extension)
  (import (scheme base) (scheme char) (scheme write)
          (chibi base64) (chibi quoted-printable)
          (chibi string))
  (include "mime.scm"))
(define-library (chibi regexp-test)
  (export run-tests)
  (import (scheme base) (scheme char) (scheme file) (scheme write)
          (chibi regexp) (chibi regexp pcre)
          (chibi string) (chibi match) (chibi test))
  (begin
    (define (run-tests)
      (define (maybe-match->sexp rx str . o)
        (let ((res (apply regexp-matches rx str o)))
          (and res (regexp-match->sexp res))))

      (define-syntax test-re
        (syntax-rules ()
          ((test-re res rx str start end)
           (test res (maybe-match->sexp rx str start end)))
          ((test-re res rx str start)
           (test-re res rx str start (string-length str)))
          ((test-re res rx str)
           (test-re res rx str 0))))

      (define (maybe-search->sexp rx str . o)
        (let ((res (apply regexp-search rx str o)))
          (and res (regexp-match->sexp res))))

      (define-syntax test-re-search
        (syntax-rules ()
          ((test-re-search res rx str start end)
           (test res (maybe-search->sexp rx str start end)))
          ((test-re-search res rx str start)
           (test-re-search res rx str start (string-length str)))
          ((test-re-search res rx str)
           (test-re-search res rx str 0))))

      (test-begin "regexp")

      (test-re '("ababc" "abab")
               '(: ($ (* "ab")) "c")
               "ababc")

      (test-re '("ababc" "abab")
               '(: ($ (* "ab")) "c")
               "xababc"
               1)

      (test-re-search '("y") '(: "y") "xy")

      (test-re-search '("ababc" "abab")
                      '(: ($ (* "ab")) "c")
                      "xababc")

      (test-re #f
               '(: (* any) ($ "foo" (* any)) ($ "bar" (* any)))
               "fooxbafba")

      (test-re '("fooxbarfbar" "fooxbarf" "bar")
               '(: (* any) ($ "foo" (* any)) ($ "bar" (* any)))
               "fooxbarfbar")

      (test-re '("abcd" "abcd")
               '($ (* (or "ab" "cd")))
               "abcd")

      ;; first match is a list of ab's, second match is the last (temporary) cd
      (test-re '("abcdc" (("ab") ("cd")) "cd")
               '(: (* (*$ (or "ab" "cd"))) "c")
               "abcdc")

      (test "ab"
          (regexp-match-submatch
           (regexp-matches '(or (-> foo "ab") (-> foo "cd")) "ab")
           'foo))

      (test "cd"
          (regexp-match-submatch
           (regexp-matches '(or (-> foo "ab") (-> foo "cd")) "cd")
           'foo))

      ;; non-deterministic case from issue #229
      (let* ((elapsed '(: (** 1 2 num) ":" num num (? ":" num num)))
             (span (rx ,elapsed "-" ,elapsed)))
        (test-re-search '("1:45:02-2:06:13") span " 1:45:02-2:06:13 "))

      (test-re '("ababc" "abab")
               '(: bos ($ (* "ab")) "c")
               "ababc")
      (test-re '("ababc" "abab")
               '(: ($ (* "ab")) "c" eos)
               "ababc")
      (test-re '("ababc" "abab")
               '(: bos ($ (* "ab")) "c" eos)
               "ababc")
      (test-re #f
               '(: bos ($ (* "ab")) eos "c")
               "ababc")
      (test-re #f
               '(: ($ (* "ab")) bos "c" eos)
               "ababc")

      (test-re '("ababc" "abab")
               '(: bol ($ (* "ab")) "c")
               "ababc")
      (test-re '("ababc" "abab")
               '(: ($ (* "ab")) "c" eol)
               "ababc")
      (test-re '("ababc" "abab")
               '(: bol ($ (* "ab")) "c" eol)
               "ababc")
      (test-re #f
               '(: bol ($ (* "ab")) eol "c")
               "ababc")
      (test-re #f
               '(: ($ (* "ab")) bol "c" eol)
               "ababc")
      (test-re '("\nabc\n" "abc")
               '(: (* #\newline) bol ($ (* alpha)) eol (* #\newline))
               "\nabc\n")
      (test-re #f
               '(: (* #\newline) bol ($ (* alpha)) eol (* #\newline))
               "\n'abc\n")
      (test-re #f
               '(: (* #\newline) bol ($ (* alpha)) eol (* #\newline))
               "\nabc.\n")

      (test-re '("ababc" "abab")
               '(: bow ($ (* "ab")) "c")
               "ababc")
      (test-re '("ababc" "abab")
               '(: ($ (* "ab")) "c" eow)
               "ababc")
      (test-re '("ababc" "abab")
               '(: bow ($ (* "ab")) "c" eow)
               "ababc")
      (test-re #f
               '(: bow ($ (* "ab")) eow "c")
               "ababc")
      (test-re #f
               '(: ($ (* "ab")) bow "c" eow)
               "ababc")
      (test-re '("  abc  " "abc")
               '(: (* space) bow ($ (* alpha)) eow (* space))
               "  abc  ")
      (test-re #f
               '(: (* space) bow ($ (* alpha)) eow (* space))
               " 'abc  ")
      (test-re #f
               '(: (* space) bow ($ (* alpha)) eow (* space))
               " abc.  ")
      (test-re '("abc  " "abc")
               '(: ($ (* alpha)) (* any))
               "abc  ")
      (test-re '("abc  " "")
               '(: ($ (*? alpha)) (* any))
               "abc  ")
      (test-re '("<em>Hello World</em>" "em>Hello World</em")
               '(: "<" ($ (* any)) ">" (* any))
               "<em>Hello World</em>")
      (test-re '("<em>Hello World</em>" "em")
               '(: "<" ($ (*? any)) ">" (* any))
               "<em>Hello World</em>")
      (test-re-search '("foo") '(: "foo") " foo ")
      (test-re-search #f '(: nwb "foo" nwb) " foo ")
      (test-re-search '("foo") '(: nwb "foo" nwb) "xfoox")

      (test-re '("beef")
               '(* (/"af"))
               "beef")

      (test-re '("12345beef" "beef")
               '(: (* digit) ($ (* (/"af"))))
               "12345beef")

      (let ((number '($ (+ digit))))
        (test '("555" "867" "5309")
            (cdr
             (regexp-match->list
              (regexp-search `(: ,number "-" ,number "-" ,number)
                             "555-867-5309"))))
        (test '("555" "5309")
            (cdr
             (regexp-match->list
              (regexp-search `(: ,number "-" (w/nocapture ,number) "-" ,number)
                             "555-867-5309")))))

      (test-re '("12345BeeF" "BeeF")
               '(: (* digit) (w/nocase ($ (* (/"af")))))
               "12345BeeF")

      (test-re #f '(* lower) "abcD")
      (test-re '("abcD") '(w/nocase (* lower)) "abcD")
      (test-re '("") '(* lower) "")
      (test-re '("") '(* upper) "")
      (test-re '("\x01C5;") '(* title) "\x01C5;")
      (test-re '("\x01C5;") '(w/nocase (* lower)) "\x01C5;")

      (test-re '("") '(* alpha) "")
      (test-re #f '(w/ascii (* alpha)) "")
      (test-re '("") '(w/nocase "") "")

      (test-re '("") '(* digit) "")
      (test-re #f '(w/ascii (* digit)) "")

      (test-re '("") 'grapheme "")
      (test-re '("") 'grapheme "")

      (test-re '("") '(: bog grapheme eog) "")
      (test-re #f '(: "" bog grapheme eog "") "")

      (test '("a" "b" "c") (regexp-extract 'grapheme "abc"))
      (test '("a" " " "b" " " "c") (regexp-extract 'grapheme "a b c"))
      (test '("a" "\n" "b" "\r\n" "c") (regexp-extract 'grapheme "a\nb\r\nc"))
      (test '("a\x0300;" "b\x0301;\x0302;" "c\x0303;\x0304;\x0305;")
          (regexp-extract 'grapheme "a\x0300;b\x0301;\x0302;c\x0303;\x0304;\x0305;"))
      (test '("" "") (regexp-extract 'grapheme ""))

      (test '("123" "456" "789") (regexp-extract '(+ digit) "abc123def456ghi789"))
      (test '("123" "456" "789") (regexp-extract '(* digit) "abc123def456ghi789"))
      (test '("abc" "def" "ghi" "") (regexp-split '(+ digit) "abc123def456ghi789"))
      (test '("abc" "def" "ghi" "")
          (regexp-split '(* digit) "abc123def456ghi789"))
      (test '("a" "b") (regexp-split '(+ whitespace) "a b"))
      (test '("a" "" "b")
          (regexp-split '(",;") "a,,b"))
      (test '("a" "" "b" "")
          (regexp-split '(",;") "a,,b,"))
      (test '("")
          (regexp-partition '(* digit) ""))
      (test '("abc" "123" "def" "456" "ghi")
          (regexp-partition '(* digit) "abc123def456ghi"))
      (test '("abc" "123" "def" "456" "ghi" "789")
          (regexp-partition '(* digit) "abc123def456ghi789"))

      (test '("" "")
          (regexp-extract
           'grapheme
           (utf8->string '#u8(#xe1 #x84 #x92 #xe1 #x85 #xa1 #xe1 #x86 #xab
                                   #xe1 #x84 #x80 #xe1 #x85 #xb3 #xe1 #x86 #xaf))))

      (test "abc def" (regexp-replace '(+ space) "abc \t\n def" " "))
      (test "  abc-abc"
          (regexp-replace '(: ($ (+ alpha)) ":" (* space)) "  abc: " '(1 "-" 1)))
      (test "  abc-  abc"
          (regexp-replace '(: ($ (+ alpha)) ":" (* space)) "  abc: " '(1 "-" pre 1)))

      (test "-abc \t\n d ef  "
          (regexp-replace '(+ space) "  abc \t\n d ef  " "-" 0))
      (test "-abc \t\n d ef  "
          (regexp-replace '(+ space) "  abc \t\n d ef  " "-" 0 #f 0))
      (test "  abc-d ef  "
          (regexp-replace '(+ space) "  abc \t\n d ef  " "-" 0 #f 1))
      (test "  abc \t\n d-ef  "
          (regexp-replace '(+ space) "  abc \t\n d ef  " "-" 0 #f 2))
      (test "  abc \t\n d ef-"
          (regexp-replace '(+ space) "  abc \t\n d ef  " "-" 0 #f 3))
      (test "  abc \t\n d ef  "
          (regexp-replace '(+ space) "  abc \t\n d ef  " "-" 0 #f 4))
      (test " abc d ef " (regexp-replace-all '(+ space) "  abc \t\n d ef  " " "))

      (test "bc pre: <<<bc >>> match1: <<<def>>> post: <<<gh>>>gh"
          (regexp-replace
           '(: ($ (+ alpha)) ":" (* space))
           "abc def: ghi"
           '("pre: <<<" pre ">>> match1: <<<" 1 ">>> post: <<<" post ">>>")
           1 11))

      (let ()
        (define (subst-matches matches input subst)
          (define (submatch n)
            (regexp-match-submatch matches n))
          (and
           matches
           (call-with-output-string
             (lambda (out)
               (call-with-input-string subst
                 (lambda (in)
                   (let lp ()
                     (let ((c (read-char in)))
                       (cond
                        ((not (eof-object? c))
                         (case c
                           ((#\&)
                            (display (or (submatch 0) "") out))
                           ((#\\)
                            (let ((c (read-char in)))
                              (if (char-numeric? c)
                                  (let lp ((res (list c)))
                                    (if (and (char? (peek-char in))
                                             (char-numeric? (peek-char in)))
                                        (lp (cons (read-char in) res))
                                        (display
                                         (or (submatch (string->number
                                                        (list->string (reverse res))))
                                             "")
                                         out)))
                                  (write-char c out))))
                           (else
                            (write-char c out)))
                         (lp)))))))))))

        (define (test-pcre line)
          (match (string-split line #\tab)
            ((pattern input result subst output)
             (let ((name (string-append pattern " " input " " result " " subst)))
               (cond
                ((equal? "c" result)
                 (test-error name (regexp-search (pcre->sre pattern) input)))
                ((equal? "n" result)
                 (test-assert name (not (regexp-search (pcre->sre pattern) input))))
                (else
                 (test name output
                   (subst-matches (regexp-search (pcre->sre pattern) input)
                                  input
                                  subst))))))
            (else
             (error "invalid regex test line" line))))

        (test-group "pcre"
          (let ((in (open-input-file "tests/re-tests.txt")))
            (let lp ()
              (let ((line (read-line in)))
                (unless (eof-object? line)
                  (test-pcre line)
                  (lp)))))))

      (test-end))))

;;> Utilities to convert sxml to xml or plain text.

(define-library (chibi sxml)
  (export sxml->xml sxml-display-as-html sxml-display-as-text sxml-strip
          html-escape html-tag->string)
  (import (scheme base) (scheme write))
  (include "sxml.scm"))
;; config.scm -- general configuration management
;; Copyright (c) 2012 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

;;> This is a library for unified configuration management.
;;> Essentially it provides an abstract collection data type for
;;> looking up named values, two or more of which can be chained
;;> together.  Values from more recent collections can be preferred as
;;> with an environment, or the values at multiple levels can be
;;> flattened together.  Convenience routines are provided from
;;> loading these collections from files while allowing extensions
;;> such as configurations from command-line options.

;;> \section{Background}
;;>
;;> As any application grows to sufficient complexity, it acquires
;;> options and behaviors that one may want to modify at startup or
;;> runtime.  The traditional approach is a combination of
;;> command-line options, config files, environment variables, and/or
;;> other specialized settings.  These all have various pros and cons:
;;>
;;> \table[(@ (border 1) (style border-collapse:collapse) (width "100%"))]{
;;> \tr{\th{name} \th{pros} \th{cons}}
;;> \tr{\td{environment variables}
;;>     \td{implicit - no need to retype; can share between applications}
;;>     \td{unclear when set; unexpected differences between users; limited size}}
;;> \tr{\td{command-line options}
;;>     \td{explicit - visible each time a command is run; }
;;>     \td{verbose; limited size}}
;;> \tr{\td{config files}
;;>     \td{implicit; preserved - can be shared and version controlled}
;;>     \td{requires a parser}}
;;> }
;;>
;;> Environment variables are convenient for broad preferences, used
;;> by many different applications, and unlikely to change per user.
;;> Command-line options are best for settings that are likely to
;;> change between invocations of a program.  Anything else is best
;;> stored in a config file.  If there are settings that multiple
;;> users of a group or whole system are likely to want to share, then
;;> it makes sense to cascade multiple config files.

;;> \section{Syntax}
;;>
;;> With any other language there is a question of config file syntax,
;;> and a few popular choices exist such as .ini syntax.  With Scheme
;;> the obvious choice is sexps, generally as an alist.  We use a
;;> single alist for the whole file, with symbols for keys and
;;> arbitrary sexps for values.  The alists are intended primarily for
;;> editing by hand and need not be dotted, but the interface allows
;;> dotted values.  Disambiguation is handled as with two separate
;;> functions, \scheme{(conf-get config key)} and
;;> \scheme{(conf-get-list config key)}, which both retrieve the value
;;> associated with \var{key} from \var{config}, in the latter case
;;> coercing to a list.  The result is determined according to the
;;> structure of the alist cell as follows:
;;>
;;> \table[(@ (border 1) (style border-collapse:collapse) (width "100%"))]{
;;> \tr{\th{Cell} \th{\scheme{conf-get} result} \th{\scheme{conf-get-list} result}}
;;> \tr{\td{\scheme{(key)}} \td{\scheme{()}} \td{\scheme{()}}}
;;> \tr{\td{\scheme{(key . non-list-value)}} \td{\scheme{non-list-value}} \td{\scheme{(non-list-value)}}}
;;> \tr{\td{\scheme{(key non-list-value)}} \td{\scheme{non-list-value}} \td{\scheme{(non-list-value)}}}
;;> \tr{\td{\scheme{(key (value1 value2 ...))}} \td{\scheme{(value1 value2 ...)}} \td{\scheme{(value1 value2 ...)}}}
;;> \tr{\td{\scheme{(key value1 value2 ...)}} \td{\scheme{(value1 value2 ...)}} \td{\scheme{(value1 value2 ...)}}}
;;> }
;;>
;;> Thus writing the non-dotted value will always do what you want.
;;> Specifically, the only thing to be careful of is if you want a
;;> single-element list value, even with \scheme{conf-get}, you should
;;> write \scheme{(key (value))}.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;> \section{Interface}

;;> Returns true iff \var{x} is a config object.

(define-record-type Config
  (%make-conf alist parent source timestamp)
  conf?
  (alist conf-alist conf-alist-set!)
  (parent conf-parent conf-parent-set!)
  (source conf-source conf-source-set!)
  (timestamp conf-timestamp conf-timestamp-set!))

(define (make-conf alist parent source timestamp)
  (if (not (alist? alist))
      (error "config requires an alist" alist)
      (%make-conf alist parent source timestamp)))

(define (assq-tail key alist)
  (let lp ((ls alist))
    (and (pair? ls)
         (if (and (pair? (car ls)) (eq? key (caar ls)))
             ls
             (lp (cdr ls))))))

(define (assq-chain key alist)
  (let ((x (assq-tail (car key) alist)))
    (and x
         (if (null? (cdr key))
             (car x)
             (or (assq-chain (cdr key) (cdar x))
                 (assq-chain key (cdr x)))))))

(define (assq-split key alist)
  (let lp ((ls alist) (rev '()))
    (cond
     ((null? ls) #f)
     ((and (pair? (car ls)) (eq? key (caar ls))) (cons (reverse rev) ls))
     (else (lp (cdr ls) (cons (car ls) rev))))))

(define (read-from-file file . opt)
  (guard (exn
          (else
           (warn "couldn't load config:" file)
           (print-exception exn)
           (print-stack-trace exn)
           (and (pair? opt) (car opt))))
    (call-with-input-file file read)))

(define (alist? x)
  (and (list? x) (every pair? x)))

;;> \procedure{(assoc-get alist key [equal? [default]])}

;;> Utility analogous to \scheme{conf-get} on a pure alist.  Returns
;;> the value of the cell in \var{alist} whose car is \var{equal?} to
;;> \var{key}, where the value is determined as the \var{cadr} if the
;;> cell is a proper list of two elements and the \var{cdr} otherwise.
;;> If no cell is found, returns \var{default}, or \scheme{#f} if
;;> unspecified.

(define (assoc-get alist key . o)
  (let ((equal (or (and (pair? o) (car o)) equal?)))
    (let lp ((ls alist))
      (cond
       ((not (pair? ls)) (and (pair? o) (pair? (cdr o)) (cadr o)))
       ((and (pair? (car ls)) (equal key (caar ls)))
        (if (and (pair? (cdar ls)) (null? (cdr (cdar ls))))
            (car (cdar ls))
            (cdar ls)))
       (else (lp (cdr ls)))))))

;;> \procedure{(assoc-get-list alist key [default])}

;;> Equivalent to \scheme{assoc-get} but coerces its result to a list
;;> as described in the syntax section.

(define (assoc-get-list alist key . o)
  (let ((res (assoc-get alist key)))
    (if res
        (if (or (pair? res) (null? res)) res (list res))
        (if (pair? o) (car o) '()))))

;;> Returns just the base of \var{config} without any parent.

(define (conf-head config)
  (make-conf
   (conf-alist config) #f (conf-source config) (conf-timestamp config)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Loading from files.

;;> \procedure{(conf-load file [conf])}

;;> Loads the config file \var{file}, prepending to \var{conf} if
;;> provided.

(define (conf-load file . o)
  (make-conf
   (read-from-file file '())
   (and (pair? o) (car o))
   file
   (current-second)))

;;> Search for and load any files named \var{file} in the
;;> \var{config-path}, which should be a list of strings.

(define (conf-load-in-path config-path file)
  (cond
   ((equal? file "")
    (error "can't load from empty filename" file))
   ((eqv? #\/ (string-ref file 0))
    (conf-load file))
   (else
    (let lp ((ls (reverse config-path)) (res #f))
      (if (null? ls)
          (or res (make-conf '() #f #f (current-second)))
          (let ((path (string-append (car ls) "/" file)))
            (if (file-exists? path)
                (lp (cdr ls) (conf-load path res))
                (lp (cdr ls) res))))))))

;;> \procedure{(conf-load-cascaded config-path file [include-keyword])}

;;> Similar to conf-load-in-path, but also recursively loads any
;;> "include" config files, indicated by a top-level
;;> \var{include-keyword} with either a string or symbol value.
;;> Includes are loaded relative to the current file, and cycles
;;> automatically ignored.

(define (conf-load-cascaded config-path file . o)
  (define (path-directory file)
    (let lp ((i (string-length file)))
      (cond ((zero? i) "./")
            ((eqv? #\/ (string-ref file (- i 1))) (substring file 0 i))
            (else (lp (- i 1))))))
  (define (path-relative file from)
    (if (eqv? #\/ (string-ref file 0))
        file
        (string-append (path-directory from) file)))
  (let ((include-keyword (if (pair? o) (car o) 'include)))
    (let load ((ls (list (cons file (and (pair? o) (pair? (cdr o)) (cadr o)))))
               (seen '())
               (res '()))
      (cond
       ((null? ls)
        res)
       (else
        (let ((file (if (symbol? (caar ls))
                        (symbol->string (caar ls))
                        (caar ls)))
              (depth (cdar ls)))
          (cond
           ((member file seen)
            (load (cdr ls) seen res))
           ((and (number? depth) (<= depth 0))
            (load (cdr ls) seen res))
           (else
            (let* ((config (conf-load-in-path config-path file))
                   (includes (conf-get-list config include-keyword)))
              (load (append (cdr ls)
                            (map (lambda (x)
                                   (cons (path-relative x file)
                                         (and (number? depth) (- depth 1))))
                                 includes))
                    (cons file seen)
                    (append res config)))))))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define (conf-get-cell config key)
  (cond
   ((pair? key)
    (cond
     ((null? (cdr key)) (conf-get-cell config (car key)))
     ((assq-chain key (conf-alist config)))
     ((conf-parent config) => (lambda (p) (conf-get-cell p key)))
     (else #f)))
   (else
    (let search ((config config))
      (and config
           (or (assq key (conf-alist config))
               (search (conf-parent config))))))))

;;> \procedure{(conf-get config key [default])}

;;> Basic config lookup - retrieves the value from \var{config}
;;> associated with \var{key}.  If not present, return \var{default}.
;;> In \scheme{conf-get} and related accessors \var{key} can be either
;;> a symbol, or a list of symbols.  In the latter case, each symbol
;;> is used as a key in turn, with the value taken as an alist to
;;> further lookup values in.

(define (conf-get config key . opt)
  (let ((cell (conf-get-cell config key)))
    (if (not cell)
        (and (pair? opt) (car opt))
        (if (and (pair? (cdr cell)) (null? (cddr cell)))
            (cadr cell)
            (cdr cell)))))

;;> \procedure{(conf-get-list config key [default])}

;;> Equivalent to \scheme{conf-get} but coerces its result to a list
;;> as described in the syntax section.

(define (conf-get-list config key . opt)
  (let ((res (conf-get config key)))
    (if res
        (if (or (pair? res) (null? res)) res (list res))
        (if (pair? opt) (car opt) '()))))

;;> Equivalent to \scheme{conf-get} but always returns the
;;> \scheme{cdr} as-is without possibly taking its \scheme{car}.

(define (conf-get-cdr config key . opt)
  (let ((cell (conf-get-cell config key)))
    (if (not cell)
        (and (pair? opt) (car opt))
        (cdr cell))))

;;> Equivalent to \scheme{conf-get-list} but returns a list of all
;;> cascaded configs appended together.

(define (conf-get-multi config key)
  (if (not config)
      '()
      (append (conf-get-list (conf-head config) key)
              (conf-get-multi (conf-parent config) key))))

;;> Extends the config with anadditional alist.

(define (conf-extend config alist . o)
  (let ((source (and (pair? o) (car o))))
    (if (pair? alist)
        (make-conf alist config source (current-second))
        config)))

;;> Joins two configs.

(define (conf-append a b)
  (let ((parent (if (conf-parent a) (conf-append (conf-parent a) b) b)))
    (make-conf (conf-alist a) parent (conf-source a) (conf-timestamp a))))

;;> Utility to create an alist cell representing the chained key
;;> \var{key} mapped to \var{value}.

(define (conf-unfold-key key value)
  (if (null? (cdr key))
      (cons (car key) value)
      (list (car key) (conf-unfold-key (cdr key) value))))

;;> Replace a new definition into the first config alist.

(define (conf-set config key value)
  (make-conf
   (let lp ((key (if (not (list? key)) (list key) key))
            (alist (conf-alist config)))
     (cond
      ((null? (cdr key))
       (cons (cons (car key) value)
             (remove (lambda (x) (and (pair? x) (eq? (car key) (car x))))
                     alist)))
      ((assq-split (car key) alist)
       => (lambda (x)
            (let ((left (car x))
                  (right (cdr x)))
              (append left
                      (cons (cons (car key) (lp (cdr key) (cdar right)))
                            (cdr right))))))
      (else
       (cons (conf-unfold-key key value) alist))))
   (conf-parent config)
   (conf-source config)
   (conf-timestamp config)))

;;> Lift specialized sections to the top-level of a config.

(define (conf-specialize config key name)
  (let lp ((cfg config) (res '()))
    (if (not cfg)
        (make-conf (reverse res) config #f (current-second))
        (let* ((specialized (assq key (conf-alist cfg)))
               (named (and specialized (assq name (cdr specialized))))
               (next (conf-parent cfg)))
          (if named
              (lp next (cons (cdr named) res))
              (lp next res))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;> \section{Config Verification}

(define (conf-default-warn . args)
  (for-each
   (lambda (a) ((if (string? a) display write) a (current-error-port)))
   args)
  (newline (current-error-port))
  #f)

(define (conf-verify-symbol->predicate sym)
  (case sym
    ((integer) integer?)
    ((number) number?)
    ((list) list?)
    ((alist) alist?)
    ((boolean) boolean?)
    ((char) char?)
    ((string) string?)
    ((symbol) symbol?)
    ((pair) pair?)
    ((filename dirname) string?)
    (else (error "no known conf predicate for" sym))))

;; non-short-circuit versions to report all warnings

(define (and* . args)
  (every (lambda (x) x) args))

(define (every* pred ls)
  (apply and* (map pred ls)))

(define (conf-verify-match def cell warn)
  (define (cell-value)
    (if (and (pair? (cdr cell)) (null? (cddr cell))) (cadr cell) (cdr cell)))
  (define (cell-list)
    (if (and (pair? (cdr cell)) (null? (cddr cell)) (not (pair? (cadr cell))))
        (list (cadr cell))
        (cdr cell)))
  (cond
   ((procedure? def)
    (or (def (cell-value))
        (warn "bad conf value for " (car cell) ": " (cell-value))))
   ((symbol? def)
    (case def
      ((existing-filename)
       (cond
        ((not (string? (cell-value)))
         (warn "bad conf value for " (car cell)
               ": expected a filename but got " (cell-value)))
        ((not (file-exists? (cell-value)))
         (warn "conf setting ~S references a non-existent file: ~S"
               (car cell) (cell-value)))
        (else
         #t)))
      ((existing-dirname)
       (cond
        ((not (string? (cell-value)))
         (warn "bad conf value for " (car cell)
               ": expected a dirname but got " (cell-value)))
        ((not (file-directory? (cell-value)))
         (cond
          ((file-exists? (cell-value))
           (warn "conf setting " (car cell)
                 " expected a directory but found a file: " (cell-value)))
          (else
           (warn "conf setting " (car cell)
                 " references a non-existent directory: " (cell-value)))))
        (else
         #t)))
      ((integer number char string symbol filename dirname boolean pair)
       (or ((conf-verify-symbol->predicate def) (cell-value))
           (warn "bad conf value for " (car cell)
                 ": expected " def " but got " (cell-value))))
      ((list alist)
       (or ((conf-verify-symbol->predicate def) (cell-list))
           (warn "bad conf value for " (car cell)
                 ": expected " def " but got " (cell-list))))
      (else
       (warn "bad conf spec list: " def))))
   ((pair? def)
    (case (car def)
      ((cons)
       (and*
        (conf-verify-match
         (cadr def) (cons `(car ,(car cell)) (car (cell-list))) warn)
        (conf-verify-match
         (car (cddr def)) (cons `(car ,(car cell)) (cdr (cell-list))) warn)))
      ((list)
       (and (list? (cell-list))
            (every* (lambda (x)
                      ;; (cons `(list ,(car cell)) x)
                      (conf-verify-match (cadr def) x warn))
                    (cell-list))))
      ((alist)
       (let ((key-def (cadr def))
             (val-def (if (pair? (cddr def)) (car (cddr def)) (lambda (x) #t))))
         (and (alist? (cell-list))
              (every* (lambda (x)
                        (and (pair? x)
                             (conf-verify-match key-def (car x) warn)
                             (conf-verify-match val-def (cell-value) warn)))
                      (cell-list)))))
      ((conf)
       (and (alist? (cell-list))
            (conf-verify (cdr def) (list (cell-list)) warn)))
      ((or)
       (or (any (lambda (x) (conf-verify-match x cell (lambda (x) x)))
                (cdr def))
           (warn "bad spec value for " (car cell)
                 ": expected " def " but got " (cell-value))))
      ((member)
       (or (member (cell-value) (cdr def))
           (warn "bad spec value " (cell-value)
                 " for " (car cell) ", expected one of " (cdr def))))
      ((quote)
       (or (equal? (cadr def) (cell-value))
           (warn "bad conf value for " (car cell)
                 ": expected '" (cadr def) " but got " (cell-value))))
      (else
       (warn "bad conf list spec name: " (car def)))))
   (else
    (or (equal? def (cell-value))
        (warn "bad conf value for " (car cell)
              ": expected " def " but got " (cell-value))))))

(define (conf-verify-one spec cell warn)
  (cond
   ((not (pair? cell))
    (warn "bad config entry: " cell))
   ((not (symbol? (car cell)))
    (warn "non-symbol config entry name: " (car cell)))
   (else
    (let ((def (assq (car cell) spec)))
      (cond
       ((not def)
        (warn "unknown config entry: " (car cell)))
       ((null? (cdr def)))
       (else (conf-verify-match (cadr def) cell warn)))))))

(define (conf-verify spec config . o)
  (let ((warn (if (pair? o) (car o) conf-default-warn)))
    (let lp ((config config))
      (cond
       (config
        (for-each
         (lambda (cell) (conf-verify-one spec cell warn))
         (conf-alist config))
        (lp (conf-parent config)))))))
(define-library (chibi parse-test)
  (export run-tests)
  (import (scheme base) (scheme char)
          (chibi test) (chibi parse) (chibi parse common))
  (cond-expand
   (chibi (import (chibi char-set) (chibi char-set ascii)))
   (else (import (srfi 14))))
  (begin
    (define (run-tests)
      (test-begin "parse")

      ;; basic

      (test-assert (parse parse-epsilon ""))
      (test-assert (parse-fully parse-epsilon ""))
      (test-error (parse-fully parse-epsilon "a"))

      (test-not (parse parse-anything ""))
      (test-assert (parse-fully parse-anything "a"))
      (test-error (parse-fully parse-anything "ab"))

      (test-not (parse parse-nothing ""))
      (test-not (parse parse-nothing "a"))
      (test-error (parse-fully parse-nothing ""))

      (test-not (parse (parse-char #\a) ""))
      (test-assert (parse-fully (parse-char #\a) "a"))
      (test-not (parse (parse-char #\a) "b"))
      (test-error (parse-fully (parse-char #\a) "ab"))

      (let ((f (parse-seq (parse-char #\a) (parse-char #\b))))
        (test-not (parse f "a"))
        (test-not (parse f "b"))
        (test-assert (parse f "ab"))
        (test-error (parse-fully f "abc")))

      (let ((f (parse-or (parse-char #\a) (parse-char #\b))))
        (test-not (parse f ""))
        (test-assert (parse f "a"))
        (test-assert (parse f "b"))
        (test-error (parse-fully f "ab")))

      (let ((f (parse-not (parse-char #\a))))
        (test-assert (parse f ""))
        (test-error (parse-fully f "a"))
        (test-assert (parse f "b")))

      (let ((f (parse-repeat (parse-char #\a))))
        (test-assert (parse-fully f ""))
        (test-assert (parse-fully f "a"))
        (test-assert (parse-fully f "aa"))
        (test-assert (parse-fully f "aaa"))
        (test-assert (parse f "b"))
        (test-assert (parse f "aab"))
        (test-error (parse-fully f "aab")))

      (let ((f (parse-seq (parse-char #\a)
                          (parse-ignore (parse-char #\b)))))
        (test '(#\a) (parse f "ab")))

      (let ((f (parse-seq (parse-char #\a)
                          (parse-ignore (parse-char #\b))
                          (parse-char #\c))))
        (test '(#\a #\c) (parse f "abc")))

      ;; grammars

      (let ()
        (define-grammar calc
          (space ((* ,char-set:whitespace)))
          (number ((=> n (+ ,char-set:digit))
                   (string->number (list->string n))))
          (simple ((=> n ,number) n)
                  ((: "(" (=> e1 ,term) ")") e1))
          (term-op ("*" *)
                   ("/" /)
                   ("%" modulo))
          (term ((: (=> e1 ,simple) ,space (=> op ,term-op)
                    ,space (=> e2 ,term))
                 (op e1 e2))
                ((=> e1 ,simple)
                 e1)))
        (test 88 (parse term "4*22"))
        (test 42 (parse term "42"))
        ;; partial match (grammar isn't checking end)
        (test 42 (parse term "42*")))

      (let ()
        (define calculator
          (grammar expr
            (space ((: ,char-set:whitespace ,space))
                   (() #f))
            (digit ((=> d ,char-set:digit) d))
            (number ((=> n (+ ,digit))
                     (string->number (list->string n))))
            (simple ((=> n ,number) n)
                    ((: "(" (=> e1 ,expr) ")") e1))
            (term-op ("*" *)
                     ("/" /)
                     ("%" modulo))
            (term ((: (=> e1 ,simple) ,space (=> op ,term-op) ,space
                      (=> e2 ,term))
                   (op e1 e2))
                  ((=> e1 ,simple)
                   e1))
            (expr-op ("+" +) ("-" -))
            (expr ((: ,space (=> e1 ,term) ,space (=> op ,expr-op) ,space
                      (=> e2 ,expr))
                   (op e1 e2))
                  ((: ,space (=> e1 ,term))
                   e1))))

        (test 42 (parse calculator "42"))
        (test 4 (parse calculator "2 + 2"))
        (test 23 (parse calculator "2 + 2*10 + 1"))
        (test 25 (parse calculator "2+2 * 10+1 * 3"))
        (test 41 (parse calculator "(2 + 2) * 10 + 1")))

      (let ()
        (define prec-calc
          (grammar expr
            (simple (,(parse-integer))
                    ((: "(" (=> e1 ,expr) ")") e1))
            (op
             ("+" '+) ("-" '-) ("*" '*) ("/" '/) ("^" '^))
            (expr
             (,(parse-binary-op op
                                `((+ 5) (- 5) (* 3) (/ 3) (^ 1 right))
                                simple)))))

        (test 42 (parse prec-calc "42"))
        (test '(+ 2 2) (parse prec-calc "2 + 2"))
        (test '(+ (+ 2 2) 2) (parse prec-calc "2 + 2 + 2"))
        (test '(+ (+ 2 (* 2 10)) 1) (parse prec-calc "2 + 2*10 + 1"))
        (test '(+ (+ 2 (* 2 10)) (* 1 3)) (parse prec-calc "2+2 * 10+1 * 3"))
        (test '(+ (* (+ 2 2) 10) 1) (parse prec-calc "(2 + 2) * 10 + 1"))
        (test '(^ 2 (^ 2 2)) (parse prec-calc "2 ^ 2 ^ 2"))
        (test '(+ (+ (+ 1 (* (* 2 (^ 3 (^ 4 5))) 6)) (^ 7 8)) 9)
            (parse prec-calc "1 + 2 * 3 ^ 4 ^ 5 * 6 + 7 ^ 8 + 9")))

      ;; this takes exponential time without memoization
      (let ()
        (define explode
          (grammar start
            (start ((: ,S eos) #t))
            (S ((+ ,A) #t))
            (A ((: "a" ,S "b") #t)
               ((: "a" ,S "c") #t)
               ((: "a") #t))))

        (test-assert (parse explode "aaabb"))
        (test-not (parse explode "bbaa"))
        (test-assert
            (parse explode
                   (string-append (make-string 10 #\a) (make-string 8 #\c)))))

      (test-end))))

;;> A library for reading and writing data in JSON format (RFC 8259).

;;> \procedure{(json-read [in])}
;;> Reads a JSON expression from port \var{in}.  Objects are
;;> represented as alists with symbol keys, arrays as Scheme vectors,
;;> null as the symbol \scheme{'null}, and strings, numbers and
;;> booleans as the corresponding Scheme types.

;;> \procedure{(string->json str)}
;;> Returns the JSON representation of \var{str} as from \scheme{json-read}.
;;>
;;> \example{
;;>   (string->json "{\\"mean\\": 2.2, \\"quartiles\\": [1, 2, 3, 4]}")
;;> }
(define (string->json str)
  (let* ((in (open-input-string str))
         (res (json-read in)))
    (close-input-port in)
    res))

;;> \procedure{(json-write json [out])}
;;> Writes a JSON representation of \var{obj} to port \var{out}, where
;;> \var{obj} should follow the same mappings as in \var{json-read}.

;;> \procedure{(json->string json)}
;;> Returns the string representation of \var{json} as from \scheme{json-write}.
(define (json->string json)
  (let ((out (open-output-string)))
    (json-write json out)
    (get-output-string out)))

(define (json-field-mapper rtd name spec strict?)
  (if (symbol? spec)
      (rtd-mutator rtd spec)
      (let ((setter (rtd-mutator rtd name))
            (mapper (make-json-mapper spec strict?)))
        (lambda (rec val)
          (setter rec (mapper val))))))

(define (make-json-mapper spec . o)
  (let ((strict? (and (pair? o) (car o))))
    (cond
     ((vector? spec)
      (if (= 1 (vector-length spec))
          (let ((elt-spec (make-json-mapper (vector-ref spec 0) strict?)))
            (lambda (x)
              (if (vector? x)
                  (vector-map elt-spec x)
                  (error "expected json array" x))))
          (lambda (x)
            (if (vector? x) x (error "expected json array" x)))))
     ((procedure? spec)
      (lambda (x)
        (if (spec x) x (error "json check failed" spec x))))
     ((rtd? spec)
      (make-json-mapper
       (cons spec (map (lambda (f) (cons f f))
                       (vector->list (rtd-all-field-names spec))))
       strict?))
     ((pair? spec)
      (if (rtd? (car spec))
          (let* ((rtd (car spec))
                 (make (make-constructor (type-name rtd) rtd))
                 (fields
                  (map (lambda (f)
                         (cons (car f)
                               (json-field-mapper rtd (car f) (cdr f) strict?)))
                       (cdr spec))))
            (lambda (x)
              (if (not (or (pair? x) (null? x)))
                  (error "expected json object" x)
                  (let ((res (make)))
                    (for-each
                     (lambda (y)
                       (cond
                        ((and (pair? y) (assq (car y) fields))
                         => (lambda (f) ((cdr f) res (cdr y))))
                        (strict?
                         (error "unknown field" (if (pair? y) (car y) y)))
                        (else
                         )))
                     x)
                    res))))
          (error "expected rtd in object spec" spec)))
     (else
      (error "unknown json reader spec" spec)))))

;;> Returns a procedure of one argument, an input port, which reads a
;;> JSON object according to the specification \var{spec}, which can
;;> be one of:
;;>
;;> \itemlist[
;;>   \item{a record type: reads a json object with field names
;;>     corresponding to the record names}
;;>   \item{a predicate: reads an arbitrary json object, and returns
;;>     that object if the predicate succeeds, or an error otherwise}
;;>   \item{a vector of one element: reads a json array of objects as
;;>     described by the vector element}
;;>   \item{a list: the car should be a record type, and the cdr
;;>     an alist of (field-name . spec).  The spec can be a symbol,
;;>     in which case it is the record field name (allowing aliasing),
;;>     otherwise it is a normal spec to read and set the corresponding
;;>     field}
;;> ]
;;>
;;> If \var{strict?} is specified and true, raises an error if any
;;> unknown field names are specified in an object.
;;>
;;> Examples:
;;>
;;> \example{
;;> (begin
;;>  (define-record-type Employee
;;>    (make-employee name id title department)
;;>    employee?
;;>    (name employee-name)
;;>    (id employee-id)
;;>    (title employee-title)
;;>    (department employee-department))
;;>  (define-record-type Team
;;>    (make-team name lead devs)
;;>    team?
;;>    (name team-name)
;;>    (lead team-lead)
;;>    (devs team-devs))
;;>  (define read-team
;;>    (make-json-reader
;;>     `(,Team
;;>       (lead . ,Employee)
;;>       (name . ,string?)
;;>       (devs . #(,Employee)))))
;;>  (define team
;;>   (read-team
;;>    (open-input-string
;;>     "{\\"name\\": \\"A-Team\\",
;;>       \\"lead\\": {\\"name\\": \\"Hannibal\\", \\"id\\": 321},
;;>       \\"devs\\": [{\\"name\\": \\"B.A.\\", \\"id\\": 7},
;;>                  {\\"name\\": \\"Murdock\\", \\"id\\": 13}]}")))
;;>  (cons (team-name team)
;;>        (map employee-name
;;>             (cons (team-lead team) (vector->list (team-devs team))))))
;;> }
(define (make-json-reader spec . o)
  (let* ((strict? (and (pair? o) (car o)))
         (proc (make-json-mapper spec strict?)))
    ;; TODO: update this to read directly without the intermediate
    ;; representation
    (lambda (in) (proc (json-read in)))))

(define-library (chibi channel)
  (cond-expand
   (chibi (import (chibi) (srfi 9)))
   (else (import (scheme base))))
  (import (srfi 18))
  (export Channel make-channel channel? channel-empty?
          channel-send! channel-receive!)
  (include "channel.scm"))
(define-library (chibi mime-test)
  (export run-tests)
  (import (scheme base) (chibi mime) (chibi string) (chibi test))
  (begin
    (define (run-tests)
      (test-begin "mime")

      (test '(text/html (charset . "UTF-8") (filename . "index.html"))
          (mime-parse-content-type
           "text/html; CHARSET=UTF-8; filename=index.html"))

      (test '(multipart/form-data (boundary . "AaB03x"))
          (mime-parse-content-type "multipart/form-data, boundary=AaB03x"))

      (test '(mime (@ (from . "\"Dr. Watson <guest@grimpen.moor>\"")
                      (to . "\"Sherlock Homes <not-really@221B-baker.street>\"")
                      (subject . "\"First Report\"")
                      (content-type . "text/plain; charset=\"ISO-8859-1\""))
                   "Moor is gloomy. Heard strange noise, attached.\n")
          (call-with-input-string
              "From:    \"Dr. Watson <guest@grimpen.moor>\"
To:      \"Sherlock Homes <not-really@221B-baker.street>\"
Subject: \"First Report\"
Content-Type: text/plain; charset=\"ISO-8859-1\"

Moor is gloomy. Heard strange noise, attached.

"
            mime-message->sxml))

      ;; from rfc 1867

      (test '(mime
              (@ (content-type . "multipart/form-data, boundary=AaB03x"))
              (mime (@ (content-disposition . "form-data; name=\"field1\""))
                    "Joe Blow")
              (mime (@ (content-disposition
                        . "form-data; name=\"pics\"; filename=\"file1.txt\"")
                       (content-type . "text/plain"))
                    " ... contents of file1.txt ..."))
          (call-with-input-string
              "Content-type: multipart/form-data, boundary=AaB03x

--AaB03x
content-disposition: form-data; name=\"field1\"

Joe Blow
--AaB03x
content-disposition: form-data; name=\"pics\"; filename=\"file1.txt\"
Content-Type: text/plain

 ... contents of file1.txt ...
--AaB03x--
"
            mime-message->sxml))

      (test '(mime
              (@ (content-type . "multipart/form-data, boundary=AaB03x"))
              (mime (@ (content-disposition . "form-data; name=\"field1\""))
                    "Joe Blow")
              (mime (@ (content-disposition . "form-data; name=\"pics\"")
                       (content-type . "multipart/mixed, boundary=BbC04y"))
                    (mime (@ (content-disposition
                              . "attachment; filename=\"file1.txt\"")
                             (content-type . "text/plain"))
                          "... contents of file1.txt ...")
                    (mime (@ (content-disposition
                              . "attachment; filename=\"file2.gif\"")
                             (content-type . "image/gif")
                             (content-transfer-encoding . "binary"))
                          #u8(32 32 46 46 46 99 111 110 116 101 110
                                 116 115 32 111 102 32 102 105 108 101
                                 50 46 103 105 102 46 46 46))))
          (call-with-input-string
              "Content-type: multipart/form-data, boundary=AaB03x

--AaB03x
content-disposition: form-data; name=\"field1\"

Joe Blow
--AaB03x
content-disposition: form-data; name=\"pics\"
Content-type: multipart/mixed, boundary=BbC04y

--BbC04y
Content-disposition: attachment; filename=\"file1.txt\"
Content-Type: text/plain

... contents of file1.txt ...
--BbC04y
Content-disposition: attachment; filename=\"file2.gif\"
Content-type: image/gif
Content-Transfer-Encoding: binary

  ...contents of file2.gif...
--BbC04y--
--AaB03x--
"
            mime-message->sxml))

      (test '(mime
              (@ (content-type . "multipart/form-data, boundary=AaB03x"))
              (mime (@ (content-disposition . "form-data; name=\"field1\"")
                       (content-type . "text/plain"))
                    "Joe Blow")
              (mime (@ (content-disposition . "form-data; name=\"pics\"")
                       (content-type . "multipart/mixed, boundary=BbC04y"))
                    (mime (@ (content-disposition
                              . "attachment; filename=\"file1.txt\"")
                             (content-type . "text/plain"))
                          "... contents of file1.txt ...")
                    (mime (@ (content-disposition
                              . "attachment; filename=\"file2.gif\"")
                             (content-type . "image/gif")
                             (content-transfer-encoding . "binary"))
                          #u8(32 32 46 46 46 99 111 110 116 101 110
                                 116 115 32 111 102 32 102 105 108 101
                                 50 46 103 105 102 46 46 46))))
          (mime-message->sxml
           (open-input-bytevector
            (string->utf8
             "Content-type: multipart/form-data, boundary=AaB03x

--AaB03x
content-disposition: form-data; name=\"field1\"
Content-Type: text/plain

Joe Blow
--AaB03x
content-disposition: form-data; name=\"pics\"
Content-type: multipart/mixed, boundary=BbC04y

--BbC04y
Content-disposition: attachment; filename=\"file1.txt\"
Content-Type: text/plain

... contents of file1.txt ...
--BbC04y
Content-disposition: attachment; filename=\"file2.gif\"
Content-type: image/gif
Content-Transfer-Encoding: binary

  ...contents of file2.gif...
--BbC04y--
--AaB03x--
"))))
      (test "text/html; charset=utf-8"
          (mime-type-from-extension "html"))
      (test "text/plain; charset=utf-8"
          (mime-type-from-extension "scm"))
      (test #f
          (mime-type-from-extension "foo"))
      (test-end))))

(define-library (chibi config)
  (export make-conf conf? conf-load conf-load-in-path conf-load-cascaded
          conf-verify conf-extend conf-append conf-set conf-unfold-key
          conf-get conf-get-list conf-get-cdr conf-get-multi
          conf-specialize read-from-file conf-source conf-head conf-parent
          assoc-get assoc-get-list)
  (import (scheme base) (scheme read) (scheme write) (scheme file)
          (scheme time) (srfi 1))
  ;; This is only used for config verification, it's acceptable to
  ;; substitute file existence for the stronger directory check.
  (cond-expand
   (chibi
    (import (only (meta) warn))
    (import (only (chibi) print-exception print-stack-trace))
    (import (only (chibi filesystem) file-directory?)))
   (else
    (begin
      (define file-directory? file-exists?)
      (define (print-exception exn) (write exn))
      (define (print-stack-trace . o) #f)
      (define (warn msg . args)
        (let ((err (current-error-port)))
          (display msg err)
          (for-each (lambda (x) (display " " err) (write x err)) args)
          (newline err))))))
  (include "config.scm"))
;; log.scm -- customizable logging with levels
;; Copyright (c) 2005-2013 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

(define-record-type Logger
  (make-logger levels level-abbrevs current-level prefix prefix-spec
               counts file port locked? zipped?)
  logger?
  (levels logger-levels logger-levels-set!)
  (level-abbrevs logger-level-abbrevs logger-level-abbrevs-set!)
  (current-level logger-current-level %logger-current-level-set!)
  (prefix logger-prefix %logger-prefix-set!)
  (prefix-spec logger-prefix-spec logger-prefix-spec-set!)
  (counts logger-counts logger-counts-set!)
  (file logger-file logger-file-set!)
  (port logger-port logger-port-set!)
  (locked? logger-locked? logger-locked?-set!)
  (zipped? logger-zipped? logger-zipped?-set!))

(define (logger-prefix-set! logger prefix)
  (%logger-prefix-set! logger (log-compile-prefix prefix))
  (logger-prefix-set! logger prefix))

(define (logger-current-level-set! logger level)
  (%logger-current-level-set! logger (log-level-index logger level)))

(define-syntax with-log-level
  (syntax-rules ()
    ((with-logger-level level expr0 expr1 ...)
     (let* ((orig-level (logger-current-level default-logger))
            (new-level (log-level-index default-logger level)))
       (dynamic-wind
         (lambda () (%logger-current-level-set! default-logger new-level))
         (lambda () expr0 expr1 ...)
         (lambda () (%logger-current-level-set! default-logger orig-level)))))))

(define-syntax define-logger
  (syntax-rules ()
    ((define-logger logger (levels ...))
     (def-logger logger (levels ...) log-default-prefix 0 () ()))))

(define-syntax def-logger
  (syntax-rules ()
    ((def-logger logger ((#f name) . rest) prefix n (names ...) defs)
     (def-logger logger rest prefix (+ n 1) (names ... name) defs))
    ((def-logger logger ((level name) . rest) prefix n (names ...) (defs ...))
     (def-logger logger rest prefix (+ n 1)
       (names ... name)
       (defs ...
         (define-syntax level
           (syntax-rules ()
             ((level . args)
              (if (<= n (logger-current-level logger))
                  (log-show logger n . args))))))))
    ((def-logger logger ((level name . x) . rest) . y)
     (syntax-error "bad logger level: " (level name . x)))
    ((def-logger logger (level . rest) prefix n names defs)
     (def-logger logger ((level (log-normalize-name 'level)) . rest)
       prefix n names defs))
    ((def-logger logger () prefix n (names ...) (defs ...))
     (begin
       defs ...
       (define logger
         (let ((names-vec (vector names ...)))
           (make-logger
            names-vec
            (log-generate-abbrevs names-vec)
            n
            (log-compile-prefix prefix)
            prefix
            '() #f (current-error-port) #f #f)))))))

(define (log-normalize-name name)
  (let ((str (symbol->string name)))
    (if (string-prefix? "log-" str)
        (string->symbol (substring str 4 (string-length str)))
        name)))

(define (log-level-index logger level)
  (if (integer? level)
      level
      (let ((len (vector-length (logger-levels logger))))
        (let lp ((i 0))
          (cond
           ((= i len)
            (error "unknown log level" (logger-levels logger) level))
           ((eq? level (vector-ref (logger-levels logger) i)) i)
           (else (lp (+ i 1))))))))

(define (log-level-name logger level)
  (cond
   ((symbol? level)
    level)
   ((< level (vector-length (logger-levels logger)))
    (vector-ref (logger-levels logger) level))
   (else
    (let ((len (vector-length (logger-levels logger))))
      (string->symbol
      (string-append
       (symbol->string (vector-ref (logger-levels logger) (- len 1)))
       "-" (number->string (- level len))))))))

(define (log-level-abbrev logger level)
  (cond
   ((symbol? level)
    (log-level-abbrev logger (log-level-index logger level)))
   ((< level (vector-length (logger-level-abbrevs logger)))
    (vector-ref (logger-level-abbrevs logger) level))
   (else
    (number->string level))))

(define (log-generate-abbrevs abbrevs)
  (let* ((len (vector-length abbrevs))
         (res (make-vector len)))
    (do ((i 0 (+ i 1)))
        ((= i len) res)
      (let ((name (symbol->string (vector-ref abbrevs i))))
        (vector-set! res i (string (char-upcase (string-ref name 0))))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; procedural interface

(define (log-generate-output logger level args)
  (let ((prefix ((logger-prefix logger) logger level))
        (message (show #f (each-in-list args))))
    (string-append
     prefix
     (string-join (string-split message #\newline)
                  (string-append "\n" prefix))
     "\n")))

(define (log-compile-prefix spec)
  (define (pad2 n)
    (if (< n 10)
        (string-append "0" (number->string n))
        (number->string n)))
  (define (log-compile-one-prefix x)
    (if (string? x)
        (lambda (lg time level) x)
        (case x
          ((year)
           (lambda (lg time level) (number->string (+ 1900 (time-year time)))))
          ((month) (lambda (lg time level) (pad2 (+ 1 (time-month time)))))
          ((day) (lambda (lg time level) (pad2 (time-day time))))
          ((hour) (lambda (lg time level) (pad2 (time-hour time))))
          ((minute) (lambda (lg time level) (pad2 (time-minute time))))
          ((second) (lambda (lg time level) (pad2 (time-second time))))
          ((level)
           (lambda (lg time level) (symbol->string (log-level-name lg level))))
          ((level-abbrev)
           (lambda (lg time level) (log-level-abbrev lg level)))
          ((pid) (lambda (lg time level) (number->string (current-process-id))))
          ((uid) (lambda (lg time level) (number->string (current-group-id))))
          ((gid) (lambda (lg time level) (number->string (current-user-id))))
          (else (error "unknown logging spec" x)))))
  (let ((procs (map log-compile-one-prefix spec)))
    (lambda (logger level)
      (let ((time (seconds->time (current-seconds))))
        (let lp ((ls procs) (res '()))
          (if (null? ls)
              (string-join (reverse res))
              (lp (cdr ls) (cons ((car ls) logger time level) res))))))))

(define log-default-prefix
  '(year "-" month "-" day " " hour ":" minute ":" second " " level-abbrev " "))

(define (log-open logger . o)
  (if (pair? o)
      (logger-file-set! logger (car o)))
  (if (string? (logger-file logger))
      (logger-port-set! logger (open-output-file/append (logger-file logger)))
      (logger-port-set! logger (current-error-port))))

(define (log-close logger)
  (if (and (output-port? (logger-port logger))
           (not (eq? (current-error-port) (logger-port logger))))
      (close-output-port (logger-port logger))))

;; Use file-locking to let multiple processes write to the same log
;; file.  On error try to re-open the log file.  We keep the port open
;; so that even if you mv the file (e.g. when rotating logs) we keep
;; writing to it in the new location.  To force writing to a new file
;; in the original location, use cp+rm instead of mv, so that the
;; logging will error and try to re-open.
(define (log-show logger level . args)
  (cond
   ((<= level (logger-current-level logger))
    (let ((str (log-generate-output logger level args)))
      (let lp ((first? #t))
        (let ((out (logger-port logger)))
          (protect (exn
                    (else
                     (cond
                      (first?  ; try to re-open log-file once
                       (log-close logger)
                       (log-open logger)
                       (lp #f))
                      (else    ; fall back to stderr
                       (write-string str (current-error-port))))))
            (let ((locked? (and (logger-locked? logger)
                                (output-port? out)
                                (file-lock out lock/exclusive))))
              ;; this is redundant with POSIX O_APPEND
              ;; (set-file-position! out 0 seek/end)
              (write-string str out)
              (flush-output out)
              (if locked? (file-lock out lock/unlock))))))))))

(define (log-show-every-n logger level id n . args)
  (cond
   ((assq id (logger-counts logger))
    => (lambda (cell)
         (if (zero? (modulo (cdr cell) n))
             (apply log-show logger level args))))
   (else
    (logger-counts-set! logger (cons (cons id 0) (logger-counts logger)))
    (apply log-show logger level args))))

;; http://httpd.apache.org/docs/2.2/mod/core.html#loglevel

(define-logger default-logger
  (log-emergency ; the server is on fire!!!           
   log-alert     ; couldn't write to user mailbox     
   log-critical  ; couldn't run 'dig' executable      
   log-error     ; error loading user filter          
   log-warn      ; invalid smtp command; relay failed 
   log-notice    ; saved to file/relayed to address   
   log-info      ; loaded alias file                  
   log-debug))   ; spam-probability: 0.5

(define-syntax with-logged-errors
  (syntax-rules ()
    ((with-logged-errors . body)
     (protect (exn (else (log-error exn)))
       . body))))

(define-syntax with-logged-and-reraised-errors
  (syntax-rules ()
    ((with-logged-errors . body)
     (protect (exn (else (log-error exn) (raise exn)))
       . body))))
;; Copyright (c) 2005-2014 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

;;> RFC 3548 base64 encoding and decoding utilities.
;;> This API is compatible with the Gauche library rfc.base64.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; string utils

(define (string-chop str n)
  (let ((len (string-length str)))
    (let lp ((i 0) (res '()))
      (let ((j (+ i n)))
        (if (>= j len)
            (reverse (cons (substring str i len) res))
            (lp j (cons (substring str i j) res)))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; constants and tables

(define *default-max-col* 76)

(define *outside-char* 99) ; luft-balloons
(define *pad-char* 101)    ; dalmations

(define *base64-decode-table*
  (let ((res (make-vector #x100 *outside-char*)))
    (let lp ((i 0)) ; map letters
      (cond
       ((<= i 25)
        (vector-set! res (+ i 65) i)
        (vector-set! res (+ i 97) (+ i 26))
        (lp (+ i 1)))))
    (let lp ((i 0)) ; map numbers
      (cond
       ((<= i 9)
        (vector-set! res (+ i 48) (+ i 52))
        (lp (+ i 1)))))
    ;; extras (be liberal for different common base64 formats)
    (vector-set! res (char->integer #\+) 62)
    (vector-set! res (char->integer #\-) 62)
    (vector-set! res (char->integer #\/) 63)
    (vector-set! res (char->integer #\_) 63)
    (vector-set! res (char->integer #\~) 63)
    (vector-set! res (char->integer #\=) *pad-char*)
    res))

(define (base64-decode-u8 u8)
  (vector-ref *base64-decode-table* u8))

(define *base64-encode-table*
  (let ((res (make-vector 64)))
    (let lp ((i 0)) ; map letters
      (cond
       ((<= i 25)
        (vector-set! res i (+ i 65))
        (vector-set! res (+ i 26) (+ i 97))
        (lp (+ i 1)))))
    (let lp ((i 0)) ; map numbers
      (cond
       ((<= i 9)
        (vector-set! res (+ i 52) (+ i 48))
        (lp (+ i 1)))))
    (vector-set! res 62 (char->integer #\+))
    (vector-set! res 63 (char->integer #\/))
    res))

(define (enc i)
  (vector-ref *base64-encode-table* i))

;; try to match common boundaries
(define decode-src-length
  (lcm 76 78))

(define decode-dst-length
  (* 3 (arithmetic-shift (+ 3 decode-src-length) -2)))

(define encode-src-length
  (* 3 1024))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; decoding

;;> Return a base64 decoded representation of string, also interpreting
;;> the alternate 62 & 63 valued characters as described in RFC3548.
;;> Other out-of-band characters are silently stripped, and = signals
;;> the end of the encoded string.  No errors will be raised.

;; Create a result buffer with the maximum possible length for the
;; input, and pass it to the internal base64-decode-string! utility.
;; If the resulting length used is exact, we can return that buffer,
;; otherwise we return the appropriate substring.

(define (base64-decode-string str)
  (utf8->string (base64-decode-bytevector (string->utf8 str))))

(define (base64-decode-bytevector src)
  (let* ((len (bytevector-length src))
         (dst-len (* 3 (arithmetic-shift (+ 3 len) -2)))
         (dst (make-bytevector dst-len)))
    (base64-decode-bytevector!
     src 0 len dst
     (lambda (src-offset res-len b1 b2 b3)
       (let ((res-len (base64-decode-finish dst res-len b1 b2 b3)))
         (if (= res-len dst-len)
             dst
             (bytevector-copy dst 0 res-len)))))))

;; This is a little funky.
;;
;;   We want to skip over "outside" characters (e.g. newlines inside
;;   base64-encoded data, as would be passed in mail clients and most
;;   large base64 data).  This would normally mean two nested loops -
;;   one for overall processing the input, and one for looping until
;;   we get to a valid character.  However, many Scheme compilers are
;;   really bad about optimizing nested loops of primitives, so we
;;   flatten this into a single loop, using conditionals to determine
;;   which character is currently being read.
(define (base64-decode-bytevector! src start end dst kont)
  (let lp ((i start)
           (j 0)
           (b1 *outside-char*)
           (b2 *outside-char*)
           (b3 *outside-char*))
    (if (>= i end)
        (kont i j b1 b2 b3)
        (let ((c (base64-decode-u8 (bytevector-u8-ref src i))))
          (cond
           ((eqv? c *pad-char*)
            (kont i j b1 b2 b3))
           ((eqv? c *outside-char*)
            (lp (+ i 1) j b1 b2 b3))
           ((eqv? b1 *outside-char*)
            (lp (+ i 1) j c b2 b3))
           ((eqv? b2 *outside-char*)
            (lp (+ i 1) j b1 c b3))
           ((eqv? b3 *outside-char*)
            (lp (+ i 1) j b1 b2 c))
           (else
            (bytevector-u8-set!
             dst
             j
             (bitwise-ior (arithmetic-shift b1 2)
                          (bit-field b2 4 6)))
            (bytevector-u8-set!
             dst
             (+ j 1)
             (bitwise-ior
              (arithmetic-shift (bit-field b2 0 4) 4)
              (bit-field b3 2 6)))
            (bytevector-u8-set!
             dst
             (+ j 2)
             (bitwise-ior
              (arithmetic-shift (bit-field b3 0 2) 6)
              c))
            (lp (+ i 1) (+ j 3)
                *outside-char* *outside-char* *outside-char*)))))))

;; If requested, account for any "partial" results (i.e. trailing 2 or
;; 3 chars) by writing them into the destination (additional 1 or 2
;; bytes) and returning the adjusted offset for how much data we've
;; written.
(define (base64-decode-finish dst j b1 b2 b3)
  (cond
   ((eqv? b1 *outside-char*)
    j)
   ((eqv? b2 *outside-char*)
    (bytevector-u8-set! dst j (arithmetic-shift b1 2))
    (+ j 1))
   (else
    (bytevector-u8-set! dst
                        j
                        (bitwise-ior (arithmetic-shift b1 2)
                                     (bit-field b2 4 6)))
    (cond
     ((eqv? b3 *outside-char*)
      (+ j 1))
     (else
      (bytevector-u8-set! dst
                          (+ j 1)
                          (bitwise-ior
                           (arithmetic-shift (bit-field b2 0 4) 4)
                           (bit-field b3 2 6)))
      (+ j 2))))))

;;>  Variation of the above to read and write to ports.

(define (base64-decode . o)
  (let ((in (if (pair? o) (car o) (current-input-port)))
        (out (if (and (pair? o) (pair? (cdr o)))
                 (cadr o)
                 (current-output-port))))
    (cond
     ((not (binary-port? in))
      (let ((str (port->string in)))
        (write-string (base64-decode-string str) out)))
     (else
      (let ((src (make-bytevector decode-src-length))
            (dst (make-bytevector decode-dst-length)))
        (let lp ((offset 0))
          (let ((src-len
                 (+ offset
                    (read-bytevector! src in offset decode-src-length))))
            (cond
             ((= src-len decode-src-length)
              ;; read a full chunk: decode, write and loop
              (base64-decode-bytevector!
               src 0 decode-src-length dst
               (lambda (src-offset dst-len b1 b2 b3)
                 (cond
                  ((and (< src-offset src-len)
                        (eqv? #x3D (bytevector-u8-ref src src-offset)))
                   ;; done
                   (let ((dst-len (base64-decode-finish dst dst-len b1 b2 b3)))
                     (write-bytevector dst out 0 dst-len)))
                  ((eqv? b1 *outside-char*)
                   (write-bytevector dst out 0 dst-len)
                   (lp 0))
                  (else
                   (write-bytevector dst out 0 dst-len)
                   ;; one to three chars left in buffer
                   (bytevector-u8-set! src 0 (enc b1))
                   (cond
                    ((eqv? b2 *outside-char*)
                     (lp 1))
                    (else
                     (bytevector-u8-set! src 1 (enc b2))
                     (cond
                      ((eqv? b3 *outside-char*)
                       (lp 2))
                      (else
                       (bytevector-u8-set! src 2 (enc b3))
                       (lp 3))))))))))
             (else
              ;; end of source - just decode and write once
              (base64-decode-bytevector!
               src 0 src-len dst
               (lambda (src-offset dst-len b1 b2 b3)
                 (let ((dst-len (base64-decode-finish dst dst-len b1 b2 b3)))
                   (write-bytevector dst out 0 dst-len)))))))))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; encoding

;;> Return a base64 encoded representation of string according to the
;;> official base64 standard as described in RFC3548.

(define (base64-encode-string str)
  (utf8->string (base64-encode-bytevector (string->utf8 str))))

(define (base64-encode-bytevector bv)
  (let* ((len (bytevector-length bv))
         (quot (quotient len 3))
         (rem (- len (* quot 3)))
         (res-len (arithmetic-shift (+ quot (if (zero? rem) 0 1)) 2))
         (res (make-bytevector res-len)))
    (base64-encode-bytevector! bv 0 len res)
    res))

(define (base64-encode-bytevector! bv start end res)
  (let ((limit (- end 2)))
    (let lp ((i start) (j 0))
      (if (>= i limit)
          (case (- end i)
            ((1)
             (let ((b1 (bytevector-u8-ref bv i)))
               (bytevector-u8-set! res j (enc (arithmetic-shift b1 -2)))
               (bytevector-u8-set!
                res
                (+ j 1)
                (enc (arithmetic-shift (bitwise-and #b11 b1) 4)))
               (bytevector-u8-set! res (+ j 2) (char->integer #\=))
               (bytevector-u8-set! res (+ j 3) (char->integer #\=))
               (+ j 4)))
            ((2)
             (let ((b1 (bytevector-u8-ref bv i))
                   (b2 (bytevector-u8-ref bv (+ i 1))))
               (bytevector-u8-set! res j (enc (arithmetic-shift b1 -2)))
               (bytevector-u8-set!
                res
                (+ j 1)
                (enc (bitwise-ior
                      (arithmetic-shift (bitwise-and #b11 b1) 4)
                      (bit-field b2 4 8))))
               (bytevector-u8-set!
                res
                (+ j 2)
                (enc (arithmetic-shift (bit-field b2 0 4) 2)))
               (bytevector-u8-set! res (+ j 3) (char->integer #\=))
               (+ j 4)))
            (else
             j))
          (let ((b1 (bytevector-u8-ref bv i))
                (b2 (bytevector-u8-ref bv (+ i 1)))
                (b3 (bytevector-u8-ref bv (+ i 2))))
            (bytevector-u8-set! res j (enc (arithmetic-shift b1 -2)))
            (bytevector-u8-set!
             res
             (+ j 1)
             (enc (bitwise-ior
                   (arithmetic-shift (bitwise-and #b11 b1) 4)
                   (bit-field b2 4 8))))
            (bytevector-u8-set!
             res
             (+ j 2)
             (enc (bitwise-ior
                   (arithmetic-shift (bit-field b2 0 4) 2)
                   (bit-field b3 6 8))))
            (bytevector-u8-set! res (+ j 3) (enc (bitwise-and #b111111 b3)))
            (lp (+ i 3) (+ j 4)))))))

;;>  Variation of the above to read and write to ports.

(define (base64-encode . o)
  (let ((in (if (pair? o) (car o) (current-input-port)))
        (out (if (and (pair? o) (pair? (cdr o)))
                 (cadr o)
                 (current-output-port))))
    (cond
     ((not (binary-port? in))
      (let ((str (port->string in)))
        (write-string (base64-encode-string str) out)))
     (else
      (let ((src (make-bytevector encode-src-length))
            (dst (make-bytevector
                  (arithmetic-shift (quotient encode-src-length 3) 2))))
        (let lp ()
          (let ((n (read-bytevector! src in 0 2048)))
            (base64-encode-bytevector! src 0 n dst)
            (write-bytevector dst out 0 (* 4 (quotient (+ n 2) 3)))
            (if (= n 2048)
                (lp)
                (flush-output-port out)))))))))

;;> Return a base64 encoded representation of the string \var{str} as
;;> above, wrapped in =?ENC?B?...?= as per RFC1522, split across
;;> multiple MIME-header lines as needed to keep each lines length
;;> less than \var{max-col}.  The string is encoded as is, and the
;;> encoding \var{enc} is just used for the prefix, i.e. you are
;;> responsible for ensuring \var{str} is already encoded according to
;;> \var{enc}.  The optional argument \var{nl} is the newline
;;> separator, defaulting to \var{crlf}.

(define (base64-encode-header encoding str . o)
  (define (round4 i) (arithmetic-shift (arithmetic-shift i -2) 2))
  (let ((start-col (if (pair? o) (car o) 0))
        (max-col (if (and (pair? o) (pair? (cdr o)))
                     (car (cdr o))
                     *default-max-col*))
        (nl (if (and (pair? o) (pair? (cdr o)) (pair? (cdr (cdr o))))
                (car (cdr (cdr o)))
                "\r\n")))
    (let* ((prefix (string-append "=?" encoding "?B?"))
           (prefix-length (+ 2 (string-length prefix)))
           (effective-max-col (round4 (- max-col prefix-length)))
           (first-max-col (round4 (- effective-max-col start-col)))
           (str (base64-encode-string str))
           (len (string-length str)))
      (if (<= len first-max-col)
          (string-append prefix str "?=")
          (string-append
           (if (positive? first-max-col)
               (string-append
                prefix (substring str 0 first-max-col) "?=" nl "\t" prefix)
               "")
           (string-join (string-chop (substring str first-max-col len)
                                     effective-max-col)
                        (string-append "?=" nl "\t" prefix))
           "?=")))))


(define-library (chibi quoted-printable)
  (export quoted-printable-encode quoted-printable-encode-string
          quoted-printable-encode-bytevector
          quoted-printable-encode-header
          quoted-printable-decode quoted-printable-decode-string
          quoted-printable-decode-bytevector)
  (import (scheme base))
  (cond-expand
   ((library (srfi 151)) (import (srfi 151)))
   ((library (srfi 33)) (import (srfi 33)))
   (else (import (srfi 60))))
  (cond-expand
   (chibi (import (chibi io)))
   (else
    (begin
      (define (port->string in)
        (let ((out (open-output-string)))
          (let lp ()
            (let ((ch (read-char in)))
              (cond
               ((eof-object? ch)
                (get-output-string out))
               (else
                (write-char ch out)
                (lp))))))))))
  (include "quoted-printable.scm"))
(define-library (chibi quoted-printable-test)
  (export run-tests)
  (import (scheme base) (chibi quoted-printable) (chibi string) (chibi test))
  (begin
    (define (run-tests)
      (test-begin "quoted-printable")

      (test "J'interdis aux marchands de vanter trop leur marchandises. Car ils se font vite pdagogues et t'enseignent comme but ce qui n'est par essence qu'un moyen, et te trompant ainsi sur la route  suivre les voil bientt qui te dgradent, car si leur musique est vulgaire ils te fabriquent pour te la vendre une me vulgaire."
          (quoted-printable-decode-string
           "J'interdis aux marchands de vanter trop leur marchandises. Car ils se font =
vite p=C3=A9dagogues et t'enseignent comme but ce qui n'est par essence qu'=
un moyen, et te trompant ainsi sur la route =C3=A0 suivre les voil=C3=A0 bi=
ent=C3=B4t qui te d=C3=A9gradent, car si leur musique est vulgaire ils te f=
abriquent pour te la vendre une =C3=A2me vulgaire."))

      (test-end))))

;; Temporary hack, need to rewrite in pure Scheme.

;;> Gzip compress a file in place, renaming with a .gz suffix.

(define (gzip-file path)
  (system "gzip" path))

;;> Gunzip decompress a file in place, removing any .gz suffix.

(define (gunzip-file path)
  (system "gzip" "-d" path))

;; Utility to filter a bytevector to a process and return the
;; accumulated output as a new bytevector.
;; (define (process-pipe-bytevector cmd bvec)
;;   (call-with-process-io
;;    cmd
;;    (lambda (pid proc-in proc-out proc-err)
;;      (let ((len (bytevector-length bvec))
;;            (out (open-output-bytevector)))
;;        (let lp ((i 0))
;;          (cond
;;           ((u8-ready? proc-out)
;;            (let ((u8 (read-u8 proc-out)))
;;              (cond
;;               ((eof-object? u8)
;;                (get-output-bytevector out))
;;               (else
;;                (write-u8 u8 out)
;;                (lp i)))))
;;           ((< i len)
;;            (write-u8 (bytevector-u8-ref bvec i) proc-in)
;;            (lp (+ i 1)))
;;           (else
;;            ;; Once we've completed sending the input we busy wait
;;            ;; until all output has been read.  We can't just waitpid
;;            ;; here because the remaining output may still overflow the
;;            ;; pipe buffer.
;;            (close-output-port proc-in)
;;            (let lp ()
;;              (let ((u8 (read-u8 proc-out)))
;;                (cond
;;                 ((eof-object? u8)
;;                  (get-output-bytevector out))
;;                 (else
;;                  (write-u8 u8 out)
;;                  (lp))))))))))))

;; Use a temp file to avoid dead-lock issues with pipes.
(define (process-run-bytevector cmd bvec)
  (call-with-temp-file "bvec"
    (lambda (path out preserve)
      (write-bytevector bvec out)
      (close-output-port out)
      (process->bytevector (append cmd (list path))))))

;;> Gzip compress a string or bytevector in memory.

(define (gzip x)
  (if (string? x)
      (gzip (string->utf8 x))
      (process-run-bytevector '("gzip" "-c") x)))

;;> Gunzip decompress a bytevector in memory.

(define (gunzip bvec)
  (process-run-bytevector '("gzip" "-c" "-d") bvec))

;;> Gunzip decompress a bytevector in memory if it has been
;;> compressed, or return as-is otherwise.

(define (maybe-gunzip bvec)
  (if (and (>= (bytevector-length bvec) 10)
           (eqv? #x1f (bytevector-u8-ref bvec 0))
           (eqv? #x8b (bytevector-u8-ref bvec 1)))
      (gunzip bvec)
      bvec))

(define-library (chibi type-inference)
  (export type-analyze-module type-analyze procedure-signature
          type=? type-subset?)
  (import (chibi) (srfi 1) (srfi 38) (srfi 69)
          (chibi modules) (chibi ast) (chibi match))
  (include "type-inference.scm"))


;;> A library for generating SXML docs from Scribble, directly or
;;> extracted from literate docs.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; utils

(define (write-to-string x)
  (call-with-output-string (lambda (out) (write x out))))

(define (string-concatenate-reverse ls)
  (string-concatenate (reverse ls)))

(define (string-strip str . o)
  (let ((bad (if (pair? o) (car o) " \t\n")))
    (call-with-output-string
      (lambda (out)
        (call-with-input-string str
          (lambda (in)
            (let lp ()
              (let ((ch (read-char in)))
                (cond
                 ((not (eof-object? ch))
                  (if (not (string-find? bad ch))
                      (write-char ch out))
                  (lp)))))))))))

(define (string-first-token str sep)
  (let ((len (string-length str)))
    (let lp ((i 0))
      (cond ((= i len) str)
            ((not (string-find? sep (string-ref str i))) (lp (+ i 1)))
            (else
             (let lp ((j (+ i 1)))
               (cond ((= j len) "")
                     ((string-find? sep (string-ref str j)) (lp (+ j 1)))
                     (else
                      (let lp ((k (+ j 1)))
                        (cond
                         ((or (= k len) (string-find? sep (string-ref str k)))
                          (substring str j k))
                         (else
                          (lp (+ k 1)))))))))))))

(define (intersperse ls x)
  (if (or (null? ls) (null? (cdr ls)))
      ls
      (let lp ((ls (cdr ls)) (res (list (car ls))))
        (let ((res (cons (car ls) (cons x res))))
          (if (null? (cdr ls))
              (reverse res)
              (lp (cdr ls) res))))))

(define (normalize-sxml x)
  (cond
   ((pair? x)
    (let lp ((ls x) (res '()))
      (cond ((null? ls)
             (string-concatenate-reverse res))
            ((string? (car ls))
             (lp (cdr ls) (cons (car ls) res)))
            ((pair? res)
             (cons (string-concatenate-reverse res)
                   (cons (car ls) (normalize-sxml (cdr ls)))))
            (else
             (cons (car ls) (normalize-sxml (cdr ls)))))))
   (else x)))

(define (map-sxml proc x)
  (if (pair? x)
      (cons (map-sxml proc (car x))  (map-sxml proc (cdr x)))
      (proc x)))

(define (sxml-body x)
  (cond ((not (and (pair? x) (pair? (cdr x)))) '())
        ((and (pair? (cadr x)) (eq? '@ (car (cadr x)))) (cddr x))
        (else (cdr x))))

(define (sxml->sexp-list x)
  (call-with-input-string (sxml-strip x) port->sexp-list))

;;> Replace ansi escape sequences in a \var{str} with the corresponding sxml.
(define (ansi->sxml str)
  ;; TODO: ick
  (let ((start (string-cursor-start str))
        (end (string-cursor-end str)))
    (let lp1 ((from start)
              (to start)
              (res '()))
      (define (lookup str)
        (case (string->number str)
          ((0) '/) ((1) 'b) ((3) 'i) ((4) 'u) ((9) 's)
          ((22) '/b) ((23) '/i) ((24) '/u) ((29) '/s)
          ((30) 'black) ((31) 'red) ((32) 'green) ((33) 'yellow)
          ((34) 'blue) ((35) 'magenta) ((36) 'cyan) ((37) 'white)
          ((39) '/color)
          (else #f)))
      (define (collect from to res)
        (if (string-cursor<? from to)
            (cons (substring-cursor str from to) res)
            res))
      (define (finish)
        (let ((ls (reverse (collect from to res))))
          (if (and (= 1 (length ls)) (string? (car ls)))
              (car ls)
              (let lp1 ((ls ls) (cur '()) (res '()))
                (define (close to)
                  (let lp2 ((ls cur) (tmp '()))
                    (cond
                     ((null? ls)
                      (list '() `(,@(reverse tmp) ,@res)))
                     ((eq? to (car ls))
                      (list (cdr ls) `((,to ,@tmp) ,@res)))
                     ((and (eq? to 'color) (memq (car ls) '(b i u s)))
                      ;; color close came to an open non-color
                      ;; back off and leave this open
                      (let ((s `(,(car ls) ,@(take-while string? tmp)))
                            (tmp (drop-while string? tmp)))
                        (list `(,@(reverse tmp) ,@(reverse s)) res)))
                     ((symbol? (car ls))
                      (lp2 (cdr ls) `((,(car ls) ,@(reverse tmp)))))
                     ((and (pair? (car ls)) (eq? 'color to))
                      (lp2 (cdr ls) `((,@(car ls) ,@(reverse tmp)))))
                     ((pair? (car ls))
                      (lp2 (cdr ls) `(,(car ls) ,@(reverse tmp))))
                     (else
                      (lp2 (cdr ls) `(,(car ls) ,@tmp))))))
                (cond
                 ((null? ls)
                  `(span ,@(reverse (cadr (close #f)))))
                 ((and (string? (car ls)) (pair? cur))
                  (lp1 (cdr ls) (cons (car ls) cur) res))
                 ((string? (car ls))
                  (lp1 (cdr ls) cur (cons (car ls) res)))
                 (else
                  (case (car ls)
                    ((b i u s) (lp1 (cdr ls) (cons (car ls) cur) res))
                    ((/b) (apply lp1 (cdr ls) (close 'b)))
                    ((/i) (apply lp1 (cdr ls) (close 'i)))
                    ((/u) (apply lp1 (cdr ls) (close 'u)))
                    ((/s) (apply lp1 (cdr ls) (close 's)))
                    ((/) (apply lp1 (cdr ls) (close 'all)))
                    ((/color) (apply lp1 (cdr ls) (close 'color)))
                    (else
                     (let ((style (string-append "color:"
                                                 (symbol->string (car ls)))))
                       (lp1 (cdr ls)
                            (cons `(span (@ (style . ,style))) cur)
                            res))))))))))
      (if (string-cursor>=? to end)
          (finish)
          (let ((c (string-cursor-ref str to))
                (sc2 (string-cursor-next str to)))
            (if (and (= 27 (char->integer c))
                     (string-cursor<? sc2 end)
                     (eqv? #\[ (string-cursor-ref str sc2)))
                (let ((sc3 (string-cursor-next str sc2)))
                  (let lp2 ((sc4 sc3))
                    (if (string-cursor>=? sc4 end)
                        (finish)
                        (let ((c2 (string-cursor-ref str sc4))
                              (sc5 (string-cursor-next str sc4)))
                          (if (eqv? #\m c2)
                              (let ((code (lookup
                                           (substring-cursor str sc3 sc4)))
                                    (res (collect from to res)))
                                (lp1 sc5 sc5 (if code (cons code res) res)))
                              (lp2 sc5))))))
                (lp1 from sc2 res)))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;> Extract the literate Scribble docs for module \var{mod-name} and
;;> print them to \var{out}, rendered with \var{render} which defaults
;;> to \scheme{sxml-display-as-text}.

(define (print-module-docs mod-name . o)
  (let ((out (if (pair? o) (car o) (current-output-port)))
        (render (or (and (pair? o) (pair? (cdr o)) (cadr o))
                    sxml-display-as-text))
        (unexpanded?
         (and (pair? o) (pair? (cdr o)) (pair? (cddr o)) (car (cddr o)))))
    (render
     ((if unexpanded? (lambda (sxml env) (fixup-docs sxml)) generate-docs)
      `((title ,(write-to-string mod-name))
        ,@(extract-module-docs mod-name #f))
      (make-module-doc-env mod-name))
     out)))

;;> Extract the literate Scribble docs for just the binding for
;;> \var{var} in module \var{mod-name}, and print them as in
;;> \scheme{print-module-docs}.

(define (print-module-binding-docs mod-name var . o)
  (let ((out (if (pair? o) (car o) (current-output-port)))
        (render (or (and (pair? o) (pair? (cdr o)) (cadr o))
                    sxml-display-as-text)))
    (render
     (generate-docs
      (extract-module-docs mod-name #t (list var))
      (make-module-doc-env mod-name))
     out)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;> Extract the literate Scribble docs for \var{proc} which should be
;;> a procedure and return them as sxml.

(define (procedure-docs proc)
  (let ((mod (and (procedure? proc) (containing-module proc))))
    (and mod
         (generate-docs
          (extract-module-docs (car mod) #t (list (procedure-name proc)))
          (make-module-doc-env (car mod))))))

;;> Extract the literate Scribble docs for \var{proc} which should be
;;> a procedure and render them as in \scheme{print-module-docs}.

(define (print-procedure-docs proc . o)
  (let ((out (if (pair? o) (car o) (current-output-port)))
        (render (or (and (pair? o) (pair? (cdr o)) (cadr o))
                    sxml-display-as-text))
        (docs (procedure-docs proc)))
    (if docs (render docs out))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; doc environments

(define (env-ref env name . o)
  (cond ((assq name (car env)) => cdr)
        ((pair? o) (car o))
        (else #f)))

(define (env-set! env name value)
  (cond ((assq name (car env)) => (lambda (cell) (set-cdr! cell value)))
        (else (set-car! env (cons (cons name value) (car env))))))

(define (env-extend env vars vals)
  (list (append (map cons vars vals) (car env))))

;;> Return a new document environment suitable for passing to
;;> \scheme{expand-docs}, with default rules for sections, code
;;> blocks, procedure and macro signatures, etc.

(define (make-default-doc-env)
  `(((title . ,(expand-section 'h1))
     (section . ,(expand-section 'h2))
     (subsection . ,(expand-section 'h3))
     (subsubsection . ,(expand-section 'h4))
     (subsubsubsection . ,(expand-section 'h5))
     (procedure . ,expand-procedure)
     (macro . ,expand-macro)
     (centered . center)
     (smaller . small)
     (larger . large)
     (bold . b)
     (italic . i)
     (emph . em)
     (subscript . sub)
     (superscript . sup)
     (itemlist . ul)
     (item . li)
     (var . code)
     (cfun . code)
     (cmacro . code)
     (ctype . code)
     (url . ,expand-url)
     (hyperlink . ,expand-hyperlink)
     (rawcode . code)
     (pre . pre)
     (bibitem . ,(lambda (x env) '()))  ;; TODO: bibtex
     (code . ,expand-code)
     (codeblock . ,expand-codeblock)
     (ccode
      . ,(lambda (x env)
           (expand-code `(,(car x) language: c ,@(cdr x)) env)))
     (ccodeblock
      . ,(lambda (x env)
           (expand-codeblock `(,(car x) language: c ,@(cdr x)) env)))
     (scheme
      . ,(lambda (x env)
           (expand-code `(,(car x) language: scheme ,@(cdr x)) env)))
     (schemeblock
      . ,(lambda (x env)
           (expand-codeblock `(,(car x) language: scheme ,@(cdr x)) env)))
     (command . ,expand-command)
     (author . ,expand-author)
     (margin-note . ,expand-note)
     (example . ,expand-example)
     (example-import . ,expand-example-import)
     (example-import-only . ,expand-example-import-only)
     )))

;;> Return a new document environment as in
;;> \scheme{make-default-doc-env}, with an \scheme{example-env}
;;> binding mapped to an environment importing \scheme{(scheme base)}
;;> and the module \var{mod-name}.  This binding is used when
;;> expanding examples in the docs.

(define (make-module-doc-env mod-name)
  (env-extend (make-default-doc-env)
              '(example-env)
              (list (delay (environment '(scheme small)
                                        '(only (chibi) import)
                                        mod-name)))))

(define (section-name tag name)
  (string-strip
   (call-with-output-string
     (lambda (out)
       (display tag out)
       (write-char #\_ out)
       (display name out)))))

(define (expand-section tag)
  (lambda (sxml env)
    (if (null? (cdr sxml))
        (error "section must not be empty" sxml)
        (let* ((name (and (eq? 'tag: (cadr sxml))
                          (pair? (cddr sxml))
                          (sxml-strip (car (cddr sxml)))))
               (body (map (lambda (x) (expand-docs x env))
                          (if name (cdr (cddr sxml)) (cdr sxml))))
               (name (or name (sxml-strip (cons tag body)))))
          `(div (a (@ (name . ,(section-name tag name)))) (,tag ,@body))))))

(define (expand-url sxml env)
  (if (not (= 2 (length sxml)))
      (error "url expects one argument" sxml)
      (let ((url (expand-docs (cadr sxml) env)))
        `(a (@ (href . ,url)) ,url))))

(define (expand-hyperlink sxml env)
  (if (not (>= (length sxml) 3))
      (error "hyperlink expects at least two arguments" sxml)
      (let ((url (expand-docs (cadr sxml) env)))
        `(a (@ (href . ,url))
            ,(map (lambda (x) (expand-docs x env)) (cddr sxml))))))

(define (expand-note sxml env)
  `(div (@ (id . "notes"))
        ,@(map (lambda (x) (expand-docs x env)) (cdr sxml))))

(define (expand-author sxml env)
  `(div (@ (id . "notes"))
        ,@(map (lambda (x) (expand-docs x env)) (cdr sxml))
        (br)
        ,(seconds->string (current-seconds))))

(define (expand-code sxml env)
  (let* ((hl (if (and (pair? (cdr sxml)) (eq? 'language: (cadr sxml)))
                 (highlighter-for (car (cddr sxml)))
                 highlight))
         (body (if (and (pair? (cdr sxml)) (eq? 'language: (cadr sxml)))
                   (cdr (cddr sxml))
                   (cdr sxml))))
    `(code ,@(map-sxml (lambda (x) (if (string? x) (hl x) x))
                       (normalize-sxml
                        (map (lambda (x) (expand-docs x env)) body))))))

(define (expand-codeblock sxml env)
  `(pre ,(expand-code sxml env)))

(define (expand-example x env)
  (let ((expr `(begin ,@(sxml->sexp-list x)))
        (example-env
         (force (or (env-ref env 'example-env) (current-environment)))))
    `(div
      ,(expand-codeblock `(,(car x) language: scheme ,@(cdr x)) env)
      ,(let* ((res-out (open-output-string))
              (tmp-out (open-output-string))
              (tmp-err (open-output-string))
              (res (parameterize ((current-output-port tmp-out)
                                  (current-error-port tmp-err))
                     (protect (exn (#t (print-exception exn tmp-err)))
                       (eval expr example-env)))))
         (display "=> " res-out)
         (write res res-out)
         (let ((res-str (get-output-string res-out))
               (out-str (get-output-string tmp-out))
               (err-str (get-output-string tmp-err)))
           `(,@(if (string-null? out-str)
                   '()
                   `((div (@ (class . "output")) (pre ,(ansi->sxml out-str)))))
             ,@(if (string-null? err-str)
                   '()
                   `((div (@ (class . "error")) (pre ,(ansi->sxml err-str)))))
             ,@(if (and (or (not (string-null? err-str))
                            (not (string-null? out-str)))
                        (eq? res (if #f #f)))
                   '()
                   `((div (@ (class . "result")) (code ,res-str))))))))))

(define (expand-example-import x env)
  (eval `(import ,@(cdr x))
        (force (or (env-ref env 'example-env) (current-environment))))
  "")

(define (expand-example-import-only x env)
  (env-set! env 'example-env (apply environment (cdr x)))
  "")

(define (expand-command sxml env)
  `(pre (@ (class . "command"))
        (code ,@(map (lambda (x) (expand-docs x env)) (cdr sxml)))))

(define (expand-tagged tag ls env)
  (cons tag (map (lambda (x) (expand-docs x env)) ls)))

;;> Given the sxml document \var{sxml}, expands macros defined in the
;;> document environment \var{env} into standard html tags.

(define (expand-docs sxml env)
  (cond
   ((pair? sxml)
    (cond
     ((symbol? (car sxml))
      (let ((op (env-ref env (car sxml))))
        (cond
         ((procedure? op)
          (op sxml env))
         ((symbol? op)
          (expand-tagged op (cdr sxml) env))
         (else
          (expand-tagged (car sxml) (cdr sxml) env)))))
     (else
      (map (lambda (x) (expand-docs x env)) sxml))))
   (else
    sxml)))

(define (expand-procedure sxml env)
  ((expand-section 'h4) `(,(car sxml) (rawcode ,@(cdr sxml))) env))

(define (expand-macro sxml env)
  (expand-procedure sxml env))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; adjustments for html

(define header-index
  (let* ((headers '(h1 h2 h3 h4 h5 h6))
         (len (length headers)))
    (lambda (h) (- len (length (memq h headers))))))

;; return a list of (index . link-to-header) for all headers
(define (extract-contents x)
  (match x
    (('div ('a ('@ ('name . name)) . _)
           ((and h (or 'h1 'h2 'h3 'h4 'h5 'h6)) . section))
     (let* ((raw-text (sxml-strip (cons h section)))
            (text (if (string-prefix? "(" raw-text)
                      (let ((end (string-find
                                  raw-text
                                  (lambda (ch)
                                    (or (char-whitespace? ch)
                                        (eqv? ch #\)))))))
                        (substring raw-text 1 end))
                      raw-text)))
       `((,(header-index h)
          (a (@ (href . ,(string-append "#" name)))
             ,text)))))
    ((a . b)
     (append (extract-contents a) (extract-contents b)))
    (else
     '())))

;; nest the (index . link-to-header)s into ol
(define (get-contents x)
  (if (null? x)
      '()
      (let lp ((ls (cdr x))
               (depth (caar x))
               (parent (cadr (car x)))
               (kids '())
               (res '()))
        (define (collect)
          (cons `(li ,parent ,(get-contents (reverse kids))) res))
        ;; take a span of all sub-headers, recurse and repeat on next span
        (cond
         ((null? ls)
          `(ol ,@(reverse (collect))))
         ((> (caar ls) depth)
          (lp (cdr ls) depth parent (cons (car ls) kids) res))
         (else
          (lp (cdr ls) (caar ls) (cadr (car ls)) '() (collect)))))))

(define (fix-header x)
  `((!DOCTYPE html)
    (html (head ,@(cond ((assq 'title x) => (lambda (x) (list x)))
                        (else '()))
                "\n"
                (meta (@ (charset . "UTF-8")))
                (style (@ (type . "text/css"))
                  "
body {color: #000; background-color: #FFFFF8;}
div#menu  {font-size: smaller; position: absolute; top: 50px; left: 0; width: 250px; height: 100%}
div#menu a:link {text-decoration: none}
div#main  {font-size: large; position: absolute; top: 0; left: 260px; max-width: 590px; height: 100%}
div#notes {position: relative; top: 2em; left: 620px; width: 200px; height: 0px; font-size: smaller;}
div#footer {padding-bottom: 50px}
div#menu ol {list-style-position:inside; padding-left: 5px; margin-left: 5px}
div#menu ol ol {list-style: lower-alpha; padding-left: 15px; margin-left: 15px}
div#menu ol ol ol {list-style: decimal; padding-left: 5px; margin-left: 5px}
h2 { color: #888888; border-top: 3px solid #4588ba; }
h3 { color: #666666; border-top: 2px solid #4588ba; }
h4 { color: #222288; border-top: 1px solid #4588ba; }
.result { color: #000; background-color: #FFEADF; width: 100%; padding: 3px}
.output { color: #000; background-color: beige; width: 100%; padding: 3px}
.error { color: #000; background-color: #F0B0B0; width: 100%; padding: 3px}
.command { color: #000; background-color: #FFEADF; width: 100%; padding: 5px}
"
                  ,(highlight-style))
                "\n")
          (body
           (div (@ (id . "menu"))
                ,(let ((contents (get-contents (extract-contents x))))
                   (match contents
                     ;; flatten if we have only a single heading
                     (('ol (li y sections ...))
                      sections)
                     (else contents))))
           (div (@ (id . "main"))
                ,@(map (lambda (x)
                         (if (and (pair? x) (eq? 'title (car x)))
                             (cons 'h1 (cdr x))
                             x))
                       x)
                (div (@ (id . "footer"))))))))

(define (fix-paragraphs x)
  (let lp ((ls x) (p '()) (res '()))
    (define (collect)
      (if (pair? p) (cons `(p ,@(reverse p)) res) res))
    (define (inline? x)
      (or (string? x)
          (and (pair? x)
               (or (string? (car x))
                   (memq (car x)
                         '(a b i u span code small large sub sup em))))))
    (define (enclosing? x)
      (and (pair? x) (symbol? (car x))
           (memq (car x) '(div body))))
    (cond
     ((null? ls)
      (reverse (collect)))
     ((equal? "\n" (car ls))
      (if (and (pair? p) (equal? "\n" (car p)))
          (let lp2 ((ls (cdr ls)))
            (if (and (pair? ls) (equal? "\n" (car ls)))
                (lp2 (cdr ls))
                (lp ls '() (collect))))
          (lp (cdr ls) (cons (car ls) p) res)))
     ((inline? (car ls))
      (lp (cdr ls) (cons (car ls) p) res))
     ((enclosing? (car ls))
      (lp (cdr ls) '() (cons (car ls) (collect))))
     (else
      (lp (cdr ls) '() (cons (car ls) (collect)))))))

(define (fix-begins x)
  x)

;;> Resolves paragraphs and adds a header to convert \var{sxml} to a
;;> standalone document renderable in html.

(define (fixup-docs sxml)
  (fix-header (fix-paragraphs (fix-begins sxml))))

;;> Composes \scheme{expand-docs} and \scheme{fixup-docs}.

(define (generate-docs sxml . o)
  (let ((env (if (pair? o) (car o) (make-default-doc-env))))
    (fixup-docs (expand-docs sxml env))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; extraction

(define (skip-horizontal-whitespace in)
  (cond ((memv (peek-char in) '(#\space #\tab))
         (read-char in)
         (skip-horizontal-whitespace in))))

(define (external-clause? x)
  (not (and (pair? (cdr x)) (pair? (cadr x)) (string? (car (cadr x))))))

(define (contains? tree x)
  (or (eq? tree x)
      (and (pair? tree)
           (or (contains? (car tree) x)
               (contains? (cdr tree) x)))))

(define (form-defined-name form)
  (match form
    (('define (name . x) . y) name)
    (((or 'define 'define-syntax) name . x)
     name)
    (((or 'define-c 'define-c-const)
      t (name . x) . y)
     name)
    (((or 'define-c 'define-c-const)
      t name . x)
     name)
    (else #f)))

;; Try to determine the names of optional parameters checking common
;; patterns.
(define (get-optionals-signature ls body)
  (let lp ((ls ls) (pre '()))
    (cond
     ((pair? ls) (lp (cdr ls) (cons (car ls) pre)))
     ((null? ls) (reverse pre))
     (else
      (let* ((o ls)
             (o? (lambda (x) (eq? x o))))
        (let extract ((x body)
                      (vars '())
                      (i 0))
          (match x
            ((('define x val) . rest)
             (if (contains? val o)
                 (extract #f vars i)
                 (extract rest vars i)))
            ((((or 'let 'let* 'letrec 'letrec*) (y ...) . body) . rest)
             (let ((ordered? (memq (car x) '(let* letrec*))))
               (let lp ((ls y) (vars vars) (j i))
                 (cond
                  ((pair? ls)
                   (match (car ls)
                     ;; handle rebinding o
                     (((? o?) ('if ('pair? (? o?)) ('cdr (? o?)) default))
                      (lp (cdr ls) vars (+ j 1)))
                     (((? o?) expr)
                      (extract #f vars i))
                     ;; binding vars to o
                     ((v ('if ('pair? (? o?)) ('car (? o?)) default))
                      (lp (cdr ls) (cons (cons v (if ordered? j i)) vars) j))
                     ((v ('and ('pair? (? o?)) ('car (? o?))))
                      (lp (cdr ls) (cons (cons v (if ordered? j i)) vars) j))
                     ((v ('or ('and ('pair? (? o?)) ('car (? o?))) default))
                      (lp (cdr ls) (cons (cons v (if ordered? j i)) vars) j))
                     ((v ('if ('and ('pair? (? o?)) ('pair? ('cdr (? o?))))
                             ('cadr (? o?))
                             default))
                      (lp (cdr ls)
                          (cons (cons v (+ 1 (if ordered? j i))) vars)
                          j))
                     ((v ('and ('pair? (? o?)) ('pair? ('cdr (? o?)))
                               ('cadr (? o?))))
                      (lp (cdr ls)
                          (cons (cons v (+ 1 (if ordered? j i))) vars)
                          j))
                     (else
                      (lp (cdr ls) vars j))))
                  (else
                   (extract body vars j))))))
            ((('let (? symbol?) (y ...) . body) . rest)
             (extract `((let ,y . ,body) . ,rest) vars i))
            ((((or 'let-optionals 'let-optionals*) ls ((var default) ...)
               . body) . rest)
             (let lp ((ls var) (vars vars) (i i))
               (cond
                ((pair? ls)
                 (lp (cdr ls) (cons (cons (car ls) i) vars) (+ i 1)))
                (else
                 (extract body vars i)))))
            (_
             (let* ((opts (map car (sort vars < cdr)))
                    (rest-var? (contains? x o))
                    (tail (cond
                           ((and (pair? opts) rest-var?)
                            (list (append opts o)))
                           (rest-var?
                            o)
                           ((pair? opts)
                            (list opts))
                           (else
                            o))))
               (append (reverse pre) tail))))))))))

(define (get-procedure-signature mod id proc)
  (protect (exn (else '()))
    (cond ((and mod (procedure? proc) (procedure-signature id mod))
           => (lambda (sig)
                (list (cons (or id (procedure-name proc)) (cdr sig)))))
          (else '()))))

(define (get-value-signature mod id proc name value)
  (match value
    (((or 'let 'let* 'letrec 'letrec*) vars body0 ... body)
     (get-value-signature mod id proc name body))
    (('lambda args . body)
     (list (cons name (get-optionals-signature args body))))
    ((('lambda args body0 ... body) vals ...)
     (get-value-signature mod id proc name body))
    (('begin body0 ... body) (get-value-signature mod id proc name body))
    (else (get-procedure-signature mod id proc))))

(define (get-signature mod id proc source form)
  (match form
    (('define (name args ...) . body)
     (list (cons name args)))
    (('define (name . args) . body)
     (list (cons name (get-optionals-signature args body))))
    (('define name value)
     (get-value-signature mod id proc name value))
    (('define-syntax name ('syntax-rules () (clause . body) ...))
     ;; TODO: smarter summary merging forms
     (map (lambda (x) (cons name (cdr x)))
          (filter external-clause? clause)))
    (else
     (cond
      ((procedure-analysis proc mod)
       => (lambda (lam) (list (cons (lambda-name lam) (lambda-params lam)))))
      (else
       (get-procedure-signature mod id proc))))))

(define (get-ffi-signatures form)
  (match form
    (('define-c ret-type (or (name _) name) (args ...))
     (list (cons name
                 (map (lambda (x) (if (pair? x) (last x) x))
                      (remove (lambda (x)
                                (and (pair? x)
                                     (memq (car x) '(value result))))
                              args)))))
    (('define-c-const type (or (name _) name))
     (list (list 'const: type name)))
    (('cond-expand (test . clauses) . rest)
     (append-map get-ffi-signatures clauses))
    (((or 'define-c-struct 'define-c-class 'define-c-type) name . rest)
     (let lp ((ls rest) (res '()))
       (cond
        ((null? ls)
         (reverse res))
        ((eq? 'predicate: (car ls))
         (lp (cddr ls) (cons (list (cadr ls) 'obj) res)))
        ((eq? 'constructor: (car ls))
         (lp (cddr ls)
             (cons (if (pair? (cadr ls)) (cadr ls) (list (cadr ls))) res)))
        ((pair? (car ls))
         (lp (cdr ls)
             (append (if (pair? (cddr (cdar ls)))
                         (list (list (car (cddr (cdar ls))) name (caar ls)))
                         '())
                     (list (list (cadr (cdar ls)) name))
                     res)))
        ((symbol? (car ls))
         (lp (cddr ls) res))
        (else
         (lp (cdr ls) res)))))
    (else
     '())))

(define section-number
  (let ((sections '(section subsection subsubsection subsubsubsection)))
    (lambda (x)
      (cond ((memq x sections) => length)
            ((memq x '(procedure macro)) (section-number 'subsubsection))
            (else 0)))))

(define (section>=? x n)
  (and (pair? x)
       (if (memq (car x) '(div))
           (find (lambda (y) (section>=? y n)) (sxml-body x))
           (>= (section-number (car x)) n))))

(define (extract-sxml tag x)
  (and (pair? x)
       (cond ((if (pair? tag) (memq (car x) tag) (eq? tag (car x))) x)
             ((memq (car x) '(div))
              (any (lambda (y) (extract-sxml tag y)) (sxml-body x)))
             (else #f))))

(define (section-describes? x name)
  (let ((name (symbol->string name)))
    (and (pair? x) (pair? (cdr x))
         (let* ((str (sxml-strip (cadr x)))
                (op (string-first-token str " \t\r\n()#")))
           (or (string=? op name)
               ;; FIXME: hack for loop iterators
               (and (string=? op "for")
                    (string-contains str (string-append "(" name " "))))))))

;; write a signature handling a trailing list as [optional] parameters
(define (write-signature sig)
  (if (and (list? sig)
           (> (length sig) 1)
           (pair? (last sig))
           (not (any pair? (drop-right sig 1))))
      (call-with-output-string
        (lambda (out)
          (display "(" out)
          (write (car sig) out)
          (let lp ((ls (cdr sig)))
            (cond
             ((pair? (car ls))
              (display " [" out)
              (write (caar ls) out)
              (let lp ((ls (cdar ls)))
                (cond
                 ((pair? ls)
                  (display " " out)
                  (write (car ls) out)
                  (lp (cdr ls)))
                 ((not (null? ls))
                  (display " . " out)
                  (write ls out))))
              (display "])" out))
             (else
              (display " " out)
              (write (car ls) out)
              (lp (cdr ls)))))))
      (write-to-string sig)))

(define (insert-signature orig-ls name sig)
  (let ((sig (if (pair? sig) sig (and name (list name)))))
    (cond
    ((not (pair? sig))
     '())
    (else
     (let ((name
            (cond
             (name)
             ((not (pair? (car sig))) (car sig))
             ((eq? 'const: (caar sig)) (cadr (cdar sig)))
             (else (caar sig)))))
       (let lp ((ls orig-ls) (rev-pre '()))
         (cond
          ((or (null? ls)
               (section>=? (car ls) (section-number 'subsubsection)))
           `(,@(reverse rev-pre)
             ,@(if (and (pair? ls)
                        (section-describes?
                         (extract-sxml
                          '(subsubsection procedure macro)
                          (car ls))
                         name))
                   '()
                   `((subsubsection
                      tag: ,(write-to-string name)
                      (rawcode
                       ,@(if (and (pair? (car sig)) (eq? 'const: (caar sig)))
                             `((i ,(write-to-string (car (cdar sig))) ": ")
                               ,(write-to-string (cadr (cdar sig))))
                             (intersperse (map write-signature sig) '(br)))))))
             ,@ls))
          (else
           (lp (cdr ls) (cons (car ls) rev-pre))))))))))

;;> Extract inline Scribble documentation (with the ;;> prefix) from
;;> the source file \var{file}, associating any signatures from the
;;> provided defs when available and not overridden in the docs.

(define (extract-file-docs mod file all-defs strict? . o)
  ;; extract (<file> . <line>) macro source or
  ;; (<offset> <file . <line>) procedure source or
  ;; ((<offset> <file . <line>) ...) bytecode sources
  (define (source-line source)
    (and (pair? source)
         (cond
          ((string? (car source))
           (and (equal? file (car source))
                (number? (cdr source))
                (cdr source)))
          ((pair? (car source))
           (source-line (car source)))
          (else
           (and (number? (car source))
                (pair? (cdr source))
                (equal? file (cadr source))
                (cddr source))))))
  (define (read-to-paren in)
    (let lp1 ((res '()))
      (let ((ch (peek-char in)))
        (cond
         ((or (eof-object? ch) (eqv? #\) ch)) (read-char in) (reverse res))
         ((char-whitespace? ch) (read-char in) (lp1 res))
         ((eq? ch #\;)
          (let lp2 ()
            (let ((ch2 (read-char in)))
              (if (or (eof-object? ch2) (eqv? #\newline ch2))
                  (lp1 res)
                  (lp2)))))
         ;; TODO: support #; and #| comments at end of list
         (else (lp1 (cons (read in) res)))))))
  (call-with-input-file file
    (lambda (in)
      (let* ((lang (or (and (pair? o) (car o)) 'scheme))
             ;; filter to only defs found in this file
             (defs (filter-map
                    (lambda (x)
                      (let ((line (source-line (third x))))
                        (and line 
                             ;; (name value line)
                             `(,(car x) ,(cadr x) ,line))))
                    all-defs)))
        (let lp ((lines '())
                 (cur '())
                 (res '())
                 (ids '())
                 (depth 0)
                 (last-line 0))
          (define (collect)
            (if (pair? lines)
                (append
                 (reverse
                  (call-with-input-string
                      (string-concatenate (reverse lines) "\n")
                    scribble-parse))
                 cur)
                cur))
          (define (get-ids sxml)
            (match sxml
              (((or 'procedure 'macro) x)
               (cond
                ((string? x)
                 (list
                  (string->symbol
                   (string-trim (car (string-split x))
                                (lambda (ch) (or (eq? ch #\() (eq? ch #\))))))))
                (else
                 '())))
              ((x ...) (append-map get-ids x))
              (else '())))
          (skip-horizontal-whitespace in)
          (cond
           ((eof-object? (peek-char in))
            (append (collect) res))
           ((eqv? #\newline (peek-char in))
            (read-char in)
            (lp lines cur res ids depth last-line))
           ((eqv? #\; (peek-char in))
            (read-char in)
            (cond
             ((and (eqv? #\; (peek-char in))
                   (begin (read-char in) (eqv? #\> (peek-char in))))
              (read-char in)
              (if (eqv? #\space (peek-char in)) (read-char in))
              (lp (cons (read-line in) lines) cur res ids depth last-line))
             (else
              (let lp ()
                (cond ((eqv? #\; (peek-char in))
                       (read-char in)
                       (lp))))
              (let* ((line (read-line in))
                     (cur (collect))
                     (ids (append (get-ids cur) ids)))
                ;; ";;/" attaches the docs to the preceding form
                ;; rather than the next
                (cond
                 ((equal? line "/")
                  (lp '() '() (append cur res) ids depth last-line))
                 (else
                  (cond
                   ((and (not (equal? line ""))
                         (eqv? #\/ (string-ref line 0)))
                    (display "WARNING: ;;/ line should be empty"
                             (current-error-port))
                    (write line (current-error-port))
                    (newline (current-error-port))))
                  (lp '() cur res ids depth last-line)))))))
           ((eqv? #\) (peek-char in))
            (read-char in)
            (if (zero? depth)
                (error "unexpected ) at line" last-line)
                (lp lines cur res ids (- depth 1) last-line)))
           ((not (eqv? #\( (peek-char in)))
            ;; ignore non-list top-level expression
            (read in)
            (lp lines cur res ids depth (port-line in)))
           (else  ;; found a top-level expression
            (read-char in)
            (let ((op (read in)))
              (case op
                ((begin define-library)
                 ;; allowed nested docs in these forms
                 (lp lines cur res ids (+ depth 1) (port-line in)))
                (else
                 ;; read until closing paren
                 (let* ((cur (collect))
                        (ids (append (get-ids cur) ids))
                        (form (cons op (read-to-paren in)))
                        (id (form-defined-name form))
                        (line (port-line in))
                        ;; find all procedures defined by form
                        (procs2 (filter (lambda (x) (<= last-line (third x) line))
                                        (filter third defs)))
                        (procs (if (= 2 (length procs2))
                                   (cdr procs2)
                                   procs2))
                        ;; the the signature for the form
                        (sigs
                         (cond
                          ((eq? lang 'ffi)
                           (filter
                            (lambda (x)
                              (assq (if (eq? 'const: (car x)) (third x) (car x))
                                    all-defs))
                            (get-ffi-signatures form)))
                          ((= 1 (length procs))
                           (get-signature
                            mod id (caar procs) (cdar procs) form))
                          (else
                           (get-signature
                            mod id (and id mod (module-ref mod id)) #f form)))))
                   (cond
                    ((and strict?
                          (or (not (pair? sigs)) (not (assq (caar sigs) defs))))
                     ;; drop unrelated docs in strict mode
                     (lp '() '() res ids depth line))
                    ((and (eq? lang 'ffi) (pair? sigs))
                     (lp '() '() (append (insert-signature cur #f sigs) res)
                         ids depth line))
                    ((and (memq lang '(scheme module)) (= 1 (length procs)))
                     (lp '() '()
                         (append (insert-signature cur (caar procs) sigs) res)
                         ids depth line))
                    ((and (null? procs)
                          (and (not (memq id ids)) (assq id all-defs)))
                     (let ((sigs (if (and (null? sigs) id)
                                     (list id)
                                     sigs)))
                       (lp '() '() (append (insert-signature cur #f sigs) res)
                           ids depth line)))
                    (else
                     (lp '() '() (append cur res) ids depth line))))))))))))))

;; utility to get the source position of an object
(define (object-source x)
  (cond ((opcode? x) #f)
        ((bytecode? x)
         (let ((src (bytecode-source x)))
           (if (and (vector? src) (positive? (vector-length src)))
               (vector-ref src 0)
               src)))
        ((procedure? x) (object-source (procedure-code x)))
        ((macro? x) (macro-source x))
        (else #f)))

;; helper for below functions
(define (extract-module-docs-from-files mod srcs includes stubs strict? exports . o)
  (let ((dir (or (and (pair? o) (car o)) (module-dir mod)))
        (defs (map (lambda (x)
                     (let ((val (and mod (protect (exn (else #f))
                                           (module-ref mod x)))))
                       `(,x ,val ,(object-source val))))
                   exports)))
    (define (resolve-file file)
      (let ((res (make-path dir file)))
        (if (file-exists? res)
            res
            file)))
    (append
     (reverse
      (append-map (lambda (x)
                    (extract-file-docs mod (resolve-file x) defs strict? 'module))
                  srcs))
     (reverse
      (append-map (lambda (x) (extract-file-docs mod (resolve-file x) defs strict?))
                  includes))
     (reverse
      (append-map (lambda (x) (extract-file-docs mod (resolve-file x) defs strict? 'ffi))
                  stubs)))))

;;> Extract the literate Scribble docs from module \var{mod-name} and
;;> return them as sxml.  If \var{strict?} is true ignore docs for
;;> unexported values, defined by the optional \var{exports} which
;;> defaults to all the module exports.

(define (extract-module-docs mod-name strict? . o)
  (let ((mod (load-module mod-name)))
    (if (not mod)
        (error "couldn't find module" mod-name))
    (let* ((exports (if (pair? o) (car o) (module-exports mod)))
           (srcs
            (append
             (cond ((find-module-file (module-name->file mod-name)) => list)
                   (else '()))
             (module-include-library-declarations mod))))
      (extract-module-docs-from-files
       mod srcs (module-includes mod) (module-shared-includes mod)
       strict? exports))))

;;> As above, but extracts docs for the module defined in \var{file},
;;> which need not be in the search path.

(define (extract-module-file-docs file strict? . o)
  (let ((forms (file->sexp-list file)))
    (if (not (and (pair? forms) (pair? (car forms))
                  (memq (caar forms) '(define-library library))))
        (error "file doesn't define a library" file))
    (let* ((mod-form (car forms))
           (mod-name (cadr mod-form))
           (lib-dir (module-lib-dir file mod-name))
           (orig-mod-path (current-module-path))
           (new-mod-path (cons lib-dir orig-mod-path))
           (mod (protect (exn (else #f))
                  (dynamic-wind
                    (lambda () (current-module-path new-mod-path))
                    (lambda ()
                      (let ((mod (load-module mod-name)))
                        (protect (exn (else #f)) (analyze-module mod-name))
                        mod))
                    (lambda () (current-module-path orig-mod-path)))))
           (dir (path-directory file)))
      (define (get-forms ls names dir . o)
        (let ((resolve? (and (pair? o) (car o))))
          (let lp ((ls ls) (res '()))
            (if (null? ls)
                (reverse res)
                (let ((x (car ls)))
                  (lp (cdr ls)
                      (append
                       (if (and (pair? x) (memq (car x) names))
                           (map (lambda (y)
                                  (if (and resolve? (string? y))
                                      (make-path dir y)
                                      y))
                                (reverse (cdr x)))
                           '())
                       (if (and (pair? x)
                                (eq? 'include-library-declarations (car x)))
                           (append-map
                            (lambda (inc)
                              (let* ((file (make-path dir inc))
                                     (sexps (file->sexp-list file))
                                     (dir (path-directory file)))
                                (get-forms sexps names dir resolve?)))
                            (cdr x))
                           '())
                       res)))))))
      (define (get-exports)
        (if mod (module-exports mod) (get-forms (cddr mod-form) '(exports) dir)))
      (define (get-decls)
        (get-forms (cddr mod-form) '(include-library-declarations) dir #t))
      (define (get-includes)
        (get-forms (cddr mod-form) '(include include-ci) dir #t))
      (define (get-shared-includes)
        (map (lambda (f) (string-append f ".stub"))
             (get-forms (cddr mod-form) '(include-shared) dir #t)))
      (let* ((exports (if (pair? o) (car o) (get-exports)))
             (srcs (cons file (get-decls))))
        (extract-module-docs-from-files
         mod srcs (get-includes) (get-shared-includes) strict? exports)))))

;;> \section{Additional accessors}

;;> Retrieve a 16-bit unsigned integer value from the given bytevector
;;> \var{bv} at offset \var{i}, in little-endian order.

(define (bytevector-u16-ref-le bv i)
  (+ (bytevector-u8-ref bv i)
     (arithmetic-shift (bytevector-u8-ref bv (+ i 1)) 8)))

;;> Retrieve a 16-bit unsigned integer value from the given bytevector
;;> \var{bv} at offset \var{i}, in big-endian order.

(define (bytevector-u16-ref-be bv i)
  (+ (arithmetic-shift (bytevector-u8-ref bv i) 8)
     (bytevector-u8-ref bv (+ i 1))))

;;> Retrieve a 32-bit unsigned integer value from the given bytevector
;;> \var{bv} at offset \var{i}, in little-endian order.

(define (bytevector-u32-ref-le bv i)
  (+ (bytevector-u8-ref bv i)
     (arithmetic-shift (bytevector-u8-ref bv (+ i 1)) 8)
     (arithmetic-shift (bytevector-u8-ref bv (+ i 2)) 16)
     (arithmetic-shift (bytevector-u8-ref bv (+ i 3)) 24)))

;;> Retrieve a 32-bit unsigned integer value from the given bytevector
;;> \var{bv} at offset \var{i}, in big-endian order.

(define (bytevector-u32-ref-be bv i)
  (+ (arithmetic-shift (bytevector-u8-ref bv i) 24)
     (arithmetic-shift (bytevector-u8-ref bv (+ i 1)) 16)
     (arithmetic-shift (bytevector-u8-ref bv (+ i 2)) 8)
     (bytevector-u8-ref bv (+ i 3))))

;;> \section{Bignum encodings}

;;> A BER compressed integer (X.209) is an unsigned integer in base 128,
;;> most significant digit first, where the high bit is set on all but the
;;> final (least significant) byte.  Thus any size integer can be
;;> encoded, but the encoding is efficient and small integers don't take
;;> up any more space than they would in normal char/short/int encodings.

(define (bytevector-ber-ref bv . o)
  (let ((end (if (and (pair? o) (pair? (cdr o)))
                 (cadr o)
                 (bytevector-length bv))))
    (let lp ((acc 0) (i (if (pair? o) (car o) 0)))
      (if (>= i end)
          (error "unterminated ber integer in bytevector" bv)
          (let ((b (bytevector-u8-ref bv i)))
            (if (< b 128)
                (+ acc b)
                (lp (arithmetic-shift (+ acc (bitwise-and b 127)) 7)
                    (+ i 1))))))))

(define (bytevector-ber-set! bv n . o)
  ;;(assert (integer? number) (not (negative? number)))
  (let ((start (if (pair? o) (car o) 0))
        (end (if (and (pair? o) (pair? (cdr o)))
                 (cadr o)
                 (bytevector-length bv))))
    (let lp ((n (arithmetic-shift n -7))
             (ls (list (bitwise-and n 127))))
      (if (zero? n)
          (do ((i start (+ i 1))
               (ls ls (cdr ls)))
              ((null? ls))
            (if (>= i end)
                (error "integer doesn't fit in bytevector as ber"
                       bv n start end)
                (bytevector-u8-set! bv i (car ls))))
          (lp (arithmetic-shift n -7)
              (cons (+ 128 (bitwise-and n 127)) ls))))))

;;> \section{Integer conversion}

;;> Convert an unsigned integer \var{n} to a bytevector representing
;;> the base-256 big-endian form (the zero index holds the MSB).

(define (integer->bytevector n)
  (cond
   ((zero? n)
    (make-bytevector 1 0))
   ((negative? n)
    (error "can't convert a negative integer to bytevector" n))
   (else
    (let lp ((n n) (res '()))
      (if (zero? n)
          (let* ((len (length res))
                 (bv (make-bytevector len 0)))
            (do ((i 0 (+ i 1))
                 (ls res (cdr ls)))
                ((= i len) bv)
              (bytevector-u8-set! bv i (car ls))))
          (lp (quotient n 256) (cons (remainder n 256) res)))))))

;;> The inverse of \scheme{integer->bytevector}.  Convert a bytevector
;;> representing the base-256 big-endian form (the zero index holds
;;> the MSB) to the corresponding unsigned integer.

(define (bytevector->integer bv)
  (let ((len (bytevector-length bv)))
    (let lp ((i 0) (n 0))
      (if (>= i len)
          n
          (lp (+ i 1)
              (+ (arithmetic-shift n 8)
                 (bytevector-u8-ref bv i)))))))

;;> Utility to pad a bytevector with zeros.  Padding is added to the
;;> left so as not to change the big-endian value.

(define (bytevector-pad-left bv len)
  (let ((diff (- len (bytevector-length bv))))
    (if (positive? diff)
        (bytevector-append bv (make-bytevector diff 0))
        bv)))

;;> \section{Hex string conversion}

;;> Big-endian conversion, guaranteed padded to even length.

(define (integer->hex-string n)
  (let* ((res (number->string n 16))
         (len (string-length res)))
    (if (even? len)
        res
        (string-append "0" res))))

(define (hex-string->integer str)
  (string->number str 16))

(define (bytevector->hex-string bv)
  (let ((out (open-output-string))
        (len (bytevector-length bv)))
    (let lp ((i 0))
      (cond
       ((>= i len)
        (get-output-string out))
       (else
        (write-string (integer->hex-string (bytevector-u8-ref bv i)) out)
        (lp (+ i 1)))))))

(define (hex-string->bytevector str)
  (integer->bytevector (hex-string->integer str)))
(define-library (chibi memoize-test)
  (export run-tests)
  (import (scheme base) (scheme file) (chibi memoize) (chibi test))
  (begin
    (define (run-tests)
      (test-begin "memoize")

      (let ()
        (define-memoized (fib n)
          (if (<= n 1)
              1
              (+ (fib (- n 1)) (fib (- n 2)))))
        (test 1 (fib 1))
        (test 573147844013817084101 (fib 100)))

      (let ()
        (define-memoized (ack m n)
          (cond
           ((= m 0) (+ n 1))
           ((= n 0) (ack (- m 1) 1))
           (else (ack (- m 1) (ack m (- n 1))))))
        (test 29 (ack 3 2))
        (test 61 (ack 3 3)))

      (let ((n 0))
        (let ((f (memoize (lambda (x) (set! n (+ n 1)) (* x x)))))
          (test 0 n)
          (test 9 (f 3))
          (test 1 n)
          (test 9 (f 3))
          (test 1 n)))

      (let ((n 0))
        (let ((f (memoize (lambda (x) (set! n (+ n 1)) (* x x))
                          'size-limit: #f)))
          (test 0 n)
          (test 9 (f 3))
          (test 1 n)
          (test 9 (f 3))
          (test 1 n)))

      (letrec ((fib (lambda (n)
                      (if (<= n 1)
                          1
                          (+ (fib (- n 1)) (fib (- n 2)))))))
        (let ((f (memoize-to-file fib 'memo-dir: "/tmp/memo.d/")))
          (test 89 (f 10))
          (test-assert (file-exists? "/tmp/memo.d/10.memo"))
          (test 89 (f 10))))

      (test-end))))

(define-library (chibi base64)
  (export base64-encode base64-encode-string base64-encode-bytevector
          base64-decode base64-decode-string base64-decode-bytevector
          base64-encode-header)
  (import (scheme base)
          (chibi string))
  (cond-expand
   ((library (srfi 151))
    (import (srfi 151)))
   ((library (srfi 33))
    (import (srfi 33))
    (begin
      (define (%mask size) (bitwise-not (arithmetic-shift -1 size)))
      (define (bit-field n start end)
        (bitwise-and (arithmetic-shift n (- start)) (mask (- end start))))))
   (else
    (import (srfi 60))
    (begin
      (define (%mask size) (bitwise-not (arithmetic-shift -1 size)))
      (define (bit-field n start end)
        (bitwise-and (arithmetic-shift n (- start)) (mask (- end start)))))))
  (cond-expand
   (chibi (import (chibi io)))
   (else
    (begin
      (define (port->string in)
        (let ((out (open-output-string)))
          (let lp ()
            (let ((ch (read-char in)))
              (cond
               ((eof-object? ch)
                (get-output-string out))
               (else
                (write-char ch out)
                (lp))))))))))
  (include "base64.scm"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Cursors

;;> Returns true iff \var{iset} is empty.

(define (iset-empty? iset)
  (and (iset? iset)
       (cond ((iset-bits iset) => zero?) (else #f))
       (let ((l (iset-left iset))) (or (not l) (iset-empty? l)))
       (let ((r (iset-right iset))) (or (not r) (iset-empty? r)))))

(define-record-type Iset-Cursor
  (make-iset-cursor node pos stack)
  iset-cursor?
  (node iset-cursor-node iset-cursor-node-set!)
  (pos iset-cursor-pos iset-cursor-pos-set!)
  (stack iset-cursor-stack iset-cursor-stack-set!))

(define (%iset-cursor iset . o)
  (iset-cursor-advance
   (make-iset-cursor iset
                     (or (iset-bits iset) (iset-start iset))
                     (if (pair? o) (car o) '()))))

;;> Create a new iset cursor pointing to the first element of iset,
;;> with an optional stack argument.

(define (iset-cursor iset . o)
  (let ((stack (if (pair? o) (car o) '())))
    (if (iset-left iset)
        (iset-cursor (iset-left iset) (cons iset stack))
        (%iset-cursor iset stack))))

;; Continue to the next node in the search stack.
(define (iset-cursor-pop cur)
  (let ((node (iset-cursor-node cur))
        (stack (iset-cursor-stack cur)))
    (cond
     ((iset-right node)
      (iset-cursor (iset-right node) stack))
     ((pair? stack)
      (%iset-cursor (car stack) (cdr stack)))
     (else
      cur))))

;; Advance to the next node+pos that can be referenced if at the end
;; of this node's range.
(define (iset-cursor-advance cur)
  (let ((node (iset-cursor-node cur))
        (pos (iset-cursor-pos cur)))
    (cond
     ((if (iset-bits node) (zero? pos) (> pos (iset-end node)))
      (iset-cursor-pop cur))
     (else cur))))

;;> Return a new iset cursor pointing to the next element of
;;> \var{iset} after \var{cur}.  If \var{cur} is already at
;;> \scheme{end-of-iset?}, the resulting cursor is as well.

(define (iset-cursor-next iset cur)
  (iset-cursor-advance
   (let ((node (iset-cursor-node cur))
         (pos (iset-cursor-pos cur))
         (stack (iset-cursor-stack cur)))
     (let ((pos (if (iset-bits node) (bitwise-and pos (- pos 1)) (+ pos 1))))
       (make-iset-cursor node pos stack)))))

;;> Return the element of iset \var{iset} at cursor \var{cur}.  If the
;;> cursor is at \scheme{end-of-iset?}, raises an error.

(define (iset-ref iset cur)
  (let ((node (iset-cursor-node cur))
        (pos (iset-cursor-pos cur)))
    (cond
     ((iset-bits node)
      (if (zero? pos)
          (error "cursor reference past end of iset")
          (+ (iset-start node)
             (integer-length (- pos (bitwise-and pos (- pos 1))))
             -1)))
     (else
      (if (> pos (iset-end node))
          (error "cursor reference past end of iset")
          pos)))))

;;> Returns true iff \var{cur} is at the end of iset, such that
;;> \scheme{iset-ref} is no longer valid.

(define (end-of-iset? cur)
  (let ((node (iset-cursor-node cur)))
    (and (if (iset-bits node)
             (zero? (iset-cursor-pos cur))
             (> (iset-cursor-pos cur) (iset-end node)))
         (not (iset-right node))
         (null? (iset-cursor-stack cur)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Rank/Select operations, acting directly on isets without an
;; optimized data structure.

(define (iset-node-size iset)
  (if (iset-bits iset)
      (bit-count (iset-bits iset))
      (+ 1 (- (iset-end iset) (iset-start iset)))))

;; Number of bits set in i below index n.
(define (bit-rank i n)
  (bit-count (bitwise-and i (- (arithmetic-shift 1 n) 1))))

;;> Returns the rank (i.e. index within the iset) of the given
;;> element, a number in [0, size).  This can be used to compress an
;;> integer set to a minimal consecutive set of integets.  Can also be
;;> thought of as the number of elements in iset smaller than element.
(define (iset-rank iset element)
  (let lp ((iset iset) (count 0))
    (cond
     ((< element (iset-start iset))
      (if (iset-left iset)
          (lp (iset-left iset) count)
          (error "integer not in iset" iset element)))
     ((> element (iset-end iset))
      (if (iset-right iset)
          (lp (iset-right iset)
              (+ count
                 (cond ((iset-left iset) => iset-size) (else 0))
                 (iset-node-size iset)))
          (error "integer not in iset" iset element)))
     ((iset-bits iset)
      (+ count
         (cond ((iset-left iset) => iset-size) (else 0))
         (bit-rank (iset-bits iset)
                   (- element (iset-start iset)))))
     (else
      (+ count
         (cond ((iset-left iset) => iset-size) (else 0))
         (integer-length (- element (iset-start iset))))))))

(define (nth-set-bit i n)
  ;; TODO: optimize
  (if (zero? n)
      (first-set-bit i)
      (nth-set-bit (bitwise-and i (- i 1)) (- n 1))))

;;> Selects the index-th element of iset starting at 0.  The inverse
;;> operation of \scheme{iset-rank}.
(define (iset-select iset index)
  (let lp ((iset iset) (index index) (stack '()))
    (if (and iset (iset-left iset))
        (lp (iset-left iset) index (cons iset stack))
        (let ((iset (if iset iset (car stack)))
              (stack (if iset stack (cdr stack))))
          (let ((node-size (iset-node-size iset)))
            (cond
             ((and (< index node-size) (iset-bits iset))
              (+ (iset-start iset)
                 (nth-set-bit (iset-bits iset) index)))
             ((< index node-size)
              (+ (iset-start iset) index))
             ((iset-right iset)
              (lp (iset-right iset) (- index node-size) stack))
             ((pair? stack)
              (lp #f  (- index node-size) stack))
             (else
              (error "iset index out of range" iset index))))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Equality

(define (iset2= is1 is2)
  (let lp ((cur1 (iset-cursor is1))
           (cur2 (iset-cursor is2)))
    (cond ((end-of-iset? cur1) (end-of-iset? cur2))
          ((end-of-iset? cur2) #f)
          ((= (iset-ref is1 cur1) (iset-ref is2 cur2))
           (lp (iset-cursor-next is1 cur1) (iset-cursor-next is2 cur2)))
          (else
           #f))))

(define (iset2<= is1 is2)
  (let lp ((cur1 (iset-cursor is1))
           (cur2 (iset-cursor is2)))
    (cond ((end-of-iset? cur1))
          ((end-of-iset? cur2) #f)
          (else
           (let ((i1 (iset-ref is1 cur1))
                 (i2 (iset-ref is1 cur2)))
             (cond ((> i1 i2)
                    (lp cur1 (iset-cursor-next is2 cur2)))
                   ((= i1 i2)
                    (lp (iset-cursor-next is1 cur1)
                        (iset-cursor-next is2 cur2)))
                   (else
                    ;; (< i1 i2) - i1 won't occur in is2
                    #f)))))))

;;> Returns true iff all arguments contain the same elements.  Always
;;> returns true if there are less than two arguments.

(define (iset= . o)
  (or (null? o)
      (let lp ((a (car o)) (ls (cdr o)))
        (or (null? ls) (and (iset2= a (car ls)) (lp (car ls) (cdr ls)))))))

;;> Returns true iff the arguments are monotonically increasing, that
;;> is each argument contains every element of all preceding
;;> arguments.  Always returns true if there are less than two
;;> arguments.

(define (iset<= . o)
  (or (null? o)
      (let lp ((a (car o)) (ls (cdr o)))
        (or (null? ls) (and (iset2<= a (car ls)) (lp (car ls) (cdr ls)))))))

;;> Returns true iff the arguments are monotonically decreasing, that
;;> is each argument contains every element of all succeeding
;;> arguments.  Always returns true if there are less than two
;;> arguments.

(define (iset>= . o)
  (apply iset<= (reverse o)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Folding

(define (iset-fold-node kons knil iset)
  (let lp ((is iset) (acc knil))
    (let* ((left (iset-left is))
           (acc (kons is (if left (lp left acc) acc)))
           (right (iset-right is)))
      (if right (lp right acc) acc))))

;;> The fundamental iset iterator.  Applies \var{kons} to every
;;> element of \var{iset} along with an accumulator, starting with
;;> \var{knil}.  Returns \var{knil} if \var{iset} is empty.

(define (iset-fold kons knil iset)
  (iset-fold-node
   (lambda (is acc)
     (let ((start (iset-start is))
           (end (iset-end is))
           (bits (iset-bits is)))
       (if bits
           (let ((limit (+ 1 (- end start))))
             (do ((n1 bits n2)
                  (n2 (bitwise-and bits (- bits 1)) (bitwise-and n2 (- n2 1)))
                  (acc acc (kons (+ start (integer-length (- n1 n2)) -1) acc)))
                 ((zero? n1) acc)))
           (do ((i start (+ i 1))
                (acc acc (kons i acc)))
               ((> i end) acc)))))
   knil
   iset))

(define (iset-for-each-node proc iset)
  (iset-fold-node (lambda (node acc) (proc node)) #f iset))

;;> Runs \var{proc} on every element of iset, discarding the results.

(define (iset-for-each proc iset)
  (iset-fold (lambda (i acc) (proc i)) #f iset))

;;> Returns a list of every integer in \var{iset} in sorted
;;> (increasing) order.

(define (iset->list iset)
  (reverse (iset-fold cons '() iset)))

;;> Returns the number of elements in \var{iset}.

(define (iset-size iset)
  (iset-fold-node
   (lambda (is acc) (+ acc (iset-node-size is)))
   0
   iset))

(define-library (chibi iset constructors)
  (cond-expand
   (chibi (import (chibi)))
   (else (import (scheme base))))
  (import (chibi iset base) (chibi iset iterators))
  (cond-expand
   ((library (srfi 151)) (import (srfi 151)))
   ((library (srfi 33)) (import (srfi 33)))
   (else (import (srfi 60))))
  (include "constructors.scm")
  (export
   iset iset-copy list->iset list->iset! iset-map
   iset-adjoin iset-adjoin! iset-delete iset-delete!
   iset-union iset-union! iset-intersection iset-intersection!
   iset-difference iset-difference!
   ;; low-level
   iset-copy-node iset-squash-bits! iset-insert-left! iset-insert-right!))

(define-library (chibi iset iterators)
  (cond-expand
   (chibi (import (chibi) (srfi 9)))
   (else (import (scheme base))))
  (import (chibi iset base))
  (cond-expand
   ((library (srfi 151)) (import (srfi 151)))
   ((library (srfi 33)) (import (srfi 33)))
   (else (import (srfi 60))))
  (include "iterators.scm")
  (export
   iset-empty? iset-fold iset-fold-node iset-for-each iset-for-each-node
   iset->list iset-size iset= iset<= iset>=
   ;; rank/select
   iset-rank iset-select
   ;; low-level cursors
   iset-cursor iset-cursor? iset-cursor-next iset-ref end-of-iset?))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Utilities for constructing and joining isets.

(define bits-thresh 128)  ; within 128 we join into a bitmap
;;(define bits-max 512)     ; don't make bitmaps larger than this

(define (bit-set n index)
  (bitwise-ior n (arithmetic-shift 1 index)))

(define (bit-clear n index)
  (if (bit-set? index n)
      (- n (arithmetic-shift 1 index))
      n))

;;> Create a new iset composed of each of the integers in \var{args}.

(define (iset . args)
  (list->iset args))

;;> Returns an iset with all integers in the list \var{ls} added to
;;> \var{iset}, possibly mutating \var{iset} in the process.

(define (list->iset! ls iset)
  (for-each (lambda (i) (iset-adjoin1! iset i)) ls)
  iset)

;;> Returns an iset with all integers in the list \var{ls}.  If the
;;> optional argument \var{iset} is provided, also includes all
;;> elements in \var{iset}, leaving \var{iset} unchanged.

(define (list->iset ls . opt)
  (list->iset! ls (if (pair? opt) (iset-copy (car opt)) (make-iset))))

(define (iset->node-list a)
  (reverse (iset-fold-node cons '() a)))

;;> Returns a new copy of \var{iset}.

(define (iset-copy iset)
  (and iset
       (%make-iset
        (iset-start iset)
        (iset-end iset)
        (iset-bits iset)
        (iset-copy (iset-left iset))
        (iset-copy (iset-right iset)))))

(define (iset-copy-node iset)
  (%make-iset (iset-start iset) (iset-end iset) (iset-bits iset) #f #f))

(define (iset-max-end iset)
  (cond ((iset-right iset) => iset-max-end)
        (else (iset-end iset))))

(define (iset-min-start iset)
  (cond ((iset-left iset) => iset-min-start)
        (else (iset-start iset))))

(define (iset-insert-left! iset new)
  (let ((left (iset-left iset)))
    (if (and left (< (iset-end new) (iset-start left)))
        (iset-right-set! new left)
        (iset-left-set! new left)))
  (iset-left-set! iset new))

(define (iset-insert-right! iset new)
  (let ((right (iset-right iset)))
    (if (and right (< (iset-end new) (iset-start right)))
        (iset-right-set! new right)
        (iset-left-set! new right)))
  (iset-right-set! iset new))

(define (range->bits start end)
  (- (arithmetic-shift 1 (+ 1 (- end start))) 1))

(define (iset-squash-bits! iset)
  (let ((bits (iset-bits iset)))
    (if (and bits (= bits (range->bits (iset-start iset) (iset-end iset))))
        (iset-bits-set! iset #f))))

(define (iset-should-merge-left? a b)
  (and (< (- (iset-start a) (iset-end b))
          bits-thresh)
       (or (not (iset-left a))
           (> (iset-start b) (iset-max-end (iset-left a))))))

(define (iset-should-merge-right? a b)
  (and (< (- (iset-start b) (iset-end a))
          bits-thresh)
       (or (not (iset-right a))
           (< (iset-end b) (iset-min-start (iset-right a))))))

(define (iset-merge-left! a b)
  (if (or (iset-bits a) (iset-bits b)
          (< (+ 1 (iset-end b)) (iset-start a)))
      (let* ((a-bits (or (iset-bits a)
                         (range->bits (iset-start a) (iset-end a))))
             (b-bits (or (iset-bits b)
                         (range->bits (iset-start b) (iset-end b))))
             (shift (- (iset-start a) (iset-start b)))
             (bits (bitwise-ior b-bits (arithmetic-shift a-bits shift))))
        (iset-bits-set! a bits)))
  (iset-start-set! a (iset-start b)))

(define (iset-merge-right! a b)
  (if (or (iset-bits a) (iset-bits b)
          (< (+ 1 (iset-end a)) (iset-start b)))
      (let* ((a-bits (or (iset-bits a)
                         (range->bits (iset-start a) (iset-end a))))
             (b-bits (or (iset-bits b)
                         (range->bits (iset-start b) (iset-end b))))
             (shift (- (iset-start b) (iset-start a)))
             (bits (bitwise-ior a-bits (arithmetic-shift b-bits shift))))
        (iset-bits-set! a bits)))
  (iset-end-set! a (iset-end b)))

(define (iset-adjoin1! is n)
  (iset-adjoin-node! is (%make-iset n n #f #f #f)))

;; adjoin just the node b (ignoring left/right) to the full iset a
(define (iset-adjoin-node! a b)
  (cond
   ((iset-empty? a)
    (iset-start-set! a (iset-start b))
    (iset-end-set! a (iset-end b))
    (iset-bits-set! a (iset-bits b)))
   ((not (iset-empty? b))
    (let ((a-start (iset-start a))
          (a-end (iset-end a))
          (a-bits (iset-bits a))
          (b-start (iset-start b))
          (b-end (iset-end b))
          (b-bits (iset-bits b)))
      (cond
       ;;         aaaa...
       ;; ...bbbb
       ((<= b-end a-start)
        (if (iset-should-merge-left? a b)
            (iset-merge-left! a b)
            (iset-adjoin-node-left! a b)))
       ;; ...aaaa
       ;;         bbbb...
       ((>= b-start a-end)
        (if (iset-should-merge-right? a b)
            (iset-merge-right! a b)
            (iset-adjoin-node-right! a b)))
       ;; ...aaaaa...
       ;;  ...bb...
       ((and (>= b-start a-start) (<= b-end a-end))
        (if a-bits
            (let ((b-bits (arithmetic-shift
                           (or b-bits (range->bits b-start b-end))
                           (- b-start a-start))))
              (iset-bits-set! a (bitwise-ior a-bits b-bits))
              (iset-squash-bits! a))))
       (else
        ;; general case: split, recurse, join sides
        (let ((ls (iset-node-split b a-start a-end)))
          (if (car ls)
              (iset-adjoin-node-left! a (car ls)))
          (iset-adjoin-node! a (cadr ls))
          (if (car (cddr ls))
              (iset-adjoin-node-right! a (car (cddr ls)))))))))))

(define (iset-adjoin-node-left! iset node)
  (if (iset-left iset)
      (iset-adjoin-node! (iset-left iset) node)
      (iset-left-set! iset (iset-copy-node node))))

(define (iset-adjoin-node-right! iset node)
  (if (iset-right iset)
      (iset-adjoin-node! (iset-right iset) node)
      (iset-right-set! iset (iset-copy-node node))))

;; start and/or end are inside the node, split into:
;;   1. node before start, if any
;;   2. node between start and end
;;   3. node after end, if any
(define (iset-node-split node start end)
  (list (and (< (iset-start node) start)
             (iset-node-extract node (iset-start node) (- start 1)))
        (iset-node-extract node start end)
        (and (> (iset-end node) end)
             (iset-node-extract node (+ end 1) (iset-end node)))))

(define (iset-node-extract node start end)
  (cond
   ((iset-bits node)
    => (lambda (node-bits)
         (let* ((bits
                 (bitwise-and
                  (arithmetic-shift node-bits (- (iset-start node) start))
                  (range->bits start end)))
                (new-end (min end (+ start (integer-length bits)))))
           (%make-iset start new-end bits #f #f))))
   (else
    (%make-iset (max start (iset-start node))
                (min end (iset-end node))
                #f #f #f))))

;;> Returns an iset with the integers in \var{ls} added to \var{iset},
;;> possibly mutating \var{iset} in the process.

(define (iset-adjoin! iset . ls)
  (list->iset! ls iset))

;;> Returns an iset with the integers in \var{ls} added to \var{iset},
;;> without changing \var{iset}.

(define (iset-adjoin iset . ls)
  (list->iset ls iset))

;; delete directly in this node
(define (%iset-delete1! iset n)
  (let ((start (iset-start iset))
        (end (iset-end iset))
        (bits (iset-bits iset)))
    (cond
     (bits
      (iset-bits-set! iset (bit-clear bits (- n start))))
     ((= n start)
      (if (= n end)
          (iset-bits-set! iset 0)
          (iset-start-set! iset (+ n 1))))
     ((= n end)
      (iset-end-set! iset (- n 1)))
     (else
      (iset-end-set! iset (- n 1))
      (iset-insert-right! iset (make-iset (+ n 1) end))))))

(define (iset-delete1! iset n)
  (let lp ((is iset))
    (let ((start (iset-start is)))
      (if (< n start)
          (let ((left (iset-left is)))
            (if left (lp left)))
          (let ((end (iset-end is)))
            (if (> n end)
                (let ((right (iset-right is)))
                  (if right (lp right)))
                (%iset-delete1! is n)))))))

;;> Returns an iset with the integers in \var{ls} removed (if present)
;;> from \var{iset}, possibly mutating \var{iset} in the process.

(define (iset-delete! iset . args)
  (for-each (lambda (i) (iset-delete1! iset i)) args)
  iset)

;;> Returns an iset with the integers in \var{ls} removed (if present)
;;> from \var{iset}, without changing \var{iset}.

(define (iset-delete iset . args)
  (apply iset-delete! (iset-copy iset) args))

;;> Returns an iset composed of the integers resulting from applying
;;> \var{proc} to every element of \var{iset}.

(define (iset-map proc iset)
  (iset-fold (lambda (i is) (iset-adjoin! is (proc i))) (make-iset) iset))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; High-level set operations.

(define (iset-union2! a b)
  (iset-for-each-node
   (lambda (is)
     (iset-adjoin-node! a is))
   b))

(define (iset-union! . args)
  (let* ((a (and (pair? args) (car args)))
         (b (and (pair? args) (pair? (cdr args)) (cadr args))))
    (cond
     (b
      (iset-union2! a b)
      (apply iset-union! a (cddr args)))
     (a a)
     (else (make-iset)))))

;;> Returns an iset containing all integers which occur in any of the
;;> isets \var{args}.  If no \var{args} are present returns an empty
;;> iset.

(define (iset-union . args)
  (if (null? args)
    (make-iset)
    (apply iset-union! (iset-copy (car args)) (cdr args))))

(define (iset-intersection2! a b)
  (let lp ((nodes-a (iset->node-list a))
           (nodes-b (iset->node-list b))
           (res '()))
    (cond
     ((or (null? nodes-a) (null? nodes-b))
      (let ((is (iset)))
        (for-each (lambda (x) (iset-adjoin-node! is x)) res)
        is))
     ((> (iset-start (car nodes-b)) (iset-end (car nodes-a)))
      (lp (cdr nodes-a) nodes-b res))
     ((> (iset-start (car nodes-a)) (iset-end (car nodes-b)))
      (lp nodes-a (cdr nodes-b) res))
     (else
      (let* ((a (car nodes-a))
             (b (car nodes-b))
             (a-ls (iset-node-split a (iset-start b) (iset-end b)))
             (overlap (cadr a-ls))
             (a-right (car (cddr a-ls)))
             (b-ls (iset-node-split b (iset-start overlap) (iset-end overlap)))
             (b-overlap (cadr b-ls))
             (b-right (car (cddr b-ls))))
        (iset-start-set! a (iset-start overlap))
        (iset-end-set! a (iset-end overlap))
        (if (iset-bits b-overlap)
            (let ((a-bits (or (iset-bits overlap)
                              (range->bits (iset-start a) (iset-end a))))
                  (b-bits (iset-bits b-overlap)))
              (iset-bits-set! a (bitwise-and a-bits b-bits)))
            (iset-bits-set! a (iset-bits overlap)))
        (lp (if a-right (cons a-right (cdr nodes-a)) (cdr nodes-a))
            (if b-right (cons b-right (cdr nodes-b)) (cdr nodes-b))
            (cons a res)))))))

(define (iset-intersection! a . args)
  (let lp ((a a) (ls args))
    (if (null? ls)
        a
        (lp (iset-intersection2! a (car ls))
            (cdr ls)))))

;;> Returns an iset containing all integers which occur in \var{a} and
;;> every of the isets \var{args}.  If no \var{args} are present
;;> returns \var{a}.

(define (iset-intersection a . args)
  (apply iset-intersection! (iset-copy a) args))

(define (iset-difference2! a b)
  (let lp ((nodes-a (iset->node-list a))
           (nodes-b (iset->node-list b)))
    (cond
     ((null? nodes-a) a)
     ((null? nodes-b) a)
     ((> (iset-start (car nodes-b)) (iset-end (car nodes-a)))
      (lp (cdr nodes-a) nodes-b))
     ((> (iset-start (car nodes-a)) (iset-end (car nodes-b)))
      (lp nodes-a (cdr nodes-b)))
     (else
      (let* ((a (car nodes-a))
             (b (car nodes-b))
             (a-ls (iset-node-split a (iset-start b) (iset-end b)))
             (left (car a-ls))
             (overlap (cadr a-ls))
             (right (car (cddr a-ls)))
             (b-ls (iset-node-split b (iset-start overlap) (iset-end overlap)))
             (b-overlap (cadr b-ls))
             (b-right (car (cddr b-ls))))
        (if left
            (iset-insert-left! a left))
        (iset-start-set! a (iset-start overlap))
        (iset-end-set! a (iset-end overlap))
        (if (not (iset-bits b-overlap))
            (iset-bits-set! a 0)
            (let ((a-bits (or (iset-bits overlap)
                              (range->bits (iset-start a) (iset-end a))))
                  (b-bits (bitwise-not (iset-bits b-overlap))))
              (iset-bits-set! a (bitwise-and a-bits b-bits))))
        (if right
            (iset-insert-right! a right))
        (lp (if right (cons right (cdr nodes-a)) (cdr nodes-a))
            (if b-right (cons b-right (cdr nodes-b)) (cdr nodes-b))))))))

;;> Returns an iset containing all integers which occur in \var{a},
;;> but removing those which occur in any of the isets \var{args}.  If
;;> no \var{args} are present returns \var{a}.  May mutate \var{a}.

(define (iset-difference! a . args)
  (if (null? args)
      a
      (begin
        ;;(iset-for-each (lambda (i) (iset-delete1! a i)) (car args))
        (iset-difference2! a (car args))
        (apply iset-difference! a (cdr args)))))

;;> As above but doesn't change \var{a}.

(define (iset-difference a . args)
  (apply iset-difference! (iset-copy a) args))

(define-library (chibi iset optimize)
  (cond-expand
   (chibi (import (chibi) (srfi 9)))
   (else (import (scheme base))))
  (import (chibi iset base)
          (chibi iset iterators)
          (chibi iset constructors))
  (cond-expand
   ((library (srfi 151)) (import (srfi 151)))
   ((library (srfi 33)) (import (srfi 33)))
   (else
    (import (srfi 60))
    (begin
      (define (%mask size) (bitwise-not (arithmetic-shift -1 size)))
      (define (extract-bit-field size position n)
        (bitwise-and (%mask size) (arithmetic-shift n (- position)))))))
  (include "optimize.scm")
  (export
   iset-balance iset-balance! iset-optimize iset-optimize!
   iset->code iset->code/lambda))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Optimizing Iset Representation

(define (iset-balance iset)
  (and iset
       (let ((nodes '()))
         (iset-for-each-node
          (lambda (is) (set! nodes (cons (iset-copy-node is) nodes)))
          iset)
         (let reduce ((nodes (reverse nodes)))
           (let ((len (length nodes)))
             (case len
               ((0) #f)
               ((1) (car nodes))
               (else
                (let ((mid (quotient len 2)))
                  (let lp ((i 0) (ls nodes) (left '()))
                    (if (= i mid)
                        (let ((res (car ls)))
                          (iset-left-set! res (reduce (reverse left)))
                          (iset-right-set! res (reduce (cdr ls)))
                          res)
                        (lp (+ i 1) (cdr ls) (cons (car ls) left))))))))))))

(define (iset-balance! iset)
  (iset-balance iset))

;; remove leading 0's in bits before squashing
(define (iset-trim-and-squash-bits! is)
  (if (iset-bits is)
      (let ((end (iset-end is)))
        (let lp ((bits (iset-bits is))
                 (start (iset-start is)))
          (cond
           ((zero? bits)
            (iset-start-set! is start)
            (iset-bits-set! is 0))
           ((>= start end)
            (iset-start-set! is start)
            (iset-bits-set! is #f)
            (if (even? (arithmetic-shift bits -1))
                (iset-end-set! is start)))
           ((even? bits)
            (lp (arithmetic-shift bits -1) (+ start 1)))
           (else
            (iset-start-set! is start)
            (iset-bits-set! is bits))))))
  (iset-squash-bits! is)
  is)

;; overwrite a node in place
(define (iset-set-node! a b)
  (iset-start-set! a (iset-start b))
  (iset-end-set! a (iset-end b))
  (iset-bits-set! a (iset-bits b)))

;; safe to insert left since we've already visited all left nodes
(define (iset-node-replace! is nodes)
  (cond
   ((pair? nodes)
    (iset-set-node! is (car nodes))
    (let loop ((is is) (ls (cdr nodes)))
      (cond
       ((pair? ls)
        (iset-insert-left! is (car ls))
        (loop (iset-left is) (cdr ls))))))))

;; compact a list of consecutive bit ranges for an iset
(define (iset-node-split-ranges! is ranges)
  (let ((start (iset-start is))
        (end (iset-end is))
        (bits (iset-bits is)))
    (let lp ((ls (reverse ranges)) (nodes '()) (last 0))
      (if (pair? ls)
          (let ((lo (caar ls)) (hi (cdar ls)))
            (lp (cdr ls)
                (cons (make-iset (+ start lo) (+ start hi -1))
                      (if (< last lo) ;; trailing bit range
                          (cons (iset-trim-and-squash-bits!
                                 (%make-iset
                                  (+ start last)
                                  (+ start lo -1)
                                  (bit-field bits last lo)
                                  #f
                                  #f))
                                nodes)
                          nodes))
                hi))
          (let ((nodes
                 (if (< (+ start last) end) ;; trailing bit range
                     (cons (iset-trim-and-squash-bits!
                            (%make-iset (+ start last)
                                        end
                                        (arithmetic-shift bits (- last))
                                        #f
                                        #f))
                           nodes)
                     nodes)))
            (iset-node-replace! is nodes))))))

;; Compact bit ranges of long consecutive chars in a single node into
;; ranges.  Loop over the bits, and convert any consecutive bit
;; patterns longer than span into new start/end nodes.
(define (iset-optimize-node! is span)
  (iset-squash-bits! is)
  (let* ((bits (iset-bits is))
         (len (and bits (integer-length bits))))
    (cond
     (bits
      (letrec
          ((full  ;; in a full bit range from [since..i)
            (lambda (i since ranges)
              (cond
               ((or (>= i len) (not (bit-set? i bits)))
                ;; if the current span is long enough, push to ranges
                (if (>= (- i since) span)
                    (sparse (+ i 1) (cons (cons since i) ranges))
                    (sparse (+ i 1) ranges)))
               (else
                (full (+ i 1) since ranges)))))
           (sparse  ;; [i-1] is not set
            (lambda (i ranges)
              (cond
               ((>= i len)
                ;; done - if there are any ranges to compact, do so
                (if (pair? ranges)
                    (iset-node-split-ranges! is ranges)))
               ((bit-set? i bits)
                (full (+ i 1) i ranges))
               (else
                (sparse (+ i 1) ranges))))))
        (sparse 0 '()))))))

;; Remove empty nodes.
(define (%iset-prune! is)
  (cond
   ((not is)
    #f)
   (else
    (iset-left-set! is (%iset-prune! (iset-left is)))
    (iset-right-set! is (%iset-prune! (iset-right is)))
    (if (and (eq? 0 (iset-bits is))
             (not (iset-left is))
             (not (iset-right is)))
        #f
        is))))

(define (iset-prune! is)
  (or (%iset-prune! is) (iset)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define (iset-optimize! is . opt)
  (let ((span (if (pair? opt) (car opt) (* 40 8)))
        (is (iset-prune! is)))
    (iset-for-each-node (lambda (node) (iset-optimize-node! node span)) is)
    (iset-prune! is)))

(define (iset-optimize iset . opt)
  (apply iset-optimize! (iset-copy iset) opt))

;; write an efficient expression which evaluates to the iset
(define (iset->code iset)
  (and iset
       `(%make-iset ,(iset-start iset)
                    ,(iset-end iset)
                    ,(iset-bits iset)
                    ,(iset->code (iset-left iset))
                    ,(iset->code (iset-right iset)))))

;; uses only if, <, <=, >, and SRFI 151 bit-set?
(define (iset->code/lambda iset)
  (define (code iset)
    (and iset
         (if (and (not (iset-left iset))
                  (not (iset-right iset))
                  (not (iset-bits iset)))
             `(<= ,(iset-start iset) n ,(iset-end iset))
             `(if (< n ,(iset-start iset))
               ,(code (iset-left iset))
               ,(if (and (not (iset-right iset)) (not (iset-bits iset)))
                    `(<= n ,(iset-end iset))
                    `(if (> n ,(iset-end iset))
                         ,(code (iset-right iset))
                         ,(if (iset-bits iset)
                              `(bit-set? (- n ,(iset-start iset))
                                         ,(iset-bits iset))
                              #t)))))))
  `(lambda (n) ,(code iset)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; The most basic set interface.  We provide a data type, low-level
;; constructor, and membership test.  This allows libraries to provide
;; an iset API without needing to include the full iset library.

(define-record-type Integer-Set
  (%make-iset start end bits left right)
  iset?
  (start iset-start iset-start-set!)
  (end   iset-end   iset-end-set!)
  (bits  iset-bits  iset-bits-set!)
  (left  iset-left  iset-left-set!)
  (right iset-right iset-right-set!))

;;> Create a new iset.  Takes two optional arguments, \var{n} and
;;> \var{m}.  If only \var{n} is provided the set contains only a
;;> single element.  If \var{m} is provided the set contains all
;;> integers from \var{n} to \var{m} inclusive.  If neither is
;;> provided the set is initially empty.

(define (make-iset . opt)
  (if (null? opt)
      (%make-iset 0 0 0 #f #f)
      (let ((end (if (pair? (cdr opt)) (cadr opt) (car opt))))
        (%make-iset (car opt) end #f #f #f))))

;;> Returns true iff \var{iset} contains the integer \var{n}.

(define (iset-contains? iset n)
  (let lp ((is iset))
    (let ((start (iset-start is)))
      (if (< n start)
          (let ((left (iset-left is))) (and left (lp left)))
          (let ((end (iset-end is)))
            (if (> n end)
                (let ((right (iset-right is))) (and right (lp right)))
                (let ((bits (iset-bits is)))
                  (or (not bits)
                      (bit-set? (- n start) bits)))))))))

(define-library (chibi iset base)
  (cond-expand
   (chibi (import (chibi) (srfi 9)))
   (else (import (scheme base))))
  (cond-expand
   ((library (srfi 151)) (import (srfi 151)))
   ((library (srfi 33)) (import (srfi 33)))
   (else (import (srfi 60))))
  (include "base.scm")
  (cond-expand  ;; workaround for #1342
   (chicken (begin (define Integer-Set #f)))
   (else))
  (export
   %make-iset make-iset iset? iset-contains? Integer-Set
   iset-start iset-end iset-bits iset-left iset-right
   iset-start-set! iset-end-set! iset-bits-set! iset-left-set! iset-right-set!))
;; highlight.scm -- source code highlighting library
;; Copyright (c) 2011 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

;;> Library for highlighting source code in different
;;> languages.  Currently supports Scheme, C and Assembly.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define (string-concatenate-reverse ls)
  (string-concatenate (reverse ls)))

(define (reverse-list->string ls)
  (list->string (reverse ls)))

;;> Returns an sxml structure representing the code from source
;;> with various language constructs wrapped in highlighting
;;> forms.  \var{source} should be a string or port.  The
;;> language to highlight for is auto-detected.

(define (highlight source)
  (let ((str (if (string? source) source (port->string source))))
    ((highlighter-for (highlight-detect-language str)) str)))

;;> Attempst to auto-detect which language \var{str} is code
;;> for, and returns a symbol representing that language.

(define (highlight-detect-language str)
  (cond
   ((protect (exn (else #f))
      (call-with-input-string str
        (lambda (in) (do ((x #f (read in))) ((eof-object? x)))))
      #t)
    'scheme)
   (else
    'c)))

;;> Return a procedure for highlighting the given language.

(define (highlighter-for language)
  (case language
    ((scheme) highlight-scheme)
    ((asm) highlight-assembly)
    ((none) (lambda (x) x))
    (else highlight-c)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define highlight-themes
  '((light
     (keyword      . "#800080")
     (type         . "#008000")
     (function     . "#0000FF")
     (variable     . "#B8860B")
     (comment      . "#FF0000")
     (string       . "#BC8F8F")
     (attribute    . "#FF5000")
     (preprocessor . "#FF00FF")
     (builtin      . "#FF00FF")
     (character    . "#0055AA")
     (syntaxerror  . "#FF0000")
     (diff-deleted . "#5F2121")
     (diff-added   . "#215F21")
     )))

(define highlight-paren-styles
  ;;'("#BAFFFF" "#FFCACA" "#FFFFBA" "#CACAFF" "#CAFFCA" "FFBAFF")
  '("#AAAAAA" "#888888" "#666666" "#444444" "#222222" "#000000"))

;;> Returns a string representing the CSS needed for the output
;;> of \var{highlight}.  This should be included in a referenced
;;> CSS file, or in a \var{<script>} section in the generated in
;;> the generated HTML output.

(define (highlight-style . theme)
  (string-concatenate
   (append
    (map
     (lambda (x)
       (if (and (list? x) (= 3 (length x)))
           (string-append
            "." (symbol->string (car x)) " { color: " (cadr x)
            "; background-color: " (car (cddr x)) "; }\n")
           (string-append
            "." (symbol->string (car x)) " { color: "
            (if (pair? (cdr x)) (cadr x) (cdr x))
            "; background-color: inherit; }\n")))
     (cond ((assq (and (pair? theme) (car theme)) highlight-themes) => cdr)
           (else (cdar highlight-themes))))
    (map
     (lambda (s i)
       (string-append
        ;;"span.paren" (number->string i)
        ;;":hover { color: inherit; background-color: " s "; }\n"
        "span.paren" (number->string i)
        " { color: " s "; background-color: inherit; }\n"))
     highlight-paren-styles
     (cdr (iota (+ 1 (length highlight-paren-styles))))))))

(define (highlight-class class x)
  `(span (@ (class . ,class)) ,@(if (list? x) x (list x))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define (read-whitespace in)
  (let lp ((res '()))
    (if (char-whitespace? (peek-char in))
        (lp (cons (read-char in) res))
        (reverse-list->string res))))

(define (read-to-whitespace in res)
  (let ((c (peek-char in)))
    (cond
     ((or (eof-object? c) (char-whitespace? c))
      (reverse-list->string res))
     (else
      (read-to-whitespace in (cons (read-char in) res))))))

(define (read-escaped in term ls)
  (let ((c (read-char in)))
    (cond
     ((eof-object? c) (reverse-list->string ls))
     ((eqv? c term) (reverse-list->string (cons c ls)))
     (else (read-escaped in term (cons c ls))))))

(define (read-to-eol in ls)
  (let ((c (read-char in)))
    (cond
     ((eof-object? c) (reverse-list->string ls))
     ((eqv? c #\newline) (reverse-list->string (cons c ls)))
     (else (read-to-eol in (cons c ls))))))

(define (collect str res)
  (if (pair? str) (cons (reverse-list->string str) res) res))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define (highlight-scheme-delimiter? ch)
  (or (eof-object? ch)
      (char-whitespace? ch)
      (memq ch '(#\; #\# #\( #\) #\[ #\] #\{ #\} #\' #\` #\, #\"))))

(define (highlight-scheme-definition? id)
  (memq id '(define define-syntax define-module define-class
             define-record define-record-type)))

(define (highlight-scheme-syntax? id)
  (memq id '(if lambda define set! cond case let let* letrec letrec*
             let-values let-values* let-optionals let-optionals*
             let-keywords let-keywords* and-let* rec receive do
             loop rxmatch-cond rxmatch-case begin when unless
             match match-lambda match-let match-let* dotimes dolist
             quote quasiquote unquote unquote-splicing error errorf
             define-syntax let-syntax letrec-syntax syntax-rules
             syntax-case parameterize module library require
             require-extension use use-modules import import-immutable
             define-module select-module provide autoload export
             only except rename prefix drop-prefix alias-for
             include include-ci include-shared
             condition-case guard protect cond-expand for with to by
             in-list in-lists in-string in-string-reverse
             in-vector in-vector-reverse in-file listing appending
             summing multpliying up-from down-from else
             )))

;;> Highlighter for Scheme source code.

(define (highlight-scheme source)
  (let ((in (if (string? source) (open-input-string source) source)))
    (define (read-identifier ls)
      (let ((c (peek-char in)))
        (cond
         ((highlight-scheme-delimiter? c)
          (reverse-list->string ls))
         (else
          (read-char in)
          (read-identifier (cons c ls))))))
    (define (hash-mark)
      (let ((c (read-char in)))
        (case c
          ((#\;)
           (highlight-class "comment" (highlight 0 '(#\; #\#) '())))
          ((#\\)
           (highlight-class "string"
                            (read-identifier (list (read-char in) #\\ #\#))))
          (else
           (string-append "#" (if (char? c) (string c) ""))))))
    (define (highlight n str res)
      (let ((c (read-char in)))
        (if (eof-object? c)
            (reverse (collect str res))
            (case c
              ((#\;)
               (let lp ((ls '()))
                 (let ((ls (cons (read-to-eol in (list #\;)) ls)))
                   (cond
                    ((eqv? #\; (peek-char in))
                     (lp ls))
                    (else
                     (highlight n
                                '()
                                (cons (highlight-class
                                       "comment"
                                       (string-concatenate-reverse ls))
                                      (collect str res))))))))
              ((#\")
               (let ((s (read-escaped in #\" (list #\"))))
                 (highlight n
                            '()
                            (cons (highlight-class "string" s)
                                  (collect str res)))))
              ((#\()
               ;;(highlight-start
               ;; (string->symbol
               ;;  (string-append
               ;;   "paren"
               ;;   (number->string
               ;;    (+ 1 (modulo n (length highlight-paren-styles))))))
               ;;out)
               (let ((res (collect (cons #\( str) res)))
                 (if (highlight-scheme-delimiter? (peek-char in))
                     (highlight (+ n 1) '() res)
                     (let* ((id (read-identifier '()))
                            (sym (string->symbol id)))
                       (cond
                        ((highlight-scheme-definition? sym)
                         (let* ((res (cons (highlight-class "keyword" id) res))
                                (res (cons (read-whitespace in) res))
                                (res (if (eqv? #\( (peek-char in))
                                         (cons (string (read-char in)) res)
                                         res)))
                           (highlight
                            (+ n 1)
                            '()
                            (cons
                             (highlight-class "function" (read-identifier '()))
                             res))))
                        ((highlight-scheme-syntax? sym)
                         (highlight (+ n 1)
                                    '()
                                    (cons (highlight-class "keyword" id) res)))
                        (else
                         (highlight (+ n 1) '() (cons id res))))))))
              ((#\))
               (cond
                ((zero? n)
                 (highlight n
                            '()
                            (cons (highlight-class "syntaxerror" ")")
                                  (collect str res))))
                (else
                 ;;(highlight-end 'paren
                 (highlight (- n 1) (cons c str) res))))
              ((#\#)
               (highlight n '() (cons (hash-mark) (collect str res))))
              (else
               (cond
                ((highlight-scheme-delimiter? c)
                 (highlight n (cons c str) res))
                (else
                 (let ((id (read-identifier (list c))))
                   (highlight n '() (cons `(span ,id) (collect str res)))))))))))
    (highlight 0 '() '())))

(define (highlight-c-keyword? id)
  (memq id '(asm break case catch const_cast continue default delete
             do dynamic_cast else explicit export false for friend goto
             if mutable namespace new operator private protected public
             register reinterpret_cast return sizeof static_cast switch
             template this throw true try typedef typeid typename using
             virtual while)))

(define (highlight-c-type? id)
  (memq id '(auto bool char class const double enum extern float inline int long
             short signed static struct union unsigned void volatile wchar_t
             sexp sexp_uint_t sexp_sint_t)))

;;> Highlighter for C source code.

(define (highlight-c source)
  (let ((in (if (string? source) (open-input-string source) source)))
    (define (char-c-initial? c)
      (and (char? c) (or (char-alphabetic? c) (eqv? c #\_) (eqv? c #\$))))
    (define (char-c-identifier? c)
      (and (char? c) (or (char-c-initial? c) (char-numeric? c))))
    (define (read-identifier in ls)
      (let ((c (peek-char in)))
        (if (char-c-identifier? c)
            (read-identifier in (cons (read-char in) ls))
            (reverse-list->string ls))))
    (define (highlight-identifier id)
      (let ((sym (string->symbol id)))
        (cond
         ((highlight-c-keyword? sym)
          (highlight-class "keyword" id))
         ((highlight-c-type? sym)
          (highlight-class "type" id))
         (else
          id))))
    (define (highlight-line res)
      (highlight
       '()
       (cond
        ((eqv? #\# (peek-char in))
         (read-char in)
         (let* ((res (cons (read-whitespace in) (cons "#" res)))
                (id (read-identifier in '()))
                (res (cons (read-whitespace in)
                           (cons (highlight-class "preprocessor" id) res))))
           (case (string->symbol id)
            ((define)
             (cons (highlight-class "function" (read-to-whitespace in '())) res))
            ((include import)
             (cons (highlight-class "string" (read-to-whitespace in '())) res))
            (else
             res))))
        ((char-c-initial? (peek-char in))
         ;; line beginning w/ an identifier is probably a
         ;; function declaration
         (let ((id1 (read-identifier in '())))
           (cond
            ((eqv? #\: (peek-char in))
             (cons (highlight-class "function" id1) res))
            (else
             (let lp ((decls '())
                      (id id1))
               (let ((space (read-whitespace in)))
                 (cond
                  ((char-c-initial? (peek-char in))
                   (lp (cons space (cons id decls))
                       (read-identifier in '())))
                  ((eqv? #\( (peek-char in))
                   `(,space
                     ,(highlight-class "function" id)
                     ,(highlight-class "type" (reverse decls))
                     ,@res))
                  (else
                   `(,space ,id ,@decls ,@res)))))))))
        (else
         res))))
    (define (highlight str res)
      (let ((c (read-char in)))
        (if (eof-object? c)
            (reverse (collect str res))
            (case c
              ((#\/)
               (case (peek-char in)
                 ((#\/)
                  (highlight
                   '()
                   (cons (highlight-class "comment" (read-to-eol in '(#\/ #\/)))
                         (collect str res))))
                 ((#\*)
                  (let lp ((ls (cons (read-char in) '(#\/))))
                    (let ((c (read-char in)))
                      (if (not (and (eqv? (car ls) #\*) (eqv? c #\/)))
                          (lp (cons c ls))
                          (highlight
                           '()
                           (cons (highlight-class "comment"
                                                  (reverse-list->string ls))
                                 (collect str res)))))))
                 (else
                  (highlight (cons c str) res))))
              ((#\" #\')
               (let ((res (collect str res))
                     (s (read-escaped in c (list c))))
                 (highlight '() (cons (highlight-class "string" s) res))))
              ((#\newline)
               (highlight-line (collect (cons #\newline str) res)))
              (else
               (cond
                ((char-c-initial? c)
                 (highlight
                  '()
                  (cons
                   (let ((id (read-identifier in (list c))))
                     (if (eqv? #\: (peek-char in))
                         (highlight-class "function" id)
                         (highlight-identifier id)))
                   (collect str res))))
                (else
                 (highlight (cons c str) res))))))))
    (highlight-line '())))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;> Highlighter for Assembly source code.

(define (highlight-assembly source)
  (let ((in (if (string? source) (open-input-string source) source)))
    (define (char-asm-initial? c)
      (and (char? c) (or (char-alphabetic? c) (memv c '(#\_ #\$ #\.)))))
    (define (char-asm-identifier? c)
      (and (char? c) (or (char-asm-initial? c) (char-numeric? c))))
    (define (read-identifier in ls)
      (let ((c (peek-char in)))
        (if (char-asm-identifier? c)
            (read-identifier (cons (read-char in) ls))
            (reverse-list->string ls))))
    (define (highlight str res)
      (let ((c (read-char in)))
        (cond
         ((eof-object? c)
          (reverse (collect str res)))
         (else
          (case c
            ((#\newline)
             (highlight-line (collect str res)))
            ((#\")
             (let ((s (read-escaped in c (list c))))
               (highlight
                '()
                (cons (highlight-class "string" s) (collect str res)))))
            ((#\%)
             (highlight
              '()
              (cons (highlight-class "variable" (read-identifier in (list c)))
                    (collect str res))))
            ((#\;)
             (highlight
              '()
              (cons (highlight-class "comment" (read-to-eol in (list c)))
                    (collect str res))))
            (else
             (highlight (cons c str) res)))))))
    (define (highlight-line res) 
      (cond
       ((eof-object? (peek-char in))
        (highlight '() res))
       ((char-asm-initial? (peek-char in))
        (let ((id (read-identifier in '())))
          (highlight
           '()
           (cons
            (if (eqv? #\: (peek-char in))
                (highlight-class "function" id)
                (highlight-class "keyword" id))
            res))))
       ((eqv? #\tab (peek-char in))
        (highlight
         '()
         (cons (highlight-class "keyword" (read-identifier in '()))
               (cons "\t" res))))
       (else
        (highlight '() res))))
    (highlight-line '())))
(define-library (chibi pathname-test)
  (export run-tests)
  (import (scheme base) (chibi pathname) (chibi test))
  (begin
    (define (run-tests)
      (test-begin "pathname")

      ;; tests from the dirname(3) manpage

      (test "dirname(3)" "/usr" (path-directory "/usr/lib"))
      (test "lib"  (path-strip-directory "/usr/lib"))

      (test "/"    (path-directory "/usr/"))
      (test ""     (path-strip-directory "/usr/"))

      (test "."    (path-directory "usr"))
      (test "usr"  (path-strip-directory "usr"))

      (test "/"    (path-directory "/"))
      (test ""     (path-strip-directory "/"))

      (test "."    (path-directory "."))
      (test "."    (path-strip-directory "."))

      (test "."    (path-directory ".."))
      (test ".."   (path-strip-directory ".."))

      ;; additional tests (should match GNU dirname/basename behavior)

      (test "path-directory:border"
          "/"    (path-directory "//"))
      (test ""     (path-strip-directory "//"))

      (test "."    (path-directory ""))
      (test ""     (path-strip-directory ""))

      (test "."    (path-directory "../"))
      (test ""     (path-strip-directory "../"))

      (test ".."   (path-directory "../.."))
      (test ".."   (path-strip-directory "../.."))

      (test "path-directory:extra"
          "/usr/local" (path-directory "/usr/local/lib"))
      (test "lib" (path-strip-directory "/usr/local/lib"))

      (test "/usr" (path-directory "/usr/local/"))
      (test "" (path-strip-directory "/usr/local/"))

      (test "usr"    (path-directory "usr/local"))
      (test "local"  (path-strip-directory "usr/local"))

      (test "/" (path-directory "//usr"))
      (test "usr" (path-strip-directory "//usr"))

      (test "/" (path-directory "//usr/"))
      (test "" (path-strip-directory "//usr/"))

      (test "path-directory:small"
          "/a" (path-directory "/a/b"))
      (test "b" (path-strip-directory "/a/b"))

      (test "a" (path-directory "a/b"))
      (test "b" (path-strip-directory "a/b"))

      (test "a" (path-directory "a/b/"))
      (test "" (path-strip-directory "a/b/"))

      (test "/a/b/c" (path-directory "/a/b/c/d"))
      (test "d" (path-strip-directory "/a/b/c/d"))

      (test "/a/b/c" (path-directory "/a/b/c/d/"))
      (test "" (path-strip-directory "/a/b/c/d/"))

      (test "a/b/c"    (path-directory "a/b/c/d"))
      (test "d"  (path-strip-directory "a/b/c/d"))

      (test "/a/b" (path-directory "/a/b/c.d"))
      (test "c.d" (path-strip-directory "/a/b/c.d"))

      (test "/a/b" (path-directory "/a/b/c.d/"))
      (test "" (path-strip-directory "/a/b/c.d/"))

      (test "/a/b/c" (path-directory "/a/b/c/."))
      (test "." (path-strip-directory "/a/b/c/."))

      (test "/a/b/c" (path-directory "/a/b/c/.."))
      (test ".." (path-strip-directory "/a/b/c/.."))

      (test "/a/b/." (path-directory "/a/b/./c"))
      (test "c" (path-strip-directory "/a/b/./c"))

      (test "/a/b/.." (path-directory "/a/b/../c"))
      (test "c" (path-strip-directory "/a/b/../c"))

      (test "/a/b" (path-directory "/a/b/c//"))
      (test "" (path-strip-directory "/a/b/c//"))

      (test "/a/b" (path-directory "/a/b//c///"))
      (test "" (path-strip-directory "/a/b//c///"))

      ;; extensions

      (test "path-extension" "scm" (path-extension "foo.scm"))
      (test "foo" (path-strip-extension "foo.scm"))

      (test "c" (path-extension "foo.scm.c"))
      (test "foo.scm" (path-strip-extension "foo.scm.c"))

      (test "scm" (path-extension "/home/me/foo.scm"))
      (test "/home/me/foo" (path-strip-extension "/home/me/foo.scm"))

      (test "scm" (path-extension "foo..scm"))
      (test "foo." (path-strip-extension "foo..scm"))

      (test "s" (path-extension "foo.s"))
      (test "foo" (path-strip-extension "foo.s"))

      (test #f (path-extension "foo."))
      (test "foo." (path-strip-extension "foo."))

      (test #f (path-extension "foo.scm."))
      (test "foo.scm." (path-strip-extension "foo.scm."))

      (test #f (path-extension "."))
      (test "." (path-strip-extension "."))

      (test #f (path-extension "a."))
      (test "a." (path-strip-extension "a."))

      (test #f (path-extension "/."))
      (test "/." (path-strip-extension "/."))

      (test #f (path-extension "foo.scm/"))
      (test "foo.scm/" (path-strip-extension "foo.scm/"))

      (test "path-replace-extension"
          "foo.c" (path-replace-extension "foo.scm" "c"))
      (test "foo.c" (path-replace-extension "foo" "c"))

      ;; absolute paths

      (test-assert (path-absolute? "/"))
      (test-assert (path-absolute? "//"))
      (test-assert (path-absolute? "/usr"))
      (test-assert (path-absolute? "/usr/"))
      (test-assert (path-absolute? "/usr/."))
      (test-assert (path-absolute? "/usr/.."))
      (test-assert (path-absolute? "/usr/./"))
      (test-assert (path-absolute? "/usr/../"))

      (test-assert (not (path-absolute? "")))
      (test-assert (not (path-absolute? ".")))
      (test-assert (not (path-absolute? "usr")))
      (test-assert (not (path-absolute? "usr/")))

      ;; normalization & building

      (test "path-normalize" "/a/b/c/d/e" (path-normalize "/a/b/c/d/./e"))
      (test "/a/b/c/d/e" (path-normalize "/a/b//.///c//d/./e"))
      (test "/a/b/c/d/e/" (path-normalize "/a/b//.///c//d/./e/"))
      (test "/a/c/d/e" (path-normalize "/a/b/../c/d/e"))
      (test "/a/b/c/e" (path-normalize "/a/b//.///c//d/../e"))
      (test "/a/c/e" (path-normalize "/a/b//..///c//d/../e"))
      (test "/a/b/c/d/e/"
          (path-normalize "/a/b//./../c/d/../../b//c/d/e/f/.."))
      (test "/a/b/c/" (path-normalize "/a/b/c/."))

      (test "path-normalize:border" "" (path-normalize ""))
      (test "." (path-normalize "."))
      (test "/" (path-normalize "/"))
      (test "/" (path-normalize "/."))

      (test "path-normalize:overflow"
          "/" (path-normalize "/a/b/c/../../../../.."))
      (test "../.." (path-normalize "a/b/c/../../../../.."))
      (test "../../.." (path-normalize "../a/b/c/../../../../.."))

      (test "" (path-strip-leading-parents ".."))
      (test "" (path-strip-leading-parents "../"))
      (test "a" (path-strip-leading-parents "../a"))
      (test "a/b" (path-strip-leading-parents "../../a/b"))
      (test "a/b" (path-strip-leading-parents "../../../a/b"))
      (test "a/../b" (path-strip-leading-parents "../../../a/../b"))

      (test "path-relative-to" "c" (path-relative-to "/a/b/c" "/a/b"))
      (test "c" (path-relative-to "/a/b/c" "/a/b/"))
      (test "." (path-relative-to "/a/b/" "/a/b/"))
      (test "." (path-relative-to "/a/b/" "/a/b"))
      (test "." (path-relative-to "/a/b" "/a/b/"))
      (test "." (path-relative-to "/a/b" "/a/b"))
      (test-not (path-relative-to "/d/a/b/c" "/a/b"))

      (test "make-path" "a/b" (make-path "a" "b"))
      (test "a/b" (make-path "a/" "b"))
      (test "a/b/./c" (make-path "a" "b" "." "c"))
      (test "a/b/../c" (make-path "a" "b" ".." "c"))
      (test "a/b/c" (make-path "a" '("b" "c")))
      (test "/" (make-path "/" ""))
      (test "/" (make-path "/" "/"))
      (test "/." (make-path "/" "."))
      (test "/a" (make-path "/a" ""))
      (test "/a" (make-path "/a" "/"))
      (test "/a/." (make-path "/a" "."))

      (test-end))))

;;> Runs a procedure on a temporary file.  \var{proc} should be a
;;> procedure of three values: \scheme{(path out preserve)}, where
;;> \scheme{path} is the path to the temporary file, \scheme{out} is
;;> an output port opened on the file, and \scheme{preserve} is a
;;> thunk to disable deleting the file.  The file name will be in a
;;> temp directory, based on \var{template} and having the same
;;> extension if present, with permissions from the optional
;;> \var{mode} which defaults to \scheme{#o700}.  Returns the result
;;> of \var{proc}, after first deleting the file if the
;;> \scheme{preserve} thunk was not called.

(define (call-with-temp-file template proc . o)
  (let* ((mode (if (pair? o) (car o) #o700))
         (pid (current-process-id))
         (base (string-append
                "/tmp/" (path-strip-extension template)
                "-" (number->string pid) "-"
                (number->string (exact (round (current-second)))) "-"))
         (ext (or (path-extension template) "tmp")))
    (let lp ((i 0))
      (let ((path (string-append base (number->string i) "." ext)))
        (cond
         ((> i 100)  ;; give up after too many tries regardless
          (error "Repeatedly failed to generate temp file in /tmp"))
         ((file-exists? path)
          (lp (+ i 1)))
         (else
          (let ((fd (open path
                          (bitwise-ior open/write open/create open/exclusive)
                          mode)))
            (if (not fd)
                (if (file-exists? path) ;; created between test and open
                    (lp (+ i 1))
                    (error "Couldn't generate temp file in /tmp " path))
                (let* ((out (open-output-file-descriptor fd))
                       (preserve? #f)
                       (res (proc path out (lambda () (set! preserve? #t)))))
                  (close-output-port out)
                  (if (and (not preserve?) (equal? pid (current-process-id)))
                      (delete-file path))
                  res)))))))))

;;> Runs a procedure on a temporary directory.  \var{proc} should be a
;;> procedure of two values: \scheme{(path preserve)}, where
;;> \scheme{path} is the path to the temporary directory and
;;> \scheme{preserve} is a thunk to disable deleting the dir.  The
;;> directory name will be in a temp directory, based on
;;> \var{template}, with permissions from the optional \var{mode}
;;> which defaults to \scheme{#o700}.  Returns the result of
;;> \var{proc}, after first deleting the file hierarchy rooted at
;;> \scheme{path} if the \scheme{preserve} thunk was not called.

(define (call-with-temp-dir template proc . o)
  (let* ((mode (if (pair? o) (car o) #o700))
         (pid (current-process-id))
         (base (string-append
                "/tmp/" template "-" (number->string pid) "-"
                (number->string (exact (round (current-second)))) "-")))
    (let lp ((i 0))
      (let ((path (string-append base (number->string i))))
        (cond
         ((> i 100)  ;; give up after too many tries
          (error "Repeatedly failed to generate temp dir in /tmp " path))
         ((file-exists? path)
          (lp (+ i 1)))
         ((create-directory path mode)
          (let* ((preserve? #f)
                 (res (proc path (lambda () (set! preserve? #t)))))
            ;; sanity check for host threading issues and broken forks
            (if (and (not preserve?) (equal? pid (current-process-id)))
                (delete-file-hierarchy path))
            res))
         (else
          (error "failed to create directory" path)))))))

(define-library (chibi monad environment)
  (export define-environment-monad)
  (import (scheme base))
  (cond-expand
   (chibi (import (only (chibi) syntax-quote)))
   (else (begin (define-syntax syntax-quote (syntax-rules ((_ x) 'x))))))
  (include "environment.scm"))
;; environment.scm - the environment (reader) monad for Scheme
;; Copyright (c) 2013 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

;;> A Scheme take on the environment (reader) monad, focusing more on
;;> being efficient and convenient than pure.

;;> \macro{(define-environment-monad name keyword: value ...)}
;;>
;;> Define a new environment monad.  This syntax hides the
;;> implementation, allowing the use of records, dynamic parameters,
;;> or explicit value passing.
;;>
;;> The \var{name} is used for description and may or may not be bound
;;> to a value representing the monad.  All other parameters are
;;> keywords, and with the exception of \scheme{fields} simply provide
;;> binding names for the monad operators described below.
;;>
;;> The \scheme{fields:} keyword takes a list of field name
;;> identifiers known to be used by the monad.  This is an
;;> optimization hint, as the monad can be used to store and query
;;> values for any identifier at runtime.
;;>
;;> The following keywords obey the definition of a monad:
;;>
;;> sequence: sequence (>>) - Essentially a semi-colon, this joins two
;;>  operations together.
;;>
;;> bind: (>>=) - Runs a normal function.  As a syntactic convenience,
;;>  \scheme{bind} looks and behaves like a lambda, but the parameters
;;>  of the \scheme{bind} are bound as Scheme variables with the
;;>  values of the corresponding environment variables.  Thus you
;;>  fetch the values of foo and bar with:
;;>
;;>    \scheme{(bind (foo bar) ...)}
;;>
;;>  hiding the need for an explicit \scheme{ask}.  If you want to
;;>  bind the values to some other name, you can use it like a
;;>  \scheme{let}:
;;>
;;>    \scheme{(bind ((my-foo foo) (my-bar bar)) ...)}
;;>
;;> return: Returns a pure (non-monadic) value.
;;>
;;> run: Start the monad.
;;>
;;> The following are specific to the environment monad:
;;>
;;> ask: Ask the current value of an environment variable.  This is not
;;>  meant to be used directly - use the `bind' syntax to query bindings.
;;>
;;> local: Shadow the value one or more environment variables,
;;>  analogous to `let'.
;;>
;;> In addition, support for optional mutation is provided:
;;>
;;> local!: (local! (var val) ...) will update the environment with
;;>  the corresponding variable bindings.  In a sequence, successive
;;>  operations will see the result of the update, unlike with `local'.
;;>  This is allowed, but not required, to perform mutation.
;;>
;;> bind-fork: \scheme{(bind-fork a b)} runs `a' followed by `b',
;;>   passing `b' the original state before `a' was run.

(define-syntax define-environment-monad
  (syntax-rules ()
    ((define-environment-monad name clauses ...)
     (dem name (ask %ask) (tell %tell) c f! f s r w u z () clauses ...))))

(define-syntax dem
  (syntax-rules (fields: sequence: bind: bind-fork:
                 local: local!: run: return: ask: tell: copy:)
    ((dem n ask tell c f! f s r w u z (fls ...)
          (fields: (fl get put) . fl-r) . x)
     (dem n ask tell c f! f s r w u z (fls ... (fl #f get put))
          (fields: . fl-r) . x))
    ((dem n ask tell c f! f s r w u z (fls ...) (fields:) . x)
     (dem n ask tell c f! f s r w u z (fls ...) . x))
    ((dem n ask tell c f! f s r w u z ())
     (syntax-error "missing fields clause in define-state-monad"))
    ((dem n ask tell c f! f s r w u z fls (bind: fn!) . x)
     (dem n ask tell c fn! f s r w u z fls . x))
    ((dem n ask tell c f! f s r w u z fls (bind-fork: fn) . x)
     (dem n ask tell c f! fn s r w u z fls . x))
    ((dem n ask tell c f! f s r w u z fls (sequence: seq) . x)
     (dem n ask tell c f! f seq r w u z fls . x))
    ((dem n ask tell c f! f s r w u z fls (run: run) . x)
     (dem n ask tell c f! f s run w u z fls . x))
    ((dem n ask tell c f! f s r w u z fls (return: return) . x)
     (dem n ask tell c f! f s r w u return fls . x))
    ((dem n ask tell c f! f s r w u z fls (local: local) . x)
     (dem n ask tell c f! f s r local u z fls . x))
    ((dem n ask tell c f! f s r w u z fls (local!: local!) . x)
     (dem n ask tell c f! f s r w local! z fls . x))
    ((dem n ask tell c f! f s r w u z fls (ask: a %a) . x)
     (dem n (a %a) tell c f! f s r w u z fls . x))
    ((dem n ask tell c f! f s r w u z fls (tell: t %t) . x)
     (dem n ask (t %t) c f! f s r w u z fls . x))
    ((dem n ask tell c f! f s r w u z fls (copy: copy) . x)
     (dem n ask tell copy f! f s r w u z fls . x))
    ((dem n ask tell c f! f s r w u z fls clause . x)
     (syntax-error "unknown clause" 'clause))
    ((dem n (ask %ask) (tell %tell) c f! f s r w u z ((field init get put) ...))
     (begin
       ;; Internals
       (define-record-type n
         (make-state field ... %props)
         state?
         (field get put) ...
         (%props get-props set-props!))
       (define (%ask st x)
         (case x
           ((field) (get st)) ...
           (else (cond ((assq x (get-props st)) => cdr) (else #f)))))
       (define-syntax ask
         (syntax-rules (quote field ...)
           ((ask st (syntax-quote field)) (get st)) ...
           ((ask st x) (%ask st x))))
       (define (%tell st x val)
         (case x
           ((field) (put st val)) ...
           (else
            (cond
             ((assq x (get-props st))
              => (lambda (cell) (set-cdr! cell val)))
             (else
              (set-props! st (cons (cons x val) (get-props st))))))))
       (define-syntax tell
         (syntax-rules (quote field ...)
           ((tell st (syntax-quote field) val) (put st val)) ...
           ((tell st x val) (%tell st x val))))
       ;; External API
       ;;
       ;; copy
       (define (c st)
         (make-state
          (get st) ...
          (map (lambda (x) (cons (car x) (cdr x))) (get-props st))))
       ;; bind - a function
       (define-syntax f!
         (syntax-rules ooo ()
           ((f! ("step") (params ooo) ((p param) . rest) . body)
            (f! ("step") (params ooo (p param)) rest . body))
           ((f! ("step") (params ooo) ((param) . rest) . body)
            (f! ("step") (params ooo (param param)) rest . body))
           ((f! ("step") (params ooo) (param . rest) . body)
            (f! ("step") (params ooo (param param)) rest . body))
           ((f! ("step") ((p param) ooo) () . body)
            (lambda (st)
              (let ((p (ask st (syntax-quote param))) ooo)
                ((let () . body) st))))
           ((f! params . body)
            (f! ("step") () params . body))))
       ;; fork - run on a copy of the state
       (define-syntax f
         (syntax-rules ()
           ((f a) a)
           ((f a b) (lambda (st) (a (c st)) (b st)))
           ((f a b . c) (f a (f b . c)))))
       ;; sequence
       (define-syntax s
         (syntax-rules ()
           ((s f) f)
           ((s f . g)
            (let ((f-tmp f) (g-tmp (s . g)))
              (lambda (st) (g-tmp (f-tmp st)))))))
       ;; update in place
       (define-syntax u
         (syntax-rules ooo ()
           ((u (prop value) ooo)
            (lambda (st)
              (tell st (syntax-quote prop) value) ooo
              st))))
       ;; local binding - update temporarily
       (define-syntax w
         (syntax-rules ooo ()
           ((w ("step") ((p tmp v tmp-v) ooo) () . b)
            (lambda (st)
              (let ((tmp-v v) ooo
                    (tmp (ask st (syntax-quote p))) ooo)
                (dynamic-wind
                  (lambda () (tell st (syntax-quote p) tmp-v) ooo)
                  (lambda () ((begin . b) st))
                  (lambda () (tell st (syntax-quote p) tmp) ooo)))))
           ((w ("step") (props ooo) ((p v) . rest) . b)
            (w ("step") (props ooo (p tmp v tmp-v)) rest . b))
           ((w ((prop value) ooo) . body)
            (w ("step") () ((prop value) ooo) . body))))
       ;; run
       (define (r proc)
         (proc (make-state init ... '())))
       ;; return
       (define (z x)
         (lambda (st) x))))))
(define (wait-on-event!) (%call/cc abort))


;;> Syntax to support optional and named keyword arguments.
;;> \scheme{let-optionals[*]} is originally from SCSH, and
;;> \scheme{let-keywords[*]} derived from Gauche.

;; Wrap bindings in temp variables to convert a let* definition to a
;; let definition.

(define-syntax let*-to-let
  (syntax-rules ()
    ((let*-to-let letstar ls (vars ...) ((v . d) . rest) . body)
     (let*-to-let letstar ls (vars ... (v tmp (tmp . d))) rest . body))
    ((let*-to-let letstar ls (vars ...) (v . rest) . body)
     (let*-to-let letstar ls (vars ... (v tmp tmp)) rest . body))
    ((let*-to-let letstar ls ((var tmp bind) ...) rest . body)
     (letstar ls (bind ... . rest)
       (let ((var tmp) ...) . body)))))

;;> \macro{(let-optionals ls ((var default) ... [rest]) body ...)}
;;>
;;> Binding construct similar to \scheme{let}.  The \var{var}s are
;;> bound to fresh locations holding values taken in order from the
;;> list \var{ls}, \var{body} is evaluated in the resulting
;;> environment, and the value(s) of the last expression of \var{body}
;;> returned.  If the length of \var{ls} is shorter than the number of
;;> \var{var}s, then the remaining \var{var}s taken their values from
;;> their corresponding \var{default}s, evaluated in an unspecified
;;> order.  Unused \var{default}s are not evaluated.  If a final
;;> \var{rest} var is specified, then it is bound to any remaining
;;> elements of \var{ls} beyond the length of \var{ls}, otherwise any
;;> extra values are unused.
;;>
;;> \var{ls} is evaluated only once.  It is an error if any
;;> \var{default} mutates \var{ls}.
;;>
;;> Typically used on the dotted rest list at the start of a lambda,
;;> \scheme{let-optionals} is more concise and more efficient than
;;> \scheme{case-lambda} for simple optional argument uses.
;;>
;;> \emph{Example:}
;;> \schemeblock{
;;> (define (copy-port . o)
;;>   (let-optionals o ((in (current-input-port))
;;>                     (out (current-output-port))
;;>                     (n-bytes #f))
;;>     (do ((i 0 (+ i 1))
;;>          (n (read-u8 in) (read-u8 in)))
;;>         ((or (and n-bytes (>= i n-bytes))
;;>              (eof-object? b)))
;;>       (write-u8 b out)))}
;;>
;;> \emph{Example:}
;;> \example{
;;> (let-optionals '(0) ((a 10) (b 11) (c 12))
;;>   (list a b c))}

(define-syntax let-optionals
  (syntax-rules ()
    ((let-optionals ls (var&default ... . rest) body ...)
     (let*-to-let let-optionals* ls () (var&default ... . rest) body ...))))

;;> \macro{(let-optionals* ls ((var default) ... [rest]) body ...)}
;;>
;;> \scheme{let*} equivalent to \scheme{let-optionals}.  Any required
;;> \var{default} values are evaluated in left-to-right order, with
;;> all preceding \var{var}s in scope.

;;> \macro{(opt-lambda ((var default) ... [rest]) body ...)}
;;>
;;> Shorthand for
;;> \schemeblock{
;;> (lambda (required ... . o)
;;>   (let-optionals o ((var default) ... [rest])
;;>      body ...))}

(define-syntax opt-lambda
  (syntax-rules ()
    ((opt-lambda vars . body)
     (lambda args (let-optionals args vars . body)))))

;;> \macro{(opt-lambda* ((var default) ... [rest]) body ...)}
;;>
;;> Variant of \scheme{opt-lambda} which binds using
;;> \scheme{let-optionals*}.

(define-syntax opt-lambda*
  (syntax-rules ()
    ((opt-lambda* vars . body)
     (lambda args (let-optionals* args vars . body)))))

;;> \macro{(define-opt (name (var default) ... [rest]) body ...)}
;;>
;;> Shorthand for
;;> \schemeblock{
;;> (define name (opt-lambda (var default) ... [rest]) body ...)}

(define-syntax define-opt
  (syntax-rules ()
    ((define-opt (name . vars) . body)
     (define name (opt-lambda vars . body)))))

;;> \macro{(define-opt* (name (var default) ... [rest]) body ...)}
;;>
;;> Shorthand for
;;> \schemeblock{
;;> (define name (opt-lambda* (var default) ... [rest]) body ...)}

(define-syntax define-opt*
  (syntax-rules ()
    ((define-opt* (name . vars) . body)
     (define name (opt-lambda* vars . body)))))

(define (mem-key key ls)
  (and (pair? ls)
       (pair? (cdr ls))
       (if (eq? key (car ls))
           ls
           (mem-key key (cddr ls)))))

;;> \procedure{(keyword-ref ls key [default])}
;;>
;;> Search for the identifier \var{key} in the list \var{ls}, treating
;;> it as a property list of the form \scheme{(key1 val1 key2 val2
;;> ...)}, and return the associated \var{val}.  If not found, return
;;> \var{default}, or \scheme{#f}.

(define (keyword-ref ls key . o)
  (cond ((mem-key key ls) => (lambda (cell) (cadr cell)))
        (else (and (pair? o) (car o)))))

;;> \macro{(keyword-ref* ls key default)}
;;>
;;> Macro equivalent of \scheme{keyword-ref}, where \var{default} is
;;> only evaluated if \var{key} is not found.

(define-syntax keyword-ref*
  (syntax-rules ()
    ((keyword-ref* ls key default)
     (cond ((mem-key key ls) => cadr) (else default)))))

(define (symbol->keyword sym)
  (string->symbol (string-append (symbol->string sym) ":")))

(define-syntax let-key*-to-let
  (syntax-rules ()
    ((let-key*-to-let ls (vars ...) ((v d) . rest) . body)
     (let-key*-to-let ls (vars ... (v tmp ,(symbol->keyword 'v) d)) rest
                      . body))
    ((let-key*-to-let ls (vars ...) ((v k d) . rest) . body)
     (let-key*-to-let ls (vars ... (v tmp k d)) rest . body))
    ((let-key*-to-let ls ((var tmp k d) ...) rest . body)
     (let-keywords* ls ((tmp k d) ... . rest)
       (let ((var tmp) ...) . body)))))

;;> \macro{(let-keywords ls ((var [keyword] default) ... [rest]) body ...)}
;;>
;;> Analogous to \scheme{let-optionals}, except instead of binding the
;;> \var{var}s by position they are bound by name, by searching in
;;> \var{ls} with \scheme{keyword-ref*}.  If an optional \var{keyword}
;;> argument is provided it must be an identifier to use as the name,
;;> otherwise \var{var} is used, appending a ":" (colon).  If the name
;;> is not found, \var{var} is bound to \var{default}, even if unused
;;> names remain in \var{ls}.
;;>
;;> Keyword arguments have precedence in CommonLisp, DSSSL, and SRFI
;;> 89.  However, unlike these systems you cannot mix optional and
;;> keyword arguments.
;;>
;;> If an optional trailing identifier \var{rest} is provided, it is
;;> bound to the list of unused arguments not bound to any \var{var}.
;;> This is useful for chaining together keyword argument procedures -
;;> you can extract just the arguments you need and pass on the rest
;;> to another procedure.  The \var{rest} usage is similar to Python's
;;> \code{**args} (again predated by CommonLisp and DSSSL).
;;>
;;> Note R7RS does not have a disjoint keyword type or auto-quoting
;;> syntax for keywords - they are simply identifiers (though no type
;;> checking is performed).  Thus when passing keyword arguments they
;;> must be quoted (or otherwise dynamically evaluated).
;;>
;;> \emph{Example:}
;;> \example{
;;> (define (make-person . o)
;;>   (let-keywords o ((name "John Doe")
;;>                    (age 0)
;;>                    (occupation job: 'unemployed))
;;>     (vector name age occupation)))
;;>
;;> (list (make-person)
;;>       (make-person 'name: "Methuselah" 'age: 969)
;;>       (make-person 'name: "Dr. Who" 'job: 'time-lord 'age: 1500))
;;> }
;;>
;;> \emph{Example:}
;;> \example{
;;> (let-keywords '(b: 2 a: 1 other: 9)
;;>     ((a 0) (b 0) (c 0) rest)
;;>   (list a b c rest))
;;> }
;;>
;;> \emph{Example:}
;;> \example{
;;> (define (auth-wrapper proc)
;;>   (lambda o
;;>     (let-keywords o ((user #f)
;;>                      (password #f)
;;>                      rest)
;;>       (if (authenticate? user password)
;;>           (apply proc rest)
;;>           (error "access denied")))))
;;>
;;> ((auth-wrapper make-payment) 'user: "bob" 'password: "5ecret" 'amount: 50)
;;> }

(define-syntax let-keywords
  (syntax-rules ()
    ((let-keywords ls vars . body)
     (let-key*-to-let ls () vars . body))))

;; Returns the plist ls filtering out key-values found in keywords.
(define (remove-keywords ls keywords)
  (let lp ((ls ls) (res '()))
    (if (and (pair? ls) (pair? (cdr ls)))
        (if (memq (car ls) keywords)
            (lp (cddr ls) res)
            (lp (cddr ls) (cons (cadr ls) (cons (car ls) res))))
        (reverse res))))

;; Extracts the known keywords from a let-keyword spec and removes
;; them from the opt-ls.
(define-syntax remove-keywords*
  (syntax-rules ()
    ((remove-keywords* opt-ls (keys ...) ((var key default) . rest))
     (remove-keywords* opt-ls (keys ... key) rest))
    ((remove-keywords* opt-ls (keys ...) ((var default) . rest))
     (remove-keywords* opt-ls (keys ... ,(symbol->keyword* 'var)) rest))
    ((remove-keywords* opt-ls (keys ...) ())
     (remove-keywords opt-ls `(keys ...)))))

;;> \macro{(let-keywords* ls ((var [keyword] default) ... [rest]) body ...)}
;;>
;;> \scheme{let*} equivalent to \scheme{let-keywords}.  Any required
;;> \var{default} values are evaluated in left-to-right order, with
;;> all preceding \var{var}s in scope.
;;>
;;> \emph{Example:}
;;> \example{
;;> (let-keywords* '(b: 5)
;;>     ((a 1) (b (* a 2)) (c (* b 3)))
;;>   (list a b c))
;;> }

(define-syntax let-keywords*
  (syntax-rules ()
    ((let-keywords* opt-ls () . body)
     (begin . body))
    ((let-keywords* (op . args) vars . body)
     (let ((tmp (op . args)))
       (let-keywords* tmp vars . body)))
    ((let-keywords* opt-ls ((var) (vars . x) ...) . body)
     (let-keywords* opt-ls ((var #f) (vars . x) ...) . body))
    ((let-keywords* opt-ls ((var default) (vars . x) ...) . body)
     (let ((var (keyword-ref* opt-ls (symbol->keyword* 'var) default)))
       (let-keywords* opt-ls ((vars . x) ...) . body)))
    ((let-keywords* opt-ls ((var key default) (vars . x) ...) . body)
     (let ((var (keyword-ref* opt-ls `key default)))
       (let-keywords* opt-ls ((vars . x) ...) . body)))
    ((let-keywords* opt-ls ((vars . x) ... tail) . body)
     (let ((tail (remove-keywords* opt-ls () ((vars . x) ...))))
       (let-keywords* opt-ls ((vars . x) ...) . body)))))

;;> A general, non-filesystem-specific pathname library.

(define-library (chibi pathname)
  (export path-strip-directory path-directory
          path-extension path-strip-extension path-replace-extension
          path-absolute? path-relative? path-strip-leading-parents
          path-relative-to path-resolve path-normalize make-path)
  (cond-expand
   (chibi (import (chibi)))
   (else (import (except (scheme base) string-map string-for-each))))
  (import (chibi string))
  (include "pathname.scm"))

(define-library (chibi pty)
  (import (scheme base)
          (chibi filesystem)
          (chibi process)
          (chibi string)
          (chibi stty)
          (only (chibi) fileno?))
  (export open-pty fork-pty login-tty
          open-pty-process call-with-pty-process-io)
  (include-shared "pty")
  (begin
    (define (winsize-arg o)
      (cond
       ((and (pair? o) (integer? (car o)))
        (unless (and (pair? (cdr o)) (integer? (cadr o)))
          (error "open-pty expects integer width and height" o))
        (make-winsize (car o) (cadr o)))
       ((and (pair? o) (pair? (cdr o)))  (cadr o))
       (else #f)))
    (define (open-pty . o)
      (let ((termios (and (pair? o) (car o)))
            (winsize (winsize-arg (if (pair? o) (cdr o) '()))))
        (openpty termios winsize)))
    (define (fork-pty . o)
      (let ((termios (and (pair? o) (car o)))
            (winsize (winsize-arg (if (pair? o) (cdr o) '()))))
        (forkpty termios winsize)))
    (define (open-pty-process command . o)
      (let* ((command (if (and (string? command)
                               (string-find? command #\space))
                          (string-split command)
                          command))
             (pty (apply fork-pty o)))
        (cond
         ((not (and (pair? pty) (integer? (car pty))
                    (not (negative? (car pty)))
                    (pair? (cdr pty)) (fileno? (cadr pty))))
          (error "failed to fork-pty" pty))
         ((zero? (car pty))  ; child
          (execute (car command) command))
         (else               ; parent
          pty))))
    (define (call-with-pty-process-io command proc . o)
      (unless (procedure? proc)
        (error "call-with-pty-process-io expected procedure" proc))
      (let ((pty (apply open-pty-process command o)))
        (if (and (pair? pty)
                 (integer? (car pty))
                 (not (negative? (car pty)))
                 (fileno? (cadr pty)))
            (let* ((pid (car pty))
                   (fd (cadr pty))
                   (name (and (pair? (cddr pty)) (car (cddr pty))))
                   (in (open-input-file-descriptor fd))
                   (out (open-output-file-descriptor fd))
                   (res (proc pid in out name)))
              (close-input-port in)
              (close-output-port out)
              (close-file-descriptor fd)
              res)
            (error "couldn't open-pty-process" command o pty))))))

(define-library (chibi edit-distance)
  (export edit-distance find-nearest-edits)
  (import (scheme base) (srfi 130))
  (begin
    ;;> Returns the levenshtein distance between s1 and s2 - a cost of
    ;;> 1 per character insertion, deletion or update.  Runs in
    ;;> quadratic time and linear memory.
    ;;>
    ;;> \example{(edit-distance "same" "same")}
    ;;> \example{(edit-distance "same" "sand")}
    ;;> \example{(edit-distance "Saturday" "Sunday")}
    (define (edit-distance s1 s2)
      (let* ((len1 (string-length s1))
             (len2 (string-length s2))
             (vec (make-vector (+ len1 1) 0)))
        (do ((i 0 (+ i 1)))
            ((> i len1))
          (vector-set! vec i i))
        (do ((i 1 (+ i 1))
             (sc2 (string-cursor-start s2) (string-cursor-next s2 sc2)))
            ((> i len2)
             (vector-ref vec len1))
          (vector-set! vec 0 i)
          (let ((ch2 (string-ref/cursor s2 sc2)))
            (let lp ((j 1)
                     (sc1 (string-cursor-start s1))
                     (last-diag (- i 1)))
              (when (<= j len1)
                (let ((old-diag (vector-ref vec j))
                      (ch1 (string-ref/cursor s1 sc1)))
                  (vector-set! vec j (min (+ (vector-ref vec j) 1)
                                          (+ (vector-ref vec (- j 1)) 1)
                                          (+ last-diag
                                             (if (eqv? ch1 ch2) 0 1))))
                  (lp (+ j 1)
                      (string-cursor-next s1 sc1)
                      old-diag))))))))
    ;;> Returns a list of strings in \var{str-ls} with the smallest
    ;;> edit distance to \var{str}, preserving order.  If
    ;;> \var{max-distance} is provided and positive, only return if
    ;;> the edits are less or equal to that distance.
    (define (find-nearest-edits str str-ls . o)
      (let ((max-distance (if (pair? o) (car o) 1e100)))
        (let lp ((ls str-ls) (dist (+ max-distance 1)) (res '()))
          (if (null? ls)
              (reverse res)
              (let ((ed (edit-distance str (car ls))))
                (cond
                 ((= ed dist) (lp (cdr ls) dist (cons (car ls) res)))
                 ((< ed dist) (lp (cdr ls) ed (list (car ls))))
                 (else (lp (cdr ls) dist res))))))))))
(define-library (chibi syntax-case-test)
  (export run-tests)
  (import (except (chibi) define-syntax let-syntax letrec-syntax)
          (chibi syntax-case)
          (chibi test))
  (begin
    (define (run-tests)
      (test-begin "syntax case")

      (test "syntax constant list"
          '(+ 1 2)
        #'(+ 1 2))

      (test "pattern variable"
          'foo
        (syntax-case 'foo ()
          (x #'x)))

      (test "syntax-case pair"
          '(a b)
        (syntax-case '(a . b) ()
          ((x . y) #'(x y))))

      (test "syntax-case var"
          'a
        (syntax-case '(a . b) (b)
          ((b . y) #f)
          ((x . b) #'x)))

      (test "syntax-case simple ellipsis"
          '(a b c)
        (syntax-case '(a b c) ()
          ((a ...) #'(a ...))))

      (test "syntax-case ellipsis with tail"
          '(a b x c)
        (syntax-case '(a b c) ()
          ((a ... b) #'(a ... x b))))

      (test "syntax-case ellipsis with dotted tail"
          '(a b x c y d)
        (syntax-case '(a b c . d) ()
          ((a ... b . c) #'(a ... x b y c))))

      (test "syntax-case nested ellipsis"
          '((a b) (d e) c f)
        (syntax-case '((a b c) (d e f)) ()
          (((x ... y) ...) #'((x ...) ... y ...))))

      (test "with-ellipsis"
          '((a b))
        (with-ellipsis :::
                       (syntax-case '(a) ()
                         ((... :::) #'((... b) :::)))))

      (test-end))))
(define-library (chibi base64-test)
  (export run-tests)
  (import (scheme base) (chibi base64) (chibi string) (chibi test))
  (begin
    (define (run-tests)
      (test-begin "base64")

      (test "YW55IGNhcm5hbCBwbGVhc3VyZS4="
          (base64-encode-string "any carnal pleasure."))
      (test "YW55IGNhcm5hbCBwbGVhc3VyZQ=="
          (base64-encode-string "any carnal pleasure"))
      (test "YW55IGNhcm5hbCBwbGVhc3Vy"
          (base64-encode-string "any carnal pleasur"))
      (test "YW55IGNhcm5hbCBwbGVhc3U="
          (base64-encode-string "any carnal pleasu"))
      (test "YW55IGNhcm5hbCBwbGVhcw=="
          (base64-encode-string "any carnal pleas"))

      (test "any carnal pleas"
          (base64-decode-string "YW55IGNhcm5hbCBwbGVhcw=="))
      (test "any carnal pleasu"
          (base64-decode-string "YW55IGNhcm5hbCBwbGVhc3U="))
      (test "any carnal pleasur"
          (base64-decode-string "YW55IGNhcm5hbCBwbGVhc3Vy"))
      (test "any carnal pleas"
          (base64-decode-string "YW55IGNhcm5hbCBwbGVhcw"))
      (test "any carnal pleasu"
          (base64-decode-string "YW55IGNhcm5hbCBwbGVhc3U"))

      (test "YW55IGNhcm5hbCBwbGVhc3VyZS4="
          (call-with-output-string
            (lambda (out)
              (call-with-input-string "any carnal pleasure."
                (lambda (in) (base64-encode in out))))))

      (test "any carnal pleasure."
          (call-with-output-string
            (lambda (out)
              (call-with-input-string "YW55IGNhcm5hbCBwbGVhc3VyZS4="
                (lambda (in) (base64-decode in out))))))

      (test-end))))
(define (list-bindings env)
  (let parents ((env env) (binds '()))
    (if (not env) binds
        (let symbols ((syms (env-exports env)) (binds binds))
          (if (null? syms) (parents (env-parent env) binds)
              (symbols (cdr syms) (if (assv (car syms) binds) binds
                                      (cons (cons (car syms) env)
                                            binds))))))))

(define (apropos-list-bindings query)
  (cond ((symbol? query) (set! query (symbol->string query)))
        ((not (string? query))
         (error "Apropos query must be a symbol or a string")))
  (sort (filter (lambda (binding)
                  (string-contains (symbol->string (car binding)) query))
                (list-bindings (interaction-environment)))
        (lambda (a b) (string<? (symbol->string (car a))
                                (symbol->string (car b))))))

(define (apropos-list query) (map car (apropos-list-bindings query)))

(define (apropos-prefix sym env)
  (let ((p "procedure  ")
        (s "syntax     ")
        (v "variable   "))
    (guard (_ (else s)) (if (procedure? (eval sym env)) p v))))

(define (apropos query)
  (for-each (lambda (bind)
              (display (apropos-prefix (car bind) (cdr bind)))
              (write (car bind))
              (newline))
            (apropos-list-bindings query)))
(define-library (chibi term ansi-test)
  (export run-tests)
  (import (scheme base)
          (scheme write)
          (chibi term ansi))
  (begin
    ;; inline (chibi test) to avoid circular dependencies in snow
    ;; installations
    (define-syntax test
      (syntax-rules ()
        ((test expect expr)
         (test 'expr expect expr))
        ((test name expect expr)
         (guard (exn
                 (else
                  (display "!\nERROR: ")
                  (write name)
                  (newline)
                  (write exn)
                  (newline)))
           (let* ((res expr)
                  (pass? (equal? expect expr)))
             (display (if pass? "." "x"))
             (cond
              ((not pass?)
               (display "\nFAIL: ")
               (write name)
               (newline))))))))
    (define-syntax test-assert
      (syntax-rules ()
        ((test-assert expr) (test #t expr))))
    (define-syntax test-error
      (syntax-rules ()
        ((test-error expr)
         (test-assert (guard (exn (else #t)) expr #f)))))
    (define-syntax test-escape-procedure
      (syntax-rules ()
        ((test-escape-procedure p s)
         (begin
           (test-assert (procedure? p))
           ;;(test-error (p #f))
           (test s (p))))))
    (define-syntax test-wrap-procedure
      (syntax-rules ()
        ((test-wrap-procedure p s)
         (begin
           (test-assert (procedure? p))
           ;; (test-error (p))
           ;; (test-error (p #f))
           ;; (test-error (p "" #f))
           (test (p "FOO")
               "FOO"
             (parameterize ((ansi-escapes-enabled? #f)) (p "FOO")))
           (test (p "FOO")
               s
             (parameterize ((ansi-escapes-enabled? #t)) (p "FOO")))))))
    (define (test-begin name)
      (display name))
    (define (test-end)
      (newline))
    (define (run-tests)
      (test-begin "term.ansi")

      (test-assert (procedure? ansi-escapes-enabled?))
      (test-assert
          (let ((tag (cons #t #t)))
            (eqv? tag
                  (parameterize ((ansi-escapes-enabled? tag))
                    (ansi-escapes-enabled?)))))

      (test-escape-procedure black-escape       "\x1b;[30m")
      (test-escape-procedure red-escape         "\x1b;[31m")
      (test-escape-procedure green-escape       "\x1b;[32m")
      (test-escape-procedure yellow-escape      "\x1b;[33m")
      (test-escape-procedure blue-escape        "\x1b;[34m")
      (test-escape-procedure cyan-escape        "\x1b;[36m")
      (test-escape-procedure magenta-escape     "\x1b;[35m")
      (test-escape-procedure white-escape       "\x1b;[37m")
      (test-escape-procedure reset-color-escape "\x1b;[39m")

      (test-assert (procedure? rgb-escape))
      (test-error (rgb-escape))
      (test-error (rgb-escape 0))
      (test-error (rgb-escape 0 0))
      (test-error (rgb-escape 0 0 0 0))
      (test-error (rgb-escape 0.0 0 0))
      (test-error (rgb-escape 0 0.0 0))
      (test-error (rgb-escape 0 0 0.0))
      (test-error (rgb-escape -1 0 0))
      (test-error (rgb-escape 0 -1 0))
      (test-error (rgb-escape 0 0 -1))
      (test-error (rgb-escape 6 0 0))
      (test-error (rgb-escape 0 6 0))
      (test-error (rgb-escape 0 0 6))
      (test-escape-procedure (lambda () (rgb-escape 0 0 0)) "\x1B;[38;5;16m")
      (test-escape-procedure (lambda () (rgb-escape 5 0 0)) "\x1B;[38;5;196m")
      (test-escape-procedure (lambda () (rgb-escape 0 5 0)) "\x1B;[38;5;46m")
      (test-escape-procedure (lambda () (rgb-escape 0 0 5)) "\x1B;[38;5;21m")
      (test-escape-procedure (lambda () (rgb-escape 1 1 1)) "\x1B;[38;5;59m")
      (test-escape-procedure (lambda () (rgb-escape 2 2 2)) "\x1B;[38;5;102m")
      (test-escape-procedure (lambda () (rgb-escape 3 3 3)) "\x1B;[38;5;145m")
      (test-escape-procedure (lambda () (rgb-escape 4 4 4)) "\x1B;[38;5;188m")
      (test-escape-procedure (lambda () (rgb-escape 5 5 5)) "\x1B;[38;5;231m")
      (test-escape-procedure (lambda () (rgb-escape 1 3 5)) "\x1B;[38;5;75m")
      (test-escape-procedure (lambda () (rgb-escape 5 1 3)) "\x1B;[38;5;205m")
      (test-escape-procedure (lambda () (rgb-escape 3 5 1)) "\x1B;[38;5;155m")

      (test-assert (procedure? gray-escape))
      (test-error (gray-escape))
      (test-error (gray-escape 0 0))
      (test-error (gray-escape 0.0))
      (test-error (gray-escape -1))
      (test-error (gray-escape 24))
      (test-escape-procedure (lambda () (gray-escape  0)) "\x1B;[38;5;232m")
      (test-escape-procedure (lambda () (gray-escape 23)) "\x1B;[38;5;255m")
      (test-escape-procedure (lambda () (gray-escape 12)) "\x1B;[38;5;244m")

      (test-wrap-procedure   black       "\x1b;[30mFOO\x1b;[39m")
      (test-wrap-procedure   red         "\x1b;[31mFOO\x1b;[39m")
      (test-wrap-procedure   green       "\x1b;[32mFOO\x1b;[39m")
      (test-wrap-procedure   yellow      "\x1b;[33mFOO\x1b;[39m")
      (test-wrap-procedure   blue        "\x1b;[34mFOO\x1b;[39m")
      (test-wrap-procedure   cyan        "\x1b;[36mFOO\x1b;[39m")
      (test-wrap-procedure   magenta     "\x1b;[35mFOO\x1b;[39m")
      (test-wrap-procedure   white       "\x1b;[37mFOO\x1b;[39m")
      (test-wrap-procedure   (rgb 0 0 0) "\x1B;[38;5;16mFOO\x1b;[39m")
      (test-wrap-procedure   (rgb 5 5 5) "\x1B;[38;5;231mFOO\x1b;[39m")
      (test-wrap-procedure   (gray 0)    "\x1B;[38;5;232mFOO\x1b;[39m")
      (test-wrap-procedure   (gray 23)   "\x1B;[38;5;255mFOO\x1b;[39m")
      (test-wrap-procedure   (rgb24 #xA6 #x7B #x5B) "\x1B;[38;2;166;123;91mFOO\x1b;[39m")

      (test-escape-procedure black-background-escape       "\x1b;[40m")
      (test-escape-procedure red-background-escape         "\x1b;[41m")
      (test-escape-procedure green-background-escape       "\x1b;[42m")
      (test-escape-procedure yellow-background-escape      "\x1b;[43m")
      (test-escape-procedure blue-background-escape        "\x1b;[44m")
      (test-escape-procedure cyan-background-escape        "\x1b;[46m")
      (test-escape-procedure magenta-background-escape     "\x1b;[45m")
      (test-escape-procedure white-background-escape       "\x1b;[47m")
      (test-escape-procedure reset-background-color-escape "\x1b;[49m")

      (test-assert (procedure? rgb-background-escape))
      (test-error (rgb-background-escape))
      (test-error (rgb-background-escape 0))
      (test-error (rgb-background-escape 0 0))
      (test-error (rgb-background-escape 0 0 0 0))
      (test-error (rgb-background-escape 0.0 0 0))
      (test-error (rgb-background-escape 0 0.0 0))
      (test-error (rgb-background-escape 0 0 0.0))
      (test-error (rgb-background-escape -1 0 0))
      (test-error (rgb-background-escape 0 -1 0))
      (test-error (rgb-background-escape 0 0 -1))
      (test-error (rgb-background-escape 6 0 0))
      (test-error (rgb-background-escape 0 6 0))
      (test-error (rgb-background-escape 0 0 6))
      (test-escape-procedure
       (lambda () (rgb-background-escape 0 0 0)) "\x1B;[48;5;16m")
      (test-escape-procedure
       (lambda () (rgb-background-escape 5 0 0)) "\x1B;[48;5;196m")
      (test-escape-procedure
       (lambda () (rgb-background-escape 0 5 0)) "\x1B;[48;5;46m")
      (test-escape-procedure
       (lambda () (rgb-background-escape 0 0 5)) "\x1B;[48;5;21m")
      (test-escape-procedure
       (lambda () (rgb-background-escape 1 1 1)) "\x1B;[48;5;59m")
      (test-escape-procedure
       (lambda () (rgb-background-escape 2 2 2)) "\x1B;[48;5;102m")
      (test-escape-procedure
       (lambda () (rgb-background-escape 3 3 3)) "\x1B;[48;5;145m")
      (test-escape-procedure
       (lambda () (rgb-background-escape 4 4 4)) "\x1B;[48;5;188m")
      (test-escape-procedure
       (lambda () (rgb-background-escape 5 5 5)) "\x1B;[48;5;231m")
      (test-escape-procedure
       (lambda () (rgb-background-escape 1 3 5)) "\x1B;[48;5;75m")
      (test-escape-procedure
       (lambda () (rgb-background-escape 5 1 3)) "\x1B;[48;5;205m")
      (test-escape-procedure
       (lambda () (rgb-background-escape 3 5 1)) "\x1B;[48;5;155m")

      (test-assert (procedure? gray-background-escape))
      (test-error (gray-background-escape))
      (test-error (gray-background-escape 0 0))
      (test-error (gray-background-escape 0.0))
      (test-error (gray-background-escape -1))
      (test-error (gray-background-escape 24))
      (test-escape-procedure
       (lambda () (gray-background-escape  0)) "\x1B;[48;5;232m")
      (test-escape-procedure
       (lambda () (gray-background-escape 23)) "\x1B;[48;5;255m")
      (test-escape-procedure
       (lambda () (gray-background-escape 12)) "\x1B;[48;5;244m")

      (test-wrap-procedure   black-background       "\x1b;[40mFOO\x1b;[49m")
      (test-wrap-procedure   red-background         "\x1b;[41mFOO\x1b;[49m")
      (test-wrap-procedure   green-background       "\x1b;[42mFOO\x1b;[49m")
      (test-wrap-procedure   yellow-background      "\x1b;[43mFOO\x1b;[49m")
      (test-wrap-procedure   blue-background        "\x1b;[44mFOO\x1b;[49m")
      (test-wrap-procedure   cyan-background        "\x1b;[46mFOO\x1b;[49m")
      (test-wrap-procedure   magenta-background     "\x1b;[45mFOO\x1b;[49m")
      (test-wrap-procedure   white-background       "\x1b;[47mFOO\x1b;[49m")
      (test-wrap-procedure   (rgb-background 0 0 0) "\x1B;[48;5;16mFOO\x1b;[49m")
      (test-wrap-procedure   (rgb-background 5 5 5) "\x1B;[48;5;231mFOO\x1b;[49m")
      (test-wrap-procedure   (gray-background 0)    "\x1B;[48;5;232mFOO\x1b;[49m")
      (test-wrap-procedure   (gray-background 23)   "\x1B;[48;5;255mFOO\x1b;[49m")

      (test-escape-procedure bold-escape            "\x1b;[1m")
      (test-escape-procedure reset-bold-escape      "\x1b;[22m")
      (test-wrap-procedure   bold                   "\x1b;[1mFOO\x1b;[22m")

      (test-escape-procedure underline-escape       "\x1b;[4m")
      (test-escape-procedure reset-underline-escape "\x1b;[24m")
      (test-wrap-procedure   underline              "\x1b;[4mFOO\x1b;[24m")

      (test-escape-procedure negative-escape        "\x1b;[7m")
      (test-escape-procedure reset-negative-escape  "\x1b;[27m")
      (test-wrap-procedure   negative               "\x1b;[7mFOO\x1b;[27m")

      (test-end))))
(define-library (chibi term ansi)
  (export

   black-escape red-escape yellow-escape green-escape
   blue-escape cyan-escape magenta-escape white-escape
   rgb-escape 
   gray-escape
   rgb24-escape 
   reset-color-escape

   black-background-escape red-background-escape
   yellow-background-escape green-background-escape
   blue-background-escape cyan-background-escape
   magenta-background-escape white-background-escape
   rgb-background-escape
   gray-background-escape
   rgb24-background-escape
   reset-background-color-escape

   black red yellow green
   blue cyan magenta white
   black-background red-background yellow-background green-background
   blue-background cyan-background magenta-background white-background
   bold
   underline
   negative
   italic
   strikethrough
   rgb rgb-background
   gray gray-background
   rgb24 rgb24-background
   bold-escape reset-bold-escape
   underline-escape reset-underline-escape
   negative-escape reset-negative-escape
   italic-escape reset-italic-escape
   strikethrough-escape reset-strikethrough-escape

   ansi-escapes-enabled?)
  (import (scheme base)
          (scheme write)
          (scheme process-context))
  (include "ansi.scm"))
;;;; edit-line.scm - pure scheme line editor
;;
;; Copyright (c) 2011-2017 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; vt100 terminal utilities

(define (terminal-escape out ch arg)
  (write-char (integer->char 27) out)
  (write-char #\[ out)
  (if arg (display arg out))
  (write-char ch out)
  (flush-output-port out))

;; we use zero-based columns
(define (terminal-goto-col out n)  (terminal-escape out #\G (+ n 1)))
(define (terminal-up out n)        (terminal-escape out #\A n))
(define (terminal-down out n)      (terminal-escape out #\B n))
(define (terminal-clear-below out) (terminal-escape out #\J #f))
(define (terminal-clear-right out) (terminal-escape out #\K #f))

(define (read-numeric-sequence in)
  (let lp ((c (peek-char in)) (acc '()))
    (case c
      ((#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9)
       (read-char in)  ;; skip peeked char
       (lp (peek-char in) (cons c acc)))
      (else
       (string->number (apply string (reverse acc)))))))

(define (terminal-current-position in out)
  (with-stty '(not icanon isig echo)
    (lambda ()
      (terminal-escape out #\n 6)
      (read-char in)
      (and (eqv? #\[ (read-char in))
           (let ((y (read-numeric-sequence in)))
             (and y
                  (eqv? #\; (read-char in))
                  (let ((x (read-numeric-sequence in)))
                    (and x
                         (eqv? #\R (read-char in))
                         (list (- y 1) (- x 1))))))))))

(define (at-first-column? in out)
  (let ((pos (terminal-current-position in out)))
    (and pos (zero? (cadr pos)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; history

(define maximum-history-size 512)

(define-record-type History
  (%make-history remaining past future filter)
  history?
  (remaining history-remaining history-remaining-set!)
  (past history-past history-past-set!)
  (future history-future history-future-set!)
  (filter history-filter history-filter-set!))

(define (make-history . o)
  (%make-history (if (pair? o) (car o) maximum-history-size)
                 '()
                 '()
                 (and (pair? o) (pair? (cdr o)) (cadr o))))

(define (history-current h)
  (let ((p (history-past h)))
    (and (pair? p) (car p))))

(define (history->list h)
  (let ((past (history-past h)) (future (history-future h)))
    (if (pair? past) (cons (car past) (append future (cdr past))) future)))

(define (list->history ls . o)
  (%make-history (max maximum-history-size (length ls)) ls '()
                 (and (pair? o) (car o))))

(define (history-flatten! h)
  (history-past-set! h (history->list h))
  (history-future-set! h '()))

(define (drop-last ls) (reverse (cdr (reverse ls))))

(define (history-past-push! h x)
  (if (positive? (history-remaining h))
      (history-remaining-set! h (- (history-remaining h) 1))
      (if (pair? (history-past h))
          (history-past-set! h (drop-last (history-past h)))
          (history-future-set! h (drop-last (history-future h)))))
  (history-past-set! h (cons x (history-past h))))

(define (history-insert! h x)
  (history-flatten! h)
  (if (not (and (history-filter h) ((history-filter h) x)))
      (history-past-push! h x)))

(define (history-reset! h)
  (cond
   ((pair? (history-future h))
    (history-past-set! h (append (drop-last (history-future h))
                                 (history-past h)))
    (history-future-set! h '()))))

(define (history-commit! h x)
  (history-reset! h)
  (if (not (and (pair? (history-past h)) (equal? x (car (history-past h)))))
      (history-insert! h x)))

(define (history-prev! h)
  (let ((past (history-past h)))
    (and (pair? past)
         (pair? (cdr past))
         (begin
           (history-future-set! h (cons (car past) (history-future h)))
           (history-past-set! h (cdr past))
           (cadr past)))))

(define (history-next! h)
  (let ((future (history-future h)))
    (and (pair? future)
         (begin
           (history-past-set! h (cons (car future) (history-past h)))
           (history-future-set! h (cdr future))
           (car future)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; char and string utils

(define (char-word-constituent? ch)
  (or (char-alphabetic? ch) (char-numeric? ch)
      (memv ch '(#\_ #\- #\+ #\:))))

(define (char-non-word-constituent? ch) (not (char-word-constituent? ch)))

(define (string-copy! dst dstart src start end)
  (if (>= start dstart)
      (do ((i start (+ i 1)) (j dstart (+ j 1)))
          ((= i end))
        (string-set! dst j (string-ref src i)))
      (do ((i (- end 1) (- i 1)) (j (+ dstart (- end start 1)) (- j 1)))
          ((< i start))
        (string-set! dst j (string-ref src i)))))

(define (string-index ch x)
  (let ((len (string-length x)))
    (let lp ((i 0))
      (cond ((>= i len) #f)
            ((eqv? ch (string-ref x i)))
            (else (lp (+ i 1)))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; buffers

(define-record-type Buffer
  (%make-buffer refresh? cleared? min pos row max-row col gap start width
                string history complete? single-line?)
  buffer?
  (refresh? buffer-refresh? buffer-refresh?-set!)
  (cleared? buffer-cleared? buffer-cleared?-set!)
  (min buffer-min buffer-min-set!)
  (pos buffer-pos buffer-pos-set!)
  (row buffer-row buffer-row-set!)
  (max-row buffer-max-row buffer-max-row-set!)
  (col buffer-col buffer-col-set!)
  (gap buffer-gap buffer-gap-set!)
  (start buffer-start buffer-start-set!)
  (width buffer-width buffer-width-set!)
  (string buffer-string buffer-string-set!)
  (kill-ring buffer-kill-ring buffer-kill-ring-set!)
  (history buffer-history buffer-history-set!)
  (complete? buffer-complete? buffer-complete?-set!)
  (single-line? buffer-single-line? buffer-single-line?-set!))

(define default-buffer-size 256)
(define default-buffer-width 80)

(define (make-buffer)
  (%make-buffer #f #f 0 0 0 0 0 default-buffer-size 0 default-buffer-width
                (make-string default-buffer-size) '() #f #f))

(define (buffer->string buf)
  (let ((str (buffer-string buf)))
    (string-append (substring str (buffer-min buf) (buffer-pos buf))
                   (substring str (buffer-gap buf) (string-length str)))))

(define (buffer-right-length buf)
  (- (string-length (buffer-string buf)) (buffer-gap buf)))
(define (buffer-length buf)
  (+ (buffer-pos buf) (buffer-right-length buf)))
(define (buffer-free-space buf)
  (- (buffer-gap buf) (buffer-pos buf)))

(define (buffer-clamp buf n)
  (max (buffer-min buf) (min n (buffer-length buf))))

(define (buffer-resize buf n)
  (cond ((<= (buffer-free-space buf) n)
         (let* ((right-len (buffer-right-length buf))
                (new-len (* 2 (max n (buffer-length buf))))
                (new-gap (- new-len right-len))
                (new (make-string new-len))
                (old (buffer-string buf)))
           (string-copy! new 0 old 0 (buffer-pos buf))
           (string-copy! new new-gap old (buffer-gap buf) (string-length old))
           (buffer-string-set! buf new)
           (buffer-gap-set! buf new-gap)))))

;; Adapted from fmt-unicode. TODO: convert to char-sets.
(define low-non-spacing-chars '#u8(
#xff #xff #xff #xff #xff #xff #xff #xff #xff #xff #xff #xff #xff #xff    0    0
   0    0    0    0    0    0    0    0    0    0    0    0    0    0    0    0
   0    0    0    0    0    0    0    0    0    0    0    0    0    0    0    0
#x78    0    0    0    0    0    0    0    0    0    0    0    0    0    0    0
   0    0    0    0    0    0    0    0    0    0    0    0    0    0    0    0
   0    0 #xfe #xff #xff #xff #xff #xff #x1f    0    0    0    0    0    0    0
   0    0 #x3f    0    0    0    0    0    0 #xf8 #xff #x01    0    0 #x01    0
   0    0    0    0    0    0    0    0    0    0 #xc0 #xff #xff #x3f    0    0
   0    0 #x02    0    0    0 #xff #xff #xff #x07    0    0    0    0    0    0
   0    0    0    0 #xc0 #xff #x01    0    0    0    0    0    0    0    0    0
   0    0    0    0    0    0    0    0    0    0    0    0    0    0    0    0
   0    0    0    0    0    0    0    0    0    0    0    0    0    0    0    0
#x06    0    0    0    0    0    0 #x10 #xfe #x21 #x1e    0 #x0c    0    0    0
#x02    0    0    0    0    0    0 #x10 #x1e #x20    0    0 #x0c    0    0    0
#x06    0    0    0    0    0    0 #x10 #xfe #x3f    0    0    0    0 #x03    0
#x06    0    0    0    0    0    0 #x30 #xfe #x21    0    0 #x0c    0    0    0
#x02    0    0    0    0    0    0 #x90 #x0e #x20 #x40    0    0    0    0    0
#x04    0    0    0    0    0    0    0    0 #x20    0    0    0    0    0    0
   0    0    0    0    0    0    0 #xc0 #xc1 #xff #x7f    0    0    0    0    0
   0    0    0    0    0    0    0 #x10 #x40 #x30    0    0    0    0    0    0
   0    0    0    0    0    0    0    0 #x0e #x20    0    0    0    0    0    0
   0    0    0    0    0    0    0    0    0 #x04 #x7c    0    0    0    0    0
   0    0    0    0    0    0 #xf2 #x07 #x80 #x7f    0    0    0    0    0    0
   0    0    0    0    0    0 #xf2 #x1f    0 #x3f    0    0    0    0    0    0
   0    0    0 #x03    0    0 #xa0 #x02    0    0    0    0    0    0 #xfe #x7f
#xdf    0 #xff #xff #xff #xff #xff #x1f #x40    0    0    0    0    0    0    0
   0    0    0    0    0 #xe0 #xfd #x02    0    0    0 #x03    0    0    0    0
   0    0    0    0    0    0    0    0    0    0    0    0    0    0    0    0
   0    0    0    0    0    0    0    0    0    0    0    0    0    0    0    0
   0    0    0    0    0    0    0    0    0    0    0    0    0    0    0    0
   0    0    0    0    0    0    0    0    0    0    0    0    0    0    0    0
   0    0    0    0    0    0    0    0    0    0    0    0    0    0    0    0
   0    0    0    0    0    0    0    0    0    0    0    0    0    0    0    0
   0    0    0    0    0    0    0    0    0    0    0    0    0    0    0    0
   0    0    0    0    0    0    0    0    0    0    0    0    0    0    0    0
   0    0    0    0    0    0    0    0    0    0    0    0    0    0    0    0
   0    0    0    0    0    0    0    0    0    0    0    0    0    0    0    0
   0    0    0    0    0    0    0    0    0    0    0    0    0    0    0    0
   0    0    0    0    0    0    0    0    0    0    0    0    0    0    0    0
   0    0    0    0    0    0    0    0    0    0    0    0    0    0    0    0
   0    0 #x1c    0    0    0 #x1c    0    0    0 #x0c    0    0    0 #x0c    0
   0    0    0    0    0    0 #x80 #x3f #x40 #xfe #x0f #x20    0    0    0    0
   0 #x38    0    0    0    0    0    0    0    0    0    0    0    0    0    0
   0    0    0    0    0 #x02    0    0    0    0    0    0    0    0    0    0
   0    0    0    0 #x87 #x01 #x04 #x0e    0    0    0    0    0    0    0    0
   0    0    0    0    0    0    0    0    0    0    0    0    0    0    0    0
   0    0    0    0    0    0    0    0    0    0    0    0    0    0    0    0
   0    0    0    0    0    0    0    0    0    0    0    0    0    0    0    0
   0    0    0    0    0    0    0    0    0    0    0    0    0    0    0    0
   0    0    0    0    0    0    0    0    0    0    0    0    0    0    0    0
   0    0    0    0    0    0    0    0    0    0    0    0    0    0    0    0
   0    0    0    0    0    0    0    0    0    0    0    0    0    0    0    0
   0    0    0    0    0    0    0    0    0    0    0    0    0    0    0    0
   0    0    0    0    0    0    0    0    0    0    0    0    0    0    0    0
   0    0    0    0    0    0    0    0    0    0    0    0    0    0    0    0
   0    0    0    0    0    0    0    0    0    0    0    0    0    0    0    0
   0    0    0    0    0    0    0    0    0    0    0    0    0    0    0    0
   0    0    0    0    0    0    0    0    0    0    0    0    0    0    0    0
   0    0    0    0    0    0    0    0    0    0    0    0    0    0    0    0
   0    0    0    0    0    0    0    0    0    0 #xff #x1f #xe2 #x07))

(define (unicode-char-width c)
  (let ((ci (char->integer c)))
    (cond
      ;; hand-checked ranges from EastAsianWidth.txt
      ((<= #x1100 ci #x115F) 2) ; Hangul
      ((<= #x2E80 ci #x4DB5) 2) ; CJK
      ((<= #x4E00 ci #xA4C6) 2)
      ((<= #xAC00 ci #xD7A3) 2) ; Hangul
      ((<= #xF900 ci #xFAD9) 2) ; CJK compat
      ((<= #xFE10 ci #xFE6B) 2)
      ((<= #xFF01 ci #xFF60) 2)
      ((<= #xFFE0 ci #xFFE6) 2)
      ((<= #x20000 ci #x30000) 2)
      ;; non-spacing mark (Mn) ranges from UnicodeData.txt
      ((<= #x0300 ci #x20fd)  ; #x3029
       ;; inlined bit-vector-ref for portability
       (let* ((i (- ci #x0300))
              (byte (quotient i 8))
              (off (remainder i 8)))
         (if (zero? (bitwise-and (bytevector-u8-ref low-non-spacing-chars byte)
                                 (arithmetic-shift 1 off)))
             1
             0)))
      ((<= #x302A ci #x302F) 0)
      ((<= #x3099 ci #x309A) 0)
      ((= #xFB1E ci) 0)
      ((<= #xFE00 ci #xFE23) 0)
      ((<= #x1D167 ci #x1D169) 0)
      ((<= #x1D17B ci #x1D182) 0)
      ((<= #x1D185 ci #x1D18B) 0)
      ((<= #x1D1AA ci #x1D1AD) 0)
      ((<= #xE0100 ci #xE01EF) 0)
      (else 1))))

(define (unicode-string-width str . o)
  (let ((start (if (pair? o) (car o) 0))
        (end (if (and (pair? o) (pair? (cdr o)))
                 (cadr o)
                 (string-length str))))
    (let lp1 ((i start) (width 0))
      (if (>= i end)
          width
          (let ((c (string-ref str i)))
            (cond
              ;; ANSI escapes
              ((and (= 27 (char->integer c)) ; esc
                    (< (+ i 1) end)
                    (eqv? #\[ (string-ref str (+ i 1))))
               (let lp2 ((i (+ i 2)))
                 (cond ((>= i end) width)
                       ((memv (string-ref str i) '(#\m #\newline))
                        (lp1 (+ i 1) width))
                       (else (lp2 (+ i 1))))))
              ;; unicode characters
              ((>= (char->integer c) #x80)
               (lp1 (+ i 1) (+ width (unicode-char-width c))))
              ;; normal ASCII
              (else (lp1 (+ i 1) (+ width 1)))))))))

(define (buffer-update-position! buf)
  (let ((pos (buffer-pos buf))
        (gap (buffer-gap buf))
        (str (buffer-string buf))
        (end (string-length (buffer-string buf)))
        (width (buffer-width buf)))
    (cond
     ((buffer-single-line? buf)
      ;; The "start" is the last left-most column of the buffer when
      ;; we overflow and need to scroll horizontally.  This defaults
      ;; to 0 and increments as we move past the last column.  We
      ;; update it when we find that (via movement or insertion) the
      ;; point would no longer be visible from "start" to the end of
      ;; the line, by shifting the start to the rightmost column that
      ;; would show the point.  Thus, after scrolling off the
      ;; beginning of the buffer, successive movements left will first
      ;; go to the 0th column, then scroll to the start one character
      ;; at a time.  A beginning-of-line command will restore the
      ;; "start" to 0 immediately.
      ;; We assume no embedded newlines in this case.
      (let ((start (buffer-start buf))
            (min-width (unicode-string-width str 0 (buffer-min buf))))
        (cond
         ((> start pos)
          ;; We've moved back before the current start - reset to pos.
          (buffer-start-set! buf pos))
         ((> (+ 1 min-width (unicode-string-width str start pos))
             (buffer-width buf))
          ;; The edited text is wider than the screen - scroll the
          ;; start so that pos fits on the end.
          ;; TODO: This isn't correct for wide characters, need to
          ;; loop checking individual widths.
          (buffer-start-set!
           buf
           (max 0 (- (+ 1 min-width (unicode-string-width str 0 pos))
                     (buffer-width buf))))))
        ;; Compute the current column as the width of the prompt plus
        ;; the width of the visible buffer from start to pos.
        (let* ((vis-width (unicode-string-width str (buffer-start buf) pos))
               (col (+ min-width vis-width)))
          (buffer-col-set! buf col))))
     (else
      ;; Otherwise, in a multi-line editor we need to scan for
      ;; newlines to determine the current (relative) row and column.
      ;; TODO: Handle ANSI escapes.
      (let lp ((i 0) (row 0) (col 0)) ;; update row/col
        (cond ((= i pos)
               (buffer-row-set! buf row)
               (buffer-col-set! buf col)
               (lp gap row col))      ;; skip from pos->gap
              ((>= i end)
               (buffer-max-row-set!
                buf (if (and (zero? col) (> row 0)) (- row 1) row)))
              ((eqv? #\newline (string-ref str i))
               (lp (+ i 1) (+ row 1) 0))
              (else
               (let ((off (unicode-char-width (string-ref str i))))
                 (if (>= (+ col off) width)
                     (lp (+ i 1) (+ row 1) 0)
                     (lp (+ i 1) row (+ col off)))))))))))

(define (buffer-clear buf out)
  (cond
   ((not (buffer-cleared? buf))
    ;; goto start of input
    (terminal-goto-col out 0)
    (if (positive? (buffer-row buf))
        (terminal-up out (buffer-row buf)))
    ;; clear below
    (terminal-clear-below out)
    (buffer-cleared?-set! buf #t))))

(define (buffer-draw buf out)
  (let* ((gap (buffer-gap buf))
         (str (buffer-string buf))
         (end (string-length str))
         (old-row (buffer-row buf))
         (old-col (buffer-col buf)))
    ;; update position and clear the current input
    (buffer-clear buf out)
    (buffer-update-position! buf)
    (let ((left (if (buffer-single-line? buf)
                    (buffer-start buf)
                    (buffer-min buf)))
          (right
           (if (buffer-single-line? buf)
               (min end (+ (buffer-gap buf)
                           (- (buffer-width buf) (buffer-col buf))))
               end)))
      (display (substring str 0 (buffer-min buf)) out)
      (display (substring str left (buffer-pos buf)) out)
      (display (substring str (buffer-gap buf) right) out))
    (cond
     ((not (buffer-single-line? buf))
      ;; move to next line if point at eol
      (if (and (zero? (buffer-col buf)) (positive? (buffer-row buf)))
          (write-char #\space out))
      ;; move to correct row then col
      (if (< (buffer-row buf) (buffer-max-row buf))
          (terminal-up out (- (buffer-max-row buf) (buffer-row buf))))))
    (terminal-goto-col out (buffer-col buf))
    (flush-output-port out)
    (buffer-cleared?-set! buf #f)))

(define (buffer-refresh buf out)
  (cond ((buffer-refresh? buf)
         (buffer-draw buf out)
         (buffer-refresh?-set! buf #f))))

(define (buffer-goto! buf out n)
  (let ((pos (buffer-pos buf))
        (gap (buffer-gap buf))
        (str (buffer-string buf))
        (n (buffer-clamp buf n)))
    (cond ((not (= n pos))
           (buffer-update-position! buf) ;; necesary?
           (if (< n pos)
               (string-copy! str (- gap (- pos n)) str n pos)
               (string-copy! str pos str gap (+ gap (- n pos))))
           (buffer-pos-set! buf n)
           (buffer-gap-set! buf (+ gap (- n pos)))
           (cond
            ((not (buffer-refresh? buf))
             (let ((old-row (buffer-row buf))
                   (old-start (buffer-start buf)))
               (buffer-update-position! buf)
               (cond
                ((not (= old-start (buffer-start buf)))
                 (buffer-refresh?-set! buf #t))
                (else
                 (let ((row-diff (- old-row (buffer-row buf))))
                   (cond ((> row-diff 0) (terminal-up out row-diff))
                         ((< row-diff 0) (terminal-down out (- row-diff)))))
                 (terminal-goto-col out (buffer-col buf)))))))))))

(define (buffer-insert! buf out x)
  (let ((len (if (char? x) 1 (string-length x)))
        (pos (buffer-pos buf)))
    (buffer-resize buf len)
    (if (char? x)
        (string-set! (buffer-string buf) pos x)
        (string-copy! (buffer-string buf) pos x 0 len))
    (buffer-pos-set! buf (+ (buffer-pos buf) len))
    (cond
     ((buffer-refresh? buf))
     ((and (= (buffer-gap buf) (string-length (buffer-string buf)))
           (< (+ (buffer-col buf) len) (buffer-width buf))
           (if (char? x)
               (not (eqv? x #\newline))
               (not (string-index #\newline x))))
      ;; fast path - append to end of buffer w/o wrapping to next line
      (display x out)
      (flush-output-port out)
      (buffer-col-set! buf (+ (buffer-col buf) len))
      (buffer-cleared?-set! buf #f))
     (else
      (buffer-refresh?-set! buf #t)))))

(define (buffer-delete! buf out start end)
  (let ((pos (buffer-pos buf))
        (gap (buffer-gap buf))
        (str (buffer-string buf))
        (start (buffer-clamp buf start))
        (end (buffer-clamp buf end)))
    (if (not (buffer-refresh? buf))
        (if (and (= start pos) (>= end (buffer-length buf)))
            (terminal-clear-below out)
            (buffer-refresh?-set! buf #t)))
    (cond ((< end pos)
           (string-copy! str start str end pos)
           (buffer-pos-set! buf (+ start (- pos end))))
          ((> start gap)
           (string-copy! str start str gap (+ gap (- end start)))
           (buffer-gap-set! buf (+ gap (- end start))))
          (else
           (buffer-pos-set! buf (min pos start))
           (buffer-gap-set! buf (max gap (+ pos (- gap pos) (- end pos))))))))

(define (buffer-skip buf pred)
  (let* ((str (buffer-string buf)) (end (string-length str)))
    (let lp ((i (buffer-gap buf)))
      (if (or (>= i end) (not (pred (string-ref str i))))
          (+ (- i (buffer-gap buf)) (buffer-pos buf))
          (lp (+ i 1))))))

(define (buffer-skip-reverse buf pred)
  (let ((str (buffer-string buf)))
    (let lp ((i (- (buffer-pos buf) 1)))
      (if (or (< i 0) (not (pred (string-ref str i)))) i (lp (- i 1))))))

(define (buffer-previous-word buf)
  (let ((i (buffer-skip-reverse buf char-word-constituent?)))
    (substring (buffer-string buf) (+ i 1) (buffer-pos buf))))

(define (buffer-format-list buf out words)
  (let ((width (buffer-width buf)))
    (define (write-rows num-cols widths)
      (let lp ((ls words) (i 0))
        (cond
         ((pair? ls)
          (let ((diff (- (vector-ref widths i) (string-length (car ls)))))
            (display (car ls) out)
            (if (= (+ i 1) num-cols)
                (newline out)
                (display (make-string (+ 1 diff) #\space) out))
            (lp (cdr ls) (modulo (+ i 1) num-cols))))
         ((< i num-cols)
          (newline out)))))
    (let try-cols ((num-cols (length words)))
      (cond
       ((<= num-cols 1)
        (newline out)
        (for-each (lambda (x) (display x out) (newline out)) words))
       (else
        (let ((widths (make-vector num-cols 0)))
          (let lp ((ls words) (i 0) (avail (- num-cols 1)))
            (cond
             ((null? ls)
              (write-rows num-cols widths))
             (else
              (let ((diff (- (string-length (car ls)) (vector-ref widths i))))
                (if (positive? diff)
                    (let ((avail (+ avail diff)))
                      (cond
                       ((> avail width)
                        (try-cols (- num-cols 1)))
                       (else
                        (vector-set! widths i (string-length (car ls)))
                        (lp (cdr ls) (modulo (+ i 1) num-cols) avail))))
                    (lp (cdr ls) (modulo (+ i 1) num-cols) avail))))))))))))

(define (buffer-make-completer generate)
  (lambda (ch buf out return)
    (let* ((word (buffer-previous-word buf))
           (ls (generate buf word)))
      (cond
       ((null? ls)
        (command/beep ch buf out return))
       ((= 1 (length ls))
        (buffer-insert! buf out (substring (car ls) (string-length word))))
       (else
        (newline out)
        (buffer-format-list buf out ls)
        (buffer-draw buf out))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; keymaps

(define keymap? pair?)

(define (make-keymap . o)
  (cons (make-vector 256 #f) (and (pair? o) (car o))))

(define (make-sparse-keymap . o)
  (cons '() (and (pair? o) (car o))))

(define (make-printable-keymap)
  (let* ((keymap (make-keymap command/self-insert))
         (v (car keymap)))
    (do ((i #x20 (+ i 1))) ((= i #x7F) keymap)
      (vector-set! v i command/self-insert))))

(define (make-standard-escape-bracket-keymap)
  (let* ((keymap (make-keymap))
         (v (car keymap)))
    (vector-set! v 65 command/backward-history)
    (vector-set! v 66 command/forward-history)
    (vector-set! v 67 command/forward-char)
    (vector-set! v 68 command/backward-char)
    keymap))

(define (make-standard-escape-keymap)
  (let* ((keymap (make-keymap))
         (v (car keymap)))
    (vector-set! v   8 command/backward-delete-word)
    (vector-set! v  91 (make-standard-escape-bracket-keymap))
    (vector-set! v  98 command/backward-word)
    (vector-set! v 100 command/forward-delete-word)
    (vector-set! v 102 command/forward-word)
    (vector-set! v 127 command/backward-delete-word)
    keymap))

(define (make-standard-keymap . o)
  (let* ((keymap (make-printable-keymap))
         (v (car keymap))
         (catch-control-c? (and (pair? o) (car o))))
    (vector-set! v   0 command/enter)   ;; for telnet
    (vector-set! v   1 command/beginning-of-line)
    (vector-set! v   2 command/backward-char)
    (vector-set! v   3 (if catch-control-c? command/cancel command/quit))
    (vector-set! v   4 command/forward-delete-char)
    (vector-set! v   5 command/end-of-line)
    (vector-set! v   6 command/forward-char)
    (vector-set! v   8 command/backward-delete-char)
    (vector-set! v  10 command/enter)
    (vector-set! v  11 command/forward-delete-line)
    (vector-set! v  12 command/refresh)
    (vector-set! v  13 command/skip)
    (vector-set! v  14 command/forward-history)
    (vector-set! v  16 command/backward-history)
    (vector-set! v  21 command/backward-delete-line)
    (vector-set! v  27 (make-standard-escape-keymap))
    (vector-set! v 127 command/backward-delete-char)
    keymap))

(define (keymap-lookup keymap n)
  (let ((table (car keymap)))
    (or (if (vector? table)
            (and (< -1 n (vector-length table)) (vector-ref table n))
            (cond ((assv n table) => cdr) (else #f)))
        (if (keymap? (cdr keymap))
            (keymap-lookup (cdr keymap) n)
            (cdr keymap)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; commands

(define (command/self-insert ch buf out return)
  (buffer-insert! buf out ch))

(define (command/enter ch buf out return)
  (protect (exn
            ((and (exception? exn)
                  (eq? 'read-incomplete (exception-kind exn)))
             (command/self-insert ch buf out return))
            (else
             (buffer-clear buf out)
             (print-exception exn out)
             (buffer-draw buf out)))
    (cond
     (((buffer-complete? buf) buf)
      (command/end-of-line ch buf out return)
      (display "\r\n" out)
      (flush-output-port out)
      (return))
     (else
      (command/self-insert ch buf out return)))))

(define (command/cancel ch buf out return)
  (command/end-of-line ch buf out return)
  (display "^C" out)
  (newline out)
  (buffer-delete! buf out 0 (buffer-length buf))
  (buffer-draw buf out))

(define (command/quit ch buf out return)
  (command/end-of-line ch buf out return)
  (display "^C" out)
  (newline out)
  (stty out '(icanon isig echo))
  (return '^C))

(define (command/beep ch buf out return)
  (write-char (integer->char 7) out))

(define (command/skip ch buf out return)
  #f)

(define (command/refresh ch buf out return)
  (buffer-draw buf out))

(define (command/beginning-of-line ch buf out return)
  (buffer-goto! buf out 0))

(define (command/end-of-line ch buf out return)
  (buffer-goto! buf out (buffer-length buf)))

(define (command/forward-char ch buf out return)
  (buffer-goto! buf out (+ (buffer-pos buf) 1)))

(define (command/backward-char ch buf out return)
  (buffer-goto! buf out (- (buffer-pos buf) 1)))

(define (command/forward-delete-char ch buf out return)
  (cond
   ((zero? (- (buffer-length buf) (buffer-min buf)))
    (newline out)
    (return 'eof))
   (else
    (buffer-delete! buf out (buffer-pos buf) (+ (buffer-pos buf) 1)))))

(define (command/backward-delete-char ch buf out return)
  (buffer-delete! buf out (- (buffer-pos buf) 1) (buffer-pos buf)))

(define (command/forward-delete-line ch buf out return)
  (buffer-delete! buf out (buffer-pos buf) (buffer-length buf)))

(define (command/backward-delete-line ch buf out return)
  (buffer-delete! buf out 0 (buffer-pos buf)))

(define (command/backward-history ch buf out return)
  (let ((history (buffer-history buf)))
    (cond
     ((and (history? history) (pair? (history-past history)))
      (if (null? (history-future history))
          (history-insert! history (buffer->string buf)))
      (cond
       ((pair? (cdr (history-past history)))
        (buffer-delete! buf out 0 (buffer-length buf))
        (buffer-insert! buf out (history-prev! history))))))))

(define (command/forward-history ch buf out return)
  (let ((history (buffer-history buf)))
    (cond
     ((and (history? history) (pair? (history-future history)))
      (buffer-delete! buf out 0 (buffer-length buf))
      (let ((res (buffer-insert! buf out (history-next! history))))
        (if (null? (history-future history))
            (history-past-set! history (cdr (history-past history))))
        res)))))

(define (command/forward-word ch buf out return)
  (buffer-goto! buf out (buffer-skip buf char-non-word-constituent?))
  (buffer-goto! buf out (buffer-skip buf char-word-constituent?)))

(define (command/backward-word ch buf out return)
  (buffer-goto! buf out (buffer-skip-reverse buf char-non-word-constituent?))
  (buffer-goto! buf out (+ (buffer-skip-reverse buf char-word-constituent?) 1)))

(define (command/forward-delete-word ch buf out return)
  (let ((start (buffer-pos buf)))
    (buffer-goto! buf out (buffer-skip buf char-non-word-constituent?))
    (buffer-delete! buf out start (buffer-skip buf char-word-constituent?))))

(define (command/backward-delete-word ch buf out return)
  (let ((end (buffer-pos buf)))
    (buffer-goto! buf out (buffer-skip-reverse buf char-non-word-constituent?))
    (let ((start (buffer-skip-reverse buf char-word-constituent?)))
      (buffer-delete! buf out (+ start 1) end))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; line-editing

(define standard-keymap (make-standard-keymap))
(define standard-cancel-keymap (make-standard-keymap #t))

(define (get-key ls key . o)
  (let ((x (memq key ls)))
    (if (and x (pair? (cdr x))) (cadr x) (and (pair? o) (car o)))))

(define (with-leading-ports ls proc)
  (if (and (pair? ls) (input-port? (car ls)))
      (if (and (pair? (cdr ls)) (output-port? (cadr ls)))
          (proc (car ls) (cadr ls) (cddr ls))
          (proc (car ls) (current-output-port) (cdr ls)))
      (proc (current-input-port) (current-output-port) ls)))

(define (make-line-editor . args)
  (let* ((prompter (get-key args 'prompt: "> "))
         (history (get-key args 'history:))
         (complete? (get-key args 'complete?: (lambda (buf) #t)))
         (completion (get-key args 'completion: #f))
         (terminal-width (get-key args 'terminal-width:))
         (single-line? (get-key args 'single-line?: #f))
         (fresh-line (get-key args 'fresh-line: #f))
         (no-stty? (get-key args 'no-stty?: #f))
         (hidden? (get-key args 'hidden?: #f))
         (keymap0 (get-key args 'keymap:
                           (if (get-key args 'catch-control-c?: #f)
                               standard-cancel-keymap
                               standard-keymap)))
         (keymap (if completion
                     (cons (list (cons 9 completion)) keymap0)
                     keymap0))
         (buf (or (get-key args 'buffer: #f) (make-buffer))))
    (lambda (in out)
      (let* ((width (or terminal-width (get-terminal-width out) 80))
             (prompt (if (procedure? prompter) (prompter) prompter))
             (done? #f)
             (tmp-out (if hidden? (open-output-string) out))
             (return (lambda o (set! done? (if (pair? o) (car o) #t)))))
        ;; Maybe start at a fresh line.
        (cond
         ((and fresh-line (not (at-first-column? in out)))
          (if (string? fresh-line) (display fresh-line out))
          (newline out)))
        ;; Clear buffer and reset prompt.
        (buffer-refresh?-set! buf #t)
        (buffer-min-set! buf 0)
        (buffer-delete! buf out 0 (buffer-length buf))
        (buffer-width-set! buf width)
        (buffer-insert! buf out prompt)
        (buffer-min-set! buf (string-length prompt))
        (buffer-history-set! buf history)
        (buffer-complete?-set! buf complete?)
        (buffer-single-line?-set! buf single-line?)
        (if single-line? (buffer-start-set! buf (buffer-min buf)))
        (buffer-refresh buf out)
        (flush-output-port out)
        ((if no-stty? (lambda (out f) (f)) with-raw-io)
         out
         (lambda ()
           (let lp ((kmap keymap))
             (let ((ch (read-char in)))
               (if (eof-object? ch)
                   (let ((res (buffer->string buf)))
                     (if (equal? res "") ch res))
                   (let ((x (keymap-lookup kmap (char->integer ch))))
                     (cond
                      ((keymap? x)
                       (lp x))
                      ((procedure? x)
                       (protect (exn (else
                                      (buffer-clear buf out)
                                      (print-exception exn out)
                                      (buffer-draw buf out)))
                         (x ch buf tmp-out return))
                       (flush-output-port tmp-out)
                       (buffer-refresh buf tmp-out)
                       (if done?
                           (and (not (eq? done? 'eof)) (buffer->string buf))
                           (lp keymap)))
                      (else
                       ;;(command/beep ch buf out return)
                       (lp keymap)))))))))))))

(define (edit-line . args)
  (with-leading-ports
   args
   (lambda (in out rest) ((apply make-line-editor rest) in out))))

(define (edit-line-repl . args)
  (with-leading-ports
   args
   (lambda (in out rest)
     (let ((eval (get-key rest 'eval: (lambda (x) x)))
           (print (get-key rest 'write: write))
           (history (or (get-key rest 'history:) (make-history))))
       (let ((edit-line
              (apply make-line-editor 'no-stty?: #t 'history: history rest)))
         ((if (get-key args 'no-stty?:) (lambda (out f) (f)) with-raw-io)
          out
          (lambda ()
            (let lp ()
              (let ((line (edit-line in out)))
                (if (pair? (history-future history))
                    (history-past-set! history (cdr (history-past history))))
                (history-commit! history line)
                (print (eval line) out)
                (newline out)
                (lp))))))))))
;; Copyright (c) 2010-2014 Alex Shinn. All rights reserved. BSD-style
;; license: http://synthcode.com/license.txt

;;> A library to use ANSI escape codes to format text and background
;;> color, font weigh, and underlining.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define (make-simple-escape-procedure parameter)
  (let ((code (string-append "\x1B;[" (number->string parameter) "m")))
    (lambda () code)))

(define (make-wrap-procedure start-escape end-escape)
  (lambda (str)
    (if (not (string? str))
        (error "argument must be a string" str))
    (if (ansi-escapes-enabled?)
        (string-append start-escape str end-escape)
        str)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Some definitions are wrapped in begin in order to avoid Scribble
;; generating duplicate signatures.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;> \section{Library}

(define black-escape
   (make-simple-escape-procedure 30))
(define red-escape
  (make-simple-escape-procedure 31))
(define green-escape
  (make-simple-escape-procedure 32))
(define yellow-escape
  (make-simple-escape-procedure 33))
(define blue-escape
  (make-simple-escape-procedure 34))
(define magenta-escape
  (make-simple-escape-procedure 35))
(define cyan-escape
  (make-simple-escape-procedure 36))
(define white-escape
  (make-simple-escape-procedure 37))

;;> Return a string consisting of an ANSI escape code to select the
;;> specified text color.
;;/

;;> Return a string consisting of an ANSI escape code to select the
;;> text color specified by the \var{red-level}, \var{green-level},
;;> and \var{blue-level} arguments, each of which must be an exact
;;> integer in the range [0, 5].
;;>
;;> The caller is resonsible for verifying that the terminal supports
;;> 256 colors.

(define (rgb-escape red-level green-level blue-level)
  (when (not (and (exact-integer? red-level) (<= 0 red-level 5)))
    (error "invalid red-level value" red-level))
  (when (not (and (exact-integer? green-level) (<= 0 green-level 5)))
    (error "invalid green-level value" green-level))
  (when (not (and (exact-integer? blue-level) (<= 0 blue-level 5)))
    (error "invalid blue-level value" blue-level))
  (string-append
   "\x1B;[38;5;"
   (number->string (+ (* 36 red-level) (* 6 green-level) blue-level 16))
   "m"))

;;> Return a string consisting of an ANSI escape code to select the
;;> text color specified by the \var{gray-level} argument, which must
;;> be an exact integer in the range [0, 23].
;;>
;;> The caller is resonsible for verifying that the terminal supports
;;> 256 colors.

(define (gray-escape gray-level)
  (when (not (and (exact-integer? gray-level) (<= 0 gray-level 23)))
    (error "invalid gray-level value" gray-level))
  (string-append "\x1B;[38;5;"
                 (number->string (+ gray-level 232))
                 "m"))

;;> The true-color equivalent of \scheme{rgb-escape}. Return a string
;;> consisting of an ANSI escape code to select the text color
;;> specified by the \var{red-level}, \var{green-level}, and
;;> \var{blue-level} arguments, each of which must be an exact integer
;;> in the range [0, 255].

(define (rgb24-escape red-level green-level blue-level)
  (when (not (and (exact-integer? red-level) (<= 0 red-level 255)))
    (error "invalid red-level value" red-level))
  (when (not (and (exact-integer? green-level) (<= 0 green-level 255)))
    (error "invalid green-level value" green-level))
  (when (not (and (exact-integer? blue-level) (<= 0 blue-level 255)))
    (error "invalid blue-level value" blue-level))
  (string-append
   "\x1B;[38;2;"
   (number->string red-level) ";"
   (number->string green-level) ";"
   (number->string blue-level)
   "m"))

;;> Return a string consisting of an ANSI escape code to select the
;;> default text color.

(define reset-color-escape
  (make-simple-escape-procedure 39))

(define black
  (make-wrap-procedure (black-escape)
                       (reset-color-escape)))
(define red
  (make-wrap-procedure (red-escape)
                       (reset-color-escape)))
(define green
  (make-wrap-procedure (green-escape)
                       (reset-color-escape)))
(define yellow
  (make-wrap-procedure (yellow-escape)
                       (reset-color-escape)))
(define blue
  (make-wrap-procedure (blue-escape)
                       (reset-color-escape)))
(define magenta
  (make-wrap-procedure (magenta-escape)
                       (reset-color-escape)))
(define cyan
  (make-wrap-procedure (cyan-escape)
                       (reset-color-escape)))
(define white
  (make-wrap-procedure (white-escape)
                       (reset-color-escape)))

;;> If ANSI escapes are enabled, return a string consisting of the
;;> string \var{str} with a prefix that selects specified text color
;;> and a suffix that selects the default text color.
;;>
;;> If ANSI escapes are not enabled, return \var{str}.
;;/

;;> Returns a procedure which takes a single argument, a string, and
;;> which when called behaves as follows.
;;>
;;> If ANSI escapes are enabled, the procedure returns a string
;;> consisting of its argument with a prefix that selects specified
;;> text color (obtained by calling the \scheme{rgb-escape} procedure
;;> with the values of the \var{red-level}, \var{green-level}, and
;;> \var{blue-level} arguments) and a suffix that selects the default
;;> text color.
;;>
;;> If ANSI escapes are not enabled, the procedure returns its argument.
;;>
;;> The caller is resonsible for verifying that the terminal supports
;;> 256 colors.

(define (rgb red-level green-level blue-level)
  (make-wrap-procedure (rgb-escape red-level green-level blue-level)
                       (reset-color-escape)))

;;> Returns a procedure which takes a single argument, a string, and
;;> which when called behaves as follows.
;;>
;;> If ANSI escapes are enabled, the procedure returns a string
;;> consisting of its argument with a prefix that selects specified
;;> text color (obtained by calling the \scheme{gray-escape} procedure
;;> with the values of the \var{gray-level} argument) and a suffix
;;> that selects the default text color.
;;>
;;> If ANSI escapes are not enabled, the procedure returns its argument.
;;>
;;> The caller is resonsible for verifying that the terminal supports
;;> 256 colors.

(define (gray gray-level)
  (make-wrap-procedure (gray-escape gray-level)
                       (reset-color-escape)))

;;> The true-color equivalent of \scheme{rbg}, extending the ranges
;;> to [0, 255].

(define (rgb24 red-level green-level blue-level)
  (make-wrap-procedure (rgb24-escape red-level green-level blue-level)
                       (reset-color-escape)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define black-background-escape
  (make-simple-escape-procedure 40))
(define red-background-escape
  (make-simple-escape-procedure 41))
(define green-background-escape
  (make-simple-escape-procedure 42))
(define yellow-background-escape
  (make-simple-escape-procedure 43))
(define blue-background-escape
  (make-simple-escape-procedure 44))
(define magenta-background-escape
  (make-simple-escape-procedure 45))
(define cyan-background-escape
  (make-simple-escape-procedure 46))
(define white-background-escape
  (make-simple-escape-procedure 47))

;;> Return a string consisting of an ANSI escape code to select the
;;> specified background color.
;;/

;;> Return a string consisting of an ANSI escape code to select the
;;> background color specified by the \var{red-level}, \var{green-level},
;;> and \var{blue-level} arguments, each of which must be an exact
;;> integer in the range [0, 5].
;;>
;;> The caller is resonsible for verifying that the terminal supports
;;> 256 colors.

(define (rgb-background-escape red-level green-level blue-level)
  (when (not (and (exact-integer? red-level) (<= 0 red-level 5)))
    (error "invalid red-level value" red-level))
  (when (not (and (exact-integer? green-level) (<= 0 green-level 5)))
    (error "invalid green-level value" green-level))
  (when (not (and (exact-integer? blue-level) (<= 0 blue-level 5)))
    (error "invalid blue-level value" blue-level))
  (string-append
   "\x1B;[48;5;"
   (number->string (+ (* 36 red-level) (* 6 green-level) blue-level 16))
   "m"))

;;> Return a string consisting of an ANSI escape code to select the
;;> background color specified by the \var{gray-level} argument, which
;;> must be an exact integer in the range [0, 23].
;;>
;;> The caller is resonsible for verifying that the terminal supports
;;> 256 colors.

(define (gray-background-escape gray-level)
  (when (not (and (exact-integer? gray-level) (<= 0 gray-level 23)))
    (error "invalid gray-level value" gray-level))
  (string-append "\x1B;[48;5;"
                 (number->string (+ gray-level 232))
                 "m"))

;;> The true-color equivalent of \scheme{rgb-background-escape}.
;;> Return a string consisting of an ANSI escape code to select the
;;> text color specified by the \var{red-level}, \var{green-level},
;;> and \var{blue-level} arguments, each of which must be an exact
;;> integer in the range [0, 255].

(define (rgb24-background-escape red-level green-level blue-level)
  (when (not (and (exact-integer? red-level) (<= 0 red-level 255)))
    (error "invalid red-level value" red-level))
  (when (not (and (exact-integer? green-level) (<= 0 green-level 255)))
    (error "invalid green-level value" green-level))
  (when (not (and (exact-integer? blue-level) (<= 0 blue-level 255)))
    (error "invalid blue-level value" blue-level))
  (string-append
   "\x1B;[48;5;"
   (number->string red-level) ";"
   (number->string green-level) ";"
   (number->string blue-level)
   "m"))

;;> \procedure{(reset-background-color-escape)}
;;>
;;> Return a string consisting of an ANSI escape code to select the
;;> default background color.

(define reset-background-color-escape
  (make-simple-escape-procedure 49))

(define black-background
  (make-wrap-procedure (black-background-escape)
                       (reset-background-color-escape)))
(define red-background
  (make-wrap-procedure (red-background-escape)
                       (reset-background-color-escape)))
(define green-background
  (make-wrap-procedure (green-background-escape)
                       (reset-background-color-escape)))
(define yellow-background
  (make-wrap-procedure (yellow-background-escape)
                       (reset-background-color-escape)))
(define blue-background
  (make-wrap-procedure (blue-background-escape)
                       (reset-background-color-escape)))
(define magenta-background
  (make-wrap-procedure (magenta-background-escape)
                       (reset-background-color-escape)))
(define cyan-background
  (make-wrap-procedure (cyan-background-escape)
                       (reset-background-color-escape)))
(define white-background
  (make-wrap-procedure (white-background-escape)
                       (reset-background-color-escape)))

;;> If ANSI escapes are enabled, return a string consisting of the
;;> string \var{str} with a prefix that selects specified background
;;> color and a suffix that selects the default background color.
;;>
;;> If ANSI escapes are not enabled, return \var{str}.
;;/

;;> Returns a procedure which takes a single argument, a string, and
;;> which when called behaves as follows.
;;>
;;> If ANSI escapes are enabled, the procedure returns a string
;;> consisting of its argument with a prefix that selects specified
;;> background color (obtained by calling the \scheme{rgb-background-escape}
;;> procedure with the values of the \var{red-level}, \var{green-level},
;;> and \var{blue-level} arguments) and a suffix that selects the
;;> default background color.
;;>
;;> If ANSI escapes are not enabled, the procedure returns its argument.
;;>
;;> The caller is resonsible for verifying that the terminal supports
;;> 256 colors.

(define (rgb-background red-level green-level blue-level)
  (make-wrap-procedure (rgb-background-escape red-level green-level blue-level)
                       (reset-background-color-escape)))

;;> Returns a procedure which takes a single argument, a string, and
;;> which when called behaves as follows.
;;>
;;> If ANSI escapes are enabled, the procedure returns a string
;;> consisting of its argument with a prefix that selects specified
;;> background color (obtained by calling the \scheme{gray-background-escape}
;;> procedure with the values of the \var{gray-level} argument) and a
;;> suffix that selects the default background color.
;;>
;;> If ANSI escapes are not enabled, the procedure returns its argument.
;;>
;;> The caller is resonsible for verifying that the terminal supports
;;> 256 colors.

(define (gray-background gray-level)
  (make-wrap-procedure (gray-background-escape gray-level)
                       (reset-background-color-escape)))

;;> The true-color equivalent of \scheme{rbg-background}, extending
;;> the ranges to [0, 255].

(define (rgb24-background red-level green-level blue-level)
  (make-wrap-procedure
   (rgb24-background-escape red-level green-level blue-level)
   (reset-background-color-escape)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;> Return a string consisting of an ANSI escape code to select bold
;;> style.

(define bold-escape
  (make-simple-escape-procedure 1))

;;> Return a string consisting of an ANSI escape code to select non-bold
;;> style.

(define reset-bold-escape
  (make-simple-escape-procedure 22))

;;> If ANSI escapes are enabled, return a string consisting of the
;;> string \var{str} with a prefix that selects bold style and a suffix
;;> that selects non-bold style.
;;>
;;> If ANSI escapes are not enabled, return \var{str}.

(define bold (make-wrap-procedure (bold-escape)
                                  (reset-bold-escape)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;> Return a string consisting of an ANSI escape code to select
;;> underlined style.

(define underline-escape
  (make-simple-escape-procedure 4))

;;> Return a string consisting of an ANSI escape code to select
;;> non-underlined style.

(define reset-underline-escape
  (make-simple-escape-procedure 24))

;;> If ANSI escapes are enabled, return a string consisting of the
;;> string \var{str} with a prefix that selects underlined style and
;;> a suffix that selects non-underlined style.
;;>
;;> If ANSI escapes are not enabled, return \var{str}.

(define underline
  (make-wrap-procedure (underline-escape) (reset-underline-escape)))

;;> Return a string consisting of an ANSI escape code to select
;;> italic style.

(define italic-escape
  (make-simple-escape-procedure 3))

;;> Return a string consisting of an ANSI escape code to select
;;> non-italic style.

(define reset-italic-escape
  (make-simple-escape-procedure 23))

;;> Returns \var{str} optionally wrapped in italic escapes.

(define italic
  (make-wrap-procedure (italic-escape) (reset-italic-escape)))

;;> Return a string consisting of an ANSI escape code to select
;;> strikethrough style.

(define strikethrough-escape
  (make-simple-escape-procedure 9))

;;> Return a string consisting of an ANSI escape code to select
;;> non-strikethrough style.

(define reset-strikethrough-escape
  (make-simple-escape-procedure 29))

;;> Returns \var{str} optionally wrapped in strikethrough escapes.

(define strikethrough
  (make-wrap-procedure (strikethrough-escape) (reset-strikethrough-escape)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;> Return a string consisting of an ANSI escape code to select negative
;;> style (text in the background color and background in the text
;;> color).

(define negative-escape
  (make-simple-escape-procedure 7))

;;> Return a string consisting of an ANSI escape code to select positive
;;> style (text in the text color and background in the background
;;> color).

(define reset-negative-escape
  (make-simple-escape-procedure 27))

;;> If ANSI escapes are enabled, return a string consisting of the
;;> string \var{str} with a prefix that selects negative style (text
;;> in the background color and background in the text color) and a
;;> suffix that selects positive style (text in the text color and
;;> background in the background color).
;;>
;;> If ANSI escapes are not enabled, return \var{str}.

(define negative (make-wrap-procedure (negative-escape)
                                      (reset-negative-escape)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;> A parameter object that determines whether ANSI escapes are enabled
;;> in some of the preceding procedures. They are disabled if
;;> \scheme{(ansi-escapes-enabled?)} returns \scheme{#f}, and otherwise
;;> they are enabled.
;;>
;;> The initial value returned by \scheme{(ansi-escapes-enabled?)} is
;;> determined by the environment.
;;>
;;> If the environment variable \scheme{ANSI_ESCAPES_ENABLED} is set,
;;> its value determines the initial value returned by
;;> \scheme{(ansi-escapes-enabled?)}. If the value of
;;> \scheme{ANSI_ESCAPES_ENABLED} is \scheme{"0"}, the initial value
;;> is \scheme{#f}, otherwise the initial value is \scheme{#t}.
;;>
;;> If the environment variable \scheme{ANSI_ESCAPES_ENABLED} is not
;;> set, but the environment variable \scheme{TERM} is set, the value
;;> of the latter determines the initial value returned by
;;> \scheme{(ansi-escapes-enabled?)}. If the value of \scheme{TERM}
;;> is \scheme{"xterm"}, \scheme{"xterm-color"}, \scheme{"xterm-256color"},
;;> \scheme{"rxvt"}, \scheme{"rxvt-unicode-256color"}, \scheme{"kterm"},
;;> \scheme{"linux"}, \scheme{"screen"}, \scheme{"screen-256color"},
;;> or \scheme{"vt100"}, the initial value is \scheme{#t}, otherwise
;;> the initial value is \scheme{#f}.
;;>
;;> If neither of the environment variables \scheme{ANSI_ESCAPES_ENABLED}
;;> and \scheme{TERM} are set, the initial value returned by
;;> \scheme{(ansi-escapes-enabled?)} is \scheme{#f}.

(define ansi-escapes-enabled?
  (make-parameter
   (cond
    ((get-environment-variable "ANSI_ESCAPES_ENABLED")
     => (lambda (s) (not (equal? s "0"))))
    (else
     (member (get-environment-variable "TERM")
             '("xterm" "xterm-color" "xterm-256color" "rxvt" "kterm"
               "linux" "screen" "screen-256color" "vt100"
               "tmux-256color" "rxvt-unicode-256color"))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;> \section{Notes}
;;>
;;> It is important to remember that the formatting procedures apply
;;> a prefix to set a particular graphics parameter and a suffix to
;;> reset the parameter to its default value. This can lead to surprises.
;;> For example, on an ANSI terminal, one might mistakenly expect the
;;> following to display GREEN in green text and then RED in red text:
;;>
;;> \codeblock{(display (red (string-append (green "GREEN") "RED")))}
;;>
;;> However, it will actually display GREEN in green text and then RED
;;> in the default text color. This is a limitation of ANSI control
;;> codes; graphics attributes are not saved to and restored from a
;;> stack, but instead are simply set. One way to display GREEN in
;;> green text and then RED in red text is:
;;>
;;> \codeblock{(display (string-append (green "GREEN") (red "RED")))}
;;>
;;> On the other hand, text color, background color, font weight (bold
;;> or default), underline (on or off), image (positive or negative)
;;> are orthogonal. So, for example, on an ANSI terminal the following
;;> should display GREEN in green text and then RED in red text, with
;;> both in bold and GREEN underlined.
;;>
;;> \codeblock{(display (bold (string-append (underline (green "GREEN")) (red "RED"))))}
;;>

(define-library (chibi term edit-line)
  (export make-line-editor edit-line edit-line-repl
          make-history history-insert! history-reset!
          history-commit! history->list list->history buffer->string
          make-buffer buffer-make-completer
          buffer-clear buffer-refresh buffer-draw
          buffer-row buffer-col
          make-keymap make-standard-keymap)
  (import (scheme base) (scheme char) (scheme write))
  (cond-expand
   ((library (srfi 151)) (import (srfi 151)))
   ((library (srfi 33)) (import (srfi 33)))
   (else (import (srfi 60))))
  (cond-expand
   (chibi
    (import (chibi stty)))
   (chicken
    (import stty))
   (else
    (define (with-stty spec thunk)
      (thunk))))
  (cond-expand
   (chibi
    (import (only (chibi) protect print-exception)
            (chibi ast)))
   (else
    (begin
      (define (with-raw-io port thunk)
        (with-stty '(not icanon isig echo) thunk port))
      (define (get-terminal-width . x) 80)
      (define-syntax protect
        (syntax-rules () ((protect . x) (guard . x))))
      (define (print-exception exn . o)
        (let ((out (if (pair? o) (car o) (current-error-port))))
          (write exn out)
          (newline out)))
      (define (exception? x) #f)
      (define (exception-kind x) #f))))
  (include "edit-line.scm"))
;; ast.scm -- ast utilities
;; Copyright (c) 2010-2012 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

;;> Abstract Syntax Tree.  Interface to the types used by
;;> the compiler, and other core types less commonly
;;> needed in user code, plus related utilities.

;;> \section{Analysis and Expansion}

;;> \procedure{(analyze x [env])}

;;> Expands and analyzes the expression \var{x} and returns the
;;> resulting AST.

;;> \procedure{(optimize ast)}

;;> Runs an optimization pass on \var{ast} and returns the
;;> resulting simplified expression.

(define (ast-renames ast)
  (define i 0)
  (define renames '())
  (define (rename-symbol id)
    (set! i (+ i 1))
    (string->symbol
     (string-append (symbol->string (identifier->symbol id))
                    "." (number->string i))))
  (define (rename-lambda lam)
    (or (assq lam renames)
        (let ((res (list lam)))
          (set! renames (cons res renames))
          res)))
  (define (rename! id lam)
    (let ((cell (rename-lambda lam)))
      (set-cdr! cell (cons (cons id (rename-symbol id)) (cdr cell)))))
  (define (check-ref id lam env)
    (let ((sym (identifier->symbol id)))
      (let lp1 ((ls env))
        (cond
         ((pair? ls)
          (let lp2 ((ls2 (car ls)) (found? #f))
            (cond
             ((null? ls2)
              (if (not found?) (lp1 (cdr ls))))
             ((and (eq? id (caar ls2)) (eq? lam (cdar ls2)))
               (lp2 (cdr ls2) #t))
             ((eq? sym (identifier->symbol (caar ls2)))
              (rename! (caar ls2) (cdar ls2))
              (lp2 (cdr ls2) found?))
             (else
              (lp2 (cdr ls2) found?)))))))))
  (define (extend-env lam env)
    (cons (map (lambda (x) (cons x lam)) (flatten-dot (lambda-params lam))) env))
  (let lp ((x ast) (env '()))
    (cond
     ((lambda? x) (lp (lambda-body x) (extend-env x env)))
     ((ref? x) (check-ref (ref-name x) (cdr (ref-cell x)) env))
     ((cnd? x) (lp (cnd-test x) env) (lp (cnd-pass x) env) (lp (cnd-fail x) env))
     ((set? x) (lp (set-var x) env) (lp (set-value x) env))
     ((seq? x) (for-each (lambda (x) (lp x env)) (seq-ls x)))
     ((pair? x) (for-each (lambda (x) (lp x env)) x))))
  renames)

(define (flatten-dot x)
  (cond ((pair? x) (cons (car x) (flatten-dot (cdr x))))
        ((null? x) x)
        (else (list x))))

(define (get-rename id lam renames)
  (let ((ls (assq lam renames)))
    (if (not ls)
        (identifier->symbol id)
        (cond ((assq id (cdr ls)) => cdr) (else (identifier->symbol id))))))

(define (map* f ls)
  (cond ((pair? ls) (cons (f (car ls)) (map* f (cdr ls))))
        ((null? ls) '())
        (else (f ls))))

;;> Performs a full syntax expansion of the form \var{x} and
;;> returns the resulting s-expression.

(define (macroexpand x)
  (ast->sexp (analyze x)))

;;> Convert \var{ast} to a s-expression, renaming variables if
;;> necessary.

(define (ast->sexp ast)
  (let ((renames (ast-renames ast)))
    (let a2s ((x ast))
      (cond
       ((lambda? x)
        `(lambda ,(map* (lambda (id) (get-rename id x renames)) (lambda-params x))
           ,@(map (lambda (d) `(define ,(identifier->symbol (caar d)) #f))
                  (lambda-defs x))
           ,@(if (seq? (lambda-body x))
                 (map a2s (seq-ls (lambda-body x)))
                 (list (a2s (lambda-body x))))))
       ((cnd? x) `(if ,(a2s (cnd-test x)) ,(a2s (cnd-pass x)) ,(a2s (cnd-fail x))))
       ((set? x) `(set! ,(a2s (set-var x)) ,(a2s (set-value x))))
       ((ref? x) (get-rename (ref-name x) (cdr (ref-cell x)) renames))
       ((seq? x) `(begin ,@(map a2s (seq-ls x))))
       ((lit? x)
        (let ((v (lit-value x)))
          (if (or (pair? v) (null? v) (symbol? v)) `',v v)))
       ((pair? x) (cons (a2s (car x)) (a2s (cdr x))))
       ((opcode? x) (cond ((opcode-name x) => string->symbol) (else x)))
       (else x)))))

;;> \section{Identifier Macros}

;;> \procedure{(make-variable-transformer proc)}

;;> Returns a new procedure wrapping the input procedure \var{proc}.
;;> The returned procedure, if used as a macro transformer procedure,
;;> can expand an instance of \scheme{set!} with its keyword on the
;;> left hand side.

;;> \macro{(identifier-syntax clauses ...)}

;;> A high-level form for creating identifier macros. See
;;> \hyperlink["http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_idx_796"]{the R6RS specification.}

(define-syntax identifier-syntax
  (syntax-rules (set!)
    ((_ template)
     (syntax-rules ()
       ((_ xs (... ...))
        (template xs (... ...)))
       (x template)))
    ((_ (id_1 template_1) ((set! id_2 pattern) template_2))
     (make-variable-transformer
      (syntax-rules (set!)
        ((set! id_2 pattern) template_2)
        ((id_1 xs (... ...)) (template_1 xs (... ...)))
        (id_1 template_1))))))

;;> \section{Types}

;;> All objects have an associated type, and types may have parent
;;> types.  When using
;;> \hyperlink["http://srfi.schemers.org/srfi-9/srfi-9/html"]{SRFI-9}
;;> \scheme{define-record-type}, the name is bound to a first class
;;> type object.

;;> The following core types are also available by name, and may be
;;> used in the \scheme{match} \scheme{($ ...)} syntax.

;;> \itemlist[
;;> \item{\scheme{Object} - the parent of all types}
;;> \item{\scheme{Number} - abstract numeric type}
;;> \item{\scheme{Bignum} - arbitrary precision exact integers}
;;> \item{\scheme{Flonum} - inexact real numbers}
;;> \item{\scheme{Integer} - abstract integer type}
;;> \item{\scheme{Symbol} - symbols}
;;> \item{\scheme{Char} - character}
;;> \item{\scheme{Boolean} - \scheme{#t} or \scheme{#f}}
;;> \item{\scheme{String} - strings of characters}
;;> \item{\scheme{Byte-Vector} - uniform vector of octets}
;;> \item{\scheme{Pair} - a \var{car} and \var{cdr}, the basis for lists}
;;> \item{\scheme{Vector} - vectors}
;;> \item{\scheme{Opcode} - a primitive opcode or C function}
;;> \item{\scheme{Procedure} - a closure}
;;> \item{\scheme{Bytecode} - the compiled code for a closure}
;;> \item{\scheme{Env} - an environment structure}
;;> \item{\scheme{Macro} - a macro object, usually not first-class}
;;> \item{\scheme{Lam} - a lambda AST type}
;;> \item{\scheme{Cnd} - an conditional AST type (i.e. \scheme{if})}
;;> \item{\scheme{Ref} - a reference AST type}
;;> \item{\scheme{Set} - a mutation AST type (i.e. \scheme{set!})}
;;> \item{\scheme{Seq} - a sequence AST type}
;;> \item{\scheme{Lit} - a literal AST type}
;;> \item{\scheme{Sc} - a syntactic closure}
;;> \item{\scheme{Context} - a context object (including threads)}
;;> \item{\scheme{Exception} - an exception object}
;;> ]

;;> The following extended type predicates may also be used to test
;;> individual objects for their type:

;;> \itemlist[
;;> \item{\scheme{environment?}}
;;> \item{\scheme{bytecode?}}
;;> \item{\scheme{macro?}}
;;> \item{\scheme{syntactic-closure?}}
;;> \item{\scheme{lambda?}}
;;> \item{\scheme{cnd?}}
;;> \item{\scheme{ref?}}
;;> \item{\scheme{set?}}
;;> \item{\scheme{seq?}}
;;> \item{\scheme{lit?}}
;;> \item{\scheme{opcode?}}
;;> \item{\scheme{type?}}
;;> \item{\scheme{context?}}
;;> \item{\scheme{exception?}}
;;> ]

;;> \procedure{(type-of x)}

;;> Returns the type of any object \var{x}.

;;> \procedure{(type-name type)}

;;> Returns the name of type \var{type}.

;;> \procedure{(type-parent type)}

;;> Returns the immediate parent of type \var{type},
;;> or \scheme{#f} for a type with no parent.

(define (type-parent type)
  (let ((v (type-cpl type)))
    (and (vector? v)
         (> (vector-length v) 1)
         (vector-ref v (- (vector-length v) 2)))))

;;> \procedure{(type-cpl type)}

;;> Returns the class precedence list of type \var{type} as a
;;> vector, or \scheme{#f} for a type with no parent.

;;> \procedure{(type-slots type)}

;;> Returns the slot list of type \var{type}.

;;> \section{Accessors}

;;> This section describes additional accessors on AST and other core
;;> types.

;;> \subsection{Procedures}

;;> \itemlist[
;;> \item{\scheme{(procedure-code f)} - the compiled bytecode object}
;;> \item{\scheme{(procedure-vars f)} - the variables closed over by \var{f}}
;;> \item{\scheme{(procedure-name f)} - the name of \var{f} if known, else \scheme{#f}}
;;> ]

(define (procedure-name x)
  (bytecode-name (procedure-code x)))

(define (procedure-name-set! x name)
  (bytecode-name-set! (procedure-code x) name))

;;> \subsection{Macros}

;;> \itemlist[
;;> \item{\scheme{(macro-procedure f)} - the macro procedure}
;;> \item{\scheme{(macro-env f)} - the environment the macro was defined in}
;;> \item{\scheme{(macro-source f)} - the source location the macro was defined in}
;;> \item{\scheme{(macro-aux f)} - custom auxiliary data stored with the macro}
;;> \item{\scheme{(macro-aux-set! f x)}}
;;> ]

;;> \subsection{Bytecode Objects}

;;> \itemlist[
;;> \item{\scheme{(bytecode-name bc)} - the macro procedure}
;;> \item{\scheme{(bytecode-literals bc)} - literals the bytecode references}
;;> \item{\scheme{(bytecode-source bc)} - the source location the procedure was defined in}
;;> ]

;;> \subsection{Syntactic Closures}

;;> \itemlist[
;;> \item{\scheme{(syntactic-closure-env sc)}}
;;> \item{\scheme{(syntactic-closure-vars sc)}}
;;> \item{\scheme{(syntactic-closure-expr sc)}}
;;> ]

;;> Return the environment, free variables, and expression
;;> associated with \var{sc} respectively.

;;> \subsection{Exceptions}

;;> \itemlist[
;;> \item{\scheme{(exception-kind exn)}}
;;> \item{\scheme{(exception-message exn)}}
;;> \item{\scheme{(exception-irritants exn)}}
;;> ]

;;> Return the kind, message, and irritants
;;> associated with \var{exn} respectively.

;;> \subsection{Lambdas}

;;> \itemlist[
;;> \item{\scheme{(lambda-name lam)} - the name of the lambda, if known}
;;> \item{\scheme{(lambda-name-set! lam x)}}
;;> \item{\scheme{(lambda-params lam)} - the lambda parameter list}
;;> \item{\scheme{(lambda-params-set! lam x)}}
;;> \item{\scheme{(lambda-body lam)} - the body of the lambda}
;;> \item{\scheme{(lambda-body-set! lam x)}}
;;> \item{\scheme{(lambda-defs lam)} - internal definitions of the lambda}
;;> \item{\scheme{(lambda-defs-set! lam x)}}
;;> \item{\scheme{(lambda-locals lam)} - local variables as a list of identifiers}
;;> \item{\scheme{(lambda-locals-set! lam x)}}
;;> \item{\scheme{(lambda-flags lam)} - various flags describing the lambda}
;;> \item{\scheme{(lambda-flags-set! lam x)}}
;;> \item{\scheme{(lambda-free-vars lam)} - free variables the lambda will need to close over}
;;> \item{\scheme{(lambda-free-vars-set! lam x)}}
;;> \item{\scheme{(lambda-set-vars lam)} - variables the lambda mutates}
;;> \item{\scheme{(lambda-set-vars-set! lam x)}}
;;> \item{\scheme{(lambda-return-type lam)} - the return type of the lambda}
;;> \item{\scheme{(lambda-return-type-set! lam x)}}
;;> \item{\scheme{(lambda-param-types lam)} - the types of the input parameters}
;;> \item{\scheme{(lambda-param-types-set! lam x)}}
;;> \item{\scheme{(lambda-source lam)} - the source code of the lambda}
;;> \item{\scheme{(lambda-source-set! lam x)}}
;;> ]

;;> \subsection{Conditionals}

;;> \itemlist[
;;> \item{\scheme{(cnd-test cnd)} - the test for the conditional}
;;> \item{\scheme{(cnd-test-set! cnd x)}}
;;> \item{\scheme{(cnd-pass cnd)} - the success branch}
;;> \item{\scheme{(cnd-pass-set! cnd x)}}
;;> \item{\scheme{(cnd-fail cnd)} - the failure branch}
;;> \item{\scheme{(cnd-fail-set! cnd x)}}
;;> ]

;;> \subsection{Sequences}

;;> \itemlist[
;;> \item{\scheme{(seq-ls seq)} - the list of sequence expressions}
;;> \item{\scheme{(seq-ls-set! seq x)}}
;;> ]

;;> \subsection{References}

;;> \itemlist[
;;> \item{\scheme{(ref-name ref)} - the name of the referenced variable}
;;> \item{\scheme{(ref-name-set! ref x)}}
;;> \item{\scheme{(ref-cell ref)} - the environment cell the reference resolves to}
;;> \item{\scheme{(ref-cell-set! ref x)}}
;;> ]

;;> \subsection{Mutations}

;;> \itemlist[
;;> \item{\scheme{(set-var set)} - a reference to the mutated variable}
;;> \item{\scheme{(set-var-set! set x)}}
;;> \item{\scheme{(set-value set)} - the value to set the variable to}
;;> \item{\scheme{(set-value-set! set x)}}
;;> ]

;;> \subsection{Literals}

;;> \itemlist[
;;> \item{\scheme{(lit-value lit)} - the literal value}
;;> \item{\scheme{(lit-value-set! lit x)}}
;;> ]

;;> \subsection{Pairs}

;;> \itemlist[
;;> \item{\scheme{(pair-source x)}}
;;> \item{\scheme{(pair-source-set! x source)}}
;;> ]

;;> Set or return the source code info associated with a pair x.
;;> Source info is represented as another pair whose \var{car} is
;;> the source file name and whose \var{cdr} is the line number.

;;> \section{Miscellaneous Utilities}

;;> \procedure{(gc)}

;;> Force a garbage collection.

;;> \procedure{(object-size x)}

;;> Returns the heap space directly used by \var{x}, not
;;> counting any elements of \var{x}.

;;> \procedure{(integer->immediate n)}

;;> Returns the interpretation of the integer \var{n} as
;;> an immediate object, useful for debugging.

;;> \procedure{(string-contains str pat [start])}

;;> Returns the first string cursor of \var{pat} in \var{str},
;;> of \scheme{#f} if it's not found.

(cond-expand
 (safe-string-cursors
  (define orig-string-contains string-contains)
  (set! string-contains
        (lambda (str pat . o)
          (let ((res
                 (if (pair? o)
                     (orig-string-contains str pat (string-cursor-where (car o)))
                     (orig-string-contains str pat))))
            (and res (make-string-cursor str res (string-size str)))))))
 (else
  ))

;;> \procedure{(string-cursor-copy! dst src from start end)}

;;> Copies the characters from \var{src}[\var{start}..\var{end}]
;;> to \var{dst} starting at \var{from}.

;;> \procedure{(safe-setenv name value)}

;;> Equivalent to \scheme{setenv} but does nothing and returns
;;> \scheme{#f} if \var{value} is a function definition.  Used to
;;> circumvent the vulnerability of the shellshock bug.

(define (safe-setenv name value)
  (define (function-def? str)
    (and (> (string-size value) 5)
         (equal? "() {" (substring value 0 4))))
  (and (not (function-def? value))
       (setenv name value)))

;;> \procedure{(atomically expr)}

;;> Run \var{expr} atomically, disabling yields.  Ideally should only be
;;> used for brief, deterministic expressions.  If used incorrectly (e.g.
;;> running an infinite loop) can render the system unusable.
;;> Never expose to a sandbox.

(cond-expand
 (threads
  (define-syntax atomically
    (syntax-rules ()
      ((atomically . body)
       (let* ((atomic? (%set-atomic! #t))
              (res (begin . body)))
         (%set-atomic! atomic?)
         res)))))
 (else
  (define-syntax atomically
    (syntax-rules () ((atomically . body) (begin . body))))))

(define (thread-interrupt! thread)
  (if (%thread-interrupt! thread)
      (yield!)))

(define-library (chibi edit-distance-test)
  (export run-tests)
  (import (scheme base) (chibi edit-distance) (chibi test))
  (begin
    (define (run-tests)
      (test-begin "(chibi edit-distance)")
      (test 0 (edit-distance "" ""))
      (test 0 (edit-distance "same" "same"))
      (test 1 (edit-distance "same" "game"))
      (test 2 (edit-distance "same" "sand"))
      (test 3 (edit-distance "kitten" "sitting"))
      (test 3 (edit-distance "Saturday" "Sunday"))
      (test-end))))
(define-library (chibi scribble-test)
  (export run-tests)
  (import (scheme base) (scheme write) (chibi scribble) (chibi string)
          (only (chibi test) test-begin test test-end))
  (begin
    (define (test-scribble expect str)
      (test (call-with-output-string (lambda (out) (write str out)))
          expect
        (call-with-input-string str scribble-parse)))
    (define (run-tests)

      (test-begin "scribble")

      (test-scribble '((foo "blah blah blah")) "\\foo{blah blah blah}")
      (test-scribble '((foo "blah \"blah\" (`blah'?)")) "\\foo{blah \"blah\" (`blah'?)}")
      (test-scribble '((foo 1 2 "3 4")) "\\foo[1 2]{3 4}")
      (test-scribble '((foo 1 2 3 4)) "\\foo[1 2 3 4]")
      (test-scribble '((foo width: 2 "blah blah")) "\\foo[width: 2]{blah blah}")
      (test-scribble '((foo "blah blah" "\n" "     yada yada")) "\\foo{blah blah
     yada yada}")
      (test-scribble '((foo "  blah blah" "\n" "  yada yada" "\n")) "\\foo{
  blah blah
  yada yada
}")

      (test-scribble '((foo "bar " (baz "3") "\n" "     blah")) "\\foo{bar \\baz{3}
     blah}")
      (test-scribble '((foo (b (u 3) " " (u "4")) "\n" "     blah")) "\\foo{\\b{\\u[3] \\u{4}}
     blah}")
      (test-scribble '((C "while (*(p++))" "\n" "     *p = '\\n';")) "\\C{while (*(p++))
     *p = '\\\"\\\\\"n';}")
      (test-scribble '(("blah blah")) "\\{blah blah}")
      (test-scribble '(("blah " (3))) "\\{blah \\[3]}")
      (test-scribble '(("foo" "\n" "   bar" "\n" "   baz")) "\\{foo
   bar
   baz}")
      (test-scribble '(foo) "\\foo")
      (test-scribble '(("blah " foo " blah")) "\\{blah \\foo blah}")
      (test-scribble '(("blah " foo: " blah")) "\\{blah \\foo: blah}")
      (test-scribble '(("blah " foo ": blah")) "\\{blah \\|foo|: blah}")
      (test-scribble '((foo "(+ 1 2) -> " (+ 1 2) "!")) "\\foo{(+ 1 2) -> \\(+ 1 2)!}")
      (test-scribble '((foo "A string escape")) "\\foo{A \\\"string\" escape}")
      (test-scribble '((foo "eli@barzilay.org")) "\\foo{eli@barzilay.org}")
      (test-scribble '((foo "eli\\barzilay.org")) "\\foo{eli\\\"\\\\\"barzilay.org}")
      (test-scribble '((foo "A { begins a block")) "\\foo{A \\\"{\" begins a block}")
      (test-scribble '((C "while (*(p++)) {" "\n" "     *p = '\\n';" "\n" "   }"))
                     "\\C{while (*(p++)) {
     *p = '\\\"\\\\\"n';
   }}")
      (test-scribble '((foo "bar}\\{baz")) "\\foo|{bar}\\{baz}|")
      (test-scribble '((foo "bar " (x "X") " baz")) "\\foo|{bar |\\x{X} baz}|")
      (test-scribble '((foo "bar " (x "\\") " baz")) "\\foo|{bar |\\x|{\\}| baz}|")

      (test-scribble '((foo "bar}\\|{baz")) "\\foo|--{bar}\\|{baz}--|")
      (test-scribble '((foo "bar}\\|{baz")) "\\foo|<<{bar}\\|{baz}>>|")

      (test-scribble '((foo "bar " (baz 2 3) " {4 5}")) "\\foo{bar \\baz[2 3] {4 5}}")

      (test-scribble '(`',@(foo "blah")) "\\`',@foo{blah}")
      ;;(test-scribble '(#`#'#,@(foo "blah")) "\\#`#'#,@foo{blah}")
      (test-scribble '(((lambda (x) x) "blah")) "\\(lambda (x) x){blah}")
      (test-scribble '(`(,foo  "blah")) "\\`(unquote foo){blah}")

      (test-scribble '(("foo bar" "\n" "  baz")) "\\{foo bar
  baz}")
      (test-scribble '('("foo bar" "\n" "       baz")) "\\'{foo bar
       baz}")
      (test-scribble '((foo "bar      baz     blah")) "\\foo{bar \\; comment
     baz\\;
     blah}")

      (test-scribble '((foo "x " y " z")) "\\foo{x \\y z}")
      (test-scribble '((foo "x " (* y 2) " z")) "\\foo{x \\(* y 2) z}")
      (test-scribble '((foo " bar")) "\\{\\foo bar}")
      ;;(test-scribble '(((foo "bar") "baz")) "\\\\foo{bar}{baz}")

      (test-scribble '((foo 1 (* 2 3) "bar")) "\\foo[1 (* 2 3)]{bar}")
      (test-scribble '((foo (bar "...") "blah")) "\\foo[\\bar{...}]{blah}")
      (test-scribble '((foo bar)) "\\foo[bar]")
      (test-scribble '((foo "bar " (f x) " baz")) "\\foo{bar \\f[x] baz}")
      (test-scribble '((foo "bar")) "\\foo[]{bar}")
      (test-scribble '((foo)) "\\foo[]")
      (test-scribble '(foo) "\\foo")
      (test-scribble '((foo)) "\\foo{}")

      (test-scribble '((foo 'style: 'big  "bar")) "\\foo['style: 'big]{bar}")

      (test-scribble '((foo "f{o}o")) "\\foo{f{o}o}")
      (test-scribble '((foo "{{}}{}")) "\\foo{{{}}{}}")
      (test-scribble '((foo "bar")) "\\foo{bar}")
      (test-scribble '((foo " bar ")) "\\foo{ bar }")
      (test-scribble '((foo 1 " bar ")) "\\foo[1]{ bar }")

      (test-scribble '((foo "a " (bar "b") " c")) "\\foo{a \\bar{b} c}")
      (test-scribble '((foo "a " bar " c")) "\\foo{a \\bar c}")
      (test-scribble '((foo "a " (bar 2) " c")) "\\foo{a \\(bar 2) c}")
      (test-scribble '((foo "A } marks the end")) "\\foo{A \\\"}\" marks the end}")
      (test-scribble '((foo "The prefix: @.")) "\\foo{The prefix: \\\"@\".}")
      (test-scribble '((foo "The prefix: \\.")) "\\foo{The prefix: \\\"\\\\\".}")
      (test-scribble '((foo "\\x{y} --> (x \"y\")")) "\\foo{\\\"\\\\x{y}\" --> (x \"y\")}")

      (test-scribble '((foo "...")) "\\foo|{...}|")
      (test-scribble '((foo "\"}\" follows \"{\"")) "\\foo|{\"}\" follows \"{\"}|")
      (test-scribble '((foo "Nesting |{is}| ok")) "\\foo|{Nesting |{is}| ok}|")

      (test-scribble '((foo "Maze" "\n" "      " (bar "is") "\n" "      Life!"))
                     "\\foo|{Maze
      |\\bar{is}
      Life!}|")
      (test-scribble '((t "In " (i "sub\\s") " too")) "\\t|{In |\\i|{sub|\\\"\\\\\"s}| too}|")
      (test-scribble '((foo "\\x{foo} |\\{bar}|.")) "\\foo|<<<{\\x{foo} |\\{bar}|.}>>>|")
      (test-scribble '((foo "X " (b "Y") "...")) "\\foo|!!{X |!!\\b{Y}...}!!|")

      (test-scribble '((foo "foo" bar.)) "\\foo{foo\\bar.}")
      (test-scribble '((foo "foo" bar ".")) "\\foo{foo\\|bar|.}")
      (test-scribble '((foo "foo" 3.0)) "\\foo{foo\\3.}")
      (test-scribble '((foo "foo" 3 ".")) "\\foo{foo\\|3|.}")
      (test-scribble '((foo "foo" (f 1) "{bar}")) "\\foo{foo\\|(f 1)|{bar}}")
      (test-scribble '((foo "foo" bar "[1]{baz}")) "\\foo{foo\\|bar|[1]{baz}}")
      (test-scribble '((foo "xyz")) "\\foo{x\\\"y\"z}")
      (test-scribble '((foo "x" "y" "z")) "\\foo{x\\|\"y\"|z}")
      (test-scribble '((foo "x" 1 (+ 2 3) 4 "y")) "\\foo{x\\|1 (+ 2 3) 4|y}")
      (test-scribble '((foo "x" * * "y")) "\\foo{x\\|*
        *|y}")
      (test-scribble '((foo "Alice" "Bob" "Carol")) "\\foo{Alice\\||Bob\\|
     |Carol}")
      (test-scribble '((blah)) "\\|{blah}|")
      (test-scribble '((blah blah)) "\\|{blah blah}|")

      (test-scribble '((foo "First line" "\n" "     Second line")) "\\foo{First line\\;{there is still a
                  newline here;}
     Second line}")
      (test-scribble '((foo "A long      single-     string arg.")) "\\foo{A long \\;
     single-\\;
     string arg.}")

      (test-scribble '((foo "bar")) "\\foo{bar}")
      (test-scribble '((foo " bar ")) "\\foo{ bar }")
      (test-scribble '((foo " bar" "\n" "     baz ")) "\\foo{ bar
     baz }")

      (test-scribble '((foo "bar" "\n")) "\\foo{bar
}")
      (test-scribble '((foo "  bar" "\n") "\n") "\\foo{
  bar
}
")
      (test-scribble '((foo "  bar" "\n" "\n")) "\\foo{

  bar

}")
      (test-scribble '((foo "  bar" "\n" "\n" "  baz" "\n")) "\\foo{
  bar

  baz
}")
      (test-scribble '((foo)) "\\foo{
}")
      (test-scribble '((foo)) "\\foo{

}")
      (test-scribble '((foo " bar" "\n" "     baz ")) "\\foo{ bar
     baz }")

      (test-scribble '((foo "  bar" "\n" "  baz" "\n" "  blah" "\n")) "\\foo{
  bar
  baz
  blah
}")
      (test-scribble '((foo "  begin" "\n" "    x++;" "\n" "  end")) "\\foo{
  begin
    x++;
  end}")
      (test-scribble '((foo "    a" "\n" "   b" "\n" "  c")) "\\foo{
    a
   b
  c}")

      (test-scribble '((foo "bar" "\n" "       baz" "\n" "     bbb")) "\\foo{bar
       baz
     bbb}")
      (test-scribble '((foo " bar" "\n" "        baz" "\n" "      bbb")) "\\foo{ bar
        baz
      bbb}")
      (test-scribble '((foo "bar" "\n" "   baz" "\n" "   bbb")) "\\foo{bar
   baz
   bbb}")
      (test-scribble '((foo " bar" "\n" "   baz" "\n" "   bbb")) "\\foo{ bar
   baz
   bbb}")
      (test-scribble
       '((foo " bar" "\n" "   baz" "\n" "     bbb"))
       "\\foo{ bar
   baz
     bbb}")
      (test-scribble
       '((text "Some " (b "bold" "\n" "\n" "  text")", and" "\n" "\n" "  more text."))
       "\\text{Some \\b{bold

  text}, and

  more text.}")

      (test-scribble '((foo "  " " bar " "\n" "  " " baz")) "\\foo{
  \\|| bar \\||
  \\|| baz}")

      (test-end))))

;;> \subsubsubsection{\scheme{(disasm f [out])}}

;;> Write a human-readable disassembly for the procedure \var{f} to
;;> the port \var{out}, defaulting to \scheme{(current-output-port)}.

(define-library (chibi disasm)
  (export disasm)
  (import (chibi))
  (include-shared "disasm"))

(define-library (chibi bytevector-test)
  (export run-tests)
  (import (scheme base) (chibi bytevector) (chibi test))
  (begin

    (define floats
      `(0.0 -1.0 #i1/3 1.192092896E-07 ,(+ 1 1.192092896E-07)
        1e-23 -1e-23
        3.40282346638528860e+38 -3.40282346638528860e+38
        1.40129846432481707e-45 -1.40129846432481707e-45
        3.14159265358979323846))

    (define f32-le
      '#u8(#x00 #x00 #x00 #x00 #x00 #x00 #x80 #xbf
           #xab #xaa #xaa #x3e #x00 #x00 #x00 #x34
           #x01 #x00 #x80 #x3f #x9a #x6d #x41 #x19
           #x9a #x6d #x41 #x99 #xff #xff #x7f #x7f
           #xff #xff #x7f #xff #x01 #x00 #x00 #x00
           #x01 #x00 #x00 #x80 #xdb #x0f #x49 #x40))

    (define f64-le
      '#u8(#x00 #x00 #x00 #x00 #x00 #x00 #x00 #x00
           #x00 #x00 #x00 #x00 #x00 #x00 #xf0 #xbf
           #x55 #x55 #x55 #x55 #x55 #x55 #xd5 #x3f
           #x68 #x5f #x1c #x00 #x00 #x00 #x80 #x3e
           #x00 #x00 #x00 #x20 #x00 #x00 #xf0 #x3f
           #x51 #xb2 #x12 #x40 #xb3 #x2d #x28 #x3b
           #x51 #xb2 #x12 #x40 #xb3 #x2d #x28 #xbb
           #x00 #x00 #x00 #xe0 #xff #xff #xef #x47
           #x00 #x00 #x00 #xe0 #xff #xff #xef #xc7
           #x00 #x00 #x00 #x00 #x00 #x00 #xa0 #x36
           #x00 #x00 #x00 #x00 #x00 #x00 #xa0 #xb6
           #x18 #x2d #x44 #x54 #xfb #x21 #x09 #x40))

    (define (run-tests)
      (test-begin "bytevector")

      (test-group "reading ieee"

        (do ((ls floats (cdr ls))
            (i 0 (+ i 4)))
           ((null? ls))
         (test (car ls) (bytevector-ieee-single-native-ref f32-le i)))

       (do ((ls floats (cdr ls))
            (i 0 (+ i 8)))
           ((null? ls))
         (test (car ls) (bytevector-ieee-double-native-ref f64-le i))))

      (test-group "writing ieee"

        (do ((ls floats (cdr ls))
            (i 0 (+ i 4)))
           ((null? ls))
         (let ((bv (make-bytevector 4 0)))
           (bytevector-ieee-single-native-set! bv 0 (car ls))
           (test (bytevector-copy f32-le i (+ i 4)) (values bv))))

        (do ((ls floats (cdr ls))
            (i 0 (+ i 8)))
           ((null? ls))
         (let ((bv (make-bytevector 8 0)))
           (bytevector-ieee-double-native-set! bv 0 (car ls))
           ;;(test (bytevector-copy f64-le i (+ i 8)) (values bv))
           (test (car ls)
             (bytevector-ieee-double-native-ref bv 0)))))

      (test-group "ber integers"
        (do ((ls '(0 1 128 16383 32767
                   18446744073709551615
                   340282366920938463463374607431768211456)
                 (cdr ls)))
            ((null? ls))
          (let ((bv (make-bytevector 256)))
            (do ((offsets '(0 1 27) (cdr offsets)))
                ((null? offsets))
              (bytevector-ber-set! bv (car ls) (car offsets))
              (test (car ls) (bytevector-ber-ref bv (car offsets)))))))

      (test-end))))
(define-library (chibi tar-test)
  (export run-tests)
  (import (scheme base)
          (chibi tar)
          (chibi test))
  (begin
    ;; Utility to flatten bytevectors, strings and individual bytes
    ;; (integers) into a single bytevector for generating readable test
    ;; data.  (<byte> . <repetition>) can be used to repeat a byte.
    (define (bv . args)
      (apply bytevector-append
             (map (lambda (x)
                    (cond ((string? x) (string->utf8 x))
                          ((pair? x) (make-bytevector (cdr x) (car x)))
                          ((integer? x) (bytevector x))
                          (else x)))
                  args)))
    (define (run-tests)
      (test-begin "tar")

      (let ((b (bv "foo" '(0 . 97)
                   "000644 " 0
                   "000765 " 0
                   "000765 " 0
                   "00000000016 "
                   "12302104616 "
                   "011512" 0 " "
                   "0"
                   '(0 . 100)
                   "ustar" 0 "00"
                   "bob" '(0 . 29)
                   "bob" '(0 . 29)
                   "000000 " 0
                   "000000 " 0
                   '(0 . 155)
                   '(0 . 12)
                   )))
        (let ((x (read-tar (open-input-bytevector b))))
          (test "foo" (tar-path x))
          (test 501 (tar-uid x))
          (test "bob" (tar-owner x)))
        (let ((x (make-tar "bar" #o644 501 502 123 456 "0")))
          (test "bar" (tar-path x))
          (test "" (tar-path-prefix x))
          (tar-owner-set! x "john")
          (tar-group-set! x "smith")
          (test "john" (tar-owner x))
          (test "smith" (tar-group x))
          (test "bar" (tar-path x))
          (test "" (tar-path-prefix x))
          ;;(test-error (tar-mode-set! x "r"))
          (let ((out (open-output-bytevector)))
            (write-tar x out)
            (let ((bv2 (get-output-bytevector out)))
              (test-assert (bytevector? bv2))
              (let ((x2 (read-tar (open-input-bytevector bv2))))
                (test-assert "bar" (tar-path x2))
                (test-assert #o644 (tar-mode x2))
                (test-assert 501 (tar-uid x2))
                (test-assert 502 (tar-gid x2))
                (test-assert "john" (tar-owner x2)))))))

      (test-end))))
;; repl.scm - friendlier repl with line editing and signal handling
;; Copyright (c) 2012-2013 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

;;> A user-friendly REPL with line editing and signal handling.  The
;;> default REPL provided by chibi-scheme is very minimal, meant
;;> primarily to be small and work on any platform.  This module
;;> provides an advanced REPL that handles vt100 line editing and
;;> signal handling, so that C-c will interrupt a computation and
;;> bring you back to the REPL prompt.  To use this repl, run
;;> \command{chibi-scheme -R} from the command line or within Emacs.

(define (with-signal-handler sig handler thunk)
  (let ((old-handler #f))
    (dynamic-wind
      (lambda () (set! old-handler (set-signal-action! sig handler)))
      thunk
      (lambda () (set-signal-action! sig old-handler)))))

(define (warn msg . args)
  (let ((out (current-error-port)))
    (display msg out)
    (for-each (lambda (x) (write-char #\space out) (write x out)) args)
    (newline out)))

(define (write-to-string x)
  (call-with-output-string (lambda (out) (write x out))))

(define (complete-sexp? str)
  (call-with-input-string str
    (lambda (in)
      (let lp () (if (not (eof-object? (read/ss in))) (lp))))))

(define (read-line/complete-sexp in)
  (let lp ((res ""))
    (let ((line (read-line in)))
      (cond
       ((eof-object? line)
        (if (equal? res "") line res))
       (else
        (let ((res (string-append res line "\n")))
          (if (protect (exn (else #f)) (complete-sexp? res))
              res
              (lp res))))))))

(define (buffer-complete-sexp? buf)
  (complete-sexp? (buffer->string buf)))

(define module? vector?)
(define (module-env mod) (vector-ref mod 1))

(define (all-exports env)
  (let lp ((env env) (res '()))
    (if (not env)
        res
        (lp (env-parent env) (lset-union eq? (env-exports env) res)))))

(define (string-common-prefix-length strings)
  (if (null? strings)
      0
      (let lp ((len (string-length (car strings)))
               (prev (car strings))
               (ls (cdr strings)))
        (if (or (null? ls) (zero? len))
            len
            (call-with-values (lambda () (string-mismatch prev (car ls)))
              (lambda (i1 i2)
                (lp (min len (string-cursor->index prev i1))
                    (car ls)
                    (cdr ls))))))))

(define (make-sexp-buffer-completer)
  (buffer-make-completer
   (lambda (buf word)
     (let* ((len (string-length word))
            (candidates
             (filter
              (lambda (w)
                (and (>= (string-length w) len)
                     (equal? word (substring w 0 len))))
              (map symbol->string
                   (map identifier->symbol
                        (all-exports (interaction-environment))))))
            (prefix-len (string-common-prefix-length candidates)))
       (if (> prefix-len len)
           (list (substring (car candidates) 0 prefix-len))
           (sort candidates))))))

(define (describe x . o)
  (let ((out (if (pair? o) (car o) (current-output-port))))
    (cond
     ((null? x)
      (display "empty list\n" out))
     ((list? x)
      (display "list of length " out) (write (length x) out) (newline out)
      (let lp ((ls x) (i 0))
        (cond
         ((pair? ls)
          (display " " out) (write i out) (display ": " out)
          (write/ss (car ls) out) (newline out)
          (lp (cdr ls) (+ i 1))))))
     ((pair? x)
      (display "pair with car " out) (write/ss (car x) out) (newline out)
      (display "and cdr " out) (write/ss (cdr x) out) (newline out))
     ((vector? x)
      (let ((len (vector-length x)))
        (display "vector of length " out) (write len out) (newline out)
        (let lp ((i 0))
          (cond
           ((< i len)
            (display " " out) (write i out) (display ": " out)
            (write/ss (vector-ref x i) out) (newline out)
            (lp (+ i 1)))))))
     ((boolean? x)
      (display (if x "boolean true\n" "boolean false\n") out))
     ((char? x)
      (let ((n (char->integer x)))
        (display "character " out) (write x out)
        (display ", code: " out) (write n out)
        (display ", #x" out) (display (number->string n 16) out)
        (display ", #o" out) (display (number->string n 8) out)
        (newline out)))
     ((and (integer? x) (exact? x))
      (display "exact integer " out) (write x out)
      (display "\n  #x" out) (display (number->string x 16) out)
      (display "\n  #o" out) (display (number->string x 8) out)
      (display "\n  #b" out) (display (number->string x 2) out)
      (newline out))
     (else
      (write/ss x out) (newline out)))))

;;> Runs an interactive REPL.  Repeatedly displays a prompt,
;;> then Reads an expression, Evaluates the expression, Prints
;;> the result then Loops.  Terminates when the end of input is
;;> reached or the \scheme|{\exit}| command is given.
;;>
;;> Basic Emacs-style line editing with persistent history
;;> completion is provided.  C-c can be used to interrupt the
;;> current computation and drop back to the prompt.  The
;;> following keyword arguments customize the REPL:
;;>
;;> \itemlist[
;;> \item{\scheme{in:} - the input port (default \scheme{(current-input-port)})}
;;> \item{\scheme{out:} - the output port (default \scheme{(current-output-port)})}
;;> \item{\scheme{module:} - the initial module}
;;> \item{\scheme{environment:} - the initial environment (default \scheme{(interaction-environment)})}
;;> \item{\scheme{escape:} - the command escape character (default \scheme|{#\\}|)}
;;> \item{\scheme{make-prompt:} - a procedure taking one argument (the current module name as a list) and returning a string to be used as the prompt}
;;> \item{\scheme{history:} - the initial command history}
;;> \item{\scheme{history-file:} - the file to save history to (default ~/.chibi-repl-history)}
;;> ]
;;>
;;> The module: and environment: keyword arguments should not both be given.
;;>
;;> REPL commands in the style of \hyperlink["http://s48.org/"]{Scheme48}
;;> are available to control out-of-band properties.  By default a
;;> command is written as an identifier beginning with an "@"
;;> character, but this can be customized with the \scheme{escape:}
;;> keyword.  The following commands are available:
;;>
;;> \itemlist[
;;> \item{\scheme|{\import <import-spec>}| - import the \var{<import-spec>} in the \scheme{interaction-environment}, useful if the \scheme{import} binding is not available}
;;> \item{\scheme|{\import-only <import-spec>}| - replace the \scheme{interaction-environment} with the given \var{<import-spec>}}
;;> \item{\scheme|{\in [<module>]}| - switch to \var{<module>}, or the \scheme{interaction-environment} if \var{<module>} is not specified}
;;> \item{\scheme|{\meta <expr>}| - evaluate \var{<expr>} in the \scheme{(meta)} module}
;;> \item{\scheme|{\meta-module-is <module>}| - switch the meta module to \var{<module>}}
;;> \item{\scheme|{\exit}| - exit the REPL}
;;> ]

;;> The results of the last ten successful evaluations are available
;;> via a history facility. \var{$0} holds the most recent result
;;> while \var{$9} holds the tenth-most recent result. Evaluations
;;> yielding single values are stored as single values while evaluations
;;> that yield multiple values are stored as lists of values. 


(define-record-type Repl
  (make-repl
   in out escape module env meta-env make-prompt history-file history raw?)
  repl?
  (in repl-in repl-in-set!)
  (out repl-out repl-out-set!)
  (escape repl-escape repl-escape-set!)
  (module repl-module repl-module-set!)
  (env repl-env repl-env-set!)
  (meta-env repl-meta-env  repl-meta-env-set!)
  (make-prompt repl-make-prompt repl-make-prompt-set!)
  (history-file repl-history-file repl-history-file-set!)
  (history repl-history repl-history-set!)
  (raw? repl-raw? repl-raw?-set!))

(define (repl/import-aux rp args meta continue only?)
  (let* ((mod-name (cadr args))
         (mod+imps (eval `(resolve-import ',mod-name) (repl-meta-env rp))))
    (cond
     ((pair? mod+imps)
      (protect
          (exn
           (else
            (print-exception exn (current-error-port))
            (warn "error loading module:" mod-name)
            (continue rp)))
        (let ((env (if only? (make-environment) (repl-env rp)))
              (imp-env
               (module-env
                (eval `(load-module ',(car mod+imps)) (repl-meta-env rp)))))
          (%import env imp-env (cdr mod+imps) #f)
          (repl-env-set! rp env)
          (continue rp))))
     (else
      (warn "couldn't find module:" mod-name)
      (continue rp)))))

(define (repl/import rp args meta continue)
  (repl/import-aux rp args meta continue #f))

(define (repl/import-only rp args meta continue)
  (repl/import-aux rp args meta continue #t))

(define (repl/in rp args meta continue)
  (cond
   ((null? (cdr args))
    (repl-module-set! rp #f)
    (repl-env-set! rp (interaction-environment)))
   ((eval `(load-module ',(cadr args)) (repl-meta-env rp))
    => (lambda (m)
         (repl-module-set! rp (cadr args))
         (repl-env-set! rp (module-env m))))
   (else
    (warn "couldn't find module:" (cadr args))))
  (continue rp))

(define (repl/meta rp args meta continue)
  (cond
   ((null? (cdr args))
    (warn "usage: @meta <expr>")
    (continue rp))
   ((and (symbol? (cadr args))
         (eqv? (repl-escape rp) (string-ref (symbol->string (cadr args)) 0)))
    (meta rp (cdr args) (lambda _ (continue rp))))
   (else
    (eval (cadr args) (repl-meta-env rp))
    (continue rp))))

(define (repl/meta-module-is rp args meta continue)
  (cond
   ((null? (cdr args))
    (warn "usage: @meta-module-is <module>"))
   ((eval `(load-module ',(cadr args)) (repl-meta-env rp))
    => (lambda (m) (repl-meta-env-set! rp (module-env m))))
   (else
    (warn "couldn't find module:" (cadr args))))
  (continue rp))

(define (repl/help rp args meta continue)
  (let ((out (repl-out rp)))
    (cond
     ((null? (cdr args))
      (display "Try @help <identifier> [<module>]\n" out))
     ((null? (cddr args))
      (let* ((failed (list 'failed))
             (val (protect (exn (else (print-exception exn) failed))
                    (eval (second args) (repl-env rp))))
             (mod (and (procedure? val) (containing-module val))))
        (cond
         (mod
          (write val out) (newline out) (newline out)
          (print-module-binding-docs (car mod) (second args) out))
         ((not (eq? val failed))
          (describe val out)))))
     (else
      (protect (exn (else (print-exception exn (current-error-port))))
        (print-module-binding-docs (third args) (second args) out))))
    (continue rp)))

(define (repl/exit rp args meta continue)
  ;; To exit the repl simply don't call continue.
  #f)

;; Utility to read all objects from a port accumulated into a list.
(define (read/ss/all port)
  (let loop ((l '()))
    (let ((x (read/ss port)))
      (if (eof-object? x)
        (reverse l)
        (loop (cons x l))))))

(define (string->sexp-list str)
  (call-with-input-string str read/ss/all))

;; Utility to provide additional help for common exceptions.
(define (repl-advise-exception exn out)
  (cond
   ((and (exception? exn)
         (equal? "undefined variable" (exception-message exn))
         (pair? (exception-irritants exn)))
    (let ((name (car (exception-irritants exn))))
      (cond
       ((identifier? name)
        (display "Searching for modules exporting " out)
        (display name out)
        (display " ...\n" out)
        (let ((mods (modules-exporting-identifier name)))
          (cond
           ((pair? mods)
            (display name out)
            (display " is exported by:\n" out)
            (for-each
             (lambda (m)
               (display "  " out) (write m out) (newline out))
             (sort (map car mods)
                   (lambda (a b)
                     (string<? (write-to-string a) (write-to-string b))))))
           (else
            (display "... none found.\n" out))))))))
   ((and (exception? exn)
         (equal? "couldn't find import" (exception-message exn))
         (pair? (exception-irritants exn)))
    (let* ((mod-name (car (exception-irritants exn)))
           (mod-file (module-name->file mod-name))
           (scm-file (string-append
                      (substring mod-file
                                 0
                                 (- (string-length mod-file) 4))
                      ".scm")))
      (cond
       ((find-module-file mod-file)
        => (lambda (path)
             (let ((defined-mod-name
                     (protect (exn (else #f))
                       (let ((x (call-with-input-file path read)))
                         (and (pair? x)
                              (pair? (cdr x))
                              (eq? 'define-library (car x))
                              (cadr x))))))
               (cond
                ((not defined-mod-name)
                 (display "File '" out)
                 (display path out)
                 (display "' does not appear to define module " out)
                 (display mod-name out)
                 (display ".\n" out))
                ((equal? defined-mod-name mod-name)
                 (display "File '" out)
                 (display path out)
                 (display "' failed to define module " out)
                 (display mod-name out)
                 (display ".\n" out))
                (else
                 (display "Expected file '" out)
                 (display path out)
                 (display "' to define module " out)
                 (display mod-name out)
                 (display " but found " out)
                 (display defined-mod-name out)
                 (display ".\n" out))))))
       (else
        (display "Searched module path " out)
        (display (current-module-path) out)
        (display " for " out)
        (write mod-file out)
        (display ".\n" out)
        (cond
         ((find-module-file scm-file)
          => (lambda (file)
               (display "But found non-module-definition file " out)
               (write file out)
               (display ".\nNote module files must end in \".sld\".\n" out)))))))
    )))

(define undefined-value (if #f #f))

(define $0 undefined-value)
(define $1 undefined-value)
(define $2 undefined-value)
(define $3 undefined-value)
(define $4 undefined-value)
(define $5 undefined-value)
(define $6 undefined-value)
(define $7 undefined-value)
(define $8 undefined-value)
(define $9 undefined-value)

(define (push-history-value! value)
  (set! $9 $8)
  (set! $8 $7)
  (set! $7 $6)
  (set! $6 $5)
  (set! $5 $4)
  (set! $4 $3)
  (set! $3 $2)
  (set! $2 $1)
  (set! $1 $0)
  (set! $0 value))

(define (push-history-value-maybe! value)
  (cond ((eq? value undefined-value) undefined-value)
        ((not (list? value)) (push-history-value! value))
        ((= (length value) 0) undefined-value)
        ((= (length value) 1) (push-history-value! (car value)))
        (else (push-history-value! value))))

(define (repl/eval rp expr-list)
  (let ((thread (current-thread))
        (out (repl-out rp)))
    (with-signal-handler
     signal/interrupt
     (lambda (n) (thread-interrupt! thread))
     (lambda ()
       (protect (exn
                 (else
                  (print-exception exn out)
                  (repl-advise-exception exn (current-error-port))))
         (for-each
          (lambda (expr)
            (call-with-values
                (lambda ()
                  (if (or (identifier? expr)
                          (pair? expr)
                          (null? expr))
                      (eval expr (repl-env rp))
                      expr))
              (lambda res-list
                (cond
                 ((not (or (null? res-list)
                           (equal? res-list (list (if #f #f)))))
                  (push-history-value-maybe! res-list)
                  (write/ss (car res-list) out)
                  (for-each
                   (lambda (res)
                     (write-char #\space out)
                     (write/ss res out))
                   (cdr res-list))
                  (newline out))))))
          expr-list))))))

(define (repl/eval-string rp str)
  (repl/eval
   rp
   (protect (exn (else (print-exception exn (current-error-port))))
     ;; Ugly wrapper to account for the implicit state mutation
     ;; implied by the #!fold-case read syntax.
     (let ((in (repl-in rp))
           (in2 (open-input-string str)))
       (set-port-fold-case! in2 (port-fold-case? in))
       (set-port-line! in2 (port-line in))
       (let ((expr-list (read/ss/all in2)))
         (set-port-fold-case! in (port-fold-case? in2))
         expr-list)))))

(define (keywords->repl ls)
  (let-keywords* ls
      ((in in: (current-input-port))
       (out out: (current-output-port))
       (escape escape: #\@)
       (module module: #f)
       (env
        environment:
        (if module
            (module-env
             (if (module? module) module (load-module module)))
            (interaction-environment)))
       (make-prompt
        make-prompt:
        (lambda (module)
          (string-append (if module (write-to-string module) "") "> ")))
       (history-file
        history-file:
        (string-append (get-environment-variable "HOME")
                       "/.chibi-repl-history"))
       (history
        history:
        (or (protect (exn (else #f))
              (list->history (call-with-input-file history-file read)))
            (make-history)))
       (raw? raw?:
             (member (get-environment-variable "TERM") '("emacs" "dumb")))
       (meta-env meta-env: (module-env (load-module '(meta)))))
    (make-repl
     in out escape module env meta-env make-prompt history-file history raw?)))

(define (repl/edit-line rp)
  (let ((prompt ((repl-make-prompt rp) (repl-module rp)))
        (in (repl-in rp))
        (out (repl-out rp)))
    (cond
     ((repl-raw? rp)
      (display prompt out)
      (flush-output out)
      (read-line/complete-sexp in))
     (else
      (edit-line in out
                 'prompt: prompt
                 'history: (repl-history rp)
                 'complete?: buffer-complete-sexp?
                 'completion: (make-sexp-buffer-completer)
                 'catch-control-c?: #t
                 'fresh-line: " \x1B;[33m\\\x1B;[0m")))))

(define repl-commands
  `((import . ,repl/import)
    (import-only . ,repl/import-only)
    (in . ,repl/in)
    (meta . ,repl/meta)
    (meta-module-is . ,repl/meta-module-is)
    (? . ,repl/help)
    (h . ,repl/help)
    (help . ,repl/help)
    (exit . ,repl/exit)))

(define (repl . o)
  (let ((rp (keywords->repl o)))
    (let lp ((rp rp))
      (let ((line (repl/edit-line rp)))
        (cond
         ((or (not line) (eof-object? line)))
         ((equal? line "")
          (history-reset! (repl-history rp))
          (lp rp))
         (else
          (history-commit! (repl-history rp) line)
          (cond
           ((and (> (string-length line) 1)
                 (eqv? (repl-escape rp) (string-ref line 0)))
            ;; @ escaped command
            (let meta ((rp rp)
                       (args (string->sexp-list (substring line 1)))
                       (continue lp))
              (cond
               ((null? args)
                (warn "empty repl command")
                (continue rp))
               ((assq (car args) repl-commands)
                => (lambda (x) ((cdr x) rp args meta continue)))
               (else
                (warn "unknown repl command" (car args))
                (continue rp)))))
           (else
            ;; Normal expression to eval.
            (repl/eval-string rp line)
            (lp rp)))))))
    ;; Update the history file on completion.
    (if (repl-history-file rp)
        (protect
            (exn
             (else
              (let ((msg (integer->error-string)))
                (display "couldn't save repl history: " (current-error-port))
                (display msg (current-error-port))
                (newline (current-error-port)))))
          (call-with-output-file (repl-history-file rp)
            (lambda (out) (write (history->list (repl-history rp)) out)))))))

(define (main args)
  (import (only (chibi repl) $0 $1 $2 $3 $4 $5 $6 $7 $8 $9))
  (repl))
;; channel.scm -- thread-safe channel (FIFO) library
;; Copyright (c) 2012 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

(define-record-type Channel
  (%make-channel mutex condvar front rear)
  channel?
  (mutex channel-mutex channel-mutex-set!)
  (condvar channel-condvar channel-condvar-set!)
  (front channel-front channel-front-set!)
  (rear channel-rear channel-rear-set!))

(define (make-channel)
  (%make-channel (make-mutex) (make-condition-variable) '() '()))

(define (channel-empty? chan)
  (null? (channel-front chan)))

(define (channel-send! chan obj)
  (mutex-lock! (channel-mutex chan))
  (let ((new (list obj))
        (rear (channel-rear chan)))
    (channel-rear-set! chan new)
    (cond
     ((pair? rear)
      (set-cdr! rear new))
     (else  ; sending to empty channel
      (channel-front-set! chan new)
      (condition-variable-broadcast! (channel-condvar chan)))))
  (mutex-unlock! (channel-mutex chan)))

(define (channel-receive! chan)
  (mutex-lock! (channel-mutex chan))
  (let ((front (channel-front chan)))
    (cond
     ((null? front)  ; receiving from empty channel
      (mutex-unlock! (channel-mutex chan) (channel-condvar chan))
      (channel-receive! chan))
     (else
      (channel-front-set! chan (cdr front))
      (if (null? (cdr front))
          (channel-rear-set! chan '()))
      (mutex-unlock! (channel-mutex chan))
      (car front)))))
;; Character sets for Unicode boundaries, TR29.
;; This code is written by Alex Shinn and placed in the
;; Public Domain.  All warranties are disclaimed.

;;> Char-sets used for
;;> \hyperlink["http://unicode.org/reports/tr29/"]{TR29} word
;;> boundaries.

(define-library (chibi char-set boundary)
  (cond-expand
   (chibi (import (chibi)))
   (else (import (scheme base))))
  (cond-expand
   ((library (chibi char-set)) (import (chibi char-set)))
   (else
    (import (srfi 14))
    (begin (define (immutable-char-set cs) cs))))
  (export char-set:regional-indicator
          char-set:extend-or-spacing-mark
          char-set:hangul-l
          char-set:hangul-v
          char-set:hangul-t
          char-set:hangul-lv
          char-set:hangul-lvt)
  ;; generated with:
  ;; tools/extract-unicode-props.scm --derived GraphemeBreakProperty.txt
  ;;   Control extend-or-spacing-mark=Extend,SpacingMark Regional_Indicator
  ;;   hangul-l=:L hangul-v=:V hangul-t=:T hangul-lv=:LV hangul-lvt=:LVT
  (include "boundary.scm"))
;; char-set:lower-case
(define char-set:lower-case (immutable-char-set (%make-iset 97 127 67108863 #f #f)))

;; char-set:upper-case
(define char-set:upper-case (immutable-char-set (%make-iset 65 127 67108863 #f #f)))

;; char-set:title-case
(define char-set:title-case (immutable-char-set (%make-iset 0 0 0 #f #f)))

;; char-set:letter
(define char-set:letter (immutable-char-set (%make-iset 65 127 288230371923853311 #f #f)))

;; char-set:punctuation
(define char-set:punctuation (immutable-char-set (%make-iset 33 127 6189700203056200029306911735 #f #f)))

;; char-set:symbol
(define char-set:symbol (immutable-char-set (%make-iset 36 127 1547425050547877224499904641 #f #f)))

;; char-set:blank
(define char-set:blank (immutable-char-set (%make-iset 9 32 8388609 #f #f)))

;; char-set:whitespace
(define char-set:whitespace (immutable-char-set (%make-iset 9 127 8388639 #f #f)))

;; char-set:digit
(define char-set:digit (immutable-char-set (%make-iset 48 57 #f #f #f)))

;; char-set:letter+digit
(define char-set:letter+digit (immutable-char-set (%make-iset 48 127 37778931308803301180415 #f #f)))

;; char-set:hex-digit
(define char-set:hex-digit (immutable-char-set (%make-iset 48 102 35465847073801215 #f #f)))

;; char-set:iso-control
(define char-set:iso-control (immutable-char-set (%make-iset 0 127 170141183460469231731687303720179073023 #f #f)))

;; char-set:graphic
(define char-set:graphic (immutable-char-set (%make-iset 33 127 19807040628566084398385987583 #f #f)))

;; char-set:printing
(define char-set:printing (immutable-char-set (%make-iset 9 127 332306998946228968225951765061697567 #f #f)))

;; Control
(define char-set:control (immutable-char-set (char-set-union (ucs-range->char-set 0 10) (ucs-range->char-set 11 13) (ucs-range->char-set 14 32) (ucs-range->char-set 127 160) (ucs-range->char-set 1536 1541) (ucs-range->char-set 8206 8208) (ucs-range->char-set 8234 8239) (ucs-range->char-set 8288 8293) (ucs-range->char-set 8294 8304) (ucs-range->char-set 55296 57344) (ucs-range->char-set 65520 65529) (ucs-range->char-set 65529 65532) (ucs-range->char-set 119155 119163) (ucs-range->char-set 917506 917536) (ucs-range->char-set 917536 917632) (ucs-range->char-set 917632 917760) (ucs-range->char-set 918000 921600))))

;; Extend,SpacingMark
(define char-set:extend-or-spacing-mark (immutable-char-set (char-set-union (char-set-union (ucs-range->char-set 768 880) (ucs-range->char-set 1155 1160) (ucs-range->char-set 1160 1162) (ucs-range->char-set 1425 1470) (ucs-range->char-set 1473 1475) (ucs-range->char-set 1476 1478) (ucs-range->char-set 1552 1563) (ucs-range->char-set 1611 1632) (ucs-range->char-set 1750 1757) (ucs-range->char-set 1759 1765) (ucs-range->char-set 1767 1769) (ucs-range->char-set 1770 1774) (ucs-range->char-set 1840 1867) (ucs-range->char-set 1958 1969) (ucs-range->char-set 2027 2036) (ucs-range->char-set 2070 2074) (ucs-range->char-set 2075 2084) (ucs-range->char-set 2085 2088) (ucs-range->char-set 2089 2094) (ucs-range->char-set 2137 2140) (ucs-range->char-set 2276 2303) (ucs-range->char-set 2304 2307) (ucs-range->char-set 2369 2377) (ucs-range->char-set 2385 2392) (ucs-range->char-set 2402 2404) (ucs-range->char-set 2497 2501) (ucs-range->char-set 2530 2532) (ucs-range->char-set 2561 2563) (ucs-range->char-set 2625 2627) (ucs-range->char-set 2631 2633) (ucs-range->char-set 2635 2638) (ucs-range->char-set 2672 2674) (ucs-range->char-set 2689 2691) (ucs-range->char-set 2753 2758) (ucs-range->char-set 2759 2761) (ucs-range->char-set 2786 2788) (ucs-range->char-set 2881 2885) (ucs-range->char-set 2914 2916) (ucs-range->char-set 3134 3137) (ucs-range->char-set 3142 3145) (ucs-range->char-set 3146 3150) (ucs-range->char-set 3157 3159) (ucs-range->char-set 3170 3172) (ucs-range->char-set 3276 3278) (ucs-range->char-set 3285 3287) (ucs-range->char-set 3298 3300) (ucs-range->char-set 3393 3397) (ucs-range->char-set 3426 3428) (ucs-range->char-set 3538 3541) (ucs-range->char-set 3636 3643) (ucs-range->char-set 3655 3663) (ucs-range->char-set 3764 3770) (ucs-range->char-set 3771 3773) (ucs-range->char-set 3784 3790) (ucs-range->char-set 3864 3866) (ucs-range->char-set 3953 3967) (ucs-range->char-set 3968 3973) (ucs-range->char-set 3974 3976) (ucs-range->char-set 3981 3992) (ucs-range->char-set 3993 4029) (ucs-range->char-set 4141 4145) (ucs-range->char-set 4146 4152) (ucs-range->char-set 4153 4155) (ucs-range->char-set 4157 4159) (ucs-range->char-set 4184 4186) (ucs-range->char-set 4190 4193) (ucs-range->char-set 4209 4213) (ucs-range->char-set 4229 4231) (ucs-range->char-set 4957 4960) (ucs-range->char-set 5906 5909) (ucs-range->char-set 5938 5941) (ucs-range->char-set 5970 5972) (ucs-range->char-set 6002 6004) (ucs-range->char-set 6068 6070) (ucs-range->char-set 6071 6078) (ucs-range->char-set 6089 6100) (ucs-range->char-set 6155 6158) (ucs-range->char-set 6432 6435) (ucs-range->char-set 6439 6441) (ucs-range->char-set 6457 6460) (ucs-range->char-set 6679 6681) (ucs-range->char-set 6744 6751) (ucs-range->char-set 6757 6765) (ucs-range->char-set 6771 6781) (ucs-range->char-set 6912 6916) (ucs-range->char-set 6966 6971) (ucs-range->char-set 7019 7028) (ucs-range->char-set 7040 7042) (ucs-range->char-set 7074 7078) (ucs-range->char-set 7080 7082) (ucs-range->char-set 7144 7146) (ucs-range->char-set 7151 7154) (ucs-range->char-set 7212 7220) (ucs-range->char-set 7222 7224) (ucs-range->char-set 7376 7379) (ucs-range->char-set 7380 7393) (ucs-range->char-set 7394 7401) (ucs-range->char-set 7616 7655) (ucs-range->char-set 7676 7680) (ucs-range->char-set 8204 8206) (ucs-range->char-set 8400 8413) (ucs-range->char-set 8413 8417) (ucs-range->char-set 8418 8421) (ucs-range->char-set 8421 8433) (ucs-range->char-set 11503 11506) (ucs-range->char-set 11744 11776) (ucs-range->char-set 12330 12334) (ucs-range->char-set 12334 12336) (ucs-range->char-set 12441 12443) (ucs-range->char-set 42608 42611) (ucs-range->char-set 42612 42622) (ucs-range->char-set 42736 42738) (ucs-range->char-set 43045 43047) (ucs-range->char-set 43232 43250) (ucs-range->char-set 43302 43310) (ucs-range->char-set 43335 43346) (ucs-range->char-set 43392 43395) (ucs-range->char-set 43446 43450) (ucs-range->char-set 43561 43567) (ucs-range->char-set 43569 43571) (ucs-range->char-set 43573 43575) (ucs-range->char-set 43698 43701) (ucs-range->char-set 43703 43705) (ucs-range->char-set 43710 43712) (ucs-range->char-set 43756 43758) (ucs-range->char-set 65024 65040) (ucs-range->char-set 65056 65063) (ucs-range->char-set 65438 65440) (ucs-range->char-set 68097 68100) (ucs-range->char-set 68101 68103) (ucs-range->char-set 68108 68112) (ucs-range->char-set 68152 68155) (ucs-range->char-set 69688 69703) (ucs-range->char-set 69760 69762) (ucs-range->char-set 69811 69815) (ucs-range->char-set 69817 69819) (ucs-range->char-set 69888 69891) (ucs-range->char-set 69927 69932) (ucs-range->char-set 69933 69941) (ucs-range->char-set 70016 70018) (ucs-range->char-set 70070 70079) (ucs-range->char-set 71344 71350) (ucs-range->char-set 94095 94099) (ucs-range->char-set 119143 119146) (ucs-range->char-set 119150 119155) (ucs-range->char-set 119163 119171) (ucs-range->char-set 119173 119180) (ucs-range->char-set 119210 119214) (ucs-range->char-set 119362 119365) (ucs-range->char-set 917760 918000)) (char-set-union (ucs-range->char-set 2366 2369) (ucs-range->char-set 2377 2381) (ucs-range->char-set 2382 2384) (ucs-range->char-set 2434 2436) (ucs-range->char-set 2495 2497) (ucs-range->char-set 2503 2505) (ucs-range->char-set 2507 2509) (ucs-range->char-set 2622 2625) (ucs-range->char-set 2750 2753) (ucs-range->char-set 2763 2765) (ucs-range->char-set 2818 2820) (ucs-range->char-set 2887 2889) (ucs-range->char-set 2891 2893) (ucs-range->char-set 3009 3011) (ucs-range->char-set 3014 3017) (ucs-range->char-set 3018 3021) (ucs-range->char-set 3073 3076) (ucs-range->char-set 3137 3141) (ucs-range->char-set 3202 3204) (ucs-range->char-set 3264 3266) (ucs-range->char-set 3267 3269) (ucs-range->char-set 3271 3273) (ucs-range->char-set 3274 3276) (ucs-range->char-set 3330 3332) (ucs-range->char-set 3391 3393) (ucs-range->char-set 3398 3401) (ucs-range->char-set 3402 3405) (ucs-range->char-set 3458 3460) (ucs-range->char-set 3536 3538) (ucs-range->char-set 3544 3551) (ucs-range->char-set 3570 3572) (ucs-range->char-set 3902 3904) (ucs-range->char-set 4155 4157) (ucs-range->char-set 4182 4184) (ucs-range->char-set 6078 6086) (ucs-range->char-set 6087 6089) (ucs-range->char-set 6435 6439) (ucs-range->char-set 6441 6444) (ucs-range->char-set 6448 6450) (ucs-range->char-set 6451 6457) (ucs-range->char-set 6581 6584) (ucs-range->char-set 6681 6683) (ucs-range->char-set 6765 6771) (ucs-range->char-set 6973 6978) (ucs-range->char-set 6979 6981) (ucs-range->char-set 7078 7080) (ucs-range->char-set 7084 7086) (ucs-range->char-set 7146 7149) (ucs-range->char-set 7154 7156) (ucs-range->char-set 7204 7212) (ucs-range->char-set 7220 7222) (ucs-range->char-set 7410 7412) (ucs-range->char-set 43043 43045) (ucs-range->char-set 43136 43138) (ucs-range->char-set 43188 43204) (ucs-range->char-set 43346 43348) (ucs-range->char-set 43444 43446) (ucs-range->char-set 43450 43452) (ucs-range->char-set 43453 43457) (ucs-range->char-set 43567 43569) (ucs-range->char-set 43571 43573) (ucs-range->char-set 43758 43760) (ucs-range->char-set 44003 44005) (ucs-range->char-set 44006 44008) (ucs-range->char-set 44009 44011) (ucs-range->char-set 69808 69811) (ucs-range->char-set 69815 69817) (ucs-range->char-set 70067 70070) (ucs-range->char-set 70079 70081) (ucs-range->char-set 71342 71344) (ucs-range->char-set 94033 94079)))))

;; Regional_Indicator
(define char-set:regional-indicator (immutable-char-set (char-set-union (ucs-range->char-set 127462 127488))))

;; :L
(define char-set:hangul-l (immutable-char-set (char-set-union (ucs-range->char-set 4352 4448) (ucs-range->char-set 43360 43389))))

;; :V
(define char-set:hangul-v (immutable-char-set (char-set-union (ucs-range->char-set 4448 4520) (ucs-range->char-set 55216 55239))))

;; :T
(define char-set:hangul-t (immutable-char-set (char-set-union (ucs-range->char-set 4520 4608) (ucs-range->char-set 55243 55292))))

;; :LV
(define char-set:hangul-lv (immutable-char-set (char-set-union)))

;; :LVT
(define char-set:hangul-lvt (immutable-char-set (char-set-union (ucs-range->char-set 44033 44060) (ucs-range->char-set 44061 44088) (ucs-range->char-set 44089 44116) (ucs-range->char-set 44117 44144) (ucs-range->char-set 44145 44172) (ucs-range->char-set 44173 44200) (ucs-range->char-set 44201 44228) (ucs-range->char-set 44229 44256) (ucs-range->char-set 44257 44284) (ucs-range->char-set 44285 44312) (ucs-range->char-set 44313 44340) (ucs-range->char-set 44341 44368) (ucs-range->char-set 44369 44396) (ucs-range->char-set 44397 44424) (ucs-range->char-set 44425 44452) (ucs-range->char-set 44453 44480) (ucs-range->char-set 44481 44508) (ucs-range->char-set 44509 44536) (ucs-range->char-set 44537 44564) (ucs-range->char-set 44565 44592) (ucs-range->char-set 44593 44620) (ucs-range->char-set 44621 44648) (ucs-range->char-set 44649 44676) (ucs-range->char-set 44677 44704) (ucs-range->char-set 44705 44732) (ucs-range->char-set 44733 44760) (ucs-range->char-set 44761 44788) (ucs-range->char-set 44789 44816) (ucs-range->char-set 44817 44844) (ucs-range->char-set 44845 44872) (ucs-range->char-set 44873 44900) (ucs-range->char-set 44901 44928) (ucs-range->char-set 44929 44956) (ucs-range->char-set 44957 44984) (ucs-range->char-set 44985 45012) (ucs-range->char-set 45013 45040) (ucs-range->char-set 45041 45068) (ucs-range->char-set 45069 45096) (ucs-range->char-set 45097 45124) (ucs-range->char-set 45125 45152) (ucs-range->char-set 45153 45180) (ucs-range->char-set 45181 45208) (ucs-range->char-set 45209 45236) (ucs-range->char-set 45237 45264) (ucs-range->char-set 45265 45292) (ucs-range->char-set 45293 45320) (ucs-range->char-set 45321 45348) (ucs-range->char-set 45349 45376) (ucs-range->char-set 45377 45404) (ucs-range->char-set 45405 45432) (ucs-range->char-set 45433 45460) (ucs-range->char-set 45461 45488) (ucs-range->char-set 45489 45516) (ucs-range->char-set 45517 45544) (ucs-range->char-set 45545 45572) (ucs-range->char-set 45573 45600) (ucs-range->char-set 45601 45628) (ucs-range->char-set 45629 45656) (ucs-range->char-set 45657 45684) (ucs-range->char-set 45685 45712) (ucs-range->char-set 45713 45740) (ucs-range->char-set 45741 45768) (ucs-range->char-set 45769 45796) (ucs-range->char-set 45797 45824) (ucs-range->char-set 45825 45852) (ucs-range->char-set 45853 45880) (ucs-range->char-set 45881 45908) (ucs-range->char-set 45909 45936) (ucs-range->char-set 45937 45964) (ucs-range->char-set 45965 45992) (ucs-range->char-set 45993 46020) (ucs-range->char-set 46021 46048) (ucs-range->char-set 46049 46076) (ucs-range->char-set 46077 46104) (ucs-range->char-set 46105 46132) (ucs-range->char-set 46133 46160) (ucs-range->char-set 46161 46188) (ucs-range->char-set 46189 46216) (ucs-range->char-set 46217 46244) (ucs-range->char-set 46245 46272) (ucs-range->char-set 46273 46300) (ucs-range->char-set 46301 46328) (ucs-range->char-set 46329 46356) (ucs-range->char-set 46357 46384) (ucs-range->char-set 46385 46412) (ucs-range->char-set 46413 46440) (ucs-range->char-set 46441 46468) (ucs-range->char-set 46469 46496) (ucs-range->char-set 46497 46524) (ucs-range->char-set 46525 46552) (ucs-range->char-set 46553 46580) (ucs-range->char-set 46581 46608) (ucs-range->char-set 46609 46636) (ucs-range->char-set 46637 46664) (ucs-range->char-set 46665 46692) (ucs-range->char-set 46693 46720) (ucs-range->char-set 46721 46748) (ucs-range->char-set 46749 46776) (ucs-range->char-set 46777 46804) (ucs-range->char-set 46805 46832) (ucs-range->char-set 46833 46860) (ucs-range->char-set 46861 46888) (ucs-range->char-set 46889 46916) (ucs-range->char-set 46917 46944) (ucs-range->char-set 46945 46972) (ucs-range->char-set 46973 47000) (ucs-range->char-set 47001 47028) (ucs-range->char-set 47029 47056) (ucs-range->char-set 47057 47084) (ucs-range->char-set 47085 47112) (ucs-range->char-set 47113 47140) (ucs-range->char-set 47141 47168) (ucs-range->char-set 47169 47196) (ucs-range->char-set 47197 47224) (ucs-range->char-set 47225 47252) (ucs-range->char-set 47253 47280) (ucs-range->char-set 47281 47308) (ucs-range->char-set 47309 47336) (ucs-range->char-set 47337 47364) (ucs-range->char-set 47365 47392) (ucs-range->char-set 47393 47420) (ucs-range->char-set 47421 47448) (ucs-range->char-set 47449 47476) (ucs-range->char-set 47477 47504) (ucs-range->char-set 47505 47532) (ucs-range->char-set 47533 47560) (ucs-range->char-set 47561 47588) (ucs-range->char-set 47589 47616) (ucs-range->char-set 47617 47644) (ucs-range->char-set 47645 47672) (ucs-range->char-set 47673 47700) (ucs-range->char-set 47701 47728) (ucs-range->char-set 47729 47756) (ucs-range->char-set 47757 47784) (ucs-range->char-set 47785 47812) (ucs-range->char-set 47813 47840) (ucs-range->char-set 47841 47868) (ucs-range->char-set 47869 47896) (ucs-range->char-set 47897 47924) (ucs-range->char-set 47925 47952) (ucs-range->char-set 47953 47980) (ucs-range->char-set 47981 48008) (ucs-range->char-set 48009 48036) (ucs-range->char-set 48037 48064) (ucs-range->char-set 48065 48092) (ucs-range->char-set 48093 48120) (ucs-range->char-set 48121 48148) (ucs-range->char-set 48149 48176) (ucs-range->char-set 48177 48204) (ucs-range->char-set 48205 48232) (ucs-range->char-set 48233 48260) (ucs-range->char-set 48261 48288) (ucs-range->char-set 48289 48316) (ucs-range->char-set 48317 48344) (ucs-range->char-set 48345 48372) (ucs-range->char-set 48373 48400) (ucs-range->char-set 48401 48428) (ucs-range->char-set 48429 48456) (ucs-range->char-set 48457 48484) (ucs-range->char-set 48485 48512) (ucs-range->char-set 48513 48540) (ucs-range->char-set 48541 48568) (ucs-range->char-set 48569 48596) (ucs-range->char-set 48597 48624) (ucs-range->char-set 48625 48652) (ucs-range->char-set 48653 48680) (ucs-range->char-set 48681 48708) (ucs-range->char-set 48709 48736) (ucs-range->char-set 48737 48764) (ucs-range->char-set 48765 48792) (ucs-range->char-set 48793 48820) (ucs-range->char-set 48821 48848) (ucs-range->char-set 48849 48876) (ucs-range->char-set 48877 48904) (ucs-range->char-set 48905 48932) (ucs-range->char-set 48933 48960) (ucs-range->char-set 48961 48988) (ucs-range->char-set 48989 49016) (ucs-range->char-set 49017 49044) (ucs-range->char-set 49045 49072) (ucs-range->char-set 49073 49100) (ucs-range->char-set 49101 49128) (ucs-range->char-set 49129 49156) (ucs-range->char-set 49157 49184) (ucs-range->char-set 49185 49212) (ucs-range->char-set 49213 49240) (ucs-range->char-set 49241 49268) (ucs-range->char-set 49269 49296) (ucs-range->char-set 49297 49324) (ucs-range->char-set 49325 49352) (ucs-range->char-set 49353 49380) (ucs-range->char-set 49381 49408) (ucs-range->char-set 49409 49436) (ucs-range->char-set 49437 49464) (ucs-range->char-set 49465 49492) (ucs-range->char-set 49493 49520) (ucs-range->char-set 49521 49548) (ucs-range->char-set 49549 49576) (ucs-range->char-set 49577 49604) (ucs-range->char-set 49605 49632) (ucs-range->char-set 49633 49660) (ucs-range->char-set 49661 49688) (ucs-range->char-set 49689 49716) (ucs-range->char-set 49717 49744) (ucs-range->char-set 49745 49772) (ucs-range->char-set 49773 49800) (ucs-range->char-set 49801 49828) (ucs-range->char-set 49829 49856) (ucs-range->char-set 49857 49884) (ucs-range->char-set 49885 49912) (ucs-range->char-set 49913 49940) (ucs-range->char-set 49941 49968) (ucs-range->char-set 49969 49996) (ucs-range->char-set 49997 50024) (ucs-range->char-set 50025 50052) (ucs-range->char-set 50053 50080) (ucs-range->char-set 50081 50108) (ucs-range->char-set 50109 50136) (ucs-range->char-set 50137 50164) (ucs-range->char-set 50165 50192) (ucs-range->char-set 50193 50220) (ucs-range->char-set 50221 50248) (ucs-range->char-set 50249 50276) (ucs-range->char-set 50277 50304) (ucs-range->char-set 50305 50332) (ucs-range->char-set 50333 50360) (ucs-range->char-set 50361 50388) (ucs-range->char-set 50389 50416) (ucs-range->char-set 50417 50444) (ucs-range->char-set 50445 50472) (ucs-range->char-set 50473 50500) (ucs-range->char-set 50501 50528) (ucs-range->char-set 50529 50556) (ucs-range->char-set 50557 50584) (ucs-range->char-set 50585 50612) (ucs-range->char-set 50613 50640) (ucs-range->char-set 50641 50668) (ucs-range->char-set 50669 50696) (ucs-range->char-set 50697 50724) (ucs-range->char-set 50725 50752) (ucs-range->char-set 50753 50780) (ucs-range->char-set 50781 50808) (ucs-range->char-set 50809 50836) (ucs-range->char-set 50837 50864) (ucs-range->char-set 50865 50892) (ucs-range->char-set 50893 50920) (ucs-range->char-set 50921 50948) (ucs-range->char-set 50949 50976) (ucs-range->char-set 50977 51004) (ucs-range->char-set 51005 51032) (ucs-range->char-set 51033 51060) (ucs-range->char-set 51061 51088) (ucs-range->char-set 51089 51116) (ucs-range->char-set 51117 51144) (ucs-range->char-set 51145 51172) (ucs-range->char-set 51173 51200) (ucs-range->char-set 51201 51228) (ucs-range->char-set 51229 51256) (ucs-range->char-set 51257 51284) (ucs-range->char-set 51285 51312) (ucs-range->char-set 51313 51340) (ucs-range->char-set 51341 51368) (ucs-range->char-set 51369 51396) (ucs-range->char-set 51397 51424) (ucs-range->char-set 51425 51452) (ucs-range->char-set 51453 51480) (ucs-range->char-set 51481 51508) (ucs-range->char-set 51509 51536) (ucs-range->char-set 51537 51564) (ucs-range->char-set 51565 51592) (ucs-range->char-set 51593 51620) (ucs-range->char-set 51621 51648) (ucs-range->char-set 51649 51676) (ucs-range->char-set 51677 51704) (ucs-range->char-set 51705 51732) (ucs-range->char-set 51733 51760) (ucs-range->char-set 51761 51788) (ucs-range->char-set 51789 51816) (ucs-range->char-set 51817 51844) (ucs-range->char-set 51845 51872) (ucs-range->char-set 51873 51900) (ucs-range->char-set 51901 51928) (ucs-range->char-set 51929 51956) (ucs-range->char-set 51957 51984) (ucs-range->char-set 51985 52012) (ucs-range->char-set 52013 52040) (ucs-range->char-set 52041 52068) (ucs-range->char-set 52069 52096) (ucs-range->char-set 52097 52124) (ucs-range->char-set 52125 52152) (ucs-range->char-set 52153 52180) (ucs-range->char-set 52181 52208) (ucs-range->char-set 52209 52236) (ucs-range->char-set 52237 52264) (ucs-range->char-set 52265 52292) (ucs-range->char-set 52293 52320) (ucs-range->char-set 52321 52348) (ucs-range->char-set 52349 52376) (ucs-range->char-set 52377 52404) (ucs-range->char-set 52405 52432) (ucs-range->char-set 52433 52460) (ucs-range->char-set 52461 52488) (ucs-range->char-set 52489 52516) (ucs-range->char-set 52517 52544) (ucs-range->char-set 52545 52572) (ucs-range->char-set 52573 52600) (ucs-range->char-set 52601 52628) (ucs-range->char-set 52629 52656) (ucs-range->char-set 52657 52684) (ucs-range->char-set 52685 52712) (ucs-range->char-set 52713 52740) (ucs-range->char-set 52741 52768) (ucs-range->char-set 52769 52796) (ucs-range->char-set 52797 52824) (ucs-range->char-set 52825 52852) (ucs-range->char-set 52853 52880) (ucs-range->char-set 52881 52908) (ucs-range->char-set 52909 52936) (ucs-range->char-set 52937 52964) (ucs-range->char-set 52965 52992) (ucs-range->char-set 52993 53020) (ucs-range->char-set 53021 53048) (ucs-range->char-set 53049 53076) (ucs-range->char-set 53077 53104) (ucs-range->char-set 53105 53132) (ucs-range->char-set 53133 53160) (ucs-range->char-set 53161 53188) (ucs-range->char-set 53189 53216) (ucs-range->char-set 53217 53244) (ucs-range->char-set 53245 53272) (ucs-range->char-set 53273 53300) (ucs-range->char-set 53301 53328) (ucs-range->char-set 53329 53356) (ucs-range->char-set 53357 53384) (ucs-range->char-set 53385 53412) (ucs-range->char-set 53413 53440) (ucs-range->char-set 53441 53468) (ucs-range->char-set 53469 53496) (ucs-range->char-set 53497 53524) (ucs-range->char-set 53525 53552) (ucs-range->char-set 53553 53580) (ucs-range->char-set 53581 53608) (ucs-range->char-set 53609 53636) (ucs-range->char-set 53637 53664) (ucs-range->char-set 53665 53692) (ucs-range->char-set 53693 53720) (ucs-range->char-set 53721 53748) (ucs-range->char-set 53749 53776) (ucs-range->char-set 53777 53804) (ucs-range->char-set 53805 53832) (ucs-range->char-set 53833 53860) (ucs-range->char-set 53861 53888) (ucs-range->char-set 53889 53916) (ucs-range->char-set 53917 53944) (ucs-range->char-set 53945 53972) (ucs-range->char-set 53973 54000) (ucs-range->char-set 54001 54028) (ucs-range->char-set 54029 54056) (ucs-range->char-set 54057 54084) (ucs-range->char-set 54085 54112) (ucs-range->char-set 54113 54140) (ucs-range->char-set 54141 54168) (ucs-range->char-set 54169 54196) (ucs-range->char-set 54197 54224) (ucs-range->char-set 54225 54252) (ucs-range->char-set 54253 54280) (ucs-range->char-set 54281 54308) (ucs-range->char-set 54309 54336) (ucs-range->char-set 54337 54364) (ucs-range->char-set 54365 54392) (ucs-range->char-set 54393 54420) (ucs-range->char-set 54421 54448) (ucs-range->char-set 54449 54476) (ucs-range->char-set 54477 54504) (ucs-range->char-set 54505 54532) (ucs-range->char-set 54533 54560) (ucs-range->char-set 54561 54588) (ucs-range->char-set 54589 54616) (ucs-range->char-set 54617 54644) (ucs-range->char-set 54645 54672) (ucs-range->char-set 54673 54700) (ucs-range->char-set 54701 54728) (ucs-range->char-set 54729 54756) (ucs-range->char-set 54757 54784) (ucs-range->char-set 54785 54812) (ucs-range->char-set 54813 54840) (ucs-range->char-set 54841 54868) (ucs-range->char-set 54869 54896) (ucs-range->char-set 54897 54924) (ucs-range->char-set 54925 54952) (ucs-range->char-set 54953 54980) (ucs-range->char-set 54981 55008) (ucs-range->char-set 55009 55036) (ucs-range->char-set 55037 55064) (ucs-range->char-set 55065 55092) (ucs-range->char-set 55093 55120) (ucs-range->char-set 55121 55148) (ucs-range->char-set 55149 55176) (ucs-range->char-set 55177 55204))))


(define-library (chibi char-set ascii)
  (import (chibi) (chibi iset base) (chibi char-set base))
  (export char-set:lower-case  char-set:upper-case  char-set:title-case
          char-set:letter      char-set:digit       char-set:letter+digit
          char-set:graphic     char-set:printing    char-set:whitespace
          char-set:iso-control char-set:punctuation char-set:symbol
          char-set:hex-digit   char-set:blank)
  (include "ascii.scm"))

(define (char-set . args)
  (list->char-set args))

(define (ucs-range->char-set start end . o)
  (let ((res (make-iset start (- end 1))))
    (if (and (pair? o) (pair? (cdr o)))
        (iset-union res (cadr o))
        res)))

(define char-set-copy iset-copy)

(define char-set-size iset-size)

(define (char-set-fold kons knil cset)
  (iset-fold (lambda (i acc) (kons (integer->char i) acc)) knil cset))

(define (char-set-for-each proc cset)
  (iset-for-each (lambda (i) (proc (integer->char i))) cset))

(define (list->char-set ls . o)
  (apply list->iset (map char->integer ls) o))
(define (char-set->list cset)
  (map integer->char (iset->list cset)))

(define (string->char-set str)
  (list->char-set (string->list str)))
(define (char-set->string cset)
  (list->string (char-set->list cset)))

(define (char-set-adjoin! cset . o)
  (apply iset-adjoin! cset (map char->integer o)))
(define (char-set-adjoin cset . o)
  (apply iset-adjoin cset (map char->integer o)))

(define char-set-union iset-union)
(define char-set-union! iset-union!)
(define char-set-intersection iset-intersection)
(define char-set-intersection! iset-intersection!)
(define char-set-difference iset-difference)
(define char-set-difference! iset-difference!)

(define char-set:empty (immutable-char-set (%make-iset 0 0 0 #f #f)))
(define char-set:ascii (immutable-char-set (%make-iset 0 #x7F #f #f #f)))

(cond-expand
 (full-unicode
  (define char-set:full
    (immutable-char-set
     (%make-iset 0 #xD7FF #f #f (%make-iset #xE000 #x10FFFD #f #f #f)))))
 (else
  (define char-set:full (immutable-char-set (%make-iset 0 #xFF #f #f #f)))))

(define (char-set-complement cset)
  (char-set-difference char-set:full cset))
;; char-set:lower-case
(define char-set:lower-case (immutable-char-set (%make-iset 64256 64279 16253055 (%make-iset 9424 9449 #f (%make-iset 5112 5117 #f (%make-iset 4304 4351 255086697644031 (%make-iset 97 1416 22887284938264971141014337570129179755609992399777111528780675890296546513071386367119974077546410416721559693053691423771947703344694730376769202575254659187795822093995337104723444869821736322171885794863427640450815392440474344301956790374649495763021348229578900579095778939172095805392163251055446497310782080664548038554460621185826295668252739466996314711438475834770016901314285482341826559 #f #f) #f) (%make-iset 7296 8580 353869376993705717983666309814247618351190174287678113276459176043923094227865988986914434975807859791714357516504109381611932394839876701874288198180298337191664934087293199631509530263991609647354664759117309216275933169802354453425934447010675612796307264925743345630387158608790178835119053596807714113213355697266571877429942286292795920673611252159132584840710559133279524688495103 #f #f)) (%make-iset 42787 43002 95439264324630185868515314481687070934879806080682891417820165461 (%make-iset 42561 42653 9078226948610564114271786325 (%make-iset 11312 11565 14813245791101562895267998279354650425217582479237920755663472014512630005759 #f #f) #f) (%make-iset 43824 43967 22300745198530623141535699970010679779262463 #f #f))) (%make-iset 71872 71903 #f (%make-iset 66776 66811 #f (%make-iset 66600 66639 #f (%make-iset 65345 65370 #f #f #f) #f) (%make-iset 68800 68850 #f #f #f)) (%make-iset 119834 120779 444943340548964340940982866068660715456164728186757437058474177871977147067683376302316343027410373945633715465679204654161745979246848264691892028767797102719485080582973803125834121219760150486448398965912256998809341410059616155617458881261948177837849096551872892480552662288302079 (%make-iset 93792 93823 #f #f #f) (%make-iset 125218 125251 #f #f #f))))))

;; char-set:upper-case
(define char-set:upper-case (immutable-char-set (%make-iset 42786 42997 3291009114642688429967820002509464820749822939213631915277227349 (%make-iset 7680 8187 785638520274487101740880943033910323429537180842953092253950843167132795415686008267132284209196677306151002524092736330931731967175255188976147426006357 (%make-iset 4256 4301 36009005809663 (%make-iset 880 1366 399583814439235607743018433929276414122672359131438942585227326377434536714801543103782834684532481120859187908224234736290921166870036097089437765 (%make-iset 65 590 146697655316552278449038744596633924335560211931196454814958098841138186316207211745962752862798165970965843222598226754321060902474197038539022666396029943807 #f #f) #f) (%make-iset 7312 7359 255086697644031 (%make-iset 5024 5109 #f #f #f) #f)) (%make-iset 11264 11506 7343601899367384673242818461543219328086099067985129140121553034817830911 (%make-iset 9398 9423 #f (%make-iset 8450 8579 680566031896284520156124052577604718113 #f #f) #f) (%make-iset 42560 42650 1650586712898282464877040981 #f #f))) (%make-iset 71840 71871 #f (%make-iset 66736 66771 #f (%make-iset 66560 66599 #f (%make-iset 65313 65338 #f #f #f) #f) (%make-iset 68736 68786 #f #f #f)) (%make-iset 125184 125217 #f (%make-iset 119808 120778 9979201548835330983407821194518788858685384005950863288577259825767119409708821569492393868869389710160130617212357964177254210485259643182013052386309627039473266559202968869934463502548157012678634651947849515675211415254343522399366454253278991292965520319119131951761218093820825227493375 (%make-iset 93760 93791 #f #f #f) #f) (%make-iset 127280 127369 1237940021126866573113425919 #f #f))))))

;; char-set:title-case
(define char-set:title-case (immutable-char-set (%make-iset 8072 8188 83076749736557537208897815481090303 (%make-iset 453 498 35184372088905 #f #f) #f)))

;; char-set:letter
(define char-set:letter (immutable-char-set (%make-iset 73728 74649 #f (%make-iset 44032 55203 #f (%make-iset 11264 11823 1886981212410784083928705666095883272632456313103710654885189572511501930284137370407319780920664817179896547747080111900838593355006827656846764529454777915054888058879 (%make-iset 4682 5120 175371358153141539868334697138091201974727802273784565887029876336158827425591861888771559902853985414166671275143283003445681807311 (%make-iset 710 4347 701607511345343921325031293280613295650363563584047519978490729359383077358884297550410308932270036416365768425677842382207322276287293659713177006227413612894587944924061823803906564559484667579925882867323561215321797968201943303393297853835679525560301154693380732024352514516646010125756963940775342237201353991829475787525337686827954407680805444296780523762057963137841378308027556874860821117801947295487165311713463777236520827639127339456080232314140432322994795399634425232687070095724698726984961548522873167285006463326215490150101100618504607995951410883161833051248149619166626455122820960241782396673158691992696607860025522306930417464131556922762792263471898532562125178042450781343251780404645472930242099490273526189375829842090820138753430860705557278357284053426278588683671793447768339721468940834067458756347114577234723722062630640575347016805880063763446477961429397827834853726802723865207765578343120520076069361948623471138480543509102294810113204259795824992525112720505293417369213971871396716915330186157421611383906399146133147628778972410167575791541393188458495 (%make-iset 248 705 #f (%make-iset 65 247 6129982162036307573327818073199315324831337964722192383 #f #f) #f) (%make-iset 4348 4680 #f #f #f)) (%make-iset 5743 8584 3367035357982338758268784949622510722982916612191244812161692820429431498581716593706634248384701102743990071526614800323777767740278248696525074079514063595020633018906444191487414743032272333744129304280152701119977616044923401668787129083479601456287183857518297935131388733746125291080234184827791547325211117363585662225920273183412115269430455152024239009925530804779327888691801682756235662479545761917359070480326189336127760678095859475917639050900757900684843609350343765609140046845435360248523208026904525955921437514939898590483829713806373594248687114412525927744074092335234180060489844018346640805554108473580318380863968226764585569120529898833132830545680610499629611893918690501961111799203658376893592897111788504412409743756134575645529801120357162841972255362273756553344620624601478535302888338174841229784041774449902080905195683839 (%make-iset 5121 5740 #f #f #f) (%make-iset 9398 9449 #f #f #f))) (%make-iset 19968 40956 #f (%make-iset 13312 19903 #f (%make-iset 12293 12799 418987604469675112232312121811755383006134734077347647800970521294245813332857242272920100715614784556927171741920066081763180938618621305852994894430215 #f #f) (%make-iset 19904 19967 0 #f #f)) (%make-iset 40960 42124 #f (%make-iset 40957 40959 0 #f #f) (%make-iset 42192 44031 37459511778596727480858760720167552238115001072139076542418113902677615115541885077928706295080038689350262401791311326449803427934415799670666025777339054315082570400533199907124236605223126960129700591011011954076661863729617875052837157583863503193178741006770284923346852998869657639429210156471214495795242910940362361587072383117763669927655024071278293749186899816268439854840270815702956921293895118585212038793225737641646132394620269432753279682332107877633567799287280136873047541948794844979664017035633388359770146648212238509285572607 #f #f)))) (%make-iset 67584 68903 22887284938254565749818744109383247949406967978307322349652263199852865228419417869730462952756096116221174605317764324377581230307880994958071799805856727308232796094333200600513577145799338614078042970309408534034848202935840583244996219449338508685150725537482981115643930082246807415866882383094211475269967982871416244918568287190458887553578663656428702320234122561042399762605982220531268927 (%make-iset 64467 64829 #f (%make-iset 63744 64109 #f (%make-iset 55216 55291 75557863725914197590015 #f #f) (%make-iset 64112 64466 8543948143683640329580086824678193390956197043536818577375087558533063846144990195973890412380159 #f #f)) (%make-iset 66176 66915 5783580587434428154555364829985543440241851299287575309621253419388298741108011764505350721575533745177520690683316465295070463038815470211559473797447776255685878443766898572197692160254187072416593098937345072057626394623 (%make-iset 64848 65908 24707306311927562973795307731929743709876635468550316716286562646635209317018505901886645743090075701165699335868370569943297768343227044512391661031435599163201783518292129339643124256032593358050626073246121036551216466234902521295499597808381385809829803642306045788839544115843261035043556920140009003018915969761279 #f #f) (%make-iset 67072 67431 2339377547286709837873638165922360609460209085825506813695393791198559449985557282922321722445852588225069055 #f #f))) (%make-iset 71680 72440 12129047596099288471689227831365311804146276076693352780019511307249129439735396723377194758471270365058665007119634759274170402554101182525962969347665090539000269657825686093903031244286834770249713375934826821970310148277665791 (%make-iset 70656 70855 1129878312369602537490101813810736315040285083843616760135679 (%make-iset 69248 70499 76948863590040469005144971740262077915138709871707804427711938909307679261270041663803351594606286294848609693580364667132017133774916458246925566432697057953241079384431833825622986657155549747901766097222088554076441369092143700337545607987940217487707717889589239882856842941820124069730022246919097465694185004383876577265794553266861112191605356870609308102150475588042751 #f #f) (%make-iset 71040 71466 346567846421811489474730532571280407814122807928349495310129337898894000305122821834524615784442454115672263551905705895720386559 #f #f)) (%make-iset 73440 73462 #f (%make-iset 72704 73112 979963828733976516379616055801500234789666513031835840361074903439886793726136230135343017269202321545632968341499542502911 #f #f) (%make-iset 73648 73727 1 #f #f))))) (%make-iset 120488 120779 7941630431187196263390207990109633018430881962027637362032835744559633884717312603324415 (%make-iset 100344 100351 0 (%make-iset 92736 93071 139983787731428653526245311103336199663126022956474675831605261751949134861852477643134813593034293247 (%make-iset 82944 83526 #f (%make-iset 77824 78894 #f (%make-iset 74752 75075 34175792574734561318320347298712833833643272357706444319152325445384743103294199240025209787383807 #f #f) #f) (%make-iset 92160 92728 #f #f #f)) (%make-iset 93952 94207 5300837753748491645787635300885286834009446351575649617730364394006642687 (%make-iset 93760 93823 #f #f #f) (%make-iset 94208 100343 #f #f #f))) (%make-iset 110960 111355 #f (%make-iset 101632 101640 #f (%make-iset 100352 101589 #f #f #f) (%make-iset 110592 110959 2201759651238793353935978839989206105180151758945528329367307032632076306562609289056077994868130232108318719 #f #f)) (%make-iset 119808 120145 277984795434575462634999469953131284498641899033547154778380155978829522737042218261318709224765652991 (%make-iset 113664 113822 388189245597642319451802680075071113378809249791 #f #f) (%make-iset 120146 120485 #f #f #f)))) (%make-iset 173790 173823 0 (%make-iset 124928 125259 4682083582738634900609771787834420919013905609276306557600504679623182643672439903440547830539747327 (%make-iset 123136 123214 302236030596063074189311 (%make-iset 122880 122922 8641373536127 #f #f) (%make-iset 123584 123627 #f #f #f)) (%make-iset 127280 127369 1237940021126866573113425919 (%make-iset 126464 126651 392317335668304952608886359756720284316824500695881220079 #f #f) (%make-iset 131072 173789 #f #f #f))) (%make-iset 183970 183983 0 (%make-iset 177984 178207 6739986666787659948666753771754907668409286105635143120275902562303 (%make-iset 173824 177972 #f #f #f) (%make-iset 178208 183969 #f #f #f)) (%make-iset 194560 195101 #f (%make-iset 183984 191456 #f #f #f) (%make-iset 196608 201546 #f #f #f))))))))

;; char-set:punctuation
(define char-set:punctuation (immutable-char-set (%make-iset 44011 44011 #f (%make-iset 6468 6469 #f (%make-iset 3572 3675 15214283082817323578510236712961 (%make-iset 2039 2142 10141204806548057579655195000839 (%make-iset 894 903 513 (%make-iset 33 191 390352614522577604377617624462440613025570388983 #f #f) (%make-iset 1370 1805 177440029682739492195629626423414285791075425806584367987188710887245779556727828964224741026149370230681856791701409903272452423743 #f #f)) (%make-iset 2557 2800 14134776518227074636666380005943348129278327166574783410780463730901647361 (%make-iset 2404 2416 4099 #f #f) (%make-iset 3191 3204 8193 #f #f))) (%make-iset 5120 5120 #f (%make-iset 4347 4347 #f (%make-iset 3844 4175 8612299728833109452216727519275634166367255279803428156814546022481552546661143084834195942383124479 #f #f) (%make-iset 4960 4968 #f #f #f)) (%make-iset 6100 6154 36011204832919671 (%make-iset 5742 5942 2410407066388485413313240885582799724938834943561245166403585 #f #f) #f))) (%make-iset 10627 10749 7975367975289779630837864365545226239 (%make-iset 7164 7379 52681756409358971006475467946070306489686807156907791211684691983 (%make-iset 6816 6829 16255 (%make-iset 6686 6687 #f #f #f) (%make-iset 7002 7008 #f #f #f)) (%make-iset 8968 9002 25769803791 (%make-iset 8208 8334 127607834706674478748244504138880122879 #f #f) (%make-iset 10088 10223 87027215340059722591700904977272299077631 #f #f))) (%make-iset 42238 42239 #f (%make-iset 11776 11858 6044629097932408385175551 (%make-iset 11513 11632 664613997892457936451903530140172399 #f #f) (%make-iset 12289 12539 1809251394333065553493296641491499378872794969502476229475819322195851214727 #f #f)) (%make-iset 43124 43761 855460879115989469712274024898745681784726670116734735081144902996232559536857409148837563689361766642268455105314774829212585106777411750165469842705887573520069114837090257203067989633531919 (%make-iset 42509 42743 54351252480975689826048702415431575448442147475312362296571857733681159 #f #f) #f)))) (%make-iset 71484 71486 #f (%make-iset 67871 67903 4294967297 (%make-iset 65792 65794 #f (%make-iset 65040 65131 4037812089938908849547248639 (%make-iset 64830 64831 #f #f #f) (%make-iset 65281 65381 2521683860030948918624327334903 #f #f)) (%make-iset 66927 66927 #f (%make-iset 66463 66512 562949953421313 #f #f) (%make-iset 67671 67671 #f #f #f))) (%make-iset 69703 70313 4249103942534136789516705652419774796587782123933481739464416821113165103188321857361644913417874677081550277884371832940892553101127100679856727609170745842644615253353548055914217599 (%make-iset 69293 69293 #f (%make-iset 68176 68508 16404380435872589432793766705135203812233573933707706872919585037667841040900352577131267021439238655 #f #f) (%make-iset 69461 69465 #f #f #f)) (%make-iset 71105 71276 5985579955691094878071637801633780729252894115627007 (%make-iset 70731 70854 10633823966279326983230456482243117087 #f #f) #f))) (%make-iset 92782 92783 #f (%make-iset 72769 72817 422212465066015 (%make-iset 72004 72006 #f (%make-iset 71739 71739 #f #f #f) (%make-iset 72162 72354 12333524112888673532067976877031085989905788216127843729409 #f #f)) (%make-iset 73727 73727 #f (%make-iset 73463 73464 #f #f #f) (%make-iset 74864 74868 #f #f #f))) (%make-iset 113823 113823 #f (%make-iset 93847 93850 #f (%make-iset 92917 92996 606750306072454571753473 #f #f) (%make-iset 94178 94178 #f #f #f)) (%make-iset 125278 125279 #f (%make-iset 121479 121483 #f #f #f) #f)))))))

;; char-set:symbol
(define char-set:symbol (immutable-char-set (%make-iset 12688 12991 994646472817765799763495797754640258220159467383567101207357820271567867180691654508483 (%make-iset 5741 5741 #f (%make-iset 3059 3066 #f (%make-iset 1758 1790 6442452993 (%make-iset 1154 1154 #f (%make-iset 706 1014 521481209941628438084722096232800884555162981189081790621504207040293760564100563907364454415 (%make-iset 36 247 3291009115408659855127328282852688335858940725263447471358476417 #f #f) #f) (%make-iset 1421 1551 2145373985196854218866744595292476145671 #f #f)) (%make-iset 2546 2555 771 (%make-iset 2038 2047 769 #f #f) (%make-iset 2801 2928 170141183460469231731687303715884105729 #f #f))) (%make-iset 3841 3896 47287798208921607 (%make-iset 3407 3449 4398046511105 (%make-iset 3199 3199 #f #f #f) (%make-iset 3647 3647 #f #f #f)) (%make-iset 4254 4255 #f (%make-iset 4030 4056 126058239 #f #f) (%make-iset 5008 5017 #f #f #f)))) (%make-iset 9472 10087 #f (%make-iset 7009 7036 267912191 (%make-iset 6464 6464 #f (%make-iset 6107 6107 #f #f #f) (%make-iset 6622 6655 #f #f #f)) (%make-iset 8592 8967 #f (%make-iset 8125 8591 17862788488288834957320686410958146518834882629703662689457631968523144179738811492739595467631686246322310040187269468445031461410243543069 #f #f) (%make-iset 8972 9471 780437137578998057845396725198413489528559879748138256739680964964447337444984473322466696354773663108767878203124465226586050111746436730191871 #f #f))) (%make-iset 10750 11123 #f (%make-iset 10224 10626 #f (%make-iset 10132 10223 4835703276769666838560767 #f #f) (%make-iset 10649 10749 633825299975764120195529965567 #f #f)) (%make-iset 11493 11498 #f (%make-iset 11126 11263 348449143727040986586495598010126353563647 #f #f) (%make-iset 11856 12444 1519597986650754257267727489298751896090282154421411377217581357937730647911548469687721828563943632274327638030901128998131571341096875963145178876601089332553757864357093441539 #f #f))))) (%make-iset 71487 71487 #f (%make-iset 64297 64297 #f (%make-iset 42752 42890 522673715590561479879743397015208866086911 (%make-iset 19904 19967 #f (%make-iset 12992 13311 #f #f #f) (%make-iset 42128 42182 #f #f #f)) (%make-iset 43639 43641 #f (%make-iset 43048 43065 245775 #f #f) (%make-iset 43867 43883 98305 #f #f))) (%make-iset 65504 65533 805339007 (%make-iset 65020 65129 796084576943328064139929612976131 (%make-iset 64434 64449 #f #f #f) (%make-iset 65284 65374 1547425050547877224499904641 #f #f)) (%make-iset 67703 67704 #f (%make-iset 65847 66044 401734511064736150903948875451877267451708131866024706310655 #f #f) (%make-iset 68296 68296 #f #f #f)))) (%make-iset 121399 121478 1057805462462383590998031 (%make-iset 118784 119365 8903894453031763226164682950375691501926942562513420334034182902046561102655861722202313153585672295538116768616297201430994412729251427960653880031895069202084170385141530623 (%make-iset 92988 92997 527 (%make-iset 73685 73713 #f #f #f) (%make-iset 113820 113820 #f #f #f)) (%make-iset 120513 120831 463168363851011130091785795673740600836767278013411671357985905734243019915265 (%make-iset 119552 119638 #f #f #f) (%make-iset 120832 121343 #f #f #f))) (%make-iset 126704 126705 #f (%make-iset 123647 123647 #f (%make-iset 123215 123215 #f #f #f) (%make-iset 126124 126254 1361129467683753853853498429727072845841 #f #f)) (%make-iset 127744 128727 #f (%make-iset 126976 127589 66923435848449520561872831652599431289448618669932687931757021603387200183513455083701749538297393227813626429413144495791734667559393462525515277714480404638844354082830588746888380415 #f #f) (%make-iset 128736 129994 9925777620949171960340658008280684297457039992464063994099317723966361011338590828312964124827475737928311999622519470623485876432710514825865764706522442988059718235454884809834410270926503441573806780806285385447513658060201828304459750125262505360366372605107841440375991737220680591608098201303438673867062542425370103497325051563265419116747628212365759869081739546347905023 #f #f))))))))

;; char-set:blank
(define char-set:blank (immutable-char-set (%make-iset 5760 5760 #f (%make-iset 160 160 #f (%make-iset 9 32 8388609 #f #f) #f) (%make-iset 12288 12288 #f (%make-iset 8192 8287 39614081257132309534260332543 #f #f) #f))))

;; char-set:whitespace
(define char-set:whitespace (immutable-char-set (%make-iset 5760 5760 #f (%make-iset 160 160 #f (%make-iset 9 133 21267647932558653966460912964493901855 #f #f) #f) (%make-iset 12288 12288 #f (%make-iset 8192 8287 39614081257132312832795215871 #f #f) #f))))

;; char-set:digit
(define char-set:digit (immutable-char-set (%make-iset 66720 66729 #f (%make-iset 6608 6617 #f (%make-iset 2406 3881 2088571161670495152870603613773632013905882285922748744142705593254390818318357331195163165688762717573196191694721634141284507822074404237950632351194253443338221100251829324587958567340176572531256437724477962020286729316609007823056573991956917606602799969471953511414751680873262969402052815928736994258639922750546801548893686346998208607418105240981129887982908516154418831792397178702030090099899895596423897954730407437607496771843392511 (%make-iset 1776 1785 #f (%make-iset 1632 1641 #f (%make-iset 48 57 #f #f #f) #f) (%make-iset 1984 1993 #f #f #f)) (%make-iset 6112 6169 287948901175002111 (%make-iset 4160 4249 1236731113465765645724419071 #f #f) (%make-iset 6470 6479 #f #f #f))) (%make-iset 43216 43273 287948901175002111 (%make-iset 7232 7257 67044351 (%make-iset 6992 7097 81050410252092417358195461194751 (%make-iset 6784 6809 67044351 #f #f) #f) (%make-iset 42528 42537 #f #f #f)) (%make-iset 44016 44025 #f (%make-iset 43472 43609 348108861360120048123032223407092631864319 #f #f) (%make-iset 65296 65305 #f #f #f)))) (%make-iset 72784 72793 #f (%make-iset 70384 70393 #f (%make-iset 69872 69951 1207745227993911763403775 (%make-iset 69734 69743 #f (%make-iset 68912 68921 #f #f #f) #f) (%make-iset 70096 70105 #f #f #f)) (%make-iset 71248 71481 27580025440495104509944356434021087490850485025387669634866738077107199 (%make-iset 70736 70873 348108861360120048123032223402698880320511 #f #f) (%make-iset 71904 72025 5311719686281128663986697744792159231 #f #f))) (%make-iset 123200 123209 #f (%make-iset 93008 93017 #f (%make-iset 92768 92777 #f (%make-iset 73040 73129 1236731113465765645724419071 #f #f) #f) (%make-iset 120782 120831 #f #f #f)) (%make-iset 125264 125273 #f (%make-iset 123632 123641 #f #f #f) (%make-iset 130032 130041 #f #f #f)))))))

;; char-set:letter+digit
(define char-set:letter+digit (immutable-char-set (%make-iset 73648 73727 1 (%make-iset 55216 55291 75557863725914197590015 (%make-iset 11264 11823 1886981212410784083928705666095883272632456313103710654885189572511501930284137370407319780920664817179896547747080111900838593355006827656846764529454777915054888058879 (%make-iset 4682 5120 175371358153141539868334697138091201974727802273784565887029876336158827425591861888771559902853985414166671275143283003445681807311 (%make-iset 710 4347 701607511345343921325031293285036737552313014249129577179713733497028661926071532849455010083188420006022421932128803337913653771636388624993711446305067180421060963655119373222189272961184068886899633373554741564778669636368856093589844366158101728786435336293764058093291763418979707412043650921213055302872789003750780577851396425649264393444359090760329269898256389309825983350245284336093100971988658026174420647486143326328076480437557565851669183768070539314890263821744143387110981714944776554548080638831897423303567005272186614313179464918458333545481225096345937715970225572284364451719098638712239902992339806396206802159899680788734660848941151984278771496568171781533610498739037672416723543236880617166428977909499207577962773953935235285669824158814173196431549842531495721252152564578613335565263697454178494502231745306094088128473637605309154922650239769678927052837333570773738740687737682733281608678822669689176315932902831879546420580581987202179604199442568942811666986778064767178555433073142876269219090056398713522294204724558088720824996033136716644467738003002888191 (%make-iset 248 705 #f (%make-iset 48 247 803469021942422906251223770490380658256293129712067200025599 #f #f) #f) (%make-iset 4348 4680 #f #f #f)) (%make-iset 5743 8584 3367035357982338758268784949622510722982916612191244812161692820429431498581716593706634248384701102743990071526614800323777767740278248696525074079514063595020633018906444191487414743032272333744129304280152701119977616044923401668787129083479601456287183857518297935131388733746125291080234184827791547325211117363585662225920273183412115269430455152024239009925530804779327888691801682756235662480693983576410994531177529387149461802069970729634476482784914634036339340562377015412485084058698897320327989538716999837534850261228337322110644360519560809149554754707165964272429644469971431171326968401697797110644144311655335924576429277145510701393680471565889930079450999612697595619341945133937402118160691419877875456952185861503290429678138749867458028240711298568652093682139555438366386674961452020711566635409862196587346721471815891806479843327 (%make-iset 5121 5740 #f #f #f) (%make-iset 9398 9449 #f #f #f))) (%make-iset 40957 40959 0 (%make-iset 19904 19967 0 (%make-iset 13312 19903 #f (%make-iset 12293 12799 418987604469675112232312121811755383006134734077347647800970521294245813332857242272920100715614784556927171741920066081763180938618621305852994894430215 #f #f) #f) (%make-iset 19968 40956 #f #f #f)) (%make-iset 42192 44031 1226312037095921067540873249696125157732687303619108564121109639949981103634081556942946939140277538350510636530797621935747780368713902592824641178321450960006902220495570008563915788942379205079421440122167818368902381354795574462001344104233832810986860819307432446673636526486701304815740220882590469586874922631415361267248605890106031740628028227046603049736480984593542786222754632833107784189285148373005396399841299981436658495656924916320180938354015596302596987563501153722197340317298015627318901338856652182726161606020902146998710120218623 (%make-iset 40960 42124 #f #f #f) (%make-iset 44032 55203 #f #f #f)))) (%make-iset 70656 70855 1129878312369602537490101813810737551771398549609262484553727 (%make-iset 66176 66915 5783580587434428154555364829985543440241851299287575309680163996179565171823086079940394042428317107123413307843790999065078909055160200980665120157566564695549802815966474581299030479291251630264346200121665873642302472191 (%make-iset 64467 64829 #f (%make-iset 64112 64466 8543948143683640329580086824678193390956197043536818577375087558533063846144990195973890412380159 (%make-iset 63744 64109 #f #f #f) #f) (%make-iset 64848 65908 24707306311927562973795307731929743709876635468550316716286562646635209317018505901886645743090075701165699335868370569943297768343227044512391661031435599163201783518292129339643124999588608312456475105204376505979855110010014504421875265772855147603821543648381608482284424295970829695103160130440035008916382042554367 #f #f)) (%make-iset 67584 68921 5993928165200000729290308920001083082576847341587927925842461097663037244330338752133997347590597605737647219240442060635157365165018379744170231264203263029768113730890110144017096347154335784723870575042920134214533925911895718155593840628866290440177627285834102009654969354882609461783254174323557180822731174564605791964206027276205503269528834393612903427731478081568316899762041796912072485764415 (%make-iset 67072 67431 2339377547286709837873638165922360609460209085825506813695393791198559449985557282922321722445852588225069055 #f #f) (%make-iset 69248 70499 76948863590040469005144971740263032799340143931645394288838262570479031585755203100836865234311410972138120833615813704113843365310437095359939338705835846998334606291229527259659092785190174281851724901836758117056118904225369779725030342341211810458681479084048346688606278118033814824005834527307005823491884312779402119273753193761131135248581757721718387151007836788490239 #f #f))) (%make-iset 71680 72440 12129047596099288471689227831365311804146276076693352780019511307249129439735396723377194758471270365058665007119634759274170545757780635519319681864130904383933882085975160638817613268773998724871607756219531117473205194942578687 (%make-iset 71040 71466 346567846421811489474730532573465522551869898942639602515540790132970357566392122899313807788286976544480556470367246162063261695 (%make-iset 70856 70873 261888 #f #f) (%make-iset 71467 71481 32736 #f #f)) (%make-iset 73113 73129 130944 (%make-iset 72704 73112 979963828733976516522819735254493591502182978845680746393477612419327198363804283278215460032785098722036288833198646885887 #f #f) (%make-iset 73440 73462 #f #f #f))))) (%make-iset 120488 120831 35835915874844843481862377449946273895690436668853644560088136612804115782023798523520115807522283061247 (%make-iset 94208 100343 #f (%make-iset 92160 92728 #f (%make-iset 77824 78894 #f (%make-iset 74752 75075 34175792574734561318320347298712833833643272357706444319152325445384743103294199240025209787383807 (%make-iset 73728 74649 #f #f #f) #f) (%make-iset 82944 83526 #f #f #f)) (%make-iset 93760 93823 #f (%make-iset 92736 93071 139983787731428661289332329645995729157694502177020931672160716245459799864212224373209363943536984063 #f #f) (%make-iset 93952 94207 5300837753748491645787635300885286834009446351575649617730364394006642687 #f #f))) (%make-iset 110960 111355 #f (%make-iset 101632 101640 #f (%make-iset 100352 101589 #f (%make-iset 100344 100351 0 #f #f) #f) (%make-iset 110592 110959 2201759651238793353935978839989206105180151758945528329367307032632076306562609289056077994868130232108318719 #f #f)) (%make-iset 119808 120145 277984795434575462634999469953131284498641899033547154778380155978829522737042218261318709224765652991 (%make-iset 113664 113822 388189245597642319451802680075071113378809249791 #f #f) (%make-iset 120146 120485 #f #f #f)))) (%make-iset 173790 173823 0 (%make-iset 126464 126651 392317335668304952608886359756720284316824500695881220079 (%make-iset 123584 123641 287966493361045503 (%make-iset 123136 123214 321107049783467945492479 (%make-iset 122880 122922 8641373536127 #f #f) #f) (%make-iset 124928 125273 143208361536576095347417075585632740453321722885049680944225653647552065946225212885193295273883919712255 #f #f)) (%make-iset 130032 130041 #f (%make-iset 127280 127369 1237940021126866573113425919 #f #f) (%make-iset 131072 173789 #f #f #f))) (%make-iset 183970 183983 0 (%make-iset 177984 178207 6739986666787659948666753771754907668409286105635143120275902562303 (%make-iset 173824 177972 #f #f #f) (%make-iset 178208 183969 #f #f #f)) (%make-iset 194560 195101 #f (%make-iset 183984 191456 #f #f #f) (%make-iset 196608 201546 #f #f #f))))))))

;; char-set:hex-digit
(define char-set:hex-digit (immutable-char-set (%make-iset 48 102 35465847073801215 #f #f)))

;; char-set:iso-control
(define char-set:iso-control (immutable-char-set (%make-iset 0 159 1461501637160761734743215600984595715944343404543 #f #f)))

;; char-set:graphic
(define char-set:graphic (immutable-char-set (%make-iset 71680 72440 12129047596099288471689227985373955882936478938241399805618182562237619198624379309670199854652352860465249331584918315770795606344464854369703857841276727779926948487630207054953758776109729070470213324736565298720109485698842623 (%make-iset 12293 12799 418987606030549387367594527373599807909543403577262868303245341779587400223793325083575935756618085036130805650556928808320932681808597112080255674220543 (%make-iset 9003 9397 80695307487762091046544861445680552597065553504995368584475953530849060932379449769070936146626014467603375549092724735 (%make-iset 4682 5119 175371358153141539868334697138231049317943616346875083730013098062167354292784136982493006299912145623972016717379408812166978953167 (%make-iset 191 767 #f (%make-iset 48 190 1215446068961133357718048828666669009207295 (%make-iset 33 47 #f #f #f) #f) (%make-iset 4304 4680 #f (%make-iset 837 4303 59974454434182532169859916382112511200130958697007503554262355183645647793598949377682516493667437923007427361162146335088305369509613116197890312982343248446873327788074346913645983245974540173325131173355062425787106492250118042419078658225390109790569126015338217902821936234701966060589729655153946272240376421489722833812843753374671752960799558967080222679291599590970969275517936885607281950757495834475947776911483174729895051496732117595864585503072339290263342019866656863327547873142700295219286192408918857375464627876188783109999288049082375685010784932525133532603417669654850685834963288668075665940656917034328341833756393789262218171406347858189123810977150389869073820261007490538842324573453517898132002756296824616540962221741369700687567203709418178974900248486333508599097762439019714345884123250284102532580517062859017605271547701358717135852043420021746256623051902392206027867430282555017576367026167536147634770375548092920289554757969682138566382695156519600549822042227193291435051048402318548574438335917540245505 #f #f) #f)) (%make-iset 8586 8591 3 (%make-iset 5761 8584 12844220573357920743703553228504741980325751284216587726781422127253281562375543599103966896871343020375829895974694551887678840316398582189601943285194282909966981707893808902666518089590015539865117379685061819660930351399943612028532154915285303544940547630002681944958985870880326608253395878332278563164458044603052848444557687198869767671241061363802592479728399115959500132272988816033548016710373534017633788713264956561177639802208470916535835522972826529183317417982131297106313800192842495772672356726235996089065724462410983010176131420305174934862477845522133159362661461416435514993309685073367387640364533729132676010424506638427320326158979284079129606233063458249142186606404367769929254519970588695774849326276537625021898243467486236927963361095045865056424506612281761446583310923195365972310351044867395039467136915865067960926207 (%make-iset 5120 5759 #f #f #f) #f) (%make-iset 8968 9002 #f (%make-iset 8592 8967 #f #f #f) #f))) (%make-iset 10750 11123 #f (%make-iset 10088 10223 87112285931760246646623899484940476104703 (%make-iset 9472 10087 #f (%make-iset 9398 9449 #f #f #f) #f) (%make-iset 10627 10749 #f (%make-iset 10224 10626 #f #f #f) #f)) (%make-iset 11824 11858 #f (%make-iset 11264 11823 3773962424821541352241553013992918144065918717465803389708073357142126389225107781719131140341939080545590717440503200418501905217430712860489709121948925827947184521215 (%make-iset 11126 11263 348449143727040986586495598010126353563647 #f #f) #f) (%make-iset 12289 12292 #f (%make-iset 11859 12284 86624774150589392456230137798312549379915298566080048889224101706101721230828234832695031726011516877687483029771255189390491648 #f #f) #f)))) (%make-iset 64467 64831 #f (%make-iset 42192 42539 #f (%make-iset 40957 40959 0 (%make-iset 12992 40956 #f (%make-iset 12800 12991 191561942607887998433433179118716749650695200769572863 #f #f) #f) (%make-iset 42128 42191 36028797018963967 (%make-iset 40960 42124 #f #f #f) #f)) (%make-iset 55216 55291 75557863725914197590015 (%make-iset 44032 55203 #f (%make-iset 42560 44031 2039744885300701967380788869810137116530743632188263859215935357859350230522117840256574059101395495159041886705878311481585634790213371830890708624108181863881758088754636831636731095473034302414935793693748647393155985431047310355444857924546463125621390338569852392255727610172691218466286306306072529586242931924633871846979795910394331961614999870579765509694242374050732945798149083553005480248845474672032101049443137144558599754743807 #f #f) #f) (%make-iset 64112 64466 559936185544451052639360570142111069515343919736656351240203305629542316848793152649014907269841682431 (%make-iset 63744 64109 #f #f #f) #f))) (%make-iset 69248 70499 76948863590040469005144971740263032799340143931645394289233579471469872637224920574897252997903446296677234589246833796642649857642601273004997210888415738695621029554820215996621291398282028165694932018608258905952824024935829987195331873067833808862509874893671707839241889210243356313957942845010655184710396639630282360817411708846108349067713936575867087655189676195577855 (%make-iset 66176 66927 11850556623653145908478190378124225009206278969194006593399371616221299748631119399029147004368405474322148214158758350982674075430842744979186328703758147415527737299423276215609731347381211724488311482597301305274361870024703 (%make-iset 65909 66044 87112285931757770766545328751878395133936 (%make-iset 64848 65908 24707306311927565711499799092842749774014471751303086659319605259203968427682889349709702706342170192446017222254590367237187741038281354388781066220198317953972091472727637273566418199072511052074254187067684745097639277784211416469632732296911495940122572454701590984291284166349092358466881661964830798265908799209471 #f #f) #f) (%make-iset 67584 68921 5993928165200000729290308920001083082576847341587927925842461097663037244330338752133997347590597605737647219240442060635157631064362194197604483656703599583162849954055478069325222580390508668953054212383448333426549086333624531567194416803575671065170924429768506337928484674313376734696887120000023450957940472544727496250463345917094819678226215107563685497562778643234051179373511076303844413537599 (%make-iset 67072 67431 2339377547286709837873638165922360609460209085825506813695393791198559449985557282922321722445852588225069055 #f #f) #f)) (%make-iset 71040 71466 346567846421811489474730532573465522551869898942639602515761619056121076336374535833422279284186663302084896705464045251403448319 (%make-iset 70856 70873 261888 (%make-iset 70656 70855 1531612823434350106375592336896041820913528324989656596742143 #f #f) #f) (%make-iset 71467 71487 1998816 #f #f))))) (%make-iset 120488 120831 35835915874844843497403728819336284991598416908354067736504587342730232796611684254438183290743688265727 (%make-iset 93952 94207 5300945593535160248346813968945634912532140900153339780020288808447639551 (%make-iset 74752 75075 34175792574734561318320347298712833833643272357706444319152325606345945717873855724470595993206783 (%make-iset 73440 73464 #f (%make-iset 73113 73129 130944 (%make-iset 72704 73112 979963828733976516522819735254493591502182978845680746393477612419327198363804283278215475609675674327662872557257626746367 #f #f) #f) (%make-iset 73727 74649 #f (%make-iset 73648 73726 73786976157399252993 #f #f) #f)) (%make-iset 92160 92728 #f (%make-iset 82944 83526 #f (%make-iset 77824 78894 #f #f #f) #f) (%make-iset 93760 93850 2321137592106832089145409535 (%make-iset 92736 93071 139983787731428661289338003232211933359637062971689268366283734165507171506071549522497847272033746943 #f #f) #f))) (%make-iset 110960 111355 #f (%make-iset 100352 101589 #f (%make-iset 100344 100351 0 (%make-iset 94208 100343 #f #f #f) #f) (%make-iset 110592 110959 2201759651238793353935978839989206105180151758945528329367307032632076306562609289056077994868130232108318719 (%make-iset 101632 101640 #f #f #f) #f)) (%make-iset 119552 119638 #f (%make-iset 118784 119365 8903894453031763226164682950375691501926942562513420334034182902046561102655861722202313153585672295538116768616297201430994412729251427960653880031895069202084170385141530623 (%make-iset 113664 113823 1210283916596275210941375398477980311935271305215 #f #f) #f) (%make-iset 120146 120485 #f (%make-iset 119808 120145 277984795434575462634999469953131284498641899033547154778380155978829522737042218261318709224765652991 #f #f) #f)))) (%make-iset 127744 128727 #f (%make-iset 124928 125279 7023704209506790630179879761491893562843016690389893052156992171808320694211679637095248954604260979376127 (%make-iset 122880 122922 8641373536127 (%make-iset 121399 121483 38534505870515888006889487 (%make-iset 120832 121343 #f #f #f) #f) (%make-iset 123584 123647 9511338530215821311 (%make-iset 123136 123215 925569959590782532845567 #f #f) #f)) (%make-iset 126976 127279 32592575620403208698341248887045371744387653189747268689130004987970774809154353846447767551 (%make-iset 126464 126705 5300541194335153381067228170533708156368811447347141191189319299759079407 (%make-iset 126124 126254 1361129467683753853853498429727072845841 #f #f) #f) (%make-iset 127370 127589 1658669802116112894150008869413016448193125602756192507330371256319 (%make-iset 127280 127369 #f #f #f) #f))) (%make-iset 178208 183969 #f (%make-iset 173790 173823 0 (%make-iset 131072 173789 #f (%make-iset 128736 130041 1395564823857300240922446466664555865028887665983335044524363252017914154373973301004635972404022510017571028632990405531056190531062782501742259967422408421904571830067909218330125344715810304357797273628378989117428119550443841642815730889863001220726100371562061441349510755262818835534689304533007067005401304757757932225110105305219425344132172538339933651336053275812227221363033527754751 #f #f) #f) (%make-iset 177984 178207 6739986666787659948666753771754907668409286105635143120275902562303 (%make-iset 173824 177972 #f #f #f) #f)) (%make-iset 194560 195101 #f (%make-iset 183984 191456 #f (%make-iset 183970 183983 0 #f #f) #f) (%make-iset 196608 201546 #f #f #f))))))))

;; char-set:printing
(define char-set:printing (immutable-char-set (%make-iset 73648 73726 73786976157399252993 (%make-iset 40957 40959 0 (%make-iset 8192 8287 79228162514264201254102042623 (%make-iset 4304 4680 #f (%make-iset 161 190 117043199 (%make-iset 160 160 #f (%make-iset 9 133 21599954931504882934686864729547210783 #f #f) #f) (%make-iset 837 4303 59974454434182532169859916382112511200130958697007503554262355183645647793598949377682516493667437923007427361162146335088305369509613116197890312982343248446873327788074346913645983245974540173325131173355062425787106492250118042419078658225390109790569126015338217902821936234701966060589729655153946272240376421489722833812843753374671752960799558967080222679291599590970969275517936885607281950757495834475947776911483174729895051496732117595864585503072339290263342019866656863327547873142700295219286192408918857375464627876188783109999288049082375685010784932525133532603417669654850685834963288668075665940656917034328341833756393789262218171406347858189123810977150389869073820261007490538842324573453517898132002756296824616540962221741369700687567203709418178974900248486333508599097762439019714345884123250284102532580517062859017605271547701358717135852043420021746256623051902392206027867430282555017576367026167536147634770375548092920289554757969682138566382695156519600549822042227193291435051048402318548574438335917540245505 (%make-iset 191 767 #f #f #f) #f)) (%make-iset 5760 5760 #f (%make-iset 5120 5759 #f (%make-iset 4682 5119 175371358153141539868334697138231049317943616346875083730013098062167354292784136982493006299912145623972016717379408812166978953167 #f #f) #f) (%make-iset 5761 8191 317998695923525198570228967423572822521434991261588284764071767201569992401390165584581045178704204301490054127468062408631708885943108667358225677011972469234926954246777340386522121844100246550392068253339466603215320800359061129339526839391203791335626963675550553378271951947350144624705803113898933028524663645729092862152082712598552250872193914071886654732452539699573881158691844945990619913263893450522980774083827664502967353722865217528197164410019518030773718119076194620420836269702745085895706078234670626226920490926006731826394605220601099116697037024613978040566925912206459014586044620174721583737664454029073402692943611855259335657924248635129515609663748275260019810042359390603653486116726997348959627427971071 #f #f))) (%make-iset 10102 10131 0 (%make-iset 9280 9471 1496577676626844588240568316941316670606575327512575 (%make-iset 8592 9254 #f (%make-iset 8305 8591 13598682245579220086383817489175160595079972807244278978321251106567328793875043089921 #f #f) #f) (%make-iset 9472 10101 #f #f #f)) (%make-iset 11904 12991 101201126653471405168551216586934141089629089514047441366871545389923157825027550043170695180534984277528398078305989977323866645665899006226360749475593738789952109427102360326204918479078287989993880535456896636095183507274125308899710052513115391193329498777546143052392166201920346619858582232973056581764685992002846719 (%make-iset 11126 11858 45184223339331479951185741475274045267603474397630752840648161876172628960516100181183283665906209584123788828086660026723286846290656013213461581462303713490545644203395787287117886857108389922857050643280606935023353855 (%make-iset 10132 11123 #f #f #f) #f) (%make-iset 12992 40956 #f #f #f)))) (%make-iset 64848 66044 2152309932048157654930929365181599324758100597226381009663514362225632576812222264108423250922765912357141089525050730139215717765333942812479968578874921158660293453653391590837844249939309570314068383407658741660310544818207931112497705281430764907804091873070120236360422428709099556058170789835669595308841297000004408200770389536066493670202892269381484543 (%make-iset 44032 55203 #f (%make-iset 42192 42539 #f (%make-iset 42128 42191 36028797018963967 (%make-iset 40960 42124 #f #f #f) #f) (%make-iset 42560 44031 2039744885300701967380788869810137116530743632188263859215935357859350230522117840256574059101395495159041886705878311481585634790213371830890708624108181863881758088754636831636731095473034302414935793693748647393155985431047310355444857924546463125621390338569852392255727610172691218466286306306072529586242931924633871846979795910394331961614999870579765509694242374050732945798149083553005480248845474672032101049443137144558599754743807 #f #f)) (%make-iset 64112 64466 559936185544451052639360570142111069515343919736656351240203305629542316848793152649014907269841682431 (%make-iset 63744 64109 #f (%make-iset 55216 55291 75557863725914197590015 #f #f) #f) (%make-iset 64467 64831 #f #f #f))) (%make-iset 70656 70873 420839322147721879631239744031379287691155611164113039708003500031 (%make-iset 67584 68921 5993928165200000729290308920001083082576847341587927925842461097663037244330338752133997347590597605737647219240442060635157631064362194197604483656703599583162849954055478069325222580390508668953054212383448333426549086333624531567194416803575671065170924429768506337928484674313376734696887120000023450957940472544727496250463345917094819678226215107563685497562778643234051179373511076303844413537599 (%make-iset 67072 67431 2339377547286709837873638165922360609460209085825506813695393791198559449985557282922321722445852588225069055 (%make-iset 66176 66927 11850556623653145908478190378124225009206278969194006593399371616221299748631119399029147004368405474322148214158758350982674075430842744979186328703758147415527737299423276215609731347381211724488311482597301305274361870024703 #f #f) #f) (%make-iset 69248 70499 76948863590040469005144971740263032799340143931645394289233579471469872637224920574897252997903446296677234589246833796642649857642601273004997210888415738695621029554820215996621291398282028165694932018608258905952824024935829987195331873067833808862509874893671707839241889210243356313957942845010655184710396639630282360817411708846108349067713936575867087655189676195577855 #f #f)) (%make-iset 72704 73129 173123605518369359058835719009821596572172747795128525636764497174436003182493469539750430159111766193840294997681874517211741695 (%make-iset 71680 72440 12129047596099288471689227985373955882936478938241399805618182562237619198624379309670199854652352860465249331584918315770795606344464854369703857841276727779926948487630207054953758776109729070470213324736565298720109485698842623 (%make-iset 71040 71487 692757414983320256106875415467050322936523228026697465579097179937343419118927509542319518736210766053452690926025310692658102684090367 #f #f) #f) (%make-iset 73440 73464 #f #f #f))))) (%make-iset 120782 121343 #f (%make-iset 100352 101589 #f (%make-iset 92160 92728 #f (%make-iset 77824 78894 #f (%make-iset 74752 75075 34175792574734561318320347298712833833643272357706444319152325606345945717873855724470595993206783 (%make-iset 73727 74649 #f #f #f) #f) (%make-iset 82944 83526 #f #f #f)) (%make-iset 94208 100343 #f (%make-iset 93760 94207 33274574784369932869560954738424869031804371793173578871583216373135890848662921739630567712991033888744523960811913145058414559231 (%make-iset 92736 93071 139983787731428661289338003232211933359637062971689268366283734165507171506071549522497847272033746943 #f #f) #f) (%make-iset 100344 100351 0 #f #f))) (%make-iset 118784 119365 8903894453031763226164682950375691501926942562513420334034182902046561102655861722202313153585672295538116768616297201430994412729251427960653880031895069202084170385141530623 (%make-iset 110960 111355 #f (%make-iset 110592 110959 2201759651238793353935978839989206105180151758945528329367307032632076306562609289056077994868130232108318719 (%make-iset 101632 101640 #f #f #f) #f) (%make-iset 113664 113823 1210283916596275210941375398477980311935271305215 #f #f)) (%make-iset 120146 120485 #f (%make-iset 119808 120145 277984795434575462634999469953131284498641899033547154778380155978829522737042218261318709224765652991 (%make-iset 119552 119638 #f #f #f) #f) (%make-iset 120488 120781 7957171782556586274486115970349133441607298412757563479047423630290551952200534008528895 #f #f)))) (%make-iset 128736 130041 1395564823857300240922446466664555865028887665983335044524363252017914154373973301004635972404022510017571028632990405531056190531062782501742259967422408421904571830067909218330125344715810304357797273628378989117428119550443841642815730889863001220726100371562061441349510755262818835534689304533007067005401304757757932225110105305219425344132172538339933651336053275812227221363033527754751 (%make-iset 124928 125279 7023704209506790630179879761491893562843016690389893052156992171808320694211679637095248954604260979376127 (%make-iset 123136 123215 925569959590782532845567 (%make-iset 122880 122922 8641373536127 (%make-iset 121399 121483 38534505870515888006889487 #f #f) #f) (%make-iset 123584 123647 9511338530215821311 #f #f)) (%make-iset 126976 127589 66923435848449520561872831652599431289448618669932687931757021603387200183513455083701749538297393227813626429413144495791734667559393462525515277714480404638844354082830588746888380415 (%make-iset 126464 126705 5300541194335153381067228170533708156368811447347141191189319299759079407 (%make-iset 126124 126254 1361129467683753853853498429727072845841 #f #f) #f) (%make-iset 127744 128727 #f #f #f))) (%make-iset 178208 183969 #f (%make-iset 173824 177972 #f (%make-iset 173790 173823 0 (%make-iset 131072 173789 #f #f #f) #f) (%make-iset 177984 178207 6739986666787659948666753771754907668409286105635143120275902562303 #f #f)) (%make-iset 194560 195101 #f (%make-iset 183984 191456 #f (%make-iset 183970 183983 0 #f #f) #f) (%make-iset 196608 201546 #f #f #f))))))))


(define-library (chibi char-set extras)
  (cond-expand
   (chibi (import (chibi)))
   (else (import (scheme base))))
  (import (chibi iset) (chibi char-set base))
  (include "extras.scm")
  (export
   char-set ucs-range->char-set char-set-copy char-set-size
   char-set-fold char-set-for-each
   list->char-set char-set->list string->char-set char-set->string
   char-set-adjoin! char-set-adjoin char-set-union char-set-union!
   char-set-intersection char-set-intersection!
   char-set-difference char-set-difference!
   char-set-complement char-set:empty char-set:ascii char-set:full))

(define-library (chibi char-set full)
  (import (chibi) (chibi iset base) (chibi char-set base))
  (export char-set:lower-case  char-set:upper-case  char-set:title-case
          char-set:letter      char-set:digit       char-set:letter+digit
          char-set:graphic     char-set:printing    char-set:whitespace
          char-set:iso-control char-set:punctuation char-set:symbol
          char-set:hex-digit   char-set:blank)
  (include "full.scm"))

(define-library (chibi char-set base)
  (cond-expand
   (chibi
    (import (chibi))
    (begin
      (define-syntax immutable-char-set
        (sc-macro-transformer
         (lambda (expr use-env)
           (eval (cadr expr) use-env))))))
   (else
    (import (scheme base))
    (begin
      (define-syntax immutable-char-set
       (syntax-rules () ((immutable-char-set cs) cs))))))
  (import (chibi iset base))
  (export (rename Integer-Set Char-Set)
          (rename iset? char-set?)
          immutable-char-set
          char-set-contains?)
  (begin
    (define (char-set-contains? cset ch)
      (iset-contains? cset (char->integer ch)))))

(define-library (chibi optional-test)
  (import (scheme base) (chibi optional))
  (cond-expand
   (chibi (import (chibi test)))
   (else
    (import (scheme write))
    ;; inline (chibi test) to avoid circular dependencies in snow
    ;; installations
    (begin
      (define-syntax test
       (syntax-rules ()
         ((test expect expr)
          (test 'expr expect expr))
         ((test name expect expr)
          (guard (exn (else (display "!\nERROR: ") (write name) (newline)
                            (write exn) (newline)))
            (let* ((res expr)
                   (pass? (equal? expect expr)))
              (display (if pass? "." "x"))
              (cond
               ((not pass?)
                (display "\nFAIL: ") (write name) (newline))))))))
      (define-syntax test-assert
        (syntax-rules ()
          ((test-assert expr) (test #t expr))))
      (define-syntax test-error
        (syntax-rules ()
          ((test-error expr)
           (test-assert (guard (exn (else #t)) expr #f)))))
      (define (test-begin name)
        (display name))
      (define (test-end)
        (newline)))))
  (export run-tests)
  (begin
    (define (run-tests)
      (test-begin "optional")
      (test '(0 11 12)
          (let-optionals '(0) ((a 10) (b 11) (c 12))
            (list a b c)))
      (test '(0 11 12)
          ((opt-lambda ((a 10) (b 11) (c 12))
             (list a b c))
           0))
      (test '(0 11 12)
          ((opt-lambda (a (b 11) (c 12))
             (list a b c))
           0))
      (test '(0 11 2)
          (let ((b 1))
            ((opt-lambda (a (b 11) (c (* b 2)))
               (list a b c))
             0)))
      (test '(0 11 22)
          (let ((b 1))
            ((opt-lambda* (a (b 11) (c (* b 2)))
               (list a b c))
             0)))
      (test '(0 1 (2 3 4))
          (let-optionals* '(0 1 2 3 4) ((a 10) (b 11) . c)
            (list a b c)))
      (test '(0 1 (2 3 4))
          (let-optionals '(0 1 2 3 4) ((a 10) (b 11) . c)
            (list a b c)))
      (test '(0 1 (2 3 4))
          (let-optionals* '(0 1 2 3 4) (a (b 11) . c)
            (list a b c)))
      (test '(0 1 (2 3 4))
          (let-optionals '(0 1 2 3 4) (a (b 11) . c)
            (list a b c)))
      (let ((ls '()))
        (let-optionals* ls ((a (begin (set! ls '(a b)) 'default-a))
                            (b 'default-b))
          (test '(default-a default-b) (list a b))))
      (let ((ls (list 0 1 2)))
        (let-optionals ls (a . b)
          (set-car! (cdr ls) 3)
          (test '(0 3 2) ls)
          (test '(0 1 2) (cons a b))))
      (test 5 (keyword-ref '(a: b: b: 5) 'b: #f))
      (test 5 (keyword-ref* '(a: b: b: 5) 'b: #f))
      (test '(1 2 0 (other: 9))
          (let-keywords '(b: 2 a: 1 other: 9)
              ((a 0) (b 0) (c 0) rest)
            (list a b c rest)))
      ;; a: is not in a keyword position, and the 3 is dropped
      (test '(1 (2 a:))
          (let-keywords '(2 a: 3) ((a a: 1) rest) (list a rest)))
      ;; a: is in a keyword position, and the 3 is dropped
      (test '(2 ())
          (let-keywords '(a: 2 3) ((a a: 1) rest) (list a rest)))
      ;; a: is in a keyword position, 3->5 is a kv, 4 is dropped
      (test '(2 (3 5))
          (let-keywords '(3 5 a: 2 4) ((a a: 1) rest) (list a rest)))
      ;; a: is in a keyword position, 3->5 and 4->6 are kvs
      (test '(2 (3 5 4 6))
          (let-keywords '(3 5 a: 2 4 6) ((a a: 1) rest) (list a rest)))
      (cond-expand
       (gauche)     ; gauche detects this at compile-time, can't catch
       (else (test-error '(0 11 12)
                         ((opt-lambda (a (b 11) (c 12))
                            (list a b c))))))
      (let ()
        (define-opt (f a (b 11) (c 12))
          (list a b c))
        (cond-expand
         (gauche)
         (else
          (test-error (f))))
        (test '(0 11 12) (f 0))
        (test '(0 1 12) (f 0 1))
        (test '(0 1 2) (f 0 1 2))
        (test '(0 1 2) (f 0 1 2 3)))
      (test-end))))
(define-library (chibi process-test)
  (export run-tests)
  (import (chibi) (chibi process) (only (chibi test) test-begin test test-end))
  (begin
    (define (run-tests)
      (test-begin "processes")
      (test #t (process-running? (current-process-id)))
      (test #t (process-running? (parent-process-id)))
      (test #f (process-running? -1))
      (test #f (signal-set-contains? (current-signal-mask) signal/alarm))
      (test #t (signal-set? (make-signal-set)))
      (test #t (signal-set? (current-signal-mask)))
      (test #f (signal-set? #f))
      (test #f (signal-set? '(#f)))
      (test #f (signal-set-contains? (make-signal-set) signal/interrupt))
      (test #t (let ((sset (make-signal-set)))
                 (signal-set-fill! sset)
                 (signal-set-contains? sset signal/interrupt)))
      (test #t (let ((sset (make-signal-set)))
                 (signal-set-add! sset signal/interrupt)
                 (signal-set-contains? sset signal/interrupt)))
      (test #f (let ((sset (make-signal-set)))
                 (signal-set-fill! sset)
                 (signal-set-delete! sset signal/interrupt)
                 (signal-set-contains? sset signal/interrupt)))
      (test-end))))
;;;; match.scm -- portable hygienic pattern matcher -*- coding: utf-8 -*-
;;
;; This code is written by Alex Shinn and placed in the
;; Public Domain.  All warranties are disclaimed.

;;> \example-import[(srfi 9)]

;;> A portable hygienic pattern matcher.

;;> This is a full superset of the popular \hyperlink[
;;> "http://www.cs.indiana.edu/scheme-repository/code.match.html"]{match}
;;> package by Andrew Wright, written in fully portable \scheme{syntax-rules}
;;> and thus preserving hygiene.

;;> The most notable extensions are the ability to use \emph{non-linear}
;;> patterns - patterns in which the same identifier occurs multiple
;;> times, tail patterns after ellipsis, and the experimental tree patterns.

;;> \section{Patterns}

;;> Patterns are written to look like the printed representation of
;;> the objects they match.  The basic usage is

;;> \scheme{(match expr (pat body ...) ...)}

;;> where the result of \var{expr} is matched against each pattern in
;;> turn, and the corresponding body is evaluated for the first to
;;> succeed.  Thus, a list of three elements matches a list of three
;;> elements.

;;> \example{(let ((ls (list 1 2 3))) (match ls ((1 2 3) #t)))}

;;> If no patterns match an error is signalled.

;;> Identifiers will match anything, and make the corresponding
;;> binding available in the body.

;;> \example{(match (list 1 2 3) ((a b c) b))}

;;> If the same identifier occurs multiple times, the first instance
;;> will match anything, but subsequent instances must match a value
;;> which is \scheme{equal?} to the first.

;;> \example{(match (list 1 2 1) ((a a b) 1) ((a b a) 2))}

;;> The special identifier \scheme{_} matches anything, no matter how
;;> many times it is used, and does not bind the result in the body.

;;> \example{(match (list 1 2 1) ((_ _ b) 1) ((a b a) 2))}

;;> To match a literal identifier (or list or any other literal), use
;;> \scheme{quote}.

;;> \example{(match 'a ('b 1) ('a 2))}

;;> Analogous to its normal usage in scheme, \scheme{quasiquote} can
;;> be used to quote a mostly literally matching object with selected
;;> parts unquoted.

;;> \example|{(match (list 1 2 3) (`(1 ,b ,c) (list b c)))}|

;;> Often you want to match any number of a repeated pattern.  Inside
;;> a list pattern you can append \scheme{...} after an element to
;;> match zero or more of that pattern (like a regexp Kleene star).

;;> \example{(match (list 1 2) ((1 2 3 ...) #t))}
;;> \example{(match (list 1 2 3) ((1 2 3 ...) #t))}
;;> \example{(match (list 1 2 3 3 3) ((1 2 3 ...) #t))}

;;> Pattern variables matched inside the repeated pattern are bound to
;;> a list of each matching instance in the body.

;;> \example{(match (list 1 2) ((a b c ...) c))}
;;> \example{(match (list 1 2 3) ((a b c ...) c))}
;;> \example{(match (list 1 2 3 4 5) ((a b c ...) c))}

;;> More than one \scheme{...} may not be used in the same list, since
;;> this would require exponential backtracking in the general case.
;;> However, \scheme{...} need not be the final element in the list,
;;> and may be succeeded by a fixed number of patterns.

;;> \example{(match (list 1 2 3 4) ((a b c ... d e) c))}
;;> \example{(match (list 1 2 3 4 5) ((a b c ... d e) c))}
;;> \example{(match (list 1 2 3 4 5 6 7) ((a b c ... d e) c))}

;;> \scheme{___} is provided as an alias for \scheme{...} when it is
;;> inconvenient to use the ellipsis (as in a syntax-rules template).

;;> The \scheme{**1} syntax is exactly like the \scheme{...} except
;;> that it matches one or more repetitions (like a regexp "+").

;;> \example{(match (list 1 2) ((a b c **1) c))}
;;> \example{(match (list 1 2 3) ((a b c **1) c))}

;;> The \scheme{*..} syntax is like \scheme{...} except that it takes
;;> two trailing integers \scheme{<n>} and \scheme{<m>}, and requires
;;> the pattern to match from \scheme{<n>} times.

;;> \example{(match (list 1 2 3) ((a b *.. 2 4) b))}
;;> \example{(match (list 1 2 3 4 5 6) ((a b *.. 2 4) b))}
;;> \example{(match (list 1 2 3 4) ((a b *.. 2 4 c) c))}

;;> The \scheme{(<expr> =.. <n>)} syntax is a shorthand for
;;> \scheme{(<expr> *.. <n> <n>)}.

;;> \example{(match (list 1 2) ((a b =.. 2) b))}
;;> \example{(match (list 1 2 3) ((a b =.. 2) b))}
;;> \example{(match (list 1 2 3 4) ((a b =.. 2) b))}

;;> The boolean operators \scheme{and}, \scheme{or} and \scheme{not}
;;> can be used to group and negate patterns analogously to their
;;> Scheme counterparts.

;;> The \scheme{and} operator ensures that all subpatterns match.
;;> This operator is often used with the idiom \scheme{(and x pat)} to
;;> bind \var{x} to the entire value that matches \var{pat}
;;> (c.f. "as-patterns" in ML or Haskell).  Another common use is in
;;> conjunction with \scheme{not} patterns to match a general case
;;> with certain exceptions.

;;> \example{(match 1 ((and) #t))}
;;> \example{(match 1 ((and x) x))}
;;> \example{(match 1 ((and x 1) x))}

;;> The \scheme{or} operator ensures that at least one subpattern
;;> matches.  If the same identifier occurs in different subpatterns,
;;> it is matched independently.  All identifiers from all subpatterns
;;> are bound if the \scheme{or} operator matches, but the binding is
;;> only defined for identifiers from the subpattern which matched.

;;> \example{(match 1 ((or) #t) (else #f))}
;;> \example{(match 1 ((or x) x))}
;;> \example{(match 1 ((or x 2) x))}

;;> The \scheme{not} operator succeeds if the given pattern doesn't
;;> match.  None of the identifiers used are available in the body.

;;> \example{(match 1 ((not 2) #t))}

;;> The more general operator \scheme{?} can be used to provide a
;;> predicate.  The usage is \scheme{(? predicate pat ...)} where
;;> \var{predicate} is a Scheme expression evaluating to a predicate
;;> called on the value to match, and any optional patterns after the
;;> predicate are then matched as in an \scheme{and} pattern.

;;> \example{(match 1 ((? odd? x) x))}

;;> The field operator \scheme{=} is used to extract an arbitrary
;;> field and match against it.  It is useful for more complex or
;;> conditional destructuring that can't be more directly expressed in
;;> the pattern syntax.  The usage is \scheme{(= field pat)}, where
;;> \var{field} can be any expression, and should result in a
;;> procedure of one argument, which is applied to the value to match
;;> to generate a new value to match against \var{pat}.

;;> Thus the pattern \scheme{(and (= car x) (= cdr y))} is equivalent
;;> to \scheme{(x . y)}, except it will result in an immediate error
;;> if the value isn't a pair.

;;> \example{(match '(1 . 2) ((= car x) x))}
;;> \example{(match 4 ((= square x) x))}

;;> The record operator \scheme{$} is used as a concise way to match
;;> records defined by SRFI-9 (or SRFI-99).  The usage is
;;> \scheme{($ rtd field ...)}, where \var{rtd} should be the record
;;> type descriptor specified as the first argument to
;;> \scheme{define-record-type}, and each \var{field} is a subpattern
;;> matched against the fields of the record in order.  Not all fields
;;> must be present.

;;> \example{
;;> (let ()
;;>   (define-record-type employee
;;>     (make-employee name title)
;;>     employee?
;;>     (name get-name)
;;>     (title get-title))
;;>   (match (make-employee "Bob" "Doctor")
;;>     (($ employee n t) (list t n))))
;;> }

;;> For records with more fields it can be helpful to match them by
;;> name rather than position.  For this you can use the \scheme{@}
;;> operator, originally a Gauche extension:

;;> \example{
;;> (let ()
;;>   (define-record-type employee
;;>     (make-employee name title)
;;>     employee?
;;>     (name get-name)
;;>     (title get-title))
;;>   (match (make-employee "Bob" "Doctor")
;;>     ((@ employee (title t) (name n)) (list t n))))
;;> }

;;> The \scheme{set!} and \scheme{get!} operators are used to bind an
;;> identifier to the setter and getter of a field, respectively.  The
;;> setter is a procedure of one argument, which mutates the field to
;;> that argument.  The getter is a procedure of no arguments which
;;> returns the current value of the field.

;;> \example{(let ((x (cons 1 2))) (match x ((1 . (set! s)) (s 3) x)))}
;;> \example{(match '(1 . 2) ((1 . (get! g)) (g)))}

;;> The new operator \scheme{***} can be used to search a tree for
;;> subpatterns.  A pattern of the form \scheme{(x *** y)} represents
;;> the subpattern \var{y} located somewhere in a tree where the path
;;> from the current object to \var{y} can be seen as a list of the
;;> form \scheme{(x ...)}.  \var{y} can immediately match the current
;;> object in which case the path is the empty list.  In a sense it's
;;> a 2-dimensional version of the \scheme{...} pattern.

;;> As a common case the pattern \scheme{(_ *** y)} can be used to
;;> search for \var{y} anywhere in a tree, regardless of the path
;;> used.

;;> \example{(match '(a (a (a b))) ((x *** 'b) x))}
;;> \example{(match '(a (b) (c (d e) (f g))) ((x *** 'g) x))}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Notes

;; The implementation is a simple generative pattern matcher - each
;; pattern is expanded into the required tests, calling a failure
;; continuation if the tests fail.  This makes the logic easy to
;; follow and extend, but produces sub-optimal code in cases where you
;; have many similar clauses due to repeating the same tests.
;; Nonetheless a smart compiler should be able to remove the redundant
;; tests.  For MATCH-LET and DESTRUCTURING-BIND type uses there is no
;; performance hit.

;; The original version was written on 2006/11/29 and described in the
;; following Usenet post:
;;   http://groups.google.com/group/comp.lang.scheme/msg/0941234de7112ffd
;; and is still available at
;;   http://synthcode.com/scheme/match-simple.scm
;; It's just 80 lines for the core MATCH, and an extra 40 lines for
;; MATCH-LET, MATCH-LAMBDA and other syntactic sugar.
;;
;; A variant of this file which uses COND-EXPAND in a few places for
;; performance can be found at
;;   http://synthcode.com/scheme/match-cond-expand.scm
;;
;; 2021/06/21 - fix for `(a ...)' patterns where `a' is already bound
;;              (thanks to Andy Wingo)
;; 2020/09/04 - perf fix for `not`; rename `..=', `..=', `..1' per SRFI 204
;; 2020/08/21 - fixing match-letrec with unhygienic insertion
;; 2020/07/06 - adding `..=' and `..=' patterns; fixing ,@ patterns
;; 2016/10/05 - treat keywords as literals, not identifiers, in Chicken
;; 2016/03/06 - fixing named match-let (thanks to Stefan Israelsson Tampe)
;; 2015/05/09 - fixing bug in var extraction of quasiquote patterns
;; 2014/11/24 - adding Gauche's `@' pattern for named record field matching
;; 2012/12/26 - wrapping match-let&co body in lexical closure
;; 2012/11/28 - fixing typo s/vetor/vector in largely unused set! code
;; 2012/05/23 - fixing combinatorial explosion of code in certain or patterns
;; 2011/09/25 - fixing bug when directly matching an identifier repeated in
;;              the pattern (thanks to Stefan Israelsson Tampe)
;; 2011/01/27 - fixing bug when matching tail patterns against improper lists
;; 2010/09/26 - adding `..1' patterns (thanks to Ludovic Courts)
;; 2010/09/07 - fixing identifier extraction in some `...' and `***' patterns
;; 2009/11/25 - adding `***' tree search patterns
;; 2008/03/20 - fixing bug where (a ...) matched non-lists
;; 2008/03/15 - removing redundant check in vector patterns
;; 2008/03/06 - you can use `...' portably now (thanks to Taylor Campbell)
;; 2007/09/04 - fixing quasiquote patterns
;; 2007/07/21 - allowing ellipsis patterns in non-final list positions
;; 2007/04/10 - fixing potential hygiene issue in match-check-ellipsis
;;              (thanks to Taylor Campbell)
;; 2007/04/08 - clean up, commenting
;; 2006/12/24 - bugfixes
;; 2006/12/01 - non-linear patterns, shared variables in OR, get!/set!

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; force compile-time syntax errors with useful messages

(define-syntax match-syntax-error
  (syntax-rules ()
    ((_) (syntax-error "invalid match-syntax-error usage"))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;> \section{Syntax}

;;> \macro{(match expr (pattern . body) ...)\br{}
;;> (match expr (pattern (=> failure) . body) ...)}

;;> The result of \var{expr} is matched against each \var{pattern} in
;;> turn, according to the pattern rules described in the previous
;;> section, until the the first \var{pattern} matches.  When a match is
;;> found, the corresponding \var{body}s are evaluated in order,
;;> and the result of the last expression is returned as the result
;;> of the entire \scheme{match}.  If a \var{failure} is provided,
;;> then it is bound to a procedure of no arguments which continues,
;;> processing at the next \var{pattern}.  If no \var{pattern} matches,
;;> an error is signalled.

;; The basic interface.  MATCH just performs some basic syntax
;; validation, binds the match expression to a temporary variable `v',
;; and passes it on to MATCH-NEXT.  It's a constant throughout the
;; code below that the binding `v' is a direct variable reference, not
;; an expression.

(define-syntax match
  (syntax-rules ()
    ((match)
     (match-syntax-error "missing match expression"))
    ((match atom)
     (match-syntax-error "no match clauses"))
    ((match (app ...) (pat . body) ...)
     (let ((v (app ...)))
       (match-next v ((app ...) (set! (app ...))) (pat . body) ...)))
    ((match #(vec ...) (pat . body) ...)
     (let ((v #(vec ...)))
       (match-next v (v (set! v)) (pat . body) ...)))
    ((match atom (pat . body) ...)
     (let ((v atom))
       (match-next v (atom (set! atom)) (pat . body) ...)))
    ))

;; MATCH-NEXT passes each clause to MATCH-ONE in turn with its failure
;; thunk, which is expanded by recursing MATCH-NEXT on the remaining
;; clauses.  `g+s' is a list of two elements, the get! and set!
;; expressions respectively.

(define-syntax match-next
  (syntax-rules (=>)
    ;; no more clauses, the match failed
    ((match-next v g+s)
     (error 'match "no matching pattern"))
    ;; named failure continuation
    ((match-next v g+s (pat (=> failure) . body) . rest)
     (let ((failure (lambda () (match-next v g+s . rest))))
       ;; match-one analyzes the pattern for us
       (match-one v pat g+s (match-drop-ids (begin . body)) (failure) ())))
    ;; anonymous failure continuation, give it a dummy name
    ((match-next v g+s (pat . body) . rest)
     (match-next v g+s (pat (=> failure) . body) . rest))))

;; MATCH-ONE first checks for ellipsis patterns, otherwise passes on to
;; MATCH-TWO.

(define-syntax match-one
  (syntax-rules ()
    ;; If it's a list of two or more values, check to see if the
    ;; second one is an ellipsis and handle accordingly, otherwise go
    ;; to MATCH-TWO.
    ((match-one v (p q . r) g+s sk fk i)
     (match-check-ellipsis
      q
      (match-extract-vars p (match-gen-ellipsis v p r  g+s sk fk i) i ())
      (match-two v (p q . r) g+s sk fk i)))
    ;; Go directly to MATCH-TWO.
    ((match-one . x)
     (match-two . x))))

;; This is the guts of the pattern matcher.  We are passed a lot of
;; information in the form:
;;
;;   (match-two var pattern getter setter success-k fail-k (ids ...))
;;
;; usually abbreviated
;;
;;   (match-two v p g+s sk fk i)
;;
;; where VAR is the symbol name of the current variable we are
;; matching, PATTERN is the current pattern, getter and setter are the
;; corresponding accessors (e.g. CAR and SET-CAR! of the pair holding
;; VAR), SUCCESS-K is the success continuation, FAIL-K is the failure
;; continuation (which is just a thunk call and is thus safe to expand
;; multiple times) and IDS are the list of identifiers bound in the
;; pattern so far.

(define-syntax match-two
  (syntax-rules (_ ___ **1 =.. *.. *** quote quasiquote ? $ struct @ object = and or not set! get!)
    ((match-two v () g+s (sk ...) fk i)
     (if (null? v) (sk ... i) fk))
    ((match-two v (quote p) g+s (sk ...) fk i)
     (if (equal? v 'p) (sk ... i) fk))
    ((match-two v (quasiquote p) . x)
     (match-quasiquote v p . x))
    ((match-two v (and) g+s (sk ...) fk i) (sk ... i))
    ((match-two v (and p q ...) g+s sk fk i)
     (match-one v p g+s (match-one v (and q ...) g+s sk fk) fk i))
    ((match-two v (or) g+s sk fk i) fk)
    ((match-two v (or p) . x)
     (match-one v p . x))
    ((match-two v (or p ...) g+s sk fk i)
     (match-extract-vars (or p ...) (match-gen-or v (p ...) g+s sk fk i) i ()))
    ((match-two v (not p) g+s (sk ...) fk i)
     (let ((fk2 (lambda () (sk ... i))))
       (match-one v p g+s (match-drop-ids fk) (fk2) i)))
    ((match-two v (get! getter) (g s) (sk ...) fk i)
     (let ((getter (lambda () g))) (sk ... i)))
    ((match-two v (set! setter) (g (s ...)) (sk ...) fk i)
     (let ((setter (lambda (x) (s ... x)))) (sk ... i)))
    ((match-two v (? pred . p) g+s sk fk i)
     (if (pred v) (match-one v (and . p) g+s sk fk i) fk))
    ((match-two v (= proc p) . x)
     (let ((w (proc v))) (match-one w p . x)))
    ((match-two v (p ___ . r) g+s sk fk i)
     (match-extract-vars p (match-gen-ellipsis v p r g+s sk fk i) i ()))
    ((match-two v (p) g+s sk fk i)
     (if (and (pair? v) (null? (cdr v)))
         (let ((w (car v)))
           (match-one w p ((car v) (set-car! v)) sk fk i))
         fk))
    ((match-two v (p *** q) g+s sk fk i)
     (match-extract-vars p (match-gen-search v p q g+s sk fk i) i ()))
    ((match-two v (p *** . q) g+s sk fk i)
     (match-syntax-error "invalid use of ***" (p *** . q)))
    ((match-two v (p **1) g+s sk fk i)
     (if (pair? v)
         (match-one v (p ___) g+s sk fk i)
         fk))
    ((match-two v (p =.. n . r) g+s sk fk i)
     (match-extract-vars
      p
      (match-gen-ellipsis/range n n v p r g+s sk fk i) i ()))
    ((match-two v (p *.. n m . r) g+s sk fk i)
     (match-extract-vars
      p
      (match-gen-ellipsis/range n m v p r g+s sk fk i) i ()))
    ((match-two v ($ rec p ...) g+s sk fk i)
     (if (is-a? v rec)
         (match-record-refs v rec 0 (p ...) g+s sk fk i)
         fk))
    ((match-two v (struct rec p ...) g+s sk fk i)
     (if (is-a? v rec)
         (match-record-refs v rec 0 (p ...) g+s sk fk i)
         fk))
    ((match-two v (@ rec p ...) g+s sk fk i)
     (if (is-a? v rec)
         (match-record-named-refs v rec (p ...) g+s sk fk i)
         fk))
    ((match-two v (object rec p ...) g+s sk fk i)
     (if (is-a? v rec)
         (match-record-named-refs v rec (p ...) g+s sk fk i)
         fk))
    ((match-two v (p . q) g+s sk fk i)
     (if (pair? v)
         (let ((w (car v)) (x (cdr v)))
           (match-one w p ((car v) (set-car! v))
                      (match-one x q ((cdr v) (set-cdr! v)) sk fk)
                      fk
                      i))
         fk))
    ((match-two v #(p ...) g+s . x)
     (match-vector v 0 () (p ...) . x))
    ((match-two v _ g+s (sk ...) fk i) (sk ... i))
    ;; Not a pair or vector or special literal, test to see if it's a
    ;; new symbol, in which case we just bind it, or if it's an
    ;; already bound symbol or some other literal, in which case we
    ;; compare it with EQUAL?.
    ((match-two v x g+s (sk ...) fk (id ...))
     ;; This extra match-check-identifier is optional in general, but
     ;; can serve as a fast path, and is needed to distinguish
     ;; keywords in Chicken.
     (match-check-identifier
      x
      (let-syntax
          ((new-sym?
            (syntax-rules (id ...)
              ((new-sym? x sk2 fk2) sk2)
              ((new-sym? y sk2 fk2) fk2))))
        (new-sym? random-sym-to-match
                  (let ((x v)) (sk ... (id ... x)))
                  (if (equal? v x) (sk ... (id ...)) fk)))
      (if (equal? v x) (sk ... (id ...)) fk)))
    ))

;; QUASIQUOTE patterns

(define-syntax match-quasiquote
  (syntax-rules (unquote unquote-splicing quasiquote or)
    ((_ v (unquote p) g+s sk fk i)
     (match-one v p g+s sk fk i))
    ((_ v ((unquote-splicing p) . rest) g+s sk fk i)
     ;; TODO: it is an error to have another unquote-splicing in rest,
     ;; check this and signal explicitly
     (match-extract-vars
      p
      (match-gen-ellipsis/qq v p rest g+s sk fk i) i ()))
    ((_ v (quasiquote p) g+s sk fk i . depth)
     (match-quasiquote v p g+s sk fk i #f . depth))
    ((_ v (unquote p) g+s sk fk i x . depth)
     (match-quasiquote v p g+s sk fk i . depth))
    ((_ v (unquote-splicing p) g+s sk fk i x . depth)
     (match-quasiquote v p g+s sk fk i . depth))
    ((_ v (p . q) g+s sk fk i . depth)
     (if (pair? v)
       (let ((w (car v)) (x (cdr v)))
         (match-quasiquote
          w p g+s
          (match-quasiquote-step x q g+s sk fk depth)
          fk i . depth))
       fk))
    ((_ v #(elt ...) g+s sk fk i . depth)
     (if (vector? v)
       (let ((ls (vector->list v)))
         (match-quasiquote ls (elt ...) g+s sk fk i . depth))
       fk))
    ((_ v x g+s sk fk i . depth)
     (match-one v 'x g+s sk fk i))))

(define-syntax match-quasiquote-step
  (syntax-rules ()
    ((match-quasiquote-step x q g+s sk fk depth i)
     (match-quasiquote x q g+s sk fk i . depth))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Utilities

;; Takes two values and just expands into the first.
(define-syntax match-drop-ids
  (syntax-rules ()
    ((_ expr ids ...) expr)))

(define-syntax match-tuck-ids
  (syntax-rules ()
    ((_ (letish args (expr ...)) ids ...)
     (letish args (expr ... ids ...)))))

(define-syntax match-drop-first-arg
  (syntax-rules ()
    ((_ arg expr) expr)))

;; To expand an OR group we try each clause in succession, passing the
;; first that succeeds to the success continuation.  On failure for
;; any clause, we just try the next clause, finally resorting to the
;; failure continuation fk if all clauses fail.  The only trick is
;; that we want to unify the identifiers, so that the success
;; continuation can refer to a variable from any of the OR clauses.

(define-syntax match-gen-or
  (syntax-rules ()
    ((_ v p g+s (sk ...) fk (i ...) ((id id-ls) ...))
     (let ((sk2 (lambda (id ...) (sk ... (i ... id ...))))
           (id (if #f #f)) ...)
       (match-gen-or-step v p g+s (match-drop-ids (sk2 id ...)) fk (i ...))))))

(define-syntax match-gen-or-step
  (syntax-rules ()
    ((_ v () g+s sk fk . x)
     ;; no OR clauses, call the failure continuation
     fk)
    ((_ v (p) . x)
     ;; last (or only) OR clause, just expand normally
     (match-one v p . x))
    ((_ v (p . q) g+s sk fk i)
     ;; match one and try the remaining on failure
     (let ((fk2 (lambda () (match-gen-or-step v q g+s sk fk i))))
       (match-one v p g+s sk (fk2) i)))
    ))

;; We match a pattern (p ...) by matching the pattern p in a loop on
;; each element of the variable, accumulating the bound ids into lists.

;; Look at the body of the simple case - it's just a named let loop,
;; matching each element in turn to the same pattern.  The only trick
;; is that we want to keep track of the lists of each extracted id, so
;; when the loop recurses we cons the ids onto their respective list
;; variables, and on success we bind the ids (what the user input and
;; expects to see in the success body) to the reversed accumulated
;; list IDs.

(define-syntax match-gen-ellipsis
  (syntax-rules ()
    ;; TODO: restore fast path when p is not already bound
    ((_ v p () g+s (sk ...) fk i ((id id-ls) ...))
     (match-check-identifier p
       ;; simplest case equivalent to (p ...), just match the list
       (let ((w v))
         (if (list? w)
             (match-one w p g+s (sk ...) fk i)
             fk))
       ;; simple case, match all elements of the list
       (let loop ((ls v) (id-ls '()) ...)
         (cond
           ((null? ls)
            (let ((id (reverse id-ls)) ...) (sk ... i)))
           ((pair? ls)
            (let ((w (car ls)))
              (match-one w p ((car ls) (set-car! ls))
                         (match-drop-ids (loop (cdr ls) (cons id id-ls) ...))
                         fk i)))
           (else
            fk)))))
    ((_ v p r g+s sk fk (i ...) ((id id-ls) ...))
     (match-verify-no-ellipsis
      r
      (match-bound-identifier-memv
       p
       (i ...)
       ;; p is bound, match the list up to the known length, then
       ;; match the trailing patterns
       (let loop ((ls v) (expect p))
         (cond
          ((null? expect)
           (match-one ls r (#f #f) sk fk (i ...)))
          ((pair? ls)
           (let ((w (car ls))
                 (e (car expect)))
             (if (equal? (car ls) (car expect))
                 (match-drop-ids (loop (cdr ls) (cdr expect)))
                 fk)))
          (else
           fk)))
       ;; general case, trailing patterns to match, keep track of
       ;; the remaining list length so we don't need any backtracking
       (let* ((tail-len (length 'r))
              (ls v)
              (len (and (list? ls) (length ls))))
         (if (or (not len) (< len tail-len))
             fk
             (let loop ((ls ls) (n len) (id-ls '()) ...)
               (cond
                ((= n tail-len)
                 (let ((id (reverse id-ls)) ...)
                   (match-one ls r (#f #f) sk fk (i ... id ...))))
                ((pair? ls)
                 (let ((w (car ls)))
                   (match-one w p ((car ls) (set-car! ls))
                              (match-drop-ids
                               (loop (cdr ls) (- n 1) (cons id id-ls) ...))
                              fk
                              (i ...))))
                (else
                 fk)))
           )))))))

;; Variant of the above where the rest pattern is in a quasiquote.

(define-syntax match-gen-ellipsis/qq
  (syntax-rules ()
    ((_ v p r g+s (sk ...) fk (i ...) ((id id-ls) ...))
     (match-verify-no-ellipsis
      r
      (let* ((tail-len (length 'r))
             (ls v)
             (len (and (list? ls) (length ls))))
        (if (or (not len) (< len tail-len))
            fk
            (let loop ((ls ls) (n len) (id-ls '()) ...)
              (cond
               ((= n tail-len)
                (let ((id (reverse id-ls)) ...)
                  (match-quasiquote ls r g+s (sk ...) fk (i ... id ...))))
               ((pair? ls)
                (let ((w (car ls)))
                  (match-one w p ((car ls) (set-car! ls))
                             (match-drop-ids
                              (loop (cdr ls) (- n 1) (cons id id-ls) ...))
                             fk
                             (i ...))))
               (else
                fk)))))))))

;; Variant of above which takes an n/m range for the number of
;; repetitions.  At least n elements much match, and up to m elements
;; are greedily consumed.

(define-syntax match-gen-ellipsis/range
  (syntax-rules ()
    ((_ %lo %hi v p r g+s (sk ...) fk (i ...) ((id id-ls) ...))
     ;; general case, trailing patterns to match, keep track of the
     ;; remaining list length so we don't need any backtracking
     (match-verify-no-ellipsis
      r
      (let* ((lo %lo)
             (hi %hi)
             (tail-len (length 'r))
             (ls v)
             (len (and (list? ls) (- (length ls) tail-len))))
        (if (and len (<= lo len hi))
            (let loop ((ls ls) (j 0) (id-ls '()) ...)
              (cond
                ((= j len)
                 (let ((id (reverse id-ls)) ...)
                   (match-one ls r (#f #f) (sk ...) fk (i ... id ...))))
                ((pair? ls)
                 (let ((w (car ls)))
                   (match-one w p ((car ls) (set-car! ls))
                              (match-drop-ids
                               (loop (cdr ls) (+ j 1) (cons id id-ls) ...))
                              fk
                              (i ...))))
                (else
                 fk)))
            fk))))))

;; This is just a safety check.  Although unlike syntax-rules we allow
;; trailing patterns after an ellipsis, we explicitly disable multiple
;; ellipsis at the same level.  This is because in the general case
;; such patterns are exponential in the number of ellipsis, and we
;; don't want to make it easy to construct very expensive operations
;; with simple looking patterns.  For example, it would be O(n^2) for
;; patterns like (a ... b ...) because we must consider every trailing
;; element for every possible break for the leading "a ...".

(define-syntax match-verify-no-ellipsis
  (syntax-rules ()
    ((_ (x . y) sk)
     (match-check-ellipsis
      x
      (match-syntax-error
       "multiple ellipsis patterns not allowed at same level")
      (match-verify-no-ellipsis y sk)))
    ((_ () sk)
     sk)
    ((_ x sk)
     (match-syntax-error "dotted tail not allowed after ellipsis" x))))

;; To implement the tree search, we use two recursive procedures.  TRY
;; attempts to match Y once, and on success it calls the normal SK on
;; the accumulated list ids as in MATCH-GEN-ELLIPSIS.  On failure, we
;; call NEXT which first checks if the current value is a list
;; beginning with X, then calls TRY on each remaining element of the
;; list.  Since TRY will recursively call NEXT again on failure, this
;; effects a full depth-first search.
;;
;; The failure continuation throughout is a jump to the next step in
;; the tree search, initialized with the original failure continuation
;; FK.

(define-syntax match-gen-search
  (syntax-rules ()
    ((match-gen-search v p q g+s sk fk i ((id id-ls) ...))
     (letrec ((try (lambda (w fail id-ls ...)
                     (match-one w q g+s
                                (match-tuck-ids
                                 (let ((id (reverse id-ls)) ...)
                                   sk))
                                (next w fail id-ls ...) i)))
              (next (lambda (w fail id-ls ...)
                      (if (not (pair? w))
                          (fail)
                          (let ((u (car w)))
                            (match-one
                             u p ((car w) (set-car! w))
                             (match-drop-ids
                              ;; accumulate the head variables from
                              ;; the p pattern, and loop over the tail
                              (let ((id-ls (cons id id-ls)) ...)
                                (let lp ((ls (cdr w)))
                                  (if (pair? ls)
                                      (try (car ls)
                                           (lambda () (lp (cdr ls)))
                                           id-ls ...)
                                      (fail)))))
                             (fail) i))))))
       ;; the initial id-ls binding here is a dummy to get the right
       ;; number of '()s
       (let ((id-ls '()) ...)
         (try v (lambda () fk) id-ls ...))))))

;; Vector patterns are just more of the same, with the slight
;; exception that we pass around the current vector index being
;; matched.

(define-syntax match-vector
  (syntax-rules (___)
    ((_ v n pats (p q) . x)
     (match-check-ellipsis q
                          (match-gen-vector-ellipsis v n pats p . x)
                          (match-vector-two v n pats (p q) . x)))
    ((_ v n pats (p ___) sk fk i)
     (match-gen-vector-ellipsis v n pats p sk fk i))
    ((_ . x)
     (match-vector-two . x))))

;; Check the exact vector length, then check each element in turn.

(define-syntax match-vector-two
  (syntax-rules ()
    ((_ v n ((pat index) ...) () sk fk i)
     (if (vector? v)
         (let ((len (vector-length v)))
           (if (= len n)
               (match-vector-step v ((pat index) ...) sk fk i)
               fk))
         fk))
    ((_ v n (pats ...) (p . q) . x)
     (match-vector v (+ n 1) (pats ... (p n)) q . x))))

(define-syntax match-vector-step
  (syntax-rules ()
    ((_ v () (sk ...) fk i) (sk ... i))
    ((_ v ((pat index) . rest) sk fk i)
     (let ((w (vector-ref v index)))
       (match-one w pat ((vector-ref v index) (vector-set! v index))
                  (match-vector-step v rest sk fk)
                  fk i)))))

;; With a vector ellipsis pattern we first check to see if the vector
;; length is at least the required length.

(define-syntax match-gen-vector-ellipsis
  (syntax-rules ()
    ((_ v n ((pat index) ...) p sk fk i)
     (if (vector? v)
       (let ((len (vector-length v)))
         (if (>= len n)
           (match-vector-step v ((pat index) ...)
                              (match-vector-tail v p n len sk fk)
                              fk i)
           fk))
       fk))))

(define-syntax match-vector-tail
  (syntax-rules ()
    ((_ v p n len sk fk i)
     (match-extract-vars p (match-vector-tail-two v p n len sk fk i) i ()))))

(define-syntax match-vector-tail-two
  (syntax-rules ()
    ((_ v p n len (sk ...) fk i ((id id-ls) ...))
     (let loop ((j n) (id-ls '()) ...)
       (if (>= j len)
         (let ((id (reverse id-ls)) ...) (sk ... i))
         (let ((w (vector-ref v j)))
           (match-one w p ((vector-ref v j) (vector-set! v j))
                      (match-drop-ids (loop (+ j 1) (cons id id-ls) ...))
                      fk i)))))))

(define-syntax match-record-refs
  (syntax-rules ()
    ((_ v rec n (p . q) g+s sk fk i)
     (let ((w (slot-ref rec v n)))
       (match-one w p ((slot-ref rec v n) (slot-set! rec v n))
                  (match-record-refs v rec (+ n 1) q g+s sk fk) fk i)))
    ((_ v rec n () g+s (sk ...) fk i)
     (sk ... i))))

(define-syntax match-record-named-refs
  (syntax-rules ()
    ((_ v rec ((f p) . q) g+s sk fk i)
     (let ((w (slot-ref rec v 'f)))
       (match-one w p ((slot-ref rec v 'f) (slot-set! rec v 'f))
                  (match-record-named-refs v rec q g+s sk fk) fk i)))
    ((_ v rec () g+s (sk ...) fk i)
     (sk ... i))))

;; Extract all identifiers in a pattern.  A little more complicated
;; than just looking for symbols, we need to ignore special keywords
;; and non-pattern forms (such as the predicate expression in ?
;; patterns), and also ignore previously bound identifiers.
;;
;; Calls the continuation with all new vars as a list of the form
;; ((orig-var tmp-name) ...), where tmp-name can be used to uniquely
;; pair with the original variable (e.g. it's used in the ellipsis
;; generation for list variables).
;;
;; (match-extract-vars pattern continuation (ids ...) (new-vars ...))

(define-syntax match-extract-vars
  (syntax-rules (_ ___ **1 =.. *.. *** ? $ struct @ object = quote quasiquote and or not get! set!)
    ((match-extract-vars (? pred . p) . x)
     (match-extract-vars p . x))
    ((match-extract-vars ($ rec . p) . x)
     (match-extract-vars p . x))
    ((match-extract-vars (struct rec . p) . x)
     (match-extract-vars p . x))
    ((match-extract-vars (@ rec (f p) ...) . x)
     (match-extract-vars (p ...) . x))
    ((match-extract-vars (object rec (f p) ...) . x)
     (match-extract-vars (p ...) . x))
    ((match-extract-vars (= proc p) . x)
     (match-extract-vars p . x))
    ((match-extract-vars (quote x) (k ...) i v)
     (k ... v))
    ((match-extract-vars (quasiquote x) k i v)
     (match-extract-quasiquote-vars x k i v (#t)))
    ((match-extract-vars (and . p) . x)
     (match-extract-vars p . x))
    ((match-extract-vars (or . p) . x)
     (match-extract-vars p . x))
    ((match-extract-vars (not . p) . x)
     (match-extract-vars p . x))
    ;; A non-keyword pair, expand the CAR with a continuation to
    ;; expand the CDR.
    ((match-extract-vars (p q . r) k i v)
     (match-check-ellipsis
      q
      (match-extract-vars (p . r) k i v)
      (match-extract-vars p (match-extract-vars-step (q . r) k i v) i ())))
    ((match-extract-vars (p . q) k i v)
     (match-extract-vars p (match-extract-vars-step q k i v) i ()))
    ((match-extract-vars #(p ...) . x)
     (match-extract-vars (p ...) . x))
    ((match-extract-vars _ (k ...) i v)    (k ... v))
    ((match-extract-vars ___ (k ...) i v)  (k ... v))
    ((match-extract-vars *** (k ...) i v)  (k ... v))
    ((match-extract-vars **1 (k ...) i v)  (k ... v))
    ((match-extract-vars =.. (k ...) i v)  (k ... v))
    ((match-extract-vars *.. (k ...) i v)  (k ... v))
    ;; This is the main part, the only place where we might add a new
    ;; var if it's an unbound symbol.
    ((match-extract-vars p (k ...) (i ...) v)
     (let-syntax
         ((new-sym?
           (syntax-rules (i ...)
             ((new-sym? p sk fk) sk)
             ((new-sym? any sk fk) fk))))
       (new-sym? random-sym-to-match
                 (k ... ((p p-ls) . v))
                 (k ... v))))
    ))

;; Stepper used in the above so it can expand the CAR and CDR
;; separately.

(define-syntax match-extract-vars-step
  (syntax-rules ()
    ((_ p k i v ((v2 v2-ls) ...))
     (match-extract-vars p k (v2 ... . i) ((v2 v2-ls) ... . v)))
    ))

(define-syntax match-extract-quasiquote-vars
  (syntax-rules (quasiquote unquote unquote-splicing)
    ((match-extract-quasiquote-vars (quasiquote x) k i v d)
     (match-extract-quasiquote-vars x k i v (#t . d)))
    ((match-extract-quasiquote-vars (unquote-splicing x) k i v d)
     (match-extract-quasiquote-vars (unquote x) k i v d))
    ((match-extract-quasiquote-vars (unquote x) k i v (#t))
     (match-extract-vars x k i v))
    ((match-extract-quasiquote-vars (unquote x) k i v (#t . d))
     (match-extract-quasiquote-vars x k i v d))
    ((match-extract-quasiquote-vars (x . y) k i v d)
     (match-extract-quasiquote-vars
      x
      (match-extract-quasiquote-vars-step y k i v d) i () d))
    ((match-extract-quasiquote-vars #(x ...) k i v d)
     (match-extract-quasiquote-vars (x ...) k i v d))
    ((match-extract-quasiquote-vars x (k ...) i v d)
     (k ... v))
    ))

(define-syntax match-extract-quasiquote-vars-step
  (syntax-rules ()
    ((_ x k i v d ((v2 v2-ls) ...))
     (match-extract-quasiquote-vars x k (v2 ... . i) ((v2 v2-ls) ... . v) d))
    ))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Gimme some sugar baby.

;;> Shortcut for \scheme{lambda} + \scheme{match}.  Creates a
;;> procedure of one argument, and matches that argument against each
;;> clause.

(define-syntax match-lambda
  (syntax-rules ()
    ((_ (pattern . body) ...) (lambda (expr) (match expr (pattern . body) ...)))))

;;> Similar to \scheme{match-lambda}.  Creates a procedure of any
;;> number of arguments, and matches the argument list against each
;;> clause.

(define-syntax match-lambda*
  (syntax-rules ()
    ((_ (pattern . body) ...) (lambda expr (match expr (pattern . body) ...)))))

;;> Matches each var to the corresponding expression, and evaluates
;;> the body with all match variables in scope.  Raises an error if
;;> any of the expressions fail to match.  Syntax analogous to named
;;> let can also be used for recursive functions which match on their
;;> arguments as in \scheme{match-lambda*}.

(define-syntax match-let
  (syntax-rules ()
    ((_ ((var value) ...) . body)
     (match-let/aux () () ((var value) ...) . body))
    ((_ loop ((var init) ...) . body)
     (match-named-let loop () ((var init) ...) . body))))

(define-syntax match-let/aux
  (syntax-rules ()
    ((_ ((var expr) ...) () () . body)
     (let ((var expr) ...) . body))
    ((_ ((var expr) ...) ((pat tmp) ...) () . body)
     (let ((var expr) ...)
       (match-let* ((pat tmp) ...)
         . body)))
    ((_ (v ...) (p ...) (((a . b) expr) . rest) . body)
     (match-let/aux (v ... (tmp expr)) (p ... ((a . b) tmp)) rest . body))
    ((_ (v ...) (p ...) ((#(a ...) expr) . rest) . body)
     (match-let/aux (v ... (tmp expr)) (p ... (#(a ...) tmp)) rest . body))
    ((_ (v ...) (p ...) ((a expr) . rest) . body)
     (match-let/aux (v ... (a expr)) (p ...) rest . body))))

(define-syntax match-named-let
  (syntax-rules ()
    ((_ loop ((pat expr var) ...) () . body)
     (let loop ((var expr) ...)
       (match-let ((pat var) ...)
         . body)))
    ((_ loop (v ...) ((pat expr) . rest) . body)
     (match-named-let loop (v ... (pat expr tmp)) rest . body))))

;;> \macro{(match-let* ((var value) ...) body ...)}

;;> Similar to \scheme{match-let}, but analogously to \scheme{let*}
;;> matches and binds the variables in sequence, with preceding match
;;> variables in scope.

(define-syntax match-let*
  (syntax-rules ()
    ((_ () . body)
     (let () . body))
    ((_ ((pat expr) . rest) . body)
     (match expr (pat (match-let* rest . body))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Challenge stage - unhygienic insertion.
;;
;; It's possible to implement match-letrec without unhygienic
;; insertion by building the let+set! logic directly into the match
;; code above (passing a parameter to distinguish let vs letrec).
;; However, it makes the code much more complicated, so we religate
;; the complexity here.

;;> Similar to \scheme{match-let}, but analogously to \scheme{letrec}
;;> matches and binds the variables with all match variables in scope.

(define-syntax match-letrec
  (syntax-rules ()
    ((_ ((pat val) ...) . body)
     (match-letrec-one (pat ...) (((pat val) ...) . body) ()))))

;; 1: extract all ids in all patterns
(define-syntax match-letrec-one
  (syntax-rules ()
    ((_ (pat . rest) expr ((id tmp) ...))
     (match-extract-vars
      pat (match-letrec-one rest expr) (id ...) ((id tmp) ...)))
    ((_ () expr ((id tmp) ...))
     (match-letrec-two expr () ((id tmp) ...)))))

;; 2: rewrite ids
(define-syntax match-letrec-two
  (syntax-rules ()
    ((_ (() . body) ((var2 val2) ...) ((id tmp) ...))
     ;; We know the ids, their tmp names, and the renamed patterns
     ;; with the tmp names - expand to the classic letrec pattern of
     ;; let+set!.  That is, we bind the original identifiers written
     ;; in the source with let, run match on their renamed versions,
     ;; then set! the originals to the matched values.
     (let ((id (if #f #f)) ...)
       (match-let ((var2 val2) ...)
          (set! id tmp) ...
          . body)))
    ((_ (((var val) . rest) . body) ((var2 val2) ...) ids)
     (match-rewrite
      var
      ids
      (match-letrec-two-step (rest . body) ((var2 val2) ...) ids val)))))

(define-syntax match-letrec-two-step
  (syntax-rules ()
    ((_ next (rewrites ...) ids val var)
     (match-letrec-two next (rewrites ... (var val)) ids))))

;; This is where the work is done.  To rewrite all occurrences of any
;; id with its tmp, we need to walk the expression, using CPS to
;; restore the original structure.  We also need to be careful to pass
;; the tmp directly to the macro doing the insertion so that it
;; doesn't get renamed.  This trick was originally found by Al*
;; Petrofsky in a message titled "How to write seemingly unhygienic
;; macros using syntax-rules" sent to comp.lang.scheme in Nov 2001.

(define-syntax match-rewrite
  (syntax-rules (quote)
    ((match-rewrite (quote x) ids (k ...))
     (k ... (quote x)))
    ((match-rewrite (p . q) ids k)
     (match-rewrite p ids (match-rewrite2 q ids (match-cons k))))
    ((match-rewrite () ids (k ...))
     (k ... ()))
    ((match-rewrite p () (k ...))
     (k ... p))
    ((match-rewrite p ((id tmp) . rest) (k ...))
     (match-bound-identifier=? p id (k ... tmp) (match-rewrite p rest (k ...))))
    ))

(define-syntax match-rewrite2
  (syntax-rules ()
    ((match-rewrite2 q ids (k ...) p)
     (match-rewrite q ids (k ... p)))))

(define-syntax match-cons
  (syntax-rules ()
    ((match-cons (k ...) p q)
     (k ... (p . q)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Otherwise COND-EXPANDed bits.

(cond-expand
 (chibi
  (define-syntax match-check-ellipsis
    (er-macro-transformer
     (lambda (expr rename compare)
       (if (compare '... (cadr expr))
           (car (cddr expr))
           (cadr (cddr expr))))))
  (define-syntax match-check-identifier
    (er-macro-transformer
     (lambda (expr rename compare)
       (if (identifier? (cadr expr))
           (car (cddr expr))
           (cadr (cddr expr))))))
  (define-syntax match-bound-identifier=?
    (er-macro-transformer
     (lambda (expr rename compare)
       (if (eq? (cadr expr) (car (cddr expr)))
           (cadr (cddr expr))
           (car (cddr (cddr expr)))))))
  (define-syntax match-bound-identifier-memv
    (er-macro-transformer
     (lambda (expr rename compare)
       (if (memv (cadr expr) (car (cddr expr)))
           (cadr (cddr expr))
           (car (cddr (cddr expr))))))))

 (chicken
  (define-syntax match-check-ellipsis
    (er-macro-transformer
     (lambda (expr rename compare)
       (if (compare '... (cadr expr))
           (car (cddr expr))
           (cadr (cddr expr))))))
  (define-syntax match-check-identifier
    (er-macro-transformer
     (lambda (expr rename compare)
       (if (and (symbol? (cadr expr)) (not (keyword? (cadr expr))))
           (car (cddr expr))
           (cadr (cddr expr))))))
  (define-syntax match-bound-identifier=?
    (er-macro-transformer
     (lambda (expr rename compare)
       (if (eq? (cadr expr) (car (cddr expr)))
           (cadr (cddr expr))
           (car (cddr (cddr expr)))))))
  (define-syntax match-bound-identifier-memv
    (er-macro-transformer
     (lambda (expr rename compare)
       (if (memv (cadr expr) (car (cddr expr)))
           (cadr (cddr expr))
           (car (cddr (cddr expr))))))))

 (else
  ;; Portable versions
  ;;
  ;; This is the R7RS version.  For other standards, and
  ;; implementations not yet up-to-spec we have to use some tricks.
  ;;
  ;;   (define-syntax match-check-ellipsis
  ;;     (syntax-rules (...)
  ;;       ((_ ... sk fk) sk)
  ;;       ((_ x sk fk) fk)))
  ;;
  ;; This is a little more complicated, and introduces a new let-syntax,
  ;; but should work portably in any R[56]RS Scheme.  Taylor Campbell
  ;; originally came up with the idea.
  (define-syntax match-check-ellipsis
    (syntax-rules ()
      ;; these two aren't necessary but provide fast-case failures
      ((match-check-ellipsis (a . b) success-k failure-k) failure-k)
      ((match-check-ellipsis #(a ...) success-k failure-k) failure-k)
      ;; matching an atom
      ((match-check-ellipsis id success-k failure-k)
       (let-syntax ((ellipsis? (syntax-rules ()
                                 ;; iff `id' is `...' here then this will
                                 ;; match a list of any length
                                 ((ellipsis? (foo id) sk fk) sk)
                                 ((ellipsis? other sk fk) fk))))
         ;; this list of three elements will only match the (foo id) list
         ;; above if `id' is `...'
         (ellipsis? (a b c) success-k failure-k)))))

  ;; This is portable but can be more efficient with non-portable
  ;; extensions.  This trick was originally discovered by Oleg Kiselyov.
  (define-syntax match-check-identifier
    (syntax-rules ()
      ;; fast-case failures, lists and vectors are not identifiers
      ((_ (x . y) success-k failure-k) failure-k)
      ((_ #(x ...) success-k failure-k) failure-k)
      ;; x is an atom
      ((_ x success-k failure-k)
       (let-syntax
           ((sym?
             (syntax-rules ()
               ;; if the symbol `abracadabra' matches x, then x is a
               ;; symbol
               ((sym? x sk fk) sk)
               ;; otherwise x is a non-symbol datum
               ((sym? y sk fk) fk))))
         (sym? abracadabra success-k failure-k)))))

  ;; This check is inlined in some cases above, but included here for
  ;; the convenience of match-rewrite.
  (define-syntax match-bound-identifier=?
    (syntax-rules ()
      ((match-bound-identifier=? a b sk fk)
       (let-syntax ((b (syntax-rules ())))
         (let-syntax ((eq (syntax-rules (b)
                            ((eq b) sk)
                            ((eq _) fk))))
           (eq a))))))

  ;; Variant of above for a list of ids.
  (define-syntax match-bound-identifier-memv
    (syntax-rules ()
      ((match-bound-identifier-memv a (id ...) sk fk)
       (match-check-identifier
        a
        (let-syntax
            ((memv?
              (syntax-rules (id ...)
                ((memv? a sk2 fk2) fk2)
                ((memv? anything-else sk2 fk2) sk2))))
          (memv? random-sym-to-match sk fk))
        fk))))
  ))

;;> Utilities for gathering statistics on the heap.  Just measuring
;;> runtime memory usage doesn't give a good idea of how to optimize
;;> that usage, so this module is provided for profiling.

;;> \procedure{(heap-stats)}

;;> Returns an alist summarizing all heap allocated objects.  The
;;> \var{car} of each cell is the type-name, and the \var{cdr} is the
;;> count of objects of that type in the heap.  Garbage is collected
;;> before the counts are taken.

;;> \procedure{(heap-dump [depth])}

;;> Returns the same value as \scheme{(heap-stats)}, but also prints
;;> all objects on the heap as it runs.  \var{depth} indicates the
;;> printing depth for compound objects and defaults to 1.

;;> These functions just return \scheme{'()} when using the Boehm GC.

(define-library (chibi heap-stats)
  (export heap-stats heap-sizes heap-dump free-sizes)
  (import (chibi))
  (include-shared "heap-stats"))
;; regexp.scm -- simple non-bactracking NFA implementation
;; Copyright (c) 2013-2016 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

;;; An rx represents a start state and meta-info such as the number
;;; and names of submatches.
(define-record-type Rx
  (make-rx start-state num-matches num-save-indexes non-greedy-indexes
           match-rules match-names sre)
  regexp?
  (start-state rx-start-state rx-start-state-set!)
  (num-matches rx-num-matches rx-num-matches-set!)
  (num-save-indexes rx-num-save-indexes rx-num-save-indexes-set!)
  (non-greedy-indexes rx-non-greedy-indexes rx-non-greedy-indexes-set!)
  (match-rules rx-rules rx-rules-set!)
  (match-names rx-names rx-names-set!)
  (sre regexp->sre))

;; Syntactic sugar.
(define-syntax rx
  (syntax-rules ()
    ((rx sre ...)
     (regexp `(: sre ...)))))

;;; A state is a single nfa state with transition rules.
(define-record-type State
  (%make-state accept? chars match match-rule next1 next2 id)
  state?
  ;; A boolean indicating if this is an accepting state.
  (accept? state-accept? state-accept?-set!)
  ;; A char or char-set indicating when we can transition.
  ;; Alternately, #f indicates an epsilon transition, while a
  ;; procedure of the form (lambda (ch i matches) ...) is a predicate
  ;; which should return #t if the char matches.
  (chars state-chars state-chars-set!)
  ;; A single integer indicating the match position to record.
  (match state-match state-match-set!)
  ;; The rule for merging ambiguous matches.  Can be any of: left,
  ;; right, (list i j).  Posix semantics are equivalent to using left
  ;; for the beginning of a submatch and right for the end.  List is
  ;; used to capture a list of submatch data in the current match.
  (match-rule state-match-rule state-match-rule-set!)
  ;; The destination if the char match succeeds.
  (next1 state-next1 state-next1-set!)
  ;; An optional additional transition used for forking to two states.
  (next2 state-next2 state-next2-set!)
  ;; A unique (per regexp) id for debugging.
  (id state-id))

(define (make-state accept? chars match match-rule next1 next2 id)
  (if (and next1 (not (state? next1)))
      (error "expected a state" next1))
  (if (and next2 (not (state? next2)))
      (error "expected a state" next2))
  (%make-state accept? chars match match-rule next1 next2 id))

(define ~none 0)
(define ~ci? 1)
(define ~ascii? 2)
(define ~nocapture? 4)

(define (flag-set? flags i) (= i (bitwise-and flags i)))
(define (flag-join a b) (if b (bitwise-ior a b) a))
(define (flag-clear a b) (bitwise-and a (bitwise-not b)))

(define (char-set-ci cset)
  (char-set-fold
   (lambda (ch res)
     (char-set-adjoin! (char-set-adjoin! res (char-upcase ch))
                       (char-downcase ch)))
   (char-set)
   cset))

(define (make-char-state ch flags next id)
  (if (flag-set? flags ~ci?)
      (let ((cset (cond ((char? ch) (char-set-ci (char-set ch)))
                        ((char-set? ch) (char-set-ci ch))
                        (else ch))))
        (make-state #f cset #f #f next #f id))
      (make-state #f ch #f #f next #f id)))
(define (make-fork-state next1 next2 id)
  (make-state #f #f #f #f next1 next2 id))
(define (make-epsilon-state next id)
  (make-fork-state next #f id))
(define (make-accept-state id)
  (make-state #t #f #f #f #f #f id))

;; A record holding the current match data - essentially a wrapper
;; around a vector, plus a reference to the RX for meta-info.
(define-record-type Regexp-Match
  (%make-regexp-match matches rx string)
  regexp-match?
  (matches regexp-match-matches regexp-match-matches-set!)
  (rx regexp-match-rx)
  (string regexp-match-string))

(define (regexp-match-rules md)
  (rx-rules (regexp-match-rx md)))
(define (regexp-match-names md)
  (rx-names (regexp-match-rx md)))
(define (make-regexp-match len rx str)
  (%make-regexp-match (make-vector len #f) rx str))
(define (make-regexp-match-for-rx rx str)
  (make-regexp-match (rx-num-save-indexes rx) rx str))
(define (regexp-match-count md)
  (- (quotient (vector-length (regexp-match-matches md)) 2) 1))

(define (regexp-match-name-offset md name)
  (let lp ((ls (regexp-match-names md)) (first #f))
    (cond
     ((null? ls) (or first (error "unknown match name" md name)))
     ((eq? name (caar ls))
      (if (regexp-match-submatch-start+end md (cdar ls))
          (cdar ls)
          (lp (cdr ls) (or first (cdar ls)))))
     (else (lp (cdr ls) first)))))

(define (regexp-match-ref md n)
  (vector-ref (regexp-match-matches md)
              (if (integer? n)
                  n
                  (regexp-match-name-offset md n))))

(define (regexp-match-set! md n val)
  (vector-set! (regexp-match-matches md) n val))

(define (copy-regexp-match md)
  (let* ((src (regexp-match-matches md))
         (len (vector-length src))
         (dst (make-vector len #f)))
    (do ((i 0 (+ i 1)))
        ((= i len)
         (%make-regexp-match dst (regexp-match-rx md) (regexp-match-string md)))
      (vector-set! dst i (vector-ref src i)))))

;;> Returns the matching result for the given named or indexed
;;> submatch \var{n}, possibly as a list for a submatch-list, or
;;> \scheme{#f} if not matched.

(define (regexp-match-submatch/list md n)
  (let ((n (if (integer? n) n (regexp-match-name-offset md n))))
    (cond
     ((>= n (vector-length (regexp-match-rules md)))
      #f)
     (else
      (let ((rule (vector-ref (regexp-match-rules md) n)))
        (cond
         ((pair? rule)
          (let ((start (regexp-match-ref md (car rule)))
                (end (regexp-match-ref md (cdr rule)))
                (str (regexp-match-string md)))
            (and start end (substring-cursor str start end))))
         (else
          (let ((res (regexp-match-ref md rule)))
            (if (pair? res)
                (reverse res)
                res)))))))))

;;> Returns the matching substring for the given named or indexed
;;> submatch \var{n}, or \scheme{#f} if not matched.

(define (regexp-match-submatch md n)
  (let ((res (regexp-match-submatch/list md n)))
    (if (pair? res) (car res) res)))

(define (regexp-match-submatch-start+end md n)
  (let ((n (if (integer? n) n (regexp-match-name-offset md n))))
    (and (< n (vector-length (regexp-match-rules md)))
         (let ((rule (vector-ref (regexp-match-rules md) n)))
           (if (pair? rule)
               (let ((start (regexp-match-ref md (car rule)))
                     (end (regexp-match-ref md (cdr rule)))
                     (str (regexp-match-string md)))
                 (and start end
                      (cons (string-cursor->index str start)
                            (string-cursor->index str end))))
               #f)))))

;;> Returns the start index for the given named or indexed submatch
;;> \var{n}, or \scheme{#f} if not matched.

(define (regexp-match-submatch-start md n)
  (cond ((regexp-match-submatch-start+end md n) => car) (else #f)))

;;> Returns the end index for the given named or indexed submatch
;;> \var{n}, or \scheme{#f} if not matched.

(define (regexp-match-submatch-end md n)
  (cond ((regexp-match-submatch-start+end md n) => cdr) (else #f)))

(define (regexp-match-convert recurse? md str)
  (cond
   ((vector? md)
    (let lp ((i 0) (res '()))
      (cond
       ((>= i (vector-length md))
        (reverse res))
       ((string-cursor? (vector-ref md i))
        (lp (+ i 2)
            (cons (substring-cursor str
                                    (vector-ref md i)
                                    (vector-ref md (+ i 1)))
                  res)))
       (else
        (lp (+ i 1)
            (cons (regexp-match-convert recurse? (vector-ref md i) str)
                  res))))))
   ((list? md)
    (if recurse?
        (map (lambda (x) (regexp-match-convert recurse? x str)) (reverse md))
        (regexp-match-convert recurse? (car md) str)))
   ((and (pair? md) (string-cursor? (car md)) (string-cursor? (cdr md)))
    (substring-cursor str (car md) (cdr md)))
   ((regexp-match? md)
    (regexp-match-convert
     recurse? (regexp-match-matches md) (regexp-match-string md)))
   (else
    md)))

;;> Convert an regexp-match result to a list of submatches, beginning
;;> with the full match, using \scheme{#f} for unmatched submatches.

(define (regexp-match->list md)
  (regexp-match-convert #f md #f))

;;> Convert an regexp-match result to a forest of submatches, beginning
;;> with the full match, using \scheme{#f} for unmatched submatches.

(define (regexp-match->sexp md)
  (regexp-match-convert #t md #f))

;; Collect results from a list match.
(define (match-collect md spec)
  (define (match-extract md n)
    (let* ((vec (regexp-match-matches md))
           (rules (regexp-match-rules md))
           (n-rule (vector-ref rules n))
           (rule (vector-ref rules n-rule)))
      (if (pair? rule)
          (let ((start (regexp-match-ref md (car rule)))
                (end (regexp-match-ref md (cdr rule))))
            (and start end (cons start end)))
          (regexp-match-ref md rule))))
  (let ((end (cadr spec))
        (vec (regexp-match-matches md)))
    (let lp ((i (+ 1 (car spec)))
             (ls '()))
      (if (>= i end)
          (reverse ls)
          (lp (+ i 1) (cons (match-extract md i) ls))))))

;; A searcher represents a single rx state and match information.
(define-record-type Searcher
  (make-searcher state matches)
  searcher?
  (state searcher-state searcher-state-set!)
  (matches searcher-matches searcher-matches-set!))

;; Merge two regexp-matches, preferring the leftmost-longest of their
;; matches, or shortest for non-greedy matches.
(define (regexp-match>=? m1 m2)
  (let ((non-greedy-indexes (rx-non-greedy-indexes (regexp-match-rx m1)))
        (end (- (vector-length (regexp-match-matches m1)) 1)))
    (let lp ((i 0))
      (cond
       ((>= i end)
        #t)
       ((and (eqv? (regexp-match-ref m1 i)
                   (regexp-match-ref m2 i))
             (eqv? (regexp-match-ref m1 (+ i 1))
                   (regexp-match-ref m2 (+ i 1))))
        (lp (+ i 2)))
       (else
        (not
         (and (string-cursor? (regexp-match-ref m2 i))
              (or (not (string-cursor? (regexp-match-ref m1 i)))
                  (string-cursor<? (regexp-match-ref m2 i)
                                   (regexp-match-ref m1 i))
                  ;; sanity check for incompletely advanced epsilons
                  (and (string-cursor? (regexp-match-ref m1 (+ i 1)))
                       (string-cursor<? (regexp-match-ref m1 (+ i 1))
                                        (regexp-match-ref m1 i)))
                  ((if (memq (+ i 1) non-greedy-indexes) not values)
                   (and
                    (string-cursor=? (regexp-match-ref m2 i)
                                     (regexp-match-ref m1 i))
                    (or (not (string-cursor? (regexp-match-ref m2 (+ i 1))))
                        (and (string-cursor? (regexp-match-ref m1 (+ i 1)))
                             (string-cursor>?
                              (regexp-match-ref m2 (+ i 1))
                              (regexp-match-ref m1 (+ i 1)))))))))))))))

(define (regexp-match-max m1 m2)
  (if (regexp-match>=? m1 m2) m1 m2))

;; Merge match data from sr2 into sr1, preferring the leftmost-longest
;; match in the event of a conflict.
(define (searcher-merge! sr1 sr2)
  (let ((m (regexp-match-max (searcher-matches sr1) (searcher-matches sr2))))
    (if (not (eq? m (searcher-matches sr1)))
        (searcher-matches-set! sr1 (copy-regexp-match m)))))

(define (searcher-max sr1 sr2)
  (if (or (not (searcher? sr2))
          (regexp-match>=? (searcher-matches sr1) (searcher-matches sr2)))
      sr1
      sr2))

(define (searcher-start-match sr)
  (regexp-match-ref (searcher-matches sr) 0))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; A posse is a group of searchers.

(define (make-posse . o)
  (make-hash-table eq?))

(define posse? hash-table?)
(define (posse-empty? posse) (zero? (hash-table-size posse)))

(define (posse-ref posse sr)
  (hash-table-ref/default posse (searcher-state sr) #f))
(define (posse-add! posse sr)
  (hash-table-set! posse (searcher-state sr) sr))
(define (posse-clear! posse)
  (hash-table-walk posse (lambda (key val) (hash-table-delete! posse key))))
(define (posse-for-each proc posse)
  (hash-table-walk posse (lambda (key val) (proc val))))
(define (posse-every pred posse)
  (hash-table-fold posse (lambda (key val acc) (and acc (pred val))) #t))

(define (posse->list posse)
  (hash-table-values posse))
(define (list->posse ls)
  (let ((searchers (make-posse)))
    (for-each (lambda (sr) (posse-add! searchers sr)) ls)
    searchers))
(define (posse . args)
  (list->posse args))

(define (make-start-searcher rx str)
  (make-searcher (rx-start-state rx) (make-regexp-match-for-rx rx str)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Execution

;; A transition which doesn't advance the index.

(define (epsilon-state? st)
  (or (not (state-chars st))
      (procedure? (state-chars st))))

;; Match the state against a char and index.

(define (state-matches? st str i ch start end matches)
  (let ((matcher (state-chars st)))
    (cond
     ((char? matcher)
      (eqv? matcher ch))
     ((char-set? matcher)
      (char-set-contains? matcher ch))
     ((pair? matcher)
      (and (char<=? (car matcher) ch) (char<=? ch (cdr matcher))))
     ((procedure? matcher)
      (matcher str i ch start end matches))
     ((not matcher))
     (else
      (error "unknown state matcher" (state-chars st))))))

;; Advance epsilons together - if the State is newly added to the
;; group and is an epsilon state, recursively add the transition.

(define (posse-advance! new seen accept sr str i start end)
  (let advance! ((sr sr))
    (let ((st (searcher-state sr)))
      ;; Update match data.
      (cond
       ((state-match st)
        (let* ((index (state-match st))
               (matches (searcher-matches sr))
               (before (copy-regexp-match matches)))
          (cond
           ((pair? index)
            ;; Submatch list, accumulate and push.
            (let* ((prev (regexp-match-ref matches (car index)))
                   (new (cons (match-collect matches (cdr index))
                              (if (pair? prev) prev '()))))
              (regexp-match-set! matches (car index) new)))
           ((not (and (eq? 'non-greedy-left (state-match-rule st))
                      (regexp-match-ref matches index)
                      (string-cursor>=? (regexp-match-ref matches index)
                                        (regexp-match-ref matches (- index 1)))))
            (regexp-match-set! matches index i))))))
      ;; Follow transitions.
      (cond
       ((state-accept? st)
        (set-cdr! accept (searcher-max sr (cdr accept))))
       ((posse-ref seen sr)
        => (lambda (sr-prev) (searcher-merge! sr-prev sr)))
       ((epsilon-state? st)
        (let ((ch (and (string-cursor<? i end) (string-cursor-ref str i))))
          ;; Epsilon transition.  If there is a procedure matcher,
          ;; it's a guarded epsilon and needs to be checked.
          (cond
           ((state-matches? st str i ch start end (searcher-matches sr))
            (posse-add! seen sr)
            (let* ((next1 (state-next1 st))
                   (next2 (state-next2 st))
                   (matches
                    (and next2 (searcher-matches sr))))
              (cond
               (next1
                (searcher-state-set! sr next1)
                (advance! (make-searcher next1 (copy-regexp-match (searcher-matches sr))))))
              (cond
               (next2
                (let ((sr2 (make-searcher next2 (copy-regexp-match matches))))
                  (advance! sr2)))))))))
       ;; Non-special, non-epsilon searcher, add to posse.
       ((posse-ref new sr)
        ;; Merge regexp-match for existing searcher.
        => (lambda (sr-prev) (searcher-merge! sr-prev sr)))
       (else
        ;; Add new searcher.
        (posse-add! new sr))))))

;; Run so long as there is more to match.

(define (regexp-run-offsets search? rx str start end)
  (let ((rx (regexp rx))
        (epsilons (posse))
        (accept (list #f)))
    (let lp ((i start)
             (searchers1 (posse))
             (searchers2 (posse)))
      ;; Advance initial epsilons once from the first index, or every
      ;; time when searching.
      (cond
       ((or search? (string-cursor=? i start))
        (posse-advance! searchers1 epsilons accept (make-start-searcher rx str)
                        str i start end)
        (posse-clear! epsilons)))
      (cond
       ((or (string-cursor>=? i end)
            (and search?
                 (searcher? (cdr accept))
                 (let ((accept-start (searcher-start-match (cdr accept))))
                   (posse-every
                    (lambda (searcher)
                      (string-cursor>? (searcher-start-match searcher)
                                       accept-start))
                    searchers1)))
            (and (not search?)
                 (posse-empty? searchers1)))
        ;; Terminate when the string is done or there are no more
        ;; searchers.  If we terminate prematurely and are not
        ;; searching, return false.
        (and (searcher? (cdr accept))
             (let ((matches (searcher-matches (cdr accept))))
               (and (or search? (string-cursor>=? (regexp-match-ref matches 1)
                                                  end))
                    (searcher-matches (cdr accept))))))
       (else
        ;; Otherwise advance normally.
        (let ((ch (string-cursor-ref str i))
              (i2 (string-cursor-next str i)))
          (posse-for-each  ;; NOTE: non-deterministic from hash order
           (lambda (sr)
             (cond
              ((state-matches? (searcher-state sr) str i ch
                               start end (searcher-matches sr))
               (searcher-state-set! sr (state-next1 (searcher-state sr)))
               ;; Epsilons are considered at the next position.
               (posse-advance! searchers2 epsilons accept sr str i2 start end)
               (posse-clear! epsilons))))
           searchers1)
          (posse-clear! searchers1)
          (lp i2 searchers2 searchers1)))))))

;; Wrapper to determine start and end offsets.

(define (regexp-run search? rx str . o)
  (let ((start (string-start-arg str o))
        (end (string-end-arg str (if (pair? o) (cdr o) o))))
    (regexp-run-offsets search? rx str start end)))

;;> Match the given regexp or SRE against the entire string and return
;;> the match data on success.  Returns \scheme{#f} on failure.

(define (regexp-matches rx str . o)
  (apply regexp-run #f rx str o))

;;> Match the given regexp or SRE against the entire string and return
;;> the \scheme{#t} on success.  Returns \scheme{#f} on failure.

(define (regexp-matches? rx str . o)
  (and (apply regexp-matches rx str o) #t))

;;> Search for the given regexp or SRE within string and return
;;> the match data on success.  Returns \scheme{#f} on failure.

(define (regexp-search rx str . o)
  (apply regexp-run #t rx str o))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Compiling

(define (parse-flags ls)
  (define (symbol->flag s)
    (case s ((i ci case-insensitive) ~ci?) (else ~none)))
  (let lp ((ls ls) (res ~none))
    (if (not (pair? ls))
        res
        (lp (cdr ls) (flag-join res (symbol->flag (car ls)))))))

(define char-set:nonl
  (char-set-difference char-set:full (char-set #\newline)))
(define char-set:control (ucs-range->char-set 0 32))
(define char-set:word-constituent
  (char-set-union char-set:letter char-set:digit (char-set #\_)))
(define %char-set:word-constituent
  (char-set-union %char-set:letter %char-set:digit (char-set #\_)))
(define (char-word-constituent? ch)
  (char-set-contains? char-set:word-constituent ch))
(define get-char-set:cased
  (let ((char-set:cased #f))
    (lambda ()
      (if (not char-set:cased)
          (set! char-set:cased
                (char-set-union char-set:upper-case
                                char-set:lower-case
                                char-set:title-case)))
      char-set:cased)))

(define (match/bos str i ch start end matches)
  (string-cursor=? i start))
(define (match/eos str i ch start end matches)
  (string-cursor>=? i end))
(define (match/bol str i ch start end matches)
  (or (string-cursor=? i start)
      (eqv? #\newline (string-cursor-ref str (string-cursor-prev str i)))))
(define (match/eol str i ch start end matches)
  (or (string-cursor>=? i end)
      (eqv? #\newline (string-cursor-ref str i))))
(define (match/bow str i ch start end matches)
  (and (string-cursor<? i end)
       (or (string-cursor=? i start)
           (not (char-word-constituent?
                 (string-cursor-ref str (string-cursor-prev str i)))))
       (char-word-constituent? ch)))
(define (match/eow str i ch start end matches)
  (and (or (string-cursor>=? i end)
           (not (char-word-constituent? ch)))
       (string-cursor>? i start)
       (char-word-constituent?
        (string-cursor-ref str (string-cursor-prev str i)))))
(define (match/nwb str i ch start end matches)
  (and (not (match/bow str i ch start end matches))
       (not (match/eow str i ch start end matches))))
(define (match/bog str i ch start end matches)
  (and (string-cursor<? i end)
       (or (string-cursor=? i start)
           (match/eog str (string-cursor-prev str i) ch start end matches))))
(define (match/eog str i ch start end matches)
  (and (string-cursor>? i start)
       (or (string-cursor>=? i end)
           (let* ((sci (string-cursor->index str i))
                  (sce (string-cursor->index str end))
                  (m (regexp-search re:grapheme str sci sce)))
             (and m (<= (regexp-match-submatch-end m 0) sci))))))

(define (lookup-char-set name flags)
  (cond
   ((flag-set? flags ~ascii?)
    (case name
      ((any) char-set:full)
      ((nonl) char-set:nonl)
      ((lower-case lower)
       (if (flag-set? flags ~ci?) %char-set:letter %char-set:lower-case))
      ((upper-case upper)
       (if (flag-set? flags ~ci?) %char-set:letter %char-set:upper-case))
      ((title-case title)
       (if (flag-set? flags ~ci?) %char-set:letter (char-set)))
      ((alphabetic alpha) %char-set:letter)
      ((numeric num digit) %char-set:digit)
      ((alphanumeric alphanum alnum) %char-set:letter+digit)
      ((punctuation punct) %char-set:punctuation)
      ((symbol) %char-set:symbol)
      ((graphic graph) %char-set:graphic)
      ((word-constituent) %char-set:word-constituent)
      ((whitespace white space) %char-set:whitespace)
      ((printing print) %char-set:printing)
      ((control cntrl) %char-set:iso-control)
      ((hex-digit xdigit hex) char-set:hex-digit)
      ((ascii) char-set:ascii)
      (else #f)))
   (else
    (case name
      ((any) char-set:full)
      ((nonl) char-set:nonl)
      ((lower-case lower)
       (if (flag-set? flags ~ci?) (get-char-set:cased) char-set:lower-case))
      ((upper-case upper)
       (if (flag-set? flags ~ci?) (get-char-set:cased) char-set:upper-case))
      ((title-case title)
       (if (flag-set? flags ~ci?) (get-char-set:cased) char-set:title-case))
      ((alphabetic alpha) char-set:letter)
      ((numeric num digit) char-set:digit)
      ((alphanumeric alphanum alnum) char-set:letter+digit)
      ((punctuation punct) char-set:punctuation)
      ((symbol) char-set:symbol)
      ((graphic graph) char-set:graphic)
      ((word-constituent) char-set:word-constituent)
      ((whitespace white space) char-set:whitespace)
      ((printing print) char-set:printing)
      ((control cntrl) char-set:control)
      ((hex-digit xdigit hex) char-set:hex-digit)
      ((ascii) char-set:ascii)
      (else #f)))))

(define (sre-flatten-ranges orig-ls)
  (let lp ((ls orig-ls) (res '()))
    (cond
     ((null? ls)
      (reverse res))
     ((string? (car ls))
      (lp (append (string->list (car ls)) (cdr ls)) res))
     ((null? (cdr ls))
      (error "unbalanced cset / range" orig-ls))
     ((string? (cadr ls))
      (lp (cons (car ls) (append (string->list (cadr ls)) (cddr ls))) res))
     (else
      (lp (cddr ls) (cons (cons (car ls) (cadr ls)) res))))))

(define (every pred ls)
  (or (null? ls) (and (pred (car ls)) (every pred (cdr ls)))))

(define (char-set-sre? sre)
  (or (char? sre)
      (and (string? sre) (= 1 (string-length sre)))
      (lookup-char-set sre ~none)
      (and (pair? sre)
           (or (string? (car sre))
               (memq (car sre)
                     '(char-set / char-range & and ~ complement - difference))
               (and (memq (car sre)
                          '(|\|| or w/case w/nocase w/unicode w/ascii))
                    (every char-set-sre? (cdr sre)))))))

(define (non-greedy-sre? sre)
  (and (pair? sre)
       (or (memq (car sre) '(?? *? **? non-greedy-optional
                             non-greedy-zero-or-more non-greedy-repeated))
           (and (memq (car sre) '(: seq w/case w/nocase w/unicode w/ascii))
                (non-greedy-sre? (car (reverse sre))))
           (and (eq? (car sre) 'or)
                (any non-greedy-sre? (cdr sre))))))

(define (valid-sre? x)
  (guard (exn (else #f)) (regexp x) #t))

(define (sre->char-set sre . o)
  (let ((flags (if (pair? o) (car o) ~none)))
    (define (->cs sre) (sre->char-set sre flags))
    (define (maybe-ci sre)
      (if (flag-set? flags ~ci?) (char-set-ci sre) sre))
    (cond
     ((lookup-char-set sre flags))
     ((char-set? sre) (maybe-ci sre))
     ((char? sre) (maybe-ci (char-set sre)))
     ((string? sre)
      (if (= 1 (string-length sre))
          (maybe-ci (string->char-set sre))
          (error "only single char strings can be char-sets")))
     ((pair? sre)
      (if (string? (car sre))
          (maybe-ci (string->char-set (car sre)))
          (case (car sre)
            ((char-set) (if (null? (cddr sre))
                            (maybe-ci (string->char-set (cadr sre)))
                            (error "(char-set) takes only one char-set" sre)))
            ((/ char-range)
             (->cs
              `(or ,@(map (lambda (x)
                            (ucs-range->char-set
                             (char->integer (car x))
                             (+ 1 (char->integer (cdr x)))))
                          (sre-flatten-ranges (cdr sre))))))
            ((& and) (apply char-set-intersection (map ->cs (cdr sre))))
            ((|\|| or) (apply char-set-union (map ->cs (cdr sre))))
            ((~ complement) (char-set-complement (->cs `(or ,@(cdr sre)))))
            ((- difference) (char-set-difference (->cs (cadr sre))
                                                 (->cs `(or ,@(cddr sre)))))
            ((w/case) (if (null? (cddr sre))
                          (sre->char-set (cadr sre) (flag-clear flags ~ci?))
                          (error "w/case takes only one char-set" sre)))
            ((w/nocase) (if (null? (cddr sre))
                            (sre->char-set (cadr sre) (flag-join flags ~ci?))
                            (error "w/nocase takes only one char-set" sre)))
            ((w/ascii) (if (null? (cddr sre))
                           (sre->char-set (cadr sre) (flag-join flags ~ascii?))
                           (error "w/ascii takes only one char-set" sre)))
            ((w/unicode) (if (null? (cddr sre))
                             (sre->char-set (cadr sre) (flag-clear flags ~ascii?))
                             (error "w/unicode takes only one char-set" sre)))
            (else (error "invalid sre char-set" sre)))))
     (else (error "invalid sre char-set" sre)))))

(define (char-set->sre cset)
  (list (char-set->string cset)))

(define (strip-submatches sre)
  (if (pair? sre)
      (case (car sre)
        (($ submatch) (strip-submatches (cons ': (cdr sre))))
        ((-> => submatch-named) (strip-submatches (cons ': (cddr sre))))
        (else (cons (strip-submatches (car sre))
                    (strip-submatches (cdr sre)))))
      sre))

(define (sre-expand-reps from to sre)
  (let ((sre0 (strip-submatches sre)))
    (let lp ((i 0) (res '(:)))
      (if (= i from)
          (cond
           ((not to)
            (reverse (cons `(* ,sre) res)))
           ((= from to)
            (reverse (cons sre (cdr res))))
           (else
            (let lp ((i (+ i 1)) (res res))
              (if (>= i to)
                  (reverse (cons `(? ,sre) res))
                  (lp (+ i 1) (cons `(? ,sre0) res))))))
          (lp (+ i 1) (cons sre0 res))))))

;;> Compile an \var{sre} into a regexp.

(define (regexp sre . o)
  (define current-index 2)
  (define current-match 0)
  (define current-id 0)
  (define match-names '())
  (define match-rules (list (cons 0 1)))
  (define non-greedy-indexes '())
  (define (next-id)
    (let ((res current-id)) (set! current-id (+ current-id 1)) res))
  (define (make-submatch-state sre flags next index)
    (let* ((n3 (make-epsilon-state next (next-id)))
           (n2 (->rx sre flags n3))
           (n1 (make-epsilon-state n2 (next-id)))
           (non-greedy? (non-greedy-sre? sre)))
      (state-match-set! n1 index)
      (state-match-rule-set! n1 'left)
      (state-match-set! n3 (+ index 1))
      (state-match-rule-set! n3 (if non-greedy? 'non-greedy-left 'right))
      (if non-greedy?
          (set! non-greedy-indexes (cons (+ index 1) non-greedy-indexes)))
      n1))
  (define (->rx sre flags next)
    (cond
     ;; The base cases chars and strings match literally.
     ((char? sre)
      (make-char-state sre flags next (next-id)))
     ((char-set? sre)
      (make-char-state sre flags next (next-id)))
     ((string? sre)
      (->rx (cons 'seq (string->list sre)) flags next))
     ((and (symbol? sre) (lookup-char-set sre flags))
      => (lambda (cset) (make-char-state cset ~none next (next-id))))
     ((symbol? sre)
      (case sre
        ((epsilon) next)
        ((bos) (make-char-state match/bos flags next (next-id)))
        ((eos) (make-char-state match/eos flags next (next-id)))
        ((bol) (make-char-state match/bol flags next (next-id)))
        ((eol) (make-char-state match/eol flags next (next-id)))
        ((bow) (make-char-state match/bow flags next (next-id)))
        ((eow) (make-char-state match/eow flags next (next-id)))
        ((nwb) (make-char-state match/nwb flags next (next-id)))
        ((bog) (make-char-state match/bog flags next (next-id)))
        ((eog) (make-char-state match/eog flags next (next-id)))
        ((grapheme)
         (->rx
          `(or (: (* ,char-set:hangul-l) (+ ,char-set:hangul-v)
                  (* ,char-set:hangul-t))
               (: (* ,char-set:hangul-l) ,char-set:hangul-v
                  (* ,char-set:hangul-v) (* ,char-set:hangul-t))
               (: (* ,char-set:hangul-l) ,char-set:hangul-lvt
                  (* ,char-set:hangul-t))
               (+ ,char-set:hangul-l)
               (+ ,char-set:hangul-t)
               (+ ,char-set:regional-indicator)
               (: "\r\n")
               (: (~ control ("\r\n"))
                  (* ,char-set:extend-or-spacing-mark))
               control)
          flags
          next))
        ((word) (->rx '(word+ any) flags next))
        (else (error "unknown sre" sre))))
     ((pair? sre)
      (case (car sre)
        ((seq :)
         ;; Sequencing.  An empty sequence jumps directly to next,
         ;; otherwise we join the first element to the sequence formed
         ;; of the remaining elements followed by next.
         (if (null? (cdr sre))
             next
             ;; Make a dummy intermediate to join the states so that
             ;; we can generate n1 first, preserving the submatch order.
             (let* ((n2 (make-epsilon-state #f (next-id)))
                    (n1 (->rx (cadr sre) flags n2))
                    (n3 (->rx (cons 'seq (cddr sre)) flags next)))
               (state-next1-set! n2 n3)
               n1)))
        ((or |\||)
         ;; Alternation.  An empty alternation always fails.
         ;; Otherwise we fork between any of the alternations, each
         ;; continuing to next.
         (cond
          ((null? (cdr sre))
           #f)
          ((char-set-sre? sre)
           (make-char-state (sre->char-set sre) flags next (next-id)))
          ((null? (cddr sre))
           (->rx (cadr sre) flags next))
          (else
           (let* ((n1 (->rx (cadr sre) flags next))
                  (n2 (->rx (cons 'or (cddr sre)) flags next)))
             (make-fork-state n1 n2 (next-id))))))
        ((? optional ?? non-greedy-optional)
         ;; Optionality.  Either match the body or fork to the next
         ;; state directly.
         (make-fork-state (->rx (cons 'seq (cdr sre)) flags next)
                          next (next-id)))
        ((* zero-or-more *? non-greedy-zero-or-more)
         ;; Repetition.  Introduce two fork states which can jump from
         ;; the end of the loop to the beginning and from the
         ;; beginning to the end (to skip the first iteration).
         (let* ((n2 (make-fork-state next #f (next-id)))
                (n1 (make-fork-state (->rx (cons 'seq (cdr sre)) flags n2)
                                     n2 (next-id))))
           (state-next2-set! n2 n1)
           n1))
        ((+ one-or-more)
         ;; One-or-more repetition.  Same as above but the first
         ;; transition is required so the rx is simpler - we only
         ;; need one fork from the end of the loop to the beginning.
         (let* ((n2 (make-fork-state next #f (next-id)))
                (n1 (->rx (cons 'seq (cdr sre)) flags n2)))
           (state-next2-set! n2 n1)
           n1))
        ((= exactly)
         ;; Exact repetition.
         (->rx (sre-expand-reps (cadr sre) (cadr sre) (cons 'seq (cddr sre)))
               flags next))
        ((>= at-least)
         ;; n-or-more repetition.
         (->rx (sre-expand-reps (cadr sre) #f (cons 'seq (cddr sre)))
               flags next))
        ((** repeated **? non-greedy-repeated)
         ;; n-to-m repetition.
         (->rx (sre-expand-reps (cadr sre) (car (cddr sre))
                                (cons 'seq (cdr (cddr sre))))
               flags next))
        ((-> => submatch-named)
         ;; Named submatches just record the name for the current
         ;; match and rewrite as a non-named submatch.
         (cond
          ((flag-set? flags ~nocapture?)
           (->rx (cons 'seq (cddr sre)) flags next))
          (else
           (set! match-names
                 (cons (cons (cadr sre) (+ 1 current-match)) match-names))
           (->rx (cons 'submatch (cddr sre)) flags next))))
        ((*-> *=> submatch-named-list)
         (cond
          ((flag-set? flags ~nocapture?)
           (->rx (cons 'seq (cddr sre)) flags next))
          (else
           (set! match-names (cons (cons (cadr sre) current-match) match-names))
           (->rx (cons 'submatch-list (cddr sre)) flags next))))
        (($ submatch)
         ;; A submatch wraps next with an epsilon transition before
         ;; next, setting the start and end index on the result and
         ;; wrapped next respectively.
         (cond
          ((flag-set? flags ~nocapture?)
           (->rx (cons 'seq (cdr sre)) flags next))
          (else
           (let ((num current-match)
                 (index current-index))
             (set! current-match (+ current-match 1))
             (set! current-index (+ current-index 2))
             (set! match-rules `((,index . ,(+ index 1)) ,@match-rules))
             (make-submatch-state (cons 'seq (cdr sre)) flags next index)))))
        ((*$ submatch-list)
         ;; A submatch-list wraps a range of submatch results into a
         ;; single match value.
         (cond
          ((flag-set? flags ~nocapture?)
           (->rx (cons 'seq (cdr sre)) flags next))
          (else
           (let* ((num current-match)
                  (index current-index))
             (set! current-match (+ current-match 1))
             (set! current-index (+ current-index 1))
             (set! match-rules `(,index ,@match-rules))
             (let* ((n2 (make-epsilon-state next (next-id)))
                    (n1 (->rx (cons 'submatch (cdr sre)) flags n2)))
               (state-match-set! n2 (list index num current-match))
               (state-match-rule-set! n2 'list)
               n1)))))
        ((~ - & / complement difference and char-range char-set)
         (make-char-state (sre->char-set sre flags) ~none next (next-id)))
        ((word)
         (->rx `(: bow ,@(cdr sre) eow) flags next))
        ((word+)
         (->rx `(word (+ ,(if (equal? '(any) (cdr sre))
                              'word-constituent
                              (char-set-intersection
                               char-set:word-constituent
                               (sre->char-set `(or ,@(cdr sre)) flags)))))
               flags
               next))
        ((w/case)
         (->rx `(: ,@(cdr sre)) (flag-clear flags ~ci?) next))
        ((w/nocase)
         (->rx `(: ,@(cdr sre)) (flag-join flags ~ci?) next))
        ((w/unicode)
         (->rx `(: ,@(cdr sre)) (flag-clear flags ~ascii?) next))
        ((w/ascii)
         (->rx `(: ,@(cdr sre)) (flag-join flags ~ascii?) next))
        ((w/nocapture)
         (->rx `(: ,@(cdr sre)) (flag-join flags ~nocapture?) next))
        (else
         (if (string? (car sre))
             (make-char-state (sre->char-set sre flags) ~none next (next-id))
             (error "unknown sre" sre)))))))
  (let ((flags (parse-flags (and (pair? o) (car o)))))
    (if (regexp? sre)
        sre
        (let ((start (make-submatch-state
                      sre flags (make-accept-state (next-id)) 0)))
          ;; (define (state->list st)
          ;;   (let ((seen (make-hash-table eq?))
          ;;         (count 0))
          ;;     (reverse
          ;;      (let lp ((st st) (res '()))
          ;;        (cond
          ;;         ((not (state? st)) res)
          ;;         ((hash-table-ref/default seen st #f) res)
          ;;         (else
          ;;          (hash-table-set! seen st count)
          ;;          (let ((orig-count count))
          ;;            (set! count (+ count 1))
          ;;            (let* ((next1 (lp (state-next1 st) '()))
          ;;                   (next2 (lp (state-next2 st) '()))
          ;;                   (this (append
          ;;                          (list (state-id st) ;;orig-count
          ;;                                (cond
          ;;                                 ((epsilon-state? st)
          ;;                                  (if (state-chars st) '? '-))
          ;;                                 ((and (char-set? (state-chars st))
          ;;                                       (< (char-set-size (state-chars st)) 5))
          ;;                                  (char-set->string (state-chars st)))
          ;;                                 ((char? (state-chars st))
          ;;                                  (string (state-chars st)))
          ;;                                 (else '+))
          ;;                                (cond
          ;;                                 ((state-next1 st) => state-id)
          ;;                                 (else #f)))
          ;;                          (if (state-next2 st)
          ;;                              (list (state-id (state-next2 st)))
          ;;                              '())
          ;;                          (if (state-match st)
          ;;                              (list (list 'm (state-match st)))
          ;;                              '()))))
          ;;              (append next2 next1 (cons this res))))))))))
          ;;(for-each (lambda (x) (write x) (newline)) (state->list start))
          (make-rx start current-match current-index non-greedy-indexes
                   (list->vector (reverse match-rules)) match-names sre)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Utilities

;;> The fundamental regexp matching iterator.  Repeatedly searches
;;> \var{str} for the regexp \var{re} so long as a match can be found.
;;> On each successful match, applies \scheme{(\var{kons} \var{i}
;;> \var{regexp-match} \var{str} \var{acc})} where \var{i} is the
;;> index since the last match (beginning with
;;> \var{start}),\var{regexp-match} is the resulting match, and
;;> \var{acc} is the result of the previous \var{kons} application,
;;> beginning with \var{knil}.  When no more matches can be found,
;;> calls \var{finish} with the same arguments, except that
;;> \var{regexp-match} is \scheme{#f}.
;;>
;;> By default \var{finish} just returns \var{acc}.

(define (regexp-fold rx kons knil str . o)
  (let* ((rx (regexp rx))
         (finish (if (pair? o) (car o) (lambda (from md str acc) acc)))
         (o (if (pair? o) (cdr o) o))
         (start (string-start-arg str o))
         (end (string-end-arg str (if (pair? o) (cdr o) o))))
    (let lp ((i start)
             (from start)
             (acc knil))
      (cond
       ((and (string-cursor<? i end) (regexp-run-offsets #t rx str i end))
        => (lambda (md)
             (let ((j (regexp-match-ref md 1)))
               (lp (if (and (string-cursor=? i j) (string-cursor<? j end))
                       (string-cursor-next str j)
                       j)
                   j
                   (kons (string-cursor->index str from) md str acc)))))
       (else
        (finish (string-cursor->index str from) #f str acc))))))

;;> Extracts all non-empty substrings of \var{str} which match
;;> \var{re} between \var{start} and \var{end} as a list of strings.

(define (regexp-extract rx str . o)
  (apply regexp-fold
         rx
         (lambda (from md str a)
           (let ((s (regexp-match-submatch md 0)))
             (if (equal? s "") a (cons s a))))
         '()
         str
         (lambda (from md str a) (reverse a))
         o))

;;> Splits \var{str} into a list of strings separated by matches of
;;> \var{re}.

(define (regexp-split rx str . o)
  ;; start and end in indices passed to regexp-fold
  (let ((start (if (pair? o) (car o) 0))
        (end (if (and (pair? o) (pair? (cdr o))) (cadr o) (string-length str))))
    (regexp-fold
     rx
     (lambda (from md str a)
       (let ((i (regexp-match-submatch-start md 0))
             (j (regexp-match-submatch-end md 0)))
         (if (eqv? i j)
             a
             (cons j
                   (cons (substring str (car a) i) (cdr a))))))
     (cons start '())
     str
     (lambda (from md str a)
       (reverse (cons (substring str (car a) end) (cdr a))))
     start
     end)))

;;> Partitions \var{str} into a list of non-empty strings
;;> matching \var{re}, interspersed with the unmatched portions
;;> of the string.  The first and every odd element is an unmatched
;;> substring, which will be the empty string if \var{re} matches
;;> at the beginning of the string or end of the previous match.  The
;;> second and every even element will be a substring matching
;;> \var{re}.  If the final match ends at the end of the string,
;;> no trailing empty string will be included.  Thus, in the
;;> degenerate case where \var{str} is the empty string, the
;;> result is \scheme{("")}.

(define (regexp-partition rx str . o)
  (let ((start (if (pair? o) (car o) 0))
        (end (if (and (pair? o) (pair? (cdr o))) (cadr o) (string-length str))))
    (define (kons from md str a)
      (let ((i (regexp-match-submatch-start md 0))
            (j (regexp-match-submatch-end md 0)))
        (if (eqv? i j)
            a
            (let ((left (substring str (car a) i)))
              (cons j
                    (cons (regexp-match-submatch md 0)
                          (cons left (cdr a))))))))
    (define (final from md str a)
      (if (or (< from end) (null? (cdr a)))
          (cons (substring str (car a) end) (cdr a))
          (cdr a)))
    (reverse (regexp-fold rx kons (cons start '()) str final start end))))

;;> Returns a new string replacing the \var{count}th match of \var{re}
;;> in \var{str} the \var{subst}, where the zero-indexed \var{count}
;;> defaults to zero (i.e. the first match).  If there are not
;;> \var{count} matches, returns the selected substring unmodified.

;;> \var{subst} can be a string, an integer or symbol indicating the
;;> contents of a numbered or named submatch of \var{re},\scheme{'pre}
;;> for the substring to the left of the match, or \scheme{'post} for
;;> the substring to the right of the match.

;;> The optional parameters \var{start} and \var{end} restrict both
;;> the matching and the substitution, to the given indices, such that
;;> the result is equivalent to omitting these parameters and
;;> replacing on \scheme{(substring str start end)}. As a convenience,
;;> a value of \scheme{#f} for \var{end} is equivalent to
;;> \scheme{(string-length str)}.

(define (regexp-replace rx str subst . o)
  (let* ((start (if (and (pair? o) (car o)) (car o) 0))
         (o (if (pair? o) (cdr o) '()))
         (end (if (and (pair? o) (car o)) (car o) (string-length str)))
         (o (if (pair? o) (cdr o) '()))
         (count (if (pair? o) (car o) 0)))
    (let lp ((i start) (count count))
      (let ((m (regexp-search rx str i end)))
        (cond
         ((not m) str)
         ((positive? count)
          (lp (regexp-match-submatch-end m 0) (- count 1)))
         (else
          (string-concatenate
           (cons
            (substring str start (regexp-match-submatch-start m 0))
            (append
             (reverse (regexp-apply-match m str subst start end))
             (list (substring str (regexp-match-submatch-end m 0) end)))))))))))

;;> Equivalent to \var{regexp-replace}, but replaces all occurrences
;;> of \var{re} in \var{str}.

(define (regexp-replace-all rx str subst . o)
  (let* ((start (if (and (pair? o) (car o)) (car o) 0))
         (o (if (pair? o) (cdr o) '()))
         (end (if (and (pair? o) (car o)) (car o) (string-length str))))
    (regexp-fold
     rx
     (lambda (i m str acc)
       (let ((m-start (regexp-match-submatch-start m 0)))
         (append (regexp-apply-match m str subst start end)
                 (if (>= i m-start)
                     acc
                     (cons (substring str i m-start) acc)))))
     '()
     str
     (lambda (i m str acc)
       (let ((end (string-length str)))
         (string-concatenate-reverse
          (if (>= i end)
              acc
              (cons (substring str i end) acc)))))
     start end)))

(define (regexp-apply-match m str ls start end)
  (let lp ((ls ls) (res '()))
    (cond
     ((null? ls)
      res)
     ((not (pair? ls))
      (lp (list ls) res))
     ((integer? (car ls))
      (lp (cdr ls) (cons (or (regexp-match-submatch m (car ls)) "") res)))
     ((procedure? (car ls))
      (lp (cdr ls) (cons ((car ls) m) res)))
     ((symbol? (car ls))
      (case (car ls)
        ((pre)
         (lp (cdr ls)
             (cons (substring str start (regexp-match-submatch-start m 0))
                   res)))
        ((post)
         (lp (cdr ls)
             (cons (substring str (regexp-match-submatch-end m 0) end)
                   res)))
        (else
         (cond
          ((assq (car ls) (regexp-match-names m))
           => (lambda (x) (lp (cons (cdr x) (cdr ls)) res)))
          (else
           (error "unknown match replacement" (car ls)))))))
     (else
      (lp (cdr ls) (cons (car ls) res))))))

(define re:grapheme (regexp 'grapheme))
(define-library (chibi match-test)
  (export run-tests)
  (import (except (scheme base) equal?)
          (chibi match)
          (only (chibi test) test-begin test test-end))
  (cond-expand
   (chibi
    (begin
      (define-record-type Point
       (make-point x y)
       point?
       (x point-x point-x-set!)
       (y point-y point-y-set!))))
   (else))
  (begin
    (define (run-tests)
      (test-begin "match")

      (test "any" 'ok (match 'any (_ 'ok)))
      (test "symbol" 'ok (match 'ok (x x)))
      (test "number" 'ok (match 28 (28 'ok)))
      (test "string" 'ok (match "good" ("bad" 'fail) ("good" 'ok)))
      (test "literal symbol" 'ok (match 'good ('bad 'fail) ('good 'ok)))
      (test "null" 'ok (match '() (() 'ok)))
      (test "pair" 'ok (match '(ok) ((x) x)))
      (test "vector" 'ok (match '#(ok) (#(x) x)))
      (test "any doubled" 'ok (match '(1 2) ((_ _) 'ok)))
      (test "and empty" 'ok (match '(o k) ((and) 'ok)))
      (test "and single" 'ok (match 'ok ((and x) x)))
      (test "and double" 'ok (match 'ok ((and (? symbol?) y) 'ok)))
      (test "or empty" 'ok (match '(o k) ((or) 'fail) (else 'ok)))
      (test "or single" 'ok (match 'ok ((or x) 'ok)))
      (test "or double" 'ok (match 'ok ((or (? symbol? y) y) y)))
      (test "or unbalanced" 1  (match 1 ((or (and 1 x) (and 2 y)) x)))
      (test "not" 'ok (match 28 ((not (a . b)) 'ok)))
      (test "not fail" 'bad (match 28 ((not a) 'ok) (else 'bad)))
      (test "not and" #t (match 1 ((and (not 2)) #t)))
      (test "pred" 'ok (match 28 ((? number?) 'ok)))
      (test "named pred" 29 (match 28 ((? number? x) (+ x 1))))

      (test "duplicate symbols pass" 'ok (match '(ok . ok) ((x . x) x)))
      (test "duplicate symbols fail" 'ok
        (match '(ok . bad) ((x . x) 'bad) (else 'ok)))
      (test "duplicate symbols fail 2" 'ok
        (match '(ok bad) ((x x) 'bad) (else 'ok)))
      (test "duplicate symbols samth" 'ok
        (match '(ok . ok) ((x . 'bad) x) (('ok . x) x)))
      (test "duplicate symbols bound" 3
        (let ((a '(1 2))) (match a ((and (a 2) (1 b)) (+ a b)) (_ #f))))
      (test "duplicate quasiquote" 'ok
        (match '(a b) ((or `(a ,x) `(,x b)) 'ok) (_ #f)))
      (test "duplicate before ellipsis" #f
        (match '(1 2) ((a a ...) a) (else #f)))
      (test "duplicate ellipsis pass" '(1 2)
        (match '((1 2) (1 2)) (((x ...) (x ...)) x) (else #f)))
      (test "duplicate ellipsis fail" #f
        (match '((1 2) (1 2 3)) (((x ...) (x ...)) x) (else #f)))
      (test "duplicate ellipsis trailing" '(1 2)
        (match '((1 2 3) (1 2 3)) (((x ... 3) (x ... 3)) x) (else #f)))
      (test "duplicate ellipsis trailing fail" #f
        (match '((1 2 3) (1 1 3)) (((x ... 3) (x ... 3)) x) (else #f)))
      (test "duplicate ellipsis fail trailing" #f
        (match '((1 2 3) (1 2 4)) (((x ... 3) (x ... 3)) x) (else #f)))

      (test "ellipses" '((a b c) (1 2 3))
        (match '((a . 1) (b . 2) (c . 3))
          (((x . y) ___) (list x y))))

      (test "real ellipses" '((a b c) (1 2 3))
        (match '((a . 1) (b . 2) (c . 3))
          (((x . y) ...) (list x y))))

      (test "vector ellipses" '(1 2 3 (a b c) (1 2 3))
        (match '#(1 2 3 (a . 1) (b . 2) (c . 3))
          (#(a b c (hd . tl) ...) (list a b c hd tl))))

      (test "pred ellipses" '(1 2 3)
        (match '(1 2 3)
          (((? odd? n) ___) n)
          (((? number? n) ___) n)))

      (test "ellipsis trailing" '(3 1 2)
        (match '(1 2 3) ((x ... y) (cons y x)) (else #f)))

      (test "failure continuation" 'ok
        (match '(1 2)
          ((a . b) (=> next) (if (even? a) 'fail (next)))
          ((a . b) 'ok)))

      (test "let" '(o k)
        (match-let ((x 'ok) (y '(o k))) y))

      (test "let*" '(f o o f)
        (match-let* ((x 'f) (y 'o) ((z w) (list y x))) (list x y z w)))

      (test "getter car" '(1 2)
        (match '(1 . 2) (((get! a) . b) (list (a) b))))

      (test "getter cdr" '(1 2)
        (match '(1 . 2) ((a . (get! b)) (list a (b)))))

      (test "getter vector" '(1 2 3)
        (match '#(1 2 3) (#((get! a) b c) (list (a) b c))))

      (test "setter car" '(3 . 2)
        (let ((x (cons 1 2)))
          (match x (((set! a) . b) (a 3)))
          x))

      (test "setter cdr" '(1 . 3)
        (let ((x (cons 1 2)))
          (match x ((a . (set! b)) (b 3)))
          x))

      (test "setter vector" '#(1 0 3)
        (let ((x (vector 1 2 3)))
          (match x (#(a (set! b) c) (b 0)))
          x))

      (test "single tail" '((a b) (1 2) (c . 3))
        (match '((a . 1) (b . 2) (c . 3))
          (((x . y) ... last) (list x y last))))

      (test "single tail 2" '((a b) (1 2) 3)
        (match '((a . 1) (b . 2) 3)
          (((x . y) ... last) (list x y last))))

      (test "single duplicate tail" #f
        (match '(1 2) ((foo ... foo) foo) (_ #f)))

      (test "multiple tail" '((a b) (1 2) (c . 3) (d . 4) (e . 5))
        (match '((a . 1) (b . 2) (c . 3) (d . 4) (e . 5))
          (((x . y) ... u v w) (list x y u v w))))

      (test "tail against improper list" #f
        (match '(a b c d e f . g)
          ((x ... y u v w) (list x y u v w))
          (else #f)))

      (test "Riastradh quasiquote" '(2 3)
        (match '(1 2 3) (`(1 ,b ,c) (list b c))))

      (test "unquote-splicing" '(2 3)
        (match '(1 2 3) (`(1 ,@ls) ls)))

      (test "unquote-splicing tail" '(b c)
        (match '(a b c d) (`(a ,@ls d) ls)))

      (test "unquote-splicing tail fail" #f
        (match '(a b c e) (`(a ,@ls d) ls) (else #f)))

      (test "trivial tree search" '(1 2 3)
        (match '(1 2 3) ((_ *** (a b c)) (list a b c))))

      (test "simple tree search" '(1 2 3)
        (match '(x (1 2 3)) ((_ *** (a b c)) (list a b c))))

      (test "deep tree search" '(1 2 3)
        (match '(x (x (x (1 2 3)))) ((_ *** (a b c)) (list a b c))))

      (test "non-tail tree search" '(1 2 3)
        (match '(x (x (x a b c (1 2 3) d e f))) ((_ *** (a b c)) (list a b c))))

      (test "restricted tree search" '(1 2 3)
        (match '(x (x (x a b c (1 2 3) d e f))) (('x *** (a b c)) (list a b c))))

      (test "fail restricted tree search" #f
        (match '(x (y (x a b c (1 2 3) d e f)))
          (('x *** (a b c)) (list a b c))
          (else #f)))

      (test "sxml tree search"
          '(((href . "http://synthcode.com/")) ("synthcode"))
        (match '(p (ul (li a (b c) (a (@ (href . "http://synthcode.com/"))
                                      "synthcode") d e f)))
          (((or 'p 'ul 'li 'b) *** ('a ('@ attrs ...) text ...))
           (list attrs text))
          (else #f)))

      (test "failed sxml tree search" #f
        (match '(p (ol (li a (b c) (a (@ (href . "http://synthcode.com/"))
                                      "synthcode") d e f)))
          (((or 'p 'ul 'li 'b) *** ('a ('@ attrs ...) text ...))
           (list attrs text))
          (else #f)))

      (test "collect tree search"
          '((p ul li) ((href . "http://synthcode.com/")) ("synthcode"))
        (match '(p (ul (li a (b c) (a (@ (href . "http://synthcode.com/"))
                                      "synthcode") d e f)))
          (((and tag (or 'p 'ul 'li 'b)) *** ('a ('@ attrs ...) text ...))
           (list tag attrs text))
          (else #f)))

      (test "anded tail pattern" '(1 2)
        (match '(1 2 3) ((and (a ... b) x) a)))

      (test "anded search pattern" '(a b c)
        (match '(a (b (c d))) ((and (p *** 'd) x) p)))

      (test "joined tail" '(1 2)
        (match '(1 2 3) ((and (a ... b) x) a)))

      (test "list **1" '(a b c)
        (match '(a b c) ((x **1) x)))

      (test "list **1 failed" #f
        (match '()
          ((x **1) x)
          (else #f)))

      (test "list **1 with predicate" '(a b c)
        (match '(a b c)
          (((and x (? symbol?)) **1) x)))

      (test "list **1 with failed predicate" #f
        (match '(a b 3)
          (((and x (? symbol?)) **1) x)
          (else #f)))

      (test "list =.. too few" #f
        (match (list 1 2) ((a b =.. 2) b) (else #f)))
      (test "list =.." '(2 3)
        (match (list 1 2 3) ((a b =.. 2) b) (else #f)))
      (test "list =.. too many" #f
        (match (list 1 2 3 4) ((a b =.. 2) b) (else #f)))
      (test "list =.. tail" 4
        (match (list 1 2 3 4) ((a b =.. 2 c) c) (else #f)))
      (test "list =.. tail fail" #f
        (match (list 1 2 3 4 5 6) ((a b =.. 2 c) c) (else #f)))

      (test "list *.. too few" #f
        (match (list 1 2) ((a b *.. 2 4) b) (else #f)))
      (test "list *.. lo" '(2 3)
        (match (list 1 2 3) ((a b *.. 2 4) b) (else #f)))
      (test "list *.. hi" '(2 3 4 5)
        (match (list 1 2 3 4 5) ((a b *.. 2 4) b) (else #f)))
      (test "list *.. too many" #f
        (match (list 1 2 3 4 5 6) ((a b *.. 2 4) b) (else #f)))
      (test "list *.. tail" 4
        (match (list 1 2 3 4) ((a b *.. 2 4 c) c) (else #f)))
      (test "list *.. tail 2" 5
        (match (list 1 2 3 4 5) ((a b *.. 2 4 c d) d) (else #f)))
      (test "list *.. tail" 6
        (match (list 1 2 3 4 5 6) ((a b *.. 2 4 c) c) (else #f)))
      (test "list *.. tail fail" #f
        (match (list 1 2 3 4 5 6 7) ((a b *.. 2 4 c) c) (else #f)))

      (test "match-named-let" 6
        (match-let loop (((x . rest) '(1 2 3))
                         (sum 0))
          (let ((sum (+ x sum)))
            (if (null? rest)
                sum
                (loop rest sum)))))

      (test "match-letrec" '(2 1 1 2)
          (match-letrec (((x y) (list 1 (lambda () (list a x))))
                         ((a b) (list 2 (lambda () (list x a)))))
                        (append (y) (b))))
      (test "match-letrec quote" #t
        (match-letrec (((x 'x) (list #t 'x))) x))
      (let-syntax
        ((foo
          (syntax-rules ()
            ((foo x)
             (match-letrec (((x y) (list 1 (lambda () (list a x))))
                            ((a b) (list 2 (lambda () (list x a)))))
                           (append (y) (b)))))))
        (test "match-letrec mnieper" '(2 1 1 2) (foo a)))

      (cond-expand
       (chibi
        (test "record positional"
            '(1 0)
          (match (make-point 0 1)
            (($ Point x y) (list y x))))
        (test "record named"
            '(1 0)
          (match (make-point 0 1)
            ((@ Point (x x) (y y)) (list y x)))))
       (else))

      (test-end))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; binary records

(define-syntax defrec
  (syntax-rules (make: pred: read: write: block:)
    ((defrec () n m p r w
       ((field-tmp field-read field-read-expr field-write field-write-expr field-get) ...)
       ((field getter . s) ...)
       (def-setter ...))
     (begin
       (define-record-type n (m field ...) p
         (field getter . s) ...)
       (define r
         (let ((field-read field-read-expr) ...)
           (lambda (in)
             (let* ((field-tmp (field-read in)) ...)
               (m field ...)))))
       (define w
         (let ((field-write field-write-expr) ...)
           (lambda (x out)
             (field-write (field-get x) out) ...)))
       def-setter ...)
     ;; workaround for impls which strip hygiene from top-level defs
     ;; for some reason, works in chicken but not across libraries
     ;;
     ;; (begin
     ;;   (define-values (n m p getter ... setter ...)
     ;;     (let ()
     ;;       (define-record-type n (m field ...) p
     ;;         (field getter . s) ...)
     ;;       (def setter val) ...
     ;;       (values (record-rtd n) m p getter ... setter ...)))
     ;;   (define r
     ;;     (let ((field-read field-read-expr) ...)
     ;;       (lambda (in)
     ;;         (let* ((field-tmp (field-read in)) ...)
     ;;           (m field ...)))))
     ;;   (define w
     ;;     (let ((field-write field-write-expr) ...)
     ;;       (lambda (x out)
     ;;         (field-write (field-get x) out) ...))))
     )
    ((defrec ((make: x) . rest) n m p r w b f s)
     (defrec rest n x p r w b f s))
    ((defrec ((pred: x) . rest) n m p r w b f s)
     (defrec rest n m x r w b f s))
    ((defrec ((read: x) . rest) n m p r w b f s)
     (defrec rest n m p x w b f s))
    ((defrec ((write: x) . rest) n m p r w b f s)
     (defrec rest n m p r x b f s))
    ((defrec ((block: (field (type . args) getter setter) . fields) . rest) n m p r w b f s)
     (defrec ((block: (field (type . args) getter setter tmp-setter) . fields) . rest) n m p r w b f s))
    ((defrec ((block: (field (type . args) getter setter tmp-setter) . fields) . rest) n m p r w
       (b ...) (f ...) (s ...))
     (defrec ((block: . fields) . rest) n m p r w
       (b ...
          (field read-tmp (type read: args) write-tmp (type write: args) getter))
       (f ...
          (field getter tmp-setter))
       (s ...
          (define setter
            (let ((pred? (type pred: args)))
              (lambda (x val)
                (if (not (pred? val))
                    (error "invalid val for" 'field val))
                (tmp-setter x val)))))))
    ((defrec ((block: (field (type . args) getter) . fields) . rest) n m p r w
       (b ...) (f ...) s)
     (defrec ((block: . fields) . rest) n m p r w
       (b ...
          (field read-tmp (type read: args) write-tmp (type write: args) getter))
       (f ...
          (field getter))
       s))
    ((defrec ((block: (field . x)) . rest) n m p r w b f s)
     (syntax-error "invalid field in block" (field . x)))
    ((defrec ((block: data . fields) . rest) n m p r w (b ...) f s)
     (defrec ((block: . fields) . rest) n m p r w
       (b ...
          (tmp-data read-tmp (read-literal 'data) write-tmp (write-literal 'data) (lambda (x) x)))
       f
       s))
    ((defrec ((block:) . rest) n m p r w b f s)
     (defrec rest n m p r w b f s))
    ))

(define-syntax define-binary-record-type
  (syntax-rules ()
    ((define-binary-record-type name x ...)
     (defrec (x ...) name hidden-make hidden-pred hidden-read hidden-write
       () () ()))))

(define-library (chibi log)
  (export
   ;; Logger record
   Logger logger?
   logger-levels logger-levels-set!
   logger-level-abbrevs logger-level-abbrevs-set!
   logger-current-level logger-current-level-set!
   logger-prefix logger-prefix-set!
   logger-counts logger-counts-set!
   logger-file logger-file-set!
   logger-port logger-port-set!
   logger-locked? logger-locked?-set!
   logger-zipped? logger-zipped?-set!
   ;; syntax
   define-logger with-logged-errors with-logged-and-reraised-errors
   ;; procedural interface
   log-open log-close log-show log-show-every-n log-compile-prefix
   ;; levels introspection
   log-level-index log-level-name log-level-abbrev
   ;; the default logger
   default-logger log-emergency log-alert log-critical log-error
   log-warn log-notice log-info log-debug
   with-log-level)
  (import (chibi time) (chibi string) (chibi show base))
  (cond-expand
   (chibi
    (import (chibi) (chibi filesystem) (chibi process) (chibi string)
            (chibi system) (srfi 9))
    (begin
      (define write-string display)
      (define (open-output-file/append path)
        (let ((fd (open path
                        (+ open/create open/write open/append open/non-block))))
          (open-output-file-descriptor fd)))))
   (else
    (import (scheme base) (scheme char) (scheme file) (chibi string))
    (begin
      (define-syntax protect
        (syntax-rules ()
          ((protect . x) (guard . x))))
      (define open-output-file/append open-output-file)
      (define flush-output flush-output-port)
      (define (file-lock port-or-fileno mode) 'unsupported)
      (define lock/exclusive 'unsupported)
      (define lock/unlock 'unsupported)
      (define (current-process-id) -1)
      (define (current-user-id) -1)
      (define (current-group-id) -1))))
  (include "log.scm"))

(define-library (chibi assert-test)
  (import (chibi) (chibi assert) (chibi test))
  (export run-tests)
  (begin
    (define-syntax test-assert
      (syntax-rules ()
        ((test-assert irritants expr)
         (protect (exn
                   (else
                    (test irritants (exception-irritants exn))))
           expr
           (error "assertion not triggered")))))
    (define (run-tests)
      (test-begin "assert")
      (test-assert '((= x (+ x 1))
                     (x 3))
        (let ((x 3)) (assert (= x (+ x 1)))))
      (test-assert '((= x (+ y 1))
                     (x 3)
                     (y 42))
        (let ((x 3) (y 42)) (assert (= x (+ y 1)))))
      (test-assert '((eq? x 'three)
                     (x 3))
        (let ((x 3)) (assert (eq? x 'three))))
      (test-assert '((eq? x 'three)
                     "expected three: "
                     3)
        (let ((x 3)) (assert (eq? x 'three) "expected three: " x)))
      (test-end))))
;; Copyright (c) 2010-2020 Alex Shinn. All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

;;> Simple but extensible testing framework with advanced reporting.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; list utilities

;; Simplified version of SRFI-1 any.
(define (any pred ls)
  (and (pair? ls)
       (or (pred (car ls))
           (any pred (cdr ls)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; exception utilities

(define (warning msg . args)
  (display msg (current-error-port))
  (for-each (lambda (x)
              (write-char #\space (current-error-port))
              (write x (current-error-port)))
            args)
  (newline (current-error-port)))

(define (exception-message exc)
  (let* ((s (let ((p (open-output-string)))
              (print-exception exc p)
              (get-output-string p)))
         (n (- (string-length s) 1)))
    ;; Strip the ERROR:  prefix if present
    (let loop ((i 0))
      (if (>= (+ i 2) n)
          (substring s 0 n)
          (if (and (char=? (string-ref s i) #\:)
                   (char=? (string-ref s (+ i 1)) #\space))
              (substring s (+ i 2) n)
              (loop (+ i 1)))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; string utilities

(define (string-search pat str)
  (let* ((pat-len (string-length pat))
         (limit (- (string-length str) pat-len)))
    (let lp1 ((i 0))
      (cond
       ((>= i limit) #f)
       (else
        (let lp2 ((j i) (k 0))
          (cond ((>= k pat-len) #t)
                ((not (eqv? (string-ref str j) (string-ref pat k)))
                 (lp1 (+ i 1)))
                (else (lp2 (+ j 1) (+ k 1))))))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; test interface

;;> \section{Testing}

;;> \macro{(test [name] expect expr)}

;;> The primary interface to testing.  Evaluate \var{expr} and check
;;> that it is equal to \var{expect}, and report the result, using
;;> \var{name} or a printed summary of \var{expr}.
;;>
;;> If used inside a group this will contribute to the overall group
;;> reporting, but can be used standalone:
;;>
;;> \example{(test 4 (+ 2 2))}
;;> \example{(test "add two and two" 4 (+ 2 2))}
;;> \example{(test 3 (+ 2 2))}
;;> \example{(test 4 (+ 2 "2"))}
;;>
;;> The equality comparison is made with
;;> \scheme{current-test-comparator}, defaulting to
;;> \scheme{test-equal?}, which is the same as \scheme{equal?} but
;;> more permissive on floating point comparisons).  Returns the
;;> status of the test (one of the symbols \scheme{'PASS},
;;> \scheme{'FAIL}, \scheme{'SKIP}, \scheme{'ERROR}).

(define-syntax test
  (syntax-rules (quote)
    ((test expect expr)
     (test #f expect expr))
    ((test name expect (expr ...))
     (test-propagate-info name expect (expr ...) ()))
    ((test name 'expect expr)
     (test-propagate-info name 'expect expr ()))
    ((test name (expect ...) expr)
     (test-syntax-error
      'test
      "the test expression should come last: (test <expected> (<expr> ...)) "
      (test name (expect ...) expr)))
    ((test name expect expr)
     (test-propagate-info name expect expr ()))
    ((test a ...)
     (test-syntax-error 'test "test requires 2 or 3 arguments" (test a ...)))))

;;> \macro{(test-equal equal [name] expect expr)}

;;> Equivalent to test, using \var{equal} for comparison instead of
;;> \scheme{equal?}.

(define-syntax test-equal
  (syntax-rules ()
    ((test-equal equal . args)
     (parameterize ((current-test-comparator equal))
       (test . args)))))

;;> \macro{(test-assert [name] expr)}

;;> Like \scheme{test} but evaluates \var{expr} and checks that it's true.

(define-syntax test-assert
  (syntax-rules ()
    ((_ expr)
     (test-assert #f expr))
    ((_ name expr)
     (test-propagate-info name #f expr ((assertion . #t))))
    ((test a ...)
     (test-syntax-error 'test-assert "1 or 2 arguments required"
                        (test a ...)))))

;;> \macro{(test-not [name] expr)}

;;> Like \scheme{test} but evaluates \var{expr} and checks that it's false.

(define-syntax test-not
  (syntax-rules ()
    ((_ expr) (test-assert (not expr)))
    ((_ name expr) (test-assert name (not expr)))))

;;> \macro{(test-values [name] expect expr)}

;;> Like \scheme{test} but \var{expect} and \var{expr} can both
;;> return multiple values.

(define-syntax test-values
  (syntax-rules ()
    ((_ expect expr)
     (test-values #f expect expr))
    ((_ name expect expr)
     (test name (call-with-values (lambda () expect) (lambda results results))
       (call-with-values (lambda () expr) (lambda results results))))))

;;> \macro{(test-error [name] expr)}

;;> Like \scheme{test} but evaluates \var{expr} and checks that it
;;> raises an error.

(define-syntax test-error
  (syntax-rules ()
    ((_ expr)
     (test-error #f expr))
    ((_ name expr)
     (test-propagate-info name #f expr ((expect-error . #t))))
    ((test a ...)
     (test-syntax-error 'test-error "1 or 2 arguments required"
                        (test a ...)))))

;;> Low-level macro to pass alist info to the underlying \var{test-run}.

(define-syntax test-propagate-info
  (syntax-rules ()
    ;; TODO: Extract interesting variables so we can show their values
    ;; on failure.  Vars are empty for now.
    ((test-propagate-info name expect expr info)
     (test-vars () name expect expr info))))

(define-syntax test-vars
  (syntax-rules ()
    ((_ (vars ...) n expect expr ((key . val) ...))
     (test-run (lambda () expect)
               (lambda () expr)
               `((name . ,n)
                 (source . expr)
                 (var-names . (vars ...))
                 (var-values . ,(list vars ...))
                 (key . val) ...)))))

;;> The procedural interface to testing.  \var{expect} and \var{expr}
;;> should be thunks, and \var{info} is an alist of properties used in
;;> test reporting.

(define (test-run expect expr info)
  (let ((info (test-expand-info info)))
    ((current-test-reporter) 'BEGIN info)
    (if (and (cond ((current-test-group)
                    => (lambda (g) (not (test-group-ref g 'skip-group?))))
                   (else #t))
             (or (and (not (any (lambda (f) (f info)) (current-test-removers)))
                      (or (pair? (current-test-removers))
                          (null? (current-test-filters))))
                 (any (lambda (f) (f info)) (current-test-filters))))
        ((current-test-applier) expect expr info)
        ((current-test-skipper) info))))

;;> Returns true if either \scheme{(equal? expect res)}, or
;;> \var{expect} is inexact and \var{res} is within
;;> \scheme{current-test-epsilon} of \var{expect}.

(define (test-equal? expect res)
  (or (equal? expect res)
      (if (real? expect)
          (and (inexact? expect)
               (real? res)
               ;; tests which expect an inexact value can
               ;; accept an equivalent exact value
               ;; (inexact? res)
               (approx-equal? expect res (current-test-epsilon)))
          (and (complex? res)
               (complex? expect)
               (test-equal? (real-part expect) (real-part res))
               (test-equal? (imag-part expect) (imag-part res))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; group interface

;;> \section{Test Groups}

;;> Tests can be collected in groups for separate reporting, filtering
;;> and for catching exceptions outside of a test case.

;;> Wraps \var{body} as a single test group, which can be filtered and
;;> summarized separately.  The \var{body} is arbitrary Scheme code,
;;> and tests run within its dynamic extent will be associated with
;;> the group.  If an uncaught exception is raised outside of a test
;;> case, it will cause the whole group to fail with an error status.

;;> \example{
;;> (test-group "pi"
;;>   (test 3.14159 (acos -1))
;;>   (test 3 (acos -1))
;;>   (test 3.14159 (acos "-1")))
;;> }

(define-syntax test-group
  (syntax-rules ()
    ((_ name-expr body ...)
     (let ((name name-expr)
           (old-group (current-test-group)))
       (when (not (string? name))
         (error "a name is required, got " 'name-expr name))
       (test-begin name)
       (guard
           (exn
            (else
             (warning "error in group outside of tests")
             (print-exception exn (current-error-port))
             (test-group-inc! (current-test-group) 'count)
             (test-group-inc! (current-test-group) 'ERROR)
             (test-failure-count (+ 1 (test-failure-count)))))
         body ...)
       (test-end name)
       (current-test-group old-group)))))

;;> Begin testing a new group until the closing \scheme{(test-end)}.

(define-opt (test-begin (name ""))
  (let* ((parent (current-test-group))
         (group (make-test-group name parent)))
    ((current-test-group-reporter) group parent)
    (current-test-group group)))

;;> Ends testing group introduced with \scheme{(test-begin)}, and
;;> summarizes the results.  The \var{name} is optional, but if
;;> present should match the corresponding \scheme{test-begin} name,
;;> or a warning is printed.

(define-opt (test-end (name #f))
  (let ((group (current-test-group)))
    (when group
      (when (and name (not (equal? name (test-group-name group))))
        (warning "mismatched test-end:" name (test-group-name group)))
      ((current-test-group-reporter) group)
      (let ((parent (test-group-ref group 'parent)))
        (when parent
          (test-group-inc! parent 'subgroups-count)
          (cond
           ((test-group-ref group 'skip-group?)
            (test-group-inc! parent 'subgroups-skip))
           ((and (zero? (test-group-ref group 'FAIL 0))
                 (zero? (test-group-ref group 'ERROR 0))
                 (= (test-group-ref group 'subgroups-pass 0)
                    (test-group-ref group 'subgroups-count 0)))
            (test-group-inc! parent 'subgroups-pass))))
        (current-test-group parent)))))

;;> Exits with a failure status if any tests have failed,
;;> and a successful status otherwise.

(define (test-exit)
  (when (current-test-group)
    (warning "calling test-exit with unfinished test group:"
             (test-group-name (current-test-group))))
  (exit (zero? (test-failure-count))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; utilities

(define-syntax test-syntax-error
  (syntax-rules ()
    ((_) (syntax-error "invalid use of test-syntax-error"))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; test-group representation

;;> \section{Accessors}

;; (name (prop . value) ...)
(define (make-test-group name parent)
  (let* ((g (list name))
         (! (lambda (k v) (test-group-set! g k v))))
    (! 'start-time (current-second))
    (! 'parent parent)
    (! 'verbose
       (if parent
           (test-group-ref parent 'verbose)
           (current-test-verbosity)))
    (! 'level
       (if parent
           (+ 1 (test-group-ref parent 'level 0))
           0))
    (! 'skip-group?
       (and (or (and parent
                     (test-group-ref parent 'skip-group?))
                (any (lambda (f) (f g))
                     (current-test-group-removers))
                (and (null? (current-test-group-removers))
                     (pair? (current-test-group-filters))))
            (not (any (lambda (f) (f g))
                      (current-test-group-filters)))))
    g))

;;> Returns the name of a test group info object.

(define (test-group-name group) (car group))

;;> Returns the value of a \var{field} in a test var{group} info
;;> object.  \var{field} should be a symbol, and predefined fields
;;> include \scheme{parent}, \scheme{verbose}, \scheme{level},
;;> \scheme{start-time}, \scheme{skip-group?}, \scheme{count},
;;> \scheme{total-pass}, \scheme{total-fail}, \scheme{total-error}.

(define (test-group-ref group field . o)
  (if group
      (apply assq-ref (cdr group) field o)
      (and (pair? o) (car o))))

;;> Sets the value of a \var{field} in a test \var{group} info object.

(define (test-group-set! group field value)
  (cond
   ((assq field (cdr group))
    => (lambda (x) (set-cdr! x value)))
   (else (set-cdr! group (cons (cons field value) (cdr group))))))

;;> Increments the value of a \var{field} in a test \var{group} info
;;> object by \var{amount}, defaulting to 1.

(define (test-group-inc! group field . o)
  (let ((amount (if (pair? o) (car o) 1)))
    (cond
     ((assq field (cdr group))
      => (lambda (x) (set-cdr! x (+ amount (cdr x)))))
     (else (set-cdr! group (cons (cons field amount) (cdr group)))))))

;;> Updates a \var{field} in a test group info object by consing
;;> \var{value} onto it.

(define (test-group-push! group field value)
  (cond
   ((assq field (cdr group))
    => (lambda (x) (set-cdr! x (cons value (cdr x)))))
   (else (set-cdr! group (cons (cons field (list value)) (cdr group))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; utilities

(define (assq-ref ls key . o)
  (cond ((assq key ls) => cdr)
        ((pair? o) (car o))
        (else #f)))

(define (approx-equal? a b epsilon)
  (cond
   ((> (abs a) (abs b))
    (approx-equal? b a epsilon))
   ((zero? a)
    (< (abs b) epsilon))
   (else
    (< (abs (/ (- a b) b)) epsilon))))

(define (call-with-output-string proc)
  (let ((out (open-output-string)))
    (proc out)
    (get-output-string out)))

;; partial pretty printing to abbreviate `quote' forms and the like
(define (write-to-string x)
  (call-with-output-string
    (lambda (out)
      (let wr ((x x))
        (if (pair? x)
            (cond
             ((and (symbol? (car x)) (pair? (cdr x)) (null? (cddr x))
                   (assq (car x)
                         '((quote . "'") (quasiquote . "`")
                           (unquote . ",") (unquote-splicing . ",@"))))
              => (lambda (s) (display (cdr s) out) (wr (cadr x))))
             (else
              (display "(" out)
              (wr (car x))
              (let lp ((ls (cdr x)))
                (cond ((pair? ls)
                       (display " " out)
                       (wr (car ls))
                       (lp (cdr ls)))
                      ((not (null? ls))
                       (display " . " out)
                       (write ls out))))
              (display ")" out)))
            (write x out))))))

(define (display-to-string x)
  (if (string? x) x (call-with-output-string (lambda (out) (display x out)))))

;; if we need to truncate, try first dropping let's to get at the
;; heart of the expression
(define (truncate-source x width . o)
  (let* ((str (write-to-string x))
         (len (string-length str)))
    (cond
     ((<= len width)
      str)
     ((and (pair? x) (eq? 'let (car x)))
      (if (and (pair? o) (car o))
          (truncate-source (car (reverse x)) width #t)
          (string-append "..."
                         (truncate-source (car (reverse x)) (- width 3) #t))))
     ((and (pair? x) (eq? 'call-with-current-continuation (car x)))
      (truncate-source (cons 'call/cc (cdr x)) width (and (pair? o) (car o))))
     ((and (pair? x) (eq? 'call-with-values (car x)))
      (string-append
       "..."
       (truncate-source (if (and (pair? (cadr x)) (eq? 'lambda (car (cadr x))))
                            (car (reverse (cadr x)))
                            (cadr x))
                        (- width 3)
                        #t)))
     (else
      (string-append
       (substring str 0 (min (max 0 (- width 3)) (string-length str)))
       "...")))))

(define (test-get-name! info)
  (or
   (assq-ref info 'name)
   (assq-ref info 'gen-name)
   (let ((name
          (cond
           ((assq 'source info)
            => (lambda (src)
                 (truncate-source (cdr src) (- (current-column-width) 12))))
           ((current-test-group)
            => (lambda (g)
                 (display "no source in: " (current-error-port))
                 (write info (current-error-port))
                 (display "\n" (current-error-port))
                 (string-append
                  "test-"
                  (number->string (test-group-ref g 'count 0)))))
           (else ""))))
     (if (pair? info)
         (set-cdr! info (cons (cons 'gen-name name) (cdr info))))
     name)))

(define (test-print-name info indent)
  (let* ((width (- (current-column-width) indent))
         (name (test-get-name! info))
         (diff (- width 9 (string-length name))))
    (display
     (if (positive? diff)
         name
         (string-append
          (substring name 0 (+ (string-length name) diff -1))
          (string (integer->char #x2026)))))
    (display " ")
    (if (positive? diff)
        (display (make-string diff (integer->char #x2024))))
    (display " ")
    (flush-output-port)))

(define (test-group-indent-width group)
  (let ((level (max 0 (+ 1 (- (test-group-ref group 'level 0)
                              (test-first-indentation))))))
    (* (current-group-indent) (min level (test-max-indentation)))))

;; Terminate the current and indent the next line with the given number
;; of spaces.  The very first string does not terminate a line.  There
;; should be a way to reset first? when creating more than one report
;; in a session.
(define indent-string
  (let ((first? #t))
    (lambda (indent)
      (string-append
       (if first?
           (begin
             (set! first? #f) "")
           "\n")
       (make-string indent #\space)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define (test-expand-info info)
  (let ((expr (assq-ref info 'source)))
    (if (and (pair? expr)
             (pair-source expr)
             (not (assq-ref info 'line-number)))
        `((file-name . ,(car (pair-source expr)))
          (line-number . ,(cdr (pair-source expr)))
          ,@info)
        info)))

(define (test-default-applier expect expr info)
  (let ((expect-val
         (guard
             (exn
              (else
               (warning "bad expect value")
               (print-exception exn (current-error-port))
               #f))
           (expect))))
    (guard
        (exn
         (else
          ((current-test-reporter)
           (if (assq-ref info 'expect-error) 'PASS 'ERROR)
           (append `((exception . ,exn)) info))))
      (let ((res (expr)))
        (let ((status
               (if (and (not (assq-ref info 'expect-error))
                        (if (assq-ref info 'assertion)
                            res
                            ((current-test-comparator) expect-val res)))
                   'PASS
                   'FAIL))
              (info `((result . ,res) (expected . ,expect-val) ,@info)))
          ((current-test-reporter) status info))))))

(define (test-default-skipper info)
  ((current-test-reporter) 'SKIP info))

(define (test-status-color status)
  (case status
    ((ERROR) (lambda (x) (underline (red x))))
    ((FAIL) red)
    ((SKIP) yellow)
    (else (lambda (x) x))))

(define (test-status-message status)
  ((test-status-color status) (symbol->string status)))

(define (test-status-code status)
  ((test-status-color status)
   ;; alternatively: , , , 
   ;; unfortunately, these have ambiguous width
   (case status
     ((ERROR) "!")
     ((FAIL) "x")
     ((SKIP) "-")
     (else "."))))

(define (display-expected/actual expected actual)
  (let* ((e-str (write-to-string expected))
         (a-str (write-to-string actual))
         (diff (diff e-str a-str read-char)))
    (write-string "expected ")
    (write-string (edits->string/color (car diff) (car (cddr diff)) 1))
    (write-string " but got ")
    (write-string (edits->string/color (cadr diff) (car (cddr diff)) 2))))

(define (test-print-explanation indent status info)
  (cond
   ((eq? status 'ERROR)
    (cond ((assq 'exception info)
           => (lambda (exc)
                (display indent)
                (display "Exception: ")
                (display (exception-message (cdr exc)))))))
   ((and (eq? status 'FAIL) (assq-ref info 'assertion))
    (display indent)
    (display "assertion failed"))
   ((and (eq? status 'FAIL) (assq-ref info 'expect-error))
    (display indent)
    (display "expected an error but got ")
    (write (assq-ref info 'result)))
   ((eq? status 'FAIL)
    (display indent)
    (display-expected/actual
     (assq-ref info 'expected) (assq-ref info 'result))))
  ;; print variables
  (cond
   ((and (memq status '(FAIL ERROR)) (assq-ref info 'var-names))
    => (lambda (names)
         (let ((values (assq-ref info 'var-values)))
           (if (and (pair? names)
                    (pair? values)
                    (= (length names) (length values)))
               (let ((indent2
                      (string-append indent (string #\space #\space))))
                 (for-each
                  (lambda (name value)
                    (display indent2)
                    (write name) (display ": ") (write value))
                  names values))))))))

(define (test-print-source indent status info)
  (case status
    ((FAIL ERROR)
     (cond
      ((assq-ref info 'line-number)
       => (lambda (line)
            (display indent)
            (display "on line ")
            (write line)
            (cond ((assq-ref info 'file-name)
                   => (lambda (file) (display " of file ") (write file)))))))
     (cond
      ((assq-ref info 'source)
       => (lambda (s)
            (cond
             ((or (assq-ref info 'name)
                  (> (string-length (write-to-string s))
                     (current-column-width)))
              (display indent)
              (display (write-to-string s)))))))
     (cond
      ((assq-ref info 'values)
       => (lambda (v)
            (for-each
             (lambda (v)
               (display indent) (display (car v))
               (display ": ") (write (cdr v)))
             v)))))))

(define (test-print-failure indent status info)
  ;; display status explanation
  (test-print-explanation indent status info)
  ;; display line, source and values info
  (test-print-source indent status info))

(define (test-group-line group open?)
  (let* ((name (test-group-name group))
         (spaces (test-group-indent-width group))
         (indent (indent-string spaces)))
    (if (test-group-ref group 'verbose)
        (let ((text (string-append
                     (if open? "" "done ")
                     (if (test-group-ref group 'skip-group?)
                         "skipping "
                         "testing ")
                     name)))
          (string-append
           indent
           "-- "
           (bold text)
           " "
           (make-string
            (max 0 (- (current-column-width)
                      (string-length text) spaces 4))
            #\-)))
        (string-append
         indent
         (bold (string-append name ": "))))))

(define (start-test info)
  (let ((group (current-test-group)))
    (when (or (not group) (test-group-ref group 'verbose))
      (let ((indent (and group (test-group-indent-width group))))
        (when (and indent (positive? indent))
          (display (indent-string indent)))
        (test-print-name info (or indent 4))))))
(define (stop-test status info)
  (define indent
    (indent-string
     (+ (current-group-indent)
        (cond ((current-test-group)
               => test-group-indent-width)
              (else 0)))))
  ;; update global failure count for exit status
  (cond
   ((or (eq? status 'FAIL) (eq? status 'ERROR))
    (test-failure-count (+ 1 (test-failure-count)))))
  (cond
   ((or (not (current-test-group))
        (test-group-ref (current-test-group) 'verbose))
    ;; display status
    (display "[")
    (if (not (eq? status 'ERROR)) (display " ")) ; pad
    (display (test-status-message status))
    (display "]")
    (test-print-failure indent status info))
   ((eq? status 'SKIP))
   (else
    (display (test-status-code status))
    (cond
     ((and (memq status '(FAIL ERROR)) (current-test-group))
      => (lambda (group)
           (test-group-push! group 'failures (list indent status info)))))
    (cond ((current-test-group)
           => (lambda (group) (test-group-set! group 'trailing #t))))))
  ;; update group info
  (cond
   ((current-test-group)
    => (lambda (group)
         (if (not (eq? 'SKIP status))
             (test-group-inc! group 'count))
         (test-group-inc! group status)
         ;; maybe wrap long status lines
         (let ((width (max (- (current-column-width)
                              (test-group-indent-width group))
                           (current-group-indent)))
               (column
                (+ (string-length (test-group-name group))
                   (test-group-ref group 'count 0)
                   1)))
           (when (and (zero? (modulo column width))
                      (not (test-group-ref group 'verbose)))
             (newline)
             (display (string-copy indent (current-group-indent))))))))
  (flush-output-port)
  status)

(define (test-default-reporter status info)
  (if (eq? status 'BEGIN)
      (start-test info)
      (stop-test status info)))

(define (close-group group)
  (define (plural word n)
    (if (= n 1) word (string-append word "s")))
  (define (percent n d)
    (string-append " (" (number->string (/ (round (* 1000.0 (/ n d))) 10))
                   "%)"))
  (let* ((end-time (current-second))
         (start-time (test-group-ref group 'start-time))
         (duration (- end-time start-time))
         (base-count (test-group-ref group 'count 0))
         (base-pass (test-group-ref group 'PASS 0))
         (base-fail (test-group-ref group 'FAIL 0))
         (base-err (test-group-ref group 'ERROR 0))
         (skip (test-group-ref group 'SKIP 0))
         (pass (+ base-pass (test-group-ref group 'total-pass 0)))
         (fail (+ base-fail (test-group-ref group 'total-fail 0)))
         (err (+ base-err (test-group-ref group 'total-error 0)))
         (count (+ pass fail err))
         (subgroups-count (test-group-ref group 'subgroups-count 0))
         (subgroups-skip (test-group-ref group 'subgroups-skip 0))
         (subgroups-run (- subgroups-count subgroups-skip))
         (subgroups-pass (test-group-ref group 'subgroups-pass 0))
         (indent (indent-string (test-group-indent-width group))))
    (when (or (positive? count) (positive? subgroups-count))
      (if (not (= base-count (+ base-pass base-fail base-err)))
          (warning "inconsistent count:"
                   base-count base-pass base-fail base-err))
      (when (positive? count)
        (display indent)
        (display
         ((if (= pass count) green (lambda (x) x))
          (string-append
           (number->string pass) " out of " (number->string count)
           (percent pass count))))
        (display
         (string-append
          (plural " test" pass) " passed in "
          (number->string duration) " seconds"
          (cond
           ((zero? skip) "")
           (else (string-append " (" (number->string skip)
                                (plural " test" skip) " skipped)")))
          ".")))
      (when (positive? fail)
        (display indent)
        (display
         (red
          (string-append
           (number->string fail) (plural " failure" fail)
           (percent fail count) "."))))
      (when (positive? err)
        (display indent)
        (display
         ((lambda (x) (underline (red x)))
          (string-append
           (number->string err) (plural " error" err)
           (percent err count) "."))))
      (unless (test-group-ref group 'verbose)
        (for-each
         (lambda (failure)
           (display indent)
           (display (red
                     (string-append (display-to-string (cadr failure)) ": ")))
           (display (test-get-name! (car (cddr failure))))
           (apply test-print-failure failure))
         (reverse (or (test-group-ref group 'failures) '()))))
      (when (positive? subgroups-run)
        (display indent)
        (display
         ((if (= subgroups-pass subgroups-run)
              green (lambda (x) x))
          (string-append
           (number->string subgroups-pass) " out of "
           (number->string subgroups-run)
           (percent subgroups-pass subgroups-run))))
        (display (plural " subgroup" subgroups-pass))
        (display " passed.")))
    (when (test-group-ref group 'verbose)
      (display (test-group-line group #f)))
    (cond
     ((test-group-ref group 'parent)
      => (lambda (parent)
           (test-group-set! parent 'trailing #f)
           (test-group-inc! parent 'total-pass pass)
           (test-group-inc! parent 'total-fail fail)
           (test-group-inc! parent 'total-error err)))
     (else
      (when (zero? (test-group-ref group 'level))
        (newline))))))

(define test-default-group-reporter
  (case-lambda
   ((group)        (close-group group))
   ((group parent) (display (test-group-line group 'open)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; parameters

;;> \section{Parameters}

;;> The current test group as started by \scheme{test-group} or
;;> \scheme{test-begin}.

(define current-test-group (make-parameter #f))

;;> If true, show more verbose output per test.  Inferred from the
;;> environment variable TEST_VERBOSE.

(define current-test-verbosity
  (make-parameter
   (cond ((get-environment-variable "TEST_VERBOSE")
          => (lambda (s) (not (member s '("" "0")))))
         (else #f))))

;;> The epsilon used for floating point comparisons.

(define current-test-epsilon (make-parameter 1e-5))

;;> The underlying comparator used in testing, defaults to
;;> \scheme{test-equal?}.

(define current-test-comparator (make-parameter test-equal?))

;;> The test applier - what we do with non-skipped tests.  Takes the
;;> same signature as \scheme{test-run}, should be responsible for
;;> evaluating the thunks, determining the status of the test, and
;;> passing this information to \scheme{current-test-reporter}.

(define current-test-applier (make-parameter test-default-applier))

;;> The test skipper - what we do with non-skipped tests.  This should
;;> not evaluate the thunks and simply pass off to
;;> \scheme{current-test-reporter}.

(define current-test-skipper (make-parameter test-default-skipper))

;;> Takes two arguments, the symbol status of the test and the info
;;> alist.  The status is one of \scheme{'BEGIN}, \scheme{'PASS},
;;> \scheme{'FAIL}, \scheme{'ERROR}, or \scheme{'SKIP}.  For each test
;;> a reporter is called twice: once with symbol \scheme{'BEGIN} to
;;> indicate that handling of the test begins and a second time when
;;> the result was determined.  A test reporter returns the tests
;;> result and updates bookkeeping in the current test group for
;;> reporting.

(define current-test-reporter (make-parameter test-default-reporter))

;;> Takes one argument, a test group, and prints a summary of the test
;;> results for that group.

(define current-test-group-reporter
  (make-parameter test-default-group-reporter))

;;> A running count of all test failures and errors across all groups
;;> (and threads).  Used by \scheme{test-exit}.

(define test-failure-count (make-parameter 0))

(define test-first-indentation
  (make-parameter
   (or (cond ((get-environment-variable "TEST_FIRST_INDENTATION")
              => string->number)
             (else #f))
       1)))

(define test-max-indentation
  (make-parameter
   (or (cond ((get-environment-variable "TEST_MAX_INDENTATION")
              => string->number)
             (else #f))
       5)))

(define (string->info-matcher str)
  (lambda (info)
    (cond ((test-get-name! info)
           => (lambda (n) (string-search str n)))
          (else #f))))

(define (string->group-matcher str)
  (lambda (group) (string-search str (test-group-name group))))

;; simplified version from SRFI 130
(define (string-split str ch)
  (let ((end (string-length str)))
    (let lp ((from 0) (to 0) (res '()))
      (cond
       ((>= to end)
        (reverse (if (> to from) (cons (substring str from to) res) res)))
       ((eqv? ch (string-ref str to))
        (lp (+ to 1) (+ to 1) (cons (substring str from to) res)))
       (else
        (lp from (+ to 1) res))))))

(define (getenv-filter-list proc name)
  (cond
   ((get-environment-variable name)
    => (lambda (s)
         (let lp ((ls (string-split s #\,))
                  (res '()))
           (cond
            ((null? ls) (reverse res))
            (else
             (let* ((s (car ls))
                    (f (guard
                           (exn
                            (else
                             (warning
                              (string-append "invalid filter '" s
                                             "' from environment variable: "
                                             name))
                             (print-exception exn (current-error-port))
                             #f))
                         (proc s))))
               (lp (cdr ls) (if f (cons f res) res))))))))
   (else '())))

(define current-test-group-filters
  (make-parameter
   (getenv-filter-list string->group-matcher "TEST_GROUP_FILTER")))

(define current-test-group-removers
  (make-parameter
   (getenv-filter-list string->group-matcher "TEST_GROUP_REMOVE")))

;;> Parameters controlling which test groups are skipped.  Each
;;> parameter is a list of procedures of one argument, a test group
;;> info, which can be queried with \var{test-group-name} and
;;> \var{test-group-ref}.  Analogous to SRFI 1, a filter selects a
;;> group for inclusion and a removers for exclusion.  The defaults
;;> are set automatically from the environment variables
;;> TEST_GROUP_FILTER and TEST_GROUP_REMOVE, which should be
;;> comma-delimited lists of strings which are checked for a substring
;;> match in the test group name.  A test group is skipped if it does
;;> not match any filter and:
;;> \itemlist[
;;> \item{its parent group is skipped, or}
;;> \item{it matches a remover, or}
;;> \item{no removers are specified but some filters are}
;;> ]
;;/

(define current-test-filters
  (make-parameter (getenv-filter-list string->info-matcher "TEST_FILTER")))

(define current-test-removers
  (make-parameter (getenv-filter-list string->info-matcher "TEST_REMOVE")))

;;> Parameters controlling which tests are skipped.  Each parameter is
;;> a list of procedures of one argument, a test info alist, which can
;;> be queried with \scheme{test-get-name!} or \scheme{assq}.
;;> Analogous to SRFI 1, a filter selects a test for inclusion and a
;;> removers for exclusion.  The defaults are set automatically from
;;> the environment variables TEST_FILTER and TEST_REMOVE, which
;;> should be comma-delimited lists of strings which are checked for a
;;> substring match in the test name.  A test is skipped if its group
;;> is skipped, or if it does not match a filter and:
;;> \itemlist[
;;> \item{it matches a remover, or}
;;> \item{no removers are specified but some filters are}
;;> ]
;;/

;;> Parameter controlling the current column width for test output,
;;> can be set from the environment variable TEST_COLUMN_WIDTH,
;;> otherwise defaults to 78.  For portability of implementation (and
;;> resulting output), does not attempt to use termios to determine
;;> the actual available width.

(define current-column-width
  (make-parameter
   (or (cond ((get-environment-variable "TEST_COLUMN_WIDTH")
              => string->number)
             (else #f))
       78)))

;;> Parameter controlling the indent in spaces for a group in test
;;> output, can be set from the environment variable TEST_GROUP_INDENT,
;;> otherwise defaults to 4.

(define current-group-indent
  (make-parameter
   (or (cond ((get-environment-variable "TEST_GROUP_INDENT")
              => string->number)
             (else #f))
       4)))

(define-library (chibi shell)
  (import (scheme base) (scheme bitwise) (scheme char) (scheme cxr)
          (scheme list) (scheme write) (srfi 130)
          (chibi io) (chibi filesystem) (chibi process)
          (only (chibi) port-fileno define-auxiliary-syntax))
  (export shell shell& shell-pipe call-with-shell-io
          shell->string shell->string-list
          shell->sexp shell->sexp-list
          shell-if shell-and shell-or shell-do
          in< out> err> out>> err>> >< >> <<)
  (begin
    (define shell-fork fork)
    (define shell-exec execute)
    (define shell-exit exit)
    (define (shell-wait pid)
      (cadr (waitpid pid 0)))
    (define (shell-create-pipe) (apply cons (open-pipe)))
    (define shell-dup duplicate-file-descriptor-to)
    (define shell-open-input open-input-file-descriptor)
    (define shell-open-output open-output-file-descriptor)
    (define shell-close close-file-descriptor)
    (define (shell-port->fd port)
      (port-fileno port))
    (define (shell-fd->input-port fd)
      (open-input-file-descriptor fd))
    (define (shell-fd->output-port fd)
      (open-output-file-descriptor fd)))
  (include "shell.scm"))

;; utility for lcs-with-positions
(define (max-seq . o)
  (if (null? o)
      (list 0 '())
      (let loop ((a (car o)) (ls (cdr o)))
        (if (null? ls)
            a
            (let ((b (car ls)))
              (if (>= (car a) (car b))
                  (loop a (cdr ls))
                  (loop b (cdr ls))))))))

;;> Finds the Longest Common Subsequence between \var{a-ls} and
;;> \var{b-ls}, comparing elements with \var{eq} (default
;;> \scheme{equal?}.  Returns this sequence as a list, using the
;;> elements from \var{a-ls}.  Uses quadratic time and space.
(define (lcs a-ls b-ls . o)
  (let ((eq (if (pair? o) (car o) equal?)))
    (map car (lcs-with-positions a-ls b-ls eq))))

;;> Variant of \scheme{lcs} which returns the annotated sequence.  The
;;> result is a list of the common elements, each represented as a
;;> list of 3 values: the element, the zero-indexed position in
;;> \var{a-ls} where the element occurred, and the position in
;;> \var{b-ls}.
(define (lcs-with-positions a-ls b-ls . o)
  (let* ((eq (if (pair? o) (car o) equal?))
         (a-len (+ 1 (length a-ls)))
         (b-len (+ 1 (length b-ls)))
         (results (make-vector (* a-len b-len) #f)))
    (let loop ((a a-ls) (a-pos 0) (b b-ls) (b-pos 0))
      ;; cache this step if not already done
      (let ((i (+ (* a-pos b-len) b-pos)))
        (or (vector-ref results i)
            (let ((res
                   (if (or (null? a) (null? b))
                       (list 0 '()) ;; base case
                       (let ((a1 (car a))
                             (b1 (car b))
                             (a-tail (loop (cdr a) (+ a-pos 1) b b-pos))
                             (b-tail (loop a a-pos (cdr b) (+ b-pos 1))))
                         (cond
                          ((eq a1 b1)
                           ;; match found, we either use it or we don't
                           (let* ((a-b-tail (loop (cdr a) (+ a-pos 1)
                                                  (cdr b) (+ b-pos 1)))
                                  (a-b-res (list (+ 1 (car a-b-tail))
                                                 (cons (list a1 a-pos b-pos)
                                                       (cadr a-b-tail)))))
                             (max-seq a-b-res a-tail b-tail)))
                          (else
                           ;; not a match
                           (max-seq a-tail b-tail)))))))
              (vector-set! results i res)
              res))))
    (cadr (vector-ref results 0))))

(define (source->list x reader)
  (port->list
   reader
   (cond ((port? x) x)
         ((string? x) (open-input-string x))
         (else (error "don't know how to diff from:" x)))))

;;> Utility to run lcs on text.  \var{a} and \var{b} can be strings or
;;> ports, which are tokenized into a sequence by calling \var{reader}
;;> until \var{eof-object} is found.  Returns a list of three values,
;;> the sequences read from \var{a} and \var{b}, and the \scheme{lcs}
;;> result.  Unless \var{minimal?} is set, we trim common
;;> prefixes/suffixes before computing the lcs.
(define (diff a b . o)
  (let-optionals o ((reader read-line)
                    (eq equal?)
                    (optimal? #f))
    (let ((a-ls (source->list a reader))
          (b-ls (source->list b reader)))
      (if optimal?
          (list a-ls b-ls (lcs-with-positions a-ls b-ls eq))
          (let lp1 ((i 0) (a a-ls) (b b-ls))
            (cond
             ((or (null? a) (null? b))  ;; prefix or equal
              (if (and (null? a) (null? b))
                  (let ((n-ls (iota (length a-ls))))  ;; equal
                    (list a-ls b-ls (map list a-ls n-ls n-ls)))
                  (list a-ls b-ls (lcs-with-positions a-ls b-ls eq))))
             ((eq (car a) (car b))
              (lp1 (+ i 1) (cdr a) (cdr b)))
             (else
              (let lp2 ((j 0) (ra (reverse a)) (rb (reverse b)))
                (cond
                 ((or (null? ra) (null? rb))  ;; can't happen
                  (list a-ls b-ls (lcs-with-positions a-ls b-ls eq)))
                 ((eq (car ra) (car rb))
                  (lp2 (+ j 1) (cdr ra) (cdr rb)))
                 (else
                  (let* ((a-ls2 (reverse ra))
                         (b-ls2 (reverse rb))
                         (a-left-len (+ i (length a-ls2)))
                         (b-left-len (+ i (length b-ls2))))
                    (list a-ls
                          b-ls
                          (append
                           (map (lambda (x i) (list x i i))
                                (take a-ls i)
                                (iota i))
                           (map (lambda (x)
                                  (list (car x)
                                        (+ i (cadr x))
                                        (+ i (car (cddr x)))))
                                (lcs-with-positions a-ls2 b-ls2 eq))
                           (map (lambda (x i)
                                  (list x (+ i a-left-len) (+ i b-left-len)))
                                (take-right a j)
                                (iota j))))))
                 )))))))))

;;> Utility to format the result of a \var{diff} to output port
;;> \var{out} (default \scheme{(current-output-port)}).  Applies
;;> \var{writer} to successive diff chunks.  \var{writer} should be a
;;> procedure of three arguments: \scheme{(writer subsequence type
;;> out).  \var{subsequence} is a subsequence from the original input,
;;> \var{type} is a symbol indicating the type of diff: \scheme{'same}
;;> if this is part of the lcs, \scheme{'add} if it is unique to the
;;> second input, or \scheme{'remove} if it is unique to the first
;;> input.  \var{writer} defaults to \scheme{write-line-diffs},
;;> assuming the default line diffs.
(define (write-diff diff . o)
  (let-optionals o ((writer write-line-diffs)
                    (out (current-output-port)))
    (let* ((a-ls (car diff))
           (b-ls (cadr diff))
           (d-ls (car (cddr diff))))
      ;; context diff
      (let lp ((d d-ls) (a a-ls) (a-pos 0) (b b-ls) (b-pos 0))
        (unless (null? d)
          (let* ((d1 (car d))
                 (a-off (cadr d1))
                 (a-skip (- a-off a-pos))
                 (b-off (car (cddr d1)))
                 (b-skip (- b-off b-pos)))
            (let-values (((a-head a-tail) (split-at a a-skip))
                         ((b-head b-tail) (split-at b b-skip)))
              ;; elements only in a have been removed
              (if (pair? a-head)
                  (writer (cdr a-head) 'remove out))
              ;; elements only in b have been added
              (if (pair? b-head)
                  (writer (cdr b-head) 'add out))
              ;; reprint this common element
              (writer (list (car d1)) 'same out)
              ;; recurse
              (lp (cdr d) a-tail a-off b-tail b-off))))))))

;;> Equivalent to \scheme{write-diff} but collects the output to a string.
(define (diff->string diff . o)
  (let ((out (open-output-string)))
    (write-diff diff (if (pair? o) (car o) write-line-diffs) out)
    (get-output-string out)))

;;> The default writer for \scheme{write-diff}, annotates simple +/-
;;> prefixes for added/removed lines.
(define (write-line-diffs lines type out)
  (for-each
   (lambda (line)
     (case type
       ((add)
        (write-char #\+ out))
       ((remove)
        (write-char #\- out))
       ((same)
        (write-char #\space out))
       (else (error "unknown diff type:" type)))
     (write-string line out)
     (newline out))
   lines))

;;> A variant of \scheme{write-line-diffs} which adds red/green ANSI
;;> coloring to the +/- prefix.
(define (write-line-diffs/color lines type out)
  (for-each
   (lambda (line)
     (case type
       ((add)
        (write-string (green "+") out)
        (write-string (green line) out))
       ((remove)
        (write-string (red "-") out)
        (write-string (red line) out))
       ((same)
        (write-char #\space out)
        (write-string line out))
       (else (error "unknown diff type:" type)))
     (newline out))
   lines))

;;> A diff writer for sequences of characters (when a diff was
;;> generated with \scheme{read-char}), enclosing added characters in
;;> ... brackets and removed characters in ....
(define (write-char-diffs chars type out)
  (case type
    ((add)
     (write-string " " out)
     (write-string (list->string chars) out)
     (write-string " " out))
    ((remove)
     (write-string " " out)
     (write-string (list->string chars) out)
     (write-string " " out))
    ((same)
     (write-string (list->string chars) out))
    (else (error "unknown diff type:" type))))

;;> A diff writer for sequences of characters (when a diff was
;;> generated with \scheme{read-char}), formatting added characters in
;;> green and removed characters in red.
(define (write-char-diffs/color chars type out)
  (case type
    ((add)
     (write-string (green (list->string chars)) out))
    ((remove)
     (write-string (red (list->string chars)) out))
    ((same)
     (write-string (list->string chars) out))
    (else (error "unknown diff type:" type))))

;;> Utility to format the result of a \scheme{diff} with respect to a
;;> single input sequence \var{ls}. \var{lcs} is the annotated common
;;> sequence from \scheme{diff} or \scheme{lcs-with-positions}, and
;;> \var{index} is the index (0 or 1, default 1) of \var{ls} in the
;;> original call.  Since we have no information about the other
;;> input, we can only format what is the same and what is different,
;;> formatting the differences as either added (if \var{index} is 0)
;;> or removed (if \var{index} is 1).
(define (write-edits ls lcs . o)
  (let-optionals o ((index 1)
                    (writer write-line-diffs)
                    (out (current-output-port)))
    (let ((type (if (eq? index 1) 'remove 'add)))
      (let lp ((ls ls) (lcs lcs) (buf '(#f)) (i 0))
        (define (output ch type)
          (cond
           ((eq? type (car buf))
            (cons type (cons ch (cdr buf))))
           (else
            (if (car buf)
                (writer (reverse (cdr buf)) (car buf) out))
            (list type ch))))
        (cond
         ((null? ls) (output #f 'done))
         ((null? lcs)
          (lp (cdr ls) lcs (output (car ls) type) (+ i 1)))
         ((= i (list-ref (car lcs) index))
          (lp (cdr ls) (cdr lcs) (output (car ls) 'same) (+ i 1)))
         (else
          (lp (cdr ls) lcs (output (car ls) type) (+ i 1))))))))

;;> Equivalent to \scheme{write-edits} but collects the output to a string.
(define (edits->string ls lcs . o)
  (let-optionals o ((type 'add)
                    (writer (if (and (pair? ls) (char? (car ls)))
                                write-char-diffs
                                write-line-diffs)))
    (let ((out (open-output-string)))
      (write-edits ls lcs type writer out)
      (get-output-string out))))

;;> Equivalent to \scheme{write-edits} but collects the output to a
;;> string and uses a color-aware writer by default.  Note with a
;;> character diff this returns the original input string as-is, with
;;> only ANSI escapes indicating what changed.
(define (edits->string/color ls lcs . o)
  (let-optionals o ((type 'add)
                    (writer (if (and (pair? ls) (char? (car ls)))
                                write-char-diffs/color
                                write-line-diffs/color)))
    (let ((out (open-output-string)))
      (write-edits ls lcs type writer out)
      (get-output-string out))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; utilities

(define (read-u16/be in)
  (let* ((i (read-u8 in))
         (j (read-u8 in)))
    (if (eof-object? j)
        (error "end of input")
        (+ (arithmetic-shift i 8) j))))

(define (read-u16/le in)
  (let* ((i (read-u8 in))
         (j (read-u8 in)))
    (if (eof-object? j)
        (error "end of input")
        (+ (arithmetic-shift j 8) i))))

(define (assert-read-u8 in i)
  (let ((i2 (read-u8 in)))
    (if (not (eqv? i i2))
        (error "unmatched value, expected: " i " but got: " i2)
        i2)))

(define (assert-read-char in ch)
  (let ((ch2 (read-char in)))
    (if (not (eqv? ch ch2))
        (error "unmatched value, expected: " ch " but got: " ch2)
        ch2)))

(define (assert-read-string in s)
  (let ((s2 (read-string (string-length s) in)))
    (if (not (equal? s s2))
        (error "unmatched value, expected: " s " but got: " s2)
        s2)))

(define (assert-read-bytevector in bv)
  (let ((bv2 (read-bytevector (bytevector-length bv) in)))
    (if (not (equal? bv bv2))
        (error "unmatched value, expected: " bv " but got: " bv2)
        bv2)))

(define (assert-read-integer in len radix)
  (let* ((s (string-trim-both (read-string len in)
                              (lambda (ch) (or (eqv? ch #\space) (eqv? ch #\null)))))
         (n (if (equal? s "") 0 (string->number s radix))))
    (or n (error "invalid number syntax: " s))))

(define (read-padded-string in len pad)
  (string-trim-right (read-string len in) pad))

(define (read-literal val)
  (cond
   ((integer? val) (lambda (in) (assert-read-u8 in val)))
   ((char? val) (lambda (in) (assert-read-char in val)))
   ((string? val) (lambda (in) (assert-read-string in val)))
   ((bytevector? val) (lambda (in) (assert-read-bytevector in val)))
   (else (error "unknown binary literal: " val))))

(define (write-literal val)
  (cond
   ((integer? val) (lambda (x out) (write-u8 val out)))
   ((char? val) (lambda (x out) (write-char val out)))
   ((string? val) (lambda (x out) (write-string val out)))
   ((bytevector? val) (lambda (x out) (write-bytevector val out)))
   (else (error "unknown binary literal: " val))))

(define (write-padded-integer out n radix len left-pad-ch right-pad-ch)
  (let ((s (string-pad (number->string n radix) (- len 1) left-pad-ch)))
    (cond
     ((>= (string-length s) len)
      (error "number too large for width" n radix len))
     (else
      (write-string s out)
      (write-char right-pad-ch out)))))

(define (write-u16/be n out)
  (write-u8 (arithmetic-shift n -8) out)
  (write-u8 (bitwise-and n #xFF) out))

(define (write-u16/le n out)
  (write-u8 (bitwise-and n #xFF) out)
  (write-u8 (arithmetic-shift n -8) out))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; syntax

(define-syntax define-auxiliary-syntax
  (syntax-rules ()
    ((define-auxiliary-syntax name)
     (define-syntax name
       (syntax-rules ()
         ((name . x)
          (syntax-error "invalid use of auxiliary syntax" (name . x))))))))

(define-auxiliary-syntax make:)
(define-auxiliary-syntax pred:)
(define-auxiliary-syntax read:)
(define-auxiliary-syntax write:)
(define-auxiliary-syntax block:)

(define-syntax syntax-let-optionals*
  (syntax-rules ()
    ((syntax-let-optionals* () type-args expr)
     expr)
    ((syntax-let-optionals* ((param default) . rest) (arg0 . args) expr)
     (let ((param arg0))
       (syntax-let-optionals* rest args expr)))
    ((syntax-let-optionals* ((param default) . rest) () expr)
     (let ((param default))
       (syntax-let-optionals* rest () expr)))
    ((syntax-let-optionals* (param . rest) (arg0 . args) expr)
     (let ((param arg0))
       (syntax-let-optionals* rest args expr)))
    ((syntax-let-optionals* (param . rest) () expr)
     (syntax-error "missing required parameter" param expr))))

(define-syntax define-binary-type
  (syntax-rules ()
    ((define-binary-type (name params ...) gen-pred gen-read gen-write)
     (define-syntax name
       (syntax-rules (pred: read: write:)
         ((name pred: type-args)
          (syntax-let-optionals* (params ...) type-args gen-pred))
         ((name read: type-args)
          (syntax-let-optionals* (params ...) type-args gen-read))
         ((name write: type-args)
          (syntax-let-optionals* (params ...) type-args gen-write)))))))

(define-binary-type (u8)
  (lambda (x) (and (exact-integer? x) (<= 0 x 255)))
  read-u8
  write-u8)

(define-binary-type (u16/le)
  (lambda (x) (and (exact-integer? x) (<= 0 x 65536)))
  read-u16/le
  write-u16/le)

(define-binary-type (u16/be)
  (lambda (x) (and (exact-integer? x) (<= 0 x 65536)))
  read-u16/be
  write-u16/be)

(define-binary-type (padded-string len (pad #\null))
  (lambda (x) (and (string? x) (<= (string-length x) len)))
  (lambda (in) (read-padded-string in len pad))
  (lambda (str out)
    (write-string (string-pad-right str len pad) out)))

(define-binary-type (fixed-string len)
  (lambda (x) (and (string? x) (= (string-length x) len)))
  (lambda (in)
    (read-string len in))
  (lambda (str out)
    (write-string str out)))

(define-binary-type (octal len)
  exact-integer?
  (lambda (in) (assert-read-integer in len 8))
  (lambda (n out)
    (write-padded-integer out n 8 len #\0 #\null)))

(define-binary-type (decimal len)
  exact-integer?
  (lambda (in) (assert-read-integer in len 10))
  (lambda (n out)
    (write-padded-integer out n 10 len #\0 #\null)))

(define-binary-type (hexadecimal len)
  exact-integer?
  (lambda (in) (assert-read-integer in len 16))
  (lambda (n out)
    (write-padded-integer out n 16 len #\0 #\null)))

(define-library (chibi scribble)
  (export scribble-parse scribble-read)
  (import (scheme base) (scheme char) (scheme read))
  (include "scribble.scm"))
(define-library (chibi filesystem-test)
  (export run-tests)
  (import (scheme base) (scheme file) (scheme write)
          (chibi filesystem) (chibi test))
  (cond-expand
   ((library (srfi 151)) (import (srfi 151)))
   ((library (srfi 33)) (import (srfi 33)))
   (else (import (srfi 60))))
  (begin
    (define (port->string in)
      (read-string 1024 in))
    (define (run-tests)
      (define tmp-file "/tmp/chibi-fs-test-0123456789")
      (define tmp-file2 "/tmp/chibi-fs-test-0123456789-2")
      (define tmp-link "/tmp/chibi-fs-test-0123456789-link")
      (define tmp-dir "/tmp/chibi-fs-test-0123456789-dir")

      (test-begin "filesystem")

      (call-with-output-file tmp-file
        (lambda (out) (display "0123456789" out)))

      (test-assert (file-exists? tmp-file))
      (test "0123456789" (call-with-input-file tmp-file port->string))

      ;; call-with-output-file truncates
      (call-with-output-file tmp-file
        (lambda (out) (display "xxxxx" out)))
      (test "xxxxx" (call-with-input-file tmp-file port->string))

      (call-with-output-file tmp-file
        (lambda (out) (display "0123456789" out)))
      (test "0123456789" (call-with-input-file tmp-file port->string))

      ;; open without open/truncate writes in place
      (let* ((fd (open tmp-file open/write))
             (out (open-output-file-descriptor fd)))
        (display "xxxxx" out)
        (close-output-port out))
      (test "xxxxx56789" (call-with-input-file tmp-file port->string))

      ;; file-truncate can explicitly truncate
      (let* ((fd (open tmp-file open/write))
             (out (open-output-file-descriptor fd)))
        (display "01234" out)
        (file-truncate out 7)
        (close-output-port out))
      (test "0123456" (call-with-input-file tmp-file port->string))

      ;; symbolic links
      (test-assert (symbolic-link-file tmp-file tmp-link))
      (test-assert (file-exists? tmp-link))
      (test-assert (file-link? tmp-link))
      (test tmp-file (read-link tmp-link))

      ;; rename
      (test-assert (rename-file tmp-file tmp-file2))
      (test-not (file-exists? tmp-file))
      (test-not (file-exists? tmp-link))
      (test-assert (file-link? tmp-link))
      (test-assert (delete-file tmp-link))
      (test-not (file-exists? tmp-link))

      ;; cleanup
      (test-assert (delete-file tmp-file2))
      (test-not (file-exists? tmp-file2))

      ;; directories
      (test-assert (file-directory? "."))
      (test-assert (file-directory? ".."))
      (test-assert (file-directory? "/"))
      (test-not (file-regular? "."))
      (test-assert (create-directory tmp-dir))
      (test-assert (file-directory? tmp-dir))
      (test-not (file-regular? tmp-dir))
      (test-assert
          (let ((files (directory-files tmp-dir)))
            (or (equal? files '("." ".."))
                (equal? files '(".." ".")))))
      (test-assert (delete-directory tmp-dir))
      (test-not (file-directory? tmp-dir))

      (test-end))))

(define-library (chibi net server-util)
  (import (chibi) (chibi io) (chibi net) (chibi string) (chibi uri)
          (chibi process) (chibi time) (chibi pathname) (chibi filesystem)
          (chibi temp-file)
          (srfi 69) (srfi 151))
  (export line-handler command-handler parse-command
          get-host file-mime-type)
  (include "server-util.scm"))

(define-library (chibi net http-server)
  (export
   ;; main interface
   run-http-server
   ;; basic servlets
   http-chain-servlets http-default-servlet http-wrap-default
   http-file-servlet http-procedure-servlet http-ext-servlet
   http-regexp-servlet http-path-regexp-servlet http-uri-regexp-servlet
   http-host-regexp-servlet http-redirect-servlet http-rewrite-servlet
   http-cgi-bin-dir-servlet http-scheme-script-dir-servlet)
  (import
   (scheme time) (srfi 39) (srfi 95)
   (chibi) (chibi mime) (chibi regexp) (chibi pathname) (chibi uri)
   (chibi filesystem) (chibi io) (chibi string) (chibi process)
   (chibi net) (chibi net server) (chibi net server-util) (chibi net servlet)
   (chibi app) (chibi ast) (chibi config) (chibi log) (chibi memoize)
   (chibi temp-file))
  (include "http-server.scm"))
;; http.scm -- http client
;; Copyright (c) 2009-2017 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; string utils

(define (string-char-index str c . o)
  (let ((start (if (pair? o) (car o) 0))
        (end (if (and (pair? o) (pair? (cdr o))) (cadr o) (string-length str))))
    (let lp ((i start))
      (cond
       ((= i end) #f)
       ((eq? c (string-ref str i)) i)
       (else (lp (+ i 1)))))))

(define (string-split str ch)
  (let ((len (string-length str)))
    (let lp ((i 0) (res '()))
      (let ((j (string-char-index str ch i)))
        (if j
            (lp (+ j 1) (cons (substring str i j) res))
            (reverse (cons (substring str i len) res)))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; client utils

(define http-user-agent "chibi")

(define http-redirect-limit 10)
(define http-chunked-buffer-size 4096)
(define http-chunked-size-limit 409600)

(define (string-scan str ch . o)
  (let ((start (if (pair? o) (car o) 0))
        (end (if (and (pair? o) (pair? (cdr o))) (cadr o) (string-length str))))
    (let lp ((i start))
      (and (< i end)
           (if (eqv? ch (string-ref str i))
               i
               (lp (+ i 1)))))))

(define (http-parse-response line)
  (let* ((len (string-length line))
         (i (or (string-scan line #\space 0 len) len))
         (j (or (string-scan line #\space (+ i 1) len) len))
         (n (and (< i j) (string->number (substring line (+ i 1) j)))))
    (if (not (integer? n))
        (error "bad response" line i j)
        (list (substring line 0 i)
              n
              (if (>= j len) "" (substring line (+ j 1) len))))))

(define (http-wrap-chunked-input-port in)
  (define (read-chunk in)
    (let* ((line (read-line in))
           (n (and (string? line) (string->number line 16))))
      (cond
       ((not (and (integer? n) (<= 0 n http-chunked-size-limit)))
        (error "invalid chunked size line" line))
       ((zero? n) "")
       (else (read-bytevector n in)))))
  (make-generated-binary-input-port
   (lambda () (read-chunk in))))

(define (http-generate-boundary)
  (string-append "chibi-boundary-"
                 (number->string (random-integer 1000000000))))

;; A body can be a raw string or bytevector, or an alist of name/value
;; pairs.
(define (http-send-body headers body out)
  (cond
   ((string? body)
    (display body out))
   ((bytevector? body)
    (write-bytevector body out))
   ((pair? body)
    (let* ((ctype (cond ((or (assq 'Content-Type headers)
                             (assq 'content-type headers))
                         => (lambda (x)
                              (mime-parse-content-type (cdr x))))
                        (else #f)))
           (boundary (and ctype (assq-ref (cdr ctype) 'boundary))))
      (for-each
       (lambda (x)
         (display "\r\n--" out)
         (if boundary (display boundary out))
         (let* ((content
                 (if (pair? (cdr x))
                     (cond ((assq 'value (cdr x)) => cdr)
                           ((assq 'file (cdr x)) =>
                            (lambda (x)
                              (port->bytevector
                               (open-binary-input-file (cdr x)))))
                           (else (error "unknown content: " x)))
                     (cdr x)))
                (content-type
                 (cond ((and (pair? (cdr x))
                             (or (assq 'content-type (cdr x))
                                 (assq 'Content-Type (cdr x))))
                        => cdr)
                       ((string? content) "text/plain")
                       (else "application/octet-stream"))))
           (display "\r\nContent-Disposition: form-data; name=\"" out)
           (display (car x) out)
           (display "\"" out)
           (cond ((and (pair? (cdr x)) (assq 'file (cdr x)))
                  => (lambda (x)
                       (display "; filename=\"" out)
                       (display (cdr x) out)
                       (display "\"" out))))
           (display "\r\nContent-Type: " out)
           (display content-type out)
           (display "\r\n\r\n" out)
           (http-send-body headers content out)))
       body)
      (display "\r\n--" out)
      (if boundary (display boundary out))
      (display "--\r\n" out)))
   (body
    (error "unknown body" body))))

(define (http-call-method method url in-headers body limit)
  (if (<= limit 0)
      (error "http-get: redirect limit reached" (uri->string url))
      (let* ((uri (if (uri? url) url (string->uri url)))
             (host (and uri (uri-host uri))))
        (if (not host)
            (error "invalid url" url)
            (let* ((io (open-net-io
                        host
                        (or (uri-port uri)
                            (if (eq? 'https (uri-scheme uri)) 443 80))
                        (assq-ref in-headers 'blocking)))
                   (in (cadr io))
                   (out (car (cddr io))))
              (display method out)
              (display " " out)
              (display (or (uri-path uri) "/") out)
              (cond
               ((uri-query uri)
                (display "?" out)
                (display (uri-query uri) out)))
              (display " HTTP/1.0\r\n" out)
              (display "Host: " out) (display host out) (display "\r\n" out)
              (cond
               ((not (assq-ref in-headers 'user-agent))
                (display "User-Agent: " out)
                (display http-user-agent out)
                (display "\r\n" out)))
              (for-each
               (lambda (x)
                 (cond
                  ((not (eq? 'blocking (car x)))
                   (display (car x) out)  (display ": " out)
                   (display (cdr x) out) (display "\r\n" out))))
               in-headers)
              (display "Connection: close\r\n\r\n" out)
              (http-send-body in-headers body out)
              (flush-output-port out)
              (let* ((resp (http-parse-response (read-line in)))
                     (headers (mime-headers->list in))
                     (status (quotient (cadr resp) 100)))
                (case status
                  ((2)
                   (let ((enc (assq-ref headers 'transfer-encoding)))
                     (cond
                      ((equal? enc "chunked")
                       (cons headers (http-wrap-chunked-input-port in)))
                      (else
                       (cons headers in)))))
                  ((3)
                   (close-input-port in)
                   (close-output-port out)
                   (let ((url2 (assq-ref headers 'location)))
                     (if url2
                         (http-get/raw url2 in-headers (- limit 1))
                         (error "redirect with no location header" url url2))))
                  (else
                   (close-input-port in)
                   (close-output-port out)
                   (error "couldn't retrieve url" (uri->string url) resp)))))))))

(define (http-get/raw url headers limit)
  (http-call-method 'GET url headers #f limit))

(define (http-get/headers url . headers)
  (http-get/raw url
                (if (pair? headers) (car headers) '())
                http-redirect-limit))

(define (http-get url . headers)
  (cdr (apply http-get/headers url headers)))

(define (http-head url . headers)
  (car (http-call-method 'HEAD url
                         (if (pair? headers) (car headers) '()) #f
                         http-redirect-limit)))

(define (http-post url body . o)
  (let* ((headers (if (pair? o) (car o) '()))
         (headers
          (if (or (assq 'content-type headers)
                  (assq 'Content-Type headers))
              headers
              (let ((boundary (http-generate-boundary)))
                `((Content-Type . ,(string-append
                                    "multipart/form-data; boundary="
                                    boundary))
                  ,@headers))))
         (body
          (let ((out (open-output-bytevector)))
            (http-send-body headers body out)
            (get-output-bytevector out)))
         (headers
          (if (or (assq 'content-length headers)
                  (assq 'Content-Length headers))
              headers
              `((Content-Length . ,(bytevector-length body))
                ,@headers))))
    (cdr (http-call-method 'POST url headers body http-redirect-limit))))

(define (http-put url body . headers)
  (cdr (http-call-method 'PUT url
                         (if (pair? headers) (car headers) '()) body
                         http-redirect-limit)))

(define (http-delete url . headers)
  (cdr (http-call-method 'DELETE url
                         (if (pair? headers) (car headers) '()) #f
                         http-redirect-limit)))

(define (call-with-input-url url proc)
  (let* ((p (http-get url))
         (res (proc p)))
    (close-input-port p)
    res))

(define (call-with-input-url/headers url proc)
  (let* ((h+p (http-get/headers url))
         (res (proc (car h+p) (cdr h+p))))
    (close-input-port (cdr h+p))
    res))

(define (with-input-from-url url thunk)
  (let ((p (http-get url)))
    (let ((res (parameterize ((current-input-port p)) (thunk))))
      (close-input-port p)
      res)))

(define (http-get-to-file url path)
  (call-with-input-url url
    (lambda (in)
      (let ((out (open-binary-output-file path)))
        (let lp ()
          (let ((c (read-u8 in)))
            (cond ((not (eof-object? c))
                   (write-u8 c out)
                   (lp)))))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; server utils

;;> Read and parse a request line.
(define (http-parse-request . o)
  (let ((line (string-split
               (read-line (if (pair? o) (car o) (current-input-port)) 4096))))
    (cons (string->symbol (car line)) (cdr line))))

;;> Parse a form body with a given URI and MIME headers (as parsed
;;> with \scheme{mime-headers->list}).  Returns an alist of
;;> \scheme{(name . value)} for every query or form parameter.
(define (http-parse-form uri headers . o)
  (let* ((in (if (pair? o) (car o) (current-input-port)))
         (type (assq-ref headers
                         'content-type
                         "application/x-www-form-urlencoded")) 
         (query0 (or (uri-query (if (string? uri) (string->uri uri) uri)) '()))
         (query (if (string? query0) (uri-query->alist query0) query0)))
    (cond
     ((and (>= (string-length type) 10)
           (string-ci=? "multipart/" (substring type 0 10)))
      (let ((mime (mime-message->sxml in headers)))
        (append
         (let lp ((ls (cddr mime))
                  (res '()))
           (cond
            ((null? ls)
             res)
            ((and (pair? (car ls))
                  (eq? 'mime (caar ls))
                  (pair? (cdar ls))
                  (pair? (car (cdar ls)))
                  (memq (caar (cdar ls)) '(^ @)))
             (let* ((disp0 (assq-ref (cdar (cdar ls)) 'content-disposition ""))
                    (disp (mime-parse-content-type disp0))
                    (name (assq-ref disp 'name)))
               (if name
                   (lp (cdr ls) (cons (cons name (cadr (cdar ls))) res))
                   (lp (cdr ls) res))))
            (else
             (lp (cdr ls) res))))
         query)))
     (else
      query))))

(define-library (chibi net servlet)
  (export
   ;; uploads
   upload? upload-name upload-filename
   upload-headers upload->string upload-input-port upload-save
   upload->bytevector upload->sexp upload-binary-input-port
   ;; requests
   request? request-method request-host request-uploads
   request-uri request-version request-headers request-body request-params
   request-in request-out request-sock request-addr request-param
   request-method-set! request-host-set! request-uri-set!
   request-version-set! request-headers-set! request-body-set!
   request-params-set! request-in-set! request-out-set!
   request-sock-set! request-addr-set!
   request-param request-param-list request-upload request-upload-list
   request-uri-string request-with-uri request-path
   copy-request make-request make-cgi-request
   ;; servlets
   servlet-write servlet-write-status servlet-respond servlet-parse-body!
   make-status-servlet servlet-handler servlet-run
   servlet-bad-request)
  (import
   (scheme base) (scheme read) (scheme write) (scheme file)
   (srfi 9) (srfi 39) (srfi 69) (srfi 98)
   (chibi ast) (chibi io) (chibi uri) (chibi mime) (chibi log) (chibi config)
   (chibi filesystem) (chibi net) (chibi net server-util))
  (include "servlet.scm"))
;; Copyright (c) 2012 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

(define default-max-requests 10000)

(define (make-socket-listener-thunk listener port)
  (lambda ()
    (let ((addr (get-address-info #f port)))
      (cond
       ((accept listener
                (address-info-address addr)
                (address-info-address-length addr))
        => (lambda (sock) (list sock addr)))
       (else #f)))))

(define (make-listener-thunk x)
  (cond
   ((integer? x)
    (make-socket-listener-thunk
     (make-listener-socket (get-address-info #f x))
     x))
   ((address-info? x)
    (make-socket-listener-thunk (make-listener-socket x) 80))
   ((fileno? x)
    (make-socket-listener-thunk x 80))
   ((procedure? x)
    x)
   (else
    (error "expected a listener socket, fileno or thunk" x))))

(define (run-net-server listener-or-addr handler . o)
  (let ((listener-thunk (make-listener-thunk listener-or-addr))
        (max-requests
         (or
          (cond ((pair? o) (car o))
                ((get-environment-variable "CHIBI_NET_SERVER_MAX_THREADS")
                 => string->number)
                (else #f))
          default-max-requests)))
    (define (run sock addr count)
      (log-debug "net-server: accepting request: " count " "
                 (sockaddr-name (address-info-address addr)))
      (let ((ports
             (protect (exn
                       (else
                        (log-error "net-server: couldn't create port: " sock)
                        (close-file-descriptor sock)))
               (cons (open-input-file-descriptor sock)
                     (open-output-file-descriptor sock)))))
        (protect (exn
                  (else (log-error "net-server: error in request: " count)
                        (print-exception exn)
                        (print-stack-trace exn)
                        (close-input-port (car ports))
                        (close-output-port (cdr ports))
                        (close-file-descriptor sock)))
          (handler (car ports) (cdr ports) sock addr)
          (flush-output (cdr ports))
          (close-input-port (car ports))
          (close-output-port (cdr ports))
          (close-file-descriptor sock)))
      (log-debug "net-server: finished: " count))
    (let ((requests 0))
      (let serve ((count 0))
        (if (>= requests  max-requests)
            (thread-yield!)
            (let ((sock+addr (listener-thunk)))
              (cond
               ((not sock+addr)
                (serve count))
               ((= 1 max-requests)
                (run (car sock+addr) (cadr sock+addr) count)
                (serve (+ 1 count)))
               (else
                (thread-start!
                 (make-thread
                  (lambda ()
                    (set! requests (+ requests 1))
                    (run (car sock+addr) (cadr sock+addr) count)
                    (set! requests (- requests 1)))
                  (string-append "net-client-" (number->string count))))
                (serve (+ 1 count))))))))))

(define (get-host uri headers)
  (cond
   ((assq 'host headers)
    => (lambda (x)
         (let ((s (string-trim (cdr x))))
           (substring-cursor s (string-cursor-start s) (string-find s #\:)))))
   ((uri-host uri))
   (else "localhost")))

(define (line-handler handler)
  (lambda (in out sock addr)
    (let ((line (read-line in)))
      (if (eof-object? line)
          #f
          (handler line in out sock addr)))))

(define (parse-command line)
  (let ((ls (string-split line #\space)))
    (cons (string->symbol (car ls)) (cdr ls))))

(define (command-handler handler)
  (line-handler
   (cond
    ((hash-table? handler)
     (lambda (line in out sock addr)
       (let ((ls (parse-command line)))
         (cond
          ((hash-table-ref/default handler (car ls))
           => (lambda (handler)
                (handler (car ls) (cdr ls) in out sock addr)))))))
    ((list? handler)
     (lambda (line in out sock addr)
       (let ((ls (parse-command line)))
         (cond
          ((assq (car ls) handler)
           => (lambda (cell)
                ((cdr cell) (car ls) (cdr ls) in out sock addr)))))))
    ((procedure? handler)
     (lambda (line in out sock addr)
       (let ((ls (parse-command line)))
         (handler (car ls) (cdr ls) in out sock addr))))
    (else
     (error "invalid handler" handler)))))

(define (load-mime-types ht file)
  (protect
      (exn
       (else
        (display "couldn't load mime types from " (current-error-port))
        (write file (current-error-port))
        (newline (current-error-port))
        (print-exception exn)))
    (call-with-input-file file
      (lambda (in)
        (let lp ()
          (let ((line (read-line in)))
            (cond
             ((not (eof-object? line))
              (let ((ls (string-split
                         (cond ((string-find line #\#)
                                => (lambda (i) (substring-cursor line (string-cursor-start line) i)))
                               (else line)))))
                (if (and (pair? ls) (pair? (cdr ls)))
                    (for-each
                     (lambda (x)
                       (hash-table-set! ht (string->symbol x) (car ls)))
                     (cdr ls)))
                (lp))))))))))

(define file-mime-type
  (let ((ext-types #f))
    (lambda (file . o)
      ;; set mime types on first use
      (if (not ext-types)
          (let ((ht (make-hash-table eq?)))
            (cond
             ((find file-exists? '("/etc/mime.types"
                                   "/etc/httpd/mime.types"
                                   "/etc/apache2/mime.types"))
              => (lambda (file) (load-mime-types ht file))))
            (set! ext-types ht)))
      (let* ((ext (path-extension file))
             (mtype (or (and ext (hash-table-ref/default
                                  ext-types
                                  (string->symbol
                                   (string-downcase-ascii ext))
                                  #f))
                        "application/octet-stream")))
        ;; TODO: auto-detect charset
        (if (equal? mtype "text/html")
            (string-append mtype "; charset=UTF-8")
            mtype)))))
;; servlet.scm -- basic web servlets and utilities
;; Copyright (c) 2013-2014 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

;;> Library for http and cgi servlets.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Uploads.

(define-record-type Upload
  (make-upload name filename sxml)
  upload?
  (name upload-name upload-name-set!)
  (filename upload-filename upload-filename-set!)
  (sxml upload-sxml upload-sxml-set!))

;; Currently uploads are only represented as inlined strings, but may
;; be saved to temp files in later versions so we provide only this
;; abstract API.

(define (upload-headers upload)
  (cadr (upload-sxml upload)))

(define (upload-content upload)
  (car (cddr (upload-sxml upload))))

(define (upload->string upload)
  (let ((x (upload-content upload)))
    (if (bytevector? x) (utf8->string x) x)))

(define (upload->bytevector upload)
  (let ((x (upload-content upload)))
    (if (string? x) (string->utf8 x) x)))

(define (upload->sexp upload)
  (let* ((in (upload-input-port upload))
         (res (read in)))
    (close-input-port in)
    res))

(define (upload-input-port upload)
  (open-input-string (upload->string upload)))

(define (upload-binary-input-port upload)
  (open-input-bytevector (upload->bytevector upload)))

(define (upload-save upload path)
  (let ((content (upload-content upload)))
    (call-with-output-file path
      (lambda (out)
        (if (string? content)
            (display content out)
            (write-bytevector content out))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Requests.

(define-record-type Request
  (%make-request
   method host uri version headers body params uploads in out sock addr status)
  request?
  (method request-method request-method-set!)
  (host request-host request-host-set!)
  (uri request-uri request-uri-set!)
  (version request-version request-version-set!)
  (headers request-headers request-headers-set!)
  (body request-body request-body-set!)
  (params request-params request-params-set!)
  (uploads request-uploads request-uploads-set!)
  (in request-in request-in-set!)
  (out request-out request-out-set!)
  (sock request-sock request-sock-set!)
  (addr request-addr request-addr-set!)
  (status request-status request-status-set!))

(define (request-uri-string request)
  (uri->string (request-uri request)))

(define (request-path request)
  (uri-path (request-uri request)))

(define (copy-request r)
  (%make-request
   (request-method r) (request-host r) (request-uri r) (request-version r)
   (request-headers r) (request-body r) (request-params r) (request-uploads r)
   (request-in r) (request-out r) (request-sock r) (request-addr r)
   (request-status r)))

(define (request-with-uri request uri)
  (let ((request2 (copy-request request))
        (uri (string->path-uri 'http uri)))
    (request-uri-set! request2 uri)
    ;; NOTE: this loses form parameters
    (request-params-set! request2 (uri-query->alist (or (uri-query uri) "") #t))
    request2))

(define (request-param request name . o)
  (cond ((assoc name (request-params request)) => cdr)
        (else (and (pair? o) (car o)))))

(define (assoc-multi ls key)
  (let lp ((ls ls) (res '()))
    (cond ((not (pair? ls)) (reverse res))
          ((equal? key (caar ls)) (lp (cdr ls) (cons (cdar ls) res)))
          (else (lp (cdr ls)res)))))

(define (request-param-list request name)
  (assoc-multi (request-params request) name))

(define (request-upload request name . o)
  (cond ((assoc name (request-uploads request)) => cdr)
        (else (and (pair? o) (car o)))))

(define (request-upload-list request name)
  (assoc-multi (request-uploads request) name))

(define (make-request method path version in out sock addr)
  (let* ((uri (string->path-uri 'http path))
         (headers (mime-headers->list in))
         (host (get-host uri headers))
         (params (uri-query->alist (or (uri-query uri) "") #t)))
    (%make-request method host uri version headers #f params '()
                   in out sock addr #f)))

(define (make-cgi-request)
  (let* ((method (or (get-environment-variable "REQUEST_METHOD") "GET"))
         (uri (string->path-uri
               'http (or (get-environment-variable "REQUEST_URI") "")))
         (params (uri-query->alist (or (uri-query uri) "") #t))
         (headers `((host . ,(or (get-environment-variable "HTTP_HOST")
                                 ""))))
         (host (get-host uri headers))
         (version (or (get-environment-variable "SERVER_PROTOCOL")
                      "HTTP/1.0")))
    (%make-request method host uri version headers #f params '()
                   (current-input-port) (current-output-port) #f #f #f)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Higher-level utilities.

(define (servlet-write-status out status msg)
  (display "HTTP/1.1 " out)
  (display status out)
  (display " " out)
  (display msg out)
  (display "\r\n" out))

;;> Respond with a numeric status, string message and optional headers.

(define (servlet-respond request status msg . o)
  (cond
   ((not (and (integer? status) (<= 0 status 999)))
    (error "http status must be a 3-digit integer" status))
   ((request-status request)
    (error "can't set servlet status multiple times: "
           (request-status request) status))
   (else
    (request-status-set! request status)
    (let* ((out (request-out request))
           (headers (if (pair? o) (car o) '()))
           (headers (if (assq 'Content-Type headers)
                        headers
                        `((Content-Type . "text/html; charset=UTF-8")
                          ,@headers)))
           (headers
            (cond
             ;; Socket bound, not CGI, send normal status.
             ((request-sock request)
              (servlet-write-status out status msg)
              headers)
             ;; No socket bound, we're in CGI, send status as a header.
             (else
              (let ((str (string-append (number->string status) " " msg)))
                `((Status . ,str)
                  ,@headers))))))
      (mime-write-headers headers out)
      (display "\r\n" out)
      (flush-output-port out)))))

;;> Write the contents of a string to the request.  If no status has
;;> been sent, assume a default of 200.

(define (servlet-write request str . o)
  (if (not (request-status request))
      (apply servlet-respond request 200 "OK" o))
  (display str (request-out request)))

(define (extract-form-data sxml)
  (define (form-data x)
    (and (pair? x) (eq? 'mime (car x))
         (pair? (cdr x)) (pair? (cadr x)) (eq? '@ (car (cadr x)))
         (or (string? (car (cddr x)))
             (bytevector? (car (cddr x))))
         (assq 'content-disposition (cdr (cadr x)))))
  (let lp ((ls sxml) (res '()) (files '()))
    (cond
     ((null? ls)
      (cons (reverse res) (reverse files)))
     ((form-data (car ls))
      => (lambda (x)
           (let ((disp (mime-parse-content-type (cdr x))))
             (cond
              ((and (pair? disp) (assq 'name (cdr disp)))
               => (lambda (y)
                    (let ((name (cdr y))
                          (val (cadr (cdar ls))))
                      (cond
                       ((assq 'filename (cdr disp))
                        => (lambda (z)
                             ;; If it has a filename it's an upload,
                             ;; we take the param value to be the
                             ;; filename, and accumulate the file.
                             (let ((upload (make-upload name (cdr z) (car ls))))
                               (lp (cdr ls)
                                   (cons (cons name (cdr z)) res)
                                   (cons (cons name upload) files)))))
                       (else
                        (lp (cdr ls) (cons (cons name val) res) files))))))
              (else
               (log-warn "ignoring form-data with no name: " x)
               (lp (cdr ls) res files))))))
     (else
      (lp (cdr ls) res files)))))

(define (servlet-parse-body! request . o)
  (let* ((headers (request-headers request))
         (ctype
          (mime-parse-content-type
           (cond ((assq 'content-type headers) => cdr)
                 (else ""))))
         (in (request-in request)))
    (cond
     ((and (pair? ctype) (eq? 'multipart/form-data (car ctype)))
      (let* ((sxml (mime-message->sxml in headers))
             (vars+files (extract-form-data sxml))
             (vars (append (request-params request) (car vars+files))))
        (request-body-set! request sxml)
        (request-params-set! request vars)
        (request-uploads-set! request (cdr vars+files))))
     ((and (pair? ctype) (eq? 'application/x-www-form-urlencoded (car ctype)))
      (let ((line (read-line in)))
        (request-body-set! request line)
        (if (not (eof-object? line))
            (request-params-set! request
                                 (append (request-params request)
                                         (uri-query->alist line #t)))))))))

(define (make-status-servlet status msg . o)
  (lambda (cfg request next restart)
    (apply servlet-respond request status msg o)))

(define servlet-bad-request
  (make-status-servlet 400 "Bad request"))

;; Generic interface.

(define servlet-handler (make-parameter #f))

(define (servlet-run servlet)
  (let ((handler (servlet-handler)))
    (cond
     ((procedure? handler)
      ;; A servlet handler has been set, so we're in a persistent server.
      (handler servlet))
     (else
      ;; Otherwise this is basic CGI.
      (let ((cfg (make-conf '() #f #f #f)))
        (let restart ((request (make-cgi-request)))
          (servlet cfg request servlet-bad-request restart)))))))

(define-library (chibi net http)
  (export http-get http-get/headers http-get-to-file
          http-head http-post http-put http-delete
          call-with-input-url call-with-input-url/headers
          with-input-from-url
          http-parse-request http-parse-form)
  (import (scheme base) (scheme write) (scheme char) (scheme file)
          (srfi 27)
          (chibi uri) (chibi mime))
  (cond-expand
   (chicken
    (import (only (chicken) parameterize))
    (import (only (ports) make-input-port))
    (import (only (tcp) tcp-connect))
    (begin
      (define (make-custom-binary-input-port read-bv)
        (let ((bv (make-bytevector 1024))
              (off 0)
              (fill 0))
          (define (refill!)
            (set! off 0)
            (set! fill (read-bv bv 0 1024)))
          (make-input-port
           (lambda ()
             (if (>= off fill)
                 (refill!))
             (if (< off fill)
                 (read-char (open-input-string ""))
                 (let ((res (integer->char (bytevector-u8-ref bv off))))
                   (set! off (+ 1 off))
                   res)))
           (lambda ()
             (or (< off fill)
                 (begin (refill!) (< off fill))))
           (lambda () #f))))
      (define (open-net-io host port . o)
        (call-with-values (lambda () (tcp-connect host port))
          (lambda (in out)
            (list #f in out))))
      (define (port->bytevector in)
        (let ((out (open-output-bytevector)))
          (do ((c (read-u8 in) (read-u8 in)))
              ((eof-object? c) (get-output-bytevector out))
            (write-u8 c out))))))
   (else
    (import (srfi 39) (chibi io) (chibi net))))
  (include "http.scm"))
;; http-server.scm -- combinator-based http server
;; Copyright (c) 2013-2019 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

;;> Runs an http server listening at the given address, with the given
;;> servlet.
;;>
;;> A servlet is a procedure which takes four arguments: a 
;;> \scheme{(chibi config)} config object, an \scheme{Http-Request} record,
;;> which contains the I/O ports and parsed request and headers;
;;> a \scheme{next} procedure to call the next available servlet if any,
;;> and a \scheme{restart} procedure to restart the servlets with a new
;;> request.
;;>
;;> The default config parameters are:
;;>
;;> \itemlist[
;;> \item{\scheme{port}: the port to listen on, default 8000}
;;> \item{\scheme{doc-root}: the directory to serve files from, default the directory of the config file, or "." if no config}
;;> \item{\scheme{index-regexp}: an SRE matching index files to serve in place of a directory listing when browsing directories, default "index.html"}
;;> ]
;;>
;;> A simple page view counter could be run as:
;;>
;;> \scheme{
;;> (let ((count 0))
;;>   (run-http-server
;;>    8000
;;>    (lambda (cfg request next restart)
;;>      (set! count (+ 1 count))
;;>      (servlet-write request (sxml->xml `(html (body (p ,count))))))))
;;> }

(define (run-http-server listener-or-addr servlet . o)
  (let ((cfg (if (pair? o) (car o) (make-conf '() #f #f #f))))
    (set-signal-action! signal/pipe #f)
    (run-net-server
     listener-or-addr
     (command-handler
      (lambda (command ls in out sock addr)
        (cond
         ((= 2 (length ls))
          (let ((request
                 (protect
                     (exn
                      (else
                       ;; error parsing headers, can't use servlet-respond
                       (log-error "request error: " exn ls
                                  (sockaddr-name (address-info-address addr)))
                       (servlet-write-status out 500 "Internal server error")
                       (mime-write-headers `((Status . "500")) out)
                       (display "\r\n" out)
                       #f))
                   (make-request command (car ls) (cadr ls) in out sock addr))))
            (cond
             (request
              (log-info `(request: ,command ,(car ls) ,(cadr ls)
                                   ,(request-headers request)))
              (protect (exn
                        (else
                         (log-error "internal error: " exn)
                         (print-stack-trace exn)
                         (servlet-respond request 500 "Internal server error")))
                (let restart ((request request))
                  (servlet cfg request servlet-bad-request restart)))))))
         (else
          (let ((request (make-request command "" #f in out sock addr)))
            (servlet-respond request 400 "bad request")))))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Servlets.

(define (http-chain-servlets f . o)
  (let lp ((f f) (ls o))
    (if (pair? ls)
        (let ((g (lp (car ls) (cdr ls))))
          (lambda (cfg request next restart)
            (let ((next2 (lambda (cfg request) (g cfg request next restart))))
              (f cfg request next2 restart))))
        f)))

(define (http-wrap-default servlet)
  (http-chain-servlets servlet http-default-servlet))

(define (http-guard-servlet cfg request next restart)
  (let ((orig-out (request-out request))
        (tmp-out (open-output-string))
        (request2 (copy-request request)))
    (request-out-set! request2 tmp-out)
    (protect (exn (else (servlet-respond request 500 "Interal server error")))
      (next cfg request2)
      (display (get-output-string tmp-out) orig-out))))

(define (http-parse-body-servlet cfg request next restart)
  (let ((request2 (copy-request request)))
    (servlet-parse-body! request2)
    (next cfg request2)))

(define (http-get*-servlet proc)
  (lambda (cfg request next restart)
    (if (memq (request-method request) '(GET POST))
        (proc cfg request next restart)
        (next cfg request))))

;; Generate a simple page listing the linked files in a directory.
(define (send-directory path out . o)
  (let ((base-dir (if (and (pair? o) (car o))
                      (path-relative-to path (car o))
                      path)))
    (display "<html><body bgcolor=white><pre>\n" out)
    (for-each
     (lambda (file)
       (display "<a href=\"/" out)
       (display (path-normalize (make-path base-dir file)) out)
       (display "\">" out)
       (display file out)
       (display "</a>\n" out))
     (sort (directory-files path)))
    (display "</pre></body></html>\n" out)))

;; TODO: If the index-rx is a short list of fixed strings, check
;; individually to avoid the full directory lookup.
(define (find-index-file dir index-rx)
  (and index-rx
       (any (lambda (f) (and (regexp-matches? index-rx f) (make-path dir f)))
            (directory-files dir))))

(define (http-send-directory request path index-rx restart . o)
  (cond
   ((find-index-file path index-rx)
    => (lambda (index-file)
         ;; Generate and restart a new request with explicit index file.
         (let* ((uri (request-uri request))
                (path2 (make-path (uri-path uri)
                                  (path-strip-directory index-file))))
           (restart
            (request-with-uri request (uri-with-path uri path2))))))
   (else
    (servlet-respond request 200 "OK")
    (apply send-directory path (request-out request) o))))

(define (http-send-file request path)
  (cond
   ((file-exists? path)
    (let ((headers
           (cond
            ((mime-type-from-extension (path-extension path))
             => (lambda (type) `((Content-Type . ,type))))
            (else '((Content-Type . "application/octet-stream"))))))
      (servlet-respond request 200 "OK" headers)
      (send-file path (request-out request))))
   (else
    (servlet-respond request 404 "Not Found"))))

(define (http-file-servlet . o)
  (let ((dir (if (pair? o) (car o) "."))
        (index-rx (and (pair? o) (pair? (cdr o)) (cadr o))))
    (http-get*-servlet
     (lambda (cfg request next restart)
       (let ((path (make-path dir (request-path request))))
         (if (file-directory? path)
             (http-send-directory request path index-rx restart dir)
             (http-send-file request path)))))))

(define (http-procedure-servlet path proc)
  (http-get*-servlet
   (lambda (cfg request next restart)
     (cond
      ((equal? path (path-normalize (request-path request)))
       (servlet-respond request 200 "OK")
       (proc request))
      (else
       (next cfg request))))))

(define (http-regexp-servlet rules get-field)
  (lambda (cfg request next restart)
    (let ((str (get-field request)))
      (let lp ((request request) (ls rules))
        (cond
         ((null? ls)
          (next cfg request))
         ((not (valid-sre? (caar ls)))
          (log-warn "invalid sre: " (caar ls))
          (lp request (cdr ls)))
         ((regexp-matches? (caar ls) str)
          => (lambda (m)
               (let ((next (lambda (cfg request) (lp request (cdr ls)))))
                 ((cdar ls) cfg request next restart))))
         (else
          (lp request (cdr ls))))))))

(define (http-uri-regexp-servlet rules)
  (http-regexp-servlet rules request-uri-string))

(define (http-path-regexp-servlet rules)
  (http-regexp-servlet
   rules
   (lambda (request) (uri-path (request-uri request)))))

(define (http-host-regexp-servlet rules)
  (http-regexp-servlet rules request-host))

(define (http-regexp-replace-servlet rules helper)
  (lambda (cfg request next restart)
    (let ((uri (uri->string (request-uri request))))
      (let lp ((ls rules))
        (if (null? ls)
            (next cfg request)
            (let ((uri2 (regexp-replace (caar ls) uri (cdar ls))))
              (cond
               ((equal? uri uri2)
                (lp (cdr ls)))
               ((string->path-uri 'http uri2)
                => (lambda (uri)
                     (helper cfg (request-with-uri request uri) next restart)))
               (else
                (log-warn "invalid rewritten uri: " uri2)
                (lp (cdr ls))))))))))

(define (http-redirect-servlet rules)
  (http-regexp-replace-servlet
   rules
   (lambda (cfg request next restart)
     (let ((headers `(Location . ,(uri->string (request-uri request)))))
       (servlet-respond request 302 "Found" headers)))))

(define (http-rewrite-servlet rules)
  (http-regexp-replace-servlet
   rules
   (lambda (cfg request next restart) (restart request))))

(define (index-path-map-servlet from to index-rx servlet)
  (http-get*-servlet
   (lambda (cfg request next restart)
     (let* ((path (path-normalize (uri-path (request-uri request))))
            (rel-path (path-relative-to path from)))
       (cond
        (rel-path
         (let* ((local-path (make-path to rel-path))
                (local-path
                 (if (and index-rx (file-directory? local-path))
                     (find-index-file local-path index-rx)
                     local-path)))
           (if (file-exists? local-path)
               (servlet cfg request local-path next restart)
               (servlet-respond request 404 "Not found"))))
        (else
         (next cfg request)))))))

(define (path-map-servlet from to servlet)
  (index-path-map-servlet from to #f servlet))

(define (http-cgi-bin-servlet request local-path next restart)
  (call-with-temp-file "cgi.out"
    (lambda (temp-file out preserve)
      (let ((pid (fork)))
        (cond
         ((zero? pid)
          (duplicate-file-descriptor-to
           (port-fileno (request-in request)) 0)
          (duplicate-file-descriptor-to (port-fileno out) 1)
          (safe-setenv "HTTP_HOST" (request-host request))
          (safe-setenv "REQUEST_URI" (uri->string (request-uri request)))
          (safe-setenv "REQUEST_METHOD"
                       (symbol->string (request-method request)))
          (safe-setenv "QUERY_STRING"
                       (or (uri-query (request-uri request)) ""))
          (let ((res (execute local-path (list local-path))))
            (display "failed to execute program: " (current-error-port))
            (write local-path (current-error-port))
            (display " => " (current-error-port))
            (write res (current-error-port))
            (newline (current-error-port))
            (exit 1)))
         (else
          (let ((status (waitpid pid 0)))
            (cond
             ((negative? (car status))
              (servlet-respond request 500 "Internal server error"))
             (else
              (display "HTTP/1.0 200 OK\r\n" (request-out request))
              (flush-output (request-out request))
              (send-file temp-file (request-out request))
              (close-output-port out))))))))))

(define (http-cgi-bin-dir-servlet local-dir . o)
  (let ((virtual-dir (if (pair? o) (car o) "/cgi-bin")))
    (path-map-servlet
     virtual-dir local-dir
     (lambda (cfg request prog-path next restart)
       (http-cgi-bin-servlet request prog-path next restart)))))

(define (with-add-to-load-path dir thunk)
  (if dir
      (let* ((orig-path (current-module-path))
             (new-path (cons dir (current-module-path))))
        (dynamic-wind (lambda () (current-module-path new-path))
                      thunk
                      (lambda () (current-module-path orig-path))))
      (thunk)))

(define (make-import-environment)
  (let ((env (make-environment)))
    (%import env (current-environment) '(import) #t)
    env))

(define (load-scheme-script path . o)
  (if (and (file-exists? path) (not (file-directory? path)))
      (let ((env (make-import-environment)) 
            (handle #f))
        (protect (exn (else
                       (log-error "failed to load servlet " exn)))
          (let ((e1 (call-with-input-file path read)))
            (cond
             ((not (and (pair? e1) (eq? 'import (car e1))))
              (log-error "not a scheme program (no import): " path))
             (else
              (parameterize ((servlet-handler (lambda (h) (set! handle h))))
                (with-add-to-load-path (and (pair? o) (car o))
                                       (lambda () (load path env))))))))
        (cond ((not (procedure? handle))
               (log-error "no servlet defined in " path)
               (lambda (cfg request next restart)
                 (servlet-respond request 500 "Internal server error")))
              (else handle)))
      (lambda (cfg request next restart)
        (servlet-respond request 404 "Not found"))))

(define load-scheme-script/memoized
  (memoize-file-loader load-scheme-script))

(define (http-scheme-script-dir-servlet local-dir . o)
  (let ((virtual-dir (or (and (pair? o) (car o)) "/"))
        (index-rx (and (pair? o) (pair? (cdr o)) (cadr o))))
    (index-path-map-servlet
     virtual-dir local-dir index-rx
     (lambda (cfg request script-path next restart)
       (let ((servlet (load-scheme-script/memoized script-path local-dir)))
         (servlet cfg request next restart))))))

(define (http-scheme-script-ext-servlet cfg request local-path next restart)
  ((load-scheme-script/memoized local-path) cfg request next restart))

(define (get-ext-servlet x file)
  (if (procedure? x)
      x
      (case x
        ((scheme) http-scheme-script-ext-servlet)
        ((cgi) http-cgi-bin-servlet)
        (else (error "unknown ext servlet" x)))))

(define (http-ext-servlet rules local-dir . o)
  (let ((virtual-dir (if (pair? o) (car o) "/")))
    (path-map-servlet
     virtual-dir local-dir
     (lambda (cfg request local-path next restart)
       (cond
        ((assoc (path-extension local-path) rules)
         => (lambda (cell)
              (let ((name (if (pair? (cdr cell)) (cadr cell) (cdr cell))))
                ((get-ext-servlet name local-path) cfg request local-path next restart))))
        (else
         (next cfg request)))))))

(define (http-default-servlet cfg request next restart)
  (case (request-method request)
    ((HEAD)
     (call-with-temp-file "get.out"
       (lambda (temp-file out preserve)
         (let ((request2 (copy-request request)))
           (request-method-set! request2 'GET)
           (request-out-set! request2 out)
           (restart request2)
           (close-output-port out)
           (call-with-input-file temp-file
             (lambda (in)
               (let* ((status (read-line in))
                      (headers (mime-headers->list in))
                      (out (request-out request)))
                 (display status out)
                 (display "\r\n" out)
                 (mime-write-headers headers out)
                 (display "\r\n" out))))))))
    ((BREW)
     (servlet-respond request 418 "I'm a teapot"))
    (else
     (servlet-bad-request cfg request next restart))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Config-based servlets.

;; Utility to wrap SRE rules.
(define (http-wrap-sre-config cfg clear ls)
  (map
   (lambda (x)
     (cond
      ((valid-sre? (car x))
       `(,(regexp (car x))
         . ,(http-config-servlet
             (make-conf (cdr x) (make-conf `((,clear)) cfg #f #f) #f #f))))
      (else
       (log-error "invalid sre in config: " (car x))
       `(,(regexp '(+ (~ any)))
         . ,(lambda (request) (error "unreachable servlet"))))))
   ls))

;; Utility to wrap servlets which take a local path as the first arg.
(define (http-wrap-doc-root f)
  (lambda (args cfg)
    (let* ((root (conf-get cfg 'doc-root "."))
           (local-dir (if (pair? args) (car args) "/"))
           (virtual-dir (if (and (pair? args) (pair? (cdr args)))
                            (cadr args)
                            (make-path "/" local-dir)))
           (args (append (list (make-path root local-dir) virtual-dir)
                         (if (and (pair? args) (pair? (cdr args)))
                             (cddr args)
                             '()))))
      (f args cfg))))

(define (http-config-file-servlet cfg . o)
  (let* ((root (conf-get cfg 'doc-root "."))
         (dir (make-path root (if (pair? o) (car o) ".")))
         (index-rx (if (and (pair? o) (pair? (cdr o)))
                       (cadr o)
                       (conf-get cfg 'index-regexp "index.html"))))
    (http-file-servlet dir index-rx)))

;; Ordered list of servlets to try for a given config.  Generally
;; gives the intuitive order, but manual ordering can be imposed with
;; regexp rules.
(define ordered-config-servlets
  `((redirect . ,(lambda (rules cfg) (http-redirect-servlet rules)))
    (rewrite . ,(lambda (rules cfg) (http-rewrite-servlet rules)))
    (host . ,(lambda (hosts cfg)
               (http-host-regexp-servlet
                (http-wrap-sre-config cfg 'host hosts))))
    (uri . ,(lambda (rules cfg)
              (http-uri-regexp-servlet
               (http-wrap-sre-config cfg 'uri rules))))
    (path . ,(lambda (rules cfg)
               (http-path-regexp-servlet
                (http-wrap-sre-config cfg 'path rules))))
    (file . ,(lambda (x cfg)
               (apply http-config-file-servlet cfg x)))
    (cgi . ,(http-wrap-doc-root
             (lambda (dirs cfg) (apply http-cgi-bin-dir-servlet dirs))))
    (scheme . ,(http-wrap-doc-root
                (lambda (dirs cfg)
                  (let ((local-dir (car dirs))
                        (virtual-dir (cadr dirs))
                        (index-rx (conf-get cfg 'index-regexp "index.scm")))
                    (http-scheme-script-dir-servlet
                     local-dir virtual-dir index-rx)))))
    (ext . ,(lambda (rules cfg)
              (http-ext-servlet rules (conf-get cfg 'doc-root "."))))
    ))

;; Config servlet for an already constructed config.
(define (http-config-conf-servlet cfg . o)
  (http-chain-servlets
   (lambda (orig-cfg request next restart)
     (next cfg request))
   (let lp ((ls ordered-config-servlets))
     (cond
      ((null? ls)
       (if (pair? o)
           (http-chain-servlets (car o) http-default-servlet)
           http-default-servlet))
      ((conf-get-cdr cfg (caar ls))
       => (lambda (x)
            (let ((rest (lp (cdr ls))))
              (if (or (pair? x) (null? x))
                  (http-chain-servlets ((cdar ls) x cfg) rest) 
                  rest))))
      (else
       (lp (cdr ls)))))))

;; Config servlet to load a config from a file.
(define (http-config-servlet-load file . o)
  (let* ((cfg (conf-load file))
         (cfg (if (and (pair? o) (conf? (car o)))
                  (if (and (pair? (cdr o)) (conf? (cadr o)))
                      (conf-append (car o) (conf-append cfg (cadr o)))
                      (conf-append (car o) cfg))
                  cfg)))
    (http-config-conf-servlet cfg (http-config-file-servlet cfg))))

;; Primary config servlet which dispatches on argument type.
(define (http-config-servlet x)
  (cond
   ((procedure? x)
    x)
   ((list? x)
    (http-config-conf-servlet (make-conf x #f #f (current-second))))
   ((string? x)
    (if (file-directory? x)
        (http-file-servlet x)
        (http-config-servlet (make-conf #f #f x -1))))
   ((not (conf? x))
    (error "unknown type for http-config-servlet" x))
   ((and (string? (conf-source x))
         (file-exists? (conf-source x)))
    (let* ((f (conf-source x))
           (mtime (file-modification-time f)))
      ((memoize-file-loader
        (lambda (f) (http-config-servlet-load f #f (conf-parent x)))
        'reloader?: #true
        'cache: `(((,mtime . ,f) . ,x)))
       f)))
   ((and (conf-parent x)
         (string? (conf-source (conf-parent x)))
         (file-exists? (conf-source (conf-parent x))))
    (let* ((f (conf-source (conf-parent x)))
           (mtime (file-modification-time f)))
      ((memoize-file-loader
        (lambda (f) (http-config-servlet-load f (conf-head x) (conf-parent x)))
        'reloader?: #true
        'cache: `(((,mtime . ,f) . ,x)))
       f)))
   (else
    (http-config-conf-servlet x))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Sample main.  In chibi-scheme you can run:
;;
;; chibi-scheme -Rchibi.net.http-server -- [<cfg-file-or-directory>]
;;
;; which defaults to serving the current directory on port 8000.

(define (run-app cfg spec . args)
  (define (run cfg servlet)
    (run-http-server (conf-get cfg 'port 8000) servlet cfg))
  (cond
   ((> (length args) 1)
    (error "usage: httpd [<cfg-file-or-directory>]"))
   ((or (null? args) (file-directory? (car args)))
    (let ((dir (if (null? args) "." (car args))))
      (run cfg (http-wrap-default (http-config-file-servlet cfg dir)))))
   (else
    (let* ((cfg-file (car args))
           (last-cfg
            (make-conf `((doc-root . ,(path-directory cfg-file))) #f #f #f))
           (cfg (conf-append cfg (conf-append (conf-load cfg-file) last-cfg))))
      (run cfg (http-config-servlet cfg))))))

(define app-spec
  `(http-config-server
    "Config-based HTTP server"
    (@
     ((port integer)
      (doc-root string)
      (verbose? boolean (#\v "verbose"))))
    ,run-app))

(define (main args) (run-application app-spec))

(define-library (chibi net server)
  (import (chibi) (chibi net) (chibi filesystem) (chibi log)
          (srfi 18) (srfi 98))
  (export run-net-server make-listener-thunk)
  (include "server.scm"))

(cond-expand
 (plan9
  (define (exit . o)
    (%exit (if (pair? o)
               (if (string? (car o))
                   (car o)
                   (if (eq? #t (car o)) "" "chibi error"))
               ""))))
 (else
  (define (exit . o)
    (%exit (if (pair? o)
               (if (integer? (car o))
                   (inexact->exact (car o))
                   (if (eq? #t (car o)) 0 1))
               0)))))

(cond-expand
 (bsd
  (define (process-command-line pid)
    (let ((res (%process-command-line pid)))
      ;; TODO: get command-line arguments
      (if (string? res) (list res) res))))
 (else
  (define (process-command-line pid)
    (call-with-current-continuation
     (lambda (return)
       (with-exception-handler
        (lambda (exn) (return #f))
        (lambda ()
          (let ((file (string-append "/proc/" (number->string pid) "/cmdline")))
            (call-with-input-file file
              (lambda (in)
                (let lp ((arg '()) (res '()))
                  (let ((ch (read-char in)))
                    (if (or (eof-object? ch) (eqv? (char->integer ch) 0))
                        (let ((res (cons (list->string (reverse arg)) res))
                              (ch2 (peek-char in)))
                          (if (or (eof-object? ch2)
                                  (eqv? (char->integer ch2) 0))
                              (reverse res)
                              (lp '() res)))
                        (lp (cons ch arg) res))))))))))))))

(define (process-running? pid . o)
  (let ((cmdline (process-command-line pid)))
    (and (pair? cmdline)
         (or (null? o)
             (not (car o))
             (equal? (car o) (car cmdline))))))

;;> Replaces the current process with a new image running the program
;;> \var{cmd}, with arguments in the list \var{args}.  The first
;;> argument, by convention, should be the file name being executed -
;;> an error is signaled if \var{args} is null.  The command and
;;> arguments may be symbols or numbers in addition to strings for
;;> convenience.  Equivalent to \ccode{execvp}.
(define (execute cmd args)
  (define (->string x)
    (cond ((symbol? x) (symbol->string x))
          ((eqv? -i x) "-i")
          ((number? x) (number->string x))
          (else x)))
  (if (null? args)
      (error "execute requires a non-empty argument list (command-name comes first)"))
  (execvp (->string cmd) (map ->string args)))

(define (execute-returned cmd)
  ;; we only arrive here if execute fails
  (let ((err (current-error-port)))
    (cond
     ((output-port? err)
      (display "ERROR: couldn't execute: " (current-error-port))
      (write cmd (current-error-port))
      (newline (current-error-port))))
    (exit 1)))

;;> Runs the given command \var{cmd} in a subprocess, with arguments
;;> \var{args}.  Uses a flat representation of arguments to avoid
;;> duplicates, so unlike \scheme{execute} automatically includes
;;> \var{cmd} as the first argument program name.  As a convenience,
;;> \var{cmd} itself may be a list which is appended to any arguments.
;;>
;;> The \ccode{stdin}, \ccode{stdout} and \ccode{stderr} will be
;;> inherited from the current process.  Use
;;> \scheme{call-with-process-io} if you need to capture or manipulate
;;> the subprocess IO.
;;>
;;> \emph{Examples:}
;;>
;;> \schemeblock{
;;> (system "date")
;;> Mon Aug 28 23:25:11 JST 2017
;;> }
;;>
;;> \schemeblock{
;;> (system "ls" "/usr/")
;;> bin  games  include  lib  local  sbin  share  src
;;> }
;;>
;;> \schemeblock{
;;> (system '(dc -e "2 2 + p"))
;;> 4
;;> }
(define (system cmd . args)
  (let ((pid (fork)))
    (cond
     ((zero? pid)
      (let ((cmd ((if (pair? cmd) append cons) cmd args)))
        (execute (car cmd) cmd)
        (execute-returned cmd)))
     (else
      (waitpid pid 0)))))

;;> Equivalent to \scheme{system}, but returns \scheme{#t} on success
;;> and \scheme{#f} on failure.
(define (system? cmd . args)
  (let ((res (apply system cmd args)))
    (and (pair? res) (zero? (cadr res)))))

;;> Runs the program \var{command} in a subprocess and calls
;;> \var{proc} on 4 arguments: the \var{pid}, \var{stdin},
;;> \var{stdout} and \var{stderr} of the subprocess.  \var{command}
;;> should be a list beginning with the program name followed by any
;;> args, which may be symbols or numbers for convenience as with
;;> \scheme{system}, or a string which is split on white-space.  If
;;> provided, the optional \var{child-proc} is called in the child
;;> process, after ports have been duplicated but before the command
;;> is executed, to allow for actions such as port remapping.
(define (call-with-process-io command proc . o)
  (define (set-non-blocking! fd)
    (cond-expand
     (threads
      (set-file-descriptor-status!
       fd
       (bitwise-ior open/non-block (get-file-descriptor-status fd))))
     (else
      #f)))
  (let ((child-proc (and (pair? o) (car o)))
        (command-ls (if (string? command) (string-split command) command))
        (in-pipe (open-pipe))
        (out-pipe (open-pipe))
        (err-pipe (open-pipe)))
    (and in-pipe out-pipe err-pipe
         (let ((pid (fork)))
           (cond
            ((not pid)
             (error "couldn't fork"))
            ((zero? pid)  ;; child
             (close-file-descriptor (cadr in-pipe))
             (close-file-descriptor (car out-pipe))
             (close-file-descriptor (car err-pipe))
             (duplicate-file-descriptor-to (car in-pipe) 0)
             (duplicate-file-descriptor-to (cadr out-pipe) 1)
             (duplicate-file-descriptor-to (cadr err-pipe) 2)
             (close-file-descriptor (car in-pipe))
             (close-file-descriptor (cadr out-pipe))
             (close-file-descriptor (cadr err-pipe))
             (if child-proc (child-proc))
             (execute (car command-ls) command-ls)
             (execute-returned command-ls))
            (else         ;; parent
             (close-file-descriptor (car in-pipe))
             (close-file-descriptor (cadr out-pipe))
             (close-file-descriptor (cadr err-pipe))
             (set-non-blocking! (cadr in-pipe))
             (set-non-blocking! (car out-pipe))
             (set-non-blocking! (car err-pipe))
             (proc pid
                   (open-output-file-descriptor (cadr in-pipe))
                   (open-input-file-descriptor (car out-pipe))
                   (open-input-file-descriptor (car err-pipe)))))))))

;;> Utility to run \var{command} and return the accumulated output as
;;> a bytevector.
(define (process->bytevector command)
  (call-with-process-io
   command
   (lambda (pid in out err)
     (close-output-port in)
     (let ((res (port->bytevector out)))
       (waitpid pid 0)
       (close-input-port out)
       (close-input-port err)
       res))))

;;> Utility to run \var{command} and return the accumulated output as
;;> a string.
(define (process->string command)
  (call-with-process-io
   command
   (lambda (pid in out err)
     (close-output-port in)
     (let ((res (port->string out)))
       (waitpid pid 0)
       (close-input-port out)
       (close-input-port err)
       res))))

;;> Utility to run \var{command} and return the accumulated output as
;;> a sexp, as from \scheme{read}.
(define (process->sexp command)
  (call-with-input-string (process->string command) read))

;;> Utility to run \var{command} and return a list of three values:
;;> the accumulated output as a string, the error output as a string,
;;> and the exit status as an integer.
(define (process->output+error+status command)
  (call-with-process-io
   command
   (lambda (pid in out err)
     (close-output-port in)
     (let* ((outs (port->string out))
            (errs (port->string err))
            (res (waitpid pid 0)))
       (close-input-port out)
       (close-input-port err)
       (list outs errs (cadr res))))))

;;> Utility to run \var{command} and return a list of two values:
;;> the accumulated output as a string, the error output as a string.
(define (process->output+error command)
  (let ((res (process->output+error+status command)))
    (list (car res) (cadr res))))

;;> Utility to run \var{command} and return the output as a list of
;;> strings, one for each line (trailing newlines not included).
(define (process->string-list command)
  (call-with-process-io
   command
   (lambda (pid in out err)
     (close-output-port in)
     (let ((res (port->string-list out)))
       (waitpid pid 0)
       (close-input-port out)
       (close-input-port err)
       res))))

(define-library (chibi net)
  (export sockaddr? address-info? get-address-info make-address-info
          socket connect bind accept listen open-socket-pair
          sockaddr-name sockaddr-port make-sockaddr
          with-net-io open-net-io make-listener-socket
          send receive! receive
          send/non-blocking receive!/non-blocking receive/non-blocking
          address-info-family address-info-socket-type address-info-protocol
          address-info-flags address-info-address address-info-address-length
          address-info-canonname address-info-next
          address-family/unix address-family/inet address-family/inet6
          address-family/unspecified
          socket-type/stream socket-type/datagram socket-type/raw
          ip-proto/ip ip-proto/icmp ip-proto/tcp ip-proto/udp
          ai/passive ai/canonname ai/numeric-host
          get-socket-option set-socket-option! level/socket
          socket-opt/debug socket-opt/broadcast socket-opt/reuseaddr
          socket-opt/keepalive socket-opt/oobinline socket-opt/sndbuf
          socket-opt/rcvbuf socket-opt/dontroute socket-opt/rcvlowat
          socket-opt/sndlowat
          get-peer-name
          ;; C structs
          sockaddr addrinfo)
  (import (chibi) (chibi filesystem))
  (cond-expand
   ((library (srfi 151)) (import (srfi 151)))
   ((library (srfi 33)) (import (srfi 33)))
   (else (import (srfi 60))))
  (include-shared "net")
  (include "net.scm"))

(define-library (chibi optimize)
  (import (chibi) (chibi ast) (chibi match) (srfi 1))
  (export register-lambda-optimization!
          replace-references
          fold-every join-seq dotted-tail)
  (include "optimize.scm"))
;; memoize.scm -- caching and memoization utilities
;; Copyright (c) 2003-2013 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

;;> Memory and persistent caching with various levels of control, based
;;> on a combination of lru-cache from Hato and an older memoization
;;> library for Gauche.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; types

(define-record-type Lru-Cache
  (%make-lru-cache table front back size size-limit compute-size)
  lru-cache?
  (table lru-table)
  (front lru-front lru-front-set!)
  (back lru-back lru-back-set!)
  (size lru-size lru-size-set!)
  (size-limit lru-size-limit)
  (compute-size lru-compute-size))

(define-record-type Lru-Entry
  (make-lru-entry key value size prev)
  lru-entry?
  (key lru-entry-key)
  (value lru-entry-value lru-entry-value-set!)
  (size lru-entry-size lru-entry-size-set!)
  (prev lru-entry-prev lru-entry-prev-set!))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; high-level interface

;;> Analagous to the procedure form of \scheme{define} but
;;> automatically memoizes the function.  Uses \scheme{equal?} for
;;> equality comparisons and reasonable defaults - for finer grained
;;> control use \scheme{memoize}.

(define-syntax define-memoized
  (syntax-rules ()
    ((define-memoized (proc x ...) . body)
     (define proc
       (make-memoizer (lambda (x ...) . body) (length '(x ...)) (make-lru-cache))))
    ((define-memoized (proc . x) . body)
     (define proc
       (make-memoizer (lambda x . body) #f (make-lru-cache ))))))

(define (make-memoizer proc arity cache)
  (let ((ref! (if (lru-cache? cache) lru-ref! hash-table-ref!)))
    (case arity
      ((0)
       proc)
      ((1)
       (lambda (x) (ref! cache x proc)))
      ((2)
       (lambda (x y)
         (ref! cache (cons x y) (lambda (xy) (proc (car xy) (cdr xy))))))
      (else
       (lambda args
         (ref! cache args (lambda (args) (apply proc args))))))))

;;> Returns a memoized version of the procedure \var{proc}.  By
;;> default uses a least-recently-used (LRU) cache, which can be tuned
;;> with the following keyword arguments:
;;>
;;> \items[
;;> \item{cache: an explicit pre-existing cache (LRU or hash-table)}
;;> \item{equal: an equality predicate defaulting to \scheme{equal?}}
;;> \item{hash: a hash function to match the equality predicate, defaulting to \scheme{hash} from \scheme{(srfi 69)}}
;;> \item{init-size: a hint for the initial size of the backing hash table}
;;> \item{size-limit: the maximum size of the cache}
;;> \item{compute-size: compute the size of a cache entry}
;;> ]
;;>
;;> \var{compute-size} is a procedure of two arguments, the key and
;;> value to be stored, and defaults to a constant 1 per entry.  After
;;> every insertion the oldest elements will be removed until the size
;;> is under \var{size-limit}.  You may find
;;>
;;>   \scheme{(lambda (k v) (+ (object-size k) (object-size v)))}
;;>
;;> using \scheme{object-size} from \scheme{(chibi ast)} to be a
;;> useful \var{compute-size}.
;;>
;;> If \var{size-limit} is \scheme{#f} then the cache is unlimited,
;;> and a simple hash-table will be used in place of an LRU cache.

(define (memoize proc . o)
  (let-keywords* o
      ((equal equal: equal?)
       (hash hash: hash)
       (arity arity: (and (not (procedure-variadic? proc))
                          (procedure-arity proc)))
       (init-size init-size: 31)
       (limit size-limit: 1000)
       (compute-size compute-size: (lambda (k v) 1))
       (cache-init cache: '()))
    (let ((cache (cond ((lru-cache? cache-init)
                        cache-init)
                       (limit
                        (make-lru-cache 'equal: equal
                                        'hash: hash
                                        'init-size: init-size
                                        'size-limit: limit
                                        'compute-size: compute-size))
                       (else
                        (make-hash-table equal hash)))))
      ;; allow an alist initializer for the cache
      (if (pair? cache-init)
          (for-each (lambda (x) (lru-add! cache (car x) (cdr x)))
                    cache-init))
      (make-memoizer proc arity cache))))

;;> Equivalent to memoize except that the procedure's first argument
;;> must be a pathname.  If the corresponding file has been modified
;;> since the memoized value, the value is recomputed.  Useful to
;;> automatically reflect external changes to a file-backed resource.
;;> The additional keyword argument \scheme{reloader?:}, if true,
;;> indicates that the result of loading is itself a procedure which
;;> should check for updates on each call.

(define (memoize-file-loader proc . o)
  (let* ((f (lambda (file . rest)
              (let ((mtime (file-modification-time/safe file)))
                (cons mtime (apply proc file rest)))))
         (g (apply memoize f o))
         (reloader? (cond ((memq 'reloader?: o) => cdr) (else #f))))
    (lambda (file . rest)
      (let ((cell (apply g file rest)))
        (let-syntax ((update!
                      (syntax-rules ()
                        ((update! default)
                         (let ((mtime (file-modification-time/safe file)))
                           (if (and mtime
                                    (or (not (car cell))
                                        (> mtime (car cell))))
                               (let ((res (apply proc file rest)))
                                 (set-car! cell mtime)
                                 (set-cdr! cell res)
                                 res)
                               default))))))
          (update! (if (and reloader? (procedure? (cdr cell)))
                       (lambda args (apply (update! (cdr cell)) args))
                       (cdr cell))))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; persistent memoization

(define (get-memo-directory proc-name)
  (or (get-environment-variable "MEMOIZE_DIR")
      (if (i-am-root?)
          (make-path "/var/run/memo.d" proc-name)
          (make-path (or (get-environment-variable "HOME") ".")
                     ".memo.d" proc-name))))

(define (encode-file-name str)
  (define (file-name-safe-char? ch)
    (or (char-alphabetic? ch) (char-numeric? ch)
        (memv ch '(#\_ #\- #\+ #\. #\,))))
  (define (encode-char ch)
    (let* ((i (char->integer ch))
           (hex (number->string i 16)))
      (if (< i 16)
          (string-append "%0" hex)
          (string-append "%" hex))))
  (define (collect str from to res)
    (if (string-cursor>=? from to)
        res
        (cons (substring-cursor str from to) res)))
  (let ((start (string-cursor-start str))
        (end (string-cursor-end str)))
    (let lp ((from start) (to start) (res '()))
      (if (string-cursor>=? to end)
          (if (string-cursor=? from start)
              str
              (string-concatenate (reverse (collect str from to res))))
          (let* ((ch (string-cursor-ref str to))
                 (next (string-cursor-next str to)))
            (if (file-name-safe-char? ch)
                (lp from next res)
                (lp next next (cons (encode-char ch)
                                    (collect str from to res)))))))))

(define (default-args-encoder args)
  (let ((out (open-output-string)))
    (write/ss args out)
    (encode-file-name (string-append (get-output-string out) ".memo"))))

;;> Returns a memoized version of the procedure \var{proc} which
;;> stores the memoized results persistently in a file.  Garbage
;;> collection of the files is left as an external task for monitoring
;;> tools or cron jobs.
;;>
;;> Accepts the following keyword arguments:
;;>
;;> \items[
;;> \item{args-encoder: procedure which takes the arguments as a single list, and returns a string representation suitable for use as a (base) file name}
;;> \item{proc-name: the name of the procedure, to use a a subdir of memo-dir to distinguish from other memoized procedures}
;;> \item{memo-dir: the directory to store results in, defaulting to ~/.memo/}
;;> \item{file-validator: validator to run on the existing file - if it returns false, the file is considered bad and the result recomputed}
;;> \item{validator: validator to run on the result of reading the file}
;;> \item{read: the read procedure to extract the result from the file}
;;> \item{write: the write procedure to write the result to the file}
;;> ]

(define (memoize-to-file proc . o)
  (let-keywords* o
      ((args-encoder args-encoder: default-args-encoder)
       (proc-name proc-name: (or (procedure-name proc) "lambda"))
       (memo-dir memo-dir: (get-memo-directory proc-name))
       (file-validator file-validator: (lambda args #t))
       (validator validator: (lambda args #t))
       (read read: read/ss)
       (write write: write/ss))
    (lambda args
      (let ((file (make-path memo-dir (args-encoder args))))
        (define (compute)
          (let ((res (apply proc args)))
            (create-directory* (path-directory file))
            (call-with-output-file file
              (lambda (out) (write res out)))
            res))
        (if (and (file-exists? file)
                 (apply file-validator file args))
            (let ((res (call-with-input-file file read)))
              (if (validator res)
                  res
                  (compute)))
            (compute))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; low-level utilities

;;> Creates a new empty LRU object.  The same keyword arguments as in
;;> \scheme{memoize} are available, except of course for \var{cache}.

(define (make-lru-cache . o)
  (let-keywords* o ((equal equal: equal?)
                    (hash hash: hash)
                    (init-size init-size: 31)
                    (compute-size compute-size: (lambda (k v) 1))
                    (size-limit size-limit: 1000))
    (let ((tab (make-hash-table equal hash))) ; init-size
      (%make-lru-cache tab '() '() 0 size-limit compute-size))))

;; add entry to the back of the queue
(define (lru-enq! lru entry)
  (let ((cell (list entry)))
    (if (null? (lru-front lru))         ; empty
        (lru-front-set! lru cell)
        (set-cdr! (lru-back lru) cell))
    (lru-back-set! lru cell)))

;; pop the front of the queue
(define (lru-deq! lru)
  (let ((cell (lru-front lru)))
    (if (null? cell)
        (error "lru queue is empty")
        (let ((rest (cdr cell)))
          (lru-front-set! lru rest)
          (if (null? rest)
              (lru-back-set! lru '()))
          (car cell)))))

;; shift the given entry, anywhere in the queue, to the end
(define (lru-shift-to-last! lru entry)
  (let ((prev (lru-entry-prev entry))
        (last-pair (lru-back lru)))
    (cond
     ((null? prev)
      ;; first entry, just pop and re-queue it, and update prev pointers
      (lru-enq! lru (lru-deq! lru))
      (lru-entry-prev-set! entry last-pair)
      (lru-entry-prev-set! (car (lru-front lru)) '()))
     ((eq? (cdr prev) last-pair)
      ;; already at the end, nothing to do
      )
     (else
      ;; a middle element, splice it out and re-queue
      (let ((cell (cdr prev)))
        (set-cdr! prev (cdr cell))      ; splice out
        (if (pair? (cdr cell))
            (lru-entry-prev-set! (cadr cell) prev))
        (lru-enq! lru entry)            ; reinsert at end
        (lru-entry-prev-set! entry last-pair))))))

(define (lru-shrink! lru)
  (let ((size-limit (lru-size-limit lru))
        (size (lru-size lru)))
    (if (> size size-limit)
        (let lp ((size size))
          (if (> size size-limit)
              (let ((x (lru-deq! lru)))
                (let ((next (lru-front lru)))
                  (if (pair? next)
                      (lru-entry-prev-set! (car next) '())))
                (hash-table-delete! (lru-table lru) (lru-entry-key x))
                (lp (- size (lru-entry-size x))))
              (lru-size-set! lru size))))))

;;> Looks up \var{key} in the cache LRU.  If not found returns #f,
;;> unless \var{compute} is given in which case \var{compute} is
;;> applied to \var{key} to determine the return value.  This does not
;;> update the cache.

(define (lru-ref lru key . o)
  (let ((entry (hash-table-ref/default (lru-table lru) key #f)))
    (cond (entry
           (lru-shift-to-last! lru entry)
           (lru-entry-value entry))
          ((pair? o)
           ((car o) key))
          (else
           (error "no lru entry for" key)))))

;;> Identical to lru-ref except that it updates the cache on a miss.

(define (lru-ref! lru key compute)
  (cond ((hash-table-ref/default (lru-table lru) key #f)
         => (lambda (entry)
              (lru-shift-to-last! lru entry)
              (lru-entry-value entry)))
        (else
         (let ((value (compute key)))
           (lru-add! lru key value)
           value))))

(define (lru-add! lru key value)
  (let* ((size ((lru-compute-size lru) key value))
         (last-pair (lru-back lru))
         (entry (make-lru-entry key value size last-pair)))
    (hash-table-set! (lru-table lru) key entry)
    (lru-enq! lru entry)
    (lru-size-set! lru (+ size (lru-size lru)))
    (lru-shrink! lru)))

;;> Directly set a value in the cache.

(define (lru-set! lru key value)
  (let ((entry (hash-table-ref/default (lru-table lru) key #f)))
    (cond (entry
           (lru-shift-to-last! lru entry)
           (lru-entry-value-set! entry value)
           (let ((prev-size (lru-entry-size entry))
                 (size ((lru-compute-size lru) key value)))
             (lru-entry-size-set! entry size)
             (lru-size-set! lru (+ (lru-size lru) (- size prev-size)))))
          (else
           (lru-add! lru key value)))
    (lru-shrink! lru)))

(define (hash-table-ref! table key proc)
  (hash-table-ref table key
                  (lambda ()
                    (let ((res (proc key)))
                      (hash-table-set! table key res)
                      res))))

(define-library (chibi sxml-test)
  (import (scheme base) (chibi sxml) (chibi test))
  (export run-tests)
  (begin
    (define (run-tests)
      (test-begin "sxml")
      (test "<html><body><div><p>hello, world</p><br></div></body></html>"
          (sxml->xml '(*TOP* (html (body (div (p "hello, world") (br)))))))
      (test-end))))
;; filesystem.scm -- additional filesystem utilities
;; Copyright (c) 2009-2013 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

;;> Creates the directory \var{dir}, including any parent directories
;;> as needed.  Returns \scheme{#t} on success and \scheme{#f} on
;;> failure.

(define (create-directory* dir . o)
  (let ((mode (if (pair? o) (car o) #o755)))
    (or (file-directory? dir)
        (create-directory dir mode)
        (let* ((start (string-cursor-start dir))
               (slash
                (string-find-right dir #\/ start (string-skip-right dir #\/))))
          (and (string-cursor>? slash start)
               (let ((parent (substring-cursor dir start slash)))
                 (and (not (equal? parent dir))
                      (not (file-exists? parent))
                      (create-directory* parent mode)
                      (create-directory dir mode))))))))

;;> The fundamental directory iterator.  Applies \var{kons} to
;;> each filename in directory \var{dir} and the result of the
;;> previous application, beginning with \var{knil}.  With
;;> \var{kons} as \scheme{cons} and \var{knil} as \scheme{'()},
;;> equivalent to \scheme{directory-files}.

(define (directory-fold dir kons knil)
  (let ((dir (opendir dir)))
    (if (not dir)
        knil
        (let lp ((res knil))
          (let ((file (readdir dir)))
            (if file
                (lp (kons (dirent-name file) res))
                (begin (closedir dir) res)))))))

;;> Returns a list of the files in \var{dir} in an unspecified
;;> order.

(define (directory-files dir)
  (directory-fold dir cons '()))

;;> The fundamental directory traverser.

(define (directory-fold-tree file down up here . o)
  ;; TODO: Use link count to reduce stats.
  ;; TODO: Provide higher-level wrapper for filtering and avoids links.
  (let ((knil (and (pair? o) (car o)))
        (down (or down (lambda (f acc) acc)))
        (up (or up (lambda (f acc) acc)))
        (here (or here (lambda (f acc) acc))))
    (let fold ((file file) (acc knil))
      (cond
       ((file-directory? file)
        (let ((d (opendir file)))
          (if (not d)
              acc
              (let lp ((acc (down file acc)))
                (let ((e (readdir d)))
                  (cond
                   (e
                    (let ((f (dirent-name e)))
                      (if (member f '("." ".."))
                          (lp acc)
                          (let ((path (string-append file "/" f)))
                            (lp (fold path acc))))))
                   (else
                    (closedir d)
                    (up file acc))))))))
       (else
        (here file acc))))))

;;> Unlinks the file named \var{string} from the filesystem.
;;> Returns \scheme{#t} on success and \scheme{#f} on failure.

(define (delete-file file)
  (if (not (%delete-file file))
      (raise-continuable
       (make-exception 'file "couldn't delete file" (list file) delete-file #f))))

;;> Recursively delete all files and directories under \var{dir}.
;;> Unless optional arg \var{ignore-errors?} is true, raises an error
;;> if any file can't be deleted.

(define (delete-file-hierarchy dir . o)
  (let ((ignore-errors? (and (pair? o) (car o))))
    (if (member dir '("" "/"))
        (error "won't delete unsafe directory" dir))
    (directory-fold-tree
     dir
     #f
     (lambda (d acc)
       (if (and (not (delete-directory d)) (not ignore-errors?))
           (error "couldn't delete directory" d)))
     (lambda (f acc)
       (if (and (not (delete-file f)) (not ignore-errors?))
           (error "couldn't delete file" f))))))

;;> Runs \var{thunk} with the current directory of the process temporarily
;;> set to \var{dir}.

(define (with-directory dir thunk)
  (let ((pwd (current-directory)))
    (dynamic-wind
      (lambda ()
        (if (not (change-directory dir))
            (error "couldn't change directory" dir)))
      thunk
      (lambda () (change-directory pwd)))))

;;> Returns the \scheme{status} object for the given \var{file},
;;> which should be a string indicating the path or a file
;;> descriptor.

(define (file-status file)
  (if (string? file) (stat file) (fstat file)))

(define (file-device x) (stat-dev (if (stat? x) x (file-status x))))
(define (file-inode x) (stat-ino (if (stat? x) x (file-status x))))
(define (file-mode x) (stat-mode (if (stat? x) x (file-status x))))
(define (file-num-links x) (stat-nlinks (if (stat? x) x (file-status x))))
(define (file-owner x) (stat-uid (if (stat? x) x (file-status x))))
(define (file-group x) (stat-gid (if (stat? x) x (file-status x))))
(define (file-represented-device x) (stat-rdev (if (stat? x) x (file-status x))))
(define (file-size x) (stat-size (if (stat? x) x (file-status x))))
(cond-expand
  (windows
    (define (file-block-size x) 1)
    (define (file-num-blocks x) (file-size x)))
  (else
    (define (file-block-size x) (stat-blksize (if (stat? x) x (file-status x))))
    (define (file-num-blocks x) (stat-blocks (if (stat? x) x (file-status x))))))
(define (file-access-time x) (stat-atime (if (stat? x) x (file-status x))))
(define (file-modification-time x) (stat-mtime (if (stat? x) x (file-status x))))
(define (file-modification-time/safe x)
  (let ((status (if (stat? x) x (file-status x))))
    (and status (stat-mtime status))))
(define (file-change-time x) (stat-ctime (if (stat? x) x (file-status x))))

;;> File status accessors.  \var{x} should be a string indicating
;;> the file to lookup the status for, or an existing status object.
;;> Raises an error in the string case for non-existing files.
;;/

(define-syntax file-test-mode
  (syntax-rules ()
    ((file-test-mode op x)
     (let* ((tmp x)
            (st (if (stat? tmp) tmp (file-status tmp))))
       (and st (op (stat-mode st)))))))

(define (file-regular? x) (file-test-mode S_ISREG x))
(define (file-directory? x) (file-test-mode S_ISDIR x))
(define (file-character? x) (file-test-mode S_ISCHR x))
(define (file-block? x) (file-test-mode S_ISBLK x))
(define (file-fifo? x) (file-test-mode S_ISFIFO x))
(cond-expand
  (windows
    (define (file-link? x) #f))
  (else
    (define (file-link? x)
      (let ((st (if (stat? x) x (file-link-status x))))
       (and st (S_ISLNK (stat-mode st)))))))
(define (file-socket? x) (file-test-mode S_ISSOCK x))
(define (file-exists? x) (and (if (stat? x) #t (file-status x)) #t))

;;> File type tests.  \var{x} should be a string indicating the
;;> file to lookup the status for, or an existing status object.
;;> Returns \scheme{#t} if the file exists and the given type
;;> is satisfied, and \scheme{#f} otherwise.
;;/

(define (file-is-readable? path) (zero? (file-access path access/read)))
(define (file-is-writable? path) (zero? (file-access path access/write)))
(define (file-is-executable? path) (zero? (file-access path access/execute)))

;;> File access tests.  Returns true iff the current real UID and GID
;;> have the corresponding permissions on path.  Equivalent to the
;;> test -r, -w, -x operators in sh.
;;/

;;> Equivalent to duplicating the file descriptor \var{old} to
;;> \var{new} and closing \var{old}.

(define (renumber-file-descriptor old new)
  (and (duplicate-file-descriptor-to old new)
       (close-file-descriptor old)))

;;> Returns the path the symbolic link \var{file} points to, or
;;> \scheme{#f} on error.

(cond-expand
  (windows
    (define (read-link file) #f))
  (else
    (define (read-link file)
      (let* ((buf (make-string 512))
             (res (readlink file buf 512)))
        (and (positive? res)
             (substring buf 0 res))))))
(define-library (chibi system-test)
  (export run-tests)
  (import (chibi) (chibi system) (only (chibi test) test-begin test test-end))
  (begin
    (define (run-tests)
      (test-begin "system")

      (test #t (user? (user-information (current-user-id))))
      (test #f (user? #f))
      (test #f (user? (list #f)))
      (test #t (string? (user-name (user-information (current-user-id)))))
      (test #t (string? (user-password (user-information (current-user-id)))))
      (test #t (integer? (user-id (user-information (current-user-id)))))
      (test #t (integer? (user-group-id (user-information (current-user-id)))))
      (test #t (string? (user-gecos (user-information (current-user-id)))))
      (test #t (string? (user-home (user-information (current-user-id)))))
      (test #t (string? (user-shell (user-information (current-user-id)))))

      (test (current-user-id) (user-id (user-information (current-user-id))))
      (test (current-group-id) (user-group-id (user-information (current-user-id))))

      (test (user-id (user-information (current-user-id)))
          (user-id (user-information (user-name (user-information (current-user-id))))))

      (test #t (integer? (current-session-id)))

      ;; stress test user-name
      (test (user-name (user-information (current-user-id)))
          (user-name (user-information (current-user-id))))
      (let ((u (user-information (current-user-id))))
        (test (user-name u) (user-name (user-information (current-user-id)))))
      (let ((un (user-name (user-information (current-user-id)))))
        (test un (user-name (user-information (current-user-id)))))

      (test-end))))
(define-library (chibi uri-test)
  (export run-tests)
  (import (scheme base) (chibi test) (chibi uri))
  (begin
    (define (run-tests)
      (test-begin "uri")

      (test-assert (uri? (make-uri 'http)))
      (test 'http (uri-scheme (make-uri 'http)))
      (test "r" (uri-user (make-uri 'http "r")))
      (test "google.com" (uri-host (make-uri 'http "r" "google.com")))
      (test 80 (uri-port (make-uri 'http "r" "google.com" 80)))
      (test "/search" (uri-path (make-uri 'http "r" "google.com" 80 "/search")))
      (test "q=cats"
          (uri-query (make-uri 'http "r" "google.com" 80 "/search" "q=cats")))
      (test "recent"
          (uri-fragment
           (make-uri 'http "r" "google.com" 80 "/search" "q=cats" "recent")))

      (let ((str "http://google.com"))
        (test-assert (uri? (string->uri str)))
        (test 'http (uri-scheme (string->uri str)))
        (test "google.com" (uri-host (string->uri str)))
        (test #f (uri-port (string->uri str)))
        (test #f (uri-path (string->uri str)))
        (test #f (uri-query (string->uri str)))
        (test #f (uri-fragment (string->uri str))))

      (let ((str "http://google.com/"))
        (test-assert (uri? (string->uri str)))
        (test 'http (uri-scheme (string->uri str)))
        (test "google.com" (uri-host (string->uri str)))
        (test #f (uri-port (string->uri str)))
        (test "/" (uri-path (string->uri str)))
        (test #f (uri-query (string->uri str)))
        (test #f (uri-fragment (string->uri str))))

      (let ((str "http://google.com:80/search?q=cats#recent"))
        (test-assert (uri? (string->uri str)))
        (test 'http (uri-scheme (string->uri str)))
        (test "google.com" (uri-host (string->uri str)))
        (test 80 (uri-port (string->uri str)))
        (test "/search" (uri-path (string->uri str)))
        (test "q=cats" (uri-query (string->uri str)))
        (test "recent" (uri-fragment (string->uri str))))

      (test "/%73" (uri-path (string->uri "http://google.com/%73")))
      (test "/s" (uri-path (string->uri "http://google.com/%73" #t)))
      (test "a=1&b=2;c=3"
          (uri-query (string->uri "http://google.com/%73?a=1&b=2;c=3" #t)))
      (test '(("a" . "1") ("b" . "2") ("c" . "3"))
          (uri-query (string->uri "http://google.com/%73?a=1&b=2;c=3" #t #t)))
      (test '(("a" . "1") ("b" . "2+2") ("c" . "3"))
          (uri-query (string->uri "http://google.com/%73?a=1&b=2+2;c=%33" #f #t)))
      (test '(("a" . "1") ("b" . "2 2") ("c" . "3"))
          (uri-query (string->uri "http://google.com/%73?a=1&b=2+2;c=%33" #t #t)))

      (let ((str "/"))
        (test-assert (uri? (string->path-uri 'http str)))
        (test 'http (uri-scheme (string->path-uri 'http str)))
        (test #f (uri-host (string->path-uri 'http str)))
        (test #f (uri-port (string->path-uri 'http str)))
        (test "/" (uri-path (string->path-uri 'http str)))
        (test #f (uri-query (string->path-uri 'http str)))
        (test #f (uri-fragment (string->path-uri 'http str))))

      (test-end))))

(define (call-with-output-string proc)
  (let ((out (open-output-string)))
    (proc out)
    (get-output-string out)))

(define (display-to-string x)
  (cond ((string? x) x)
        ((char? x) (string x))
        ((symbol? x) (symbol->string x))
        ((number? x) (number->string x))
        (else (error "don't know how to display as sxml" x))))

(define (html-display-escaped-attr str . o)
  (let ((start 0)
        (end (string-length str))
        (out (if (pair? o) (car o) (current-output-port))))
    (let lp ((from start) (to start))
      (if (>= to end)
          (display (substring str from to) out)
          (let ((c (string-ref str to)))
            (cond
             ((eq? c #\<)
              (display (substring str from to) out)
              (display "&lt;" out)
              (lp (+ to 1) (+ to 1)))
             ((eq? c #\&)
              (display (substring str from to) out)
              (display "&amp;" out)
              (lp (+ to 1) (+ to 1)))
             ((eq? c #\")
              (display (substring str from to) out)
              (display "&quot;" out)
              (lp (+ to 1) (+ to 1)))
             (else
              (lp from (+ to 1)))))))))

(define (html-escape-attr str)
  (call-with-output-string
    (lambda (out) (html-display-escaped-attr (display-to-string str) out))))

(define (html-attr->string attr)
  (if (null? (cdr attr))
      (symbol->string (car attr))
      (let ((val (if (pair? (cdr attr)) (cadr attr) (cdr attr))))
        (string-append (symbol->string (car attr))
                       "=\"" (html-escape-attr val) "\""))))

(define (html-tag->string tag attrs)
  (let lp ((ls attrs) (res (list (symbol->string tag) "<")))
    (if (null? ls)
        (apply string-append (reverse (cons ">" res)))
        (lp (cdr ls) (cons (html-attr->string (car ls)) (cons " " res))))))

(define void-elements
  '(area base br col embed hr img input keygen link meta param source track wbr))

(define (html-display-escaped-string x . o)
  (let* ((str (display-to-string x))
         (start 0)
         (end (string-length str))
         (out (if (pair? o) (car o) (current-output-port))))
    (let lp ((from start) (to start))
      (if (>= to end)
          (display (substring str from to) out)
          (let ((c (string-ref str to)))
            (cond
             ((eq? c #\<)
              (display (substring str from to) out)
              (display "&lt;" out)
              (lp (+ to 1) (+ to 1)))
             ((eq? c #\&)
              (display (substring str from to) out)
              (display "&amp;" out)
              (lp (+ to 1) (+ to 1)))
             (else
              (lp from (+ to 1)))))))))

(define (html-escape str)
  (call-with-output-string
    (lambda (out) (html-display-escaped-string str out))))

(define indentable-elements
  '(address article aside base blockquote body dd details dialog
    div dl dt fieldset figcaption figure footer form h1 h2 h3 h4
    h5 h6 head header hgroup hr li link main meta nav ol p pre
    script section style table title ul))

(define (indent i out)
  (do ((j (* 2 i) (- j 1))) ((= j 0)) (write-char #\space out)))

;;> Render (valid, expanded) \var{sxml} as html.
;;> \var{@raw} tag is considered safe text and not processed or escaped.
(define (sxml-display-as-html sxml . args)
  (let* ((out (if (null? args) (current-output-port) (car args)))
         (args (if (null? args) args (cdr args)))
	 (indent? (if (null? args) #f (car args)))
         (args (if (null? args) args (cdr args))))
    (unless (null? args) (error "too many args"))
    (let lp ((sxml (if (and (pair? sxml) (eq? '*TOP* (car sxml)))
                       (cdr sxml)
                       sxml))
	     (depth 0))
      (cond
       ((pair? sxml)
        (let ((tag (car sxml))
              (rest (cdr sxml)))
          (cond
           ((symbol? tag)
            (cond
             ((eqv? #\! (string-ref (symbol->string tag) 0))
              (display "<" out) (display tag out)
              (for-each (lambda (x) (display " " out) (display x out)) rest)
              (display ">\n" out))
             ((and (eq? '@raw tag)
                   (string? (car rest)))
              (if (not (null? (cdr rest)))
                  (error "@raw takes only one value" sxml))
              (display (car rest) out))
             ((and (pair? rest)
                   (pair? (car rest))
                   (eq? '@ (caar rest)))
	      (when (and indent? (memq tag indentable-elements))
		(newline out)
		(indent depth out))
	      (display (html-tag->string tag (cdar rest)) out)
	      (for-each (lambda (x) (lp x (+ 1 depth))) (cdr rest))
	      (unless (and (null? (cdr rest)) (memq tag void-elements))
                (display "</" out) (display tag out) (display ">" out)))
             (else
	      (when (and indent? (memq tag indentable-elements))
		(newline out)
		(indent depth out))
	      (display (html-tag->string tag '()) out)
	      (for-each (lambda (x) (lp x (+ 1 depth))) rest)
	      (unless (and (null? rest) (memq tag void-elements))
                (display "</" out) (display tag out) (display ">" out)))))
           (else
            (for-each (lambda (x) (lp x (+ 1 depth))) sxml)))))
       ((null? sxml))
       (else (html-display-escaped-string sxml out))))))

;;> Render \var{sxml} as \var{xml}.
;;> \var{@raw} tag is considered safe text and not processed or escaped.
(define (sxml->xml sxml)
  (call-with-output-string
    (lambda (out) (sxml-display-as-html sxml out))))

;;> Render \var{sxml} as simple text, stripping all tags.
(define (sxml-strip sxml)
  (call-with-output-string
    (lambda (out)
      (let strip ((x sxml))
        (cond
         ((pair? x)
          (for-each
           strip
           (if (and (pair? (cdr x)) (eq? '@ (cadr x))) (cddr x) (cdr x))))
         ((string? x)
          (display x out)))))))

;;> Render \var{sxml} as text for viewing in a terminal.
(define (sxml-display-as-text sxml . o)
  (let ((out (if (pair? o) (car o) (current-output-port)))
        (sxml (if (and (pair? sxml) (null? (cddr sxml)) (eq? '*TOP* (car sxml)))
                       (cadr sxml)
                       sxml)))
    (let lp ((sxml sxml))
      (cond
       ((pair? sxml)
        (let ((tag (car sxml)))
          (cond
           ;; skip headers and the menu
           ((or (memq tag '(head style script !DOCTYPE))
                (and (eq? 'div tag)
                     (pair? (cdr sxml))
                     (pair? (cadr sxml))
                     (eq? '@ (car (cadr sxml)))
                     (equal? '(id . "menu") (assq 'id (cdr (cadr sxml)))))))
           ;; recurse other tags, appending newlines for new sections
           ((symbol? tag)
            (if (memq tag '(h1 h2 h3 h4 h5 h6))
                (newline out))
            (for-each
             lp
             (if (and (pair? (cdr sxml)) (eq? '@ (cadr sxml)))
                 (cddr sxml)
                 (cdr sxml)))
            (if (memq tag '(p li br h1 h2 h3 h4 h5 h6))
                (newline out)))
           (else
            (for-each lp sxml)))))
       ((null? sxml))
       (else (display sxml out))))))
;;;; loop.scm - the chibi loop (aka foof-loop)
;;
;; Copyright (c) 2009-2015 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

;;> The loop API is mostly compatible with Taylor Campbell's
;;> \hyperlink["http://mumble.net/~campbell/scheme/foof-loop.txt"]{foof-loop},
;;> but the iterator API is different and subject to change.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define (assoc-pred equal elt ls)
  (and (pair? ls)
       (if (equal elt (car (car ls)))
           (car ls)
           (assoc-pred equal elt (cdr ls)))))

(define-syntax let-keyword-form
  (syntax-rules ()
    ((let-keyword-form
      ((labeled-arg-macro-name (positional-name . params)))
      . body)
     (let-syntax
         ((labeled-arg-macro-name
           (er-macro-transformer
            (lambda (expr rename compare)
              (let lp ((ls (cdr expr)) (named '()) (posns '()))
                (cond
                 ((pair? ls)
                  (if (and (list? (car ls)) (compare (caar ls) (rename '=>)))
                      (lp (cdr ls) (cons (cdar ls) named) posns)
                      (lp (cdr ls) named (cons (car ls) posns))))
                 (else
                  (let lp ((ls (syntax-quote params))
                           (posns (reverse posns))
                           (args '()))
                    (cond
                     ((null? ls)
                      (if (pair? posns)
                          (error "let-keyword-form: too many args" expr)
                          (cons (syntax-quote positional-name) (reverse args))))
                     ((assoc-pred compare (caar ls) named)
                      => (lambda (x) (lp (cdr ls) posns (cons (cadr x) args))))
                     ((pair? posns)
                      (lp (cdr ls) (cdr posns) (cons (car posns) args)))
                     (else
                      (lp (cdr ls) posns (cons (car (cdar ls)) args))))))))))))
       . body))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;> \macro{(loop [name] (vars ...) [=> result] body ...)}

(define-syntax loop
  (syntax-rules ()
    ;; unnamed, implicit recursion
    ((loop (vars ...) body ...)
     (%loop tmp-loop () () () () () (vars ...) body ... (tmp-loop)))
    ;; named, explicit recursion
    ((loop name (vars ...) body ...)
     (%loop name () () () () () (vars ...) body ...))))

;; Main LOOP macro. Separate the variables from the iterator and
;; parameters, then walk through each parameter expanding the
;; bindings, and build the final form.

(define-syntax %loop
  (syntax-rules (=> for with let while until)
    ;; automatic iteration
    ((_ name l v c r f ((for var1 (iterator source ...)) rest ...) . body)
     (iterator ((var1) (source ...)) %loop-next name l v c r f (rest ...) . body))
    ((_ name l v c r f ((for var1 var2 (iterator source ...)) rest ...) . body)
     (iterator ((var1 var2) (source ...)) %loop-next name l v c r f (rest ...) . body))
    ((_ name l v c r f ((for var1 var2 var3 (iterator source ...)) rest ...) . body)
     (iterator ((var1 var2 var3) (source ...)) %loop-next name l v c r f (rest ...) . body))
    ((_ name l v c r f ((for var1 var2 var3 var4 (iterator source ...)) rest ...) . body)
     (iterator ((var1 var2 var3 var4) (source ...)) %loop-next name l v c r f (rest ...) . body))
    ;; do equivalents, with optional guards
    ((_ name l (vars ...) (checks ...) r f ((with var init step guard) rest ...) . body)
     (%loop name l (vars ... (var init step)) (checks ... (guard var)) r f (rest ...) . body))
    ((_ name l (vars ...) c r f ((with var init step) rest ...) . body)
     (%loop name l (vars ... (var init step)) c r f (rest ...) . body))
    ((_ name l (vars ...) c r f ((with var init) rest ...) . body)
     (%loop name l (vars ... (var init var)) c r f (rest ...) . body))
    ;; user-specified terminators
    ((_ name l vars (checks ...) r f ((until expr) rest ...) . body)
     (%loop name l vars (checks ... expr) r f (rest ...) . body))
    ((_ name l vars (checks ...) r f ((while expr) rest ...) . body)
     (%loop name l vars (checks ... (not expr)) r f (rest ...) . body))
    ;; specify a default done?
    ((_ name l v c r f ())
     (%loop name l v c r f () (#f #f)))
    ((_ name l v c r f () () . body)
     (%loop name l v c r f () (#f #f) . body))
    ;; final expansion
    ((_ name (lets ...) ((var init step) ...) (checks ...) (refs ...) (finals ...) ()
        => result
        . body)
     (let* (lets ...)
       (letrec ((tmp (lambda (var ...)
                       (if (or checks ...)
                           (let-keyword-form ((name (tmp (var step) ...)))
                             (let (finals ...) result))
                           (let (refs ...)
                             (let-keyword-form ((name (tmp (var step) ...)))
                               (if #f #f)
                               . body))))))
         (tmp init ...))))
    ;; unspecified return value case
    ((_ name (lets ...) ((var init step) ...) (checks ...) (refs ...) (finals ...) ()
        . body)
     (%loop name (lets ...) ((var init step) ...) (checks ...) (refs ...) (finals ...) ()
            => (if #f #f) . body))
    ))

(define-syntax %loop-next
  (syntax-rules ()
    ((_ (new-lets ...) (new-vars ...) (new-checks ...) (new-refs ...) (new-finals ...)
        name (lets ...) (vars ...) (checks ...) (refs ...) (finals ...)
        . rest)
     (%loop name (lets ... new-lets ...) (vars ... new-vars ...)
                 (checks ... new-checks ...) (refs ... new-refs ...)
                 (finals ... new-finals ...)
        . rest))))

;;> Utility syntax for the common case of a loop which has only
;;> \scheme{for} clauses.

(define-syntax for
  (syntax-rules ()
    ((for ((vars ...) ...) body ...)
     (loop ((for vars ...) ...) body ...))
    ((for lp ((vars ...) ...) body ...)
     (loop lp ((for vars ...) ...) body ...))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;> \section{Iterators}

;; Each gets passed two lists, those items left of the macro and those to
;; the right, followed by a NEXT and REST continuation.
;;
;; Should finish with
;;
;; \schemeblock{
;;  (next (outer-vars ...) (cursor-vars ...) (done?-tests ...)
;;        (loop-vars ...) (final-vars ...) . rest)
;; }
;;
;; \itemlist[
;; \item{\var{outer-vars} - bound once outside the loop in a LET*}
;; \item{\var{cursor-vars} - DO-style bindings of the form (name init update)}
;; \item{\var{done?-tests} - possibly empty list of forms that terminate the loop on #t}
;; \item{\var{loop-vars} - inner variables, updated in parallel after the cursors}
;; \item{\var{final-vars} - final variables, bound only in the => result}
;; ]

;;> \macro{(for var [pair] (in-list ls [cdr]))}

;;> Basic list iterator.

(define-syntax in-list                  ; called just "IN" in ITER
  (syntax-rules ()
    ((in-list ((var) source) next . rest)
     (in-list ((var cursor) source) next . rest))
    ((in-list ((var cursor) source) next . rest)
     (in-list ((var cursor succ) source) next . rest))
    ((in-list ((var cursor succ) (source)) next . rest)
     (next ()                         ; outer let bindings
           ((cursor source succ))     ; iterator, init, step
           ((not (pair? cursor)))     ; finish tests for iterator vars
           ;; step variables and values
           ((var (car cursor))
            (succ (cdr cursor)))
           ()                           ; final result bindings
           . rest))
    ((in-list ((var cursor succ) (source step)) next . rest)
     (next ()
           ((cursor source succ))
           ((not (pair? cursor)))
           ((var (car cursor))
            (succ (step cursor)))
           ()
           . rest))))

;;> \macro{(for elts [pairs] (in-lists lol [cdr [done?]]))}

;;> Iterator from Taylor R. Campbell.  If you know the number of lists
;;> ahead of time it's much more efficient to iterate over each one
;;> separately.

(define-syntax in-lists
  (syntax-rules ()
    ((in-lists ((elts) lol) next . rest)
     (in-lists ((elts pairs) lol) next . rest))
    ((in-lists ((elts pairs) lol) next . rest)
     (in-lists ((elts pairs succ) lol) next . rest))
    ((in-lists ((elts pairs succ) (lol)) next . rest)
     (in-lists ((elts pairs succ) (lol cdr)) next . rest))
    ((in-lists ((elts pairs succ) (lol)) next . rest)
     (in-lists ((elts pairs succ) (lol cdr)) next . rest))
    ((in-lists ((elts pairs succ) (lol step)) next . rest)
     (in-lists ((elts pairs succ) (lol step null?)) next . rest))
    ((in-lists ((elts pairs succ) (lol step done?)) next . rest)
     (next ()
           ((pairs lol succ))
           ((let lp ((ls pairs)) ; an in-lined ANY
              (and (pair? ls) (if (done? (car ls)) #t (lp (cdr ls))))))
           ((elts (map car pairs))
            (succ (map step pairs)))
           ()
           . rest))
    ))

(define-syntax define-in-indexed
  (syntax-rules ()
    ((define-in-indexed in-type in-type-reverse length ref)
     (begin
       (define-syntax in-type
         (syntax-rules ()
           ((in-type seq next . rest)
            (%in-idx >= (lambda (x i) (+ i 1)) (lambda (x) 0) length ref tmp seq next . rest))))
       (define-syntax in-type-reverse
         (syntax-rules ()
           ((in-type-reverse seq next . rest)
            (%in-idx < (lambda (x i) (- i 1)) (lambda (x) (- (length x) 1)) (lambda (x) 0) ref tmp seq next . rest))))
       ))))

(define-in-indexed in-vector in-vector-reverse vector-length vector-ref)

;;> \macro{(for var [index] (in-vector vec))}
;;> \macro{(for var [index] (in-vector-reverse vec))}

;;> \macro{(for ch [cursor] (in-string str))}

(define-syntax in-string
  (syntax-rules ()
    ((in-string s next . rest)
     (%in-idx string-cursor>=? string-cursor-next
              string-cursor-start string-cursor-end string-cursor-ref
              tmp s next . rest))))

;;> \macro{(for ch [cursor] (in-string-reverse str))}

(define-syntax in-string-reverse
  (syntax-rules ()
    ((in-string-reverse s next . rest)
     (%in-idx string-cursor<? string-cursor-prev
              (lambda (x) (string-cursor-prev x (string-cursor-end x)))
              string-cursor-start string-cursor-ref
              tmp s next . rest))))

;; helper for the above string and vector iterators
(define-syntax %in-idx
  (syntax-rules ()
    ;;   cmp inc start end ref
    ((%in-idx ge + s e r tmp ((var) (seq ...)) next . rest)
     (%in-idx ge + s e r tmp ((var seq-index) (seq ...)) next . rest))
    ((%in-idx ge + s e r tmp ((var index) (seq)) next . rest)
     (%in-idx ge + s e r tmp ((var index) (seq (s tmp) (e tmp))) next . rest))
    ((%in-idx ge + s e r tmp ((var index) (seq from)) next . rest)
     (%in-idx ge + s e r tmp ((var index) (seq from (e tmp))) next . rest))
    ((%in-idx ge + s e r tmp ((var index) (seq from to)) next . rest)
     (next ((tmp seq) (end to))
           ((index from (+ tmp index)))
           ((ge index end))
           ((var (r tmp index)))
           ()
       . rest))
    ))

;;> \macro{(for substr (in-substrings k str))}

(define (string-cursor-forward str cursor n)
  (if (positive? n)
      (string-cursor-forward str (string-cursor-next str cursor) (- n 1))
      cursor))

(define-syntax in-substrings
  (syntax-rules ()
    ((in-substrings ((ch) (k str)) next . rest)
     (next ((tmp str) (end (string-cursor-end tmp)))
           ((sc1 (string-cursor-start tmp)
                 (string-cursor-next tmp sc1))
            (sc2 (string-cursor-forward tmp (string-cursor-start tmp) k)
                 (string-cursor-next tmp sc2)))
           ((string-cursor>? sc2 end))
           ((ch (substring-cursor tmp sc1 sc2)))
           ()
       . rest))))

;;> \macro{(for ch (in-port [input-port [reader [eof?]]]))}

(define-syntax in-port
  (syntax-rules ()
    ((in-port ((var) source) next . rest)
     (in-port ((var p) source) next . rest))
    ((in-port ((var p) ()) next . rest)
     (in-port ((var p) ((current-input-port))) next . rest))
    ((in-port ((var p) (port)) next . rest)
     (in-port ((var p) (port read-char)) next . rest))
    ((in-port ((var p) (port read-char)) next . rest)
     (in-port ((var p) (port read-char eof-object?)) next . rest))
    ((in-port ((var p) (port reader eof?)) next . rest)
     (next ((p port) (r reader) (e? eof?))
           ((var (r p) (r p)))
           ((e? var))
           ()
           ()
       . rest))))

;;> \macro{(for ch (in-file [input-port [reader [eof?]]]))}

(define-syntax in-file
  (syntax-rules ()
    ((in-file ((var) source) next . rest)
     (in-file ((var p) source) next . rest))
    ((in-file ((var p) (file)) next . rest)
     (in-file ((var p) (file read-char)) next . rest))
    ((in-file ((var p) (file reader)) next . rest)
     (in-file ((var p) (file reader eof-object?)) next . rest))
    ((in-file ((var p) (file reader eof?)) next . rest)
     (next ((p (open-input-file file)) (r reader) (e? eof?))
           ((var (r p) (r p)))
           ((e? var))
           ()
           ((dummy (close-input-port p)))
       . rest))))

;;> \macro{(for x (up-from [start] [(to limit)] [(by step)]))}

(define-syntax up-from
  (syntax-rules (to by)
    ((up-from (() . args) next . rest)
     (up-from ((var) . args) next . rest))
    ((up-from ((var) (start (to limit) (by step))) next . rest)
     (next ((s start) (l limit) (e step))
           ((var s (+ var e)))
           ((>= var l))
           ()
           ()
           . rest))
    ((up-from ((var) (start (to limit))) next . rest)
     (next ((s start) (l limit))
           ((var s (+ var 1)))
           ((>= var l))
           ()
           ()
           . rest))
    ((up-from ((var) (start (by step))) next . rest)
     (next ((s start) (e step)) ((var s (+ var e))) () () () . rest))
    ((up-from ((var) (start)) next . rest)
     (next ((s start)) ((var s (+ var 1))) () () () . rest))
    ))

;;> \macro{(for x (down-from [start] [(to limit)] [(by step)]))}

(define-syntax down-from
  (syntax-rules (to by)
    ((down-from (() . args) next . rest)
     (down-from ((var) . args) next . rest))
    ((down-from ((var) (start (to limit) (by step))) next . rest)
     (next ((s start) (l limit) (e step))
           ((var (- s e) (- var e)))
           ((< var l))
           ()
           ()
           . rest))
    ((down-from ((var) (start (to limit))) next . rest)
     (next ((s start) (l limit))
           ((var (- s 1) (- var 1)))
           ((< var l))
           ()
           ()
           . rest))
    ((down-from ((var) (start (by step))) next . rest)
     (next ((s start) (e step)) ((var (- s e) (- var e))) () () ()
           . rest))
    ((down-from ((var) (start)) next . rest)
     (next ((s start)) ((var (- s 1) (- var 1))) () () ()
           . rest))
    ))

(define-syntax accumulating
  (syntax-rules (initial if)
    ((accumulating (kons final init) ((var) . x) next . rest)
     (accumulating (kons final init) ((var cursor) . x) next . rest))
    ((accumulating (kons final init) ((var cursor) ((initial i) . x)) n . rest)
     (accumulating (kons final i) ((var cursor) x) n . rest))
    ((accumulating (kons final init) ((var cursor) (expr (if check))) n . rest)
     (n ((tmp-kons kons))
        ((cursor init (if check (tmp-kons expr cursor) cursor)))
        ()
        ()
        ((var (final cursor)))
        . rest))
    ((accumulating (kons final init) ((var cursor) (expr)) n . rest)
     (n ((tmp-kons kons))
        ((cursor init (tmp-kons expr cursor)))
        ()
        ()
        ((var (final cursor)))
        . rest))))

;;> \macro{(for x [pair] (listing expr))}

(define-syntax listing
  (syntax-rules ()
    ((listing args next . rest)
     (accumulating (cons reverse '()) args next . rest))))

;;> \macro{(for x [pair] (listing-reverse expr))}

(define-syntax listing-reverse
  (syntax-rules ()
    ((listing-reverse args next . rest)
     (accumulating (cons (lambda (x) x) '()) args next . rest))))

(define (append-reverse rev tail)
  (if (null? rev) tail (append-reverse (cdr rev) (cons (car rev) tail))))

;;> \macro{(for x [pair] (appending expr))}

(define-syntax appending
  (syntax-rules ()
    ((appending args next . rest)
     (accumulating (append-reverse reverse '()) args next . rest))))

;;> \macro{(for x [pair] (appending-reverse expr))}

(define-syntax appending-reverse
  (syntax-rules ()
    ((appending-reverse args next . rest)
     (accumulating (append-reverse (lambda (x) x) '()) args next . rest))))

;;> \macro{(for x (summing expr))}

(define-syntax summing
  (syntax-rules ()
    ((summing args next . rest)
     (accumulating (+ (lambda (x) x) 0) args next . rest))))

;;> \macro{(for x (multiplying expr))}

(define-syntax multiplying
  (syntax-rules ()
    ((multiplying args next . rest)
     (accumulating (* (lambda (x) x) 1) args next . rest))))
;;; Copyright (c) 2004-2018 by Alex Shinn.

;; Adapted from SRFI 56.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; syntax

(define-syntax combine
  (syntax-rules ()
    ((combine) 0)
    ((combine b1) b1)
    ((combine b1 b2 b3 ...)
     (combine (+ (arithmetic-shift b1 8) b2) b3 ...))))

(define-syntax bytes-u8-set-all!
  (syntax-rules ()
    ((_) bv off i)
    ((_ bv off i b1) (bytevector-u8-set! bv (+ off i) b1))
    ((_ bv off i b1 b2 b3 ...)
     (begin
       (bytevector-u8-set! bv (+ off i) b1)
       (bytes-u8-set-all! bv off (+ i 1) b2 b3 ...)))))

(define-syntax bytevector-u8-set-all!
  (syntax-rules ()
    ((_ bvapp iapp b1 ...)
     (let ((bv bvapp)
           (i iapp))
       (bytes-u8-set-all! bv i 0 b1 ...)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; reading floating point numbers

;; Inspired by Oleg's implementation from
;;   http://okmij.org/ftp/Scheme/reading-IEEE-floats.txt
;; but removes mutations and magic numbers and allows for manually
;; specifying the endianness.
;;
;; See also
;;   http://www.cs.auckland.ac.nz/~jham1/07.211/floats.html
;; and
;;   http://babbage.cs.qc.edu/courses/cs341/IEEE-754references.html
;; as references to IEEE 754.

(define (bytevector-ieee-single-ref bytevector k endianness)
  (define (mantissa expn b2 b3 b4)
    (case expn
      ((255)     ; special exponents
       (if (zero? (combine b2 b3 b4)) (/ 1. 0.) (/ 0. 0.)))
      ((0)       ; denormalized
       (inexact (* (expt 2.0 (- 1 (+ 127 23))) (combine b2 b3 b4))))
      (else
       (inexact
        (* (expt 2.0 (- expn (+ 127 23)))
           (combine (+ b2 128) b3 b4)))))) ; hidden bit
  (define (exponent b1 b2 b3 b4)
    (if (> b2 127)  ; 1st bit of b2 is low bit of expn
        (mantissa (+ (* 2 b1) 1) (- b2 128) b3 b4)
        (mantissa (* 2 b1) b2 b3 b4)))
  (define (sign b1 b2 b3 b4)
    (if (> b1 127)  ; 1st bit of b1 is sign
        (- (exponent (- b1 128) b2 b3 b4))
        (exponent b1 b2 b3 b4)))
  (let* ((b1 (bytevector-u8-ref bytevector (+ k 0)))
         (b2 (bytevector-u8-ref bytevector (+ k 1)))
         (b3 (bytevector-u8-ref bytevector (+ k 2)))
         (b4 (bytevector-u8-ref bytevector (+ k 3))))
    (if (eq? endianness 'big)
        (sign b1 b2 b3 b4)
        (sign b4 b3 b2 b1))))

(define (bytevector-ieee-single-native-ref bytevector k)
  (bytevector-ieee-single-ref bytevector k (native-endianness)))

(define (bytevector-ieee-double-ref bytevector k endianness)
  (define (mantissa expn b2 b3 b4 b5 b6 b7 b8)
    (case expn
      ((255)     ; special exponents
       (if (zero? (combine b2 b3 b4 b5 b6 b7 b8)) (/ 1. 0.) (/ 0. 0.)))
      ((0)       ; denormalized
       (inexact (* (expt 2.0 (- 1 (+ 1023 52)))
                   (combine b2 b3 b4 b5 b6 b7 b8))))
      (else
       (inexact
        (* (expt 2.0 (- expn (+ 1023 52)))
           (combine (+ b2 16) b3 b4 b5 b6 b7 b8)))))) ; hidden bit
  (define (exponent b1 b2 b3 b4 b5 b6 b7 b8)
    (mantissa (bitwise-ior (arithmetic-shift b1 4)        ; 7 bits
                           (arithmetic-shift b2 -4))      ; + 4 bits
              (bitwise-and b2 #b1111)
              b3 b4 b5 b6 b7 b8))
  (define (sign b1 b2 b3 b4 b5 b6 b7 b8)
    (if (> b1 127)  ; 1st bit of b1 is sign
        (- (exponent (- b1 128) b2 b3 b4 b5 b6 b7 b8))
        (exponent b1 b2 b3 b4 b5 b6 b7 b8)))
  (let* ((b1 (bytevector-u8-ref bytevector (+ k 0)))
         (b2 (bytevector-u8-ref bytevector (+ k 1)))
         (b3 (bytevector-u8-ref bytevector (+ k 2)))
         (b4 (bytevector-u8-ref bytevector (+ k 3)))
         (b5 (bytevector-u8-ref bytevector (+ k 4)))
         (b6 (bytevector-u8-ref bytevector (+ k 5)))
         (b7 (bytevector-u8-ref bytevector (+ k 6)))
         (b8 (bytevector-u8-ref bytevector (+ k 7))))
    (if (eq? endianness 'big)
        (sign b1 b2 b3 b4 b5 b6 b7 b8)
        (sign b8 b7 b6 b5 b4 b3 b2 b1))))

(define (bytevector-ieee-double-native-ref bytevector k)
  (bytevector-ieee-double-ref bytevector k (native-endianness)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; writing floating point numbers

;; Underflow rounds down to zero as in IEEE-754, and overflow gets
;; written as +/- Infinity.

;; Break a real number down to a normalized mantissa and exponent.
;; Default base=2, mant-size=23 (52), exp-size=8 (11) for IEEE singles
;; (doubles).
;;
;; Note: This should never be used in practice, since it can be
;; implemented much faster in C.  See decode-float in ChezScheme or
;; Gauche.
(define (call-with-mantissa&exponent num base mant-size exp-size proc)
  (cond
   ((negative? num)
    (call-with-mantissa&exponent (- num) base mant-size exp-size proc))
   ((zero? num) (proc 0 0))
   (else
    (let* ((bot (expt base mant-size))
           (top (* base bot)))
      (let loop ((n (inexact num)) (e 0))
        (cond
         ((>= n top)
          (loop (/ n base) (+ e 1)))
         ((< n bot)
          (loop (* n base) (- e 1)))
         (else
          (proc (exact (round n)) e))))))))

(define (bytevector-ieee-single-set! bytevector k num endianness)
  (define output
    (if (eq? endianness 'big)
        (lambda (b1 b2 b3 b4) (bytevector-u8-set-all! bytevector k b1 b2 b3 b4))
        (lambda (b1 b2 b3 b4) (bytevector-u8-set-all! bytevector k b4 b3 b2 b1))))
  (define (compute)
    (call-with-mantissa&exponent num 2 23 8
      (lambda (f e)
        (let ((e0 (+ e 127 23)))
          (cond
           ((negative? e0)
            (let* ((f1 (exact (round (* f (expt 2 (- e0 1))))))
                   (b2 (bit-field f1 16 24))        ; mant:16-23
                   (b3 (bit-field f1 8 16))         ; mant:8-15
                   (b4 (bit-field f1 0 8)))         ; mant:0-7
              (output (if (negative? num) 128 0) b2 b3 b4)))
           ((> e0 255)  ; infinity
            (output (if (negative? num) 255 127) 128 0 0))
           (else
            (let* ((b0 (arithmetic-shift e0 -1))
                   (b1 (if (negative? num) (+ b0 128) b0)) ; sign + exp:1-7
                   (b2 (bitwise-ior
                        (if (odd? e0) 128 0)               ; exp:0
                        (bit-field f 16 23)))              ;   + mant:16-23
                   (b3 (bit-field f 8 16))                 ; mant:8-15
                   (b4 (bit-field f 0 8)))                 ; mant:0-7
              (output b1 b2 b3 b4))))))))
  (cond
   ((zero? num) (output 0 0 0 0))
   ((nan? num) (output #xff #xff #xff #xff))
   (else (compute))))

(define (bytevector-ieee-single-native-set! bytevector k num)
  (bytevector-ieee-single-set! bytevector k num (native-endianness)))

(define (bytevector-ieee-double-set! bytevector k num endianness)
  (define output
    (if (eq? endianness 'big)
        (lambda (b1 b2 b3 b4 b5 b6 b7 b8)
          (bytevector-u8-set-all! bytevector k b1 b2 b3 b4 b5 b6 b7 b8))
        (lambda (b1 b2 b3 b4 b5 b6 b7 b8)
          (bytevector-u8-set-all! bytevector k b8 b7 b6 b5 b4 b3 b2 b1))))
  (define (compute)
    (call-with-mantissa&exponent num 2 52 11
      (lambda (f e)
        (let ((e0 (+ e 1023 52)))
          (cond
           ((negative? e0)
            (let* ((f1 (exact (round (* f (expt 2 (- e0 1))))))
                   (b2 (bit-field f1 48 52))
                   (b3 (bit-field f1 40 48))
                   (b4 (bit-field f1 32 40))
                   (b5 (bit-field f1 24 32))
                   (b6 (bit-field f1 16 24))
                   (b7 (bit-field f1 8 16))
                   (b8 (bit-field f1 0 8)))
              (output (if (negative? num) 128 0) b2 b3 b4 b5 b6 b7 b8)))
           ((> e0 4095) ; infinity
            (output (if (negative? num) 255 127) 224 0 0 0 0 0 0))
           (else
            (let* ((b0 (bit-field e0 4 11))
                   (b1 (if (negative? num) (+ b0 128) b0))
                   (b2 (bitwise-ior (arithmetic-shift
                                     (bit-field e0 0 4)
                                     4)
                                    (bit-field f 48 52)))
                   (b3 (bit-field f 40 48))
                   (b4 (bit-field f 32 40))
                   (b5 (bit-field f 24 32))
                   (b6 (bit-field f 16 24))
                   (b7 (bit-field f 8 16))
                   (b8 (bit-field f 0 8)))
              (output b1 b2 b3 b4 b5 b6 b7 b8))))))))
  (cond
   ((zero? num) (output 0 0 0 0 0 0 0 0))
   ((nan? num) (output #xff #xff #xff #xff #xff #xff #xff #xff))
   (else (compute))))

(define (bytevector-ieee-double-native-set! bytevector k num)
  (bytevector-ieee-double-set! bytevector k num (native-endianness)))

;; Local Variables:
;; eval: (put 'call-with-mantissa&exponent 'scheme-indent-function 4)
;; End:

(define-library (chibi parse common)
  (export parse-integer parse-unsigned-integer parse-c-integer
          parse-real parse-complex
          parse-identifier parse-delimited parse-separated parse-records
          parse-space parse-binary-op
          parse-ipv4-address parse-ipv6-address parse-ip-address
          parse-domain parse-common-domain parse-email parse-uri
          char-hex-digit? char-octal-digit?)
  (cond-expand
   (chibi (import (chibi)))
   (else (import (scheme base) (scheme char))))
  (import (chibi parse))
  (include "common.scm"))

(define (char-hex-digit? ch)
  (or (char-numeric? ch)
      (memv (char-downcase ch) '(#\a #\b #\c #\d #\e #\f))))

(define (char-octal-digit? ch)
  (and (char? ch) (char<=? #\0 ch #\7)))

(define (parse-assert-range proc lo hi)
  (if (or lo hi)
      (parse-assert proc (lambda (n)
                          (and (or (not lo) (<= lo n))
                               (or (not hi) (<= n hi)))))
      proc))

(define (parse-unsigned-integer . o)
  (let ((lo (and (pair? o) (car o)))
        (hi (and (pair? o) (pair? (cdr o)) (cadr o))))
    (parse-assert-range
     (parse-map (parse-token char-numeric?) string->number)
     lo hi)))

(define (parse-sign+)
  (parse-or (parse-char #\+) (parse-char #\-)))

(define (parse-sign)
  (parse-or (parse-sign+) parse-epsilon))

(define (parse-integer . o)
  (let ((lo (and (pair? o) (car o)))
        (hi (and (pair? o) (pair? (cdr o)) (cadr o))))
    (parse-assert-range
     (parse-map-substring
      (parse-seq (parse-sign) (parse-token char-numeric?)
                 ;; (parse-not (parse-or (parse-sign) (parse-char #\.)))
                 )
      string->number)
     lo hi)))

(define (parse-c-integer)
  (parse-or
   (parse-map (parse-seq (parse-string "0x") (parse-token char-hex-digit?))
              (lambda (x) (string->number (cadr x) 16)))
   (parse-map (parse-seq (parse-string "0") (parse-token char-octal-digit?))
              (lambda (x) (string->number (cadr x) 8)))
   (parse-integer)))

(define (parse-real)
  (parse-map-substring
   (parse-seq
    (parse-or
     (parse-seq (parse-sign) (parse-repeat+ (parse-char char-numeric?))
                (parse-optional
                 (parse-seq (parse-char #\.)
                            (parse-repeat (parse-char char-numeric?)))))
     (parse-seq (parse-sign) (parse-char #\.)
                (parse-repeat+ (parse-char char-numeric?))))
    (parse-optional
     (parse-seq (parse-char (lambda (ch) (eqv? #\e (char-downcase ch))))
                (parse-sign)
                (parse-repeat+ (parse-char char-numeric?)))))
   string->number))

(define (parse-imag)
  (parse-or (parse-char #\i) (parse-char #\I)))

(define (parse-complex)
  (parse-map-substring
   (parse-or
    (parse-seq (parse-real) (parse-sign+) (parse-real) (parse-imag))
    (parse-seq (parse-real) (parse-imag))
    (parse-real))
   string->number))

(define (parse-identifier . o)
  ;; Slightly more complicated than mapping parse-token because the
  ;; typical identifier syntax has different initial and subsequent
  ;; char-sets.
  (let* ((init?
          (if (pair? o)
              (car o)
              (lambda (ch) (or (eqv? #\_ ch) (char-alphabetic? ch)))))
         (init (parse-char init?))
         (subsequent
          (parse-char
           (if (and (pair? o) (pair? (cdr o)))
               (cadr o)
               (lambda (ch) (or (init? ch) (char-numeric? ch)))))))
    (lambda (source0 index0 sk0 fk0)
      (init
       source0
       index0
       (lambda (res source index fk2)
         (let lp ((s source) (i index))
           (subsequent
            s i (lambda (r s i fk) (lp s i))
            (lambda (s i r)
              (sk0 (string->symbol (parse-stream-substring source0 index0 s i))
                   s i fk0)))))
       fk0))))

(define (parse-delimited . o)
  (let ((delim (if (pair? o) (car o) #\"))
        (esc (if (and (pair? o) (pair? (cdr o))) (cadr o) #\\))
        (parse-esc (if (and (pair? o) (pair? (cdr o)) (pair? (cddr o)))
                       (car (cddr o))
                       parse-anything)))
    (parse-map
     (parse-seq
      (parse-char delim)
      (parse-repeat
       (parse-or (parse-char
                  (lambda (ch)
                    (and (not (eqv? ch delim)) (not (eqv? ch esc)))))
                 (parse-map (parse-seq (parse-char esc)
                                       (if (eqv? delim esc)
                                           (parse-char esc)
                                           parse-esc))
                            cadr)))
      (parse-char delim))
     (lambda (res) (list->string (cadr res))))))

(define (parse-separated . o)
  (let* ((sep (if (pair? o) (car o) #\,))
         (o1 (if (pair? o) (cdr o) '()))
         (delim (if (pair? o1) (car o1) #\"))
         (o2 (if (pair? o1) (cdr o1) '()))
         (esc (if (pair? o2) (car o2) delim))
         (o3 (if (pair? o2) (cdr o2) '()))
         (ok?
          (if (pair? o3)
              (let ((pred (car o3)))
                (lambda (ch)
                  (and (not (eqv? ch delim))
                       (not (eqv? ch sep))
                       (pred ch))))
              (lambda (ch) (and (not (eqv? ch delim)) (not (eqv? ch sep))))))
         (parse-field
          (parse-or (parse-delimited delim esc)
                    (parse-map-substring
                     (parse-repeat+ (parse-char ok?))))))
    (parse-map
     (parse-seq parse-field
                (parse-repeat
                 (parse-map (parse-seq (parse-char sep) parse-field) cadr)))
     (lambda (res) (cons (car res) (cadr res))))))

(define (parse-records . o)
  (let* ((terms (if (pair? o) (car o) '("\r\n" "\n")))
         (terms (if (list? terms) terms (list terms)))
         (term-chars (apply append (map string->list terms)))
         (ok? (lambda (ch) (not (memv ch term-chars))))
         (o (if (pair? o) (cdr o) '()))
         (sep (if (pair? o) (car o) #\,))
         (o (if (pair? o) (cdr o) '()))
         (delim (if (pair? o) (car o) #\"))
         (o (if (pair? o) (cdr o) '()))
         (esc (if (pair? o) (car o) delim)))
    (parse-repeat
     (parse-map
      (parse-seq (parse-separated sep delim esc ok?)
                 (apply parse-or parse-end (map parse-string terms)))
      car))))

(define parse-space (parse-char char-whitespace?))

(define (op-value op) (car op))
(define (op-prec op) (cadr op))
(define (op-assoc op)
  (let ((tail (cddr op))) (if (pair? tail) (car tail) 'left)))
(define (op<? op1 op2)
  (or (< (op-prec op1) (op-prec op2))
      (and (= (op-prec op1) (op-prec op2))
           (eq? 'right (op-assoc op1)))))

;; rules are of the form ((op precedence [assoc=left]) ...)
;; ls is of the forms (expr [op expr] ...)
;; returns an sexp representation of the operator chain
(define (resolve-operator-precedence rules ls)
  (define (lookup op rules)
    (or (assoc op rules)
        (list op 0)))
  (define (join exprs ops)
    `((,(op-value (car ops)) ,(cadr exprs) ,(car exprs))
      ,@(cddr exprs)))
  (if (null? ls) (error "empty operator chain"))
  (let lp ((ls (cdr ls)) (exprs (list (car ls))) (ops '((#f -1))))
    ;; ls: trailing operations ([op expr] ...)
    ;; exprs: list of expressions (expr expr ...)
    ;; ops: operator chain, same len as exprs ((op prec [assoc]) ...)
    (cond
     ((and (null? ls) (null? (cdr exprs)))
      (car exprs))
     ((null? ls)
      (lp ls (join exprs ops) (cdr ops)))
     ((null? (cdr ls))
      (error "unbalanced expression" ls))
     (else
      (let ((op (lookup (car ls) rules))
            (expr (cadr ls)))
        (if (or (null? (cdr ops)) (op<? op (car ops)))
            (lp (cddr ls) (cons expr exprs) (cons op ops))
            (lp ls (join exprs ops) (cdr ops))))))))

(define (parse-binary-op op rules expr . o)
  (let* ((ws (if (pair? o) (car o) (parse-repeat parse-space)))
         (ws-right (if (and (pair? o) (pair? (cdr o))) (cadr o) ws)))
    (parse-map
     (parse-seq ws expr (parse-repeat (parse-seq ws-right op ws expr)))
     (lambda (x)
       (resolve-operator-precedence
        rules
        (cons (cadr x)
              (apply append
                     (map (lambda (y) (list (cadr y) (cadr (cddr y))))
                          (car (cddr x))))))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define parse-ipv4-digit (parse-integer 0 255))

(define parse-ipv4-address
  (parse-map-substring
   (parse-seq parse-ipv4-digit
              (parse-repeat (parse-seq (parse-char #\.) parse-ipv4-digit)
                            3 3))))

(define parse-ipv6-digit
  (parse-repeat (parse-char char-hex-digit?) 0 4))

(define parse-ipv6-address
  (parse-map-substring
   (parse-seq
    parse-ipv6-digit
    (parse-repeat (parse-seq (parse-repeat (parse-char #\:) 1 2)
                             parse-ipv6-digit)
                  1 7))))

(define parse-ip-address
  (parse-or parse-ipv4-address parse-ipv6-address))

(define parse-domain-atom
  (parse-token
   (lambda (ch)
     (or (char-alphabetic? ch) (char-numeric? ch) (memv ch '(#\- #\_))))))

(define (parse-domain)
  (parse-map-substring
   (parse-or
    parse-ip-address
    (parse-seq (parse-repeat (parse-seq parse-domain-atom (parse-char #\.)))
               parse-domain-atom))))

(define parse-top-level-domain
  (apply parse-or
         (parse-repeat (parse-char char-alphabetic?) 2 2)
         (map parse-string
              '("arpa" "com" "gov" "mil" "net" "org" "aero" "biz" "coop"
                "info" "museum" "name" "pro"))))

(define (parse-common-domain)
  (parse-map-substring
   (parse-seq (parse-repeat+ (parse-seq parse-domain-atom (parse-char #\.)))
              parse-top-level-domain)))

(define parse-email-local-part
  (parse-token
   (lambda (ch)
     (or (char-alphabetic? ch)
         (char-numeric? ch)
         (memv ch '(#\- #\_ #\. #\+))))))

(define (parse-email)
  ;; no quoted local parts or bang paths
  (parse-seq parse-email-local-part
             (parse-ignore (parse-char #\@))
             (parse-domain)))

(define (char-url-fragment? ch)
  (or (char-alphabetic? ch) (char-numeric? ch)
      (memv ch '(#\_ #\- #\+ #\\ #\= #\~ #\&))))

(define (char-url? ch)
  (or (char-url-fragment? ch) (memv ch '(#\. #\, #\;))))

(define (parse-url-char pred)
  (parse-or (parse-char pred)
            (parse-seq (parse-char #\%)
                       (parse-repeat (parse-char char-hex-digit?) 2 2))))

(define (parse-uri)
  (parse-seq
   (parse-identifier)
   (parse-ignore
    (parse-seq (parse-char #\:) (parse-repeat (parse-char #\/))))
   (parse-domain)
   (parse-optional (parse-map (parse-seq (parse-char #\:)
                                         (parse-integer 0 65536))
                              cadr))
   (parse-optional
    (parse-map-substring
     (parse-seq (parse-char #\/)
                (parse-repeat (parse-url-char char-url?)))))
   (parse-optional
    (parse-map
     (parse-seq (parse-ignore (parse-char #\?))
                (parse-map-substring
                 (parse-repeat (parse-url-char char-url?))))
     car))
   (parse-optional
    (parse-map
     (parse-seq (parse-ignore (parse-char #\#))
                (parse-map-substring
                 (parse-repeat (parse-url-char char-url-fragment?))))
     car))))
;; parse.scm -- Parser Combinators
;; Copyright (c) 2013 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

;;> \section{Parse Streams}

;;> Parse streams are an abstraction to treat ports as proper streams
;;> so that we can backtrack from previous states.  A single
;;> Parse-Stream record represents a single buffered chunk of text.

(define-record-type Parse-Stream
  (%make-parse-stream
   filename port buffer cache offset prev-char line column tail)
  parse-stream?
  ;; The file the data came from, for debugging and error reporting.
  (filename parse-stream-filename)
  ;; The underlying port.
  (port parse-stream-port)
  ;; A vector of characters read from the port.  We use a vector
  ;; rather than a string for guaranteed O(1) access.
  (buffer parse-stream-buffer)
  ;; A vector of caches corresponding to parser successes or failures
  ;; starting from the corresponding char.  Currently each cache is
  ;; just an alist, optimized under the assumption that the number of
  ;; possible memoized parsers is relatively small.  Note that
  ;; memoization is only enabled explicitly.
  (cache parse-stream-cache)
  ;; The current offset of filled characters in the buffer.
  ;; If offset is non-zero, (vector-ref buffer (- offset 1)) is
  ;; valid.
  (offset parse-stream-offset parse-stream-offset-set!)
  ;; The previous char before the beginning of this Parse-Stream.
  ;; Used for line/word-boundary checks.
  (prev-char parse-stream-prev-char)
  ;; The debug info for the start line and column of this chunk.
  (line parse-stream-line)
  (column parse-stream-column)
  ;; The successor Parse-Stream chunk, created on demand and filled
  ;; from the same port.
  (tail %parse-stream-tail %parse-stream-tail-set!))

;; We want to balance avoiding reallocating buffers with avoiding
;; holding many memoized values in memory.
(define default-buffer-size 256)

;;> Create a parse stream open on the given \var{filename}, with a
;;> possibly already opened \var{port}.

(define (make-parse-stream filename . o)
  (let ((port (if (pair? o) (car o) (open-input-file filename)))
        (len (if (and (pair? o) (pair? (cdr o))) (cadr o) default-buffer-size)))
    (%make-parse-stream
     filename port (make-vector len #f) (make-vector len '()) 0 #f 0 0 #f)))

;;> Open \var{filename} and create a parse stream on it.

(define (file->parse-stream filename)
  (make-parse-stream filename (open-input-file filename)))

;;> Create a parse stream on a string \var{str}.

(define (string->parse-stream str)
  (make-parse-stream #f (open-input-string str)))

;;> Access the next buffered chunk of a parse stream.

(define (parse-stream-tail source)
  (or (%parse-stream-tail source)
      (let* ((len (vector-length (parse-stream-buffer source)))
             (line-info (parse-stream-count-lines source))
             (line (+ (parse-stream-line source) (car line-info)))
             (col (if (zero? (car line-info))
                      (+ (parse-stream-column source) (cadr line-info))
                      (cadr line-info)))
             (tail (%make-parse-stream (parse-stream-filename source)
                                       (parse-stream-port source)
                                       (make-vector len #f)
                                       (make-vector len '())
                                       0
                                       (parse-stream-last-char source)
                                       line
                                       col
                                       #f)))
        (%parse-stream-tail-set! source tail)
        tail)))

(define (parse-stream-fill! source i)
  (let ((off (parse-stream-offset source))
        (buf (parse-stream-buffer source)))
    (if (<= off i)
        (do ((off off (+ off 1)))
            ((> off i) (parse-stream-offset-set! source off))
          (vector-set! buf off (read-char (parse-stream-port source))))
        #f)))

;;> Returns true iff \var{i} is the first character position in the
;;> parse stream \var{source}.

(define (parse-stream-start? source i)
  (and (zero? i) (not (parse-stream-prev-char source))))

;;> Returns true iff \var{i} is the last character position in the
;;> parse stream \var{source}.

(define (parse-stream-end? source i)
  (eof-object? (parse-stream-ref source i)))

;;> Returns the character in parse stream \var{source} indexed by
;;> \var{i}.

(define (parse-stream-ref source i)
  (parse-stream-fill! source i)
  (vector-ref (parse-stream-buffer source) i))

(define (parse-stream-last-char source)
  (let ((buf (parse-stream-buffer source)))
    (let lp ((i (min (- (vector-length buf) 1) (parse-stream-offset source))))
      (if (negative? i)
          (parse-stream-prev-char source)
          (let ((ch (vector-ref buf i)))
            (if (eof-object? ch)
                (lp (- i 1))
                ch))))))

(define (parse-stream-char-before source i)
  (if (> i (parse-stream-offset source))
      (parse-stream-ref source (- i 1))
      (parse-stream-prev-char source)))

(define (parse-stream-max-char source)
  (let ((buf (parse-stream-buffer source)))
    (let lp ((i (min (- (vector-length buf) 1)
                     (parse-stream-offset source))))
      (if (or (negative? i)
              (char? (vector-ref buf i)))
          i
          (lp (- i 1))))))

(define (parse-stream-count-lines source . o)
  (let* ((buf (parse-stream-buffer source))
         (end (if (pair? o) (car o) (vector-length buf))))
    (let lp ((i 0) (from 0) (lines 0))
      (if (>= i end)
          (list lines (- i from) from)
          (let ((ch (vector-ref buf i)))
            (cond
             ((not (char? ch))
              (list lines (- i from) from))
             ((eqv? ch #\newline)
              (lp (+ i 1) i (+ lines 1)))
             (else
              (lp (+ i 1) from lines))))))))

(define (parse-stream-end-of-line source i)
  (let* ((buf (parse-stream-buffer source))
         (end (vector-length buf)))
    (let lp ((i i))
      (if (>= i end)
          i
          (let ((ch (vector-ref buf i)))
            (if (or (not (char? ch)) (eqv? ch #\newline))
                i
                (lp (+ i 1))))))))

(define (parse-stream-debug-info s i)
  ;; i is the failed parse index, but we want the furthest reached
  ;; location
  (if (%parse-stream-tail s)
      (parse-stream-debug-info (%parse-stream-tail s) i)
      (let ((max-char (parse-stream-max-char s)))
        (if (< max-char 0)
            (list 0 0 "")
            (let* ((line-info
                    (parse-stream-count-lines s max-char))
                   (line (+ (parse-stream-line s) (car line-info)))
                   (col (if (zero? (car line-info))
                            (+ (parse-stream-column s) (cadr line-info))
                            (cadr line-info)))
                   (from (car (cddr line-info)))
                   (to (parse-stream-end-of-line s (+ from 1)))
                   (str (parse-stream-substring s from s to)))
              (list line col str))))))

(define (parse-stream-next-source source i)
  (if (>= (+ i 1) (vector-length (parse-stream-buffer source)))
      (parse-stream-tail source)
      source))

(define (parse-stream-next-index source i)
  (if (>= (+ i 1) (vector-length (parse-stream-buffer source)))
      0
      (+ i 1)))

(define (parse-stream-close source)
  (close-input-port (parse-stream-port source)))

(define (vector-substring vec start . o)
  (let* ((end (if (pair? o) (car o) (vector-length vec)))
         (res (make-string (- end start))))
    (do ((i start (+ i 1)))
        ((= i end) res)
      (string-set! res (- i start) (vector-ref vec i)))))

(define (parse-stream-in-tail? s0 s1)
  (let ((s0^ (%parse-stream-tail s0)))
    (or (eq? s0^ s1)
        (and s0^ (parse-stream-in-tail? s0^ s1)))))

(define (parse-stream< s0 i0 s1 i1)
  (if (eq? s0 s1)
      (< i0 i1)
      (parse-stream-in-tail? s0 s1)))

;;> Returns a string composed of the characters starting at parse
;;> stream \var{s0} index \var{i0} (inclusive), and ending at \var{s1}
;;> index \var{i1} (exclusive).

(define (parse-stream-substring s0 i0 s1 i1)
  (cond
   ((eq? s0 s1)
    (parse-stream-fill! s0 i1)
    (vector-substring (parse-stream-buffer s0) i0 i1))
   (else
    (let lp ((s (parse-stream-tail s0))
             (res (list (vector-substring (parse-stream-buffer s0) i0))))
      (let ((buf (parse-stream-buffer s)))
        (cond
         ((eq? s s1)
          (apply string-append
                 (reverse (cons (vector-substring buf 0 i1) res))))
         (else
          (lp (parse-stream-tail s)
              (cons (vector-substring buf 0) res)))))))))

(define (parse-stream-cache-cell s i f)
  (assv f (vector-ref (parse-stream-cache s) i)))

(define (parse-stream-cache-set! s i f x)
  (let ((cache (vector-ref (parse-stream-cache s) i)))
    (cond
     ((assv f cache)
      => (lambda (cell)
           ;; prefer longer matches
           (if (and (pair? (cdr cell))
                    (parse-stream< (car (cddr cell)) (cadr (cddr cell)) s i))
               (set-cdr! cell x))))
     (else
      (vector-set! (parse-stream-cache s) i (cons (cons f x) cache))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;> \section{Parser Interface}

;;> Combinator to indicate failure.

(define (parse-failure s i reason)
  (let ((line+col (parse-stream-debug-info s i)))
    (error "incomplete parse at" (append line+col (list reason)))))

;;> Call the parser combinator \var{f} on the parse stream
;;> \var{source}, starting at index \var{index}, passing the result to
;;> the given success continuation \var{sk}, which should be a
;;> procedure of the form \scheme{(result source index fail)}.  The
;;> optional failure continuation should be a procedure of the form
;;> \scheme{(source index reason)}, and defaults to just returning
;;> \scheme{#f}.

(define (call-with-parse f source index sk . o)
  (let ((s (if (string? source) (string->parse-stream source) source))
        (fk (if (pair? o) (car o) (lambda (s i reason) #f))))
    (f s index sk fk)))

;;> Call the parser combinator \var{f} on the parse stream
;;> \var{source}, at index \var{index}, and return the result, or
;;> \scheme{#f} if parsing fails.

(define (parse f source . o)
  (let ((index (if (pair? o) (car o) 0)))
    (call-with-parse f source index (lambda (r s i fk) r))))

;;> Call the parser combinator \var{f} on the parse stream
;;> \var{source}, at index \var{index}.  If the entire source is not
;;> parsed, raises an error, otherwise returns the result.

(define (parse-fully f source . o)
  (let ((s (if (string? source) (string->parse-stream source) source))
        (index (if (pair? o) (car o) 0)))
    (call-with-parse
     f s index
     (lambda (r s i fk)
       (if (parse-stream-end? s i) r (fk s i "incomplete parse")))
     parse-failure)))

;;> The fundamental parse iterator.  Repeatedly applies the parser
;;> combinator \var{f} to \var{source}, starting at \var{index}, as
;;> long as a valid parse is found.  On each successful parse applies
;;> the procedure \var{kons} to the parse result and the previous
;;> \var{kons} result, beginning with \var{knil}.  If no parses
;;> succeed returns \var{knil}.

(define (parse-fold f kons knil source . o)
  (let lp ((p (if (string? source) (string->parse-stream source) source))
           (index (if (pair? o) (car o) 0))
           (acc knil))
    (f p index (lambda (r s i fk) (lp s i (kons r acc))) (lambda (s i r) acc))))

;;> Parse as many of the parser combinator \var{f} from the parse
;;> stream \var{source}, starting at \var{index}, as possible, and
;;> return the result as a list.

(define (parse->list f source . o)
  (let ((index (if (pair? o) (car o) 0)))
    (reverse (parse-fold f cons '() source index))))

;;> As \scheme{parse->list} but requires the entire source be parsed
;;> with no left over characters, signalling an error otherwise.

(define (parse-fully->list f source . o)
  (let lp ((s (if (string? source) (string->parse-stream source) source))
           (index (if (pair? o) (car o) 0))
           (acc '()))
    (f s index
       (lambda (r s i fk)
         (if (eof-object? r) (reverse acc) (lp s i (cons r acc))))
       (lambda (s i reason) (error "incomplete parse")))))

;;> Return a new parser combinator with the same behavior as \var{f},
;;> but on failure replaces the reason with \var{reason}.  This can be
;;> useful to provide more descriptive parse failure reasons when
;;> chaining combinators.  For example, \scheme{parse-string} just
;;> expects to parse a single fixed string.  If it were defined in
;;> terms of \scheme{parse-char}, failure would indicate some char
;;> failed to match, but it's more useful to describe the whole string
;;> we were expecting to see.

(define (parse-with-failure-reason f reason)
  (lambda (r s i fk)
    (f r s i (lambda (s i r) (fk s i reason)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;> \section{Basic Parsing Combinators}

;;> Parse nothing successfully.

(define parse-epsilon
  (lambda (source index sk fk)
    (sk #t source index fk)))

;;> Parse any single character successfully.  Fails at end of input.

(define parse-anything
  (lambda (source index sk fk)
    (if (parse-stream-end? source index)
        (fk source index "end of input")
        (sk (parse-stream-ref source index)
            (parse-stream-next-source source index)
            (parse-stream-next-index source index)
            fk))))

;;> Always fail to parse.

(define parse-nothing
  (lambda (source index sk fk)
    (fk source index "nothing")))

;;> The disjunction combinator.  Returns the first combinator that
;;> succeeds parsing from the same source and index.

(define (parse-or f . o)
  (if (null? o)
      f
      (let ((g (apply parse-or o)))
        (lambda (source index sk fk)
          (let ((fk2 (lambda (s i r)
                       (g source index sk fk
                          ;; (lambda (s2 i2 r2)
                          ;;   (fk s2 i2 `(or ,r ,r2)))
                          ))))
            (f source index sk fk2))))))

;;> The conjunction combinator.  If both \var{f} and \var{g} parse
;;> successfully starting at the same source and index, returns the
;;> result of \var{g}.  Otherwise fails.

(define (parse-and f g)
  (lambda (source index sk fk)
    (f source index (lambda (r s i fk) (g source index sk fk)) fk)))

;;> The negation combinator.  If \var{f} succeeds, fails, otherwise
;;> succeeds with \var{#t}.

(define (parse-not f)
  (lambda (source index sk fk)
    (f source index (lambda (r s i fk) (fk s i "not"))
       (lambda (s i r) (sk #t source index fk)))))

(define (parse-seq-list o)
  (cond
   ((null? o)
    parse-epsilon)
   ((null? (cdr o))
    (let ((f (car o)))
      (lambda (s i sk fk)
        (f s i (lambda (r s i fk)
                 (sk (if (eq? r ignored-value) '() (list r)) s i fk))
           fk))))
   (else
    (let* ((f (car o))
           (o (cdr o))
           (g (car o))
           (o (cdr o))
           (g (if (pair? o)
                  (apply parse-seq g o)
                  (lambda (s i sk fk)
                    (g s i (lambda (r s i fk)
                             (sk (if (eq? r ignored-value) '() (list r))
                                 s i fk))
                       fk)))))
      (lambda (source index sk fk)
        (f source
           index
           (lambda (r s i fk)
             (g s i (lambda (r2 s i fk)
                      (let ((r2 (if (eq? r ignored-value) r2 (cons r r2))))
                        (sk r2 s i fk)))
                fk))
           fk))))))

;;> The sequence combinator.  Each combinator is applied in turn just
;;> past the position of the previous.  If all succeed, returns a list
;;> of the results in order, skipping any ignored values.

(define (parse-seq . o)
  (parse-seq-list o))

;;> Convert the list of parser combinators \var{ls} to a
;;> \scheme{parse-seq} sequence.

(define (list->parse-seq ls)
  (if (null? (cdr ls)) (car ls) (parse-seq-list ls)))

;;> The optional combinator.  Parse the combinator \var{f} (in
;;> sequence with any additional combinator args \var{o}), and return
;;> the result, or parse nothing successully on failure.

(define (parse-optional f . o)
  (if (pair? o)
      (parse-optional (apply parse-seq f o))
      (lambda (source index sk fk)
        (f source index sk (lambda (s i r) (sk #f source index fk))))))

(define ignored-value (list 'ignore))

;;> The repetition combinator.  Parse \var{f} repeatedly and return a
;;> list of the results.  \var{lo} is the minimum number of parses
;;> (deafult 0) to be considered a successful parse, and \var{hi} is
;;> the maximum number (default infinite) before stopping.

(define (parse-repeat f . o)
  (let ((lo (if (pair? o) (car o) 0))
        (hi (and (pair? o) (pair? (cdr o)) (cadr o))))
    (lambda (source0 index0 sk fk)
      (let repeat ((source source0) (index index0) (fk fk) (j 0) (res '()))
        (let ((fk (if (>= j lo)
                      (lambda (s i r) (sk (reverse res) source index fk))
                      fk)))
          (if (and hi (= j hi))
              (sk (reverse res) source index fk)
              (f source
                 index
                 (lambda (r s i fk) (repeat s i fk (+ j 1) (cons r res)))
                 fk)))))))

;;> Parse \var{f} one or more times.

(define (parse-repeat+ f)
  (parse-repeat f 1))

;;> Parse \var{f} and apply the procedure \var{proc} to the result on success.

(define (parse-map f proc)
  (lambda (source index sk fk)
    (f source index (lambda (res s i fk) (sk (proc res) s i fk)) fk)))

;;> Parse \var{f} and apply the procedure \var{proc} to the substring
;;> of the parsed data.  \var{proc} defaults to the identity.

(define (parse-map-substring f . o)
  (let ((proc (if (pair? o) (car o) (lambda (res) res))))
    (lambda (source index sk fk)
      (f source
         index
         (lambda (res s i fk)
           (sk (proc (parse-stream-substring source index s i)) s i fk))
         fk))))

;;> Parses the same streams as \var{f} but ignores the result on
;;> success.  Inside a \scheme{parse-seq} the result will not be
;;> included in the list of results.  Useful for discarding
;;> boiler-plate without the need for post-processing results.

(define (parse-ignore f)
  (parse-map f (lambda (res) ignored-value)))

;;> Parse with \var{f} and further require \var{check?} to return true
;;> when applied to the result.

(define (parse-assert f check?)
  (lambda (source index sk fk)
    (f source
       index
       (lambda (res s i fk)
         (if (check? res) (sk res s i fk) (fk s i "assertion failed")))
       fk)))

;;> Parse with \var{f} once and keep the first result, not allowing
;;> further backtracking within \var{f}.

(define (parse-atomic f)
  (lambda (source index sk fk)
    (f source index (lambda (res s i fk2) (sk res s i fk)) fk)))

;;> Parse with \var{f} once, keep the first result, and commit to the
;;> current parse path, discarding any prior backtracking options.
;;> Since prior backtracking options are discarded, prior failure
;;> continuations are also not used. By default, \scheme{#f} is
;;> returned on failure, a custom failure continuation can be passed
;;> as the second argument.

(define (parse-commit f . o)
  (let ((commit-fk (if (pair? o) (car o) (lambda (s i r) #f))))
    (lambda (source index sk fk)
      (f source index (lambda (res s i fk) (sk res s i commit-fk)) fk))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;> \section{Boundary Checks}

;;> Returns true iff \var{index} is the first index of the first parse
;;> stream \var{source}.

(define parse-beginning
  (lambda (source index sk fk)
    (if (parse-stream-start? source index)
        (sk #t source index fk)
        (fk source index "expected beginning"))))

;;> Returns true iff \var{index} is the last index of the last parse
;;> stream \var{source}.

(define parse-end
  (lambda (source index sk fk)
    (if (parse-stream-end? source index)
        (sk #t source index fk)
      (fk source index "expected end"))))

;;> Returns true iff \var{source}, \var{index} indicate the beginning
;;> of a line (or the entire stream).

(define parse-beginning-of-line
  (lambda (source index sk fk)
    (let ((before (parse-stream-char-before source index)))
      (if (or (not before) (eqv? #\newline before))
          (sk #t source index fk)
          (fk source index "expected beginning of line")))))

;;> Returns true iff \var{source}, \var{index} indicate the end of a
;;> line (or the entire stream).

(define parse-end-of-line
  (lambda (source index sk fk)
    (if (or (parse-stream-end? source index)
            (eqv? #\newline (parse-stream-ref source index)))
        (sk #t source index fk)
        (fk source index "expected end of line"))))

(define (char-word? ch)
  (or (char-alphabetic? ch) (eqv? ch #\_)))

;;> Returns true iff \var{source}, \var{index} indicate the beginning
;;> of a word (or the entire stream).

(define parse-beginning-of-word
  (lambda (source index sk fk)
    (let ((before (parse-stream-char-before source index)))
      (if (and (or (not before) (not (char-word? before)))
               (not (parse-stream-end? source index))
               (char-word? (parse-stream-ref source index)))
          (sk #t source index fk)
          (fk source index "expected beginning of word")))))

;;> Returns true iff \var{source}, \var{index} indicate the end of a
;;> word (or the entire stream).

(define parse-end-of-word
  (lambda (source index sk fk)
    (let ((before (parse-stream-char-before source index)))
      (if (and before
               (char-word? before)
               (or (parse-stream-end? source index)
                   (not (char-word? (parse-stream-ref source index)))))
          (sk #t source index fk)
          (fk source index "expected end of word")))))

;;> Parse the combinator \var{word} (default a \scheme{parse-token} of
;;> \scheme{char-alphabetic?} or underscores), ensuring it begins and
;;> ends on a word boundary.

(define (parse-word . o)
  (let ((word (if (pair? o) (car o) (parse-token char-word?))))
    (lambda (source index sk fk)
      (parse-map
       (parse-seq parse-beginning-of-word
                  word
                  parse-end-of-word)
       cadr))))

;;> As \scheme{parse-word}, but instead of an arbitrary word
;;> combinator takes a character predicate \var{pred} (conjoined with
;;> \scheme{char-alphabetic?} or underscore), and parses a sequence of
;;> those characters with \scheme{parse-token}.  Returns the parsed
;;> substring.

(define (parse-word+ . o)
  (let ((pred (if (pair? o)
                  (lambda (ch) (and (char-word? ch) ((car o) ch)))
                  char-word?)))
    (parse-word (parse-token pred))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;> \section{Constant Parsers}

(define (parse-char-pred pred)
  (lambda (source index sk fk)
    (let ((ch (parse-stream-ref source index)))
      (if (and (char? ch) (pred ch))
          (sk ch
              (parse-stream-next-source source index)
              (parse-stream-next-index source index)
              fk)
          (fk source index "failed char pred")))))

(define (x->char-predicate x)
  (cond
   ((char? x)
    (lambda (ch) (eqv? ch x)))
   ((char-set? x)
    (lambda (ch) (and (char? ch) (char-set-contains? x ch))))
   ((procedure? x)
    (lambda (ch) (and (char? ch) (x ch))))
   (else
    (error "don't know how to handle char predicate" x))))

;;> Parse a single char which matches \var{x}, which can be a
;;> character, character set, or arbitrary procedure.

(define (parse-char x)
  (parse-char-pred (x->char-predicate x)))

;;> Parse a single char which does not match \var{x}, which can be a
;;> character, character set, or arbitrary procedure.

(define (parse-not-char x)
  (let ((pred (x->char-predicate x)))
    (parse-char-pred (lambda (ch) (not (pred ch))))))

;;> Parse the exact string \var{str}.

(define (parse-string str)
  (parse-map (parse-with-failure-reason
              (parse-seq-list (map parse-char (string->list str)))
              (string-append "expected '" str "'"))
             list->string))

;;> Parse a sequence of characters matching \var{x} as with
;;> \scheme{parse-char}, and return the resulting substring.

(define (parse-token x)
  ;; (parse-map (parse-repeat+ (parse-char x)) list->string)
  ;; Tokens are atomic - we don't want to split them at any point in
  ;; the middle - so the implementation is slightly more complex than
  ;; the above.  With a sane grammar the result would be the same
  ;; either way, but this provides a useful optimization.
  (let ((f (parse-char x)))
    (lambda (source0 index0 sk fk)
      (let lp ((source source0) (index index0))
        (f source
           index
           (lambda (r s i fk) (lp s i))
           (lambda (s i r)
             (if (and (eq? source source0) (eqv? index index0))
                 (fk s i r)
                 (sk (parse-stream-substring source0 index0 source index)
                     source index fk))))))))

;;> We provide an extended subset of SRE syntax (see
;;> \hyperlink["http://srfi.schemers.org/srfi-115/srfi-115.html"]{SRFI 115}),
;;> taking advantage of more general parsing features.  These are just
;;> translated directly into parser combinators, with characters and
;;> strings implicitly matching themselves.  For example, \scheme{'(or
;;> "foo" "bar")} matches either of the strings \scheme{"foo"} or
;;> \scheme{"bar"}.  Existing parser combinators may be embedded directly.
;;> This is of course more powerful than SREs since it is not
;;> restricted to regular languages (or in fact any languages), though
;;> it does not provide the same performance guarantees.

(define (parse-sre x)
  (define (ranges->char-set ranges)
    (let lp ((ls ranges) (res (char-set)))
      (cond
       ((null? ls)
        res)
       ((string? (car ls))
        (lp (append (string->list (car ls)) (cdr ls)) res))
       ((null? (cdr ls))
        (error "incomplete range in / char-set" ranges))
       (else
        (let ((cs (ucs-range->char-set (char->integer (car ls))
                                       (+ 1 (char->integer (cadr ls))))))
          (lp (cddr ls) (char-set-union cs res)))))))
  (define (sre-list->char-set ls)
    (apply char-set-union (map sre->char-set ls)))
  (define (sre->char-set x)
    (cond
     ((char? x) (char-set x))
     ((string? x) (if (= 1 (string-length x))
                      (string->char-set x)
                      (error "multi-element string in char-set" x)))
     ((pair? x)
      (if (and (string? (car x)) (null? (cdr x)))
          (string->char-set (car x))
          (case (car x)
            ((/) (ranges->char-set (cdr x)))
            ((~) (char-set-complement (sre-list->char-set (cdr x))))
            ((-) (apply char-set-difference (map sre->char-set (cdr x))))
            ((&) (apply char-set-intersection (map sre->char-set (cdr x))))
            ((or) (sre-list->char-set (cdr x)))
            (else (error "unknown SRE char-set operator" x)))))
     (else (error "unknown SRE char-set" x))))
  (cond
   ((procedure? x)  ; an embedded parser
    x)
   ((or (char? x) (char-set? x))
    (parse-char x))
   ((string? x)
    (parse-string x))
   ((null? x)
    parse-epsilon)
   ((list? x)
    (case (car x)
      ((: seq) (parse-seq-list (map parse-sre (cdr x))))
      ((or) (apply parse-or (map parse-sre (cdr x))))
      ((and) (apply parse-and (map parse-sre (cdr x))))
      ((not) (apply parse-not (map parse-sre (cdr x))))
      ((*) (parse-repeat (list->parse-seq (map parse-sre (cdr x)))))
      ((+) (parse-repeat+ (list->parse-seq (map parse-sre (cdr x)))))
      ((?) (parse-optional (parse-seq-list (map parse-sre (cdr x)))))
      ((=> ->) (list->parse-seq (map parse-sre (cddr x))))
      ((word) (apply parse-word (cdr x)))
      ((word+) (apply parse-word+ (cdr x)))
      ((/ ~ & -) (parse-char (sre->char-set x)))
      (else
       (if (string? (car x))
           (parse-char (sre->char-set x))
           (error "unknown SRE operator" x)))))
   (else
    (case x
      ((any) parse-anything)
      ((nonl) (parse-char (lambda (ch) (not (eqv? ch #\newline)))))
      ((space whitespace) (parse-char char-whitespace?))
      ((digit numeric) (parse-char char-numeric?))
      ((alpha alphabetic) (parse-char char-alphabetic?))
      ((alnum alphanumeric)
       (parse-char-pred (lambda (ch) (or (char-alphabetic? ch) (char-numeric? ch)))))
      ((lower lower-case) (parse-char char-lower-case?))
      ((upper upper-case) (parse-char char-upper-case?))
      ((word) (parse-word))
      ((bow) parse-beginning-of-word)
      ((eow) parse-end-of-word)
      ((bol) parse-beginning-of-line)
      ((eol) parse-end-of-line)
      ((bos) parse-beginning)
      ((eos) parse-end)
      (else (error "unknown SRE parser" x))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;> \section{Laziness}

;;> A delayed combinator.  This is equivalent to the parser combinator
;;> \var{f}, but is delayed so it can be more efficient if never used
;;> and \var{f} is expensive to compute.  Moreover, it can allow
;;> self-referentiality as in:
;;>
;;> \schemeblock{
;;> (letrec* ((f (parse-lazy (parse-or (parse-seq g f) h))))
;;>   ...)
;;> }

(define-syntax parse-lazy
  (syntax-rules ()
    ((parse-lazy f)
     (let ((g (delay f)))
       (lambda (source index sk fk)
         ((force g) source index sk fk))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;> \section{Memoization}

;; debugging
(define *procedures* '())
(define (procedure-name f)
  (cond ((assq f *procedures*) => cdr) (else #f)))
(define (procedure-name-set! f name)
  (set! *procedures* (cons (cons f name) *procedures*)))

(define memoized-failure (list 'failure))

;;> Parse the same strings as \var{f}, but memoize the result at each
;;> source and index to avoid exponential backtracking.  \var{name} is
;;> provided for debugging only.

(define (parse-memoize name f)
  ;;(if (not (procedure-name f)) (procedure-name-set! f name))
  (lambda (source index sk fk)
    (cond
     ((parse-stream-cache-cell source index f)
      => (lambda (cell)
           (if (and (pair? (cdr cell)) (eq? memoized-failure (cadr cell)))
               (fk source index (cddr cell))
               (apply sk (append (cdr cell) (list fk))))))
     (else
      (f source
         index
         (lambda (res s i fk)
           (parse-stream-cache-set! source index f (list res s i))
           (sk res s i fk))
         (lambda (s i r)
           (if (not (pair? (parse-stream-cache-cell source index f)))
               (parse-stream-cache-set!
                source index f (cons memoized-failure r)))
           (fk s i r)))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;> \section{Syntax}

;;> The four basic interfaces are \scheme{grammar},
;;> \scheme{define-grammar}, and their unmemoized variants
;;> \scheme{grammar/unmemoized} and
;;> \scheme{define-grammar/unmemoized}.  This is optimized for the
;;> common case - generally you want to memoize grammars, and may or
;;> may not want to memoize the smaller lexical components.

;;> \macro{(grammar/unmemoized init (rule (clause [action]) ...) ...)}
;;>
;;> Describe an grammar for the given named \var{rules} and return the
;;> rule named \var{init}.  The rules are parser combinators which
;;> match the first \var{clause} which succeeds, and returns the
;;> corresponding action.  Each \var{clause} is an SRE parser as in
;;> \scheme{parse-sre}, which may include embdedded parser combinators
;;> with \scheme{unquote} (,).  In particular, the rule itself and any
;;> other rules can be referenced in this way.  The optional
;;> \var{action}, which defaults to the normal result of the clause
;;> parser, is a normal Scheme expression with all \scheme{->} named
;;> expressions in clause bound to the corresponding result.
;;> Alternately, \var{action} can be of the form \scheme{=> receiver}
;;> to send the results directly to a success continuation as in
;;> \scheme{call-with-parse}.

(define-syntax grammar/unmemoized
  (syntax-rules ()
    ((grammar/unmemoized init (rule (clause . action) ...) ...)
     (letrec ((rule (parse-or (grammar-clause clause . action) ...))
              ...)
       init))))

;;> \macro{(grammar init (rule (clause [action]) ...) ...)}
;;>
;;> Equivalent to \scheme{grammar} but memoizes each clause.  Parsers
;;> nested within each clause are not automatically memoized, so if
;;> necessary should be memoized explicitly or split out into separate
;;> rules.

(define-syntax grammar
  (syntax-rules ()
    ((grammar init (rule (clause . action) ...) ...)
     (letrec ((rule
               (parse-memoize
                'rule
                (parse-or (grammar-clause clause . action) ...)))
              ...)
       init))))

;;> \macro{(define-grammar/unmemoized name (rule (clause [action]) ...) ...)}
;;>
;;> Similar to \scheme{grammar/unmemoized}, instead of returning a
;;> single entry point parser defines each \var{rule} as its own
;;> parser.  Also defines \var{name} as an alist mapping rule names to
;;> their values.

(define-syntax define-grammar/unmemoized
  (syntax-rules ()
    ((define-grammar/unmemoized name (rule (clause . action) ...) ...)
     (begin
       (define rule (parse-or (grammar-clause clause . action) ...))
       ...
       (define name (list (cons 'rule rule) ...))))))

;;> \macro{(define-grammar name (rule (clause [action]) ...) ...)}
;;>
;;> The memoized version of \scheme{define-grammar/unmemoized}.
;;>
;;> Example:
;;>
;;> \example{
;;> (define-grammar calc
;;>   (space ((* ,(parse-char char-whitespace?))))
;;>   (number ((-> n (+ ,(parse-char char-numeric?)))
;;>            (string->number (list->string n))))
;;>   (simple ((-> n ,number) n)
;;>           ((: "(" (=> e1 ,term) ")") e1))
;;>   (term-op ("*" *)
;;>            ("/" /)
;;>            ("%" modulo))
;;>   (term ((: (-> e1 ,simple) ,space (-> op ,term-op) ,space (-> e2 ,term))
;;>          (op e1 e2))
;;>         ((-> e1 ,simple)
;;>          e1)))
;;> (parse term "12 / (2*3)")
;;> }

(define-syntax define-grammar
  (syntax-rules ()
    ((define-grammar name (rule (clause . action) ...) ...)
     (begin
       (define rule
         (parse-memoize 'rule (parse-or (grammar-clause clause . action) ...)))
       ...
       (define name (list (cons 'rule rule) ...))))))

;; Most of the implementation goes into how we parse a single grammar
;; clause.  This is hard to read if you're not used to CPS macros.

(define-syntax grammar-clause
  (syntax-rules ()
    ((grammar-clause clause . action)
     (grammar-extract clause () (grammar-action action)))))

(define-syntax grammar-extract
  (syntax-rules (unquote -> => : seq * + ? or and)
    ;; Named patterns
    ((grammar-extract (-> name pattern) bindings k)
     (grammar-extract pattern bindings (grammar-bind name k)))
    ((grammar-extract (-> name pattern ...) bindings k)
     (grammar-extract (: pattern ...) bindings (grammar-bind name k)))
    ;; Allow => as an alias for -> for SRE compatibility.
    ((grammar-extract (=> name pattern) bindings k)
     (grammar-extract pattern bindings (grammar-bind name k)))
    ((grammar-extract (=> name pattern ...) bindings k)
     (grammar-extract (: pattern ...) bindings (grammar-bind name k)))
    ((grammar-extract ,name bindings k)
     (grammar-bind name k (parse-sre name) bindings))
    ;; Walk container patterns.
    ((grammar-extract (: x y ...) bindings k)
     (grammar-extract x bindings (grammar-map parse-seq (y ...) () k)))
    ((grammar-extract (* x) bindings k)
     (grammar-extract x bindings (grammar-map parse-repeat () () k)))
    ((grammar-extract (* x y ...) bindings k)
     (grammar-extract (: x y ...) bindings (grammar-map parse-repeat () () k)))
    ((grammar-extract (+ x) bindings k)
     (grammar-extract x bindings (grammar-map parse-repeat+ () () k)))
    ((grammar-extract (+ x y ...) bindings k)
     (grammar-extract (: x y ...) bindings (grammar-map parse-repeat+ () () k)))
    ((grammar-extract (? x y ...) bindings k)
     (grammar-extract x bindings (grammar-map parse-optional (y ...) () k)))
    ((grammar-extract (or x y ...) bindings k)
     (grammar-extract x bindings (grammar-map parse-or (y ...) () k)))
    ((grammar-extract (and x y ...) bindings k)
     (grammar-extract x bindings (grammar-map parse-and (y ...) () k)))
    ;; Anything else is an implicitly quasiquoted SRE
    ((grammar-extract pattern bindings (k ...))
     (k ... (parse-sre `pattern) bindings))))

(define-syntax grammar-map
  (syntax-rules ()
    ((grammar-map f () (args ...) (k ...) x bindings)
     (k ... (f args ... x) bindings))
    ((grammar-map f (y . rest) (args ...) k x bindings)
     (grammar-extract y bindings (grammar-map f rest (args ... x) k)))))

(define-syntax grammar-action
  (syntax-rules (=>)
    ((grammar-action () parser bindings)
     ;; By default just return the result.
     (grammar-action (=> (lambda (r s i fk) r)) parser bindings))
    ((grammar-action (=> receiver) parser ((var tmp) ...))
     ;; Explicit => handler.
     (lambda (source index sk fk)
       (let ((tmp #f) ...)
         (parser source
                 index
                 (lambda (r s i fk)
                   (sk (receiver r s i fk) s i fk))
                 fk))))
    ((grammar-action (action-expr) parser ())
     ;; Fast path - no named variables.
     (let ((f parser))
       (lambda (source index sk fk)
         (f source index (lambda (r s i fk) (sk action-expr s i fk)) fk))))
    ((grammar-action (action-expr) parser ((var tmp) ...))
     (lambda (source index sk fk)
       (let ((tmp #f) ...)
         ;; TODO: Precompute static components of the parser.
         ;; We need to bind fresh variables on each parse, so some
         ;; components must be reified in this scope.
         (parser source
                 index
                 (lambda (r s i fk)
                   (sk (let ((var tmp) ...) action-expr) s i fk))
                 fk))))))

(define-library (chibi log-test)
  (export run-tests)
  (import (scheme base) (scheme inexact) (srfi 130)
          (chibi log) (chibi show) (chibi test))
  (begin
    (define-syntax log->string
      (syntax-rules ()
        ((log->string expr ...)
         (let ((out (open-output-string)))
           (parameterize ((current-error-port out))
             (log-open default-logger)
             expr ...
             (get-output-string out))))))
    (define-syntax log->string/no-dates
      (syntax-rules ()
        ((log->string/no-dates expr ...)
         (string-join
          (map (lambda (line)
                 (if (string-null? line) line (substring line 20)))
               (string-split (log->string expr ...) "\n"))
          "\n"))))
    (define (run-tests)
      (test-begin "logging")
      (test "D four: 4\n"
          (log->string/no-dates
           (log-debug "four: " (+ 2 2))))
      (test "I pi: 3.14\n"
          (log->string/no-dates
           (log-info "pi: " (with ((precision 2)) (acos -1)))))
      (test-assert
        (string-prefix? "E "
                        (log->string/no-dates
                         (with-logged-errors (/ 1 0)))))
      (test "W warn\nE error\n"
          (log->string/no-dates
           (with-log-level
            'warn
            (log-info "info")
            (log-warn "warn")
            (log-error "error"))))
      (test-end))))

(define-library (chibi doc)
  (import
   (except (chibi) eval) (scheme eval) (srfi 1) (srfi 39) (srfi 95)
   (chibi modules) (chibi ast) (chibi io) (chibi match)
   (chibi time) (chibi filesystem) (chibi process) (chibi pathname)
   (chibi string) (chibi scribble) (chibi sxml) (chibi highlight)
   (chibi type-inference))
  (export procedure-docs print-procedure-docs
          print-module-docs print-module-binding-docs
          generate-docs expand-docs fixup-docs
          extract-module-docs extract-module-file-docs extract-file-docs
          make-default-doc-env make-module-doc-env
          get-optionals-signature
          ansi->sxml)
  (include "doc.scm"))

(define-library (chibi show) (alias-for (srfi 166)))

(define-library (chibi binary-record)
  (import (scheme base) (srfi 1))
  (cond-expand
   ((library (srfi 151)) (import (srfi 151)))
   ((library (srfi 33)) (import (srfi 33)))
   (else (import (srfi 60))))
  (cond-expand
   ((library (srfi 130)) (import (srfi 130)))
   (else (import (srfi 13))))
  (export
   ;; interface
   define-binary-record-type
   ;; binary types
   u8 u16/le u16/be padded-string fixed-string
   octal decimal hexadecimal
   ;; auxiliary syntax
   make: pred: read: write: block:
   ;; indirect exports
   define-binary-type defrec define-auxiliary-syntax
   syntax-let-optionals*)
  (include "binary-types.scm")
  (cond-expand
   (chicken
    (include "binary-record-chicken.scm"))
   (else
    (include "binary-record.scm"))))
;; strings.scm -- cursor-oriented string library
;; Copyright (c) 2012-2015 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

;;> \section{High-level API}

;;> The procedures below are similar to those in SRFI 13 or other
;;> string libraries, except instead of receiving and returning
;;> character indexes they use opaque string cursors.

;;> \procedure{(string-null? str)}
;;> Returns true iff \var{str} is equal to the empty string \scheme{""}.

(define (string-null? str)
  (equal? str ""))

(define (->cursor str x)
  (if (string-cursor? x)
      x
      (string-index->cursor str x)))

(define (make-char-predicate x)
  (cond ((procedure? x) x)
        ((char? x) (lambda (ch) (eq? ch x)))
        ((char-set? x) (lambda (ch) (char-set-contains? x ch)))
        (else (error "invalid character predicate" x))))

(define (complement pred) (lambda (x) (not (pred x))))

;;> Returns true iff \var{check} is true for any character in
;;> \var{str}.  \var{check} can be a procedure, char (to test for
;;> \scheme{char=?} equivalence) or char-set (to test for
;;> \var{char-set-contains?}).  Always returns false if \var{str} is
;;> empty.

(define (string-any check str . o)
  (let ((pred (make-char-predicate check))
        (end (if (and (pair? o) (pair? (cdr o)))
                 (->cursor str (cadr o))
                 (string-cursor-end str))))
    (and (string-cursor>? end (if (pair? o)
                                  (->cursor str (car o))
                                  (string-cursor-start str)))
         (let lp ((i (string-cursor-start str)))
           (let ((i2 (string-cursor-next str i))
                 (ch (string-cursor-ref str i)))
             (if (string-cursor>=? i2 end)
                 (pred ch)  ;; tail call
                 (or (pred ch) (lp i2))))))))

;;> Returns true iff \var{check} is true for every character in
;;> \var{str}.  \var{check} can be a procedure, char or char-set as in
;;> \scheme{string-any}.  Always returns true if \var{str} is empty.

(define (string-every check str . o)
  (not (apply string-any (complement (make-char-predicate check)) str o)))

;;> Returns a cursor pointing to the first position from the left in
;;> string for which \var{check} is true.  \var{check} can be a
;;> procedure, char or char-set as in \scheme{string-any}.  The
;;> optional cursors \var{start} and \var{end} can specify a substring
;;> to search, and default to the whole string.  Returns a cursor just
;;> past the end of \var{str} if no character matches.

(define (string-find str check . o)
  (let ((pred (make-char-predicate check))
        (end (if (and (pair? o) (pair? (cdr o)))
                 (->cursor str (cadr o))
                 (string-cursor-end str))))
    (let lp ((i (if (pair? o) (car o) (string-cursor-start str))))
      (cond ((string-cursor>=? i end) end)
            ((pred (string-cursor-ref str i)) i)
            (else (lp (string-cursor-next str i)))))))

;;> As above, ignoring the position and returning true iff any
;;> character matches.

(define (string-find? str check . o)
  (let ((start (if (pair? o) (->cursor str (car o)) (string-cursor-start str)))
        (end (if (and (pair? o) (pair? (cdr o)))
                 (->cursor str (cadr o))
                 (string-cursor-end str))))
    (string-cursor<? (string-find str check start end) end)))

;;> As \scheme{string-find}, but returns the position of the first
;;> character from the right of \var{str}.  If no character matches,
;;> returns a string cursor pointing just before \var{start}.

(define (string-find-right str check . o)
  (let ((pred (make-char-predicate check))
        (start (if (pair? o) (->cursor str (car o)) (string-cursor-start str))))
    (let lp ((i (if (and (pair? o) (pair? (cdr o)))
                    (->cursor str (cadr o))
                    (string-cursor-end str))))
      (let ((i2 (string-cursor-prev str i)))
        (cond ((string-cursor<? i2 start) start)
              ((pred (string-cursor-ref str i2)) i)
              (else (lp i2)))))))

;;> As \scheme{string-find}, but inverts the check, returning the
;;> position of the first character which doesn't match.

(define (string-skip str check . o)
  (apply string-find str (complement (make-char-predicate check)) o))

;;> As \scheme{string-find-right}, but inverts the check, returning
;;> the position of the first character which doesn't match.

(define (string-skip-right str check . o)
  (apply string-find-right str (complement (make-char-predicate check)) o))

;;> \procedure{(string-join list-of-strings [separator])}
;;>
;;> Concatenates the \var{list-of-strings} and return the result as a
;;> single string.  If \var{separator} is provided it is inserted
;;> between each pair of strings.

(define string-join string-concatenate)

;;> Split \var{str} into a list of substrings separated by \var{pred},
;;> which defaults to \scheme{#\\space}.  Multiple adjacent characters
;;> which satisy \var{pred} will result in empty strings in the list.
;;> If the optional \var{limit} is provided, splits into at most that
;;> many substrings starting from the left.

(define (string-split str . o)
  (let ((pred (make-char-predicate (if (pair? o) (car o) #\space)))
        (limit (if (and (pair? o) (pair? (cdr o)))
                   (cadr o)
                   (+ 1 (string-size str))))
        (start (string-cursor-start str))
        (end (string-cursor-end str)))
    (if (string-cursor>=? start end)
        '()
        (let lp ((i start) (n 1) (res '()))
          (cond
           ((>= n limit)
            (reverse (cons (substring-cursor str i) res)))
           (else
            (let* ((j (string-find str pred i))
                   (res (cons (substring-cursor str i j) res)))
              (if (string-cursor>=? j end)
                  (reverse res)
                  (lp (string-cursor-next str j) (+ n 1) res)))))))))

;;> Returns a copy of the string \var{str} with all characters
;;> matching \var{pred} (default \scheme{#\\space}) removed from the
;;> left.

(define (string-trim-left str . o)
  (let ((pred (make-char-predicate (if (pair? o) (car o) #\space))))
    (substring-cursor str (string-skip str pred))))

;;> Returns a copy of the string \var{str} with all characters
;;> matching \var{pred} (default \scheme{#\\space}) removed from the
;;> right.

(define (string-trim-right str . o)
  (let ((pred (make-char-predicate (if (pair? o) (car o) #\space))))
    (substring-cursor str
                      (string-cursor-start str)
                      (string-skip-right str pred))))

;;> Returns a copy of the string \var{str} with all characters
;;> matching \var{pred} (default \scheme{#\\space}) removed from both
;;> sides.

(define (string-trim str . o)
  (let* ((pred (if (pair? o) (car o) #\space))
         (left (string-skip str pred))
         (right (string-skip-right str pred)))
    (if (string-cursor>=? left right)
        ""
        (substring-cursor str left right))))

;;> Returns two values: the first cursors from the left in
;;> \var{prefix} and in \var{str} where the two strings don't match.

(define (string-mismatch prefix str)
  (let ((end1 (string-cursor-end prefix))
        (end2 (string-cursor-end str)))
    (let lp ((i (string-cursor-start prefix))
             (j (string-cursor-start str)))
      (if (or (string-cursor>=? i end1)
              (string-cursor>=? j end2)
              (not (eq? (string-cursor-ref prefix i) (string-cursor-ref str j))))
          (values i j)
          (lp (string-cursor-next prefix i) (string-cursor-next str j))))))

;;> Returns two values: the first cursors from the right in
;;> \var{prefix} and in \var{str} where the two strings don't match.

(define (string-mismatch-right suffix str)
  (let ((end1 (string-cursor-start suffix))
        (end2 (string-cursor-start str)))
    (let lp ((i (string-cursor-prev suffix (string-cursor-end suffix)))
             (j (string-cursor-prev str (string-cursor-end str))))
      (if (or (string-cursor<? i end1)
              (string-cursor<? j end2)
              (not (eq? (string-cursor-ref suffix i) (string-cursor-ref str j))))
          (values i j)
          (lp (string-cursor-prev suffix i) (string-cursor-prev str j))))))

;;> Returns true iff \var{prefix} is a prefix of \var{str}.

(define (string-prefix? prefix str)
  (call-with-values (lambda () (string-mismatch prefix str))
    (lambda (i j) (string-cursor=? (string-cursor-end prefix) i))))

;;> Returns true iff \var{suffix} is a suffix of \var{str}.

(define (string-suffix? suffix str)
  (let ((diff (- (string-size str) (string-size suffix))))
    (and (>= diff 0)
         (string-cursor=? (string-cursor-prev suffix
                                              (string-cursor-start suffix))
                          (string-cursor-back
                           str
                           (call-with-values
                               (lambda () (string-mismatch-right suffix str))
                             (lambda (i j) j))
                           diff)))))

;;> The fundamental string iterator.  Calls \var{kons} on each
;;> character of \var{str} and an accumulator, starting with
;;> \var{knil}.  If multiple strings are provided, calls \var{kons} on
;;> the corresponding characters of all strings, with the accumulator
;;> as the final argument, and terminates when the shortest string
;;> runs out.

(define (string-fold kons knil str . los)
  (if (null? los)
      (let ((end (string-cursor-end str)))
        (let lp ((i (string-cursor-start str)) (acc knil))
          (if (string-cursor>=? i end)
              acc
              (lp (string-cursor-next str i)
                  (kons (string-cursor-ref str i) acc)))))
      (let ((los (cons str los)))
        (let lp ((is (map string-cursor-start los))
                 (acc knil))
          (if (any (lambda (str i)
                     (string-cursor>=? i (string-cursor-end str)))
                   los is)
              acc
              (lp (map string-cursor-next los is)
                  (apply kons (append (map string-cursor-ref los is)
                                      (list acc)))))))))

;;> Equivalent to \scheme{string-fold}, but iterates over \var{str}
;;> from right to left.

(define (string-fold-right kons knil str)
  (let ((end (string-cursor-end str)))
    (let lp ((i (string-cursor-start str)))
      (if (string-cursor>=? i end)
          knil
          (kons (string-cursor-ref str i) (lp (string-cursor-next str i)))))))

;;> \procedure{(string-map proc str)}
;;>
;;> Returns a new string composed of applying the procedure \var{proc}
;;> to every character in \var{string}.

;;> \procedure{(string-for-each proc str)}
;;>
;;> Apply \var{proc} to every character in \var{str} in order and
;;> discard the result.

;;> \procedure{(string-count str check)}
;;>
;;> Count the number of characters in \var{str} for which \var{check}
;;> is true.

(define (string-count str check)
  (let ((pred (make-char-predicate check)))
    (string-fold (lambda (ch count) (if (pred ch) (+ count 1) count)) 0 str)))

;;> \procedure{(string-contains s1 s2 [start])}
;;>
;;> Returns a cursor pointing to the first position in the string
;;> \var{s1} where \var{s2} occurs, or \scheme{#f} if there is no such
;;> match.

;;> \procedure{(make-string-searcher needle)}
;;>
;;> Partial application of \scheme{string-contains}.  Return a
;;> procedure of one argument, a string, which runs
;;> \scheme{(string-contains str \var{needle})}.

(define (make-string-searcher needle)
  (lambda (haystack) (string-contains haystack needle)))

;;> Return a copy of string \var{s} with all 26 upper-case ASCII
;;> characters mapped to their corresponding 26 lower-case ASCII
;;> characters.

(define (string-downcase-ascii s)
  (call-with-output-string
    (lambda (out)
      (string-for-each (lambda (ch) (write-char (char-downcase ch) out)) s))))

;;> Return a copy of string \var{s} with all 26 lower-case ASCII
;;> characters mapped to their corresponding 26 upper-case ASCII
;;> characters.

(define (string-upcase-ascii s)
  (call-with-output-string
    (lambda (out)
      (string-for-each (lambda (ch) (write-char (char-upcase ch) out)) s))))

;;> \section{Cursor API}

;;> \procedure{(substring-cursor str i [j])}
;;>
;;> Returns the substring of \var{str} between \var{i} (inclusive) and
;;> optional \var{j} (exclusive), which defaults to the end of the
;;> string.

;;> \procedure{(string-cursor-ref str i)}
;;>
;;> Returns the character of \var{str} at position \var{i}.

;;> \procedure{(string-cursor-start str)}
;;>
;;> Returns a string cursor pointing to the start of \var{str}.

;;> \procedure{(string-cursor-end str)}
;;>
;;> Returns a string cursor pointing just past the end of \var{str}.

;;> \procedure{(string-cursor-next str i)}
;;>
;;> Returns a string cursor to the character in \var{str} just after
;;> the cursor \var{i}.

;;> \procedure{(string-cursor-prev str i)}
;;>
;;> Returns a string cursor to the character in \var{str} just before
;;> the cursor \var{i}.

(define (string-cursor-forward str cursor n)
  (if (positive? n)
      (string-cursor-forward str (string-cursor-next str cursor) (- n 1))
      cursor))

(define (string-cursor-back str cursor n)
  (if (positive? n)
      (string-cursor-back str (string-cursor-prev str cursor) (- n 1))
      cursor))

;;> \procedure{(string-cursor<? i j)}
;;> \procedure{(string-cursor>? i j)}
;;> \procedure{(string-cursor=? i j)}
;;> \procedure{(string-cursor<=? i j)}
;;> \procedure{(string-cursor>=? i j)}
;;>
;;> String cursor comparators.
;;/
(define-library (chibi syntax-case)
  (export ... _ free-identifier=? bound-identifier=? identifier?
          syntax-case syntax quasisyntax unsyntax unsyntax-splicing
          datum->syntax syntax->datum
          generate-temporaries with-syntax syntax-violation
          with-ellipsis ellipsis-identifier?
          define-syntax let-syntax letrec-syntax)
  (import (rename (chibi)
                  (define-syntax %define-syntax)
                  (let-syntax %let-syntax)
                  (letrec-syntax %letrec-syntax))
          (only (chibi ast)
                env-cell macro? macro-aux macro-aux-set!
                procedure-arity procedure-variadic?
                procedure-variable-transformer?
                make-variable-transformer)
          (only (meta) environment)
          (srfi 1)
          (srfi 2)
          (srfi 9)
          (srfi 11)
          (srfi 39))
  (include "syntax-case.scm"))

;;> A minimal character set library.

(define-library (chibi char-set)
  (import (chibi char-set base) (chibi char-set extras))
  (export
   Char-Set char-set? char-set-contains?
   char-set ucs-range->char-set char-set-copy char-set-size
   char-set-fold char-set-for-each
   list->char-set char-set->list string->char-set char-set->string
   char-set-adjoin! char-set-adjoin char-set-union char-set-union!
   char-set-intersection char-set-intersection!
   char-set-difference char-set-difference!
   immutable-char-set char-set-complement
   char-set:empty char-set:ascii char-set:full))

(define-library (chibi modules)
  (export module? module-name module-dir module-includes module-shared-includes
          module-include-library-declarations module-meta-data
          module-ast module-ast-set! module-ref module-contains?
          analyze-module containing-module load-module module-exports
          module-name->file module-lib-dir procedure-analysis find-module
          available-modules-in-directory available-modules
          modules-exporting-identifier file->sexp-list)
  (import (chibi)
          (srfi 1)
          (chibi ast)
          (chibi pathname)
          (chibi filesystem)
          (chibi string)
          (only (meta)
                module-env module-meta-data module-exports
                make-module load-module find-module resolve-import
                resolve-module-imports
                module-name-prefix
                module-name->file
                *modules*))
  (include "modules.scm"))

(define-library (chibi show c-test)
  (import (scheme base) (chibi show) (chibi show c) (chibi test))
  (export run-tests)
  (begin
    (define (run-tests)
      (test-begin "show c")

      (test "if (1) {
    2;
} else {
    3;
}
"
          (show #f (c-if 1 2 3)))

      (test "if (x ? y : z) {
    2;
} else {
    3;
}
"
          (show #f (c-if (c-if 'x 'y 'z) 2 3)))

      (test "if (x ? y : z) {
    2;
} else {
    3;
}
"
          (show #f (c-expr '(if (if x y z) 2 3))))

      (test "if (x ? y : z) {
    2;
} else {
    3;
}
"
          (show #f (c-expr '(%begin (if (if x y z) 2 3)))))

      (test "if (x ? y : z) {
    2;
} else {
    if (w) {
        3;
    } else {
        4;
    }
}
"
          (show #f (c-expr '(if (if x y z) 2 (if w 3 4)))))

      (test "if (x ? y : z) {
    2;
} else {
    if (w) {
        if (u) {
            3;
        } else {
            4;
        }
    } else {
        5;
    }
}
"
          (show #f (c-expr '(if (if x y z) 2 (if w (if u 3 4) 5)))))

      (test "int square (int x) {
    return x * x;
}
"
          (show #f (c-fun 'int 'square '((int x)) (c* 'x 'x))))

      (test "int foo (int x, int y, int z) {
    if (x ? y : z) {
        return 2;
    } else {
        return 3;
    }
}
"
          (show #f (c-fun 'int 'foo '((int x) (int y) (int z))
                          (c-if (c-if 'x 'y 'z) 2 3))))

      (test "some_function(shape, x, y + 1, z);\n"
          (show #f (c-expr '(some_function shape x (+ y 1) z))))

      (test "if (y < 255 && pred(shape, x, y, z) == 0) {
    2;
} else {
    3;
}
"
          (show #f (c-expr '(if (&& (< y 255) (== (pred shape x y z) 0)) 2 3))))

      (test "heightmap[i + k * 16];\n"
          (show #f (c-expr '(vector-ref heightmap (+ i (* k 16))))))

      (test "void bar (int mode, const char *msg, unsigned int arg) {
    if (mode == 1) {
        printf(msg);
    } else {
        printf(msg, arg);
    }
}
"
          (show #f (c-fun 'void 'bar
                          '((int mode)
                            ((%pointer (const char)) msg)
                            ((unsigned int) arg))
                          (c-if (c== 'mode 1) '(printf msg) '(printf msg arg)))))

      (test "while ((line = readline()) != EOF) {
    printf(\"%s\", line);
}
"
          (show #f (c-while (c!= (c= 'line '(readline)) 'EOF)
                            '(printf "%s" line))))

      (test "switch (y) {
case 1:
    x = 1;
    break;
case 2:
    x = 4;
    break;
default:
    x = 5;
    break;
}
"
          (show #f (c-switch 'y
                             (c-case 1 (c= 'x 1))
                             (c-case 2 (c= 'x 4))
                             (c-default (c= 'x 5)))))

      (test "switch (y) {
case 1:
    x = 1;
    break;
case 2:
    x = 4;
default:
    x = 5;
    break;
}
"
          (show #f (c-switch 'y
                             (c-case 1 (c= 'x 1))
                             (c-case/fallthrough 2 (c= 'x 4))
                             (c-default (c= 'x 5)))))

      (test "switch (y) {
case 1:
    x = 1;
    break;
case 2:
    x = 4;
    break;
default:
    x = 5;
    break;
}
"
          (show #f (c-switch 'y '((1) (= x 1)) '((2) (= x 4)) '(else (= x 5)))))

      (test "switch (y) {
case 1:
    x = 1;
    break;
case 2:
    x = 4;
    break;
default:
    x = 5;
    break;
}
"
          (show #f (c-expr '(switch y ((1) (= x 1)) ((2) (= x 4)) (else (= x 5))))))

      (test "int q (int x) {
    switch (x) {
    case 1:
        return 1;
    case 2:
        return 4;
    default:
        return 5;
    }
}
"
          (show #f (c-fun 'int 'q '(x) (c-switch 'x '((1) 1) '((2) 4) '(else 5)))))

      (test "switch (x) {
case 1:
case 2:
    foo();
    break;
default:
    bar();
    break;
}
"
          (show #f (c-expr '(switch x ((1 2) (foo)) (else (bar))))))

      (test "switch (x) {
case 1:
    foo();
    break;
case 2:
case 3:
    bar();
    break;
default:
    baz();
    break;
}
"
          (show #f (c-expr
                    '(switch x (case 1 (foo)) (case (2 3) (bar)) (else (baz))))))

      (test "switch (x) {
case 1:
case 2:
    foo();
default:
    bar();
    break;
}
"
          (show #f (c-expr '(switch x (case/fallthrough (1 2) (foo)) (else (bar))))))

      (test "switch (x) {
case 1:
case 2:
    foo();
    break;
default:
    bar();
    break;
}
"
          (show #f (c-expr '(switch x ((1 2) (foo)) (default (bar))))))

      (test "switch (x) {
default:
    bar();
case 1:
case 2:
    foo();
    break;
}
"
          (show #f (c-expr '(switch x (else/fallthrough (bar)) ((1 2) (foo))))))

      (test "for (i = 0; i < n; i++) {
    printf(\"i: %d\");
}
"
          (show #f (c-for (c= 'i 0) (c< 'i 'n) (c++/post 'i) '(printf "i: %d"))))

      (test "a * x + b * y == c;\n"
          (show #f (c== (c+ (c* 'a 'x) (c* 'b 'y)) 'c)))
      (test "a * x + b * y == c;\n"
          (show #f (c-expr '(== (+ (* a x) (* b y)) c))))

      (test "(a + x) * (b + y) == c;\n"
          (show #f (c-expr '(== (* (+ a x) (+ b y)) c))))

      (test "1 - (3 + 2);\n"
          (show #f (c-expr '(- 1 (+ 3 2)))))
      (test "1 - (3 - 2);\n"
          (show #f (c-expr '(- 1 (- 3 2)))))
      (test "1 - 3 - 2;\n"
          (show #f (c-expr '(- 1 3 2))))
      (test "1 + (3 + 2);\n"
          (show #f (c-expr '(+ 1 (+ 3 2)))))
      (test "1 + 3 + 2;\n"
          (show #f (c-expr '(+ 1 3 2))))

      (test "x == 0 && (y == 2 || y == 3);\n"
          (show #f (c-expr '(%and (== x 0) (%or (== y 2) (== y 3))))))

      (test
          "(abracadabra!!!! + xylophone????)
  * (bananarama____ + yellowstonepark~~~~)
  * (cryptoanalysis + zebramania);\n"
          (show #f (c-expr '(* (+ abracadabra!!!! xylophone????)
                               (+ bananarama____ yellowstonepark~~~~)
                               (+ cryptoanalysis zebramania)))))

      (test
          "abracadabra(xylophone,
            bananarama,
            yellowstonepark,
            cryptoanalysis,
            zebramania,
            delightful,
            wubbleflubbery);\n"
          (show #f (c-expr '(abracadabra xylophone
                                         bananarama
                                         yellowstonepark
                                         cryptoanalysis
                                         zebramania
                                         delightful
                                         wubbleflubbery))))

      (test "#define foo(x, y) ((x) + (y))\n"
          (show #f (cpp-define '(foo (int x) (int y)) (c+ 'x 'y))))

      (test "#define foo(x, y) (2 * ((x) + (y) + z))\n"
          (show #f (cpp-define '(foo (int x) (int y)) '(* 2 (+ x y z)))))

      (test "#define min(x, y) ((x) < (y) ? (x) : (y))\n"
          (show #f (cpp-define '(min x y) (c-if (c< 'x 'y) 'x 'y))))

      (test
          "#define foo(x, y) abracadabra((x) + (y),
                              xylophone,
                              bananarama,
                              yellowstonepark,
                              cryptoanalysis,
                              zebramania,
                              delightful,
                              wubbleflubbery)
"
          (show #f (cpp-define '(foo x y)
                               '(abracadabra (+ x y)
                                             xylophone
                                             bananarama
                                             yellowstonepark
                                             cryptoanalysis
                                             zebramania
                                             delightful
                                             wubbleflubbery))))

      (test "#ifndef FOO_H
#define FOO_H

extern int foo ();

#endif  /* ! FOO_H */
"
          (show #f (cpp-wrap-header
                    'FOO_H
                    (c-extern (c-prototype 'int 'foo '())))))

      (test "#if foo
1
#elif bar
2
#elif baz
3
#else 
4
#endif
"
          (show #f (cpp-if 'foo 1 'bar 2 'baz 3 4)))

      (test "/* this is a /\\* nested *\\/ comment */"
          (show #f (c-comment " this is a /* nested */ comment ")))

      (test "/* this is a /\\* nested *\\/ comment */"
          (show #f (c-comment " this is a " (c-comment " nested ") " comment ")))

      ;; the initial leading space is annoying but hard to remove at the
      ;; moment - the important thing is we preserve indentation in the body
      (test "switch (y) {
case 1:
    x = 1;
    break;
#ifdef H_TWO
case 2:
    x = 4;
    break;
#endif  /* H_TWO */
default:
    x = 5;
    break;
}
"
          (show #f (c-expr
                    `(switch y
                             ((1) (= x 1))
                             ,(cpp-ifdef 'H_TWO (c-case '(2) '(= x 4)))
                             (else (= x 5))))))

      (test "#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n"
          (show #f (c-expr '(%define (eprintf . args) (fprintf stderr args)))))

      (test "struct point {
    int x;
    int y;
};
"
          (show #f (c-expr `(struct point (x y)))))

      (test "struct employee {
    short age;
    char *name;
    struct {
        int year;
        int month;
        int day;
    } dob;
} __attribute__ ((packed));
"
          (show #f (c-expr `(struct employee
                                    ((short age)
                                     ((%pointer char) name)
                                     ((struct (year month day)) dob))
                                    (%attribute packed)
                                    ))))

      (test "class employee {
    short age;
    char *name;
    struct {
        int year;
        int month;
        int day;
    } dob;
} __attribute__ ((packed));
"
          (show #f (c-class 'employee
                            '((short age)
                              ((%pointer char) name)
                              ((struct (year month day)) dob))
                            (c-attribute 'packed)
                            )))

      (test "union object {
    char tag;
    struct {
        char tag;
        char *data;
    } string;
    struct {
        char tag;
        void *car;
        void *cdr;
    } pair;
    struct {
        char tag;
        unsigned int length;
        void *data;
    } vector;
};
"
          (show #f (c-expr
                    '(union object
                            ((char tag)
                             ((struct ((char tag) ((* char) data))) string)
                             ((struct ((char tag)
                                       ((* void) car)
                                       ((* void) cdr)))
                              pair)
                             ((struct ((char tag)
                                       ((unsigned int) length)
                                       ((* void) data)))
                              vector)
                             )))))

      (test "enum type_tags {
    TYPE_CHAR = 1,
    TYPE_FIXNUM,
    TYPE_BOOLEAN,
    TYPE_NULL,
    TYPE_EOF,
    TYPE_STRING,
    TYPE_PAIR,
    TYPE_VECTOR
};
"
          (show #f (c-expr '(enum type_tags ((TYPE_CHAR 1) TYPE_FIXNUM TYPE_BOOLEAN TYPE_NULL TYPE_EOF TYPE_STRING TYPE_PAIR TYPE_VECTOR)))))

      (test "#define OP_EVAL 0xFE\n" (show #f (with ((radix 16)) (cpp-define 'OP_EVAL 254))))

      (test "unsigned long table[SIZE] = {1, 2, 3, 4};\n"
          (show #f (c-var '(%array (unsigned long) SIZE) 'table '#(1 2 3 4))))

      (test "int *array_of_ptr[];\n"
          (show #f (c-var '(%array (* int)) 'array_of_ptr)))

      (test "int (*ptr_to_array)[];\n"
          (show #f (c-var '(* (%array int)) 'ptr_to_array)))

      (test "foo **table = {{1, \"foo\"}, {2, \"bar\"}, {3, \"baz\"}, {4, \"qux\"}};\n"
          (show #f (c-var '(* (* foo)) 'table
                          '#(#(1 "foo") #(2 "bar") #(3 "baz") #(4 "qux")))))

      (test "sexp (*f)(sexp, sexp) = NULL;\n"
          (show #f (c-var '(%fun sexp (sexp sexp)) 'f 'NULL)))

      (test "sexp (*)(sexp) (*f)(sexp, sexp) = NULL;\n"
          (show #f (c-var '(%fun (%fun sexp (sexp)) (sexp sexp)) 'f 'NULL)))

      (test "typedef double (*f)(double *, double, int);\n"
          (show #f (c-typedef '(%fun double ((* double) double int)) 'f)))

      (test "\"foo\\tbar\";\n"
          (show #f (c-expr "foo\tbar")))

      (test "static int i;\n"
          (show #f (c-expr '(static (%var int i)))))

      (test-end))))

(define-library (chibi show unicode) (alias-for (srfi 166 unicode)))

(define-library (chibi show pretty) (alias-for (srfi 166 pretty)))

(define-library (chibi show color) (alias-for (srfi 166 color)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; additional state information

(define-syntax define-state-variables
  (syntax-rules ()
    ((define-state-variables var ...)
     (begin
       (define var
         (make-state-variable 'var #f #f))
       ...))))

(define-state-variables
  expression? in-cond? in-macro? return? non-spaced-ops?
  braceless-bodies? newline-before-brace? no-wrap? macro-vars
  expr-writer switch-indent-space indent-space
  indent default-type dot op)

(define (c-in-expr proc) (with ((expression? #t)) (c-expr proc)))
(define (c-in-stmt proc) (with ((expression? #f)) (c-expr proc)))
(define (c-in-test proc) (with ((in-cond? #t)) (c-in-expr proc)))
(define (c-with-op new-op proc) (with ((op new-op)) proc))

(define nl-str (call-with-output-string newline))
(define (make-nl-space n) (string-append nl-str (make-string n #\space)))
(define (make-space n) (make-string n #\space))

(define (call-with-output-string proc)
  (let ((out (open-output-string)))
    (proc out)
    (let ((res (get-output-string out)))
      (close-output-port out)
      res)))

(define (display-to-string x)
  (if (string? x)
      x
      (call-with-output-string (lambda (out) (display x out)))))

(define (write-to-string x)
  (call-with-output-string (lambda (out) (write x out))))

(define (string-find/index str pred i)
  (string-cursor->index
   str
   (string-find str pred (string-index->cursor str i))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; be smart about operator precedence

(define (c-op-precedence x)
  (if (string? x)
      (cond
        ((or (string=? x ".") (string=? x "->")) 10)
        ((or (string=? x "++") (string=? x "--")) 20)
        ((string=? x "|") 65)
        ((string=? x "||") 75)
        ((string=? x "|=") 85)
        ((or (string=? x "+=") (string=? x "-=")) 85)
        (else (c-op-precedence (string->symbol x))))
      (case x
        ((zero) 0)
        ;;((|::|) 5)                    ; C++
        ((paren bracket) 5)
        ((dot arrow post-decrement post-increment) 10)
        ((**) 15)                       ; Perl
        ((unary+ unary- ! ~ cast unary-* unary-& sizeof) 20) ; ++ --
        ((=~ !~) 25)                    ; Perl
        ((* / %) 30)
        ((+ -) 35)
        ((<< >>) 40)
        ((< > <= >=) 45)
        ((lt gt le ge) 45)              ; Perl
        ((== !=) 50)
        ((eq ne cmp) 50)                ; Perl
        ((&) 55)
        ((^) 60)
        ;;((|\||) 65)                   ; SCSH
        ((&&) 70)
        ;;((|\|\||) 75)                 ; SCSH
        ;;((.. ...) 77)                 ; Perl
        ((? if) 80)
        ((= *= /= %= &= ^= <<= >>=) 85) ; |\|=| ;  += -=
        ((comma) 90)
        ((=>) 90)                       ; Perl
        ((not) 92)                      ; Perl
        ((and) 93)                      ; Perl
        ((or xor) 94)                   ; Perl
        (else 95))))

(define (c-op< x y) (< (c-op-precedence x) (c-op-precedence y)))
(define (c-op<= x y) (<= (c-op-precedence x) (c-op-precedence y)))

(define (c-paren x)
  (each "(" x ")"))

(define (c-maybe-paren x-op x)
  (fn ((orig-op op))
    (let ((x (with ((op x-op)) x)))
      (if (c-op<= orig-op x-op)
          (c-paren x)
          x))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; default literals writer

(define (c-control-operator? x)
  (memq x '(if while switch repeat do for fun begin)))

(define (c-literal? x)
  (or (number? x) (string? x) (char? x) (boolean? x)))

(define (char->c-char c)
  (string-append "'" (c-escape-char c #\') "'"))

(define (c-escape-char c quote-char)
  (let ((n (char->integer c)))
    (if (<= 32 n 126)
        (if (or (eqv? c quote-char) (eqv? c #\\))
            (string #\\ c)
            (string c))
        (case n
          ((7) "\\a") ((8) "\\b") ((9) "\\t") ((10) "\\n")
          ((11) "\\v") ((12) "\\f") ((13) "\\r")
          (else (string-append "\\x" (number->string (char->integer c) 16)))))))

(define (c-format-number x)
  (if (and (integer? x) (exact? x))
      (fn (radix)
        (case radix
          ((16) (each "0x" (string-upcase-ascii (number->string x 16))))
          ((8) (each "0" (number->string x 8)))
          (else (each (number->string x)))))
      (each (number->string x))))

(define (c-format-string s)
  (each "\"" (each-in-list (c-string-escaped s)) "\""))

(define (c-string-escaped s)
  (let ((start (string-cursor-start s)))
    (let lp ((parts '()) (i (string-cursor-end s)))
      (let ((j (string-find-right s c-needs-string-escape? start i)))
        (cond
         ((string-cursor>? j start)
          (lp (cons (c-escape-char (string-cursor-ref s (string-cursor-prev s j)) #\")
                    (cons (substring-cursor s j i) parts))
              (string-cursor-prev s j)))
         (else
          (cons (substring-cursor s start i) parts)))))))

(define (c-needs-string-escape? c)
  (if (<= 32 (char->integer c) 127) (memv c '(#\" #\\)) #t))

(define (c-simple-literal x)
  (c-wrap-stmt
   (cond ((char? x) (each (char->c-char x)))
         ((boolean? x) (each (if x "1" "0")))
         ((number? x) (c-format-number x))
         ((string? x) (c-format-string x))
         ((null? x) (each "NULL"))
         ((eof-object? x) (each "EOF"))
         (else (each (write-to-string x))))))

(define (c-literal x)
  (fn (op in-macro? macro-vars)
    (if (and in-macro? (memq x macro-vars))
        (c-paren (c-simple-literal x))
        (c-simple-literal x))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; default expression generator

(define (c-expr/sexp x)
  (cond
   ((procedure? x)
    x)
   ((pair? x)
    (case (car x)
      ((if) (apply c-if (cdr x)))
      ((for) (apply c-for (cdr x)))
      ((while) (apply c-while (cdr x)))
      ((switch) (apply c-switch (cdr x)))
      ((case) (apply c-case (cdr x)))
      ((case/fallthrough) (apply c-case/fallthrough (cdr x)))
      ((default) (apply c-default (cdr x)))
      ((break) c-break)
      ((continue) c-continue)
      ((return) (apply c-return (cdr x)))
      ((goto) (apply c-goto (cdr x)))
      ((typedef) (apply c-typedef (cdr x)))
      ((struct union class) (apply c-struct/aux x))
      ((enum) (apply c-enum (cdr x)))
      ((inline auto restrict register volatile extern static)
       (each (car x) " " (apply c-begin (cdr x))))
      ;; non C-keywords must have some character invalid in a C
      ;; identifier to avoid conflicts - by default we prefix %
      ((vector-ref)
       (c-wrap-stmt
        (each (c-expr (cadr x)) "[" (c-expr (caddr x)) "]")))
      ((vector-set!)
       (c= (c-in-expr
            (each (c-expr (cadr x)) "[" (c-expr (caddr x)) "]"))
           (c-expr (cadddr x))))
      ((extern/C) (apply c-extern/C (cdr x)))
      ((%apply) (apply c-apply (cdr x)))
      ((%define) (apply cpp-define (cdr x)))
      ((%include) (apply cpp-include (cdr x)))
      ((%fun %lambda) (apply c-fun (cdr x)))
      ((%cond)
       (let lp ((ls (cdr x)) (res '()))
         (if (null? ls)
             (apply c-if (reverse res))
             (lp (cdr ls)
                 (cons (if (pair? (cddar ls))
                           (apply c-begin (cdar ls))
                           (cadar ls))
                       (cons (caar ls) res))))))
      ((%prototype) (apply c-prototype (cdr x)))
      ((%var) (apply c-var (cdr x)))
      ((%begin) (apply c-begin (cdr x)))
      ((%attribute) (apply c-attribute (cdr x)))
      ((%line) (apply cpp-line (cdr x)))
      ((%pragma %error %warning)
       (apply cpp-generic (substring (symbol->string (car x)) 1) (cdr x)))
      ((%if %ifdef %ifndef %elif)
       (apply cpp-if/aux (substring (symbol->string (car x)) 1) (cdr x)))
      ((%endif) (apply cpp-endif (cdr x)))
      ((%block) (apply c-braced-block (cdr x)))
      ((%comment) (apply c-comment (cdr x)))
      ((:) (apply c-label (cdr x)))
      ((%cast) (apply c-cast (cdr x)))
      ((+ - & * / % ! ~ ^ && < > <= >= == != << >>
          = *= /= %= &= ^= >>= <<=)     ; |\|| |\|\|| |\|=|
       (apply c-op x))
      ((bitwise-and bit-and) (apply c-op '& (cdr x)))
      ((bitwise-ior bit-or) (apply c-op "|" (cdr x)))
      ((bitwise-xor bit-xor) (apply c-op '^ (cdr x)))
      ((bitwise-not bit-not) (apply c-op '~ (cdr x)))
      ((arithmetic-shift) (apply c-op '<< (cdr x)))
      ((bitwise-ior= bit-or=) (apply c-op "|=" (cdr x)))
      ((%and) (apply c-op "&&" (cdr x)))
      ((%or) (apply c-op "||" (cdr x)))
      ((%. %field) (apply c-op "." (cdr x)))
      ((%->) (apply c-op "->" (cdr x)))
      (else
       (cond
        ((eq? (car x) (string->symbol "."))
         (apply c-op "." (cdr x)))
        ((eq? (car x) (string->symbol "->"))
         (apply c-op "->" (cdr x)))
        ((eq? (car x) (string->symbol "++"))
         (apply c-op "++" (cdr x)))
        ((eq? (car x) (string->symbol "--"))
         (apply c-op "--" (cdr x)))
        ((eq? (car x) (string->symbol "+="))
         (apply c-op "+=" (cdr x)))
        ((eq? (car x) (string->symbol "-="))
         (apply c-op "-=" (cdr x)))
        (else (c-apply x))))))
   ((vector? x)
    (c-wrap-stmt
     (each "{" (joined c-expr (vector->list x) ", ") "}")))
   (else
    (c-literal x))))

(define (try-fitted2 proc fail)
  (fn (width (orig-output output))
    (let ((out (open-output-string)))
      (call-with-current-continuation
       (lambda (abort)
         ;; Modify output to accumulate to an output string port,
         ;; and escape immediately with failure if we exceed the
         ;; column width.
         (define (output* str)
           (fn (col)
             (let lp ((i 0) (col col))
               (let ((nli (string-find/index str #\newline i))
                     (len (string-length str)))
                 (if (< nli len)
                     (if (> (+ (- nli i) col) width)
                         (abort fail)
                         (lp (+ nli 1) 0))
                     (let ((col (+ (- len i) col)))
                       (cond
                        ((> col width)
                         (abort fail))
                        (else
                         (output-default str)))))))))
         (forked
          (with ((output output*)
                 (port out))
            proc)
          ;; fitted successfully
          (fn () (orig-output (get-output-string out)))))))))

(define (try-fitted proc . fail)
  (let lp ((proc proc) (ls fail))
    (if (null? ls)
        proc
        (try-fitted2 proc (lp (car ls) (cdr ls))))))

(define (c-apply ls)
  (c-wrap-stmt
   (with ((op 'comma))
     (each
      (c-expr (car ls))
      (let ((flat (with ((no-wrap? #t)) (joined c-expr (cdr ls) ", "))))
        (fn (no-wrap?)
          (if no-wrap?
              (c-paren flat)
              (c-paren
               (try-fitted
                flat
                (fn (col)
                  (let ((sep (string-append "," (make-nl-space col))))
                    (joined c-expr (cdr ls) sep))))))))))))

(define (c-expr x)
  (fn (expr-writer) ((or expr-writer c-expr/sexp) x)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; comments, with Emacs-friendly escaping of nested comments

(define (make-comment-writer output)
  (lambda (str)
    (let ((start (string-cursor-start str))
          (end (string-cursor-prev str (string-cursor-end str))))
      (let lp ((i start))
        (let ((j (string-find str #\/ i)))
          (cond
           ((string-cursor>? j end)
            (output (substring-cursor str i j)))
           (else
            (each
             (cond
              ((and (string-cursor>? j start)
                    (eqv? #\* (string-cursor-ref str (string-cursor-prev str j))))
               (each (output (substring-cursor str i j))
                     (output "\\/")))
              (else
               (output (substring-cursor str i (string-cursor-next str j)))))
             (if (and (string-cursor<? j end)
                      (eqv? #\* (string-cursor-ref str (string-cursor-next str j))))
                 (output "\\")
                 nothing)
             (lp (string-cursor-next str j))))))))))

(define (c-comment . args)
  (each "/*" (fn ((orig-output output))
               (with ((output (make-comment-writer orig-output)))
                 (each-in-list args)))
        "*/"))

(define (make-block-comment-writer)
  (lambda (str)
    (fn (col (orig-output output))
      (with ((output (make-comment-writer orig-output)))
        (let ((end (string-cursor-end str))
              (indent (string-append (make-nl-space (+ col 1)) "* ")))
          (let lp ((i (string-cursor-start str)))
            (let ((j (string-find str #\newline i)))
              (each indent (substring-cursor str i j))
              (if (string-cursor<? j end)
                  (lp (string-cursor-next str j))))))))))

(define (c-block-comment . args)
  (fn (col (row1 row))
    (let ((indent (c-indent-string col)))
      (each "/* "
            (with ((writer (make-block-comment-writer)))
              (each-in-list args))
            (fn ((row2 row))
              (cond
               ((= row1 row2) (displayed " */"))
               (else (each fl indent " */"))))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; preprocessor

(define (make-cpp-writer output)
  (lambda (str)
    (let ((lim (string-length str)))
      (let lp ((i 0))
        (let ((j (string-find str #\newline i)))
          (output (substring str i j))
          (cond
           ((< j lim)
            (output "\n")
            (lp (+ j 1)))))))))

(define (cpp-include file)
  (if (string? file)
      (each fl "#include " (written file) fl)
      (each fl "#include <" file ">" fl)))

(define (list-dot x)
  (cond ((pair? x) (list-dot (cdr x)))
        ((null? x) #f)
        (else x)))

(define (list-without-dot x)
  (let lp ((ls x) (res '()))
    (cond ((pair? ls) (lp (cdr ls) (cons (car ls) res)))
          (else (reverse res)))))

(define (replace-tree from to x)
  (let replace ((x x))
    (cond ((eq? x from) to)
          ((pair? x) (cons (replace (car x)) (replace (cdr x))))
          (else x))))

(define (cpp-define x . body)
  (define (name-of x) (c-expr (if (pair? x) (cadr x) x)))
  (fn ()
    (let* ((body (cond
                  ((and (pair? x) (list-dot x))
                   => (lambda (dot)
                        (if (eq? dot '...)
                            body
                            (replace-tree dot '__VA_ARGS__ body))))
                  (else body)))
           (tail
            (if (pair? body)
                (each " "
                      (fn (output)
                        (with ((writer (make-cpp-writer output))
                               (in-macro? (pair? x))
                               (macro-vars
                                (map (lambda (v) (if (pair? v) (cadr v) v))
                                     (if (pair? x)
                                         (list-without-dot x)
                                         (list x))))
                               (op 'zero))
                          (c-in-expr (apply c-begin body)))))
                "")))
      (c-in-expr
       (if (pair? x)
           (each fl "#define " (name-of (car x))
                 (c-paren
                  (joined/dot name-of
                              (lambda (dot) (displayed "..."))
                              (cdr x)
                              ", "))
                 tail fl)
           (each fl "#define " (c-expr x) tail fl))))))

(define (cpp-expr x)
  (if (or (symbol? x) (string? x)) (displayed x) (c-expr x)))

(define (cpp-if/aux name check . o)
  (let* ((pass (and (pair? o) (car o)))
         (comment
          (if (member name '("ifdef" "ifndef"))
              (each "  "
                    (c-comment
                     " " (if (equal? name "ifndef") "! " "")
                     check " "))
              ""))
         (endif (if pass (each fl "#endif" comment) ""))
         (tail (cond
                ((and (pair? o) (pair? (cdr o)))
                 (if (pair? (cddr o))
                     (apply cpp-elif (cdr o))
                     (each (cpp-else) (cadr o) endif)))
                (else endif))))
    (fn ()
      (each fl "#" name " " (cpp-expr check) fl
            (or pass "")
            tail fl))))

(define (cpp-if check . o)
  (apply cpp-if/aux "if" check o))
(define (cpp-ifdef check . o)
  (apply cpp-if/aux "ifdef" check o))
(define (cpp-ifndef check . o)
  (apply cpp-if/aux "ifndef" check o))
(define (cpp-elif check . o)
  (apply cpp-if/aux "elif" check o))
(define (cpp-else . o)
  (each fl "#else " (if (pair? o) (c-comment (car o)) "") fl))
(define (cpp-endif . o)
  (each fl "#endif " (if (pair? o) (c-comment (car o)) "") fl))

(define (cpp-wrap-header name . body)
  (let ((name name)) ; consider auto-mangling
    (cpp-ifndef name (c-begin (cpp-define name) nl (apply c-begin body) nl))))

(define (cpp-line num . o)
  (each fl "#line " num (if (pair? o) (each " " (car o)) "") fl))

(define (cpp-generic name . ls)
  (each fl "#" name (each-in-list ls) fl))

(define (cpp-undef . args) (apply cpp-generic "undef" args))
(define (cpp-pragma . args) (apply cpp-generic "pragma" args))
(define (cpp-error . args) (apply cpp-generic "error" args))
(define (cpp-warning . args) (apply cpp-generic "warning" args))

(define (cpp-stringify x)
  (each "#" x))

(define (cpp-sym-cat . args)
  (joined displayed args " ## "))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; general indentation and brace rules

(define (c-indent-string col . o)
  (make-space (max 0 (+ col (if (pair? o) (car o) 0)))))

;; (c-indent [offset])
(define (c-indent . o)
  (fn (col indent-space)
    (displayed
     (make-space (max 0 (+ (or indent-space 4)
                           (if (pair? o) (car o) 0)))))))

(define (c-indent/switch)
  (fn (col switch-indent-space)
    (displayed (make-space (max 0 (- (or switch-indent-space 0) col))))))

(define (c-open-brace)
  (fn (col newline-before-brace?)
    (if newline-before-brace?
        (each nl (c-indent-string col) "{" nl)
        (each " {" nl))))

(define (c-close-brace)
  (displayed "}"))

(define (c-wrap-stmt x)
  (fn (expression? return?)
    (if expression?
        (c-expr x)
        (each (if return? "return " "")
              (c-in-expr (c-expr x)) ";" nl))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; code blocks

(define (c-block . args)
  (apply c-block/aux 0 args))

(define (c-block/aux offset header body0 . body)
  (let ((inner (apply c-begin body0 body)))
    (if (or (pair? body)
            (not (or (c-literal? body0)
                     (and (pair? body0)
                          (not (c-control-operator? (car body0)))))))
        (c-braced-block/aux offset header inner)
        (fn (braceless-bodies?)
          (if braceless-bodies?
              (each header fl (c-indent offset) inner fl)
              (c-braced-block/aux offset header inner))))))

(define (c-braced-block . args)
  (fn (col) (apply c-braced-block/aux col args)))

(define (c-braced-block/aux offset header . body)
  (fn ()
    (each header (c-open-brace) (c-indent offset)
          (apply c-begin body) fl
          (c-indent-string offset)
          (c-close-brace))))

(define (c-begin . args)
  (apply c-begin/aux #f args))

(define (c-begin/aux ret? body0 . body)
  (if (null? body)
      (c-expr body0)
      (fn (col expression?)
        (if expression?
            (with ((no-wrap? #t))
               (joined c-expr (cons body0 body) ", "))
            (let ((sep (each fl (c-indent-string col))))
              (each
               (with ((return? #f))
                 (joined c-expr (cons body0 (drop-right body 1)) sep))
               sep
               (with ((return? ret?))
                 (c-expr (last body)))))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; data structures

(define (c-struct/aux type x . o)
  (let* ((name (if (null? o) (if (or (symbol? x) (string? x)) x #f) x))
         (body (if name (car o) x))
         (o (if (null? o) o (cdr o))))
    (c-wrap-stmt
     (each
      (c-braced-block
       (each type
             (if (and name (not (equal? name "")))
                 (each " " name)
                 nothing))
       (each
        (c-in-stmt
         (if (list? body)
             (apply c-begin (map c-wrap-stmt (map c-param body)))
             (c-wrap-stmt (c-expr body))))))
      (if (pair? o) (each " " (apply c-begin o)) nothing)))))

(define (c-struct . args) (apply c-struct/aux "struct" args))
(define (c-union . args) (apply c-struct/aux "union" args))
(define (c-class . args) (apply c-struct/aux "class" args))

(define (c-enum x . o)
  (define (c-enum-one x)
    (if (pair? x) (each (car x) " = " (c-expr (cadr x))) (displayed x)))
  (let* ((name (if (null? o) (if (or (symbol? x) (string? x)) x #f) x))
         (vals (if name (car o) x)))
    (fn (col indent-space)
      (let ((sep (each ",\n" (c-indent-string (+ col (or indent-space 4))))))
        (c-wrap-stmt
         (each
          (c-braced-block
           (if name (each "enum " name) (displayed "enum"))
           (joined c-enum-one vals sep))))))))

(define (c-attribute . args)
  (each "__attribute__ ((" (joined c-expr args ", ") "))"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; basic control structures

(define (c-while check . body)
  (each (c-block (each "while (" (c-in-test check) ")")
                 (c-in-stmt (apply c-begin body)))
        fl))

(define (c-for init check update . body)
  (each
   (c-block
    (c-in-expr
     (each "for (" (c-expr init) "; " (c-in-test check) "; "
          (c-expr update ) ")"))
    (c-in-stmt (apply c-begin body)))
   fl))

(define (c-param x)
  (cond
    ((procedure? x) x)
    ((pair? x) (c-type (car x) (cadr x)))
    (else (fn (default-type) (c-type (or default-type 'int) x)))))

(define (c-param-list ls)
  (c-in-expr (joined/dot c-param (fn (dot) (displayed "...")) ls ", ")))

(define (c-fun type name params . body)
  (each (c-block (c-in-expr (c-prototype type name params))
                (with ((return? (not (eq? 'void type))))
                  (c-in-stmt (apply c-begin body))))
       fl))

(define (c-prototype type name params . o)
  (c-wrap-stmt
   (each (c-type type) " " (c-expr name) " (" (c-param-list params) ")"
         (joined/prefix c-expr o " "))))

(define (c-static x) (each "static " (c-expr x)))
(define (c-const x) (each "const " (c-expr x)))
(define (c-restrict x) (each "restrict " (c-expr x)))
(define (c-volatile x) (each "volatile " (c-expr x)))
(define (c-auto x) (each "auto " (c-expr x)))
(define (c-inline x) (each "inline " (c-expr x)))
(define (c-extern x) (each "extern " (c-expr x)))
(define (c-extern/C . body)
  (each "extern \"C\" {" nl (apply c-begin body) nl "}" nl))

(define (c-type type . o)
  (let ((name (and (pair? o) (car o))))
    (cond
     ((pair? type)
      (case (car type)
        ((%fun)
         (each (c-type (cadr type) #f)
              " (*" (or name "") ")("
              (joined (lambda (x) (c-type x #f)) (caddr type) ", ") ")"))
        ((%array)
         (let ((name (each name "[" (if (pair? (cddr type))
                                       (c-expr (caddr type))
                                       "")
                          "]")))
           (c-type (cadr type) name)))
        ((%pointer *)
         (let ((name (each "*" (if name (c-expr name) ""))))
           (c-type (cadr type)
                   (if (and (pair? (cadr type)) (eq? '%array (caadr type)))
                       (c-paren name)
                       name))))
        ((enum) (apply c-enum name (cdr type)))
        ((struct union class)
         (each (apply c-struct/aux (car type) (cdr type)) " " name))
        (else (joined/last c-expr (lambda (x) (c-type x name)) type " "))))
     ((not type)
      (fn (default-type) (c-type (or default-type 'int) name)))
     (else
      (each (if (eq? '%pointer type) '* type) (if name (each " " name) ""))))))

(define (c-var type name . init)
  (c-wrap-stmt
   (if (pair? init)
       (each (c-type type name) " = " (c-expr (car init)))
       (c-type type (if (pair? name)
                        (joined c-expr name ", ")
                        (c-expr name))))))

(define (c-cast type expr)
  (each "(" (c-type type) ")" (c-expr expr)))

(define (c-typedef type alias . o)
  (c-wrap-stmt
   (each "typedef " (c-type type alias) (joined/prefix c-expr o " "))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Generalized IF: allows multiple tail forms for if/else if/.../else
;; blocks.  A final ELSE can be signified with a test of #t or 'else,
;; or by simply using an odd number of expressions (by which the
;; normal 2 or 3 clause IF forms are special cases).

(define (c-if/stmt c p . rest)
  (fn (col)
    (let lp ((c c) (p p) (ls rest))
      (if (or (eq? c 'else) (eq? c #t))
          (if (not (null? ls))
              (error "forms after else clause in IF" c p ls)
              (each (c-block/aux col " else" p) fl))
          (let ((tail (if (pair? ls)
                          (if (pair? (cdr ls))
                              (lp (car ls) (cadr ls) (cddr ls))
                              (lp 'else (car ls) '()))
                          fl)))
            (each (c-block/aux
                   col
                   (each (if (eq? ls rest) nothing " else ")
                         "if (" (c-in-test (c-expr c)) ")")
                   p)
                  tail))))))

(define (c-if/expr c p . rest)
  (let lp ((c c) (p p) (ls rest))
    (cond
     ((or (eq? c 'else) (eq? c #t))
      (if (not (null? ls))
          (error "forms after else clause in IF" c p ls)
          (c-expr p)))
     ((pair? ls)
      (c-maybe-paren
       '?
       (with ((op '?))
         (c-in-test (c-expr c))
         " ? " (c-expr p) " : "
         (if (pair? (cdr ls))
             (lp (car ls) (cadr ls) (cddr ls))
             (lp 'else (car ls) '())))))
     (else
      (c-or (c-in-test (c-expr c)) (c-expr p))))))

(define (c-if . args)
  (fn (expression?)
    (if expression?
        (apply c-if/expr args)
        (apply c-if/stmt args))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; switch statements, automatic break handling

(define (c-label name)
  (fn (col)
    (let ((indent (make-space (max 0 (- col 2)))))
      (each fl indent name ":" fl))))

(define c-break
  (c-wrap-stmt (displayed "break")))
(define c-continue
  (c-wrap-stmt (displayed "continue")))
(define (c-return . result)
  (if (pair? result)
      (c-wrap-stmt (each "return " (c-expr (car result))))
      (c-wrap-stmt (displayed "return"))))
(define (c-goto label)
  (c-wrap-stmt (each "goto " (c-expr label))))

(define (c-switch val . clauses)
  (fn (col)
    (let ((sep (each fl (c-indent-string col))))
      (each "switch (" (c-in-expr val) ")" (c-open-brace)
            (c-indent/switch)
            sep
            (joined c-in-stmt
                    (map (lambda (x) (c-switch-clause x col))
                         clauses)
                    sep)
            sep (c-close-brace) fl))))

(define (c-switch-clause/breaks x . o)
  (fn (col indent indent-space return?)
    (let* ((col (if (pair? o) (car o) col))
           (break?
            (and (car x)
                 (not (member (cadr x) '(case/fallthrough
                                         default/fallthrough
                                         else/fallthrough)))))
           (explicit-case? (member (cadr x) '(case case/fallthrough)))
           (indent-body (c-indent-string (+ col (or indent 4))))
           (indent (c-indent-string col))
           (sep (string-append ":" nl-str indent)))
      (each (c-in-expr
             (joined/suffix
              displayed
              (cond
               ((or explicit-case? (pair? (cadr x)))
                (map (lambda (y) (each "case " (c-expr y)))
                     (if explicit-case?
                         (if (list? (third x))
                             (third x)
                             (list (third x)))
                         (cadr x))))
               (else
                (list (each "default"))))
              sep))
            (make-space (or indent-space 4))
            (joined c-expr
                    (if explicit-case? (cdr (cddr x)) (cddr x))
                    indent-body)
            (if (and break? (not return?))
                (each fl indent-body c-break)
                "")))))

(define (c-switch-clause x . o)
  (if (procedure? x) x (apply c-switch-clause/breaks (cons #t x) o)))
(define (c-switch-clause/no-break x . o)
  (if (procedure? x) x (apply c-switch-clause/breaks (cons #f x) o)))

(define (c-case x . body)
  (c-switch-clause (cons (if (pair? x) x (list x)) body)))
(define (c-case/fallthrough x . body)
  (c-switch-clause/no-break (cons (if (pair? x) x (list x)) body)))
(define (c-default . body)
  (c-switch-clause/breaks (cons #t (cons 'else body))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; operators

(define (c-op op first . rest)
  (if (null? rest)
      (c-unary-op op first)
      (apply c-binary-op op first rest)))

(define (c-binary-op op . ls)
  (define (lit-op? x) (or (c-literal? x) (symbol? x)))
  (let ((str (display-to-string op)))
    (c-wrap-stmt
     (c-maybe-paren
      op
      (if (or (equal? str ".") (equal? str "->"))
          (joined c-expr ls str)
          (let ((flat
                 (with ((no-wrap? #t))
                   (fn (non-spaced-ops?)
                     (joined c-expr
                             ls
                             (if (and non-spaced-ops?
                                      (every lit-op? ls))
                                 str
                                 (string-append " " str " ")))))))
            (fn (no-wrap?)
              (if no-wrap?
                  flat
                  (try-fitted
                   flat
                   (fn (col)
                     (joined c-expr
                             ls
                             (each nl (make-space (+ 2 col)) str " ")
                             )))))))))))

(define (c-unary-op op x)
  (c-wrap-stmt
   (each (display-to-string op) (c-maybe-paren op (c-expr x)))))

;; some convenience definitions

(define (c++ . args) (apply c-op "++" args))
(define (c-- . args) (apply c-op "--" args))
(define (c+ . args) (apply c-op '+ args))
(define (c- . args) (apply c-op '- args))
(define (c* . args) (apply c-op '* args))
(define (c/ . args) (apply c-op '/ args))
(define (c% . args) (apply c-op '% args))
(define (c& . args) (apply c-op '& args))
;; (define (|c\|| . args) (apply c-op '|\|| args))
(define (c^ . args) (apply c-op '^ args))
(define (c~ . args) (apply c-op '~ args))
(define (c! . args) (apply c-op '! args))
(define (c&& . args) (apply c-op '&& args))
;; (define (|c\|\|| . args) (apply c-op '|\|\|| args))
(define (c<< . args) (apply c-op '<< args))
(define (c>> . args) (apply c-op '>> args))
(define (c== . args) (apply c-op '== args))
(define (c!= . args) (apply c-op '!= args))
(define (c< . args) (apply c-op '< args))
(define (c> . args) (apply c-op '> args))
(define (c<= . args) (apply c-op '<= args))
(define (c>= . args) (apply c-op '>= args))
(define (c= . args) (apply c-op '= args))
(define (c+= . args) (apply c-op "+=" args))
(define (c-= . args) (apply c-op "-=" args))
(define (c*= . args) (apply c-op '*= args))
(define (c/= . args) (apply c-op '/= args))
(define (c%= . args) (apply c-op '%= args))
(define (c&= . args) (apply c-op '&= args))
;; (define (|c\|=| . args) (apply c-op '|\|=| args))
(define (c^= . args) (apply c-op '^= args))
(define (c<<= . args) (apply c-op '<<= args))
(define (c>>= . args) (apply c-op '>>= args))

(define (c. . args) (apply c-op "." args))
(define (c-> . args) (apply c-op "->" args))

(define (c-bit-or . args) (apply c-op "|" args))
(define (c-or . args) (apply c-op "||" args))
(define (c-bit-or= . args) (apply c-op "|=" args))

(define (c++/post x)
  (each (c-maybe-paren 'post-increment (c-expr x)) "++"))
(define (c--/post x)
  (each (c-maybe-paren 'post-decrement (c-expr x)) "--"))

(define-library (chibi show column) (alias-for (srfi 166 columnar)))

(define-library (chibi show c)
  (export
   c-in-expr c-in-stmt c-in-test
   c-paren c-maybe-paren c-type c-literal? c-literal char->c-char
   c-struct c-union c-class c-enum c-typedef c-cast
   c-expr c-expr/sexp c-apply c-op c-indent c-indent-string
   c-wrap-stmt c-open-brace c-close-brace
   c-block c-braced-block c-begin
   c-fun c-var c-prototype c-param c-param-list
   c-while c-for c-if c-switch
   c-case c-case/fallthrough c-default
   c-break c-continue c-return c-goto c-label
   c-static c-const c-extern c-volatile c-auto c-restrict c-inline
   c++ c-- c+ c- c* c/ c% c& c^ c~ c! c&& c<< c>> c== c!= ;  |c\||  |c\|\||
   c< c> c<= c>= c= c+= c-= c*= c/= c%= c&= c^= c<<= c>>= ;++c --c ;  |c\|=|
   c++/post c--/post c. c->
   c-bit-or c-or c-bit-or=
   cpp-if cpp-ifdef cpp-ifndef cpp-elif cpp-endif cpp-undef
   cpp-include cpp-define cpp-wrap-header cpp-pragma cpp-line
   cpp-error cpp-warning cpp-stringify cpp-sym-cat
   c-comment c-block-comment c-attribute)
  (import (chibi) (chibi string) (chibi show) (chibi show pretty)
          (srfi 1) (scheme cxr))
  (include "c.scm"))

(define-library (chibi show base) (alias-for (srfi 166 base)))
    
;;; shared structure utilities

(define-library (chibi show shared)
  (import (scheme base) (scheme write) (srfi 69))
  (export
   extract-shared-objects call-with-shared-ref call-with-shared-ref/cdr)
  (begin
    (define (extract-shared-objects x cyclic-only?)
      (let ((seen (make-hash-table eq?)))
        ;; find shared references
        (let find ((x x))
          (cond ;; only interested in pairs and vectors (and records later)
           ((or (pair? x) (vector? x))
            ;; increment the count
            (hash-table-update!/default seen x (lambda (n) (+ n 1)) 0)
            ;; walk if this is the first time
            (cond
             ((> (hash-table-ref seen x) 1))
             ((pair? x)
              (find (car x))
              (find (cdr x)))
             ((vector? x)
              (do ((i 0 (+ i 1)))
                  ((= i (vector-length x)))
                (find (vector-ref x i)))))
            ;; delete if this shouldn't count as a shared reference
            (if (and cyclic-only? (<= (hash-table-ref/default seen x 0) 1))
                (hash-table-delete! seen x)))))
        ;; extract shared references
        (let ((res (make-hash-table eq?))
              (count 0))
          (hash-table-walk
           seen
           (lambda (k v)
             (cond
              ((> v 1)
               (hash-table-set! res k (cons count #f))
               (set! count (+ count 1))))))
          (cons res 0))))

    (define (gen-shared-ref cell shares)
      (set-car! cell (cdr shares))
      (set-cdr! cell #t)
      (set-cdr! shares (+ (cdr shares) 1))
      (string-append (number->string (car cell))))

    (define (call-with-shared-ref obj shares each proc)
      (let ((cell (hash-table-ref/default (car shares) obj #f)))
        (cond
         ((and (pair? cell) (cdr cell))
          (each "#" (number->string (car cell)) "#"))
         ((pair? cell)
          (each "#" (gen-shared-ref cell shares) "=" proc))
         (else
          (each proc)))))

    (define (call-with-shared-ref/cdr obj shares each proc . o)
      (let ((sep (if (pair? o) (car o) ""))
            (cell (hash-table-ref/default (car shares) obj #f)))
        (cond
         ((and (pair? cell) (cdr cell))
          (each sep ". #" (number->string (car cell)) "#"))
         ((pair? cell)
          (each sep ". #" (gen-shared-ref cell shares) "=(" proc ")"))
         (else
          (each sep proc)))))
    ))

(define (register-lambda-optimization! proc . o)
  (define (optimize ast)
    (match ast
      (($ Set ref value)
       (make-set ref (optimize value)))
      (($ Cnd test pass fail)
       (make-cnd (optimize test) (optimize pass) (optimize fail)))
      (($ Seq ls)
       (make-seq (map optimize ls)))
      (($ Lam name params body)
       (lambda-body-set! ast (optimize body))
       (proc ast))
      ((app ...)
       (map optimize app))
      (else
       ast)))
  (register-optimization! optimize (if (pair? o) (car o) 600)))

(define (replace-references ast name lam new)
  (let replace ((x ast))
    (match x
      (($ Ref _ (n . (? lambda? f)))
       (if (and (eq? n name) (eq? f lam))
           new
           x))
      (($ Set ref value)
       (make-set (replace ref) (replace value)))
      (($ Cnd test pass fail)
       (make-cnd (replace test) (replace pass) (replace fail)))
      (($ Seq ls)
       (make-seq (map replace ls)))
      (($ Lam name params body)
       (lambda-body-set! x (replace body))
       x)
      ((app ...)
       (map replace app))
      (else
       x))))

(define (join-seq a b)
  (make-seq (append (if (seq? a) (seq-ls a) (list a))
                    (if (seq? b) (seq-ls b) (list b)))))

(define (dotted-tail ls)
  (if (pair? ls) (dotted-tail (cdr ls)) ls))

(define (fold-every kons knil ls)
  (if (null? ls)
      knil
      (let ((knil (kons (car ls) knil)))
        (and knil (fold-every kons knil (cdr ls))))))

(define-library (chibi ast)
  (export
   analyze optimize env-cell ast->sexp macroexpand identifier-syntax
   type-of
   Object Input-Port Output-Port Opcode Procedure Bytecode Macro Env
   Number Bignum Flonum Integer Complex Char Boolean
   Symbol String Byte-Vector Vector Pair File-Descriptor
   Context Lam Cnd Set Set-Syn Ref Seq Lit Sc Exception Core
   syntactic-closure? lambda? cnd? set? ref? seq? lit? type? core?
   environment? bytecode? exception? macro? context? file-descriptor?
   syntactic-closure-expr syntactic-closure-env syntactic-closure-vars
   copy-lambda make-lambda make-cnd make-ref make-set make-seq make-lit
   make-macro
   lambda-name lambda-params lambda-body lambda-defs lambda-locals
   lambda-flags lambda-free-vars lambda-set-vars lambda-return-type
   lambda-param-types lambda-source
   lambda-name-set! lambda-params-set! lambda-body-set! lambda-defs-set!
   lambda-locals-set! lambda-flags-set! lambda-free-vars-set!
   lambda-set-vars-set! lambda-return-type-set! lambda-param-types-set!
   lambda-source-set!
   cnd-test cnd-pass cnd-fail
   cnd-test-set! cnd-pass-set! cnd-fail-set!
   set-var set-value set-var-set! set-value-set! set-source set-source-set!
   ref-name ref-cell ref-name-set! ref-cell-set!
   seq-ls seq-ls-set! lit-value lit-value-set!
   exception-kind exception-message exception-irritants exception-source
   opcode-name opcode-num-params opcode-return-type opcode-param-type
   opcode-class opcode-code opcode-data opcode-variadic? opcode?
   macro-procedure macro-env macro-source macro-aux macro-aux-set!
   procedure-code procedure-vars procedure-name procedure-name-set!
   procedure-arity procedure-variadic? procedure-variable-transformer?
   procedure-flags make-variable-transformer make-procedure procedure?
   bytecode-name bytecode-literals bytecode-source
   port-line port-line-set! port-source? port-source?-set!
   extend-env env-parent env-parent-set! env-lambda env-lambda-set!
   env-define! env-push! env-syntactic? env-syntactic?-set! core-code
   type-name type-cpl type-parent type-slots type-num-slots
   type-printer type-printer-set!
   object-size object->integer integer->immediate gc gc-usecs gc-count
   atomically thread-list abort
   string-contains string-cursor-copy! errno integer->error-string
   flatten-dot update-free-vars! setenv unsetenv safe-setenv
   immutable? immutable-string make-immutable!
   thread-interrupt!
   chibi-version)
  (import (chibi))
  (include-shared "ast")
  (include "ast.scm"))

(define-library (chibi match)
  (export match match-lambda match-lambda* match-let match-letrec match-let*)
  (cond-expand
   (chibi (import (chibi)))
   (else (import (scheme base))))
  (include "match/match.scm"))

;;> Cycle-aware equality.  Returns \scheme{#t} iff \scheme{a} and
;;> \scheme{b} are \scheme{equal?}, including cycles.  Another way
;;> to think of it is they are \scheme{equiv} if they print the
;;> same, assuming all elements can be printed.

(define (equiv? a b)
  (let ((equivs (make-hash-table eq?)))
    (define (get-equivs x)
      (or (hash-table-ref/default equivs x #f)
          (let ((tmp (make-hash-table eq?)))
            (hash-table-set! equivs x tmp)
            tmp)))
    (define (merge! tab x)
      (hash-table-set! tab x tab)
      (cond ((hash-table-ref/default equivs x #f)
             => (lambda (tab2)
                  (hash-table-walk tab2 (lambda (key value)
                                          (hash-table-set! tab key tab)))))))
    (define (equiv? a b)
      (cond
       ((eq? a b))
       ((pair? a)
        (and (pair? b)
             (let ((a-tab (get-equivs a)))
               (hash-table-ref
                a-tab
                b
                (lambda ()
                  (merge! a-tab b)
                  (and (equiv? (car a) (car b))
                       (equiv? (cdr a) (cdr b))))))))
       ((vector? a)
        (and (vector? b)
             (= (vector-length a) (vector-length b))
             (let ((a-tab (get-equivs a)))
               (hash-table-ref
                a-tab
                b
                (lambda ()
                  (merge! a-tab b)
                  (let lp ((i (- (vector-length a) 1)))
                    (or (< i 0)
                        (and (equiv? (vector-ref a i) (vector-ref b i))
                             (lp (- i 1))))))))))
       (else
        (equal? a b))))
    (let ((res (equal?/bounded a b 100000 100000)))
      (and res (or (> res 0) (equiv? a b)) #t))))
(define-library (chibi app-test)
  (import (scheme base) (chibi app) (chibi config) (chibi test))
  (export run-tests)
  (begin
    (define (feed cfg spec . args)
      (let ((animals (conf-get-list cfg 'animals '())))
        (cons (if (conf-get cfg 'lions) (cons 'lions animals) animals) args)))
    (define (wash cfg spec . args)
      (let ((animals (conf-get-list cfg 'animals '())))
        (cons (cons 'soap (conf-get cfg '(command wash soap))) animals)))
    (define zoo-app-spec
      `(zoo
        "Zookeeper Application"
        (@
         (animals (list symbol) "list of animals to act on (default all)")
         (lions boolean (#\l) "also apply the action to lions"))
        (or
         (feed "feed the animals" (,feed animals ...))
         (wash "wash the animals" (@ (soap boolean)) (,wash animals ...))
         (help "print help" (,app-help-command)))
        ))
    (define (run-tests)
      (test-begin "app")
      (test '((camel elephant) "today")
          (run-application
           zoo-app-spec
           '("zoo" "--animals" "camel,elephant" "feed" "today")))
      (test '((lions camel elephant) "tomorrow")
          (run-application
           zoo-app-spec
           '("zoo" "--animals" "camel,elephant" "--lions" "feed" "tomorrow")))
      (test '((soap . #f) rhino)
          (run-application zoo-app-spec '("zoo" "--animals" "rhino" "wash")))
      (test '((soap . #t) rhino)
          (run-application zoo-app-spec
                           '("zoo" "--animals" "rhino" "wash" "--soap")))
      (test '((soap . #t) rhino)
          (run-application zoo-app-spec
                           '("zoo" "wash" "--soap" "--animals" "rhino")))
      (test 'error
          (guard (exn (else 'error))
            (run-application zoo-app-spec
                           '("zoo" "--soap" "wash" "--animals" "rhino"))))
      (test-end))))
;; mime.scm -- RFC2045 MIME library
;; Copyright (c) 2005-2013 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

;;> A library to parse MIME headers and bodies into SXML.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define mime-line-length-limit 4096)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; association lists

;;> \procedure{(assq-ref ls key [default])}
;;> Returns the \scheme{cdr} of the cell in \var{ls} whose
;;> \scheme{car} is \scheme{eq?} to \var{key}, or \var{default}
;;> if not found.  Useful for retrieving values associated with
;;> MIME headers.

(define (assq-ref ls key . o)
  (cond ((and (pair? ls) (pair? (car ls)) (assq key ls)) => cdr)
        (else (and (pair? o) (car o)))))

;; most of these are plain text for easier viewing in the browser
(define (mime-type-from-extension ext)
  (assq-ref
   '((c . "text/plain; charset=utf-8")
     (css . "text/css; charset=utf-8")
     (gif . "image/gif")
     (h . "text/plain; charset=utf-8")
     (htm . "text/html; charset=utf-8")
     (html . "text/html; charset=utf-8")
     (jpeg . "image/jpeg")
     (jpg . "image/jpeg")
     (js . "application/javascript; charset=utf-8")
     (json . "application/json; charset=utf-8")
     (md . "text/plain; charset=utf-8")
     (mp3 . "audio/mpeg")
     (org . "text/plain; charset=utf-8")
     (pdf . "application/pdf")
     (png . "image/png")
     (scm . "text/plain; charset=utf-8")
     (sld . "text/plain; charset=utf-8")
     (svg . "image/svg+xml")
     (txt . "text/plain; charset=utf-8"))
   (and (string? ext) (string->symbol ext))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; simple matching instead of regexps

(define (match-mbox-from-line line)
  (let ((len (string-length line)))
    (and (> len 5)
         (string=? (substring line 0 5) "From ")
         (let lp ((i 6))
           (cond
             ((= i len) (list (substring line 5 len) ""))
             ((memq (string-ref line i) '(#\space #\tab))
              (list (substring line 5 i) (substring line (+ i 1) len)))
             (else (lp (+ i 1))))))))

(define (string-scan-colon-or-maybe-equal str)
  (let ((len (string-length str)))
    (let lp ((i 0) (best #f))
      (if (= i len)
          best
          (let ((c (string-ref str i)))
            (cond ((or (char-alphabetic? c)
                       (char-numeric? c)
                       (memv c '(#\- #\_)))
                   (lp (+ i 1) best))
                  ((eq? c #\:)
                   (if (= i 0) #f i))
                  ((eqv? c #\=)
                   (lp (+ i 1) (or best i)))
                  (else
                   best)))))))

(define (string-skip-white-space str i)
  (let ((lim (string-length str)))
    (let lp ((i i))
      (cond ((>= i lim) lim)
            ((char-whitespace? (string-ref str i)) (lp (+ i 1)))
            (else i)))))

(define (match-mime-header-line line)
  (let ((i (string-scan-colon-or-maybe-equal line)))
    (and i
         (let ((j (string-skip-white-space line (+ i 1))))
           (list (string->symbol (string-downcase-ascii (substring line 0 i)))
                 (substring line j (string-length line)))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; dummy encoder

(define (ces-convert bv . o)
  (let ((enc (if (pair? o) (car o) "utf8")))
    ;; TODO: add conversion routines for non-utf8 encodings
    (utf8->string bv)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;> \section{RFC2822 Headers}

;;> \procedure{(mime-header-fold kons knil [source [limit [kons-from]]])}
;;>
;;> Performs a fold operation on the MIME headers of source which can be
;;> either a string or port, and defaults to current-input-port.  \var{kons}
;;> is called on the three values:
;;>    \scheme{(kons header value accumulator)}
;;> where accumulator begins with \var{knil}.  Neither the header nor the
;;> value are modified, except wrapped lines are handled for the value.
;;>
;;> The optional procedure \var{kons-from} is a procedure to be called when
;;> the first line of the headers is an "From <address> <date>" line, to
;;> enable this procedure to be used as-is on mbox files and the like.
;;> It defaults to \var{kons}, and if such a line is found the fold will begin
;;> with \scheme{(kons-from '%from <address> (kons-from '%date <date> knil))}.
;;>
;;> The optional \var{limit} gives a limit on the number of headers to read.

(define (mime-header-fold kons knil . o)
  (let ((src (and (pair? o) (car o)))
        (limit (and (pair? o) (pair? (cdr o)) (car (cdr o))))
        (kons-from (if (and (pair? o) (pair? (cdr o)) (pair? (cddr o))) (car (cddr o)) kons)))
    ((if (string? src) mime-header-fold-string mime-header-fold-port)
     kons knil (or src (current-input-port)) limit kons-from)))

(define (mime-header-fold-string kons knil str limit kons-from)
  (call-with-input-string str
    (lambda (in) (mime-header-fold-port kons knil in limit kons-from))))

(define (mime-header-fold-port kons knil port limit kons-from)
  (define (out line acc count)
    (cond
     ((or (and limit (> count limit)) (eof-object? line) (string=? line ""))
      acc)
     ((match-mime-header-line line)
      => (lambda (m) (in (car m) (list (cadr m)) acc (+ count 1))))
     (else
      ;;(warn "invalid header line: ~S\n" line)
      (out (read-line port mime-line-length-limit) acc (+ count 1)))))
  (define (in header value acc count)
    (let ((line (read-line port mime-line-length-limit)))
      (cond
       ((and limit (> count limit))
        acc)
       ((or (eof-object? line) (string=? line ""))
        (kons header (string-join (reverse value)) acc))
       ((char-whitespace? (string-ref line 0))
        (in header (cons line value) acc (+ count 1)))
       (else
        (out line
             (kons header (string-join (reverse value)) acc)
             (+ count 1))))))
  (let ((first-line (read-line port mime-line-length-limit)))
    (cond
     ((eof-object? first-line)
      knil)
     ((and kons-from (match-mbox-from-line first-line))
      => (lambda (m) ; special case check on first line for mbox files
           (out (read-line port mime-line-length-limit)
                (kons-from '%from (car m)
                           (kons-from '%date (cadr m) knil))
                0)))
     (else
      (out first-line knil 0)))))

;;> \procedure{(mime-headers->list [source])}
;;> Return an alist of the MIME headers from source with headers all
;;> downcased.

(define (mime-headers->list . o)
  (reverse
   (apply
    mime-header-fold
    (lambda (h v acc) (cons (cons h v) acc))
    '()
    o)))

(define (mime-split-name+value s)
  (let ((i (string-find s #\=))
        (start (string-cursor-start s))
        (end (string-cursor-end s)))
    (if (string-cursor<? i end)
        (cons (string->symbol
               (string-downcase-ascii
                (string-trim (substring-cursor s start i))))
              (if (string-cursor=? (string-cursor-next s i) end)
                  ""
                  (if (eqv? #\" (string-cursor-ref s (string-cursor-next s i)))
                      (substring-cursor s
                                        (string-cursor-forward s i 2)
                                        (string-cursor-prev s end))
                      (substring-cursor s (string-cursor-next s i) end))))
        (cons (string->symbol (string-downcase-ascii (string-trim s))) ""))))

;;> \procedure{(mime-parse-content-type str)}
;;> Parses \var{str} as a Content-Type style-value returning the list
;;> \scheme{(type (attr . val) ...)}.

;;> \example{
;;> (mime-parse-content-type "text/html; CHARSET=UTF-8; filename=index.html")
;;> }

(define (mime-parse-content-type str)
  (let ((res (map mime-split-name+value
                  (string-split str (lambda (ch)
                                      (or (eqv? ch #\;) (eqv? ch #\,)))))))
    (if (and (pair? res) (pair? (car res)) (equal? "" (cdar res)))
        (cons (caar res) (cdr res))
        res)))

;;> \procedure{(mime-decode-header str)}
;;> Replace all occurrences of RFC1522 =?ENC?...?= escapes in \var{str} with
;;> the appropriate decoded and charset converted value.

(define (mime-decode-header str)
  (let* ((end (string-cursor-end str))
         ;; need at least 8 chars: "=?Q?X??="
         (limit (string-cursor-back end 8))
         (start (string-cursor-start str)))
    (let lp ((i start) (from start) (res '()))
      (cond
       ((string-cursor>=? i limit)
        (string-join (reverse (cons (substring-cursor str from end) res))))
       ((and (eqv? #\= (string-cursor-ref str i))
             (eqv? #\? (string-cursor-ref str (string-cursor-next str i))))
        (let* ((j (string-find str #\? (string-cursor-forward str i 3)))
               (k (string-find str #\? (string-cursor-forward str j 3))))
          (if (and j k (string-cursor<? (string-cursor-next str k) end)
                   (eqv? #\?
                         (string-cursor-ref str
                                            (string-cursor-forward str j 2)))
                   (memq (string-cursor-ref str (string-cursor-next str j))
                         '(#\Q #\B #\q #\b))
                   (eqv? #\=
                         (string-cursor-ref str (string-cursor-next str k))))
              (let ((decode
                     (if (memq (string-cursor-ref str
                                                  (string-cursor-next str j))
                               '(#\Q #\q))
                         quoted-printable-decode-string
                         base64-decode-string))
                    (cset
                     (substring-cursor str (string-cursor-forward str i 2) j))
                    (content
                     (substring-cursor str (string-cursor-forward str j 3) k))
                    (k2 (string-cursor-forward k 2)))
                (lp k2 k2 (cons (ces-convert (decode content) cset)
                                (cons (substring-cursor str from i) res))))
              (lp (string-cursor-forward str i 2) from res))))
       (else
        (lp (string-cursor-forward str i 1) from res))))))

;;> Write out an alist of headers in mime format.

(define (mime-write-headers headers out)
  (for-each
   (lambda (h)
     (write-string (car h) out) (write-string ": " out)
     (write-string (cdr h) out) (write-string "\r\n" out))
   headers))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; message parsing

(define (read-line/binary in)
  (let ((out (open-output-bytevector)))
    (let lp ()
      (let ((ch (read-u8 in)))
        (cond ((eof-object? ch)
               (let ((res (get-output-bytevector out)))
                 (if (zero? (bytevector-length res))
                     ch
                     res)))
              ((eqv? ch 10)
               (get-output-bytevector out))
              (else
               (write-u8 ch out)
               (lp)))))))

(define (bv-length-before-cr bv)
  (let ((len (bytevector-length bv)))
    (if (and (> len 0) (= 13 (bytevector-u8-ref bv (- len 1))))
        (- len 1)
        len)))

(define (mime-read-to-boundary/binary port boundary next final)
  (let* ((boundary (if (string? boundary) (string->utf8 boundary) boundary))
         (boundary-cr (and boundary (bytevector-append boundary #u8(13))))
         (final-boundary
          (and boundary (bytevector-append boundary #u8(45 45))))
         (final-boundary-cr
          (and final-boundary (bytevector-append final-boundary #u8(13))))
         (out (open-output-bytevector)))
    (let lp ((prev #f))
      (let ((line (read-line/binary port)))
        (cond
         ((or (eof-object? line)
              (equal? line final-boundary)
              (equal? line final-boundary-cr))
          (if prev
              (write-bytevector prev out 0 (bv-length-before-cr prev)))
          (final (get-output-bytevector out)))
         ((or (equal? line boundary) (equal? line boundary-cr))
          (if prev
              (write-bytevector prev out 0 (bv-length-before-cr prev)))
          (next (get-output-bytevector out)))
         (else
          (cond (prev
                 (write-bytevector prev out)
                 (write-u8 10 out)))
          (lp line)))))))

(define (mime-read-to-boundary/text port boundary next final)
  (let ((final-boundary (and boundary (string-append boundary "--"))))
    (let lp ((res '()))
      (let ((line (read-line port mime-line-length-limit)))
        (cond
         ((or (eof-object? line) (equal? line final-boundary))
          (final (string-join (reverse res)
                              (call-with-output-string newline))))
         ((equal? line boundary)
          (next (string-join (reverse res)
                             (call-with-output-string newline))))
         (else
          (lp (cons line res))))))))

(define (mime-read-to-boundary port boundary next final)
  ((if (binary-port? port)
       mime-read-to-boundary/binary
       mime-read-to-boundary/text)
   port boundary next final))

(define (mime-convert-part part text? cte enc)
  (let ((res (cond
              ((and (string? cte) (string-ci=? cte "quoted-printable"))
               (if text?
                   (quoted-printable-decode-string part)
                   (quoted-printable-decode-bytevector
                    (if (string? part) (string->utf8 part) part))))
              ((and (string? cte) (string-ci=? cte "base64"))
               (if text?
                   (base64-decode-string part)
                   (base64-decode-bytevector
                    (if (string? part) (string->utf8 part) part))))
              ((and (not text?) (string? part))
               (string->utf8 part))
              (else
               part))))
    (cond
     ((and text? (bytevector? res)) (ces-convert res enc))
     (else res))))

(define (mime-read-part port type cte enc boundary next final)
  (let ((text? (and (symbol? type)
                    (string-prefix? "text/" (symbol->string type)))))
    (mime-read-to-boundary
     port boundary
     (lambda (x) (next (mime-convert-part x text? cte enc)))
     (lambda (x) (final (mime-convert-part x text? cte enc))))))

;;> \section{RFC2045 MIME Encoding}

;;> \procedure{(mime-message-fold src kons knil [down up headers])}
;;> Performs a tree fold operation on the given string or port
;;> \var{src} as a MIME body corresponding to the headers give in
;;> \var{headers}.  If \var{headers} are false or not provided they
;;> are first read from \var{src}.
;;>
;;> \var{kons} is called on the successive values:
;;>
;;> \schemeblock{(kons parent-headers part-headers part-body accumulator)}
;;>
;;> where \var{part-headers} are the headers for the given MIME part (the
;;> original headers for single-part MIME), \var{part-body} is the
;;> appropriately decoded and charset-converted body of the message,
;;> and the \var{accumulator} begins with \var{knil}.
;;>
;;> If a multipart body is found, then a tree fold is performed,
;;> calling \var{down} once to get a new accumulator to pass to
;;> \var{kons}, and \var{up} on the result when returning.  Their
;;> signatures are:
;;>
;;> \schemeblock{(down headers seed)}
;;> \schemeblock{(up headers parent-seed seed)}
;;>
;;> The default \var{down} simply returns null, and the default
;;> \var{up} wraps the seed in the following sxml:
;;>
;;> \schemeblock{
;;>  ((mime (@ headers ...)
;;>     seed ...)
;;>   parent-seed ...)
;;> }

(define (mime-message-fold src kons init-seed . o)
  (let ((port (if (string? src) (open-input-string src) src)))
    (let ((kons-down
           (or (and (pair? o) (car o)) (lambda (headers seed) '())))
          (kons-up
           (or (and (pair? o) (pair? (cdr o)) (car (cdr o)))
               (lambda (headers parent-seed seed)
                 `((mime (@ ,@headers)
                         ,@(if (pair? seed) (reverse seed) seed))
                   ,@parent-seed))))
          (headers
           (or (and (pair? o) (pair? (cdr o)) (pair? (cdr (cdr o)))
                    (car (cdr (cdr o))))
               (mime-headers->list port))))
      (let tfold ((parent-headers '())
                  (headers headers)
                  (seed init-seed)
                  (boundary #f)
                  (next (lambda (x) x))
                  (final (lambda (x) x)))
        (let* ((ctype (mime-parse-content-type
                       (assq-ref headers 'content-type "text/plain")))
               (type (car ctype))
               (enc (string-trim
                     (or (assq-ref ctype 'charset)
                         (assq-ref headers 'charset "ascii"))))
               (cte (string-trim
                     (or (assq-ref headers 'content-transfer-encoding)
                         (assq-ref headers 'encoding "7-bit")))))
          (cond
           ((and (symbol? type)
                 (string-prefix? "multipart/" (symbol->string type))
                 (assq-ref (cdr ctype) 'boundary))
            => (lambda (boundary2)
                 (let ((boundary2 (string-append "--" boundary2)))
                   ;; skip preamble
                   (mime-read-to-boundary port boundary2 (lambda (x) x) (lambda (x) x))
                   (let lp ((part-seed (kons-down headers seed)))
                     (let ((part-headers (mime-headers->list port)))
                       (flush-output-port (current-error-port))
                       (tfold headers part-headers
                              part-seed boundary2
                              lp
                              (lambda (x)
                                ;; skip epilogue
                                (if boundary
                                    (mime-read-to-boundary
                                     port boundary
                                     (lambda (x) x) (lambda (x) x)))
                                (next (kons-up headers seed x)))))))))
           (else
            (mime-read-part
             port type cte enc boundary
             (lambda (x) (next (kons parent-headers headers x seed)))
             (lambda (x) (final (kons parent-headers headers x seed)))))))))))

;;> \procedure{(mime-message->sxml [src [headers]])}
;;> 
;;> Parse the given source as a MIME message and return
;;> the result as an SXML object of the form:
;;> \scheme{(mime (@ (header . value) ...) parts ...)}.

(define (mime-message->sxml . o)
  (car
   (apply
    mime-message-fold
    (if (pair? o) (car o) (current-input-port))
    (lambda (parent-headers headers body seed)
      ;; Discard empty bodies.
      (if (and (equal? body "") (null? headers))
          seed
          `((mime (@ ,@headers) ,body) ,@seed)))
    '() #f #f (if (pair? o) (cdr o) '()))))
;; Copyright (c) 2011 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

;;> A high-level interface to stty and ioctl.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; symbolic representation of attributes

(define stty-lookup (make-hash-table eq?))

(for-each
 (lambda (c) (hash-table-set! stty-lookup (car c) (cdr c)))

 ;; ripped from the stty man page, then trimmed down to what seemed
 ;; available on most systems

 `(;; characters
   ;;(dsusp    char     ,VDSUSP)   ; CHAR will send a terminal stop signal
   (eof      char     ,VEOF)     ; CHAR will send an EOF (terminate input)
   (eol      char     ,VEOL)     ; CHAR will end the line
   (eol2     char     ,VEOL2)    ; alternate CHAR for ending the line
   (erase    char     ,VERASE)   ; CHAR will erase the last character typed
   (intr     char     ,VINTR)    ; CHAR will send an interrupt signal
   (kill     char     ,VKILL)    ; CHAR will erase the current line
   (lnext    char     ,VLNEXT)   ; CHAR will enter the next character quoted
   (quit     char     ,VQUIT)    ; CHAR will send a quit signal
   (rprnt    char     ,VREPRINT) ; CHAR will redraw the current line
   (start    char     ,VSTART)   ; CHAR will restart output after stopping it
   (stop     char     ,VSTOP)    ; CHAR will stop the output
   (susp     char     ,VSUSP)    ; CHAR will send a terminal stop signal
   (werase   char     ,VWERASE)  ; CHAR will erase the last word typed

   ;; special settings
   (cols     special  #f) ; tell the kernel that the terminal has N columns
   (columns  special  #f) ; same as cols N
   (ispeed   special  #f) ; set the input speed to N
   (line     special  #f) ; use line discipline N
   (min      special  #f) ; with -icanon, set N characters minimum for a completed read
   (ospeed   special  #f) ; set the output speed to N
   (rows     special  #f) ; tell the kernel that the terminal has N rows
   (size     special  #f) ; print the number of rows and columns according to the kernel
   (speed    special  #f) ; print the terminal speed
   (time     special  #f) ; with -icanon, set read timeout of N tenths of a second

   ;; control settings
   (clocal   control  ,CLOCAL)  ; disable modem control signals
   (cread    control  ,CREAD)   ; allow input to be received
   (crtscts  control  ,CRTSCTS) ; enable RTS/CTS handshaking
   (cs5      control  ,CS5)     ; set character size to 5 bits
   (cs6      control  ,CS6)     ; set character size to 6 bits
   (cs7      control  ,CS7)     ; set character size to 7 bits
   (cs8      control  ,CS8)     ; set character size to 8 bits
   (cstopb   control  ,CSTOPB)  ; use two stop bits per character (one with `-')
   (hup      control  ,HUPCL)   ; send a hangup signal when the last process closes the tty
   (hupcl    control  ,HUPCL)   ; same as [-]hup
   (parenb   control  ,PARENB)  ; generate parity bit in output and expect parity bit in input
   (parodd   control  ,PARODD)  ; set odd parity (even with `-')

   ;; input settings
   (brkint   input    ,BRKINT)  ; breaks cause an interrupt signal
   (icrnl    input    ,ICRNL)   ; translate carriage return to newline
   (ignbrk   input    ,IGNBRK)  ; ignore break characters
   (igncr    input    ,IGNCR)   ; ignore carriage return
   (ignpar   input    ,IGNPAR)  ; ignore characters with parity errors
   (imaxbel  input    ,IMAXBEL) ; * beep and do not flush a full input buffer on a character
   (inlcr    input    ,INLCR)   ; translate newline to carriage return
   (inpck    input    ,INPCK)   ; enable input parity checking
   (istrip   input    ,ISTRIP)  ; clear high (8th) bit of input characters
   ;;(iuclc    input    ,IUCLC)   ; * translate uppercase characters to lowercase
   (ixany    input    ,IXANY)   ; * let any character restart output, not only start character
   (ixoff    input    ,IXOFF)   ; enable sending of start/stop characters
   (ixon     input    ,IXON)    ; enable XON/XOFF flow control
   (parmrk   input    ,PARMRK)  ; mark parity errors (with a 255-0-character sequence)
   (tandem   input    ,IXOFF)   ; same as [-]ixoff

   ;; output settings
   ;;(bs0      output   ,BS0) ; backspace delay style, N in [0..1]
   ;;(bs1      output   ,BS1) ; backspace delay style, N in [0..1]
   ;;(cr0      output   ,CR0) ; carriage return delay style, N in [0..3]
   ;;(cr1      output   ,CR1) ; carriage return delay style, N in [0..3]
   ;;(cr2      output   ,CR2) ; carriage return delay style, N in [0..3]
   ;;(cr3      output   ,CR3) ; carriage return delay style, N in [0..3]
   ;;(ff0      output   ,FF0) ; form feed delay style, N in [0..1]
   ;;(ff1      output   ,FF1) ; form feed delay style, N in [0..1]
   ;;(nl0      output   ,NL0) ; newline delay style, N in [0..1]
   ;;(nl1      output   ,NL1) ; newline delay style, N in [0..1]
   (ocrnl    output   ,OCRNL) ; translate carriage return to newline
   ;;(ofdel    output   ,OFDEL) ; use delete characters for fill instead of null characters
   ;;(ofill    output   ,OFILL) ; use fill (padding) characters instead of timing for delays
   ;;(olcuc    output   ,OLCUC) ; translate lowercase characters to uppercase
   (onlcr    output   ,ONLCR) ; translate newline to carriage return-newline
   (onlret   output   ,ONLRET) ; newline performs a carriage return
   (onocr    output   ,ONOCR) ; do not print carriage returns in the first column
   (opost    output   ,OPOST) ; postprocess output
   (tab0     output   #f) ; horizontal tab delay style, N in [0..3]
   (tab1     output   #f) ; horizontal tab delay style, N in [0..3]
   (tab2     output   #f) ; horizontal tab delay style, N in [0..3]
   (tab3     output   #f) ; horizontal tab delay style, N in [0..3]
   (tabs     output   #f) ; same as tab0
   ;;(-tabs    output   #f) ; same as tab3
   ;;(vt0      output   ,VT0) ; vertical tab delay style, N in [0..1]
   ;;(vt1      output   ,VT1) ; vertical tab delay style, N in [0..1]

   ;; local settings
   (crterase local    ,ECHOE)   ; echo erase characters as backspace-space-backspace
   (crtkill  local    ,ECHOKE)  ; kill all line by obeying the echoprt and echoe settings
   ;;(-crtkill local    #f) ; kill all line by obeying the echoctl and echok settings
   (ctlecho  local    ,ECHOCTL) ; echo control characters in hat notation (`^c')
   (echo     local    ,ECHO)    ; echo input characters
   (echoctl  local    ,ECHOCTL) ; same as [-]ctlecho
   (echoe    local    ,ECHOE)   ; same as [-]crterase
   ;;(echok    local    ,ECHOK)   ; echo a newline after a kill character
   (echoke   local    ,ECHOKE)  ; same as [-]crtkill
   (echonl   local    ,ECHONL)  ; echo newline even if not echoing other characters
   ;;(echoprt  local    ,ECHOPRT) ; echo erased characters backward, between `\' and '/'
   (icanon   local    ,ICANON)  ; enable erase, kill, werase, and rprnt special characters
   ;;(iexten   local    ,IEXTEN)  ; enable non-POSIX special characters
   (isig     local    ,ISIG)    ; enable interrupt, quit, and suspend special characters
   (noflsh   local    ,NOFLSH)  ; disable flushing after interrupt and quit special characters
   ;;(prterase local    ,ECHOPRT) ; same as [-]echoprt
   (tostop   local    ,TOSTOP)  ; stop background jobs that try to write to the terminal
   ;;(xcase    local    ,XCASE)   ; with icanon, escape with `\' for uppercase characters

   ;; combination settings
   (LCASE    combine  (lcase))
   (cbreak   combine  (not icanon))
   (cooked   combine  (brkint ignpar istrip icrnl ixon opost isig icanon))
                                        ; also eof and eol characters
                                        ; to their default values
   (crt      combine  (echoe echoctl echoke))
   (dec      combine  (echoe echoctl echoke (not ixany)))
                                        ; also intr ^c erase 0177 kill ^u
   (decctlq  combine  (ixany))
   (ek       combine  ()) ; erase and kill characters to their default values
   (evenp    combine  (parenb (not parodd) cs7))
   ;;(-evenp combine  #f) ; same as -parenb cs8
   (lcase    combine  (xcase iuclc olcuc))
   (litout   combine  (cs8 (not parenb istrip opost)))
   ;;(-litout  combine  #f) ; same as parenb istrip opost cs7
   (nl       combine  (not icrnl onlcr))
   ;;(-nl      combine  #f) ; same as icrnl -inlcr -igncr onlcr -ocrnl -onlret
   (oddp     combine  (parenb parodd cs7))
   (parity   combine  (evenp)) ; same as [-]evenp
   (pass8    combine  (cs8 (not parenb istrip)))
   ;;(-pass8   combine  #f) ; same as parenb istrip cs7
   (raw      combine  (not ignbrk brkint ignpar parmrk
                           inpck istrip inlcr igncr icrnl))
   ;;(ixon     combine  (ixoff ixany imaxbel opost isig icanon)) ;; xcase iuclc
   ;;(time     combine  #f) ; 0
   ;;(-raw     combine  #f) ; same as cooked
   (sane     combine  (cread brkint icrnl imaxbel opost onlcr
                       isig icanon ;; nl0 cr0 bs0 vt0 ff0 ; tab0
                       echo echoe echoctl echoke ;; iexten echok
                       (not ignbrk igncr ixoff ixany inlcr ;; iuclc
                            ocrnl onocr onlret ;; olcuc ofill ofdel
                            echonl noflsh tostop echoprt))) ;; xcase
                                        ; plus all special characters to
                                        ; their default values
   ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; high-level interface

;;> \subsubsubsection{\scheme{(stty [port] args ...)}}

;;> Set the terminal attributes for \var{port} (default
;;> \scheme{(current-output-port)}) to \var{attrs}.
;;> Attributes are specified symbolically using the
;;> names from the \rawcode{stty(1)} command.  In addition,
;;> (not args ...) may be used to negate the listed symbols.

(define (stty . args)
  (let* ((port (if (and (pair? args) (port? (car args)))
                   (car args)
                   (current-output-port)))
         (attr (get-terminal-attributes port)))
    ;; parse change requests
    (let lp ((lst (if (and (pair? args) (port? (car args))) (cdr args) args))
             (iflag (term-attrs-iflag attr))
             (oflag (term-attrs-oflag attr))
             (cflag (term-attrs-cflag attr))
             (lflag (term-attrs-lflag attr))
             (invert? #f)
             (return (lambda (iflag oflag cflag lflag)
                       (term-attrs-iflag-set! attr iflag)
                       (term-attrs-oflag-set! attr oflag)
                       (term-attrs-cflag-set! attr cflag)
                       (term-attrs-lflag-set! attr lflag)
                       (set-terminal-attributes! port TCSANOW attr))))
      (define (join old new)
        (if invert? (bitwise-and old (bitwise-not new)) (bitwise-ior old new)))
      (cond
       ((pair? lst)
        (let ((command (car lst)))
          (cond
           ((pair? command) ;; recurse on sub-expr
            (lp command iflag oflag cflag lflag invert?
                (lambda (i o c l) (lp (cdr lst) i o c l invert? return))))
           ((eq? command 'not) ;; toggle current setting
            (lp (cdr lst) iflag oflag cflag lflag (not invert?) return))
           (else
            (let ((x (hash-table-ref/default stty-lookup command #f)))
              (case (and x (car x))
                ((input)
                 (lp (cdr lst) (join iflag (cadr x)) oflag cflag lflag invert? return))
                ((output)
                 (lp (cdr lst) iflag (join oflag (cadr x)) cflag lflag invert? return))
                ((control)
                 (lp (cdr lst) iflag oflag (join cflag (cadr x)) lflag invert? return))
                ((local)
                 (lp (cdr lst) iflag oflag cflag (join lflag (cadr x)) invert? return))
                ((char)
                 ;;(term-attrs-cc-set! attr (cadr x) (or (cadr lst) 0))
                 (lp (cddr lst) iflag oflag cflag lflag invert? return))
                ((combine)
                 (lp (cadr x) iflag oflag cflag lflag invert?
                     (lambda (i o c l) (lp (cdr lst) i o c l invert? return))))
                ((special)
                 (error "special settings not yet supported" command))
                (else
                 (error "unknown stty command" command))))))))
       (else
        (return iflag oflag cflag lflag))))))

;;> Run \var{thunk} with the \scheme{stty} \var{setting}s in effect
;;> during its dynamic extent, resetting the original settings
;;> when it returns.

(define (with-stty setting thunk . o)
  (let* ((port (if (pair? o) (car o) (current-input-port)))
         (orig-attrs (get-terminal-attributes port)))
    (cond
     (orig-attrs
      (dynamic-wind
        (lambda () (stty port setting))
        thunk
        (lambda () (set-terminal-attributes! port TCSANOW orig-attrs))))
     (else
      ;; No terminal attributes means this isn't a tty.
      (thunk)))))

;;> Run \var{thunk} with the "raw" (no canonical or echo) options
;;> needed for a terminal application.

(define (with-raw-io port thunk)
  (with-stty '(not icanon isig echo) thunk port))

;;> Returns the current terminal width in characters of \var{x},
;;> which must be a port or a file descriptor.

(define (get-terminal-width x)
  (let ((ws (ioctl x TIOCGWINSZ)))
    (and ws (winsize-col ws))))

;;> Returns the current terminal dimensions, as a list of character width
;;> and height, of \var{x}, which must be a port or a file descriptor.

(define (get-terminal-dimensions x)
  (let ((ws (ioctl x TIOCGWINSZ)))
    (and ws (list (winsize-col ws) (winsize-row ws)))))
;; Copyright (c) 2004-2015 Alex Shinn. All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

;;> A space efficient integer set (iset) implementation, optimized for
;;> minimal space usage and fast membership lookup.  General set
;;> operations are provided based on the character set operations
;;> found in SRFI-14.

(define-library (chibi iset)
  (import (scheme base)
          (chibi iset base)
          (chibi iset iterators)
          (chibi iset constructors))
  (export
   %make-iset make-iset iset? iset-contains? Integer-Set
   iset iset-copy list->iset list->iset!
   iset-adjoin iset-adjoin! iset-delete iset-delete!
   iset-union iset-union! iset-intersection iset-intersection!
   iset-difference iset-difference!
   iset-empty? iset-fold iset-fold-node iset-for-each iset-for-each-node
   iset-map iset->list iset-size iset= iset<= iset>=
   iset-cursor iset-cursor? iset-cursor-next iset-ref end-of-iset?
   iset-rank iset-select))
(define-library (chibi loop-test)
  (export run-tests)
  (import (chibi) (chibi loop) (only (chibi test) test-begin test test-end))
  (begin
    (define (flatten ls)
      (reverse
       (loop lp ((for x ls (in-list ls)) (with res '()))
         => res
         (if (pair? x)
             (lp (=> res (lp (=> ls x))))
             (lp (=> res (cons x res)))))))
    (define (run-tests)
      (test-begin "loops")

      (test
          "stepping"
          '(0 1 2)
        (loop lp ((with i 0 (+ i 1))
                  (with res '() (cons i res)))
          (if (= i 3)
              (reverse res)
              (lp))))

      (test
          "basic in-list"
          '(c b a)
        (let ((res '()))
          (loop ((for x (in-list '(a b c))))
            (set! res (cons x res)))
          res))

      (test
          "in-list with result"
          '(c b a)
        (loop ((for x (in-list '(a b c)))
               (with res '() (cons x res)))
          => res))

      (test
          "in-list with listing"
          '(a b c)
        (loop ((for x (in-list '(a b c))) (for res (listing x))) => res))

      (test
          "in-list with listing-reverse"
          '(c b a)
        (loop ((for x (in-list '(a b c))) (for res (listing-reverse x)))
          => res))

      (test
          "uneven length in-list's"
          '((a . 1) (b . 2) (c . 3))
        (loop ((for x (in-list '(a b c)))
               (for y (in-list '(1 2 3 4)))
               (for res (listing (cons x y))))
          => res))

      (test
          "in-lists"
          '((a 1) (b 2) (c 3))
        (loop ((for ls (in-lists '((a b c) (1 2 3))))
               (for res (listing ls)))
          => res))

      (test
          "flatten (recursion test)"
          '(1 2 3 4 5 6 7)
        (flatten '(1 (2) (3 (4 (5)) 6) 7)))

      (test
          "in-string"
          '(#\h #\e #\l #\l #\o)
        (loop ((for c (in-string "hello")) (for res (listing c))) => res))

      (test
          "in-string with start"
          '(#\l #\o)
        (let* ((s "hello")
               (start (string-index->cursor s 3)))
          (loop ((for c (in-string s start)) (for res (listing c))) => res)))

      (test
          "in-string with start and end"
          '(#\h #\e #\l #\l)
        (let* ((s "hello")
               (start (string-index->cursor s 0))
               (end (string-index->cursor s 4)))
          (loop ((for c (in-string s start end)) (for res (listing c)))
            => res)))

      (test
          "in-string-reverse"
          '(#\o #\l #\l #\e #\h)
        (loop ((for c (in-string-reverse "hello")) (for res (listing c)))
          => res))

      (test
          "in-vector"
          '(1 2 3)
        (loop ((for x (in-vector '#(1 2 3))) (for res (listing x)))
          => res))

      (test
          "in-vector-reverse"
          '(3 2 1)
        (loop ((for x (in-vector-reverse '#(1 2 3))) (for res (listing x)))
          => res))

      (test "up-from" '(5 6 7)
        (loop ((for i (up-from 5 (to 8)))
               (for res (listing i)))
          => res))

      (test "up-from by" '(5 10 15)
        (loop ((for i (up-from 5 (to 20) (by 5)))
               (for res (listing i)))
          => res))

      (test "up-from listing if" '(10 12 14 16 18)
        (loop ((for i (up-from 10 (to 20)))
               (for res (listing i (if (even? i)))))
          => res))

      (test "down-from" '(7 6 5)
        (loop ((for i (down-from 8 (to 5)))
               (for res (listing i)))
          => res))

      (test "down-from by" '(15 10 5)
        (loop ((for i (down-from 20 (to 5) (by 5)))
               (for res (listing i)))
          => res))

      (test "down-from listing if" '(18 16 14 12 10)
        (loop ((for i (down-from 20 (to 10)))
               (for res (listing i (if (even? i)))))
          => res))

      (test "appending" '(1 2 3 4 5 6 7 8 9)
        (loop ((for ls (in-list '((1 2 3) (4 5 6) (7 8 9))))
               (for res (appending ls)))
          => res))

      (test "appending-reverse" '(9 8 7 6 5 4 3 2 1)
        (loop ((for ls (in-list '((1 2 3) (4 5 6) (7 8 9))))
               (for res (appending-reverse ls)))
          => res))

      (test "while + up-from" '(5 6 7)
        (loop ((for i (up-from 5 (to 10)))
               (while (< i 8))
               (for res (listing i)))
          => res))

      (test "up-from by, open-ended" '(5 7 9)
        (loop ((for i (up-from 5 (by 2)))
               (while (< i 10))
               (for res (listing i)))
          => res))

      (test "up-from open-ended" '(5 6 7)
        (loop ((for i (up-from 5))
               (while (< i 8))
               (for res (listing i)))
          => res))

      (test "down-from by, open-ended" '(5 3 1)
        (loop ((for i (down-from 7 (by 2)))
               (until (< i 1))
               (for res (listing i)))
          => res))

      (test "down-from open-ended" '(4 3 2)
        (loop ((for i (down-from 5))
               (until (< i 2))
               (for res (listing i)))
          => res))

      (test '(1 4 9)
          (for ((i (in-list '(1 2 3)))
                (res (listing (* i i))))
               => res))

      (test-end))))

(define-library (chibi time)
  (export current-seconds get-time-of-day time
          seconds->time seconds->string time->seconds time->string
          make-timeval make-tm timeval-seconds timeval-microseconds
          timezone-offset timezone-dst-time
          time-second time-minute time-hour time-day time-month time-year
          time-day-of-week time-day-of-year time-dst?
          tm? timeval? timezone?)
  (cond-expand
   (solaris)
   (else
    (export time-offset time-timezone-name)))
  (cond-expand
   (emscripten)
   (else
    (export set-time-of-day!)))
  (cond-expand
   ((or bsd linux)
    (export rusage? resource-usage-time resource-usage-system-time
            resource-usage-max-rss resource-usage/self
            resource-usage/children get-resource-usage))
   (else))
  (cond-expand
   (chibi
    (import (chibi))
    (include-shared "time"))
   (else
    (import (scheme base) (scheme write) (scheme time)
            (rename (srfi 19) (time-second srfi-19:time-second)))
    (begin
      ;; a SRFI-19 `date' is a datetime, which in C is a tm (time) struct
      (define tm? date?)
      (define time-second date-second)
      (define time-minute date-minute)
      (define time-hour date-hour)
      (define time-day date-day)
      (define time-month date-month)
      (define (time-year x) (- (date-year x) 1900))
      (define time-day-of-week date-week-day)
      (define time-day-of-year date-year-day)
      (define (seconds->time seconds)
        (time-tai->date (make-time time-tai 0 (exact (round seconds)))))
      (define current-seconds current-second)
      (define (get-time-of-day)
        (list (current-time) time-utc))
      (define (timeval-seconds tv) (srfi-19:time-second tv))
      (define (timeval-microseconds tv) (/ (time-nanosecond tv) 1000)))))
  (begin
    (define (timeval->milliseconds tv)
      (quotient (+ (* 1000000 (timeval-seconds tv))
                   (timeval-microseconds tv))
                1000))
    (define (time* name thunk)
      (let* ((start (car (get-time-of-day)))
             (result (thunk))
             (end (car (get-time-of-day)))
             (msecs (- (timeval->milliseconds end)
                       (timeval->milliseconds start))))
        (display name (current-error-port))
        (display ": " (current-error-port))
        (display msecs (current-error-port))
        (display " ms\n" (current-error-port))
        result))
    (define-syntax time
      (syntax-rules ()
        ((time expr)
         (let ((out (open-output-string)))
           (write 'expr out)
           (time (get-output-string out) expr)))
        ((time name expr)
         (time* name (lambda () expr)))))))

(define-library (chibi diff-test)
  (import (scheme base) (chibi diff))
  (export run-tests)
  (cond-expand
   (chibi (import (chibi test)))
   (else
    (import (scheme write))
    ;; inline (chibi test) to avoid circular dependencies in snow
    ;; installations
    (begin
      (define-syntax test
        (syntax-rules ()
          ((test expect expr)
           (test 'expr expect expr))
          ((test name expect expr)
           (guard (exn (else (display "!\nERROR: ") (write name) (newline)
                             (write exn) (newline)))
             (let* ((res expr)
                    (pass? (equal? expect expr)))
               (display (if pass? "." "x"))
               (cond
                ((not pass?)
                 (display "\nFAIL: ") (write name) (newline))))))))
      (define (test-begin name)
        (display name))
      (define (test-end)
        (newline)))))
  (begin
    (define (run-tests)
      (test-begin "diff")
      (test '((#\A 1 0) (#\C 2 2))
          (lcs-with-positions '(#\G #\A #\C) '(#\A #\G #\C #\A #\T)))
      (test '(#\A #\C)
          (lcs '(#\G #\A #\C) '(#\A #\G #\C #\A #\T)))
      (test '((#\G #\A #\C) (#\A #\G #\C #\A #\T) ((#\A 1 0) (#\C 2 2)))
          (diff "GAC" "AGCAT" read-char))
      (test '((#\A #\G #\C #\A #\T) (#\A #\G #\C #\A #\T)
              ((#\A 0 0) (#\G 1 1) (#\C 2 2) (#\A 3 3) (#\T 4 4)))
          (diff "AGCAT" "AGCAT" read-char))
      (test '((#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9 #\.
               #\G #\A #\C #\. #\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9)
              (#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9 #\.
               #\A #\G #\C #\A #\T #\. #\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9)
              ((#\0 0 0) (#\1 1 1) (#\2 2 2) (#\3 3 3) (#\4 4 4) (#\5 5 5)
               (#\6 6 6) (#\7 7 7) (#\8 8 8) (#\9 9 9) (#\. 10 10)
               (#\A 12 11) (#\C 13 13)
               (#\. 14 16) (#\0 15 17) (#\1 16 18) (#\2 17 19) (#\3 18 20)
               (#\4 19 21) (#\5 20 22) (#\6 21 23) (#\7 22 24) (#\8 23 25)
               (#\9 24 26)))
          (diff "0123456789.GAC.0123456789"
                "0123456789.AGCAT.0123456789"
                read-char))
      (let ((d (diff "GAC" "AGCAT" read-char)))
        (test " G AC"
            (edits->string (car d) (car (cddr d)) 1))
        (test "A G C AT "
            (edits->string (cadr d) (car (cddr d)) 2))
        (test "\x1b;[31mG\x1b;[39mAC"
            (edits->string/color (car d) (car (cddr d)) 1))
        (test "A\x1b;[32mG\x1b;[39mC\x1b;[32mAT\x1b;[39m"
            (edits->string/color (cadr d) (car (cddr d)) 2)))
      (test-end))))
(define-library (chibi iset-test)
  (export run-tests)
  (import (scheme base) (scheme write)
          (except (srfi 1) make-list list-copy)
          (chibi iset) (chibi iset optimize)
          (chibi test))
  (begin
    (define (run-tests)
      (define (test-name iset op)
        (let ((out (open-output-string)))
          (let* ((ls (iset->list iset))
                 (ls (if (> (length ls) 10)
                         `(,@(take ls 5) ... ,@(take-right ls 5))
                         ls)))
            (write `(,(car op) (iset ,@ls) ,@(cdr op)) out)
            (get-output-string out))))

      (test-begin "iset")

      ;; Tests to perform repeated operations on an iset.  The first element
      ;; in each list is a list of integers to initialize the set `is', which
      ;; we generate and verify the size and round-trip list conversion.
      ;; Subsequent elements are abbreviated operations on is:
      ;;
      ;;   (+ a ...)     (iset-adjoin! a) ...
      ;;   (- a ...)     (iset-delete! a) ...
      ;;   (= a ...)     (test (list a ...) (iset->list is))
      ;;   (<= a ...)    (test-assert (iset<= is (iset a ...)))
      ;;   (? a ...)     (test-assert (iset-contains? is a)) ...
      ;;   (!? a ...)    (test-not (iset-contains? is a)) ...
      ;;   (u a ...)     (iset-union is (iset a ...))
      ;;   (u: a b)      (iset-union is (make-iset a b))
      ;;   (i a ...)     (iset-intersection is (iset a ...))
      ;;   (d a ...)     (iset-difference is (iset a ...))
      ;;   (m f)         (iset-map f is)
      ;;   (s size)      (test size (iset-size iset))
      ;;   (z [empty?])  (test empty? (iset-empty? iset))
      (let ((tests
             `(;; construction
               ((1 128 127))
               ((129 2 127))
               ((1 -128 -126))
               ((1 2 3 1000 1005))
               ((97308 97827 97845 97827))
               ((1 2 3 4 5 6 7 8))
               ((2 3 4 5 6 7 8))
               ((1 3 4 5 6 7 8))
               ((1 2 4 5 6 7 8))
               ((1 2 3 5 6 7 8))
               ((1 2 3 4 6 7 8))
               ((1 2 3 4 5 7 8))
               ((1 2 3 4 5 6 8))
               ((1 2 3 4 5 6 7))
               ;; ordering
               ((97) (<= 97 117))
               ((117) (<= 97 117))
               ;; individual elements
               (() (+ 99) (u 3 50) (? 99))
               (() (+ 1) (+ 1000) (+ -1000) (+ 3) (+ -1))
               ((0) (z #f) (- 0) (z))
               ((0 1 2) (- 1) (- 2) (? 0))
               ;; union
               ((17 29) (u 7 29))
               ((2 3 4) (u 1 2 3 4 5))
               ((1 2 3 4 5) (u 2 3 4))
               ((1 2 3 1000 2000) (u 1 4))
               ((1 3) (u 1 4) (= 1 3 4))
               ((1 3) (u 3 4) (= 1 3 4))
               ((1) (u 1 3) (= 1 3))
               ((3) (u 1 3) (= 1 3))
               ((1 4) (u 3 4 5) (= 1 3 4 5))
               ((1 2 3 4) (u 5 6 7 8) (= 1 2 3 4 5 6 7 8))
               ((1 3 4) (u 5 6 7 8) (= 1 3 4 5 6 7 8))
               ((1 2 4) (u 5 6 7 8) (= 1 2 4 5 6 7 8))
               ((1 2 3) (u 5 6 7 8) (= 1 2 3 5 6 7 8))
               ((1 2 3 4) (u 6 7 8) (= 1 2 3 4 6 7 8))
               ((1 2 3 4) (u 5 7 8) (= 1 2 3 4 5 7 8))
               ((1 2 3 4) (u 5 6 8) (= 1 2 3 4 5 6 8))
               ((1 2 3) (u 6 7 8) (= 1 2 3 6 7 8))
               ((1 3) (u 6 8) (= 1 3 6 8))
               ((1 2 3 4 1001 1002)
                (u 1003 1004 2001 2002 2003 2004)
                (= 1 2 3 4 1001 1002 1003 1004 2001 2002 2003 2004))
               ((1 2 4 1001 1002)
                (u 1003 1004 2001 2002 2003 2004)
                (= 1 2 4 1001 1002 1003 1004 2001 2002 2003 2004))
               ((1 2 3 4 1001 1002)
                (u 1004 2001 2002 2003 2004)
                (= 1 2 3 4 1001 1002 1004 2001 2002 2003 2004))
               ((1 2 3 4 1001 1002)
                (u 1003 1004 2001 2003 2004)
                (= 1 2 3 4 1001 1002 1003 1004 2001 2003 2004))
               (() (u: 349 680) (u: 682 685))
               (() (u: 64434 64449) (u: 65020 65021) (u #xFE62))
               (() (u: 716 747) (u: 750 1084))
               (() (u: 48 57) (u: 65 90) (u: 97 122) (u 45 46 95 126) (? 119))
               ;; intersection
               ((1 2 3 4 5) (i 1) (= 1))
               ((1 2 3 4 5) (i 1 2) (= 1 2))
               ((1 2 3 4 5) (i 1 2 3) (= 1 2 3))
               ((1 2 3 4 5) (i 2 3) (= 2 3))
               ((1 2 3 4 5) (i 2 3 4) (= 2 3 4))
               ((1 2 3 4 5) (i 5) (= 5))
               ((1 2 3 4 5) (i 4 5) (= 4 5))
               ((1 2 3 4 5) (i 1 2 3 4 5) (= 1 2 3 4 5))
               ((1 2 3 4 5) (i 0 1 5 6) (= 1 5))
               ((1 2 3 4 5 6 7 8) (i 1 2 3 4) (= 1 2 3 4))
               ((1 3 4 5 6 7 8) (i 1 3 4) (= 1 3 4))
               ((1 2 4 5 6 7 8) (i 1 2 4) (= 1 2 4))
               ((1 2 3 5 6 7 8) (i 1 2 3) (= 1 2 3))
               ((1 2 3 4 6 7 8) (i 1 2 3 4) (= 1 2 3 4))
               ((1 2 3 6 7 8) (i 1 2 3) (= 1 2 3))
               ((1 3 6 8) (i 1 3) (= 1 3))
               ((1 2 3 4 1001 1002 1003 1004 2001 2002 2003 2004)
                (i 0 1 2 3 4 10 1001 1002 3001)
                (= 1 2 3 4 1001 1002))
               ((1 2 4 1001 1002 1003 1004 2001 2002 2003 2004)
                (i 1 2 3 4 1001 1002)
                (= 1 2 4 1001 1002))
               ((1 2 3 4 1001 1002 1004 2001 2002 2003 2004)
                (i 1 2 3 4 1001 1003)
                (= 1 2 3 4 1001))
               ((1 2 3 4 1001 1002 1003 1004 2001 2003 2004)
                (i 1 2 3 4 1001 1004 1005 2000 2001)
                (= 1 2 3 4 1001 1004 2001))
               ((0 1 2 3 4 5 6 7 8 9
                 101 102 103 104 105
                 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009)
                (i 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120)
                (= 101 102 103 104 105))
               ;; difference
               ((1 2 3 4 5) (d 1) (!? 0) (? 2 3 4 5) (!? 6))
               ((1 2 3 4 5) (d 1 2) (!? 0) (? 3 4 5) (!? 6))
               ((1 2 3 4 5) (d 1 2 3) (!? 0) (? 4 4) (!? 6))
               ((1 2 3 4 5) (d 2 3) (!? 0) (? 1 4 5) (!? 6))
               ((1 2 3 4 5) (d 2 3 4) (!? 0) (? 1 5) (!? 6))
               ((1 2 3 4 5) (d 5) (!? 0) (? 1 2 3 4) (!? 6))
               ((1 2 3 4 5) (d 4 5) (!? 0) (? 1 2 3) (!? 6))
               ((1 2 3 4 5) (d 1 2 3 4 5) (z))
               ((1 2 3 4 5) (d 0 1 5 6) (? 2 3 4))
               ((1 2 3 4 5 6 7 8) (d 1 2 3 4) (= 5 6 7 8))
               ((1 3 4 5 6 7 8) (d 1 3 4) (= 5 6 7 8))
               ((1 2 4 5 6 7 8) (d 1 2 4) (= 5 6 7 8))
               ((1 2 3 5 6 7 8) (d 1 2 3) (= 5 6 7 8))
               ((1 2 3 4 6 7 8) (d 1 2 3 4) (= 6 7 8))
               ((1 2 3 4 5 7 8) (d 1 2 3 4) (= 5 7 8))
               ((1 2 3 4 5 6 8) (d 1 2 3 4) (= 5 6 8))
               ((1 2 3 6 7 8) (d 1 2 3) (= 6 7 8))
               ((1 3 6 8) (d 1 3) (= 6 8))
               ((1 2 3 4 1001 1002 1003 1004 2001 2002 2003 2004)
                (d 1 2 3 4 1001 1002)
                (= 1003 1004 2001 2002 2003 2004))
               ((1 2 4 1001 1002 1003 1004 2001 2002 2003 2004)
                (d 1 2 4 1001 1002)
                (= 1003 1004 2001 2002 2003 2004))
               ((1 2 3 4 1001 1002 1004 2001 2002 2003 2004)
                (d 1 2 3 4 1001 1002)
                (= 1004 2001 2002 2003 2004))
               ((1 2 3 4 1001 1002 1003 1004 2001 2003 2004)
                (d 1 2 3 4 1001 1002)
                (= 1003 1004 2001 2003 2004))
               ;; map
               ((1 2 3) (m ,(lambda (x) (+ x 1))) (= 2 3 4))
               )))
        (for-each
         (lambda (tst)
           (let* ((ls (car tst))
                  (is (list->iset ls))
                  (ls2 (delete-duplicates ls =)))
             ;; initial creation and sanity checks
             (test-assert (lset= equal? ls2 (iset->list is)))
             (test (length ls2) (iset-size is))
             (test-assert (let ((out (open-output-string)))
                            (display "init: " out)
                            (write ls out)
                            (get-output-string out))
               (every
                (lambda (x) (iset-contains? is x))
                ls))
             (test (iset-contains? is 42) (member 42 ls))
             ;; additional operations
             (for-each
              (lambda (op)
                (let ((name (test-name is op)))
                  (case (car op)
                    ((+)
                     (for-each
                      (lambda (x) (iset-adjoin! is x))
                      (cdr op))
                     (test-assert name (iset-contains? is (cadr op))))
                    ((-)
                     (for-each
                      (lambda (x) (iset-delete! is x))
                      (cdr op))
                     (test-assert name (not (iset-contains? is (cadr op)))))
                    ((=)
                     (test name (cdr op) (iset->list is))
                     (test-assert name (iset= (list->iset (cdr op)) is)))
                    ((<=)
                     (test-assert name (iset<= is (list->iset (cdr op)))))
                    ((?)
                     (test-assert name
                       (every (lambda (x) (iset-contains? is x)) (cdr op))))
                    ((!?)
                     (test-assert name
                       (every (lambda (x) (not (iset-contains? is x))) (cdr op))))
                    ((d)
                     (set! is (iset-difference is (list->iset (cdr op))))
                     (test-assert name
                       (every
                        (lambda (x) (not (iset-contains? is x)))
                        (cdr op))))
                    ((i) (set! is (iset-intersection is (list->iset (cdr op)))))
                    ((u u:)
                     (let ((arg (cond ((eq? 'u: (car op))
                                       (make-iset (cadr op) (car (cddr op))))
                                      ((iset? (cadr op)) (cadr op))
                                      (else (list->iset (cdr op))))))
                       (set! is (iset-union is arg)))
                     (test-assert name
                       (every (lambda (x)
                                (or (not (integer? x))
                                    (iset-contains? is x)))
                              (cdr op))))
                    ((m) (set! is (iset-map (cadr op) is)))
                    ((s) (test (iset-size is) (cadr op)))
                    ((z)
                     (test (iset-empty? is)
                         (if (pair? (cdr op)) (cadr op) #t)))
                    (else (error "unknown operation" (car op))))))
              (cdr tst))
             ;; optimization
             (let* ((is2 (iset-optimize is))
                    (is3 (iset-balance is))
                    (is4 (iset-balance is2)))
               (test-assert (iset= is is2))
               (test-assert (iset= is is3))
               (test-assert (iset= is is4)))))
         tests))

      (let ((a (%make-iset 65 90 #f #f (%make-iset 97 122 #f #f #f)))
            (b (list->iset '(45 46 95 126))))
        (test-assert (iset-contains? (iset-union a b) 119))
        (test-assert (iset-contains? (iset-union b a) 119)))

      (let* ((elts '(0 1 5 27 42 113 114 256))
             (is (list->iset elts)))
        (test (iota (length elts))
            (map (lambda (elt) (iset-rank is elt)) elts))
        (test elts
            (map (lambda (i) (iset-select is i)) (iota (length elts)))))

      (let* ((elts '(903 595 694 581 91 628 648 152 188 29 347 876 381 945 508 890 816 654 871 228 200 397 116 952 60 878 361 205 691 318 87 998 35 886 580 787 856 535 964 133 245 314 711 598 180 984 458 235 599 692 568 1 740 514 995 930 625 638 881 997 412 151 195 512 857 948 956 750 896 813 988 40 85 426 740 83 294 249 235 45 20 784 837 640 56 519 211 780 771 684 408 510 677 773 574 114 537 934 477 136))
             (is (list->iset elts)))
        (test elts
            (map (lambda (i) (iset-select is i))
                 (map (lambda (elt) (iset-rank is elt)) elts))))

      (test-end))))

(define-library (chibi io)
  (export read-string read-string! read-line write-line %%read-line
          port-fold port-fold-right port-map
          port->list port->string-list port->sexp-list
          port->string port->bytevector
          file->string file->bytevector
          file-position set-file-position! seek/set seek/cur seek/end
          make-custom-input-port make-custom-output-port
          make-custom-binary-input-port make-custom-binary-output-port
          make-null-output-port make-null-input-port
          make-broadcast-port make-concatenated-port
          make-generated-input-port make-generated-binary-input-port
          make-filtered-output-port make-filtered-input-port
          string-count-chars
          open-input-bytevector open-output-bytevector get-output-bytevector
          string->utf8 utf8->string
          write-string write-u8 read-u8 peek-u8 send-file
          is-a-socket?
          call-with-input-file call-with-output-file)
  (import (chibi) (chibi ast))
  (include-shared "io/io")
  (include "io/io.scm"))

;;> A cursor-oriented string library.  Provides efficient string
;;> utilities for implementations with or without fast random-access
;;> strings.

(define-library (chibi string)
  (export
   string-cursor?
   string-cursor-start string-cursor-end string-cursor-ref
   string-cursor<? string-cursor<=? string-cursor>? string-cursor>=?
   string-cursor=? string-cursor-next string-cursor-prev substring-cursor
   string-cursor->index string-index->cursor
   string-cursor-forward string-cursor-back
   string-null? string-every string-any
   string-join string-split string-count
   string-trim string-trim-left string-trim-right
   string-mismatch string-mismatch-right
   string-prefix? string-suffix?
   string-find string-find-right string-find? string-skip string-skip-right
   string-fold string-fold-right string-map string-for-each
   string-contains make-string-searcher
   string-downcase-ascii string-upcase-ascii
   call-with-input-string call-with-output-string)
  (cond-expand
   (chibi
    (import (chibi) (chibi ast) (chibi char-set base))
    (begin
      (define (string-for-each proc str . los)
        (if (null? los)
            (string-fold (lambda (ch a) (proc ch)) #f str)
            (let ((los (cons str los)))
              (let lp ((is (map string-cursor-start los)))
                (cond
                 ((any (lambda (str i)
                         (string-cursor>=? i (string-cursor-end str)))
                       los is))
                 (else
                  (apply proc (map string-cursor-ref los is))
                  (lp (map string-cursor-next los is))))))))
      (define (string-map proc str . los)
        (call-with-output-string
          (lambda (out)
            (apply string-for-each
                   (lambda args (write-char (apply proc args) out))
                   str los))))))
   (else
    (import (scheme base) (scheme char) (srfi 14)
            (except (srfi 1) make-list list-copy))
    (begin
      (define (string-cursor->index str i) i)
      (define (string-index->cursor str i) i)
      (define string-cursor? integer?)
      (define string-cursor<? <)
      (define string-cursor>? >)
      (define string-cursor=? =)
      (define string-cursor<=? <=)
      (define string-cursor>=? >=)
      (define string-cursor-ref string-ref)
      (define (string-cursor-start s) 0)
      (define string-cursor-end string-length)
      (define (string-cursor-next s i) (+ i 1))
      (define (string-cursor-prev s i) (- i 1))
      (define (substring-cursor s start . o)
        (substring s start (if (pair? o) (car o) (string-length s))))
      (define (string-concatenate orig-ls . o)
        (let ((sep (if (pair? o) (car o) ""))
              (out (open-output-string)))
          (let lp ((ls orig-ls))
            (cond
             ((pair? ls)
              (if (and sep (not (eq? ls orig-ls)))
                  (write-string sep out))
              (write-string (car ls) out)
              (lp (cdr ls)))))
          (get-output-string out)))
      (define string-size string-length)
      (define (call-with-input-string str proc)
        (let* ((in (open-input-string str))
               (res (proc in)))
          (close-input-port in)
          res))
      (define (call-with-output-string proc)
        (let ((out (open-output-string)))
          (proc out)
          (let ((res (get-output-string out)))
            (close-output-port out)
            res))))))
  (cond-expand
   (chibi)
   ((library (srfi 13))
    (import (only (srfi 13) string-contains)))
   (else
    (begin
      (define (string-contains a b . o)  ; really, stupidly slow
        (let ((alen (string-length a))
              (blen (string-length b)))
          (let lp ((i (if (pair? o) (car o) 0)))
            (and (<= (+ i blen) alen)
                 (if (string=? b (substring a i (+ i blen)))
                     i
                     (lp (+ i 1))))))))))
  (include "string.scm"))
;; md5.scm -- pure R7RS md5 implementation (originally from hato)
;; Copyright (c) 2009-2014 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

;; Break computations down into 16-bit words to keep everything in
;; fixnum even on 32-bit machines.

;; All values are in little-endian.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Utilities.

(define (extract-byte n i)
  (bitwise-and #xFF (arithmetic-shift n (* i -8))))

;; integer->hex-string is big-endian, so we adjust here
(define (hex-byte n)
  (if (< n 16)
      (string-append "0" (number->string n 16))
      (number->string n 16)))

(define (hex n)
  (string-append (hex-byte (remainder n 256))
                 (hex-byte (quotient n 256))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; 3. MD5 Algorithm Description

;; We begin by supposing that we have a b-bit message as input, and that
;; we wish to find its message digest. Here b is an arbitrary
;; nonnegative integer; b may be zero, it need not be a multiple of
;; eight, and it may be arbitrarily large. We imagine the bits of the
;; message written down as follows:

;;           m_0 m_1 ... m_{b-1}

;; The following five steps are performed to compute the message digest
;; of the message.

;; 3.1 Step 1. Append Padding Bits

;; The message is "padded" (extended) so that its length (in bits) is
;; congruent to 448, modulo 512. That is, the message is extended so
;; that it is just 64 bits shy of being a multiple of 512 bits long.
;; Padding is always performed, even if the length of the message is
;; already congruent to 448, modulo 512.

;; Padding is performed as follows: a single "1" bit is appended to the
;; message, and then "0" bits are appended so that the length in bits of
;; the padded message becomes congruent to 448, modulo 512. In all, at
;; least one bit and at most 512 bits are appended.

;; 3.2 Step 2. Append Length

;; A 64-bit representation of b (the length of the message before the
;; padding bits were added) is appended to the result of the previous
;; step. In the unlikely event that b is greater than 2^64, then only
;; the low-order 64 bits of b are used. (These bits are appended as two
;; 32-bit words and appended low-order word first in accordance with the
;; previous conventions.)

;; At this point the resulting message (after padding with bits and with
;; b) has a length that is an exact multiple of 512 bits. Equivalently,
;; this message has a length that is an exact multiple of 16 (32-bit)
;; words. Let M[0 ... N-1] denote the words of the resulting message,
;; where N is a multiple of 16.

;; 3.3 Step 3. Initialize MD Buffer

;; A four-word buffer (A,B,C,D) is used to compute the message digest.
;; Here each of A, B, C, D is a 32-bit register. These registers are
;; initialized to the following values in hexadecimal, low-order bytes
;; first):

;;           word A: 01 23 45 67
;;           word B: 89 ab cd ef
;;           word C: fe dc ba 98
;;           word D: 76 54 32 10

;; 3.4 Step 4. Process Message in 16-Word Blocks

;; We first define four auxiliary functions that each take as input
;; three 32-bit words and produce as output one 32-bit word.

;;           F(X,Y,Z) = XY v not(X) Z
;;           G(X,Y,Z) = XZ v Y not(Z)
;;           H(X,Y,Z) = X xor Y xor Z
;;           I(X,Y,Z) = Y xor (X v not(Z))

;; In each bit position F acts as a conditional: if X then Y else Z.
;; The function F could have been defined using + instead of v since XY
;; and not(X)Z will never have 1's in the same bit position.) It is
;; interesting to note that if the bits of X, Y, and Z are independent
;; and unbiased, the each bit of F(X,Y,Z) will be independent and
;; unbiased.

;; The functions G, H, and I are similar to the function F, in that they
;; act in "bitwise parallel" to produce their output from the bits of X,
;; Y, and Z, in such a manner that if the corresponding bits of X, Y,
;; and Z are independent and unbiased, then each bit of G(X,Y,Z),
;; H(X,Y,Z), and I(X,Y,Z) will be independent and unbiased. Note that
;; the function H is the bit-wise "xor" or "parity" function of its
;; inputs.

;; This step uses a 64-element table T[1 ... 64] constructed from the
;; sine function. Let T[i] denote the i-th element of the table, which
;; is equal to the integer part of 4294967296 times abs(sin(i)), where i
;; is in radians. The elements of the table are given in the appendix.

;; (define T
;;   (do ((i 64 (- i 1))
;;        (ls '()
;;            (cons (u32 (exact (truncate (* 4294967296 (abs (sin i))))))
;;                  ls)))
;;       ((< i 0) (list->vector ls))))

(define T
  '#(0     0       #xd76a #xa478 #xe8c7 #xb756 #x2420 #x70db #xc1bd #xceee
     #xf57c #x0faf #x4787 #xc62a #xa830 #x4613 #xfd46 #x9501 #x6980 #x98d8
     #x8b44 #xf7af #xffff #x5bb1 #x895c #xd7be #x6b90 #x1122 #xfd98 #x7193
     #xa679 #x438e #x49b4 #x0821 #xf61e #x2562 #xc040 #xb340 #x265e #x5a51
     #xe9b6 #xc7aa #xd62f #x105d #x0244 #x1453 #xd8a1 #xe681 #xe7d3 #xfbc8
     #x21e1 #xcde6 #xc337 #x07d6 #xf4d5 #x0d87 #x455a #x14ed #xa9e3 #xe905
     #xfcef #xa3f8 #x676f #x02d9 #x8d2a #x4c8a #xfffa #x3942 #x8771 #xf681
     #x6d9d #x6122 #xfde5 #x380c #xa4be #xea44 #x4bde #xcfa9 #xf6bb #x4b60
     #xbebf #xbc70 #x289b #x7ec6 #xeaa1 #x27fa #xd4ef #x3085 #x0488 #x1d05
     #xd9d4 #xd039 #xe6db #x99e5 #x1fa2 #x7cf8 #xc4ac #x5665 #xf429 #x2244
     #x432a #xff97 #xab94 #x23a7 #xfc93 #xa039 #x655b #x59c3 #x8f0c #xcc92
     #xffef #xf47d #x8584 #x5dd1 #x6fa8 #x7e4f #xfe2c #xe6e0 #xa301 #x4314
     #x4e08 #x11a1 #xf753 #x7e82 #xbd3a #xf235 #x2ad7 #xd2bb #xeb86 #xd391))

;;> Returns the md5 checksum of \var{src} as a lowercase hex-string.
;;> \var{src} can be any of a string (interpreted as utf8), a
;;> bytevector, or a binary input port.

(define (md5 src)
  (let ((in (cond ((string? src) (open-input-bytevector (string->utf8 src)))
                  ((bytevector? src) (open-input-bytevector src))
                  ((input-port? src) src)
                  (else (error "unknown digest source: " src))))
        ;; 3.3 Step 3. Initialize MD Buffer
        (buf (make-bytevector 64 0))
        (vec (make-vector 32))
        (A1 #x6745) (A0 #x2301)
        (B1 #xefcd) (B0 #xab89)
        (C1 #x98ba) (C0 #xdcfe)
        (D1 #x1032) (D0 #x5476))
    ;; Process each 16-word block.
    (let lp ((i 0)
             (pad #x80))
      (let* ((n (read-bytevector! buf in))
             (n (if (eof-object? n) 0 n)))
        (cond
         ((< n 64)
          (let ((len (* 8 (+ i n))))
            ;; 3.1 Step 1. Append Padding Bits
            (bytevector-u8-set! buf n pad)
            (do ((j (+ n 1) (+ j 1))) ((>= j 64))
              (bytevector-u8-set! buf j 0))
            ;; 3.2 Step 2. Append Length
            (cond
             ((< n 56)
              (bytevector-u8-set! buf 56 (extract-byte len 0))
              (bytevector-u8-set! buf 57 (extract-byte len 1))
              (bytevector-u8-set! buf 58 (extract-byte len 2))
              (bytevector-u8-set! buf 59 (extract-byte len 3))
              (bytevector-u8-set! buf 60 (extract-byte len 4))
              (bytevector-u8-set! buf 61 (extract-byte len 5))
              (bytevector-u8-set! buf 62 (extract-byte len 6))
              (bytevector-u8-set! buf 63 (extract-byte len 7)))))))
        ;; 3.4 Step 4. Process Message in 16-Word Blocks
        ;;
        ;; Copy block i into X.
        (do ((j 0 (+ j 1)))
            ((= j 16))
          (vector-set! vec (* j 2) (bytevector-u16-ref-le buf (* j 4)))
          (vector-set! vec
                       (+ (* j 2) 1)
                       (bytevector-u16-ref-le buf (+ (* j 4) 2))))
        ;; Save A as AA, B as BB, C as CC, and D as DD.
        (let ((AA0 A0) (AA1 A1)
              (BB0 B0) (BB1 B1)
              (CC0 C0) (CC1 C1)
              (DD0 D0) (DD1 D1)
              (T1 0)   (T0 0))
          (letrec-syntax
              ((add
                (syntax-rules ()
                  ((add d1 d0 a1 a0 b1 b0)
                   (begin
                     (set! d0 (+ a0 b0))
                     (set! d1 (bitwise-and
                               (+ a1 b1 (arithmetic-shift d0 -16))
                               #xFFFF))
                     (set! d0 (bitwise-and d0 #xFFFF))))))
               (rot
                (syntax-rules ()
                  ((rot d1 d0 a1 a0 s)
                   (let ((tmp a1))
                     (set! d1 (bitwise-and
                               (bitwise-ior (arithmetic-shift a1 s)
                                            (arithmetic-shift a1 (- s 32))
                                            (arithmetic-shift a0 (- s 16)))
                               #xFFFF))
                     (set! d0 (bitwise-and
                               (bitwise-ior (arithmetic-shift a0 s)
                                            (arithmetic-shift a0 (- s 32))
                                            (arithmetic-shift tmp (- s 16)))
                               #xFFFF))))))
               (bit-not
                (syntax-rules ()
                  ((bit-not a) (- (expt 2 16) a 1))))
               (FF
                (syntax-rules ()
                  ((FF d1 d0 x1 x0 y1 y0 z1 z0)
                   (begin
                     (set! d1 (bitwise-ior (bitwise-and x1 y1)
                                           (bitwise-and (bit-not x1) z1)))
                     (set! d0 (bitwise-ior (bitwise-and x0 y0)
                                           (bitwise-and (bit-not x0) z0)))
                     ))))
               (GG
                (syntax-rules ()
                  ((GG d1 d0 x1 x0 y1 y0 z1 z0)
                   (begin
                     (set! d1 (bitwise-ior (bitwise-and x1 z1)
                                           (bitwise-and y1 (bit-not z1))))
                     (set! d0 (bitwise-ior (bitwise-and x0 z0)
                                           (bitwise-and y0 (bit-not z0))))
                     ))))
               (HH
                (syntax-rules ()
                  ((HH d1 d0 x1 x0 y1 y0 z1 z0)
                   (begin (set! d1 (bitwise-xor x1 y1 z1))
                          (set! d0 (bitwise-xor x0 y0 z0))))))
               (II
                (syntax-rules ()
                  ((II d1 d0 x1 x0 y1 y0 z1 z0)
                   (begin
                     (set! d1 (bitwise-xor y1 (bitwise-ior x1 (bit-not z1))))
                     (set! d0 (bitwise-xor y0 (bitwise-ior x0 (bit-not z0))))
                     ))))
               (R
                (syntax-rules ()
                  ((R op T1 T0 a1 a0 b1 b0 c1 c0 d1 d0 vec k s i)
                   (begin
                     (op T1 T0 b1 b0 c1 c0 d1 d0)
                     (add T1 T0 T1 T0
                          (vector-ref vec (+ (* k 2) 1))
                          (vector-ref vec (* k 2)))
                     (add T1 T0 T1 T0
                          (vector-ref T (* i 2))
                          (vector-ref T (+ (* i 2) 1)))
                     (add a1 a0 a1 a0 T1 T0)
                     (rot a1 a0 a1 a0 s)
                     (add a1 a0 a1 a0 b1 b0)))))
               (R1 (syntax-rules ()
                     ((R1 T1 T0 a1 a0 b1 b0 c1 c0 d1 d0 vec k s i)
                      (R FF T1 T0 a1 a0 b1 b0 c1 c0 d1 d0 vec k s i))))
               (R2 (syntax-rules ()
                     ((R2 T1 T0 a1 a0 b1 b0 c1 c0 d1 d0 vec k s i)
                      (R GG T1 T0 a1 a0 b1 b0 c1 c0 d1 d0 vec k s i))))
               (R3 (syntax-rules ()
                     ((R3 T1 T0 a1 a0 b1 b0 c1 c0 d1 d0 vec k s i)
                      (R HH T1 T0 a1 a0 b1 b0 c1 c0 d1 d0 vec k s i))))
               (R4 (syntax-rules ()
                     ((R4 T1 T0 a1 a0 b1 b0 c1 c0 d1 d0 vec k s i)
                      (R II T1 T0 a1 a0 b1 b0 c1 c0 d1 d0 vec k s i)))))
            ;; Round 1: Let [abcd k s i] denote the operation
            ;;   a = b + ((a + F(b,c,d) + X[k] + T[i]) <<< s)
            (R1 T1 T0 A1 A0 B1 B0 C1 C0 D1 D0 vec 0 7 1)
            (R1 T1 T0 D1 D0 A1 A0 B1 B0 C1 C0 vec 1 12 2)
            (R1 T1 T0 C1 C0 D1 D0 A1 A0 B1 B0 vec 2 17 3)
            (R1 T1 T0 B1 B0 C1 C0 D1 D0 A1 A0 vec 3 22 4)
            (R1 T1 T0 A1 A0 B1 B0 C1 C0 D1 D0 vec 4 7 5)
            (R1 T1 T0 D1 D0 A1 A0 B1 B0 C1 C0 vec 5 12 6)
            (R1 T1 T0 C1 C0 D1 D0 A1 A0 B1 B0 vec 6 17 7)
            (R1 T1 T0 B1 B0 C1 C0 D1 D0 A1 A0 vec 7 22 8)
            (R1 T1 T0 A1 A0 B1 B0 C1 C0 D1 D0 vec 8 7 9)
            (R1 T1 T0 D1 D0 A1 A0 B1 B0 C1 C0 vec 9 12 10)
            (R1 T1 T0 C1 C0 D1 D0 A1 A0 B1 B0 vec 10 17 11)
            (R1 T1 T0 B1 B0 C1 C0 D1 D0 A1 A0 vec 11 22 12)
            (R1 T1 T0 A1 A0 B1 B0 C1 C0 D1 D0 vec 12 7 13)
            (R1 T1 T0 D1 D0 A1 A0 B1 B0 C1 C0 vec 13 12 14)
            (R1 T1 T0 C1 C0 D1 D0 A1 A0 B1 B0 vec 14 17 15)
            (R1 T1 T0 B1 B0 C1 C0 D1 D0 A1 A0 vec 15 22 16)
            ;; Round 2: Let [abcd k s i] denote the operation
            ;;   a = b + ((a + G(b,c,d) + X[k] + T[i]) <<< s)
            (R2 T1 T0 A1 A0 B1 B0 C1 C0 D1 D0 vec 1 5 17)
            (R2 T1 T0 D1 D0 A1 A0 B1 B0 C1 C0 vec 6 9 18)
            (R2 T1 T0 C1 C0 D1 D0 A1 A0 B1 B0 vec 11 14 19)
            (R2 T1 T0 B1 B0 C1 C0 D1 D0 A1 A0 vec 0 20 20)
            (R2 T1 T0 A1 A0 B1 B0 C1 C0 D1 D0 vec 5 5 21)
            (R2 T1 T0 D1 D0 A1 A0 B1 B0 C1 C0 vec 10 9 22)
            (R2 T1 T0 C1 C0 D1 D0 A1 A0 B1 B0 vec 15 14 23)
            (R2 T1 T0 B1 B0 C1 C0 D1 D0 A1 A0 vec 4 20 24)
            (R2 T1 T0 A1 A0 B1 B0 C1 C0 D1 D0 vec 9 5 25)
            (R2 T1 T0 D1 D0 A1 A0 B1 B0 C1 C0 vec 14 9 26)
            (R2 T1 T0 C1 C0 D1 D0 A1 A0 B1 B0 vec 3 14 27)
            (R2 T1 T0 B1 B0 C1 C0 D1 D0 A1 A0 vec 8 20 28)
            (R2 T1 T0 A1 A0 B1 B0 C1 C0 D1 D0 vec 13 5 29)
            (R2 T1 T0 D1 D0 A1 A0 B1 B0 C1 C0 vec 2 9 30)
            (R2 T1 T0 C1 C0 D1 D0 A1 A0 B1 B0 vec 7 14 31)
            (R2 T1 T0 B1 B0 C1 C0 D1 D0 A1 A0 vec 12 20 32)
            ;; Round 3: Let [abcd k s i] denote the operation
            ;;   a = b + ((a + H(b,c,d) + X[k] + T[i]) <<< s)
            (R3 T1 T0 A1 A0 B1 B0 C1 C0 D1 D0 vec 5 4 33)
            (R3 T1 T0 D1 D0 A1 A0 B1 B0 C1 C0 vec 8 11 34)
            (R3 T1 T0 C1 C0 D1 D0 A1 A0 B1 B0 vec 11 16 35)
            (R3 T1 T0 B1 B0 C1 C0 D1 D0 A1 A0 vec 14 23 36)
            (R3 T1 T0 A1 A0 B1 B0 C1 C0 D1 D0 vec 1 4 37)
            (R3 T1 T0 D1 D0 A1 A0 B1 B0 C1 C0 vec 4 11 38)
            (R3 T1 T0 C1 C0 D1 D0 A1 A0 B1 B0 vec 7 16 39)
            (R3 T1 T0 B1 B0 C1 C0 D1 D0 A1 A0 vec 10 23 40)
            (R3 T1 T0 A1 A0 B1 B0 C1 C0 D1 D0 vec 13 4 41)
            (R3 T1 T0 D1 D0 A1 A0 B1 B0 C1 C0 vec 0 11 42)
            (R3 T1 T0 C1 C0 D1 D0 A1 A0 B1 B0 vec 3 16 43)
            (R3 T1 T0 B1 B0 C1 C0 D1 D0 A1 A0 vec 6 23 44)
            (R3 T1 T0 A1 A0 B1 B0 C1 C0 D1 D0 vec 9 4 45)
            (R3 T1 T0 D1 D0 A1 A0 B1 B0 C1 C0 vec 12 11 46)
            (R3 T1 T0 C1 C0 D1 D0 A1 A0 B1 B0 vec 15 16 47)
            (R3 T1 T0 B1 B0 C1 C0 D1 D0 A1 A0 vec 2 23 48)
            ;; Round 4: Let [abcd k s i] denote the operation
            ;;   a = b + ((a + I(b,c,d) + X[k] + T[i]) <<< s)
            (R4 T1 T0 A1 A0 B1 B0 C1 C0 D1 D0 vec 0 6 49)
            (R4 T1 T0 D1 D0 A1 A0 B1 B0 C1 C0 vec 7 10 50)
            (R4 T1 T0 C1 C0 D1 D0 A1 A0 B1 B0 vec 14 15 51)
            (R4 T1 T0 B1 B0 C1 C0 D1 D0 A1 A0 vec 5 21 52)
            (R4 T1 T0 A1 A0 B1 B0 C1 C0 D1 D0 vec 12 6 53)
            (R4 T1 T0 D1 D0 A1 A0 B1 B0 C1 C0 vec 3 10 54)
            (R4 T1 T0 C1 C0 D1 D0 A1 A0 B1 B0 vec 10 15 55)
            (R4 T1 T0 B1 B0 C1 C0 D1 D0 A1 A0 vec 1 21 56)
            (R4 T1 T0 A1 A0 B1 B0 C1 C0 D1 D0 vec 8 6 57)
            (R4 T1 T0 D1 D0 A1 A0 B1 B0 C1 C0 vec 15 10 58)
            (R4 T1 T0 C1 C0 D1 D0 A1 A0 B1 B0 vec 6 15 59)
            (R4 T1 T0 B1 B0 C1 C0 D1 D0 A1 A0 vec 13 21 60)
            (R4 T1 T0 A1 A0 B1 B0 C1 C0 D1 D0 vec 4 6 61)
            (R4 T1 T0 D1 D0 A1 A0 B1 B0 C1 C0 vec 11 10 62)
            (R4 T1 T0 C1 C0 D1 D0 A1 A0 B1 B0 vec 2 15 63)
            (R4 T1 T0 B1 B0 C1 C0 D1 D0 A1 A0 vec 9 21 64)
            ;; Then in increment each of the four registers by the
            ;; value it had before this block was started.
            (add A1 A0 A1 A0 AA1 AA0)
            (add B1 B0 B1 B0 BB1 BB0)
            (add C1 C0 C1 C0 CC1 CC0)
            (add D1 D0 D1 D0 DD1 DD0)
            (cond
             ((< n 64)
              ;; 3.5 Step 5. Output
              ;;
              ;;    The message digest produced as output is A, B, C,
              ;;    D. That is, we begin with the low-order byte of A,
              ;;    and end with the high-order byte of D.
              (if (>= n 56)
                  (lp (+ i n) 0)
                  (string-append
                   (hex A0) (hex A1)
                   (hex B0) (hex B1)
                   (hex C0) (hex C1)
                   (hex D0) (hex D1))))
             (else
              (lp (+ i 64) pad)))))))))

;; This completes the description of MD5. A reference implementation in
;; C is given in the appendix.
;; sha2-native.scm -- SHA-2 digest algorithms native interface
;; Copyright (c) 2015 Alexei Lozovsky.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

(define (process-sha-data! context src)
  (cond ((or (bytevector? src) (string? src))
         (add-sha-data! context src))
        ((input-port? src)
         (let lp ((chunk (read-bytevector 1024 src)))
           (unless (eof-object? chunk)
             (add-sha-data! context chunk)
             (lp (read-bytevector 1024 src)))))
        (else
         (error "unknown digest source: " src))))

(define (sha-224 src)
  (let ((context (start-sha type-sha-224)))
    (process-sha-data! context src)
    (get-sha context)))

(define (sha-256 src)
  (let ((context (start-sha type-sha-256)))
    (process-sha-data! context src)
    (get-sha context)))
(define-library (chibi crypto rsa-test)
  (export run-tests)
  (import (scheme base)
          (chibi crypto rsa)
          (chibi crypto sha2)
          (chibi test))
  (begin
    (define (run-tests)

      (define (test-key key)
        (test #t (rsa-key? key))
        (test #t (positive? (rsa-key-n key)))
        (test #t (positive? (rsa-key-e key)))
        (test #t (positive? (rsa-key-d key)))
        (test 5 (rsa-decrypt key (rsa-encrypt (rsa-pub-key key) 5))))

      (test-begin "rsa")

      ;; Verify an explicit key.

      ;; p = 61, q = 53
      (let* ((priv-key (rsa-key-gen-from-primes 8 61 53))
             (pub-key (rsa-pub-key priv-key)))
        (test 439 (rsa-sign priv-key 42))
        (test #t (rsa-verify? pub-key 42 (rsa-sign priv-key 42)))
        (let ((msg 42))
          (test msg (rsa-decrypt priv-key (rsa-encrypt pub-key msg)))))

      (let* ((priv-key2 (rsa-key-gen-from-primes 32 2936546443 3213384203))
             (pub-key2 (rsa-pub-key priv-key2)))
        (let ((msg 42))
          (test msg (rsa-decrypt priv-key2 (rsa-encrypt pub-key2 msg))))

        (let ((msg #u8(42)))
          (test msg (rsa-decrypt priv-key2 (rsa-encrypt pub-key2 msg))))

        (let ((msg "*"))
          (test msg (utf8->string (rsa-decrypt priv-key2 (rsa-encrypt pub-key2 msg)))))

        (let ((msg "*"))
          (test #t (rsa-verify? pub-key2 msg (rsa-sign priv-key2 msg))))

        (let ((msg #u8(42)))
          (test #t (rsa-verify? pub-key2 msg (rsa-sign priv-key2 msg)))))

      ;; Key generation.

      (test-key (rsa-key-gen 8))
      (test-key (rsa-key-gen 16))
      (test-key (rsa-key-gen 32))
      (test-key (rsa-key-gen-from-primes 32 2936546443 3213384203))

      ;; These are expensive to test.  Times with -h1G:
      ;; (test-key (rsa-key-gen 128))   ; 0.04s
      ;; (test-key (rsa-key-gen 256))   ; 0.4s
      ;; (test-key (rsa-key-gen 512))   ; 4s
      ;; (test-key (rsa-key-gen 1024))  ; 92s

      ;; padding

      (test #u8(8 8 8 8 8 8 8 8) (pkcs1-pad #u8()))
      (test #u8(1 7 7 7 7 7 7 7) (pkcs1-pad #u8(1)))
      (test #u8(1 2 6 6 6 6 6 6) (pkcs1-pad #u8(1 2)))
      (test #u8(1 2 3 5 5 5 5 5) (pkcs1-pad #u8(1 2 3)))
      (test #u8(1 2 3 4 4 4 4 4) (pkcs1-pad #u8(1 2 3 4)))
      (test #u8(1 2 3 4 5 3 3 3) (pkcs1-pad #u8(1 2 3 4 5)))
      (test #u8(1 2 3 4 5 6 2 2) (pkcs1-pad #u8(1 2 3 4 5 6)))
      (test #u8(1 2 3 4 5 6 7 1) (pkcs1-pad #u8(1 2 3 4 5 6 7)))
      (test #u8(1 2 3 4 5 6 7 8 8 8 8 8 8 8 8 8) (pkcs1-pad #u8(1 2 3 4 5 6 7 8)))

      (test #u8() (pkcs1-unpad #u8(8 8 8 8 8 8 8 8)))
      (test #u8(1) (pkcs1-unpad #u8(1 7 7 7 7 7 7 7)))
      (test #u8(1 2) (pkcs1-unpad #u8(1 2 6 6 6 6 6 6)))
      (test #u8(1 2 3) (pkcs1-unpad #u8(1 2 3 5 5 5 5 5)))
      (test #u8(1 2 3 4) (pkcs1-unpad #u8(1 2 3 4 4 4 4 4)))
      (test #u8(1 2 3 4 5) (pkcs1-unpad #u8(1 2 3 4 5 3 3 3)))
      (test #u8(1 2 3 4 5 6) (pkcs1-unpad #u8(1 2 3 4 5 6 2 2)))
      (test #u8(1 2 3 4 5 6 7) (pkcs1-unpad #u8(1 2 3 4 5 6 7 1)))
      (test #u8(1 2 3 4 5 6 7 8) (pkcs1-unpad #u8(1 2 3 4 5 6 7 8 8 8 8 8 8 8 8 8)))

      (test-end))))

;;> Implementation of the MD5 (Message Digest) cryptographic hash.  In
;;> new applications SHA-2 should be preferred.

(define-library (chibi crypto md5)
  (import (scheme base) (chibi bytevector))
  (cond-expand
   ((library (srfi 151)) (import (srfi 151)))
   ((library (srfi 33)) (import (srfi 33)))
   (else (import (srfi 60))))
  (export md5)
  (include "md5.scm"))

;;> RSA public key cryptography implementation.

(define-library (chibi crypto rsa)
  (import (scheme base) (srfi 27)
          (chibi bytevector) (chibi math prime))
  (cond-expand
   ((library (srfi 151)) (import (srfi 151)))
   ((library (srfi 33)) (import (srfi 33)))
   (else (import (srfi 60))))
  (export make-rsa-key rsa-key-gen rsa-key-gen-from-primes rsa-pub-key
          rsa-encrypt rsa-decrypt rsa-sign rsa-verify rsa-verify?
          rsa-key? rsa-key-bits rsa-key-n rsa-key-e rsa-key-d
          pkcs1-pad pkcs1-unpad)
  (include "rsa.scm"))
;; rsa.scm -- RSA public key cryptography library
;; Copyright (c) 2014 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

;; The RSA key type.  The public fields are always present, but the
;; private key d may be #f.
(define-record-type Rsa-Key
  (make-rsa-key bits n e d)
  rsa-key?
  (bits rsa-key-bits)
  (n rsa-key-n)         ; public modulus, the product of two primes
  (e rsa-key-e)         ; public exponent, coptime to (totient n)
  (d rsa-key-d))        ; private exponent, the inverse of e mod (totient n)

(define (rsa-key-gen-from-primes bit-length p q . o)
  (define (choose-exponent phi e)
    (cond ((>= e phi) (error "couldn't find an exponent for " p q))
          ((= 1 (gcd e phi)) e)
          (else (choose-exponent phi (+ e 2)))))
  (let* ((n (* p q))
         (phi (* (- p 1) (- q 1)))
         ;; Default to Fermat's number F4, or if too large the number
         ;; 3, as suggested by RFC 1423.  Ensure it's coprime to phi.
         (e (choose-exponent phi (cond ((pair? o) (car o))
                                       ((< 65537 phi) 65537)
                                       (else 3))))
         (d (modular-inverse e phi)))
    (make-rsa-key bit-length n e d)))

(define (rsa-key-gen . o)
  (let* ((bit-length (if (pair? o) (car o) 128))
         (lo (max 3 (expt 2 (- bit-length 1))))
         (hi (expt 2 bit-length))
         (p (random-prime lo hi))
         (q (random-prime-distinct-from lo hi p)))
    (rsa-key-gen-from-primes bit-length p q)))

;;> Returns a copy of the given key with the private key, if any,
;;> removed.
(define (rsa-pub-key priv-key)
  (make-rsa-key (rsa-key-bits priv-key) (rsa-key-n priv-key)
                (rsa-key-e priv-key) #f))

;; From RFC-1423
(define (pkcs1-pad bv)
  (let ((pad (- 8 (modulo (bytevector-length bv) 8))))
    (bytevector-append bv (make-bytevector pad pad))))

(define (pkcs1-unpad bv)
  (let* ((len (bytevector-length bv))
         (pad (bytevector-u8-ref bv (- len 1))))
    (if (not (<= 1 pad 8))
        (error "not pkcs1 padded" bv)
        (bytevector-copy bv 0 (- len pad)))))

;; Actual encryption and decryption are trivially defined as modular
;; exponentiation.

(define (rsa-encrypt-integer pub-key msg)
  (if (>= msg (rsa-key-n pub-key))
      (error "message larger than modulus" msg (rsa-key-n pub-key)))
  (modular-expt msg (rsa-key-e pub-key) (rsa-key-n pub-key)))

(define (rsa-decrypt-integer priv-key cipher)
  (if (>= cipher (rsa-key-n priv-key))
      (error "cipher larger than modulus"))
  (modular-expt cipher (rsa-key-d priv-key) (rsa-key-n priv-key)))

;; Arbitrary messages are encrypted by converting encoded bytevectors
;; to and from integers.
;; TODO: user emsa-pss encoding

(define (convert-plain f key msg)
  (cond
   ((bytevector? msg)
    (integer->bytevector (f key (bytevector->integer (pkcs1-pad msg)))))
   ((string? msg)
    (convert-plain f key (string->utf8 msg)))
   (else
    (f key msg))))

(define (convert-cipher f key cipher)
  (cond
   ((bytevector? cipher)
    (pkcs1-unpad (integer->bytevector (f key (bytevector->integer cipher)))))
   ((string? cipher)
    (convert-cipher f key (string->utf8 cipher)))
   (else
    (f key cipher))))

;; General API can handle integers, bytevectors, or strings which are
;; converted to utf8 bytevectors.

;;> Encrypts \var{msg} for the given public key \var{pub-key}.
;;> \var{msg} may be an integer or bytevector, in which case the
;;> result is of the same type, or a string, in which case the string
;;> is first coerced to a utf8 encoded bytevector.
(define (rsa-encrypt pub-key msg)
  (if (not (rsa-key-e pub-key))
      (error "can't encrypt without a public key" pub-key)
      (convert-plain rsa-encrypt-integer pub-key msg)))

;;> Decrypts \var{cipher} using the given private key \var{priv-key}.
;;> \var{cipher} may be an integer or bytevector, in which case the
;;> result is of the same type, or a string, in which case the string
;;> is first coerced to a utf8 encoded bytevector.
(define (rsa-decrypt priv-key cipher)
  (if (not (rsa-key-d priv-key))
      (error "can't decrypt without a private key" priv-key)
      (convert-cipher rsa-decrypt-integer priv-key cipher)))

;;> Signs \var{msg} using the given private key \var{priv-key}.
(define (rsa-sign priv-key msg)
  (if (not (rsa-key-d priv-key))
      (error "can't sign without a private key" priv-key)
      (convert-plain rsa-decrypt-integer priv-key msg)))

;;> Returns the verified (decrypted) message for the signature \var{sig}.
(define (rsa-verify pub-key sig)
  (if (not (rsa-key-e pub-key))
      (error "can't verify without a public key" pub-key)
      (convert-cipher rsa-encrypt-integer pub-key sig)))

;;> Returns true iff \var{sig} is a valid signature of \var{msg} for
;;> the given public key \var{pub-key}.
(define (rsa-verify? pub-key msg sig)
  (equal? (if (string? msg) (string->utf8 msg) msg)
          (rsa-verify pub-key sig)))
(define-library (chibi crypto md5-test)
  (export run-tests)
  (import (scheme base) (chibi crypto md5) (chibi test))
  (begin
    (define (run-tests)
      (test-begin "md5")
      (test "d41d8cd98f00b204e9800998ecf8427e"
          (md5 ""))
      (test "900150983cd24fb0d6963f7d28e17f72"
          (md5 "abc"))
      (test "9e107d9d372bb6826bd81d3542a419d6"
          (md5 "The quick brown fox jumps over the lazy dog"))
      (test-end))))

;;> Implementation of the SHA-2 (Secure Hash Algorithm) cryptographic
;;> hash.

(define-library (chibi crypto sha2)
  (import (scheme base))
  (export sha-224 sha-256)
  (cond-expand
   (chibi
    (include "sha2-native.scm")
    (include-shared "crypto"))
   (else
    (cond-expand
     ((library (srfi 151)) (import (srfi 151)))
     ((library (srfi 33)) (import (srfi 33)))
     (else (import (srfi 60))))
    (import (chibi bytevector))
    (include "sha2.scm"))))

;;> \procedure{(sha-224 src)}
;;>
;;> Computes SHA-224 digest of the \var{src} which can be a string,
;;> a bytevector, or a binary input port. Returns a hexadecimal string
;;> (in lowercase).

;;> \procedure{(sha-256 src)}
;;>
;;> Computes SHA-256 digest of the \var{src} which can be a string,
;;> a bytevector, or a binary input port. Returns a hexadecimal string
;;> (in lowercase).
(define-library (chibi crypto sha2-test)
  (export run-tests)
  (import (scheme base) (chibi crypto sha2) (chibi test))
  (begin
    (define (run-tests)
      (test-begin "sha2")
      (test "d14a028c2a3a2bc9476102bb288234c415a2b01f828ea62ac5b3e42f"
          (sha-224 ""))
      (test "23097d223405d8228642a477bda255b32aadbce4bda0b3f7e36c9da7"
          (sha-224 "abc"))
      (test "730e109bd7a8a32b1cb9d9a09aa2325d2430587ddbc0c38bad911525"
          (sha-224 "The quick brown fox jumps over the lazy dog"))
      (test "7c9da3bf97ccdeee630639aacdce35d3c136e514332a28e67097a4a4"
          (sha-224 "Boundary test for 448 bits (-1) - 012345678901234567890"))
      (test "35aebce593c857a2c817428340ff465922ffe43ed076d24553db1a24"
          (sha-224 "Boundary test for 448 bits (0)  - 0123456789012345678901"))
      (test "3f8dbeb9c33981d7007e20641d506d048e89e98a9546ecccc3224d3b"
          (sha-224 "Boundary test for 448 bits (+1) - 01234567890123456789012"))
      (test "8b311209d5880800911d3e72ffe7e75ec33a6e83932d5cdd00c96327"
          (sha-224 "Boundary test for 512 bits (-1) - 01234567890123456789012345678"))
      (test "9b68fdc122e1cb38575ba97f54699d71eaf0e58ee88f9e653b31d6ce"
          (sha-224 "Boundary test for 512 bits (0)  - 012345678901234567890123456789"))
      (test "52b28e31226ee5e6ada43e33194e11d8015abf8b5511c1631ad11aea"
          (sha-224 "Boundary test for 512 bits (+1) - 0123456789012345678901234567890"))
      (test "aa85fe2924d9c259f92e154fa88d0c845654fe69aa7dc1e3f7e4c789"
          (sha-224 "Boundary test for 960 bits (-1) - 0123456789012345678901234567890123456789012345678901234567890123456789012345678901234"))
      (test "dd8af6abfe24e78065afd1ae06220e8d46401db13f202109770ca2d2"
          (sha-224 "Boundary test for 960 bits (0)  - 01234567890123456789012345678901234567890123456789012345678901234567890123456789012345"))
      (test "5299a41ce9c6e8b405f42b193922fb4af3da16a1519610057baca20f"
          (sha-224 "Boundary test for 960 bits (+1) - 012345678901234567890123456789012345678901234567890123456789012345678901234567890123456"))
      (test "cb88e45dc662233ef4e7171e9e1c4903bd6502dd25923105778ea82e"
          (sha-224 "Boundary test for 1024 bits (-1) - 01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901"))
      (test "f41c907a7fd2fa3aec70815669fe467760f4fd15763a75192d2c9f45"
          (sha-224 "Boundary test for 1024 bits (0)  - 012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012"))
      (test "cc1501345f86b1ef60eaf3637f7a37c38c63252b5674d343a3cc4aea"
          (sha-224 "Boundary test for 1024 bits (+1) - 0123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123"))
      (test "d14a028c2a3a2bc9476102bb288234c415a2b01f828ea62ac5b3e42f"
          (sha-224 #u8()))
      (test "ae40be26ae2072dd84f37c13a5f6af48e3c33ea1c08a5ef4a54b22e3"
          (sha-224 #u8(1 2 3 4 5 6 7 8 9)))
      (test "54e5eb52479c241cc4759318619f548994ae46979124cb9b1435db14"
          (sha-224 (open-input-bytevector #u8(1 2 3 9))))
      (test "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855"
          (sha-256 ""))
      (test "ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad"
          (sha-256 "abc"))
      (test "d7a8fbb307d7809469ca9abcb0082e4f8d5651e46d3cdb762d02d0bf37c9e592"
          (sha-256 "The quick brown fox jumps over the lazy dog"))
      (test "61f8fe4c4cdc8b3e10673933fcd0c5b1f6b46d3392550e42b265daefc7bc0d31"
          (sha-256 "abcdbcdecdefdefgefghfghighijhijkijkljklmklm"))
      (test "248d6a61d20638b8e5c026930c3e6039a33ce45964ff2167f6ecedd419db06c1"
          (sha-256 "abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq"))
      (test "f904e41d6488bc982a929e1f9307d9b47f12e6cc01ab42d109b083a780dbb70a"
          (sha-256 "Boundary test for 448 bits (-1) - 012345678901234567890"))
      (test "4621c7c067a12951ed5b0339a6c6811aec2dea4adcb2dcbb1383868765dbbc21"
          (sha-256 "Boundary test for 448 bits (0)  - 0123456789012345678901"))
      (test "a62bd24e12494c5a213dc366fec9d79e2bd77789febf6b1437191f264ad0a7fe"
          (sha-256 "Boundary test for 448 bits (+1) - 01234567890123456789012"))
      (test "2c47adeb018cd5634aa3c121bf0e6d122789448568814e7243b19b6c26ac4860"
          (sha-256 "Boundary test for 512 bits (-1) - 01234567890123456789012345678"))
      (test "eb1018cf7e5f40ba45a711c4154584234e2194f10cc6fa7559a438bed9e4a388"
          (sha-256 "Boundary test for 512 bits (0)  - 012345678901234567890123456789"))
      (test "714f030e4971ade8976564693a8fe202ca357e87cb1cb7391a9af3c45590f7c0"
          (sha-256 "Boundary test for 512 bits (+1) - 0123456789012345678901234567890"))
      (test "a745d68a9999da92558757735428346439e2af5668b188e9e4da7935e318335b"
          (sha-256 "Boundary test for 960 bits (-1) - 0123456789012345678901234567890123456789012345678901234567890123456789012345678901234"))
      (test "f2d7ad79e0360fbad145dd551db33548dc7cd253e6c56c975f2820e4c99dee51"
          (sha-256 "Boundary test for 960 bits (0)  - 01234567890123456789012345678901234567890123456789012345678901234567890123456789012345"))
      (test "9f0378e0ba55965bd17232f994710b786e9d72a88a806c0b10cd9d36a06e41ed"
          (sha-256 "Boundary test for 960 bits (+1) - 012345678901234567890123456789012345678901234567890123456789012345678901234567890123456"))
      (test "483a36ca7824cc0d9bff2d63901301ba8ca7deb675628c71d8a08d52a0396cfe"
          (sha-256 "Boundary test for 1024 bits (-1) - 01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901"))
      (test "8bd16f15e5f1b753650753497d09e1956137fba0cb2162a61dc6a2b49c7fcda3"
          (sha-256 "Boundary test for 1024 bits (0)  - 012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012"))
      (test "c6c960e1c106d214e82d58c12c44adb000903d2022ea2ce239f273294d3055e5"
          (sha-256 "Boundary test for 1024 bits (+1) - 0123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123"))
      (test "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855"
          (sha-256 #u8()))
      (test "47e4ee7f211f73265dd17658f6e21c1318bd6c81f37598e20a2756299542efcf"
          (sha-256 #u8(1 2 3 4 5 6 7 8 9)))
      (test "a745f3ca4f474d583c050eaf476ce76439d171ebe2b49d4af8b44f13ba71fb56"
          (sha-256 (open-input-bytevector #u8(1 2 3 9))))
      (test-end))))
;; sha2.scm -- SHA2 digest algorithms
;; Copyright (c) 2014 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

;; http://csrc.nist.gov/groups/STM/cavp/documents/shs/sha256-384-512.pdf
;; http://tools.ietf.org/html/rfc6234

;; Note 1: All variables are 32 bit unsigned integers and addition is
;;   calculated modulo 32
;; Note 2: For each round, there is one round constant k[i] and one entry
;;   in the message schedule array w[i], 0  i  63
;; Note 3: The compression function uses 8 working variables, a through h
;; Note 4: Big-endian convention is used when expressing the constants in
;;   this pseudocode, and when parsing message block data from bytes to
;;   words, for example, the first word of the input message "abc" after
;;   padding is #x61626380

;; On a 32-bit machine, these will involve bignum computations
;; resulting in poor performance.  Breaking this down into separate
;; 16-bit computations may help.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Utilities.

;; We fake 32-bit arithmetic by ANDing out the low 32 bits.
(define (u32 n)
  (bitwise-and n #xFFFFFFFF))

;; 32-bit addition.
(define (u32+ a b)
  (u32 (+ a b)))

;; Extract bytes 0..3 of a big-endian 32-bit value.
(define (extract-byte n i)
  (bitwise-and #xFF (arithmetic-shift n (* i -8))))

;; Rotate right in 32 bits.
(define (bitwise-rot-u32 n k)
  (bitwise-ior
   (u32 (arithmetic-shift n (- 32 k)))
   (arithmetic-shift n (- k))))

(define (hex32 num)
  (let* ((res (number->string num 16))
         (len (string-length res)))
    (if (>= len 8)
        res
        (string-append (make-string (- 8 len) #\0) res))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; The first 32 bits of the fractional parts of the square roots of
;; the first 8 primes 2..19:

(define sha-224-inits
  '#(#xc1059ed8 #x367cd507 #x3070dd17 #xf70e5939
     #xffc00b31 #x68581511 #x64f98fa7 #xbefa4fa4))

;; The second 32 bits of the fractional parts of the square roots of
;; the 9th through 16th primes 23..53.

(define sha-256-inits
  '#(#x6a09e667 #xbb67ae85 #x3c6ef372 #xa54ff53a
     #x510e527f #x9b05688c #x1f83d9ab #x5be0cd19))

;; First 32 bits of the fractional parts of the cube roots of the
;; first 64 primes 2..311:

(define k
  '#(#x428a2f98 #x71374491 #xb5c0fbcf #xe9b5dba5
     #x3956c25b #x59f111f1 #x923f82a4 #xab1c5ed5
     #xd807aa98 #x12835b01 #x243185be #x550c7dc3
     #x72be5d74 #x80deb1fe #x9bdc06a7 #xc19bf174
     #xe49b69c1 #xefbe4786 #x0fc19dc6 #x240ca1cc
     #x2de92c6f #x4a7484aa #x5cb0a9dc #x76f988da
     #x983e5152 #xa831c66d #xb00327c8 #xbf597fc7
     #xc6e00bf3 #xd5a79147 #x06ca6351 #x14292967
     #x27b70a85 #x2e1b2138 #x4d2c6dfc #x53380d13
     #x650a7354 #x766a0abb #x81c2c92e #x92722c85
     #xa2bfe8a1 #xa81a664b #xc24b8b70 #xc76c51a3
     #xd192e819 #xd6990624 #xf40e3585 #x106aa070
     #x19a4c116 #x1e376c08 #x2748774c #x34b0bcb5
     #x391c0cb3 #x4ed8aa4a #x5b9cca4f #x682e6ff3
     #x748f82ee #x78a5636f #x84c87814 #x8cc70208
     #x90befffa #xa4506ceb #xbef9a3f7  #xc67178f2))

(define (sha-224-256 src inits full?)
  (let ((in (cond ((string? src) (open-input-bytevector (string->utf8 src)))
                  ((bytevector? src) (open-input-bytevector src))
                  ((input-port? src) src)
                  (else (error "unknown digest source: " src))))
        (buf (make-bytevector 64 0))
        (w (make-vector 64 0)))
    (let chunk ((i 0)
                (pad #x80)
                (h0 (vector-ref inits 0))
                (h1 (vector-ref inits 1))
                (h2 (vector-ref inits 2))
                (h3 (vector-ref inits 3))
                (h4 (vector-ref inits 4))
                (h5 (vector-ref inits 5))
                (h6 (vector-ref inits 6))
                (h7 (vector-ref inits 7)))
      (let* ((n (read-bytevector! buf in))
             (n (if (eof-object? n) 0 n)))
        ;; Maybe pad.
        (cond
         ((< n 64)
          (let ((len (* 8 (+ i n))))
            (bytevector-u8-set! buf n pad)
            (do ((j (+ n 1) (+ j 1))) ((>= j 64))
              (bytevector-u8-set! buf j 0))
            (cond
             ((< n 56)
              (bytevector-u8-set! buf 63 (extract-byte len 0))
              (bytevector-u8-set! buf 62 (extract-byte len 1))
              (bytevector-u8-set! buf 61 (extract-byte len 2))
              (bytevector-u8-set! buf 60 (extract-byte len 3))
              (bytevector-u8-set! buf 59 (extract-byte len 4))
              (bytevector-u8-set! buf 58 (extract-byte len 5))
              (bytevector-u8-set! buf 57 (extract-byte len 6))
              (bytevector-u8-set! buf 56 (extract-byte len 7)))))))
        ;; Copy block i into the buffer.
        (do ((j 0 (+ j 1)))
            ((= j 16))
          (vector-set! w j (bytevector-u32-ref-be buf (* j 4))))
        ;; Extend the first 16 words into the remaining 48 words
        ;; w[16..63] of the message schedule array:
        (do ((j 16 (+ j 1)))
            ((= j 64))
          (let* ((w15 (vector-ref w (- j 15)))
                 (w2 (vector-ref w (- j 2)))
                 (s0 (bitwise-xor (bitwise-rot-u32 w15 7)
                                  (bitwise-rot-u32 w15 18)
                                  (arithmetic-shift w15 -3)))
                 (s1 (bitwise-xor (bitwise-rot-u32 w2 17)
                                  (bitwise-rot-u32 w2 19)
                                  (arithmetic-shift w2 -10))))
            (vector-set! w j (u32 (+ (vector-ref w (- j 16))
                                     s0
                                     (vector-ref w (- j 7))
                                     s1)))))
        ;; Compression function main loop:
        (let lp ((j 0)
                 (a h0) (b h1)
                 (c h2) (d h3)
                 (e h4) (f h5)
                 (g h6) (h h7))
          (cond
           ((= j 64)
            (let ((a (u32+ h0 a)) (b (u32+ h1 b))
                  (c (u32+ h2 c)) (d (u32+ h3 d))
                  (e (u32+ h4 e)) (f (u32+ h5 f))
                  (g (u32+ h6 g)) (h (u32+ h7 h)))
              (cond
               ((< n 64)
                (if (>= n 56)
                    (chunk (+ i n) 0 a b c d e f g h)
                    (string-append
                     (hex32 a) (hex32 b) (hex32 c) (hex32 d)
                     (hex32 e) (hex32 f) (hex32 g) (if full? (hex32 h) ""))))
               (else
                (chunk (+ i 64) pad a b c d e f g h)))))
           (else
            ;; Step - compute the two sigmas and recurse on the new a-h.
            (let* ((s1 (bitwise-xor (bitwise-rot-u32 e 6)
                                    (bitwise-rot-u32 e 11)
                                    (bitwise-rot-u32 e 25)))
                   (ch (bitwise-xor (bitwise-and e f)
                                    (bitwise-and (bitwise-not e) g)))
                   (temp1 (u32 (+ h s1 ch (vector-ref k j) (vector-ref w j))))
                   (s0 (bitwise-xor (bitwise-rot-u32 a 2)
                                    (bitwise-rot-u32 a 13)
                                    (bitwise-rot-u32 a 22)))
                   (maj (bitwise-xor (bitwise-and a b)
                                     (bitwise-and a c)
                                     (bitwise-and b c)))
                   (temp2 (u32+ s0 maj)))
              (lp (+ j 1)
                  (u32+ temp1 temp2) a b c
                  (u32+ d temp1) e f g)))))))))

(define (sha-224 src)
  (sha-224-256 src sha-224-inits #f))

(define (sha-256 src)
  (sha-224-256 src sha-256-inits #t))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; binary records, simpler version with type-checking on set! removed

(define-syntax defrec
  (syntax-rules (make: pred: read: write: block:)
    ((defrec () n m p r w
       ((field-tmp field-read field-read-expr field-write field-write-expr field-get) ...)
       ((field getter . s) ...))
     (begin
       (define-record-type n (m field ...) p
         (field getter . s) ...)
       (define n 'n)  ; chicken define-record-type doesn't define the rtd
       (define r
         (let ((field-read field-read-expr) ...)
           (lambda (in)
             (let* ((field-tmp (field-read in)) ...)
               (m field ...)))))
       (define w
         (let ((field-write field-write-expr) ...)
           (lambda (x out)
             (field-write (field-get x) out) ...)))))
    ((defrec ((make: x) . rest) n m p r w b f)
     (defrec rest n x p r w b f))
    ((defrec ((pred: x) . rest) n m p r w b f)
     (defrec rest n m x r w b f))
    ((defrec ((read: x) . rest) n m p r w b f)
     (defrec rest n m p x w b f))
    ((defrec ((write: x) . rest) n m p r w b f)
     (defrec rest n m p r x b f))
    ((defrec ((block: (field (type . args) getter . s) . fields) . rest) n m p r w
       (b ...) (f ...))
     (defrec ((block: . fields) . rest) n m p r w
       (b ...
          (field read-tmp (type read: args) write-tmp (type write: args) getter))
       (f ...
          (field getter . s))))
    ((defrec ((block: (field . x)) . rest) n m p r w b f)
     (syntax-error "invalid field in block" (field . x)))
    ((defrec ((block: data . fields) . rest) n m p r w (b ...) f)
     (defrec ((block: . fields) . rest) n m p r w
       (b ...
          (tmp-data read-tmp (read-literal 'data) write-tmp (write-literal 'data) (lambda (x) x)))
       f))
    ((defrec ((block:) . rest) n m p r w b f)
     (defrec rest n m p r w b f))
    ))

(define-syntax define-binary-record-type
  (syntax-rules ()
    ((define-binary-record-type name x ...)
     (defrec (x ...) name hidden-make hidden-pred hidden-read hidden-write
       () ()))))
(define-library (chibi io-test)
  (export run-tests)
  (import (chibi)
          (chibi io)
          (only (scheme base) read-bytevector write-bytevector)
          (only (chibi test) test-begin test test-end))
  (begin
    (define (run-tests)
      (define long-string (make-string 2000 #\a))

      (define (string-upcase str)
        (list->string (map char-upcase (string->list str))))

      (define (strings->input-port str-ls)
        (make-generated-input-port
         (lambda ()
           (and (pair? str-ls)
                (let ((res (car str-ls)))
                  (set! str-ls (cdr str-ls))
                  res)))))

      (define (bytevectors->input-port bv-ls)
        (make-generated-binary-input-port
         (lambda ()
           (and (pair? bv-ls)
                (let ((res (car bv-ls)))
                  (set! bv-ls (cdr bv-ls))
                  res)))))

      (test-begin "io")

      (test "input-string-port" 1025
        (call-with-input-string (substring long-string 0 1025)
          (lambda (in)
            (let loop ((c (read-char in)) (i 0))
              (cond ((eof-object? c) i)
                    ((> i 1025) (error "read past eof"))
                    (else (loop (read-char in) (+ i 1))))))))

      (test "read-line" '("abc" "def")
        (call-with-input-string "abc\ndef\n"
          (lambda (in) (let ((line (read-line in))) (list line (read-line in))))))

      (test "read-line" '("abc" "def" "ghi")
        (call-with-input-string "abcdef\nghi\n"
          (lambda (in)
            (let* ((line1 (read-line in 3))
                   (line2 (read-line in 3)))
              (list line1 line2 (read-line in 3))))))

      (test "read-line-to-eof" '("abc" "def")
        (call-with-input-string "abc\ndef"
          (lambda (in) (let ((line (read-line in))) (list line (read-line in))))))

      (test "read-string" '("abc" "def")
        (call-with-input-string "abcdef"
          (lambda (in)
            (let ((str (read-string 3 in))) (list str (read-string 3 in))))))

      (test "read-string-to-eof" '("abc" "de")
        (call-with-input-string "abcde"
          (lambda (in)
            (let ((str (read-string 3 in))) (list str (read-string 3 in))))))

      (test "read-string" '("ab" "f")
        (call-with-input-string "abf"
          (lambda (in)
            (let ((str (read-string 3 in))) (list str (read-string 3 in))))))

      (test "read-string!" '("abc" "def")
        (call-with-input-string "abcdef"
          (lambda (in)
            (let* ((str1 (make-string 3))
                   (str2 (make-string 3)))
              (read-string! str1 3 in)
              (read-string! str2 3 in)
              (list str1 str2)))))

      (test "read-string!-to-eof" '("abc" "de ")
        (call-with-input-string "abcde"
          (lambda (in)
            (let* ((str1 (make-string 3))
                   (str2 (make-string 3 #\space)))
              (read-string! str1 3 in)
              (read-string! str2 3 in)
              (list str1 str2)))))

      (test "null-output-port" #t
        (let ((out (make-null-output-port)))
          (write 1 out)
          (close-output-port out)
          #t))

      (test "null-input-port" #t
        (let ((in (make-null-input-port)))
          (let ((res (eof-object? (read-char in))))
            (close-input-port in)
            res)))

      (test "upcase-input-port" "ABC"
        (call-with-input-string "abc"
          (lambda (in)
            (let ((in (make-filtered-input-port string-upcase in)))
              (let ((res (read-line in)))
                (close-input-port in)
                res)))))

      (test "upcase-output-port" "ABC"
        (call-with-output-string
          (lambda (out)
            (let ((out (make-filtered-output-port string-upcase out)))
              (display "abc" out)
              (close-output-port out)))))

      (test "abcdef" (read-line (strings->input-port '("abcdef"))))
      (test "abcdef" (read-line (strings->input-port '("abc" "def"))))
      (test "abcdef"
          (read-line (strings->input-port '("a" "b" "c" "d" "e" "f"))))
      (test "" (read-line (strings->input-port '(""))))
      (test "" (read-line (strings->input-port '("" "" ""))))
      (test "abc"
          (let ((in (strings->input-port
                     (list "" (make-string 4087 #\-) "abc"))))
            (read-string 4090 in)
            (read-line in)))
      (test "abc"
          (let ((in (strings->input-port
                     (list "" (make-string 4087 #\) "abc"))))
            (read-string 4090 in)
            (read-line in)))
      (test "abc"
          (let ((in (strings->input-port
                     (list "" (make-string 4093 #\-) "abc"))))
            (read-string 4096 in)
            (read-line in)))

      (test #u8(0 1 2)
        (let ((in (bytevectors->input-port (list #u8(0 1 2)))))
          (read-bytevector 3 in)))

      (test #u8(0 1 2 3 4 5)
        (let ((in (bytevectors->input-port (list #u8(0 1 2) #u8(3 4 5)))))
          (read-bytevector 6 in)))

      (test #u8(3 4 5)
        (let ((in (bytevectors->input-port
                   (list #u8(0 1 2) (make-bytevector 4087 7) #u8(3 4 5)))))
          (read-bytevector 4090 in)
          (read-bytevector 3 in)))

      (test #u8(3 4 5)
        (let ((in (bytevectors->input-port
                   (list #u8(0 1 2) (make-bytevector 4093 7) #u8(3 4 5)))))
          (read-bytevector 4096 in)
          (read-bytevector 3 in)))

      (test #u8(3 4 5)
        (let ((in (bytevectors->input-port
                   (list #u8(0 1 2) (make-bytevector 5000 7) #u8(3 4 5)))))
          (read-bytevector 5003 in)
          (read-bytevector 3 in)))

      (let ((in (make-custom-binary-input-port
                 (let ((i 0))
                   (lambda (bv start end)
                     (do ((j start (+ j 1)))
                         ((= j end))
                       (bytevector-u8-set! bv j (modulo (- (+ j i) start) 256)))
                     (if (> end 0)
                         (set! i (bytevector-u8-ref bv (- end 1))))
                     (- end start))))))
        (test #u8(0 1 2 3) (read-bytevector 4 in))
        (test #u8(4 5 6 7) (read-bytevector 4 in))
        (test 7 (bytevector-u8-ref (read-bytevector 256 in) 255))
        (test 6 (bytevector-u8-ref (read-bytevector 1024 in) 1022)))

      (let* ((sum 0)
             (out (make-custom-binary-output-port
                   (lambda (bv start end)
                     (do ((i start (+ i 1))
                          (x 0 (+ x (bytevector-u8-ref bv i))))
                         ((= i end) (set! sum (+ sum x))))))))
        (write-bytevector #u8(0 1 2 3) out)
        (flush-output out)
        (test 6 sum)
        (write-bytevector #u8(100) out)
        (flush-output out)
        (test 106 sum))

      (let* ((ls '())
             (out (make-custom-output-port
                   (lambda (str start end)
                     (set! ls (cons (substring str start end) ls))
                     (- end start)))))
        (display "Test1\n" out)
        (flush-output out)
        (display "Test2\n" out)
        (flush-output out)
        (display "Test3\n" out)
        (flush-output out)
        (test "Test1\nTest2\nTest3\n" (string-concatenate (reverse ls))))

      (test "file-position"
          '(0 1 2)
        (let* ((p (open-input-file "/etc/passwd"))
               (t0 (file-position p)))
          (read-char p)
          (let ((t1 (file-position p)))
            (read-char p)
            (let ((t2 (file-position p)))
              (close-input-port p)
              (list t0 t1 t2)))))

      (test-end))))
(define-library (chibi generic-test)
  (export run-tests)
  (import (chibi) (chibi generic) (chibi test))
  (begin
    (define (run-tests)
      (test-begin "generics")

      (let ()
        (define-generic add)
        (define-method (add (x number?) (y number?))
          (+ x y))
        (define-method (add (x string?) (y string?))
          (string-append x y))
        (define-method (add x (y list?))
          (append x y))
        (test 4 (add 2 2))
        (test "22" (add "2" "2"))
        (test '(2 2) (add '() '(2 2)))
        (test '(2 2) (add '(2) '(2)))
        (test '(2 2) (add '(2 2) '()))
        (test '(2) (add #f '(2)))
        (test-error (add #(2) #(2))))

      (let ()
        (define-generic mul)
        (define-method (mul (x number?) (y number?))
          (* x y))
        (define-method (mul (x inexact?) (y inexact?))
          (+ (* x y) 0.1))
        (define-method (mul (x exact?) (y exact?))
          (inexact->exact (call-next-method)))
        (test 21 (mul 3 7))
        (test 21.0 (mul 3.0 7))
        (test 21.0 (mul 3 7.0))
        (test 21.1 (mul 3.0 7.0)))

      (test-end))))
(define-library (chibi temp-file)
  (export call-with-temp-file call-with-temp-dir)
  (import (scheme base) (scheme time)
          (chibi filesystem) (chibi pathname))
  (cond-expand
   ((library (srfi 151)) (import (srfi 151)))
   ((library (srfi 33)) (import (srfi 33)))
   (else (import (srfi 60))))
  (cond-expand
   (chibi (import (only (chibi process) current-process-id)))
   (chicken (import (only (posix) current-process-id)))
   (else (begin (define (current-process-id) 0))))
  (include "temp-file.scm"))

(define-library (chibi optional)
  (export let-optionals let-optionals*
          opt-lambda opt-lambda*
          define-opt define-opt*
          let-keywords let-keywords*
          keyword-ref keyword-ref*)
  (cond-expand
   (chibi
    (import (chibi))
    (begin
      (define-syntax symbol->keyword*
        (er-macro-transformer
         (lambda (expr rename compare)
           (if (and (pair? (cdr expr)) (pair? (cadr expr))
                    (compare 'quote (car (cadr expr))))
               `(,(rename 'quote)
                 ,(string->symbol
                   (string-append
                    (symbol->string
                     (identifier->symbol (cadr (cadr expr)))) ":")))
               `(string->symbol
                 (string-append (symbol->string ,(cadr expr)) ":"))))))))
   (else
    (import (scheme base))
    (begin
      (define-syntax let-optionals*
        (syntax-rules ()
          ((let-optionals* opt-ls () . body)
           (begin . body))
          ((let-optionals* (op . args) vars . body)
           (let ((tmp (op . args)))
             (let-optionals* tmp vars . body)))
          ((let-optionals* tmp ((var default) . rest) . body)
           (let* ((tmp2 (if (pair? tmp) (cdr tmp) '()))
                  (var (if (pair? tmp) (car tmp) default)))
             (let-optionals* tmp2 rest . body)))
          ((let-optionals* tmp tail . body)
           (let ((tail (list-copy tmp))) . body))))
      (define-syntax symbol->keyword*
        (syntax-rules ()
          ((symbol->keyword* sym)
           (string->symbol (string-append (symbol->string sym) ":")))
          )))))
  (include "optional.scm"))

;;> Additional bytevector utilities.

(define-library (chibi bytevector)
  (export
   bytevector-u16-ref-le bytevector-u16-ref-be
   bytevector-u32-ref-le bytevector-u32-ref-be
   bytevector-ber-ref bytevector-ber-set!
   bytevector-pad-left
   integer->bytevector bytevector->integer
   integer->hex-string hex-string->integer
   bytevector->hex-string hex-string->bytevector
   bytevector-ieee-single-ref
   bytevector-ieee-single-native-ref
   bytevector-ieee-single-set!
   bytevector-ieee-single-native-set!
   bytevector-ieee-double-ref
   bytevector-ieee-double-native-ref
   bytevector-ieee-double-set!
   bytevector-ieee-double-native-set!
   )
  (import (scheme base) (scheme inexact))
  (cond-expand
   (big-endian
    (begin
      (define-syntax native-endianness
        (syntax-rules () ((_) 'big)))))
   (else
    (begin
      (define-syntax native-endianness
        (syntax-rules () ((_) 'little))))))
  (cond-expand
   ((library (srfi 151)) (import (srfi 151)))
   ((library (srfi 33)) (import (srfi 33)))
   (else (import (srfi 60))))
  (include "bytevector.scm")
  (cond-expand
   (chibi
    (import (except (scheme bytevector) bytevector-copy!)))
   (else
    (include "ieee-754.scm"))))
(define-library (chibi string-test)
  (export run-tests)
  (import (scheme base) (scheme char)
          (chibi test) (chibi string))
  (cond-expand
   (chibi
    (import (only (chibi) string-cursor->index)))
   (else
    (begin
      (define (string-cursor->index str i) i))))
  (begin
    (define (digit-value ch)
      (case ch
        ((#\0) 0) ((#\1) 1) ((#\2) 2) ((#\3) 3) ((#\4) 4)
        ((#\5) 5) ((#\6) 6) ((#\7) 7) ((#\8) 8) ((#\9) 9) (else #f)))
    (define (string-find/index str pred)
      (string-cursor->index str (string-find str pred)))
    (define (string-find-right/index str pred)
      (string-cursor->index str (string-find-right str pred)))
    (define (string-skip/index str pred)
      (string-cursor->index str (string-skip str pred)))
    (define (string-skip-right/index str pred)
      (string-cursor->index str (string-skip-right str pred)))
    (define (run-tests)
      (test-begin "strings")

      (test #t (string-null? ""))
      (test #f (string-null? " "))

      (test #t (string-every char-alphabetic? "abc"))
      (test #f (string-every char-alphabetic? "abc0"))
      (test #f (string-every char-alphabetic? " abc"))
      (test #f (string-every char-alphabetic? "a.c"))

      (test 3 (string-any digit-value "a3c"))
      (test #f (string-any digit-value "abc"))

      (test 0 (string-find/index "abc" char-alphabetic?))
      (test 3 (string-find/index "abc0" char-numeric?))
      (test 3 (string-find/index "abc" char-numeric?))

      (test 3 (string-find-right/index "abc" char-alphabetic?))
      (test 4 (string-find-right/index "abc0" char-numeric?))
      (test 0 (string-find-right/index "abc" char-numeric?))

      (test 0 (string-skip/index "abc" char-numeric?))
      (test 3 (string-skip/index "abc0" char-alphabetic?))
      (test 3 (string-skip/index "abc" char-alphabetic?))

      (test 3 (string-skip-right/index "abc" char-numeric?))
      (test 4 (string-skip-right/index "abc0" char-alphabetic?))
      (test 0 (string-skip-right/index "abc" char-alphabetic?))

      (test "foobarbaz" (string-join '("foo" "bar" "baz")))
      (test "foo bar baz" (string-join '("foo" "bar" "baz") " "))

      (test '() (string-split ""))
      (test '("" "") (string-split " "))
      (test '("foo" "bar" "baz") (string-split "foo bar baz"))
      (test '("foo" "bar" "baz" "") (string-split "foo bar baz "))
      (test '("foo" "bar" "baz") (string-split "foo:bar:baz" #\:))
      (test '("" "foo" "bar" "baz") (string-split ":foo:bar:baz" #\:))
      (test '("foo" "bar" "baz" "") (string-split "foo:bar:baz:" #\:))
      (test '("foo" "bar:baz") (string-split "foo:bar:baz" #\: 2))

      (test "abc" (string-trim-left "  abc"))
      (test "abc  " (string-trim-left "abc  "))
      (test "abc  " (string-trim-left "  abc  "))

      (test "  abc" (string-trim-right "  abc"))
      (test "abc" (string-trim-right "abc  "))
      (test "  abc" (string-trim-right "  abc  "))

      (test "abc" (string-trim "  abc"))
      (test "abc" (string-trim "abc  "))
      (test "abc" (string-trim "  abc  "))
      (test "" (string-trim ""))
      (test "" (string-trim " "))
      (test "" (string-trim "  "))

      (test #t (string-prefix? "abc" "abc"))
      (test #t (string-prefix? "abc" "abcde"))
      (test #f (string-prefix? "abcde" "abc"))

      (test #t (string-suffix? "abc" "abc"))
      (test #f (string-suffix? "abc" "abcde"))
      (test #f (string-suffix? "abcde" "abc"))
      (test #f (string-suffix? "abcde" "cde"))
      (test #t (string-suffix? "cde" "abcde"))

      (test 3 (string-count "!a0 bc /.," char-alphabetic?))

      (test "ABC" (string-map char-upcase "abc"))

      (test-end))))
;; prime.scm -- prime number utilities
;; Copyright (c) 2004-2014 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

;;> Prime and number theoretic utilities.

;; Given \var{n} and a continuation \var{return},
;; returns (\var{return} \var{k2} \var{n2}) where
;; \var{k2} is the power of 2 in the factorization of \var{n}, and
;; \var{n2} is product of all other prime powers dividing \var{n}
(define (factor-twos n return)
  (let ((b (first-set-bit n)))
    (return b (arithmetic-shift n (- b)))))

;;> Returns the multiplicative inverse of \var{a} modulo \var{b}.
(define (modular-inverse a b)
  (let lp ((a1 a) (b1 b) (x 0) (y 1) (last-x 1) (last-y 0))
    (if (zero? b1)
        (if (negative? last-x) (+ last-x b) last-x)
        (let ((q (quotient a1 b1)))
          (lp b1 (remainder a1 b1)
              (- last-x (* q x)) (- last-y (* q y))
              x y)))))

;;> Returns (remainder (expt a e) m).
(define (modular-expt a e m)
  (let lp ((tmp a) (e e) (res 1))
    (if (zero? e)
        res
        (lp (remainder (* tmp tmp) m)
            (arithmetic-shift e -1)
            (if (odd? e) (remainder (* res tmp) m) res)))))

;;> Returns true iff n and m are coprime.
(define (coprime? n m)
  (= 1 (gcd n m)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Exact prime testing.

;; All primes under 1000.
(define prime-table
  '#(  2   3   5   7  11  13  17  19  23  29  31  37  41  43  47  53  59
      61  67  71  73  79  83  89  97 101 103 107 109 113 127 131 137 139
     149 151 157 163 167 173 179 181 191 193 197 199 211 223 227 229 233
     239 241 251 257 263 269 271 277 281 283 293 307 311 313 317 331 337
     347 349 353 359 367 373 379 383 389 397 401 409 419 421 431 433 439
     443 449 457 461 463 467 479 487 491 499 503 509 521 523 541 547 557
     563 569 571 577 587 593 599 601 607 613 617 619 631 641 643 647 653
     659 661 673 677 683 691 701 709 719 727 733 739 743 751 757 761 769
     773 787 797 809 811 821 823 827 829 839 853 857 859 863 877 881 883
     887 907 911 919 929 937 941 947 953 967 971 977 983 991 997 ))

;;> Returns true iff \var{n} is definitely prime.  May take an
;;> impossibly long time for large values.
(define (provable-prime? n)
  (if (or (even? n) (<= n 2))
      (= 2 n)
      (let ((limit (exact (ceiling (sqrt n)))))
        (define (by-twos d)
          (cond ((> d limit) #t)
                ((zero? (remainder n d)) #f)
                (else (by-twos (+ d 2)))))
        (let ((len (vector-length prime-table)))
          (let lp ((i 0))
            (if (>= i len)
                (by-twos (vector-ref prime-table (- len 1)))
                (let ((d (vector-ref prime-table i)))
                  (cond
                   ((> d limit) #t)
                   ((zero? (remainder n d)) #f)
                   (else (lp (+ i 1)))))))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Probable primes.

;; Given \var{n}, return a predicate that tests whether
;; its argument \var{a} is a witness for \var{n} not being prime,
;; either (1) because \var{a}^(\var{n}-1)1 mod \var{n}
;; \em{or} (2) because \var{a}'s powers include
;; a third square root of 1 beyond {1, -1}
(define (miller-rabin-witnesser n)
  (let ((neg1 (- n 1)))
    (factor-twos neg1
     (lambda (twos odd)
       (lambda (a)
         (let ((b (modular-expt a odd n)))
           (let lp ((i 0) (b b))
             (cond ((= b neg1)
                    ;; found -1 (expected sqrt(1))
                    #f)
                   ((= b 1)
                    ;; !! (previous b)^2=1 and was not 1 or -1
                    (not (zero? i)))
                   ((>= i twos)
                    ;; !! a^(n-1)!=1 mod n
                    )
                   (else
                    (lp (+ i 1) (remainder (* b b) n)))))))))))

;;> Returns true if we can show \var{n} to be composite
;;> using the Miller-Rabin test (i.e., finding a witness \var{a}
;;> where \var{a}^(\var{n}-1)1 mod \var{n} or \var{a} reveals
;;> the existence of a 3rd square root of 1 in \b{Z}/(n))
(define (miller-rabin-composite? n)
  (let* ((witness? (miller-rabin-witnesser n))
         ;; Each iteration of Miller Rabin reduces the odds by 1/4, so
         ;; this is a 1 in 2^40 probability of false positive,
         ;; assuming good randomness from SRFI 27 and no bugs, further
         ;; reduced by preliminary sieving.
         (fixed-limit 16)
         (rand-limit (if (< n 341550071728321) fixed-limit 20)))
    (let try ((i 0))
      (and (< i rand-limit)
           (or (witness? (if (< i fixed-limit)
                             (vector-ref prime-table i)
                             (+ (random-integer (- n 3)) 2)))
               (try (+ i 1)))))))

;;> Returns true if \var{n} has a very high probability (enough that
;;> you can assume a false positive will never occur in your lifetime)
;;> of being prime.
(define (probable-prime? n)
  (cond
   ((< n 1) #f)
   (else
    (let ((len (vector-length prime-table)))
      (let lp ((i 0))
        (if (>= i len)
            (not (miller-rabin-composite? n))
            (let ((x (vector-ref prime-table i)))
              (cond
               ((>= x n) (= x n))
               ((zero? (remainder n x)) #f)
               (else (lp (+ i 1)))))))))))

;;> Returns true iff \var{n} is prime.  Uses \scheme{provable-prime?}
;;> for small \var{n}, falling back on \scheme{probable-prime?} for
;;> large values.
(define (prime? n)
  (and (> n 1)
       (if (< n #e1e10)
           (provable-prime? n)
           (probable-prime? n))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Prime iteration and factorization

;;> Returns the nth prime, with 2 being the 0th prime.
(define (nth-prime i)
  (define (by-twos n j)
    (if (prime? n)
        (if (<= j 0) n (by-twos (+ n 2) (- j 1)))
        (by-twos (+ n 2) j)))
  (let ((len (vector-length prime-table)))
    (if (< i len)
        (vector-ref prime-table i)
        (by-twos (+ 2 (vector-ref prime-table (- len 1))) (- i len)))))

;;> Returns the first prime less than or equal to \var{n}, or #f if
;;> there are no such primes.
(define (prime-below n)
  (cond
   ((> n 3)
    (let lp ((n (if (even? n) (- n 1) (- n 2))))
      (if (prime? n) n (lp (- n 2)))))
   ((= n 3)
    2)
   (else
    #f)))

;;> Returns the first prime greater than or equal to \var{n}.  If the
;;> optional \var{limit} is given and not false, returns \scheme{#f}
;;> if no such primes exist below \var{limit}.
(define (prime-above n . o)
  (let ((limit (and (pair? o) (car o))))
    (cond
     ((< n 2)
      2)
     (limit
      (let lp ((n (if (even? n) (+ n 1) (+ n 2))))
        (cond
         ((>= n limit) #f)
         ((prime? n) n)
         (else (lp (+ n 2))))))
     (else
      (let lp ((n (if (even? n) (+ n 1) (+ n 2))))
        (cond
         ((prime? n) n)
         (else (lp (+ n 2)))))))))

;; Given an initial value \var{r1} representing the (empty)
;; factorization of 1 and a procedure \var{put}
;; (called as \scheme{(\var{put} \var{r} \var{p} \var{k})})
;; that, given prior representation \var{r},
;; adds a prime factor \var{p} of multiplicity \var{k},
;; returns a factorization function which returns the factorization
;; of its non-zero integer argument \var{n} in this representation.
;; The optional 3rd and 4th arguments, if provided, specialize \var{put}
;; for particular primes:
;; \var{put2}  for \var{p}=2,  called as \scheme{(\var{put2} \var{r} \var{k})})
;; \var{put-1} for \var{p}=-1, called as \scheme{(\var{put-1} \var{r})}).
(define (make-factorizer r1 put . o)
  (let-optionals o ((put2  (lambda (r k) (put r  2 k)))
                    (put-1 (lambda (r)   (put r -1 1))))
    (lambda (n)
      (when (zero? n)
        (error "cannot factor 0"))
      (factor-twos
       n
       (lambda (k2 n)
         (let lp ((i 3) (ii 9)
                  (n (abs n))
                  (res (let ((res (if (negative? n) (put-1 r1) r1)))
                         (if (zero? k2) res (put2 res k2)))))
           (let next-i ((i i) (ii ii))
             (cond ((> ii n)
                    (if (= n 1) res (put res n 1)))
                   ((not (zero? (remainder n i)))
                    (next-i (+ i 2) (+ ii (* (+ i 1) 4))))
                   (else
                    (let rest ((n (quotient n i))
                               (k 1))
                      (if (zero? (remainder n i))
                          (rest (quotient n i) (+ k 1))
                          (lp (+ i 2) (+ ii (* (+ i 1) 4))
                              n (put res i k)))))))))))))

;;> Returns the factorization of \var{n} as a list of
;;> elements of the form \scheme{(\var{p} . \var{k})},
;;> where \var{p} is a prime factor
;;> and \var{k} is its multiplicity.
(define factor-alist
  (let ((rfactor (make-factorizer '()
                  (lambda (l p k) (cons (cons p k) l)))))
    (lambda (n) (reverse (rfactor n)))))

;;> Returns the factorization of \var{n} as a monotonically
;;> increasing list of primes.
(define factor
  (let ((rfactor (make-factorizer '()
                  (lambda (l p k) (cons (make-list k p) l)))))
    (lambda (n) (concatenate! (reverse (rfactor n))))))

;;> The Euler totient (\var{n}) is the number of positive
;;> integers less than or equal to \var{n} that are
;;> relatively prime to \var{n}.
(define totient
  (make-factorizer 1
   (lambda (tot p k)
     (* tot (- p 1) (expt p (- k 1))))
   (lambda (tot k)
     (arithmetic-shift tot (- k 1)))
   (lambda (_)
     (error "totient of negative number?"))))

;;> The aliquot sum s(\var{n}) is
;;> the sum of proper divisors of a positive integer \var{n}.
(define aliquot
  (let ((aliquot+n
         (make-factorizer 1
          (lambda (aliq p k)
            (* aliq (quotient (- (expt p (+ k 1)) 1) (- p 1))))
          (lambda (aliq k)
            (- (arithmetic-shift aliq (+ k 1)) aliq))
          (lambda (_)
            (error "aliquot of negative number?")))))
    (lambda (n) (- (aliquot+n n) n))))


;;> Returns true iff \var{n} is a perfect number, i.e. the sum of its
;;> divisors other than itself equals itself.
(define (perfect? n)
  (and (> n 1) (= n (aliquot n))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Random prime generation

;;> Returns a random prime between \var{lo}, inclusive, and \var{hi},
;;> exclusive.
(define (random-prime lo hi)
  (if (> lo hi)
      (error "bad range: " lo hi))
  (let ((n (bitwise-ior 1 (+ lo (random-integer (- hi lo))))))
    (or (prime-above n hi)
        (prime-above lo n)
        (error "couldn't find prime between: " lo hi))))

;;> Variant of \scheme{random-prime} which ensures the result is
;;> distinct from \var{p}.
(define (random-prime-distinct-from lo hi p)
  (let ((q (random-prime lo hi)))
    (if (= q p)
        (random-prime-distinct-from lo hi p)
        q)))

;;> Returns a random integer less than \var{n} relatively prime to
;;> \var{n}.
(define (random-coprime n)
  (let ((init (+ 2 (random-integer (- n 1)))))
    (let lp ((m init))
      (cond ((>= m n)
             (let lp ((m (- init 1)))
               (cond
                ((<= m 1) (error "couldn't find coprime to " n))
                ((coprime? n m) m)
                (else (lp (- m 1))))))
            ((coprime? n m) m)
            (else (lp (+ m 1)))))))

(define-library (chibi math prime)
  (import (scheme base) (scheme inexact) (chibi optional) (srfi 1) (srfi 27))
  (cond-expand
   ((library (srfi 151)) (import (srfi 151)))
   ((library (srfi 33)) (import (srfi 33)))
   (else (import (srfi 60))))
  (export prime? nth-prime prime-above prime-below
          factor factor-alist perfect?
          totient aliquot
          provable-prime? probable-prime?
          random-prime random-prime-distinct-from
          coprime? random-coprime modular-inverse modular-expt
          miller-rabin-composite?)
  (include "prime.scm"))
(define-library (chibi math prime-test)
  (export run-tests)
  (import (scheme base) (chibi math prime) (chibi test))
  (begin
    (define (run-tests)

      (test-begin "prime")

      (test 7 (modular-inverse 3 10))
      (test 4 (modular-inverse 3 11))
      (test 27 (modular-inverse 3 40))
      (test 43 (modular-inverse 3 64))

      (test #f (prime? 1))
      (test #t (prime? 2))
      (test #t (prime? 3))
      (test #f (prime? 4))
      (test #t (prime? 5))
      (test #f (prime? 6))
      (test #t (prime? 7))
      (test #f (prime? 8))
      (test #f (prime? 9))
      (test #f (prime? 10))
      (test #t (prime? 11))

      (test 2 (nth-prime 0))
      (test 3 (nth-prime 1))
      (test 5 (nth-prime 2))
      (test 7 (nth-prime 3))
      (test 11 (nth-prime 4))
      (test 997 (nth-prime 167))
      (test 1009 (nth-prime 168))
      (test 1013 (nth-prime 169))

      (test 2 (prime-above 1))
      (test 3 (prime-above 2))
      (test 5 (prime-above 3))
      (test 5 (prime-above 4))
      (test 7 (prime-above 5))
      (test 907 (prime-above 888))
      (test 911 (prime-above 907))
      (test-not (prime-below 2))
      (test 2 (prime-below 3))
      (test 3 (prime-below 4))
      (test 3 (prime-below 5))
      (test 5 (prime-below 6))
      (test 5 (prime-below 7))
      (test 797 (prime-below 808))

      (test 1 (totient 1))
      (test 1 (totient 2))
      (test 2 (totient 3))
      (test 2 (totient 4))
      (test 4 (totient 5))
      (test 2 (totient 6))
      (test 6 (totient 7))
      (test 4 (totient 8))
      (test 6 (totient 9))
      (test 4 (totient 10))
      (test-error (totient 0))

      (test #f (perfect? 1))
      (test #f (perfect? 2))
      (test #f (perfect? 3))
      (test #f (perfect? 4))
      (test #f (perfect? 5))
      (test #t (perfect? 6))
      (test #f (perfect? 7))
      (test #f (perfect? 8))
      (test #f (perfect? 9))
      (test #f (perfect? 10))
      (test #t (perfect? 28))
      (test #t (perfect? 496))
      (test #t (perfect? 8128))

      (test '() (factor 1))
      (test '(2) (factor 2))
      (test '(3) (factor 3))
      (test '(2 2) (factor 4))
      (test '(5) (factor 5))
      (test '(2 3) (factor 6))
      (test '(7) (factor 7))
      (test '(2 2 2) (factor 8))
      (test '(3 3) (factor 9))
      (test '(2 5) (factor 10))
      (test '(11) (factor 11))
      (test '(2 2 3) (factor 12))
      (test '(2 3 3) (factor 18))
      (test '(2 2 2 3 3) (factor 72))
      (test '(3 3 3 5 7) (factor 945))
      (test-error (factor 0))

      (test '() (factor-alist 1))
      (test '((2 . 3) (3 . 2)) (factor-alist 72))
      (test '((3 . 3) (5 . 1) (7 . 1)) (factor-alist 945))
      (test-error (factor-alist 0))

      (test 0 (aliquot 1))
      (test 975 (aliquot 945))
      (test-error (aliquot 0))

      (do ((i 3 (+ i 2)))
          ((>= i 101))
        (test (number->string i) (prime? i)
          (probable-prime? i)))

      (test #t (probable-prime? 4611686020149081683))
      (test #t (probable-prime? 4611686020243253179))
      (test #t (probable-prime? 4611686020243253219))
      (test #t (probable-prime? 4611686020243253257))
      (test #f (probable-prime? 4611686020243253181))
      (test #f (probable-prime? 4611686020243253183))
      (test #f (probable-prime? 4611686020243253247))

      (test 5
          (modular-expt 7670626353261554806
                        5772301760555853353
                        (* 2936546443 3213384203)))

      (test "Miller-Rabin vs. Carmichael prime"
            #t (miller-rabin-composite? 118901521))

      (test-end))))
;;> Unified command-line option parsing and config management.

(define-library (chibi app)
  (export parse-option parse-options parse-app run-application
          app-help app-help-command)
  (import (scheme base)
          (scheme read)
          (scheme write)
          (scheme process-context)
          (srfi 1)
          (chibi config)
          (chibi edit-distance)
          (chibi string))
  (include "app.scm"))

(define-library (chibi equiv)
  (export equiv?)
  (import (chibi))
  (import (srfi 69))
  (include "equiv.scm"))

(define (static-url cfg path)
  (make-path "/s" path))

(define (static-local-path cfg path)
  (make-path (conf-get cfg 'doc-root ".") "s" path))

(define (maybe-parse-hex x)
  (if (string? x) (hex-string->bytevector x) x))

(define valid-email?
  ;; Conservatively match local parts allowed by hotmail, removing
  ;; the restriction on ".." as allowed by Japanese phone providers.
  (let ((re (regexp
             '(: (+ (or alphanumeric #\_ #\- #\. #\+ #\= #\& #\'))
                 "@" (+ (or alphanumeric #\_ #\-))
                 (+ "." (+ (or alphanumeric #\_ #\-)))))))
    (lambda (str) (regexp-matches? re str))))

(define (extract-snowball-package bv)
  (define (path-top path)
    (substring-cursor path (string-cursor-start path) (string-find path #\/)))
  (guard (exn
          (else
           (log-error "couldn't extract package.scm: " exn)
           #f))
    (cond
     ((tar-safe? bv)
      (let* ((files (tar-files bv))
             (dir (path-top (car files)))
             (pkg-path (make-path dir "package.scm")))
        (cond
         ((member pkg-path files)
          (read (open-input-bytevector
                 (tar-extract-file bv pkg-path))))
         (else
          (log-error "no package.scm in " dir)
          #f))))
     (else
      (log-error "tar-bomb")
      #f))))

(define escape-path
  (lambda (str)
    (let ((re (regexp '(w/ascii (~ (or alphanumeric #\_ #\- #\.))))))
      (regexp-replace
       re
       str
       (lambda (m)
         (let ((n (char->integer
                   (string-ref (regexp-match-submatch m 0) 0))))
           (string-append
            "%"
            (if (< n 16) "0" "")
            (number->string n 16))))))))

(define (x->string x)
  (cond ((string? x) x)
        ((symbol? x) (symbol->string x))
        ((number? x) (number->string x))
        (else (error "not stringable" x))))

(define (email->path str)
  (let ((ls (string-split str #\@)))
    (make-path (escape-path (cadr ls)) (escape-path (car ls)))))

(define (repo-publishers cfg)
  (filter (lambda (x) (and (pair? x) (eq? 'publisher (car x))))
          (cdr (current-repo cfg))))

(define (invalid-signature-reason cfg sig-spec snowball)
  (let* ((digest-name (assoc-get (cdr sig-spec) 'digest #f 'sha-256))
         (digest (assoc-get (cdr sig-spec) digest-name))
         (actual-digest ((lookup-digest digest-name) snowball))
         (sig (assoc-get (cdr sig-spec) 'rsa))
         (email (assoc-get (cdr sig-spec) 'email))
         (publisher (find (rsa-identity=? email)
                          (repo-publishers cfg)))
         (verify-rsa? (conf-get cfg 'verify-signatures?))
         (rsa-key (and verify-rsa?
                       (pair? publisher)
                       (extract-rsa-public-key (cdr publisher)))))
    (cond
     ((not (equal? digest actual-digest))
      (string-append "the " digest-name " digest in the signature <" digest
                     "> didn't match the actual value: <" actual-digest ">"))
     ((not publisher)
      (string-append "unknown publisher: " email))
     ((and verify-rsa?
           (not (rsa-verify? rsa-key
                             (maybe-parse-hex digest)
                             (maybe-parse-hex sig))))
      (log-error "digest: " digest " sig: " (maybe-parse-hex sig)
                 " verify: " (rsa-encrypt rsa-key digest))
      "rsa signature did not match")
     (else
      #f))))

(define (get-user-password cfg email)
  (let* ((user-dir (static-local-path cfg (email->path email)))
         (key-file (make-path user-dir "pub-key"))
         (key (guard (exn (else #f)) (call-with-input-file key-file read))))
    (and (pair? key) (assoc-get key 'password))))

(define (package-dir email pkg . o)
  (make-path
   (email->path email)
   (string-join (map escape-path (map x->string (package-name pkg))) "/")
   (escape-path (if (pair? o) (car o) (package-version pkg)))))

;; Simplistic pretty printing for package/repository/config declarations.
(define (write-simple-pretty pkg out)
  (let wr ((ls pkg) (indent 0) (tails 0))
    (cond
     ((and (pair? ls)
           (pair? (cdr ls))
           (pair? (cadr ls)))
      (display (make-string indent #\space) out)
      (write-char #\( out)
      (write (car ls) out)
      (newline out)
      (for-each (lambda (x) (wr x (+ indent 2) 0)) (drop-right (cdr ls) 1))
      (wr (last ls) (+ indent 2) (+ tails 1)))
     (else
      (display (make-string indent #\space) out)
      (write ls out)
      (display (make-string tails #\)) out)
      (newline out)))))

(define (file-lock-loop port-or-fd mode)
  (let lp ()
    (cond
     ((file-lock port-or-fd mode))
     ((memv (errno) '(11 35)) (thread-sleep! 0.01) (lp))
     (else (error "couldn't lock file" (integer->error-string))))))

(define (call-with-locked-file path proc . o)
  (let ((fd (open path
                  (+ open/create open/read-write)
                  (if (pair? o) (car o) #o644))))
    (file-lock-loop fd (+ lock/exclusive lock/non-blocking))
    (exception-protect (proc fd) (file-lock fd lock/unlock))))

;; Rewrites file in place with the result of (proc orig-contents),
;; synchronized with file-lock.
(define (synchronized-rewrite-text-file path proc . o)
  (call-with-locked-file
   path
   (lambda (fd)
     (let* ((in (open-input-file-descriptor fd))
            (out (open-output-file-descriptor fd))
            (str (port->string in))
            (res (proc str)))
       (set-file-position! out seek/set 0)
       (display res out)
       (file-truncate out (string-size res))
       (close-output-port out)
       res))))

(define (synchronized-rewrite-sexp-file path proc . o)
  (apply synchronized-rewrite-text-file
         path
         (lambda (str)
           (let ((x (call-with-input-string str read)))
             (call-with-output-string
               (lambda (out) (write-simple-pretty (proc x) out)))))
         o))

(define (current-repo cfg)
  (call-with-input-file (static-local-path cfg "repo.scm") read))

(define (rewrite-repo cfg proc)
  (synchronized-rewrite-sexp-file
   (static-local-path cfg "repo.scm")
   proc
   "(repository)"))

(define (update-repo cfg rem-pred value)
  (rewrite-repo
   cfg
   (lambda (repo)
     (let*-values (((repo) (if (pair? repo) repo '(repository)))
                   ((drop keep) (partition rem-pred (cdr repo))))
       `(,(car repo)
         ,(if (procedure? value) (value repo drop) value)
         ,@keep)))))

(define (update-repo-object cfg key-field value)
  (let* ((type (car value))
         (key-value (assoc-get (cdr value) key-field eq?))
         (pred
          (lambda (x)
            (and (pair? x)
                 (eq? type (car x))
                 (equal? key-value (assoc-get (cdr x) key-field eq?))))))
    (update-repo cfg pred value)))

(define (update-repo-package cfg pkg . o)
  (let* ((email (package-email pkg))
         (auth-pred (lambda (x) (equal? email (package-email x))))
         (pkg-pred
          (cond
           ((package-name pkg)
            => (lambda (name)
                 (lambda (x) (equal? name (package-name x)))))
           (else
            (let ((libs (map (lambda (x) (assoc-get (cdr x) 'name eq?))
                             (package-libraries pkg))))
              (lambda (x)
                (every (lambda (y)
                         (member (assoc-get (cdr x) 'name eq?) libs))
                       (package-libraries x)))))))
         (rem-pred
          (lambda (x)
            (and (pair? x) (eq? 'package (car x))
                 (auth-pred x) (pkg-pred x))))
         (value (if (pair? o) (lambda (repo drop) ((car o) repo drop pkg)) pkg)))
    (update-repo cfg rem-pred value)))

(define (fail msg . args)
  `(span (@ (style . "background:red")) ,msg ,@args))

(define (page body . o)
  `(html
    (head
     (title "Snow")
     (meta (@ (charset . "utf-8")))
     (link (@ (type . "text/css")
              (rel . "stylesheet")
              (href . "/s/snow.css")))
     (link (@ (rel . "shortcut icon")
              (href . "/s/favicon.ico")))
     ,@o)
    (body
     (div (@ (id . "head"))
          (div (@ (id . "head_pic")) "")
          (div (@ (id . "head_name")) (b "Snow")))
     (div (@ (id . "toolbar"))
          (nav (@ (id . "menu"))
               (a (@ (href . "/")) "Home")
               (a (@ (href . "/pkg")) "Libraries")
               (a (@ (href . "/doc")) "Docs")
               (a (@ (href . "/link")) "Resources")
               (a (@ (href . "/faq")) "FAQ"))
          (div (@ (id . "search"))
               (form
                 (@ (action . "http://www.google.com/search"))
                 (input (@ (type . "text") (name . "q")))
                 (input (@ (type . "hidden")
                           (name . "domains")
                           (value . "snow-fort.org")))
                 (input (@ (type . "hidden")
                           (name . "sitesearch")
                           (value . "snow-fort.org")))
                 (input (@ (type . "submit")
                           (name . "search")
                           (value . "Search Libraries"))))))
     ,body)))

(define (dependency-url cfg dep . o)
  (if (and (eq? 'srfi (car dep))
           (pair? (cdr dep))
           (integer? (cadr dep))
           (null? (cddr dep)))
      (string-append "https://srfi.schemers.org/srfi-"
                     (number->string (cadr dep))
                     "/")
      ;; TODO: alternative impls
      (let* ((repo (if (pair? o) (car o) (current-repo cfg)))
             (pkg (find (lambda (p)
                          (and (package? p)
                               (any (lambda (m) (equal? dep (library-name m)))
                                    (package-libraries p))))
                        (cdr repo))))
        (and pkg
             (make-path "/s" (package-dir (package-email pkg) pkg "latest"))))))

(define (package-page pkg files . o)
  (let* ((cfg (if (pair? o) (car o) (make-conf '() #f #f 0)))
         (repo (if (and (pair? o) (pair? (cdr o)))
                   (cadr o)
                   (current-repo cfg))))
    `(div
      (div " " (b ,(package-name pkg)) " - " (i ,(package-version pkg)))
      (div ,(or (assoc-get pkg 'description) ""))
      ,(let ((auth (package-author '() pkg))
             (maint (package-maintainer '() pkg)))
         `(div ,auth
               ,@(if (and maint (not (equal? maint auth)))
                     `((" (" ,maint ")"))
                     '())
               ,(cond ((assoc-get pkg 'license)
                       => (lambda (x)
                            (string-append " - " (write-to-string x))))
                      (else ""))))
      ,@(cond
         ((assq 'manual (cdr pkg))
          => (lambda (ls)
               (if (and (pair? ls) (pair? (cdr ls)))
                   (if (or (string-prefix? "http:" (cadr ls))
                           (string-prefix? "https:" (cadr ls)))
                       `((a (@ (href . ,(cadr ls))) "doc"))
                       `((a (@ (href . ,(make-path "files" (cadr ls))))
                            "Documentation")))
                   '())))
         (else '()))
      (div
       (b "Dependencies")
       (ul
        ,@(map
           (lambda (dep)
             `(li (a (@ (href . ,(dependency-url cfg dep repo)))
                     ,(write-to-string dep))))
           (filter
            (lambda (dep)
              (and (pair? dep) (not (eq? 'scheme (car dep)))))
            (package-dependencies 'chibi cfg pkg)))))
      (div
       (b "Files")
       (ul
        ,@(map
           (lambda (file) `(li (a (@ (href . ,(make-path "files" file))) ,file)))
           (filter
            (lambda (file)
              (and (string? file)
                   (not (equal? "" file))
                   (not (string-prefix? "." file))))
            files)))))))

(define (respond cfg request proc)
  (let ((sexp? (equal? "sexp" (request-param request "fmt"))))
    (servlet-write
     request
     (cond
      (sexp?
       (call-with-current-continuation proc))
      (else
       (let ((res (sxml->xml (proc (lambda (x) x)))))
         (servlet-respond request 200 "OK"
                          '((Content-Type . "text/html; charset=utf-8")))
         res))))
    (if sexp? (servlet-write request "\n"))))

(define-library (chibi snow interface)
  (export warn info message die input input-password input-number yes-or-no?
          restore-history save-history)
  (import (scheme base) (scheme char) (scheme read) (scheme write)
          (scheme file) (scheme process-context) (srfi 1)
          (chibi config) (chibi pathname) (chibi show)
          (chibi term edit-line))
  (cond-expand
   (chibi
    (import (chibi filesystem)))
   (chicken
    (import posix)
    (begin
      (define (create-directory* dir) (create-directory dir #t))))
   (sagittarius
    (import (only (sagittarius) create-directory)
            (chibi string))
    (begin
      (define (create-directory* dir . o)
        (let ((mode (if (pair? o) (car o) #o755)))
          (or (file-directory? dir)
              (create-directory dir mode)
              (let* ((start (string-cursor-start dir))
                     (slash
                      (string-find-right dir #\/ start
                                         (string-skip-right dir #\/))))
                (and (string-cursor>? slash start)
                     (let ((parent (substring-cursor dir start slash)))
                       (and (not (equal? parent dir))
                            (not (file-exists? parent))
                            (create-directory* parent mode)
                            (create-directory dir mode)))))))))))
  (include "interface.scm"))
;; utilities for the snow repo server

(define-library (chibi snow fort)
  (export fail page respond static-url static-local-path
          escape-path email->path maybe-parse-hex
          valid-email? valid-package?
          extract-snowball-package package-dir
          invalid-signature-reason
          rewrite-repo update-repo
          update-repo-package update-repo-object
          repo-publishers current-repo get-user-password
          dependency-url package-page)
  (import (scheme base)
          (scheme read)
          (scheme write)
          (scheme file)
          (srfi 1)
          (srfi 18)
          (chibi snow package)
          (chibi snow utils)
          (chibi bytevector)
          (chibi config)
          (chibi crypto rsa)
          (chibi filesystem)
          (chibi io)
          (chibi log)
          (chibi net servlet)
          (chibi pathname)
          (chibi regexp)
          (chibi string)
          (chibi sxml)
          (chibi tar))
  (cond-expand
   ((library (srfi 151)) (import (srfi 151)))
   ((library (srfi 33)) (import (srfi 33)))
   (else (import (srfi 60))))
  (cond-expand
   (chibi
    (import (only (chibi ast)
                  errno integer->error-string)
            (only (chibi)
                  string-size exception-protect)))
   (else
    (begin
      (define (errno) 0)
      (define (integer->error-string n)
        (string-append "errno: " (number->string n)))
      (define string-size string-length)
      (define (with-exception-protect thunk final)
        (let* ((finalized? #f)
               (run-finalize
                (lambda ()
                  (cond ((not finalized?)
                         (set! finalized? #t)
                         (final))))))
          (guard (exn (else (run-finalize) (raise exn)))
            (let ((res (thunk)))
              (run-finalize)
              res))))
      (define-syntax exception-protect
        (syntax-rules ()
          ((exception-protect expr final)
           (with-exception-protect (lambda () expr)  (lambda () final))))))))
  (include "fort.scm"))

(define-library (chibi snow package)
  (export package? library? program?
          package-name package-email package-url package-version
          package-libraries package-programs package-data-files
          package-provides? package-dependencies package-test-dependencies
          package-installed-files package-author package-maintainer
          package-digest-mismatches package-signature-mismatches
          package-digest-ok? package-signature-ok?
          package->path package-name->meta-file
          package-file-meta package-file? package-file-top-directory
          package-file-unzipped
          get-package-meta-file get-library-meta-file
          library-name->path library->path get-library-file find-library-file
          library-url library-name parse-library-name library-name->path
          library-analyze library-include-files library-dependencies
          library-shared-include-files library-foreign-dependencies
          library-rewrite-includes library-file-name
          get-program-file program-name program-install-name
          invalid-package-reason valid-package?
          invalid-library-reason valid-library?
          invalid-program-reason valid-program?
          repo-find-publisher lookup-digest rsa-identity=?
          extract-rsa-private-key extract-rsa-public-key)
  (import (scheme base)
          (scheme char)
          (scheme file)
          (scheme read)
          (scheme write)
          (srfi 1)
          (srfi 115)
          (chibi snow interface)
          (chibi snow utils)
          (chibi bytevector)
          (chibi config)
          (chibi crypto md5)
          (chibi crypto rsa)
          (chibi crypto sha2)
          (chibi pathname)
          (chibi process)
          (chibi string)
          (chibi tar)
          (chibi uri)
          (chibi zlib))
  (include "package.scm"))
;; commands.scm -- snow commands
;;
;; This code was written by Alex Shinn in 2014 and placed in the
;; Public Domain.  All warranties are disclaimed.

(define (impl-available? cfg spec confirm?)
  (if (find-in-path (cadr spec))
      (or (null? (cddr spec))
          (not (third spec))
          (conf-get cfg 'skip-version-checks?)
          (let ((version (impl->version (car spec) (third spec))))
            (or (and version (version>=? version (fourth spec)))
                (let ((msg
                       (string-append
                        "Implementation " (symbol->string (car spec))
                        (if (string? version)
                            (string-append " is an unsupported version, "
                                           version)
                            " is an unknown version")
                        ", but at least " (fourth spec) " is required.")))
                  (cond
                   (confirm?
                    (yes-or-no? cfg msg " Install anyway?"))
                   (else
                    (warn msg)
                    #f))))))
      (and confirm?
           (yes-or-no? cfg "Implementation " (car spec) " does not "
                       " seem to be available, install anyway?"))))

(define (conf-selected-implementations cfg)
  (let ((requested (conf-get-list cfg 'implementations '(chibi))))
    (let lp ((ls (if (memq 'all requested)
                     (append (map car known-implementations)
                             (delete 'all requested))
                     requested))
             (res '()))
      (cond
       ((null? ls)
        (if (null? res)
            (warn "no implementations available"))
        (reverse res))
       ((memq (car ls) res)
        (lp (cdr ls) res))
       ((assq (car ls) known-implementations)
        => (lambda (x)
             (cond
              ((or (cond-expand (chibi (eq? 'chibi (car ls))) (else #f))
                   (impl-available? cfg x #t))
               (lp (cdr ls) (cons (car ls) res)))
              (else
               (warn "ignoring unavailable implementation" (car ls))
               (lp (cdr ls) res)))))
       ((yes-or-no? cfg "Unknown implementation: " (car ls)
                    " - try to install anyway?")
        (lp (cdr ls) (cons (car ls) res)))
       (else
        (warn "ignoring unknown implementation: " (car ls))
        (lp (cdr ls) res))))))

(define (conf-program-implementation? impl cfg)
  (cond ((conf-get cfg 'program-implementation)
         => (lambda (x) (eq? impl x)))
        (else
         (let ((ls (conf-selected-implementations cfg)))
           (or (null? ls) (eq? impl (car ls)))))))

(define (conf-for-implementation cfg impl)
  (conf-specialize cfg 'implementation impl))

;; Hack to evaluate an expression in a separate process with a larger
;; default heap.  The expression and result must be serializable with
;; write, and imports should be an argument list for environment.
;; Currently only used when generating keys and signing.
(define (fast-eval expr imports . o)
  (let* ((heap-size (if (pair? o) (car o) 500))
         (cmd
          `("chibi-scheme"
            ,(string-append "-h" (number->string heap-size) "M")
            ,@(map
               (lambda (i)
                 (string-append "-m" (string-join (map write-to-string i) ".")))
               imports)
            "-p" ,(write-to-string expr))))
    (let ((res (process->sexp cmd)))
      (if (eof-object? res)  ; process error
          (eval expr (apply environment imports))
          res))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Package - generate a package from one or more libraries.

(define (x->string x)
  (cond ((string? x) x)
        ((symbol? x) (symbol->string x))
        ((number? x) (number->string x))
        (else (error "not a valid path component" x))))

(define (library-path-base file name)
  (let lp ((ls (cdr (reverse name))) (dir (path-directory file)))
    (cond
     ((null? ls) dir)
     ((equal? (x->string (car ls)) (path-strip-directory dir))
      (lp (cdr ls) (path-directory dir)))
     (else dir))))

(define (path-relative file dir)
  (let ((file (path-normalize file))
        (dir (string-trim-right (path-normalize dir) #\/)))
    (string-trim-left
     (if (string-prefix? dir file)
         (substring file (string-length dir))
         file)
     #\/)))

;; remove import qualifiers
(define (import-name import)
  (cond
   ((and (pair? import)
         (memq (car import) '(only except prefix drop-prefix rename))
         (pair? (cadr import)))
    (import-name (cadr import)))
   (else import)))

(define (extract-library cfg file)
  (let ((lib (read-from-file file)))
    (match lib
      (('define-library (name ...)
         declarations ...)
       (let* ((dir (library-path-base file name))
              (lib-file (path-relative file dir))
              (lib-dir (path-directory lib-file)))
         (define (resolve file)
           (let ((dest-path (if (equal? lib-dir ".")
                                file
                                (make-path lib-dir file))))
             (list 'rename (make-path dir dest-path) dest-path)))
         (define (ffi-file-includes file)
           (let lp ((forms (guard (exn (else '()))
                             (call-with-input-file file port->sexp-list)))
                    (res '()))
             (cond ((null? forms) (reverse res))
                   ((and (pair? (car forms))
                         (eq? 'c-include-verbatim (caar forms)))
                    (lp (cdr forms) (append (cdar forms) res)))
                   (else (lp (cdr forms) res)))))
         (define (ffi-files base)
           (let* ((path (path-resolve base (path-directory file)))
                  (stub-file (string-append path ".stub"))
                  (c-file (string-append path ".c")))
             (cond
              ((file-exists? stub-file)
               (cons (string-append base ".stub")
                     (ffi-file-includes stub-file)))
              ((file-exists? c-file)
               (list c-file))
              (else
               (warn "couldn't find ffi stub or c source" base)
               '()))))
         (let lp ((ls declarations)
                  (info `(,@(cond
                             ((conf-get cfg '(command package author))
                              => (lambda (x) (list (list 'author x))))
                             (else '()))
                          (path ,lib-file)
                          (name ,name)
                          library))
                  (deps '())
                  (files `((rename ,file ,lib-file)))
                  (chibi-ffi? #f))
           (cond
            ((null? ls)
             ;; Force a fake dependency on (chibi) if the chibi ffi is
             ;; used so this isn't available to other implementations.
             (let* ((deps (if (and chibi-ffi? (not (member '(chibi) deps)))
                              (cons '(chibi) deps)
                              deps))
                    (info (reverse (cons `(depends ,@deps) info))))
               (cons info files)))
            (else
             (match (car ls)
               (((or 'include 'include-ci) includes ...)
                (lp (cdr ls)
                    info
                    deps
                    (append (map resolve includes) files)
                    chibi-ffi?))
               (('include-library-declarations includes ...)
                (lp (append (append-map
                             (lambda (inc)
                               (file->sexp-list
                                (path-resolve inc (path-directory file))))
                             includes)
                            (cdr ls))
                    info
                    deps
                    (append (map resolve includes) files)
                    chibi-ffi?))
               (('include-shared includes ...)
                (lp (cdr ls)
                    info
                    deps
                    (append (map resolve (append-map ffi-files includes))
                            files)
                    #t))
               (('import libs ...)
                (lp (cdr ls)
                    info
                    (append (map import-name libs) deps)
                    files
                    chibi-ffi?))
               (('cond-expand clauses ...)
                (let ((libs+files (map (lambda (c) (lp c '() '() '() #f)) clauses)))
                  (lp (cdr ls)
                      (cons (cons 'cond-expand
                                  (map cons
                                       (map car clauses)
                                       (map car libs+files)))
                            info)
                      deps
                      (append files (append-map cdr libs+files))
                      chibi-ffi?)))
               (else
                (lp (cdr ls) info deps files chibi-ffi?))))))))
      (else
       (die 2 "not a valid library declaration " lib " in file " file)))))

(define (extract-program-dependencies file . o)
  (let ((depends (or (and (pair? o) (car o)) 'depends)))
    (let lp ((ls (guard (exn (else '()))
                   (if (and (pair? file) (eq? 'inline (car file)))
                       (port->sexp-list (open-input-string (cadr file)))
                       (file->sexp-list file))))
             (deps '())
             (cond-deps '()))
      (cond
       ((and (pair? ls) (pair? (car ls)) (eq? 'import (caar ls)))
        (lp (cdr ls)
            (append (reverse (map import-name (cdar ls))) deps)
            cond-deps))
       ((and (pair? ls) (pair? (car ls)) (eq? 'cond-expand (caar ls)))
        ;; flatten all imports, but maintain cond-expand's separately
        (let ((res (filter-map
                    (lambda (clause)
                      (let ((imps (lp (cdar ls) '() '())))
                        ;; TODO: support nested cond-expand's
                        (and (pair? imps)
                             (pair? (car imps))
                             (eq? depends (caar imps))
                             (list (car clause) (car imps)))))
                    (cdar ls))))
          (if (pair? res)
              (lp (cdr ls) deps `((cond-expand ,@res) ,@cond-deps))
              (lp (cdr ls) deps cond-deps))))
       (else
        (append (if (pair? deps) (list (cons depends (reverse deps))) '())
                (if (pair? cond-deps) (reverse cond-deps) '())))))))

(define (make-package-name cfg pkg libs . o)
  (let ((name (or (assoc-get pkg 'name)
                  (any (lambda (x) (or (library-name x) (program-name x))) libs)))
        (version (and (pair? o) (car o))))
    (cond
     ((not (and (pair? name) (list? name)))
      (die 2 "Invalid library name: " name))
     ((not name)
      (die 2 "Couldn't determine package name from libs: " libs))
     (else
      (let lp ((ls (if version
                       (append name (list version))
                       name))
               (res '()))
        (if (null? ls)
            (string-join (reverse (cons ".tgz" res)))
            (lp (cdr ls)
                (cons (x->string (car ls))
                      (if (null? res) res (cons "-" res))))))))))

(define (check-overwrite cfg file type-pred type-name)
  (let ((mode (conf-get cfg '(command package overwrite) 'same-type)))
    (cond
     ((eq? mode 'always))
     ((file-exists? file)
      (case mode
        ((never)
         (die 2 "Destination " file " already exists, not overwriting"))
        ((same-type)
         (if (and (not (type-pred file))
                  (not (yes-or-no? cfg "Destination " file
                                   " doesn't look like a " type-name
                                   ", overwrite?")))
             (die 2 "Not overwriting " file)))
        ((confirm)
         (if (not (yes-or-no? cfg "Overwrite existing " file "?"))
             (die 2 "Not overwriting " file))))))))

;; Simplistic pretty printing for package/repository/config declarations.
(define (write-simple-pretty pkg out)
  (let wr ((ls pkg) (indent 0) (tails 0))
    (cond
     ((and (pair? ls)
           (pair? (cdr ls))
           (pair? (cadr ls)))
      (display (make-string indent #\space) out)
      (write-char #\( out)
      (write (car ls) out)
      (newline out)
      (for-each (lambda (x) (wr x (+ indent 2) 0)) (drop-right (cdr ls) 1))
      (wr (last ls) (+ indent 2) (+ tails 1)))
     (else
      (display (make-string indent #\space) out)
      (write ls out)
      (display (make-string tails #\)) out)
      (newline out)))))

;; We want to automatically bundle (foo bar *) when packaging (foo bar)
;; if it's already in the same directory.
(define (submodule->path cfg base file lib dep)
  (and base
       (> (length dep) (length base))
       (equal? base (take dep (length base)))
       ;; TODO: find-library(-relative)
       (let* ((dir (library-path-base file lib))
              (dep-file (make-path dir (string-append
                                        (library-name->path cfg dep)
                                        ".sld"))))
         (and (file-exists? dep-file) dep-file))))

(define (package-docs cfg spec libs lib-dirs)
  (guard (exn (else (warn "package-docs failed" exn)
                    '()))
    (cond
     ((conf-get cfg '(command package doc)) => list)
     ((conf-get cfg '(command package doc-from-scribble))
      (filter-map
       (lambda (lib)
         (let ((lib-name (library-file-name lib))
               (docs (extract-module-file-docs lib #f)))
           (and (pair? docs)
                (not (and (= 1 (length docs)) (pair? (car docs))
                          (eq? 'subsection (caar docs))))
                `(inline
                  ,(string-append (library-name->path cfg lib-name) ".html")
                  ,(call-with-output-string
                     (lambda (out)
                       (sxml-display-as-html
                        (generate-docs
                         `((title ,(write-to-string lib-name)) ,docs)
                         (guard (exn (else (make-default-doc-env)))
                           (make-module-doc-env lib-name)))
                        out)))))))
       libs))
     (else '()))))

(define package-description
  (let ((sent-re (regexp '(: "<p>" (* "\n") (* space)
                             ($ (* (or (: "<" (* (~ (">"))) ">")
                                       (~ ("<."))))
                                "."))))
        (space-re (regexp '(or (: (* space) "\n" (* space)) (>= 2 space))))
        (tag-re (regexp '(: "<" (? "/") (* (~ ("<>"))) ">"))))
    (lambda (cfg spec libs docs)
      (cond
       ((conf-get cfg '(command package description)))
       ((conf-get cfg '(command upload description)))
       ;; Crazy hack, make this more robust, probably opt-in.
       ((and (pair? docs) (pair? (car docs)) (eq? 'inline (caar docs))
             (regexp-search sent-re (third (car docs))))
        => (lambda (m)
             (let ((s (regexp-match-submatch m 1)))
               (and s
                    (string-trim
                     (regexp-replace-all
                      space-re
                      (regexp-replace-all tag-re s "")
                      " "))))))
       (else #f)))))

(define (package-test cfg)
  (conf-get cfg '(command package test)))

(define (package-license cfg)
  (conf-get cfg '(command package license)))

(define (read-version-file cfg file lib-files)
  (let ((file (or (find file-exists?
                        (map (lambda (f) (make-path (path-directory f) file))
                             lib-files))
                  file)))
    (call-with-input-file file read-line)))

(define (package-output-version cfg lib-files)
  (cond ((conf-get cfg '(command package version)))
        ((conf-get cfg '(command upload version)))
        ((conf-get cfg '(command package version-file))
         => (lambda (file) (read-version-file cfg file lib-files)))
        ((conf-get cfg '(command upload version-file))
         => (lambda (file) (read-version-file cfg file lib-files)))
        (else #f)))

(define (package-output-path cfg package-spec libs)
  (or (conf-get cfg '(command package output))
      (make-path
       (conf-get cfg '(command package output-dir) ".")
       (make-package-name
        cfg
        package-spec
        (filter (lambda (x) (and (pair? x) (memq (car x) '(library program))))
                package-spec)
        (package-output-version cfg libs)))))

(define (replace-library-pattern pat base-lib)
  (case (and (pair? pat) (car pat))
    ((append-to-last)
     (append (drop-right base-lib 1)
             (list
              (string->symbol
               (string-append (x->string (last base-lib))
                              (x->string (cadr pat)))))))
    ((append) (append base-lib (cdr pat)))
    ((quote) (cadr pat))
    (else pat)))

(define (find-library-from-pattern cfg pat lib . o)
  (cond ((not pat) #f)
        ((and (pair? pat) (eq? 'or (car pat)))
         (any (lambda (pat) (find-library-from-pattern pat lib)) (cdr pat)))
        (else
         (let ((lib-name (replace-library-pattern pat lib)))
           (apply find-library-file cfg lib-name o)))))

(define (tests-from-libraries cfg libs lib-dirs)
  (let ((pat (conf-get cfg '(command package test-library))))
    (cond
     ((string? pat)
      (list pat))
     ((symbol? pat)
      (list (symbol->string pat)))
     (else
      (filter-map
       (lambda (lib) (find-library-from-pattern cfg pat lib lib-dirs))
       libs)))))

(define (test-program-from-libraries lib-files)
  (call-with-output-string
    (lambda (out)
      (let* ((lib-names (filter-map library-file-name lib-files))
             (run-names
              (map (lambda (lib)
                     (string->symbol
                      (string-append "run-"
                                     (string-join (map x->string lib) "-")
                                     "-tests")))
                   lib-names)))
        (for-each
         (lambda (lib run)
           (write `(import (rename ,lib (run-tests ,run))) out)
           (newline out))
         lib-names
         run-names)
        (newline out)
        (for-each (lambda (run) (write `(,run) out) (newline out)) run-names)))))

(define (package-spec+files cfg spec libs)
  (define (symbols->strings x)
    (cond
     ((symbol? x) (symbol->string x))
     ((pair? x) (cons (symbols->strings (car x)) (symbols->strings (cdr x))))
     (else x)))
  (let* ((recursive? (conf-get cfg '(command package recursive?)))
         (programs (conf-get-list cfg '(command package programs)))
         (data-files (symbols->strings
                      (conf-get-list cfg '(command package data-files))))
         (name (conf-get cfg '(command package name)))
         (authors (conf-get-list cfg '(command package authors)))
         (test (package-test cfg))
         (version (package-output-version cfg libs))
         (maintainers (conf-get-list cfg '(command package maintainers)))
         (license (package-license cfg)))
    (let lp ((ls (map (lambda (x) (list x #f)) libs))
             (progs programs)
             (res
              `(,@(if license `((license ,license)) '())
                ,@(if version `((version ,version)) '())
                ,@(if (pair? authors) `((authors ,@authors)) '())
                ,@(if (pair? maintainers) `((maintainers ,@maintainers)) '())
                ,@(if name `((name ,name)) '())))
             (files '())
             (lib-dirs '())
             (test test)
             (extracted-tests? #f)
             (seen '()))
      (cond
       ((and (pair? ls) (member (caar ls) seen))
        (lp (cdr ls) progs res files lib-dirs test extracted-tests? seen))
       ((pair? ls)
        (let* ((lib+files (extract-library cfg (caar ls)))
               (lib (car lib+files))
               (name (library-name lib))
               (base (or (second (car ls)) name))
               (use-for-test? (and (pair? (cddr (car ls))) (third (car ls))))
               (lib (if use-for-test? (append lib '((use-for test))) lib))
               (subdeps (if recursive?
                            (filter-map
                             (lambda (x)
                               (submodule->path cfg base (caar ls) name x))
                             (cond ((assq 'depends (cdr lib)) => cdr)
                                   (else '())))
                            '())))
          (lp (append (map (lambda (x) (list x base use-for-test?)) subdeps)
                      (cdr ls))
              progs
              (cons lib res)
              (append (reverse (cdr lib+files)) files)
              (delete-duplicates
               (cons (library-path-base (caar ls) name) lib-dirs))
              test
              extracted-tests?
              (cons (caar ls) seen))))
       ((pair? progs)
        (lp ls
            (cdr progs)
            (cons `(program
                    (path ,(path-strip-leading-parents (car progs)))
                    ,@(extract-program-dependencies (car progs)))
                  res)
            (cons (car progs) files)
            lib-dirs
            test
            extracted-tests?
            seen))
       ((null? res)
        (die 2 "No packages generated"))
       ((and (not test)
             (not extracted-tests?)
             (tests-from-libraries
              cfg
              (filter-map (lambda (x) (and (library? x) (library-name x)))
                          res)
              lib-dirs))
        => (lambda (tests-from-libraries)
             (if (pair? tests-from-libraries)
                 (lp (append ls
                             (map (lambda (x) (list x #f #t))
                                  tests-from-libraries))
                     progs
                     res
                     files
                     lib-dirs
                     `(inline
                       "run-tests.scm"
                       ,(test-program-from-libraries tests-from-libraries))
                     #t
                     seen)
                 (lp ls progs res files lib-dirs test #t seen))))
       (else
        (let* ((docs (package-docs cfg spec libs lib-dirs))
               (desc (package-description cfg spec libs docs))
               (test-depends
                (if test
                    (extract-program-dependencies test 'test-depends)
                    '()))
               ;; cleanup - package data-files relative to the lib-dir
               (src-data-files
                (map (lambda (x) (if (pair? x) (cadr x) x)) data-files))
               (rel-data-files
                (if (= 1 (length lib-dirs))
                    (map (lambda (f) (path-relative-to f (car lib-dirs)))
                         data-files)
                    src-data-files))
               (tar-data-files
                (map (lambda (src rel) `(rename ,src ,rel))
                     src-data-files
                     rel-data-files))
               (pkg-data-files
                (if (= 1 (length lib-dirs))
                    (map (lambda (file rel)
                           (if (pair? file)
                               `(rename ,rel ,(third file))
                               rel))
                         data-files
                         rel-data-files)
                    data-files))
               (tar-files
                (reverse
                 (append
                  (cond
                   ((pair? test) (list test))
                   (test
                    `((rename ,test
                              ,(path-strip-leading-parents test))))
                   (else '()))
                  (remove (lambda (x)
                            (and (string? x)
                                 (or (string-prefix? "http://" x)
                                     (string-prefix? "https://" x))))
                          docs)
                  tar-data-files files))))
          (cons `(package
                  ,@(reverse res)
                  ,@(if (pair? data-files) `((data-files ,@pkg-data-files)) '())
                  ,@(if (pair? docs)
                        `((manual ,@(map
                                     (lambda (x)
                                       (path-strip-leading-parents
                                        (if (pair? x) (cadr x) x)))
                                     docs)))
                        '())
                  ,@(if desc `((description ,desc)) '())
                  ,@(if test
                        `((test ,(path-strip-leading-parents
                                  (if (pair? test) (cadr test) test))))
                        '())
                  ,@test-depends)
                tar-files)))))))

(define (create-package spec files path)
  (gzip
   (tar-create #f `(,@files
                    (inline "package.scm"
                            ,(call-with-output-string
                               (lambda (out) (write-simple-pretty spec out)))))
               (let ((dir (path-strip-extension (path-strip-directory path))))
                 (lambda (f) (make-path dir f)))
               #t)))

(define (command/package cfg spec . libs)
  (let* ((spec+files (package-spec+files cfg spec libs))
         (output (package-output-path cfg (car spec+files) libs))
         (tarball (create-package (car spec+files) (cdr spec+files) output)))
    (check-overwrite cfg output package-file? "package")
    (let ((out (open-binary-output-file output)))
      (write-bytevector tarball out)
      (close-output-port out))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Index - add packages to a local repository file.

(define (command/index cfg spec repo-path . pkg-files)
  (let* ((dir (path-directory repo-path))
         (pkgs (filter-map
                (lambda (pkg-file)
                  (let ((pkg (package-file-meta pkg-file)))
                    (and pkg
                         `(,(car pkg)
                           (url ,(path-relative-to pkg-file dir))
                           ,@(cdr pkg)))))
                (if (pair? pkg-files)
                    pkg-files
                    (filter package-file?
                            (map
                             (lambda (f) (make-path dir f))
                             (directory-files dir))))))
         (repo (fold (lambda (pkg repo)
                       (let ((name (package-name pkg)))
                         `(,(car repo)
                           ,pkg
                           ,@(remove
                              (lambda (x) (equal? name (package-name x)))
                              (cdr repo)))))
                     (guard (exn (else (list 'repository)))
                       (car (file->sexp-list repo-path)))
                     pkgs)))
    (call-with-output-file repo-path
      (lambda (out) (write-simple-pretty repo out)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Gen-key - generate a new RSA key pair.

(define (conf-get-snow-dir cfg)
  (or (conf-get cfg 'snow-dir)
      (string-append (get-environment-variable "HOME") "/.snow")))

(define (rsa-key->sexp key name email . o)
  (let ((password (and (pair? o) (not (equal? "" (car o))) (car o))))
    (cond
     (key
      `((name ,name)
        (email ,email)
        (bits ,(rsa-key-bits key))
        ,@(cond (password `((password ,password))) (else '()))
        ,@(cond
           ((rsa-key-e key)
            => (lambda (e)
                 `((public-key
                    (modulus ,(integer->hex-string (rsa-key-n key)))
                    (exponent ,e)))))
           (else '()))
        ,@(cond
           ((rsa-key-d key)
            => (lambda (d)
                 `((private-key
                    (modulus ,(integer->hex-string (rsa-key-n key)))
                    (exponent ,d)))))
           (else '()))))
     (password
      `((name ,name)
        (email ,email)
        (password ,password)))
     (else
      (error "neither key nor password provided" email)))))

(define (conf-gen-key cfg bits)
  (show #t "Generating a new key, this may take quite a while...\n")
  (if (conf-get cfg '(command gen-key gen-key-in-process?))
      (rsa-key-gen bits)
      (let* ((lo (max 3 (expt 2 (- bits 1))))
             (hi (expt 2 bits))
             (p (fast-eval `(random-prime ,lo ,hi)
                           '((chibi math prime))))
             (q (fast-eval `(random-prime-distinct-from ,lo ,hi ,p)
                           '((chibi math prime)))))
        (rsa-key-gen-from-primes bits p q))))

(define (command/gen-key cfg spec)
  (show #t
        "Generate a new key for uploading packages.\n"
        "We need a descriptive name, and an email address to "
        "uniquely identify the key.\n")
  (let* ((name (input cfg '(gen-key name) "Name: "))
         (email (input cfg '(gen-key email) "Email: "))
         (passwd (input-password cfg '(gen-key password)
                                 "Password for upload: "
                                 "Password (confirmation): "))
         (bits (if (conf-get cfg '(command gen-key gen-rsa-key?))
                   (input-number cfg '(gen-key bits)
                                 "RSA key size in bits: " 0 256 2048)
                   0))
         (key (and (>= bits 256) (conf-gen-key cfg bits)))
         (snow-dir (conf-get-snow-dir cfg))
         (key-file (or (conf-get cfg 'key-file)
                       (string-append snow-dir "/priv-key.scm")))
         (old-keys (guard (exn (else '()))
                     (call-with-input-file key-file read)))
         (new-keys
          (cons (rsa-key->sexp key name email passwd)
                ;; TODO: confirm overwrite, preserve old keys
                (remove (rsa-identity=? email) old-keys))))
    (if (not (file-directory? snow-dir))
        (create-directory snow-dir))
    (let* ((fd (open key-file (bitwise-ior open/write open/create) #o600))
           (out (open-output-file-descriptor fd)))
      (show out "("
            (joined (lambda (x)
                      (if (pair? x)
                          (each "(" (joined written x "\n  ") ")")
                          (written x)))
                    new-keys
                    "\n ")
            ")" nl)
      (close-output-port out)
      (show #t "Saved key to " key-file ".\n"))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Reg-key - register an RSA key pair with a repository.

(define (remote-uri cfg name path)
  (or (conf-get cfg name)
      (make-path (or (conf-get cfg 'host) "http://snow-fort.org")
                 path)))

;; a subset of http-post functionality that can shell out to curl
;; depending on config
(define (snow-post cfg uri params)
  (cond
   ((conf-get cfg 'use-curl?)
    (let ((cmd `(curl --silent
                      ,@(append-map
                         (lambda (x)
                           (cond
                            ((and (pair? (cdr x)) (assq 'value (cdr x)))
                             => (lambda (y)
                                  `("-F" ,(string-append
                                           (display-to-string (car x)) "="
                                           (write-to-string
                                            (display-to-string (cdr y)))
                                           "\""))))
                            ((and (pair? (cdr x)) (assq 'file (cdr x)))
                             => (lambda (y)
                                  `("-F" ,(string-append
                                           (display-to-string (car x)) "=@"
                                           (display-to-string (cdr y))))))
                            (else
                             `("-F" ,(string-append
                                      (display-to-string (car x)) "="
                                      (write-to-string
                                       (display-to-string (cdr x))))))))
                         params)
                      ,(uri->string uri))))
      (open-input-bytevector (process->bytevector cmd))))
   ((not (conf-get cfg 'non-blocking-io))
    (http-post uri params '((blocking . #t))))
   (else
    (http-post uri params))))

(define (remote-command cfg name path params)
  (let ((uri (remote-uri cfg name path)))
    (sxml-display-as-text
     (read (snow-post cfg uri (cons '(fmt . "sexp") params))))
    (newline)))

(define (command/reg-key cfg spec)
  (let* ((keys (call-with-input-file
                   (or (conf-get cfg 'key-file)
                       (string-append (conf-get-snow-dir cfg) "/priv-key.scm"))
                 read))
         (email (or (conf-get cfg 'email)
                    (assoc-get (car keys) 'email)))
         (rsa-key-sexp (or (find (rsa-identity=? email) keys)
                           (and (not email) (car keys))))
         (name (assoc-get rsa-key-sexp 'name))
         ;; Register the sha-256 sum of email and password - we'll
         ;; never send the password itself over the network.
         ;; TODO: encrypt this
         (password
          (cond ((assoc-get rsa-key-sexp 'password)
                 => (lambda (pw) (sha-256 (string-append email pw))))
                (else #f)))
         (rsa-pub-key (extract-rsa-public-key rsa-key-sexp))
         (rsa-pub-key-str
          (write-to-string (rsa-key->sexp rsa-pub-key name email password))))
    (remote-command cfg
                    '(command reg-key uri)
                    "/pkg/reg"
                    `((u (file . "pub-key.scm")
                         (value . ,rsa-pub-key-str))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Sign - sign a package.

(define (generate-signature cfg package)
  (let* ((digest-name (conf-get cfg 'digest 'sha-256))
         (digest-func (lookup-digest digest-name))
         (raw-data (if (string? package)
                       (call-with-input-file package port->bytevector)
                       package))
         (snowball (maybe-gunzip raw-data))
         (digest (delay (digest-func snowball)))
         (keys (call-with-input-file
                   (or (conf-get cfg 'key-file)
                       (string-append (conf-get-snow-dir cfg) "/priv-key.scm"))
                 read))
         (email (or (conf-get cfg 'email)
                    (assoc-get (car keys) 'email)))
         (rsa-key-sexp (find (rsa-identity=? email) keys))
         (rsa-key (extract-rsa-private-key rsa-key-sexp))
         (use-rsa? (and rsa-key (conf-get cfg 'sign-uploads?))))
    (append
     `(signature
       (email ,email))
     (if (or use-rsa?
             (not (conf-get cfg 'skip-digest?)))
         `((digest ,digest-name)
           (,digest-name ,(force digest)))
         '())
     (if use-rsa?
         (let* ((sig (fast-eval
                      `(rsa-sign (make-rsa-key ,(rsa-key-bits rsa-key)
                                               ,(rsa-key-n rsa-key)
                                               #f
                                               ,(rsa-key-d rsa-key))
                                 ;;,(hex-string->integer digest)
                                 ,(hex-string->bytevector (force digest)))
                      '((chibi crypto rsa))))
                (hex-sig (if (bytevector? sig)
                             (bytevector->hex-string sig)
                             (integer->hex-string sig))))
           `((rsa ,hex-sig)))
         '()))))

(define (command/sign cfg spec package)
  (let* ((dst (or (conf-get cfg 'output)
                  (path-replace-extension package "sig")))
         (sig (generate-signature cfg package)))
    (call-with-output-file dst
      (lambda (out) (write sig out)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Verify - verify a signature.

(define (command/verify cfg spec sig)
  (let* ((sig-spec (cdr (call-with-input-file sig read)))
         (keys (call-with-input-file
                   (or (conf-get cfg 'key-file)
                       (string-append (conf-get-snow-dir cfg) "/priv-key.scm"))
                 read))
         (email (assoc-get sig-spec 'email))
         (digest-name (assoc-get sig-spec 'digest #f 'sha-256))
         (digest (assoc-get sig-spec digest-name))
         (sig (assoc-get sig-spec 'rsa))
         (rsa-key-sexp (or (and (string? email)
                                (find (rsa-identity=? email) keys))
                           (car keys))))
    (cond
     ((not email)
      (show #t "invalid signature - no email: " sig-spec))
     ((not sig)
      (show #t "no rsa signature in key for: " email))
     ((not rsa-key-sexp)
      (show #t "couldn't find public key in repo for: " email))
     (else
      (let* ((rsa-key (extract-rsa-public-key rsa-key-sexp))
             (cipher (rsa-verify rsa-key (hex-string->bytevector sig)))
             (digest-bv (hex-string->bytevector digest)))
        (if (equal? cipher digest-bv)
            (show #t "signature valid " nl)
            (show #t "signature invalid " cipher " != " digest-bv nl)))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Upload - upload a package.

(define (get-password cfg package)
  (and (not (conf-get cfg 'upload-without-password?))
       (let* ((keys (call-with-input-file
                        (or (conf-get cfg 'key-file)
                            (string-append (conf-get-snow-dir cfg)
                                           "/priv-key.scm"))
                      read))
              (email (or (conf-get cfg 'email)
                         (assoc-get (car keys) 'email)))
              (rsa-key-sexp (find (rsa-identity=? email) keys))
              (raw-password (assoc-get rsa-key-sexp 'password)))
         (and raw-password
              (sha-256 (string-append email raw-password))))))

(define (upload-package cfg spec package . o)
  (let ((password `(pw (value . ,(get-password cfg package))))
        (pkg (if (string? package)
                 `(u (file . ,package))
                 `(u (file . ,(if (pair? o) (car o) "package.tgz"))
                     (value . ,package))))
        (sig
         (cond
          ((conf-get cfg 'sig-file)
           => (lambda (sig-file) `(sig (file . ,sig-file))))
          (else
           (let ((sig (generate-signature cfg package)))
             `(sig (file . "package.sig")
                   (value . ,(write-to-string sig))))))))
    (remote-command cfg '(command package uri) "/pkg/put"
                    (list password pkg sig))))

(define (command/upload cfg spec . o)
  (define (non-homogeneous)
    (die 1 "upload arguments must all be packages or all be libraries, "
         "but got " o))
  (cond
   ((null? o)
    (die 1 "upload requires at least one input argument"))
   ((package-file? (car o))
    (if (not (every package-file? (cdr o)))
        (non-homogeneous))
    ;; TODO: include a summary (version, file size, etc.)
    (if (yes-or-no? cfg "Upload " o " to "
                    (remote-uri cfg '(command package uri) "/?"))
      (for-each
       (lambda (package) (upload-package cfg spec package))
       o)))
   (else
    (if (any package-file? (cdr o))
        (non-homogeneous))
    (let* ((spec+files (package-spec+files cfg spec o))
           (package-file (package-output-path cfg (car spec+files) o))
           (package (create-package (car spec+files)
                                    (cdr spec+files)
                                    package-file)))
      ;; TODO: include a summary (version, file size, etc.)
      (if (yes-or-no? cfg "Upload " o " to "
                      (remote-uri cfg '(command package uri) "/?"))
        (upload-package cfg spec package package-file))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Remove - removes the listed libraries.
;;
;; Provides a summary of the libraries to remove along with any
;; dependencies they have which were not explicitly installed.

(define (remove-with-sudo? cfg path)
  (case (or (conf-get cfg '(command remove use-sudo?))
            (conf-get cfg '(command upgrade use-sudo?)))
    ((always) #t)
    ((never) #f)
    (else
     (not (file-is-writable? (path-directory path))))))

(define (remove-file cfg file)
  (if (remove-with-sudo? cfg file)
      (system "sudo" "rm" file)
      (delete-file file)))

(define (remove-directory cfg dir)
  (if (remove-with-sudo? cfg dir)
      (system "sudo" "rmdir" dir)
      (delete-directory dir)))

(define (warn-delete-file cfg file)
  (guard (exn (else (warn "couldn't delete file: " file)))
    (remove-file cfg file)))

(define (delete-library-files impl cfg pkg lib-name)
  (for-each (lambda (f) (warn-delete-file cfg f)) (package-installed-files pkg))
  (warn-delete-file cfg (make-path (get-install-source-dir impl cfg)
                                   (get-package-meta-file cfg pkg)))
  (cond
   ((package->path cfg pkg)
    => (lambda (path)
         (let ((dir (make-path (get-install-source-dir impl cfg) path)))
           (if (and (file-directory? dir)
                    (= 2 (length (directory-files dir))))
               (remove-directory cfg dir)))
         (when (eq? impl 'guile)
           (let ((go-file (string-append (make-path (get-install-library-dir impl cfg) path)
                                         ".go")))
             (warn-delete-file cfg go-file)))))))

(define (command/remove cfg spec . args)
  (let* ((impls (conf-selected-implementations cfg))
         (impl-cfgs (map (lambda (impl)
                           (conf-for-implementation cfg impl))
                         impls))
         (lib-names (map parse-library-name args)))
    (for-each
     (lambda (impl impl-cfg)
       (for-each (lambda (pkg lib-name)
                   (delete-library-files impl impl-cfg (cdr pkg) lib-name))
                 (lookup-installed-libraries impl impl-cfg lib-names)
                 lib-names))
     impls
     impl-cfgs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Search - search for libraries matching keywords.
;;
;; Prints a list of libraries whose meta-info contain any of the given
;; keywords.  Returns in sorted order for how well the package matches.

(define (summarize-libraries cfg lib-names+pkgs)
  (for-each (lambda (name pkg) (describe-library cfg name pkg))
            (map car lib-names+pkgs)
            (map cdr lib-names+pkgs)))

(define (string-count-word str word)
  (let lp ((sc (string-cursor-start str)) (count 0))
    (let ((sc2 (string-contains str word sc)))
      (if sc2
          (lp (string-cursor-next str sc2) (+ count 1))
          count))))

(define (count-in-sexp x keywords)
  (let ((s (string-downcase (write-to-string x))))
    (fold (lambda (k sum) (+ sum (string-count-word s k)))
          0
          (map string-downcase keywords))))

(define (extract-matching-libraries cfg repo keywords)
  (define (library-score lib)
    (+ (* 10 (count-in-sexp (library-name lib) keywords))
       (count-in-sexp lib keywords)
       (let ((use-for (assq 'use-for (cdr lib))))
         (apply
          max
          0
          (map
           (lambda (x) (case x ((test) 0) ((build) 10) (else 100)))
           (if (pair? use-for) (cdr use-for) (list use-for)))))))
  (append-map
   (lambda (x)
     (cond
      ((not (package? x)) '())
      (else
       (let ((pkg-score (count-in-sexp x keywords))
             (libs (package-libraries x)))
         (if (or (zero? pkg-score) (null? libs))
             '()
             (let lp ((libs (cdr libs))
                      (best-score (library-score (car libs)))
                      (best-lib (car libs)))
               (cond
                ((null? libs)
                 (list (cons (+ best-score pkg-score)
                             (cons (library-name best-lib) x))))
                (else
                 (let ((score (library-score (car libs))))
                   (if (> score best-score)
                       (lp (cdr libs) score (car libs))
                       (lp (cdr libs) best-score best-lib)))))))))))
   repo))

(define (extract-sorted-packages cfg repo keywords)
  (let ((ls (extract-matching-libraries cfg repo keywords)))
    (map cdr (sort ls > car))))

(define (command/search cfg spec . keywords)
  (let* ((repo (current-repositories cfg))
         (lib-names+pkgs (extract-sorted-packages cfg repo keywords))
         (sexp? (conf-get cfg 'sexp?)))
    (cond
     ((or (pair? lib-names+pkgs) sexp?)
      (if sexp? (display "("))
      (summarize-libraries cfg lib-names+pkgs)
      (if sexp? (display ")\n")))
     (else
      (display "No libraries matched your query.\n")))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Show - show detailed information for the given libraries
;;
;; The typical pattern is to use search to find the names of libraries
;; of interest, and show to see detailed information to decide whether
;; or not to install them.

(define (describe-library cfg library-name pkg)
  (let ((sexp? (conf-get cfg 'sexp?)))
    (if sexp? (display "("))
    (display library-name)
    (display (if sexp? " " "\t"))
    ((if sexp? write display) (package-version pkg))
    (if sexp? (display ")"))
    (newline)))

(define (command/show cfg spec . args)
  (current-repositories cfg)
  (let* ((impls (conf-selected-implementations cfg))
         (impl-cfgs (map (lambda (impl)
                           (conf-for-implementation cfg impl))
                         impls))
         (lib-names (map parse-library-name args)))
    (for-each
     (lambda (impl impl-cfg)
       (for-each (lambda (name pkg) (describe-library impl-cfg name pkg))
                 (lookup-installed-libraries impl impl-cfg lib-names)
                 lib-names))
     impls
     impl-cfgs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Update - update the repository.

(define (valid-repository? repo)
  (and (pair? repo) (list? repo) (eq? 'repository (car repo))))

(define (repository-dir cfg)
  (cond
   ((zero? (current-user-id))
    (or (conf-get cfg 'local-root-repository)
        "/usr/local/share/snow/repo"))
   (else
    (or (conf-get cfg 'local-user-repository)
        (make-path (conf-get-snow-dir cfg) "repo")))))

(define (repository-local-path cfg repo-uri)
  (let* ((repo-id (substring (sha-224 (string->utf8 repo-uri)) 0 32))
         (local-dir (repository-dir cfg))
         (local-base (string-append "repo-" repo-id ".scm")))
    (make-path local-dir local-base)))

(define (update-repository cfg repo-uri)
  (let* ((local-path (repository-local-path cfg repo-uri))
         (local-dir (path-directory local-path))
         (local-tmp (string-append local-path ".tmp."
                                   (number->string (current-second)) "-"
                                   (number->string (current-process-id))))
         (repo-str (utf8->string (resource->bytevector cfg repo-uri)))
         (repo (guard (exn (else #f))
                 (let ((repo (read (open-input-string repo-str))))
                   `(,(car repo) (url ,repo-uri) ,@(cdr repo))))))
    (cond
     ((not (valid-repository? repo))
      (warn "not a valid repository" repo-uri repo))
     ((not (create-directory* local-dir))
      (warn "can't create directory" local-dir))
     (else
      (guard (exn (else (die 2 "couldn't write repository")))
        (call-with-output-file local-tmp
          (lambda (out) (write repo out)))
        (if (file-exists? local-path)
            (rename-file local-path (string-append local-path ".bak")))
        (rename-file local-tmp local-path)
        repo)))))

(define (repository-stale? cfg repo-uri)
  (let ((local-path (repository-local-path cfg repo-uri)))
    (guard (exn (else #t))
      (> (current-second)
         (+ (file-modification-time local-path)
            ;; by default update once every 3 hours
            (conf-get cfg 'update-refresh (* 3 60 60)))))))

(define (should-update-repository? cfg repo-uri)
  (case (conf-get cfg 'update-strategy 'cache)
    ((always) #t)
    ((never) #f)
    ((cache)
     (repository-stale? cfg repo-uri))
    ((confirm)
     (and (repository-stale? cfg repo-uri)
          (yes-or-no? cfg "Update repository info?")))
    (else
     (warn "unknown update-stategy: " (conf-get cfg 'update-strategy))
     #f)))

;; returns the single repo as a sexp, updated as needed
(define (maybe-update-repository cfg repo-uri)
  (or (guard (exn
              (else
               (warn "error updating remote repository: "
                     repo-uri " error: " exn)
               #f))
        (and (should-update-repository? cfg repo-uri)
             (update-repository cfg repo-uri)))
      (guard (exn
              (else
               (warn "error reading local repository: " exn)
               '(repository)))
        (call-with-input-file (repository-local-path cfg repo-uri)
          read))))

(define (get-repository-list cfg)
  (let ((ls (conf-get-list cfg 'repository-uri)))
    (if (pair? ls)
        ls
        (list (remote-uri cfg 'default-repository "/s/repo.scm")))))

;; returns all repos merged as a sexp, updated as needed
;; not to be confused with the current-repo util in (chibi snow fort)
;; which returns the single host
(define (current-repositories cfg)
  (define (make-loc uri trust depth) (vector uri trust depth))
  (define (loc-uri loc) (vector-ref loc 0))
  (define (loc-trust loc) (vector-ref loc 1))
  (define (loc-depth loc) (vector-ref loc 2))
  (define (adjust-package-urls ls uri)
    (map
     (lambda (x)
       (cond
        ((and (pair? x) (eq? 'package (car x)) (assq 'url (cdr x)))
         => (lambda (y)
              (set-car! (cdr y)
                        (uri-resolve (cadr y) (string->path-uri 'http uri))))))
       x)
     (remove (lambda (x)
               (and (pair? x)
                    (eq? 'url (car x))))
             ls)))
  (let lp ((ls (map (lambda (x) (make-loc x 1.0 0))
                    (get-repository-list cfg)))
           (seen '())
           (res '()))
    (cond
     ((null? ls)
      (cons 'repository (reverse res)))
     ((> (loc-depth (car ls)) (conf-get cfg 'sibling-depth-limit 1000))
      (warn "skipping sibling repo at max depth: "
            (loc-uri (car ls)) (loc-depth (car ls)))
      (lp (cdr ls)))
     ((< (loc-trust (car ls)) (conf-get cfg 'sibling-min-trust 0.0))
      (warn "skipping sibling repo with low trust: "
            (loc-uri (car ls)) (loc-trust (car ls)) )
      (lp (cdr ls)))
     (else
      (let ((uri (uri-normalize (loc-uri (car ls)))))
        (if (member uri seen)
            (lp (cdr ls) seen res)
            (let* ((repo (maybe-update-repository cfg uri))
                   (siblings
                    (if (and (valid-repository? repo)
                             (conf-get cfg 'follow-siblings? #t))
                        (let ((uri-base
                               (if (string-suffix? "/" uri)
                                   uri
                                   (uri-directory uri))))
                          (filter-map
                           (lambda (x)
                             (and (pair? x)
                                  (eq? 'sibling (car x))
                                  (assoc-get (cdr x) 'url)
                                  (make-loc
                                   (uri-resolve (assoc-get (cdr x) 'url)
                                                uri-base)
                                   (* (loc-trust (car ls))
                                      (or (assoc-get (cdr x) 'trust) 1.0))
                                   (+ (loc-depth (car ls)) 1))))
                           (cdr repo)))
                        '()))
                   (res (if (valid-repository? repo)
                            (let ((multi? (or (pair? res)
                                              (pair? siblings)
                                              (pair? (cdr ls)))))
                              (append
                               (reverse
                                (if multi?
                                    (adjust-package-urls (cdr repo) uri)
                                    (cdr repo)))
                               res))
                            (begin
                              (if repo
                                  (warn "invalid repository for uri: " uri))
                              res))))
              (lp (append siblings (cdr ls)) (cons uri seen) res))))))))

(define (command/update cfg spec)
  (current-repositories (conf-extend cfg '((update-strategy . always)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Install - install one or more libraries.
;;
;; Installs the listed libraries along with their transitive closure
;; of dependencies.  For each library to install we confirm the
;; current status (skipping if already installed), the signature and
;; trust (optionally updating the trust level), and the default tests.
;; If multiple implementations are targeted, we install separately but
;; use the same confirmations for each.

(define (get-chicken-binary-version cfg)
  (or (conf-get cfg 'chicken-binary-version)
      (string->number (process->string '(csi -p "(##sys#fudge 42)")))
      8))

(define (get-chicken-repo-path)
  (let ((release (string-trim (process->string '(csi -release))
                              char-whitespace?)))
    (string-trim
     (if (string-prefix? "4." release)
         (process->string '(csi -p "(repository-path)"))
         (process->string
          '(csi -R chicken.platform -p "(car (repository-path))")))
     char-whitespace?)))

(define (get-guile-site-dir)
  (process->string '(guile -c "(display (%site-dir))")))

(define (get-guile-site-ccache-dir)
  (process->string '(guile -c "(display (%site-ccache-dir))")))

(define (get-install-dirs impl cfg)
  (define (guile-eval expr)
    (guard (exn (else #f))
      (process->sexp `(guile -c ,(write-to-string `(write ,expr))))))
  (case impl
    ((chibi)
     (let* ((dirs
             (reverse
              (cond-expand
               (chibi (eval '(current-module-path) (environment '(chibi))))
               (else (process->sexp
                      '(chibi-scheme -q -p "(current-module-path)"))))))
            (share-dir (find (lambda (d) (string-contains d "/share/")) dirs)))
       (if share-dir
           (cons share-dir (delete share-dir dirs))
           dirs)))
    ((chicken)
     (let ((dir (get-chicken-repo-path)))
       (list
        (if (file-exists? dir)  ; repository-path should always exist
            dir
            (make-path (or (conf-get cfg 'install-prefix)) "lib" impl
                       (get-chicken-binary-version cfg))))))
    ((cyclone)
     (let ((dir (let ((lib-path (get-environment-variable "CYCLONE_LIBRARY_PATH")))
                  (if lib-path
                      (car (string-split lib-path #\:)) ; searches only in the first path set
                      (string-trim (process->string '(icyc -p "(Cyc-installation-dir 'sld)"))
                                   char-whitespace?)))))
       (list (or dir "/usr/local/share/cyclone/"))))
    ((gauche)
     (list
      (let ((dir (string-trim
                  (process->string '(gauche-config "--sitelibdir"))
                  char-whitespace?)))
        (or (and (string? dir) (> (string-length dir) 0)
                 (eqv? #\/ (string-ref dir 0))
                 dir)
            "/usr/local/share/gauche/"))))
    ((guile)
     (let ((path
            (guile-eval
             '(string-append (cdr (assq 'pkgdatadir %guile-build-info))
                             (string (integer->char 47))
                             (effective-version)))))
       (list
        (if (string? path)
            path
            "/usr/local/share/guile/"))))
    ((larceny)
     (list
      (make-path
       (string-trim
        (process->string
         '(larceny -quiet -nobanner -- -e
                   "(begin (display (getenv \"LARCENY_ROOT\")) (exit))"))
        char-whitespace?)
       "lib/Snow")))
    (else
     (list (make-path (or (conf-get cfg 'install-prefix) "/usr/local")
                      "share/snow"
                      impl)))))

(define (get-install-library-dirs impl cfg)
  (case impl
    ((chibi)
     (let* ((dirs
             (reverse
              (cond-expand
               (chibi (eval '(current-module-path) (environment '(chibi))))
               (else (process->sexp
                      '(chibi-scheme -q -p "(current-module-path)"))))))
            (lib-dir (find (lambda (d)
                             (and (equal? (string-ref d 0) #\/)
                                  (string-contains d "/lib")))
                           dirs)))
       (if lib-dir
           (cons lib-dir (delete lib-dir dirs))
           dirs)))
    (else
     (list (make-path (or (conf-get cfg 'install-prefix) "/usr/local")
                      "lib"
                      impl)))))

(define (scheme-script-command impl cfg)
  (or (and (eq? impl 'chibi) (conf-get cfg 'chibi-path))
      (let* ((prog (cond ((conf-get cfg 'scheme-script))
                         ((assq impl known-implementations) => cadr)
                         (else "scheme-script")))
             (path (or (find-in-path prog) prog))
             (arg (case impl
                    ((chicken) "-s")
                    ((cyclone) "-s")
                    ((gauche) "-b")
                    ((larceny) "-program")
                    (else #f))))
        (if (and path arg)
            (string-append path " " arg)
            path))))

(define (scheme-program-command impl cfg file . o)
  (cond
   ((conf-get cfg 'scheme-program-command) => string-split)
   (else
    (let ((lib-path (and (pair? o) (car o)))
          (install-dir (get-install-source-dir impl cfg)))
      (case impl
        ((chibi)
         (let ((chibi (string-split (conf-get cfg 'chibi-path "chibi-scheme"))))
           (if lib-path
               `(,@chibi -A ,install-dir -A ,lib-path ,file)
               `(,@chibi -A ,install-dir ,file))))
        ((chicken)
         (if lib-path
             `(csi -R r7rs -I ,install-dir -I ,lib-path -s ,file)
             `(csi -R r7rs -I ,install-dir -s ,file)))
        ((cyclone)
         (if lib-path
             `(icyc -A ,install-dir -A ,lib-path -s ,file)
             `(icyc -A ,install-dir -s ,file)))
        ((foment)
         (if lib-path
             `(foment -A ,install-dir -A ,lib-path ,file)
             `(foment -A ,install-dir ,file)))
        ((gauche)
         (if lib-path
             `(gosh -A ,install-dir -A ,lib-path ,file)
             `(gosh -A ,install-dir ,file)))
        ((guile)
         (if lib-path
             `(guile -L ,install-dir -L ,lib-path ,file)
             `(guile -L ,install-dir ,file)))
        ((kawa)
         (let ((install-dir (path-resolve install-dir (current-directory))))
           (if lib-path
               `(kawa
                 ,(string-append "-Dkawa.import.path=" install-dir ":"
                                 (path-resolve lib-path (current-directory)))
                 --r7rs --script ,file)
               `(kawa ,(string-append "-Dkawa.import.path=" install-dir)
                      --r7rs --script ,file))))
        ((larceny)
         (if lib-path
             `(larceny -r7rs -path ,(string-append install-dir ":" lib-path)
                       -program ,file)
             `(larceny -r7rs -path ,install-dir -program ,file)))
        (else
         #f))))))

(define (get-install-search-dirs impl cfg)
  (let ((install-dir (get-install-source-dir impl cfg))
        (other-dirs (get-install-dirs impl cfg)))
    (cons install-dir (delete install-dir other-dirs))))

(define (find-library-meta impl cfg name)
  (let ((dirs (get-install-search-dirs impl cfg)))
    (let lp ((subname name))
      (or (find-sexp-in-path
           (package-name->meta-file cfg subname)
           dirs
           (lambda (x)
             (and (package? x)
                  (or (equal? name (package-name x))
                      (any (lambda (y) (equal? name (library-name y)))
                           (package-libraries x))
                      (any (lambda (y) (equal? name (program-name y)))
                           (package-programs x))))))
          (and (pair? (cdr subname))
               (lp (drop-right subname 1)))))))

;; test the package locally built in dir
(define (test-package impl cfg pkg dir)
  (let* ((test-file (cond ((assoc-get pkg 'test)
                           => (lambda (f) (path-resolve f dir)))
                          (else #f)))
         (command (scheme-program-command impl cfg test-file dir)))
    (cond
     ((and test-file command
           (not (or (conf-get cfg '(command install skip-tests?))
                    (conf-get cfg '(command upgrade skip-tests?)))))
      ;; install any data files locally in the dir
      (let ((true-install-dir (get-install-data-dir impl cfg))
            (test-install-dir
             (make-path dir (string-append "tmp-data-"
                                           (number->string
                                            (current-process-id)))))
            (data-files (package-data-files pkg)))
        (for-each
         (lambda (file)
           (let* ((src (make-path dir (if (pair? file) (cadr file) file)))
                  (dest0 (if (pair? file) (third file) file))
                  (dest (make-path test-install-dir
                                   (if (path-absolute? dest0)
                                       (path-relative-to dest0 true-install-dir)
                                       dest0))))
             (create-directory* (path-directory dest))
             (install-file cfg src dest)))
         (package-data-files pkg))
        (setenv "SNOW_TEST_DATA_DIR" test-install-dir))
      ;; Run the tests from within the temp directory.  This reduces
      ;; stray output in the pwd, can be useful for accessing data
      ;; files during testing, and is needed for chicken (see chicken
      ;; trac #736).
      ;; For chibi we run from the current directory anyway for the
      ;; sake of running snow-tests from an uninstalled chibi-scheme.
      (or (match ((if (eq? impl 'chibi) (lambda (dir f) (f)) with-directory)
                  dir
                  (lambda () (process->output+error+status command)))
            ((output error status)
             (cond
              ((or (not (zero? status))
                   (string-contains output "FAIL")
                   (string-contains error "FAIL")
                   (string-contains output "ERROR")
                   (string-contains error "ERROR"))
               (call-with-output-file (make-path dir "test-out.txt")
                 (lambda (out) (display output out)))
               (call-with-output-file (make-path dir "test-err.txt")
                 (lambda (err) (display error err)))
               (display output)
               (display error)
               #f)
              (else
               (info "All tests passed.")
               (cond ((or (conf-get cfg '(command install show-tests?))
                          (conf-get cfg '(command upgrade show-tests?)))
                      (display output)
                      (display error)))
               #t)))
            (other
             (warn "Test error: " other)
             #f))
          (yes-or-no? cfg "Tests failed: " test-file
                      " (details in " dir "/test-{out,err}.txt)\n"
                      "Proceed anyway?")))
     (else
      #t))))

(define (lookup-installed-libraries impl cfg names)
  (map (lambda (name)
         (cons name
               (or (find-library-meta impl cfg name)
                   `(not-installed ,name))))
       names))

(define (installed-libraries impl cfg)
  (delete-duplicates
   (append-map
    (lambda (dir)
      (directory-fold-tree
       dir
       #f #f
       (lambda (file acc)
         (cond
          ((and (equal? "meta" (path-extension file))
                (guard (exn (else (warn "read meta failed" exn) #f))
                  (let ((pkg (call-with-input-file file read)))
                    (and (package? pkg)
                         (every file-exists? (package-installed-files pkg))
                         pkg))))
           => (lambda (pkg)
                (append
                 (map
                  (lambda (lib) (cons (library-name lib) pkg))
                  (package-libraries pkg))
                 acc)))
          (else acc)))
       '()))
    (get-install-search-dirs impl cfg))
   (lambda (a b) (equal? (car a) (car b)))))

(define r7rs-small-libraries
  '(base case-lambda char complex cxr eval file inexact
    lazy load process-context r5rs read repl time write))

;; chibi is not included because chibi is already installed with full
;; package information for each builtin library
(define native-srfi-support
  '((foment 60)
    (gauche 0 1 4 5 7 9 11 13 14 19 26 27 29 31 37 42 43 55)
    (guile 0 1 2 4 6 8 9 10 11 13 14 16 17 18 19 23 26 27 28 30 31 34
           35 37 38 39 41 42 43 45 46 55 60 61 62 64 67 69 71 87 88
           98 105 111 171)
    (kawa 1 2 13 14 34 37 60 69 95)
    (larceny 0 1 2 4 5 6 7 8 9 11 13 14 16 17 19 22 23 25 26 27 28 29
             30 31 37 38 39 41 42 43 45 48 51 54 56 59 60 61 62 63 64
             66 67 69 71 74 78 86 87 95 96 98)))

(define native-self-support
  '((kawa base expressions hashtable quaternions reflect regex
          rotations string-cursors)
    (gauche array auxsys cgen charconv collection common-macros
            condutil config defvalues dictionary fileutil hashutil
            hook interactive interpolate let-opt libutil listener
            logger logical macroutil modutil net numerical package
            parameter parseopt portutil procedure process redefutil
            regexp reload selector sequence serializer signal singleton
            sortutil stringutil syslog termios test threads time
            treeutil uvector validator version vport)
    ))

;; Currently we make assumptions about default installed libraries of
;; the form (scheme *), (srfi *) and (<impl> *), but don't make any
;; particular effort to analyze other libraries installed outside of
;; the snow-chibi command.  When adding support for versioning we can
;; keep in mind that srfi's are a fixed version, scheme is for the
;; forseeable future tied to the current standard (R7RS), and all core
;; <impl> libraries will be tied to the installed implementation
;; version, although in all cases the actual installed library may
;; have its own version due to improvements and bugfixes.
(define (implementation-supports-natively? impl cfg lib-name)
  (and (pair? lib-name)
       (or
        (and (eq? 'scheme (car lib-name))
             (= 2 (length lib-name))
             (memq (cadr lib-name) r7rs-small-libraries))
        (and (eq? 'srfi (car lib-name))
             (= 2 (length lib-name))
             (cond ((assq impl native-srfi-support)
                    => (lambda (x) (memq (cadr lib-name) (cdr x))))
                   ((eq? impl 'chicken)
                    (file-exists?
                     (make-path (get-install-library-dir impl cfg)
                                (string-append "srfi-"
                                               (number->string (cadr lib-name))
                                               ".import.so"))))
                   (else #f)))
        (equal? lib-name (list impl))
        (and (eq? impl (car lib-name))
             (= 2 (length lib-name))
             (cond ((assq impl native-self-support)
                    => (lambda (x) (memq (cadr lib-name) (cdr x))))
                   (else #f)))
        )))

(define (get-install-source-dir impl cfg)
  (cond
   ((eq? impl 'chicken) (get-install-library-dir impl cfg))
   ((eq? impl 'cyclone) (get-install-library-dir impl cfg))
   ((eq? impl 'guile) (get-guile-site-dir))
   ((conf-get cfg 'install-source-dir))
   ((conf-get cfg 'install-prefix)
    => (lambda (prefix) (make-path prefix "share/snow" impl)))
   (else snow-module-directory)))

(define (get-install-data-dir impl cfg)
  (cond
   ((eq? impl 'chicken) (get-install-library-dir impl cfg))
   ((eq? impl 'cyclone) (get-install-library-dir impl cfg))
   ((conf-get cfg 'install-data-dir))
   ((conf-get cfg 'install-prefix)
    => (lambda (prefix) (make-path prefix "share/snow" impl)))
   (else snow-module-directory)))

(define (get-install-library-dir impl cfg)
  (cond
   ((conf-get cfg 'install-library-dir))
   ((eq? impl 'chicken)
    (cond ((conf-get cfg 'install-prefix)
           => (lambda (prefix)
                (make-path prefix "lib" impl
                           (get-chicken-binary-version cfg))))
          (else
           (car (get-install-dirs impl cfg)))))
   ((eq? impl 'cyclone)
    (car (get-install-dirs impl cfg)))
   ((eq? impl 'guile)
    (get-guile-site-ccache-dir))
   ((conf-get cfg 'install-prefix)
    => (lambda (prefix) (make-path prefix "lib" impl)))
   (else snow-binary-module-directory)))

(define (get-install-binary-dir impl cfg)
  (cond
   ((conf-get cfg 'install-binary-dir))
   ((conf-get cfg 'install-prefix)
    => (lambda (prefix) (make-path prefix "bin")))
   (else "/usr/local/bin")))

(define (get-library-extension impl cfg)
  (or (conf-get cfg 'library-extension)
      (case impl
        ((gauche kawa) "scm")
        (else "sld"))))

(define (install-with-sudo? cfg path)
  (case (or (conf-get cfg '(command install use-sudo?))
            (conf-get cfg '(command upgrade use-sudo?)))
    ((always) #t)
    ((never) #f)
    (else
     (let lp ((path path))
       (let ((dir (path-directory path)))
         (and (not (file-is-writable? path))
              (or (file-exists? path)
                  (lp dir))))))))

(define (install-file cfg source dest)
  (if (not (equal? source dest))
      (if (install-with-sudo? cfg dest)
          (system "sudo" "cp" source dest)
          (system "cp" source dest))))

(define (install-sexp-file cfg obj dest)
  (if (install-with-sudo? cfg dest)
      (call-with-temp-file "sexp"
        (lambda (tmp-path out preserve)
          (write-simple-pretty obj out)
          (close-output-port out)
          (system "sudo" "cp" tmp-path dest)
          (system "sudo" "chmod" "644" dest)))
      (call-with-output-file dest
        (lambda (out) (write-simple-pretty obj out)))))

(define (install-symbolic-link cfg source dest)
  (if (install-with-sudo? cfg dest)
      (system "sudo" "ln" "-s" source dest)
      (symbolic-link-file source dest)))

(define (install-directory cfg dir)
  (cond
   ((file-directory? dir))
   ((install-with-sudo? cfg dir)
    (system "sudo" "mkdir" "-p" dir))
   (else
    (create-directory* dir))))

(define (should-install-library? impl cfg lib)
  (let ((use-for (assq 'use-for (cdr lib))))
    (or (not (and (pair? use-for)
                  (not (or (memq 'build use-for) (memq 'final use-for)))))
        (conf-get cfg '(command install install-tests?))
        (conf-get cfg '(command upgrade install-tests?)))))

(define (install-package-meta-info impl cfg pkg)
  (let* ((meta-file (get-package-meta-file cfg pkg))
         (install-dir (get-install-source-dir impl cfg))
         (path (make-path install-dir meta-file)))
    ;; write the package name
    (install-sexp-file cfg pkg path)
    ;; symlink utility libraries for which the package can't be inferred
    (let ((pkg-name (package-name pkg)))
      (for-each
       (lambda (lib)
         (let ((lib-name (library-name lib)))
           (if (and (not (equal? pkg-name (take lib-name (length pkg-name))))
                    (should-install-library? impl cfg lib))
               (let* ((lib-meta (make-path install-dir
                                           (get-library-meta-file cfg lib)))
                      (rel-path
                       (path-relative-to path (path-directory lib-meta))))
                 (install-symbolic-link cfg rel-path lib-meta)))))
       (package-libraries pkg)))))

;; The default installer just copies the library file and any included
;; source files to the installation directory.
;; Returns a list of installed files.
(define (default-installer impl cfg library dir)
  (let* ((library-file (get-library-file cfg library))
         (ext (get-library-extension impl cfg))
         (dest-library-file
          (string-append (library->path cfg library) "." ext))
         (include-files
          (library-include-files impl cfg (make-path dir library-file)))
         (install-dir (get-install-source-dir impl cfg))
         (install-lib-dir (get-install-library-dir impl cfg)))
    ;; install the library file
    (let ((path (make-path install-dir dest-library-file)))
      (install-directory cfg (path-directory path))
      (install-file cfg (make-path dir library-file) path)
      ;; install any includes
      (cons
       path
       (append
        (map
         (lambda (x)
           (let ((dest-file (make-path install-dir (path-relative x dir))))
             (install-directory cfg (path-directory dest-file))
             (install-file cfg x dest-file)
             dest-file))
         include-files)
        (map
         (lambda (x)
           (let* ((so-file (string-append x (cond-expand (macosx ".dylib")
                                                         (else ".so"))))
                  (dest-file (make-path install-lib-dir
                                        (path-relative so-file dir))))
             (install-directory cfg (path-directory dest-file))
             (install-file cfg so-file dest-file)
             dest-file))
         (library-shared-include-files
          impl cfg (make-path dir library-file))))))))

(define (chicken-library-base name)
  (if (and (= 2 (length name)) (eq? 'srfi (car name)) (integer? (cadr name)))
      (string-append "srfi-" (number->string (cadr name)))
      (string-join (map x->string name) ".")))

(define (chicken-installer impl cfg library dir)
  (let* ((library-file (get-library-file cfg library))
         (name (library-name library))
         (library-base (chicken-library-base name))
         (install-dir (get-install-library-dir impl cfg))
         (so-path (string-append library-base ".so"))
         (imp-path (string-append library-base ".import.scm"))
         (dest-so-path (make-path install-dir so-path))
         (dest-imp-path (make-path install-dir imp-path)))
    (install-directory cfg install-dir)
    (let ((meta-dir
           (string-join (map x->string (drop-right (library-name library) 1))
                        "/")))
      (install-directory cfg (make-path install-dir meta-dir)))
    (install-file cfg (make-path dir so-path) dest-so-path)
    (install-file cfg (make-path dir imp-path) dest-imp-path)
    (list dest-so-path dest-imp-path)))

(define (cyclone-installer impl cfg library dir)
  (let* ((library-file (get-library-file cfg library))
         (install-dir (get-install-library-dir impl cfg))
         (so-path (string-append (path-strip-extension library-file) ".so"))
         (dest-so-path (make-path install-dir so-path))
         (o-path (string-append (path-strip-extension library-file) ".o"))
         (dest-o-path (make-path install-dir o-path)))
    (install-directory cfg (path-directory dest-so-path))
    (install-file cfg (make-path dir so-path) dest-so-path)
    (install-file cfg (make-path dir o-path) dest-o-path)
    (cons dest-o-path
          (cons dest-so-path
                (default-installer impl cfg library dir)))))

(define (guile-installer impl cfg library dir)
  (let* ((source-scm-file (get-library-file cfg library))
         (source-go-file (string-append
                          (library->path cfg library) ".go"))
         (dest-scm-file
          (string-append (library->path cfg library) ".scm"))
         (dest-go-file
          (string-append (library->path cfg library) ".go"))
         (include-files
          (library-include-files impl cfg (make-path dir source-scm-file)))
         (install-dir (get-install-source-dir impl cfg))
         (install-lib-dir (get-install-library-dir impl cfg)))
    (let ((scm-path (make-path install-dir dest-scm-file))
          (go-path (make-path install-lib-dir dest-go-file)))
      (install-directory cfg (path-directory scm-path))
      (install-directory cfg (path-directory go-path))
      (install-file cfg (make-path dir source-scm-file) scm-path)
      (install-file cfg (make-path dir source-go-file) go-path)
      ;; install any includes
      (cons
       scm-path
       (append
        (map
         (lambda (x)
           (let ((dest-file (make-path install-dir (path-relative x dir))))
             (install-directory cfg (path-directory dest-file))
             (install-file cfg x dest-file)
             dest-file))
         include-files)
        (map
         (lambda (x)
           (let* ((so-file (string-append x (cond-expand (macosx ".dylib")
                                                         (else ".so"))))
                  (dest-file (make-path install-lib-dir
                                        (path-relative so-file dir))))
             (install-directory cfg (path-directory dest-file))
             (install-file cfg so-file dest-file)
             dest-file))
         (library-shared-include-files
          impl cfg (make-path dir source-scm-file))))))))

;; installers should return the list of installed files
(define (lookup-installer installer)
  (case installer
    ((chicken) chicken-installer)
    ((cyclone) cyclone-installer)
    ((guile) guile-installer)
    (else default-installer)))

(define (installer-for-implementation impl cfg)
  (case impl
    ((chicken) 'chicken)
    ((cyclone) 'cyclone)
    ((guile) 'guile)
    (else 'default)))

(define (install-library impl cfg library dir)
  (if (should-install-library? impl cfg library)
      (let ((installer
             (lookup-installer (or (conf-get cfg 'installer)
                                   (installer-for-implementation impl cfg)))))
        (installer impl cfg library dir))))

;; The default builder just renames files per implementation.
;; Returns a new library object with any renames.
(define (default-builder impl cfg library dir)
  (let* ((library-file (get-library-file cfg library))
         (ext (get-library-extension impl cfg))
         (src-library-file (make-path dir library-file))
         (library-dir (path-directory src-library-file))
         (dest-library-file
          (string-append (library->path cfg library) "." ext))
         (dest-dir
          (path-directory (make-path dir dest-library-file)))
         (include-files
          (library-include-files impl cfg (make-path dir library-file)))
         (rewrite-include-files
          ;; Rewrite if any include has the same path as the library
          ;; declaration file after extension renaming.
          ;; TODO: Also rewrite for implementations which require certain
          ;; characters to be escaped.
          ;; TODO: Also rewrite if multiple libs use same file names?
          ;; For now we assume libraries with the same prefix cooperate.
          (filter-map
           (lambda (x)
             (and (equal? x (make-path dir dest-library-file))
                  (list x (string-append x ".renamed.scm"))))
           include-files))
         (relative-rewrite-include-files
          (map (lambda (x)
                 (list (path-relative-to (car x) library-dir)
                       (path-relative-to (cadr x) library-dir)))
               rewrite-include-files)))
    ;; ensure the build directory exists
    (create-directory* dest-dir)
    ;; rename or copy includes
    (for-each
     (lambda (x)
       (rename-file (car x) (cadr x)))
     rewrite-include-files)
    (for-each
     (lambda (x)
       (let ((dest-file (make-path dest-dir (path-relative x library-dir))))
         (install-directory cfg (path-directory dest-file))
         (install-file cfg x dest-file)
         dest-file))
     (filter (lambda (f) (not (equal? f dest-library-file))) include-files))
    ;; install the library declaration file
    (cond
     ((pair? rewrite-include-files)
      ;; If we needed to rename an include file, we also need to rewrite
      ;; the library declaration itself to point to the new location.
      ;; TODO: rewrite with a structural editor to preserve formatting
      (let ((library
             (library-rewrite-includes
              (car (file->sexp-list src-library-file))
              relative-rewrite-include-files)))
        (install-sexp-file cfg library (make-path dir dest-library-file))
        (if (not (equal? library-file dest-library-file))
            (delete-file src-library-file))))
     ((not (equal? library-file dest-library-file))
      (rename-file src-library-file (make-path dir dest-library-file))))
    ;; return the rewritten library
    (library-rewrite-includes
     library
     (append relative-rewrite-include-files
             (if (equal? library-file dest-library-file)
                 '()
                 (list (list library-file dest-library-file)))))))

;; first call the default builder to fix paths, then compile any ffi files
(define (chibi-builder impl cfg library dir)
  (let* ((library (default-builder impl cfg library dir))
         (library-file (make-path dir (get-library-file cfg library)))
         (shared-includes
          (library-shared-include-files impl cfg library-file))
         (local-test? (file-exists? "tools/chibi-ffi"))
         (chibi-ffi
          (if local-test?
              (scheme-program-command impl cfg "tools/chibi-ffi")
              '("chibi-ffi")))
         (cc (string-split (or (conf-get cfg 'cc)
                               (get-environment-variable "CC")
                               "cc")))
         (cflags (string-split (or (conf-get cfg 'cflags)
                                   (get-environment-variable "CFLAGS")
                                   ""))))
    (let lp ((ls shared-includes))
      (if (null? ls)
          library
          (let* ((base (car ls))
                 (stub-file (string-append base ".stub"))
                 (c-file (string-append base ".c"))
                 (so-file (string-append base (cond-expand (macosx ".dylib")
                                                           (else ".so"))))
                 (so-flags (cond-expand (macosx '("-dynamiclib" "-Oz"))
                                        (else '("-fPIC" "-shared" "-Os"))))
                 (lib-flags
                  (map (lambda (lib) (string-append "-l" lib))
                       (library-foreign-dependencies impl cfg library)))
                 (ffi-cmd
                  `(,@chibi-ffi
                    "-c" "-cc" ,(car cc)
                    "-f" ,(string-join cflags " ")
                    "-f" ,(string-join lib-flags " ")
                    ,@(if local-test? '("-f" "-Iinclude -L.") '())
                    ,@(if (pair? (cdr cc))
                          (list "-f" (string-join (cdr cc) " "))
                          '())
                    ,stub-file))
                 (cc-cmd
                  `(,@cc ,@cflags ,@so-flags
                         ,@(if local-test? '("-Iinclude" "-L.") '())
                         "-o" ,so-file ,c-file "-lchibi-scheme"
                         ,@lib-flags)))
            (when (or (and (file-exists? c-file)
                           (or (system? cc-cmd)
                               (yes-or-no?
                                cfg "couldn't compile chibi ffi c code: "
                                c-file " - install anyway?")))
                      (and (file-exists? stub-file)
                           (or (system? ffi-cmd)
                               (yes-or-no? cfg "couldn't compile stub: "
                                           stub-file " - install anyway?")))
                      (yes-or-no? cfg "can't find ffi stub or c source for: "
                                  base " - install anyway?"))
              (lp (cdr ls))))))))

(define (chicken-builder impl cfg library dir)
  (let* ((library-file (make-path dir (get-library-file cfg library)))
         (library-base (chicken-library-base (library-name library)))
         (so-path (make-path dir (string-append library-base ".so")))
         (imp-path (string-append library-base ".import.scm")))
    (with-directory
     dir
     (lambda ()
       (let ((res (system 'csc '-R 'r7rs '-X 'r7rs '-s '-J '-o so-path
                          '-I (path-directory library-file) library-file)))
         (and (or (and (pair? res) (zero? (cadr res)))
                  (yes-or-no? cfg "chicken failed to build: "
                              (library-name library-name)
                              " - install anyway?"))
              library))))))

(define (cyclone-builder impl cfg library dir)
  (let* ((library-file (make-path dir (get-library-file cfg library)))
         (so-path (make-path dir (string-append (path-strip-extension library-file) ".so"))))
    (with-directory
     dir
     (lambda ()
       (let ((res (system 'cyclone '-o so-path
                          '-A (path-directory library-file) library-file)))
         (and (or (and (pair? res) (zero? (cadr res)))
                  (yes-or-no? cfg "cyclone failed to build: "
                              (library-name library)
                              " - install anyway?"))
              library))))))

(define (guile-builder impl cfg library dir)
  (let* ((library-file (get-library-file cfg library))
         (src-library-file (make-path dir library-file))
         (library-dir (path-directory src-library-file))
         (dest-library-file
          (string-append (library->path cfg library) ".go"))
         (dest-dir
          (path-directory (make-path dir dest-library-file))))
    ;; ensure the build directory exists
    (create-directory* dest-dir)
    (with-directory
     dir
     (lambda ()
       (and (system 'guild 'compile '-O0 '--r7rs '-o dest-library-file src-library-file)
            library)))))

(define (lookup-builder builder)
  (case builder
    ((chibi) chibi-builder)
    ((chicken) chicken-builder)
    ((cyclone) cyclone-builder)
    ((guile) guile-builder)
    (else default-builder)))

(define (builder-for-implementation impl cfg)
  (case impl
    ((chibi chicken cyclone guile) impl)
    (else 'default)))

(define (build-library impl cfg library dir)
  (let ((builder (lookup-builder (or (conf-get cfg 'builder)
                                     (builder-for-implementation impl cfg)))))
    (builder impl cfg library dir)))

;; strip extension, add #! if needed, copy and chmod
(define (default-program-builder impl cfg prog dir)
  (let* ((path (make-path dir (get-program-file cfg prog)))
         (dest (path-strip-extension path))
         (src-lines (call-with-input-file path port->string-list))
         (script (scheme-script-command impl cfg)))
    (if (equal? path dest)
        (system "cp" path (string-append path ".bak")))
    (call-with-output-file dest
      (lambda (out)
        (when script
          (display "#! " out)
          (display script out)
          (newline out)) 
        (for-each
         (lambda (line) (display line out) (newline out))
         (if (and (pair? src-lines) (string-prefix? "#!" (car src-lines)))
             (cdr src-lines)
             src-lines))))
    (chmod dest #o755)
    prog))

(define (chicken-program-builder impl cfg prog dir)
  (let ((path (get-program-file cfg prog)))
    (with-directory
     dir
     (lambda ()
       (let ((res (system 'csc '-R 'r7rs '-X 'r7rs
                          '-I (path-directory path) path)))
         (and (or (and (pair? res) (zero? (cadr res)))
                  (yes-or-no? cfg "chicken failed to build: "
                              path " - install anyway?"))
              prog))))))

(define (cyclone-program-builder impl cfg prog dir)
  (let ((path (get-program-file cfg prog)))
    (with-directory
     dir
     (lambda ()
       (let ((res (system 'cyclone
                          '-A (path-directory path) path)))
         (and (or (and (pair? res) (zero? (cadr res)))
                  (yes-or-no? cfg "cyclone failed to build: "
                              path " - install anyway?"))
              prog))))))

(define (lookup-program-builder builder)
  (case builder
    ((chicken) chicken-program-builder)
    ((cyclone) cyclone-program-builder)
    (else default-program-builder)))

(define (program-builder-for-implementation impl cfg)
  (case impl
    ((chicken) 'chicken)
    ((cyclone) 'cyclone)
    (else 'default)))

(define (build-program impl cfg prog dir)
  (let ((builder (lookup-program-builder
                  (or (conf-get cfg 'program-builder)
                      (program-builder-for-implementation impl cfg)))))
    (builder impl cfg prog dir)))

(define (default-program-installer impl cfg prog dir)
  (let* ((program-file (path-strip-extension (get-program-file cfg prog)))
         (dest-program-file (program-install-name prog))
         (install-dir (get-install-binary-dir impl cfg)))
    (let ((path (make-path install-dir dest-program-file)))
      (install-directory cfg (path-directory path))
      (install-file cfg (make-path dir program-file) path)
      (list path))))

(define (lookup-program-installer installer)
  (case installer
    (else default-program-installer)))

(define (install-program impl cfg prog dir)
  (let ((installer (lookup-program-installer
                    (conf-get cfg 'program-installer))))
    (installer impl cfg prog dir)))

(define (install-data-file impl cfg file dir)
  (let* ((src (if (pair? file) (cadr file) file))
         (dest0 (if (pair? file) (third file) file))
         (install-dir (get-install-data-dir impl cfg))
         (dest (path-resolve dest0 install-dir)))
    (create-directory* (path-directory dest))
    (install-file cfg (make-path dir src) dest)
    dest))

(define (fetch-package cfg url)
  (resource->bytevector cfg url))

(define (path-strip-top file)
  (let ((pos (string-find file #\/)))
    (if (string-cursor<? pos (string-cursor-end file))
        (substring-cursor file (string-cursor-next file pos))
        file)))

(define (maybe-invalid-package-reason impl cfg pkg)
  (let ((res (invalid-package-reason pkg)))
    (and res
         (not (yes-or-no? cfg "Package invalid: " res "\nProceed anyway?"))
         res)))

(define (package-maybe-digest-mismatches impl cfg pkg raw)
  (and (not (conf-get cfg 'ignore-digests?))
       (let ((res (package-digest-mismatches cfg pkg raw)))
         (and res
              (not (yes-or-no? cfg "Package checksum mismatches: " res
                               "\nProceed anyway?"))
              res))))

(define (package-maybe-signature-mismatches repo impl cfg pkg raw)
  (cond
   ((conf-get cfg 'ignore-signature? #t) #f)
   ((not (cond
          ((assq 'signature (cdr pkg))
           => (lambda (x) (assoc-get (cdr x) 'rsa)))
          (else #f)))
    (and (conf-get cfg 'require-signature?)
         (not (yes-or-no? cfg "Package signature missing.\nProceed anyway?"))
         '(package-signature-missing)))
   (else
    (let ((res (package-signature-mismatches repo cfg pkg raw)))
      (and res
           (not (yes-or-no? cfg "Package signature mismatches: " res
                            "\nProceed anyway?"))
           res)))))

;; install from a raw, unzipped snowball as an in-memory bytevector
(define (install-package-from-snowball repo impl cfg pkg snowball)
  (cond
   ((not (tar-safe? snowball))
    (die 2 "package tarball should contain a single relative directory: "
         (tar-files snowball)))
   ((package-maybe-digest-mismatches impl cfg pkg snowball)
    => (lambda (x) (die 2 "package checksum didn't match: " x)))
   ((package-maybe-signature-mismatches repo impl cfg pkg snowball)
    => (lambda (x) (die 2 "package signature didn't match: " x)))
   (else
    (call-with-temp-dir
     "pkg"
     (lambda (dir preserve)
       (tar-extract snowball (lambda (f) (make-path dir (path-strip-top f))))
       (let* ((ordered-lib-names
               (reverse
                (topological-sort
                 (map (lambda (lib)
                        (cons (library-name lib)
                              (library-dependencies impl cfg lib)))
                      (package-libraries pkg)))))
              (ordered-libs
               (filter-map
                (lambda (lib-name)
                  (find (lambda (x) (equal? lib-name (library-name x)))
                        (package-libraries pkg)))
                ordered-lib-names))
              (libs (filter-map (lambda (lib) (build-library impl cfg lib dir))
                                ordered-libs)))
         (if (test-package impl cfg pkg dir)
             (let* ((data-files
                     (append-map
                      (lambda (file)
                        (install-data-file impl cfg file dir))
                      (package-data-files pkg)))
                    (lib-files
                     (append-map
                      (lambda (lib)
                        (install-library impl cfg lib dir))
                      libs))
                    (prog-files
                     (if (conf-program-implementation? impl cfg)
                         (append-map
                          (lambda (prog)
                            (build-program impl cfg prog dir)
                            (install-program impl cfg prog dir))
                          (package-programs pkg))
                         '()))
                    (installed-files
                     (append data-files lib-files prog-files)))
               (if (pair? installed-files)
                   (install-package-meta-info
                    impl cfg
                    `(,@(remove (lambda (x)
                                  (and (pair? x)
                                       (eq? 'installed-files (car x))))
                                pkg)
                      (installed-files ,@installed-files)))))
             (preserve))))))))

(define (install-package-from-file repo impl cfg file)
  (let ((pkg (package-file-meta file))
        (snowball (maybe-gunzip (file->bytevector file))))
    (install-package-from-snowball repo impl cfg pkg snowball)))

(define (install-package repo impl cfg pkg)
  (cond
   ((maybe-invalid-package-reason impl cfg pkg)
    => (lambda (x) (die 2 "package invalid: " x)))
   ((package-url repo pkg)
    => (lambda (url)
         (let* ((raw (fetch-package cfg url))
                (snowball (maybe-gunzip raw)))
           (install-package-from-snowball repo impl cfg pkg snowball))))
   (else
    (die 2 "package missing url: " (package-name pkg)))))

(define (install-for-implementation repo impl cfg pkgs)
  (for-each
   (lambda (pkg) (install-package repo impl cfg pkg))
   pkgs))

;; --always-yes implies first candidate, --always-no implies none
(define (select-best-candidate impl cfg repo candidates)
  (cond
   ((or (null? (cdr candidates))
        (conf-get cfg 'always-yes?))
    (car candidates))
   ((conf-get cfg 'always-no?)
    #f)
   (else
    (display "Select a package:\n")
    (let lp ((ls candidates) (i 1))
      (if (pair? ls)
          (let ((pkg (car ls)))
            (display "  ") (display i)
            (display "  ") (display (package-name pkg))
            (display " ") (display (package-version pkg))
            (display " (") (display (package-author repo pkg #t))
            (display ")\n")
            (lp (cdr ls) (+ i 1)))))
    (let ((n (input-number cfg 'candidate-number "Candidate number: "
                           1 1 (length candidates))))
      (list-ref candidates (- n 1))))))

;; Choose packages for the corresponding libraries, and recursively
;; select uninstalled packages.
(define (expand-package-dependencies repo impl cfg lib-names)
  (let ((current (installed-libraries impl cfg))
        (auto-upgrade-dependencies?
         (conf-get cfg '(command install auto-upgrade-dependencies?))))
    (let lp ((ls lib-names) (res '()) (ignored '()))
      (cond
       ((null? ls) res)
       ((find (lambda (pkg) (package-provides? pkg (car ls))) res)
        (lp (cdr ls) res ignored))
       (else
        (let* ((current-version
                (cond ((assoc (car ls) current)
                       => (lambda (x) (package-version (cdr x))))
                      (else #f)))
               (providers
                (filter (lambda (pkg) (package-provides? pkg (car ls)))
                        (cdr repo)))
               (candidates
                (filter
                 (lambda (pkg)
                   (or (not current-version)
                       (and (or auto-upgrade-dependencies?
                                (member (car ls) lib-names))
                            (version>? (package-version pkg)
                                       current-version))))
                 providers)))
          (cond
           ((member (car ls) ignored)
            (lp (cdr ls) res ignored))
           ((and (null? candidates) (assoc (car ls) current))
            (if (member (car ls) lib-names)
                (warn "skipping already installed library: " (car ls)))
            (lp (cdr ls) res (cons (car ls) ignored)))
           ((and (null? candidates)
                 (not (assoc (car ls) current))
                 (pair? (car ls))
                 (implementation-supports-natively? impl cfg (car ls)))
            ;; assume certain core libraries already installed
            ;; (info "assuming core library installed: " (car ls))
            (lp (cdr ls) res (cons (car ls) ignored)))
           ((and (null? candidates) (member (car ls) lib-names))
            (die 2 "Can't find package: " (car ls)))
           ((null? candidates)
            (cond
             ((yes-or-no? cfg "Can't find package: " (car ls)
                          ".  Proceed anyway?")
              (lp (cdr ls) res (cons (car ls) ignored)))
             (else
              (die 2 "No candidates, not installing: " (car ls)))))
           ((select-best-candidate impl cfg repo candidates)
            => (lambda (pkg)
                 (lp (append (package-dependencies impl cfg pkg)
                             (package-test-dependencies impl cfg pkg)
                             (cdr ls))
                     (cons pkg res)
                     ignored)))
           (else
            (warn "no candidate selected")
            (lp (cdr ls) res ignored)))))))))

;; First lookup dependencies for all implementations so we can
;; download in a single batch.  Then perform the installations a
;; single implementation at a time.
(define (command/install cfg spec . args)
  (let*-values
      (((repo) (current-repositories cfg))
       ((impls) (conf-selected-implementations cfg))
       ((impl-cfgs) (map (lambda (impl)
                           (conf-for-implementation cfg impl))
                         impls))
       ((package-files lib-names) (partition package-file? args))
       ((lib-names) (map parse-library-name lib-names))
       ((impl-pkgs)
        (map (lambda (impl cfg)
               (expand-package-dependencies repo impl cfg lib-names))
             impls
             impl-cfgs)))
    (for-each
     (lambda (impl cfg pkgs)
       (when (conf-get cfg 'verbose?)
         (if (pair? pkgs)
             (info `(installing packages: ,(map package-name pkgs) for ,impl)))
         (if (pair? package-files)
             (info `(installing files: ,package-files for ,impl))))
       ;; install by name and dependency
       (install-for-implementation repo impl cfg pkgs)
       ;; install by file
       (for-each
        (lambda (pkg-file)
          (install-package-from-file repo impl cfg pkg-file))
        package-files))
     impls
     impl-cfgs
     impl-pkgs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Upgrade - upgrade installed packages.

;; With explicit packages same as install, but by default upgrade all
;; available packages.
(define (command/upgrade cfg spec . args)
  (if (pair? args)
      (apply command/install cfg spec args)
      (let* ((repo (current-repositories cfg))
             (impls (conf-selected-implementations cfg))
             (impl-cfgs (map (lambda (impl)
                               (conf-extend
                                (conf-for-implementation cfg impl)
                                '((command install auto-upgrade-dependencies?)
                                  . #t)))
                             impls)))
        (for-each
         (lambda (impl cfg)
           (let ((pkgs (map cdr (installed-libraries impl cfg))))
             (install-for-implementation repo impl cfg pkgs)))
         impls
         impl-cfgs))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Status - show the status of installed libraries.

(define (command/status cfg spec . args)
  (let* ((impls (conf-selected-implementations cfg))
         (impl-cfgs (map (lambda (impl)
                           (conf-for-implementation cfg impl))
                         impls))
         (sexp? (conf-get cfg 'sexp?)))
    (if sexp? (display "("))
    (for-each
     (lambda (impl impl-cfg)
       (if sexp? (display "("))
       (cond
        ((or sexp? (pair? (cdr impls)))
         (if (not (eq? impl (car impls)))
             (display "\n"))
         (display impl)
         (if (not sexp?) (display ":"))
         (display "\n")))
       (summarize-libraries
        impl-cfg
        (if (pair? args)
            (lookup-installed-libraries
             impl impl-cfg (map parse-library-name args))
            (installed-libraries impl impl-cfg)))
       (if sexp? (display ")\n")))
     impls
     impl-cfgs)
    (if sexp? (display ")\n"))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Implementations - show the currently available implementations.

(define (command/implementations cfg spec . args)
  (for-each
   (lambda (impl) (write (car impl)) (newline))
   (filter (lambda (x) (impl-available? cfg x #f))
           known-implementations)))

;; Abstract user interface for the snow command.  This could be
;; substituted with a different implementation to provide a GUI.

(define (message . args)
  (for-each display args)
  (newline))

(define (info . args)
  (apply message args))

(define (warn msg . args)
  (let ((err (current-error-port)))
    (display "WARNING: " err)
    (display msg err)
    (if (pair? args) (display ": " err))
    (if (and (pair? args) (null? (cdr args)))
        (write (car args) err)
        (for-each (lambda (x) (display "\n  " err) (write x err)) args))
    (newline err)))

(define (die x . args)
  (let ((n (if (number? x) x 2))
        (args (if (number? x) args (cons x args)))
        (err (current-error-port)))
    (for-each (lambda (x) (display x err)) args)
    (newline err)
    (flush-output-port err)
    (exit n)))

(define input-history #f)

(define (conf-input-history-file cfg)
  (or (conf-get cfg 'input-history)
      (string-append (or (conf-get cfg 'snow-dir)
                         (string-append (get-environment-variable "HOME")
                                        "/.snow"))
                     "/input-history.scm")))

(define (restore-history cfg)
  (let ((history-file (conf-input-history-file cfg)))
    (set! input-history
          (or (guard (exn (else #f))
                (list->history (call-with-input-file history-file read)))
              (make-history)))))

(define (save-history cfg)
  (let ((history-file (conf-input-history-file cfg)))
    (guard (exn (else (warn "couldn't save history to " history-file)))
      (create-directory* (path-directory history-file))
      (call-with-output-file history-file
        (lambda (out)
          (write (remove (lambda (x) (equal? x ""))
                         (history->list input-history))
                 out))))))

(define (input cfg name prompt . o)
  (let ((proc (or (and (pair? o) (car o)) (lambda (x) x)))
        (check (or (and (pair? o) (pair? (cdr o)) (cadr o))
                   (lambda (str res lp) res))))
    (let lp ((reason #f))
      (cond
       ((and (not reason) (conf-get cfg name))
        => (lambda (res) (check "" res lp)))
       (else
        (if reason
            (show #t reason fl))
        (let ((str (edit-line 'prompt: (lambda () (show #f prompt))
                              'history: input-history)))
          (history-insert! input-history str)
          (check str (proc str) lp)))))))

(define (input-password cfg name prompt1 . o)
  (let ((prompt2 (or (and (pair? o) (car o))
                     (string-append prompt1 " (confirmation): "))))
    (let lp ()
      (let ((password (edit-line 'hidden?: #t 'prompt: prompt1)))
        (newline)
        (cond
         ((equal? password "")
          (show #t "password must be non-empty\n")
          (lp))
         (else
          (let ((conf (edit-line 'hidden?: #t 'prompt: prompt2)))
            (newline)
            (cond
             ((not (equal? password conf))
              (show #t "password didn't match\n")
              (lp))
             (else
              password)))))))))

(define (input-number cfg name prompt . o)
  (let* ((default (and (pair? o) (car o)))
         (lo (and (pair? o) (pair? (cdr o)) (cadr o)))
         (hi (and (pair? o) (pair? (cdr o)) (pair? (cddr o)) (car (cddr o))))
         (prompt
          (if default (each prompt " [default=" default "]: ") prompt))
         (proc (lambda (str)
                 (if (and default (equal? str ""))
                     default
                     (string->number str))))
         (check
          (lambda (str res fail)
            (cond
             ((not (number? res))
              (fail "not a valid number"))
             ((equal? res default)
              res)
             ((and lo (< res lo))
              (fail (each "too low, must be greater than " lo)))
             ((and hi (> res hi))
              (fail (each "too high, must be less than " hi)))
             (else
              res)))))
    (input cfg name prompt proc check)))

(define (yes-or-no? cfg . prompt)
  (define (is-true? str)
    (and (string? str) (member (string-downcase str) '("#t" "y" "yes")) #t))
  (if (conf-get cfg 'always-no?)
      #f
      (input cfg 'always-yes? (each (each-in-list prompt) " [y/n]: ")
             is-true?)))

;; (chibi io) utils

(define (port-fold kons knil . o)
  (let ((read (if (pair? o) (car o) read))
        (in (if (and (pair? o) (pair? (cdr o)))
                (car (cdr o))
                (current-input-port))))
    (let lp ((acc knil))
      (let ((x (read in)))
        (if (eof-object? x) acc (lp (kons x acc)))))))

(define (port-map fn . o)
  (reverse (apply port-fold (lambda (x ls) (cons (fn x) ls)) '() o)))

(define (port->list read in)
  (port-map (lambda (x) x) read in))

(define (port->sexp-list in)
  (port->list read in))

(define (port->bytevector in)
  (let ((out (open-output-bytevector)))
    (do ((c (read-u8 in) (read-u8 in)))
        ((eof-object? c) (get-output-bytevector out))
      (write-u8 c out))))

;; general utils

(define (read-from-string str)
  (call-with-input-string str read))

(define (display-to-string x)
  (cond ((string? x) x)
        ((symbol? x) (symbol->string x))
        ((number? x) (number->string x))
        (else (call-with-output-string (lambda (out) (display x out))))))

(define (maybe-parse-hex x)
  (if (string? x) (hex-string->bytevector x) x))

;; rsa key utils

(define (lookup-digest name)
  (case name
    ((md5) md5)
    ((sha-224) sha-224)
    ((sha-256) sha-256)
    (else (error "unknown digest: " name))))

(define (rsa-identity=? email)
  (lambda (x)
    (cond ((not email) #f)
          ((assoc-get x 'email eq?)
           => (lambda (e) (string-ci=? email e)))
          (else #f))))

(define (extract-rsa-key ls name)
  (define (hex x)
    (if (integer? x) x (string->number x 16)))
  (cond
   ((assq name ls)
    => (lambda (x)
         (let ((bits (assoc-get ls 'bits))
               (modulus (assoc-get (cdr x) 'modulus))
               (exponent (assoc-get (cdr x) 'exponent)))
           (and bits modulus exponent
                (if (eq? name 'private-key)
                    (make-rsa-key (hex bits) (hex modulus) #f (hex exponent))
                    (make-rsa-key (hex bits) (hex modulus)
                                  (hex exponent) #f))))))
   (else #f)))

(define (extract-rsa-private-key ls)
  (extract-rsa-key ls 'private-key))

(define (extract-rsa-public-key ls)
  (extract-rsa-key ls 'public-key))

;; repositories

(define (repo-url repo)
  (and (pair? repo) (assoc-get (cdr repo) 'url eq?)))

(define (repo-find-publisher repo email)
  (find (rsa-identity=? email)
        (filter (lambda (x) (and (pair? x) (eq? 'publisher (car x))))
                (cdr repo))))

;; packages

(define (package? x)
  (and (pair? x) (eq? 'package (car x)) (every pair? (cdr x))))

(define (package-name package)
  (and (pair? package)
       (eq? 'package (car package))
       (or (cond ((assoc-get (cdr package) 'name)
                  => (lambda (x) (and (pair? x) x)))
                 (else #f))
           (any library-name (package-libraries package))
           (any program-name (package-programs package)))))

(define (package-email pkg)
  (and (package? pkg)
       (let ((sig (assq 'signature (cdr pkg))))
         (and (pair? sig)
              (assoc-get (cdr sig) 'email eq?)))))

(define (strip-email str)
  (string-trim (regexp-replace '(: "<" (* (~ (">"))) ">") str "")))

(define (package-author repo pkg . o)
  (let ((show-email? (and (pair? o) (car o))))
    (cond
     ((not (package? pkg))
      #f)
     ((assoc-get (cdr pkg) 'authors)
      => (lambda (authors)
           (cond (show-email? authors)
                 ((pair? authors) (map strip-email authors))
                 (else (strip-email authors)))))
     (else
      (let ((email (package-email pkg)))
        (or (cond
             ((repo-find-publisher repo email)
              => (lambda (pub)
                   (let ((name (assoc-get pub 'name)))
                     (if (and name show-email?)
                         (string-append name " <" (or email "") ">")
                         (or name email "")))))
             (else #f))
            email))))))

(define (package-maintainer repo pkg . o)
  (let ((show-email? (and (pair? o) (car o))))
    (cond
     ((not (package? pkg))
      #f)
     ((assoc-get (cdr pkg) 'maintainers)
      => (lambda (maint) (if show-email? maint (strip-email maint))))
     (else
      #f))))

(define (package-url repo pkg)
  (let ((url (and (pair? pkg) (assoc-get (cdr pkg) 'url eq?))))
    (and url
         (uri-resolve url (string->path-uri 'http (or (repo-url repo) ""))))))

(define (package-version pkg)
  (and (pair? pkg) (assoc-get (cdr pkg) 'version eq?)))

(define (package-digest-mismatches cfg pkg raw)
  (let ((size (assoc-get (cdr pkg) 'size))
        (actual-size (bytevector-length raw)))
    (if (and (integer? size) (not (= size actual-size)))
        `(size: expected: ,size actual: ,actual-size)
        (let* ((digest-name (assoc-get (cdr pkg) 'digest #f 'sha-256))
               (digest (assoc-get (cdr pkg) digest-name))
               (actual-digest ((lookup-digest digest-name) raw)))
          (and digest
               (not (equal? digest actual-digest))
               `(digest: ,digest-name expected: ,digest
                         actual: ,actual-digest))))))

(define (package-digest-ok? cfg pkg raw)
  (not (package-digest-mismatches cfg pkg raw)))

(define (package-signature-mismatches repo cfg pkg raw)
  (let* ((sig-spec (assoc-get-list (cdr pkg) 'signature))
         (digest-name (assoc-get sig-spec 'digest #f 'sha-256))
         (digest (assoc-get sig-spec digest-name))
         (sig (assoc-get sig-spec 'rsa))
         (email (assoc-get sig-spec 'email))
         (rsa-key-sexp (repo-find-publisher repo email))
         (rsa-key (and (pair? rsa-key-sexp)
                       (extract-rsa-public-key (cdr rsa-key-sexp)))))
    (cond
     ((not email)
      `(sign: missing-email ,sig-spec))
     ((not rsa-key)
      `(sign: unknown-publisher: ,email))
     ((not (rsa-verify? rsa-key
                        (maybe-parse-hex digest)
                        (maybe-parse-hex sig)))
      `(sign: rsa-signature-invalid: digest: ,digest sig: ,sig
              actual: ,(rsa-verify rsa-key (maybe-parse-hex digest))))
     (else #f))))

(define (package-signature-ok? cfg pkg raw)
  (not (package-signature-mismatches cfg pkg raw)))

(define (failure str . args)
  (let ((out (open-output-string)))
    (display str out)
    (cond
     ((pair? args)
      (display ":" out)
      (for-each (lambda (x) (display " " out) (write x out)) args)))
    (get-output-string out)))

(define (invalid-library-reason lib)
  (cond
   ((not (list? lib)) "library must be a list")
   ((not (list? (library-name lib)))
    (failure "library name must be a list" (library-name lib)))
   ((not (every (lambda (x) (or (symbol? x) (integer? x))) (library-name lib)))
    (failure "library name must contain only symbols or integers"
             (library-name lib)))
   (else #f)))

(define (valid-library? lib)
  (not (invalid-library-reason lib)))

(define (invalid-program-reason prog)
  (cond
   ((not (list? prog)) "program must be a list")
   ((not (or (assoc-get prog 'path) (assoc-get prog 'name)))
    "program must have a path")
   (else #f)))

(define (valid-program? prog)
  (not (invalid-program-reason prog)))

(define (invalid-package-reason pkg)
  (cond
   ((not (list? pkg))
    "package must be a list")
   ((not (string? (package-version pkg)))
    (failure "package-version is not a string" (package-version pkg)))
   (else
    (let ((libs (package-libraries pkg))
          (progs (package-programs pkg)))
      (cond
       ((and (not (pair? libs)) (not (pair? progs)))
        "package must contain at least one library or program")
       ((any invalid-library-reason libs))
       ((any invalid-program-reason progs))
       (else #f))))))

(define (valid-package? pkg)
  (not (invalid-package-reason pkg)))

(define (package-for-impl impl cfg pkg)
  (append
   pkg
   (append-map
    (lambda (x)
      (or (and (pair? x) (eq? 'cond-expand (car x))
               (cond
                ((find
                  (lambda (clause) (check-cond-expand impl cfg (car clause)))
                  (cdr x))
                 => cdr)
                (else #f)))
          '()))
    (cdr pkg))))

(define (package-libraries package)
  (and (package? package) (filter library? (cdr package))))

(define (package-programs package)
  (and (package? package) (filter program? (cdr package))))

(define (package-data-files package)
  (and (package? package)
       (append-map cdr (filter data-files? (cdr package)))))

(define (package-provides? package name)
  (and (pair? package)
       (eq? 'package (car package))
       (or (equal? name (assoc-get (cdr package) 'name))
           (find (lambda (x) (equal? name (library-name x)))
                 (package-libraries package)))))

(define (package-dependencies impl cfg package)
  (append-map (lambda (lib) (library-dependencies impl cfg lib))
              (append (package-libraries package)
                      (package-programs package))))

(define (package-test-dependencies impl cfg package)
  (let ((pkg (package-for-impl impl cfg package)))
    (if (or (conf-get cfg '(command install skip-tests?))
            (conf-get cfg '(command upgrade skip-tests?)))
        '()
        (or (assoc-get (cdr pkg) 'test-depends)
            '()))))

(define (package-installed-files pkg)
  (or (and (pair? pkg) (assoc-get-list (cdr pkg) 'installed-files)) '()))

(define (library-separator cfg)
  (conf-get cfg 'library-separator "/"))

(define (library-name->path cfg name)
  (if (null? name)
      ""
      (call-with-output-string
        (lambda (out)
          (let lp ((name name))
            (display (car name) out)
            (cond ((pair? (cdr name))
                   (display (library-separator cfg) out)
                   (lp (cdr name)))))))))

;; map a library to the path name it would be found in (sans extension)
(define (library->path cfg library)
  (library-name->path cfg (library-name library)))

;; find the library declaration file for the given library
(define (get-library-file cfg library)
  (or (assoc-get library 'path)
      (string-append (library->path cfg library) "."
                     (conf-get cfg 'library-extension "sld"))))

(define (package->path cfg pkg)
  (library-name->path cfg (package-name pkg)))

(define (package-name->meta-file cfg name)
  (let ((path (library-name->path cfg name)))
    (string-append (path-directory path) "/."
                   (path-strip-directory path) ".meta")))

(define (get-package-meta-file cfg pkg)
  (package-name->meta-file cfg (package-name pkg)))

(define (get-library-meta-file cfg lib)
  (package-name->meta-file cfg (library-name lib)))

(define (library-file-name file)
  (guard (exn (else #f))
    (let ((x (call-with-input-file file read)))
      (and (pair? x)
           (memq (car x) '(define-library library))
           (list? (cadr x))
           (cadr x)))))

(define (find-library-file cfg lib-name . o)
  (let ((base (string-append (library-name->path cfg lib-name)
                             "."
                             (conf-get cfg 'library-extension "sld"))))
    (let lp ((dirs (append (or (and (pair? o) (car o)) '())
                           (cons "." (conf-get-list cfg 'library-path )))))
      (and (pair? dirs)
           (let ((path (make-path (car dirs) base)))
             (or (and (file-exists? path)
                      (equal? lib-name (library-file-name path))
                      path)
                 (lp (cdr dirs))))))))

(define (tar-file? file)
  (or (equal? (path-extension file) "tgz")
      (and (member (path-extension file) '("gz" "bz2"))
           (equal? (path-extension (path-strip-extension file)) "tar"))))

(define (package-file-unzipped file)
  (and (tar-file? file)
       (if (member (path-extension file) '("tgz" "gz"))
           (gunzip (let* ((in (open-binary-input-file file))
                          (res (port->bytevector in)))
                     (close-input-port in)
                     res))
           file)))

(define (package-file-meta file)
  (let* ((unzipped-file (package-file-unzipped file))
         (package-file
          (and unzipped-file
               (find
                (lambda (x)
                  (and (equal? "package.scm" (path-strip-directory x))
                       (equal? "." (path-directory (path-directory x)))))
                (tar-files unzipped-file)))))
    (and package-file
         (guard (exn (else #f))
           (let* ((str (utf8->string
                        (tar-extract-file unzipped-file package-file)))
                  (package (read (open-input-string str))))
             (and (pair? package)
                  (eq? 'package (car package))
                  package))))))

(define (package-file? file)
  (and (package-file-meta file) #t))

(define (package-file-top-directory file)
  (let ((unzipped-file (package-file-unzipped file)))
    (and unzipped-file
         (let lp ((file (car (tar-files unzipped-file))))
           (let ((dir (path-directory file)))
             (if (member dir '("" "." "/"))
                 file
                 (lp dir)))))))

;; libraries

(define (library? x)
  (and (pair? x) (eq? 'library (car x)) (every pair? (cdr x))))

(define (library-name lib)
  (and (pair? lib) (assoc-get (cdr lib) 'name eq?)))

(define (library-url lib)
  (and (pair? lib) (assoc-get (cdr lib) 'url eq?)))

(define (library-for-impl impl cfg lib)
  (append
   lib
   (append-map
    (lambda (x)
      (or (and (pair? x) (eq? 'cond-expand (car x))
               (cond
                ((find
                  (lambda (clause) (check-cond-expand impl cfg (car clause)))
                  (cdr x))
                 => cdr)
                (else #f)))
          '()))
    (cdr lib))))

(define (library-dependencies impl cfg lib)
  (append-map
   (lambda (x) (or (and (pair? x) (eq? 'depends (car x)) (cdr x)) '()))
   (cdr (library-for-impl impl cfg lib))))

(define (library-foreign-dependencies impl cfg lib)
  (append-map
   (lambda (x) (or (and (pair? x) (eq? 'foreign-depends (car x)) (cdr x)) '()))
   (cdr (library-for-impl impl cfg lib))))

(define (parse-library-name str)
  (cond
   ((pair? str) str)
   ((equal? "" str) (error "empty library name"))
   ((eqv? #\( (string-ref str 0)) (read-from-string str))
   (else (map (lambda (x) (or (string->number x) (string->symbol x)))
              (string-split str #\.)))))

(define (check-cond-expand impl config test)
  (define (library-installed? config name)
    ;; assume it could be installed for now... this is effectively a
    ;; "suggested" package rather than a required one
    #t)
  (cond
   ((symbol? test)
    (or (eq? test 'else)
        (eq? test impl)
        (memq test (conf-get-list config 'features))
        (memq test (impl->features impl))))
   ((pair? test)
    (case (car test)
      ((not) (not (check-cond-expand impl config (cadr test))))
      ((and) (every (lambda (x) (check-cond-expand impl config x)) (cdr test)))
      ((or) (any (lambda (x) (check-cond-expand impl config x)) (cdr test)))
      ((library) (every (lambda (x) (library-installed? config x)) (cdr test)))
      (else
       (warn "unknown cond-expand form" test)
       #f)))
   (else #f)))

(define (library-analyze-body impl config body dir)
  (let lp ((ls body) (include-decls '()) (res '()))
    (cond
     ((null? ls) (values (reverse res) (reverse include-decls)))
     (else
      (let ((decl (car ls)))
        (case (and (pair? decl) (car decl))
          ((cond-expand)
           (cond
            ((find (lambda (x) (check-cond-expand impl config (car x)))
                   (cdar ls))
             => (lambda (x) (lp (append (cdr x) (cdr ls)) include-decls res)))
            (else (lp (cdr ls) include-decls res))))
          ((include-library-declarations)
           (let* ((ls (if (pair? (cddr decl))
                          `((include-library-declarations ,@(cddr decl))
                            ,@(cdr ls))
                          (cdr ls)))
                  (file (make-path dir (cadr decl)))
                  (dir (path-directory file))
                  (include-decls (cons file include-decls))
                  (sexp (call-with-input-file file port->sexp-list)))
             (if (and (pair? sexp) (list? sexp))
                 (let-values (((lib sub-include-decls)
                               (library-analyze-body impl config sexp dir)))
                   (lp ls
                       (append (reverse sub-include-decls) include-decls)
                       (append (reverse lib) res)))
                 (lp ls include-decls res))))
          (else
           (lp (cdr ls)
               include-decls
               (if (pair? decl) (cons decl res) res)))))))))

;; We can't use the native library system introspection since we may
;; be analyzing a library which can't be loaded in the native system.
(define (library-analyze impl config file)
  (let ((sexp (call-with-input-file file read)))
    (and (list? sexp)
         (memq (car sexp) '(define-library library define-module module))
         (pair? sexp)
         (pair? (cdr sexp))
         (library-analyze-body impl config (cddr sexp) (path-directory file)))))

(define (library-include-files impl config file)
  (let-values (((lib include-decls) (library-analyze impl config file))
               ((dir) (path-directory file)))
    (append
     (append-map
      (lambda (x) (map (lambda (y) (make-path dir y)) (cdr x)))
      (filter (lambda (x) (and (pair? x) (memq (car x) '(include include-ci))))
              lib))
     include-decls)))

(define (library-shared-include-files impl config file)
  (let-values (((lib include-decls) (library-analyze impl config file))
               ((dir) (path-directory file)))
    (append-map
     (lambda (x) (map (lambda (y) (make-path dir y)) (cdr x)))
     (filter (lambda (x) (and (pair? x) (eq? (car x) 'include-shared)))
             lib))))

(define (library-rewrite-includes x rules)
  (define (recurse x) (library-rewrite-includes x rules))
  (define (rewrite x)
    (cond ((find (lambda (r) (and (pair? r) (equal? x (car r)))) rules) => cadr)
          (else x)))
  (cond
   ((pair? x)
    (case (car x)
      ((include include-ci)
       (cons (car x) (map rewrite (cdr x))))
      ((cond-expand)
       (cons (car x)
             (map (lambda (y) (cons (car y) (map recurse (cdr y)))) (cdr x))))
      ((define-library library)
       (cons (car x) (map recurse (cdr x))))
      ;; support define-library as well as the package format
      ((path) (cons (car x) (map rewrite (cdr x))))
      (else x)))
   (else x)))

;; programs

(define (program? x)
  (and (pair? x) (eq? 'program (car x)) (every pair? (cdr x))))

(define (program-name prog)
  (and (pair? prog)
       (cond ((assoc-get (cdr prog) 'name eq?))
             ((assoc-get (cdr prog) 'path eq?)
              => (lambda (p) (list (string->symbol (path-strip-directory p)))))
             (else #f))))

(define (get-program-file cfg prog)
  (cond ((assoc-get prog 'path))
        ((assoc-get prog 'name)
         => (lambda (name) (library-name->path cfg (list (last name)))))
        (else (error "program missing path: " prog))))

(define (program-install-name prog)
  (or (assoc-get (cdr prog) 'install-name eq?)
      (path-strip-extension
       (path-strip-directory
        (assoc-get (cdr prog) 'path eq?)))))

;; data files

(define (data-files? x)
  (and (pair? x) (eq? 'data-files (car x))))

(define-library (chibi snow commands)
  (export command/package
          command/gen-key
          command/reg-key
          command/sign
          command/verify
          command/upload
          command/implementations
          command/index
          command/install
          command/remove
          command/search
          command/show
          command/status
          command/update
          command/upgrade)
  (import (scheme base)
          (scheme char)
          (scheme eval)
          (scheme file)
          (scheme lazy)
          (scheme load)
          (scheme process-context)
          (scheme time)
          (scheme read)
          (scheme write)
          (srfi 1)
          (srfi 27)
          (srfi 95)
          (chibi snow interface)
          (chibi snow package)
          (chibi snow utils)
          (chibi ast)
          (chibi bytevector)
          (chibi config)
          (chibi crypto md5)
          (chibi crypto rsa)
          (chibi crypto sha2)
          (chibi doc)
          (chibi filesystem)
          (chibi io)
          (chibi match)
          (chibi modules)
          (chibi net http)
          (chibi process)
          (chibi pathname)
          (chibi regexp)
          (chibi show)
          (chibi show pretty)
          (chibi string)
          (chibi sxml)
          (chibi system)
          (chibi tar)
          (chibi temp-file)
          (chibi uri)
          (chibi zlib))
  (cond-expand
   ((library (srfi 151)) (import (srfi 151)))
   ((library (srfi 33)) (import (srfi 33)))
   (else (import (srfi 60))))
  (cond-expand
   ((library (chibi snow install))
    (import (chibi snow install)))
   (else
    (begin
      (define snow-module-directory "/usr/local/share/snow")
      (define snow-binary-module-directory "/usr/local/lib/snow"))))
  (include "commands.scm"))
(define-library (chibi snow install)
  (import (scheme base))
  (export snow-module-directory snow-binary-module-directory)
  (begin
   (define snow-module-directory "/usr/local/share/snow")
   (define snow-binary-module-directory "/usr/local/lib/snow")))

(define-library (chibi snow utils)
  (export find-in-path find-sexp-in-path
          write-to-string display-to-string
          resource->bytevector uri-normalize uri-directory
          version-split version-compare version>? version>=?
          topological-sort
          known-implementations impl->version impl->features)
  (import (scheme base)
          (scheme char)
          (scheme file)
          (scheme lazy)
          (scheme read)
          (scheme write)
          (scheme process-context)
          (srfi 1)
          (chibi config)
          (chibi char-set)
          (chibi net http)
          (chibi pathname)
          (chibi process)
          (chibi string)
          (chibi uri))
  (cond-expand
   (chibi (import (chibi io)))
   (chicken
    (begin
      (define (port->bytevector in) (read-bytevector #f in))
      (define (file->bytevector in)
        (call-with-input-file in port->bytevector))
      (define (call-with-output-string proc)
        (let ((out (open-output-string)))
          (proc out)
          (get-output-string out))))))
  (include "utils.scm"))
(define (write-to-string x)
  (call-with-output-string (lambda (out) (write x out))))

(define known-implementations
  `((chibi "chibi-scheme" (chibi-scheme -V) "0.7.3"
           ,(delay
              (process->sexp
               '(chibi-scheme -p "(features)"))))
    (chicken "chicken" (csi -release) "4.9.0"
             ;; work around Chicken's write() not quoting 64bit and
             ;; 32bit properly
             ,(delay
                (process->sexp
                 `(csi -R r7rs -R srfi-1 -e ,(write-to-string
                                              '(write
                                                (filter (lambda (x)
                                                          (not (or (eq? x '|64bit|)
                                                                   (eq? x '|32bit|))))
                                                        (features))))))))
    (cyclone "cyclone" (icyc -vn) "0.5.3"
             ,(delay
                (process->sexp
                 '(icyc -p "(features)"))))
    (foment "foment" #f #f
            ,(delay
               (process->sexp
                '(foment -e "(write (features))"))))
    (gauche "gosh" (gosh -E "print (gauche-version)") "0.9.4"
            ,(delay
               (process->sexp
                '(gosh -uscheme.base -e "(write (features))"))))
    (guile "guile" (guile -e "(display (version))") "3.0.8"
           ,(delay
              (process->sexp
               '(guile --r7rs -c "(import (scheme base)) (display (features))"))))
    (kawa "kawa" (kawa --version) "2.0"
          ,(delay
             (process->sexp
              '(kawa -e "(write (features))"))))
    (larceny "larceny" (larceny --version) "v0.98"
             ,(delay '()))
    (sagittarius "sagittarius" #f #f
                 ,(delay
                    (process->sexp
                     '(sagittarius -I "(scheme base)" -e "(write (features))"))))))

(define (impl->version impl cmd)
  (let* ((lines (process->string-list cmd))
         (line (and (pair? lines) (string-split (car lines)))))
    (and (pair? line)
         (if (and (pair? (cdr line))
                  (let ((x (string-downcase (car line)))
                        (name (symbol->string impl)))
                    (or (equal? x name)
                        (equal? x (string-append name "-scheme")))))
             (cadr line)
             (car line)))))

(define (target-is-host? impl)
  (case impl
    ((chibi) (cond-expand (chibi #t) (else #f)))
    ((gauche) (cond-expand (gauche #t) (else #f)))
    ((sagittarius) (cond-expand (sagittarius #t) (else #f)))
    (else #f)))

(define (impl->features impl)
  (cond
   ((target-is-host? impl)
    (features))
   ((assq impl known-implementations)
    => (lambda (impl)
         (force (fifth impl))))
   (else '())))

(define (find-in-path file . o)
  (any (lambda (dir)
         (let ((path (make-path dir file)))
           (and (file-exists? path) path)))
       (if (pair? o)
           (car o)
           (string-split (get-environment-variable "PATH") #\:))))

(define (find-sexp-in-path file dirs . o)
  (let ((pred (if (pair? o) (car o) (lambda (x) #t))))
    (any (lambda (dir)
           (let ((path (make-path dir file)))
             (and (file-exists? path)
                  (guard (exn (else #f))
                    (let ((x (call-with-input-file path read)))
                      (and (pred x) x))))))
         dirs)))

(define (display-to-string x)
  (call-with-output-string
    (lambda (out)
      (if (bytevector? x) (write-bytevector x out) (display x out)))))

(define (resource->bytevector cfg uri)
  (let ((uri (if (uri? uri) uri (string->path-uri 'http uri))))
    (if (uri-host uri)
        (if (conf-get cfg 'use-curl?)
            (process->bytevector `(curl --silent ,(uri->string uri)))
            (call-with-input-url uri port->bytevector))
        (file->bytevector (uri-path uri)))))

;; path-normalize either a uri or path, and return the result as a string
(define (uri-normalize x)
  (cond
   ((uri? x)
    (uri->string (uri-with-path x (path-normalize (uri-path x)))))
   ((not (string? x))
    (error "not a uri" x))
   ((string->uri x)
    => uri-normalize)
   (else
    (path-normalize x))))

(define (uri-directory x)
  (cond
   ((uri? x)
    (uri->string (uri-with-path x (path-directory (uri-path x)))))
   ((not (string? x))
    (error "not a uri" x))
   ((string->uri x)
    => uri-directory)
   (else
    (path-directory x))))

(define (version-split str)
  (if str
      (map (lambda (x) (or (string->number x) x))
        (string-split str (string->char-set "._")))
      '()))

(define (version-compare a b)
  (define (less? x y)
    (cond ((number? x) (if (number? y) (< x y) 1))
          ((number? y) -1)
          (else (string<? x y))))
  (let lp ((as (version-split a))
           (bs (version-split b)))
    (cond
     ((null? as) (if (null? bs) 0 -1))
     ((null? bs) 1)
     ((less? (car as) (car bs)) -1)
     ((less? (car bs) (car as)) 1)
     (else (lp (cdr as) (cdr bs))))))

(define (version>? a b) (> (version-compare a b) 0))
(define (version>=? a b) (>= (version-compare a b) 0))

;; graph is a list of ((vertex dep-vertices ...) ...)
(define (topological-sort graph . o)
  (let ((eq (if (pair? o) (car o) equal?)))
    (cdr
     (let lp ((ls graph) (seen '()) (res '()))
       (if (null? ls)
           (cons seen res)
           (let ((x (caar ls)))
             (if (member x seen eq)
                 (lp (cdr ls) seen res)
                 (let lp2 ((ls2 (cdar ls))
                           (seen (cons x seen))
                           (res res))
                   (cond
                    ((null? ls2)
                     (lp (cdr ls) seen (cons x res)))
                    ((member (car ls2) seen eq)
                     (lp2 (cdr ls2) seen res))
                    ((assoc (car ls2) graph eq)
                     => (lambda (vertices)
                          (let ((tmp (lp (list vertices) seen res)))
                            (lp2 (cdr ls2) (car tmp) (cdr tmp)))))
                    (else
                     (lp2 (cdr ls2)
                          (cons (car ls2) seen)
                          (cons (car ls2) res))))))))))))
;; reload.scm -- automatic module reloading
;; Copyright (c) 2012 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

(define last-modified-time (current-seconds))

(define reload-verbose? (make-parameter #f))

(define (warn msg . args)
  (let ((err (current-error-port)))
    (display msg err)
    (display ":" err)
    (for-each (lambda (a)
                (display " " err)
                (if (string? a) (display a err) (write a err)))
              args)
    (newline err)))

(define (reload module-name)
  (if (reload-verbose?)
      (warn "Reloading module" module-name))
  (let ((old-module (find-module module-name)))
    ;; Remove old entry in modules list.
    (delete-module! module-name)
    (protect (exn (else (warn "Error loading module definition" module-name)
                        (print-exception exn)
                        (print-stack-trace)
                        (add-module! module-name old-module)))
      (load-module-definition module-name)
      (let ((module (find-module module-name)))
        (cond
         ((not module) (warn "Couldn't find module" module-name))
         (else
          (protect (exn (else (warn "Error loading module" module-name)
                              (print-exception exn)
                              (print-stack-trace)
                              (delete-module! module-name)
                              (add-module! module-name old-module)))
            (let ((env (eval-module module-name module)))
              (%import (module-env module) env (env-exports env) #f)))))))))

(define (file-modified? path)
  (and path (> (file-modification-time path) last-modified-time)))

(define (module-definition-modified? module-name module)
  (file-modified? (find-module-file (module-name->file module-name))))

(define (module-includes-modified? module-name module)
  (let ((dir (module-name-prefix module-name)))
    (any
     (lambda (x)
       (and (pair? x) (memq (car x) '(include include-ci))
            (any file-modified?
                 (map (lambda (f) (find-module-file (string-append dir f)))
                      (cdr x)))))
     (module-meta-data module))))

(define (module-modified? module-name module)
  (or (module-definition-modified? module-name module)
      (module-includes-modified? module-name module)))

(define (reload-modified-modules)
  (for-each
   (lambda (x)
     (if (module-modified? (car x) (cdr x))
         (reload (car x))))
   *modules*)
  (set! last-modified-time (current-seconds)))

(define-library (chibi reload)
  (import (chibi)
          (meta)
          (srfi 39)
          (only (chibi time) current-seconds)
          (only (chibi filesystem) file-modification-time))
  (include "reload.scm")
  (export reload reload-modified-modules reload-verbose?))

(define-library (chibi json)
  (import (scheme base)
          (except (srfi 99 records) define-record-type)
          (only (chibi ast) type-name)
          (only (chibi) make-constructor))
  (export string->json json->string json-read json-write
          make-json-reader)
  (include-shared "json")
  (include "json.scm"))

(define-library (chibi loop)
  (export loop for in-list in-lists in-port in-file up-from down-from
          listing listing-reverse appending appending-reverse
          summing multiplying in-string in-string-reverse in-substrings
          in-vector in-vector-reverse)
  (import (chibi))
  (include "loop/loop.scm"))

(define-library (chibi test)
  (export
   ;; basic interface
   test test-equal test-error test-assert test-not test-values
   test-group current-test-group
   test-begin test-end test-syntax-error test-propagate-info
   test-run test-exit test-equal?
   ;; test and group data
   test-get-name! test-group-name test-group-ref
   test-group-set! test-group-inc! test-group-push!
   ;; parameters
   current-test-verbosity
   current-test-applier current-test-skipper current-test-reporter
   current-test-group-reporter test-failure-count
   current-test-epsilon current-test-comparator
   current-test-filters current-test-removers
   current-test-group-filters current-test-group-removers
   current-column-width current-group-indent)
  (import (scheme base)
          (scheme case-lambda)
          (scheme write)
          (scheme complex)
          (scheme process-context)
          (scheme time)
          (chibi diff)
          (chibi term ansi)
          (chibi optional))
  (cond-expand
   (chibi
    (import (only (chibi) pair-source print-exception)))
   (chicken
    (import (only (chicken) print-error-message))
    (begin
      (define (pair-source x) #f)
      (define print-exception print-error-message)))
   (else
    (begin
      (define (pair-source x) #f)
      (define print-exception write))))
  (include "test.scm"))

;;> A nice assert macro.
;;>
;;> Assert macros are common in Scheme, in particular being helpful
;;> for domain checks at the beginning of a procedure to catch errors
;;> as early as possible.  Compared to statically typed languages this
;;> has the advantages that the assertions are optional, and that they
;;> are not limited by the type system.  SRFI 145 provides the related
;;> notion of assumptions, but the motivation there is to provide
;;> hints to optimizing compilers, and these are not required to
;;> actually signal an error.
;;>
;;> \macro{(assert expr [msg ...])}
;;>
;;> Equivalent to SRFI 145 \code{assume} except that an error is
;;> guaranteed to be raised if \var{expr} is false.  Conceptually
;;> shorthand for
;;>
;;> \code{(or \var{expr}
;;>     (error "assertion failed" \var{msg} ...))}
;;>
;;> that is, evaluates \var{expr} and returns it if true, but raises
;;> an exception otherwise.  The error is augmented to include the
;;> text of the failed \var{expr}.  If no additional \var{msg}
;;> arguments are provided then \var{expr} is scanned for free
;;> variables in non-operator positions to report values from, e.g. in
;;>
;;> \code{(let ((x 3))
;;>  (assert (= x (+ x 1))))}
;;>
;;> the error would also report the bound value of \code{x}.  This
;;> uses the technique from Oleg Kiselyov's \hyperlink[http://okmij.org/ftp/Scheme/assert-syntax-rule.txt]{good assert macro},
;;> which is convenient but fallible.  It is thus best to keep the
;;> body of the assertion simple, moving any predicates you need to
;;> external utilities, or provide an explicit \var{msg}.

(define-library (chibi assert)
  (export assert)
  (cond-expand
   (chibi
    (import (chibi))
    (begin
      (define-syntax syntax-identifier?
        (er-macro-transformer
         (lambda (expr rename compare)
           (if (identifier? (cadr expr))
               (car (cddr expr))
               (cadr (cddr expr))))))
      (define-syntax syntax-id-memq?
        (er-macro-transformer
         (lambda (expr rename compare)
           (let ((expr (cdr expr)))
             (if (any (lambda (x) (compare x (car expr))) (cadr expr))
                 (car (cddr expr))
                 (cadr (cddr expr)))))))))
   (else
    (import (scheme base))
    (begin
      ;; from match.scm
      (define-syntax syntax-identifier?
        (syntax-rules ()
          ((_ (x . y) success-k failure-k) failure-k)
          ((_ #(x ...) success-k failure-k) failure-k)
          ((_ x success-k failure-k)
           (let-syntax
               ((sym?
                 (syntax-rules ()
                   ((sym? x sk fk) sk)
                   ((sym? y sk fk) fk))))
             (sym? abracadabra success-k failure-k)))))
      (define-syntax syntax-id-memq?
        (syntax-rules ()
          ((syntax-memq? id (ids ...) sk fk)
           (let-syntax
               ((memq?
                 (syntax-rules (ids ...)
                   ((memq? id sk2 fk2) fk2)
                   ((memq? any-other sk2 fk2) sk2))))
             (memq? random-symbol-to-match sk fk))))))))
  (begin
    (define-syntax extract-vars
      (syntax-rules ()
        ((report-vars (op arg0 arg1 ...) (next ...) res)
         (syntax-id-memq? op (quote quasiquote lambda let let* letrec letrec*
                              let-syntax letrec-syntax let-values let*-values
                              receive match case define define-syntax do)
                          (next ... res)
                          (extract-vars arg0
                                        (extract-vars (op arg1 ...) (next ...))
                                        res)))
        ((report-vars (op . x) (next ...) res)
         (next ... res))
        ((report-vars x (next ...) (res ...))
         (syntax-identifier? x
                             (syntax-id-memq? x (res ...)
                                              (next ... (res ...))
                                              (next ... (res ... x)))
                             (next ... (res ...))))))
    (define-syntax qq-vars
      (syntax-rules ()
        ((qq-vars (next ...) (var ...))
         (next ... `(var ,var) ...))))
    (define-syntax report-final
      (syntax-rules ()
        ((report-final expr msg ...)
         (error "assertion failed" 'expr msg ...))))
    (define-syntax assert
      (syntax-rules ()
        ((assert test)
         (or test
             (extract-vars test (qq-vars (report-final test)) ())))
        ((assert test msg ...)
         (or test
             (report-final test msg ...)))
        ((assert) #t)))))

(define-library (chibi highlight)
  (export highlight highlight-detect-language highlighter-for highlight-style
          highlight-scheme highlight-c highlight-assembly)
  (import (chibi) (srfi 1) (chibi io))
  (include "highlight.scm"))

(define-library (chibi trace)
  (export trace untrace untrace-all trace-cell untrace-cell)
  (import (chibi) (chibi ast) (srfi 38) (srfi 39) (srfi 69))
  (include "trace.scm"))
;; Copyright (c) 2009-2013 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

;; POSIX basename
;; (define (path-strip-directory path)
;;   (if (string=? path "")
;;       path
;;       (let ((end (string-skip-right path #\/)))
;;         (if (zero? end)
;;             "/"
;;             (let ((start (string-find-right path #\/ 0 end)))
;;               (substring-cursor path start end))))))

;;> Returns just the basename of \var{path}, with any directory
;;> removed.  If \var{path} does not contain a directory separator,
;;> return the whole \var{path}.  If \var{path} ends in a directory
;;> separator (i.e. path is a directory), or is empty, return the
;;> empty string.

;; GNU basename
(define (path-strip-directory path)
  (substring-cursor path (string-find-right path #\/)))

;;> Returns just the directory of \var{path}.
;;> If \var{path} is relative (or empty), return \scheme{"."}.

(define (path-directory path)
  (if (string=? path "")
      "."
      (let ((start (string-cursor-start path))
            (end (string-skip-right path #\/)))
        (if (string-cursor=? start end)
            "/"
            (let ((slash (string-find-right path #\/ start end)))
              (if (string-cursor=? start slash)
                  "."
                  (let ((start2 (string-skip-right path #\/ start slash)))
                    (if (string-cursor=? start start2)
                        "/"
                        (substring-cursor path start start2)))))))))

(define (path-extension-pos path)
  (let ((start (string-cursor-start path))
        (end (string-cursor-end path)))
    (let lp ((i end) (dot #f))
      (if (string-cursor<=? i start)
          #f
          (let* ((i2 (string-cursor-prev path i))
                 (ch (string-cursor-ref path i2)))
            (cond ((eqv? #\. ch)
                   (and (string-cursor<? i end) (lp i2 (or dot i))))
                  ((eqv? #\/ ch) #f)
                  (dot)
                  (else (lp i2 #f))))))))

;;> Returns the rightmost extension of \var{path}, not including the
;;> \scheme{"."}.  If there is no extension, returns \scheme{#f}.  The
;;> extension will always be non-empty and contain no \scheme{"."}s.

(define (path-extension path)
  (let ((i (path-extension-pos path)))
    (and i
         (substring-cursor path i))))

;;> Returns \var{path} with the extension, if any, removed,
;;> along with the \scheme{"."}.

(define (path-strip-extension path)
  (let ((i (path-extension-pos path)))
    (if i
        (substring-cursor path
                          (string-cursor-start path)
                          (string-cursor-prev path i))
        path)))

;;> Returns \var{path} with the extension, if any, replaced
;;> with \var{ext}.

(define (path-replace-extension path ext)
  (string-append (path-strip-extension path) "." ext))

;;> Returns \var{path} with any leading ../ removed.

(define (path-strip-leading-parents path)
  (if (string-prefix? "../" path)
      (path-strip-leading-parents
       (substring-cursor
        path
        (string-cursor-forward path (string-cursor-start path) 3)))
      (if (equal? path "..") "" path)))

;;> Returns \scheme{#t} iff \var{path} is an absolute path,
;;> i.e. begins with "/".

(define (path-absolute? path)
  (and (not (string=? "" path)) (eqv? #\/ (string-ref path 0))))

;;> Returns \scheme{#t} iff \var{path} is a relative path.

(define (path-relative? path) (not (path-absolute? path)))

;;> Returns the suffix of \var{path} relative to the directory
;;> \var{dir}, or \scheme{#f} if \var{path} is not contained in
;;> \var{dir}.  If the two are the same (modulo a trailing
;;> \scheme{"/"}), then \scheme{"."} is returned.

(define (path-relative-to path dir)
  (let* ((path (path-normalize path))
         (path-end (string-cursor-end path))
         (dir (path-normalize dir))
         (dir-end (string-cursor-end dir)))
    (call-with-values
        (lambda () (string-mismatch dir path))
      (lambda (i j)
        (cond
         (
          ;;(not (string-cursor<=?
          ;;      (string-cursor-next path (string-cursor-start path))
          ;;      dir-end i path-end))
          (not (and (string-cursor<=?
                     (string-cursor-next dir (string-cursor-start dir))
                     dir-end i)
                    (string-cursor<=? j path-end)))
          (and (string-cursor=? j path-end)
               (string-cursor=? (string-cursor-next dir i) dir-end)
               (eqv? #\/ (string-cursor-ref dir i))
               "."))
         ((string-cursor=? j path-end)
          ".")
         ((eqv? #\/ (string-cursor-ref path j))
          (let ((j2 (string-cursor-next path j)))
            (if (string-cursor=? j2 path-end) "." (substring-cursor path j2))))
         ((eqv? #\/ (string-cursor-ref path (string-cursor-prev path j)))
          (substring-cursor path j))
         (else
          #f))))))

;;> Resolve \var{path} relative to the given directory.  Returns
;;> \var{path} unchanged if already absolute.

(define (path-resolve path dir)
  (if (path-absolute? path) path (make-path dir path)))

;; This looks big and hairy, but it's mutation-free and guarantees:
;;   (string=? s (path-normalize s))  <=>  (eq? s (path-normalize s))
;; i.e. fast and simple for already normalized paths.

;;> Returns a normalized version of path, with duplicate directory
;;> separators removed and "/./" and "x/../" references removed.
;;> Does not take symbolic links into account - this is meant to
;;> be abstract and applicable to paths on remote systems and in
;;> URIs.  Returns \var{path} itself if \var{path} is already
;;> normalized.

(define (path-normalize path)
  (let* ((start (string-cursor-start path))
         (end (string-cursor-end path))
         (end-1 (string-cursor-prev path end)))
    (define (collect i j res)
      (if (string-cursor>=? i j) res (cons (substring-cursor path i j) res)))
    (define (finish i res)
      (if (string-cursor=? start i)
          path
          (string-join (reverse (collect i end res)))))
    ;; loop invariants:
    ;;   - res is a list such that (string-concatenate-reverse res)
    ;;     is always the normalized string up to j
    ;;   - the tail of the string from j onward can be concatenated to
    ;;     the above value to get a partially normalized path referring
    ;;     to the same location as the original path
    (define (inside i j res)
      (if (string-cursor>=? j end)
          (finish i res)
          (if (eqv? #\/ (string-cursor-ref path j))
              (boundary i (string-cursor-next path j) res)
              (inside i (string-cursor-next path j) res))))
    (define (boundary i j res)
      (if (string-cursor>=? j end)
          (finish i res)
          (case (string-cursor-ref path j)
            ((#\.)
             (cond
              ((or (string-cursor=? j end-1)
                   (eqv? #\/ (string-cursor-ref path (string-cursor-next path j))))
               (if (string-cursor=? i j)
                   (boundary (string-cursor-forward path j 2)
                             (string-cursor-forward path j 2)
                             res)
                   (let ((s (substring-cursor path i j)))
                     (boundary (string-cursor-forward path j 2)
                               (string-cursor-forward path j 2)
                               (cons s res)))))
              ((eqv? #\. (string-cursor-ref path (string-cursor-next path j)))
               (if (or (string-cursor>=? j (string-cursor-back path end 2))
                       (eqv? #\/ (string-cursor-ref
                                  path
                                  (string-cursor-forward path j 2))))
                   (if (string-cursor>=? i (string-cursor-prev path j))
                       (if (null? res)
                           (backup j "" '())
                           (backup j (car res) (cdr res)))
                       (backup j (substring-cursor path i j) res))
                   (inside i (string-cursor-forward path j 2) res)))
              (else
               (inside i (string-cursor-next path j) res))))
            ((#\/)
             (boundary (string-cursor-next path j)
                       (string-cursor-next path j)
                       (collect i j res)))
            (else (inside i (string-cursor-next path j) res)))))
    (define (backup j s res)
      (let ((pos (string-cursor-forward path j 3)))
        (cond
         ;; case 1: we're reduced to accumulating parents of the cwd
         ((or (string=? s "/..") (string=? s ".."))
          (boundary pos pos (cons "/.." (cons s res))))
         ;; case 2: the string isn't a component itself, skip it
         ((or (string=? s "") (string=? s ".") (string=? s "/"))
          (if (pair? res)
              (backup j (car res) (cdr res))
              (boundary pos pos (if (string=? s "/") '("/") '("..")))))
         ;; case3: just take the directory of the string
         (else
          (let ((d (path-directory s)))
            (cond
             ((string=? d "/")
              (boundary pos pos (if (null? res) '("/") res)))
             ((string=? d ".")
              (boundary pos pos res))
             (else (boundary pos pos (cons "/" (cons d res))))))))))
    ;; start with boundary if abs path, otherwise inside
    (if (string-cursor=? start end)
        path
        ((if (eqv? #\/ (string-ref path 0)) boundary inside)
         start (string-cursor-next path start) '()))))

;;> Return a new string representing the path where each of \var{args}
;;> is a path component, separated with the directory separator.
;;> \var{args} may include symbols and integers, in addition to
;;> strings.

(define (make-path . args)
  (define (x->string x)
    (cond ((string? x) x)
          ((symbol? x) (symbol->string x))
          ((number? x) (number->string x))
          (else (error "not a valid path component" x))))
  (define (trim-trailing-slash s)
    (substring-cursor s (string-cursor-start s) (string-skip-right s #\/)))
  (if (null? args)
      ""
      (let* ((args0 (x->string (car args)))
             (start (trim-trailing-slash args0)))
        (let lp ((ls (cdr args))
                 (res (if (string=? "" start) '() (list start))))
          (cond
           ((null? ls)
            (if (and (null? res) (not (string=? "" args0)))
                "/"
                (string-join (reverse res))))
           ((pair? (car ls))
            (lp (append (car ls) (cdr ls)) res))
           (else
            (let ((x (trim-trailing-slash (x->string (car ls)))))
              (cond
               ((string=? x "")
                (lp (cdr ls) res))
               ((eqv? #\/ (string-ref x 0))
                (lp (cdr ls) (cons x res)))
               (else
                (lp (cdr ls) (cons x (cons "/" res))))))))))))
(define (exit . code?)
  (%exit (if (pair? code?) 
           (let ((c (car code?)))
            (cond ((integer? c) c)
                  ((eq? #t c) 0)
                  (else 1)))
           0)))
(define-library (chibi win32 process-win32)
  (import (scheme base))
  (export exit)
  (cond-expand
   (windows
    (include-shared "process-win32")
    (include "process-win32.scm"))
   (else
    (import (only (chibi process) exit)))))
(define-library (chibi emscripten)
  (cond-expand
    (emscripten
      (import (chibi) (chibi ast))
      (export eval-script! integer-eval-script string-eval-script
              wait-on-event!)
      (include "emscripten.scm")
      (include-shared "emscripten"))))

;;> Interface to the filesystem and file descriptor objects.
;;> Note that file descriptors are currently represented as
;;> integers, but may be replaced with opaque (and gc-managed)
;;> objects in a future release.

(define-library (chibi filesystem)
  (export duplicate-file-descriptor duplicate-file-descriptor-to
          close-file-descriptor renumber-file-descriptor
          open-input-file-descriptor open-output-file-descriptor
          delete-file link-file symbolic-link-file rename-file
          directory-files directory-fold directory-fold-tree
          delete-file-hierarchy delete-directory
          create-directory create-directory*
          current-directory change-directory with-directory
          open open-pipe make-fifo
          read-link
          file-status               file-link-status
          file-device               file-inode
          file-mode                 file-num-links
          file-owner                file-group
          file-represented-device   file-size
          file-block-size           file-num-blocks
          file-access-time file-change-time
          file-modification-time  file-modification-time/safe
          file-regular?    file-directory?        file-character?
          file-block?      file-fifo?             file-link?
          file-socket?     file-exists?
          get-file-descriptor-flags   set-file-descriptor-flags!
          get-file-descriptor-status  set-file-descriptor-status!
          open/read        open/write             open/read-write
          open/create      open/exclusive         open/truncate
          open/append      open/non-block
          file-lock        file-truncate
          file-is-readable? file-is-writable? file-is-executable?
          chmod chown is-a-tty?)
  (cond-expand
   (chibi
    (export lock/shared lock/exclusive lock/non-blocking lock/unlock)
    (import (chibi) (chibi string))
    (include-shared "filesystem")
    (include "filesystem.scm"))
   (chicken
    (import (scheme base) (srfi 1)
            (only (chicken) delete-file rename-file file-exists?)
            (rename (posix) (file-truncate %file-trunc))
            (chibi string))
    (begin
      (define file-status file-stat)
      (define (file-link-status x) (file-stat x #t))
      (define (stat-dev x) (vector-ref x 9))
      (define (stat-ino x) (vector-ref x 0))
      (define (stat-mode x) (vector-ref x 1))
      (define (stat-nlinks x) (vector-ref x 2))
      (define (stat-uid x) (vector-ref x 3))
      (define (stat-gid x) (vector-ref x 4))
      (define (stat-rdev x) (vector-ref x 10))
      (define (stat-size x) (vector-ref x 5))
      (define (stat-blksize x) (vector-ref x 11))
      (define (stat-blocks x) (vector-ref x 12))
      (define (stat-atime x) (vector-ref x 6))
      (define (stat-mtime x) (vector-ref x 7))
      (define (stat-ctime x) (vector-ref x 8))
      (define (file-mode x) (stat-mode (if (vector? x) x (file-stat x))))
      (define (file-num-links x) (stat-nlinks (if (vector? x) x (file-stat x))))
      (define (file-group x) (stat-gid (if (vector? x) x (file-stat x))))
      (define (file-inode x) (stat-ino (if (vector? x) x (file-stat x))))
      (define (file-device x) (stat-dev (if (vector? x) x (file-stat x))))
      (define (file-represented-device x) (if (vector? x) x (file-stat x)))
      (define (file-block-size x) (stat-blksize (if (vector? x) x (file-stat x))))
      (define (file-num-blocks x) (stat-blocks (if (vector? x) x (file-stat x))))
      (define duplicate-file-descriptor duplicate-fileno)
      (define duplicate-file-descriptor-to duplicate-fileno)
      (define close-file-descriptor file-close)
      (define open-input-file-descriptor open-input-file*)
      (define open-output-file-descriptor open-output-file*)
      (define link-file file-link)
      (define symbolic-link-file create-symbolic-link)
      (define read-link read-symbolic-link)
      (define open file-open)
      (define open-pipe create-pipe)
      (define make-fifo create-fifo)
      (define file-regular? regular-file?)
      (define file-directory? directory?)
      (define file-character? character-device?)
      (define file-block? block-device?)
      (define file-fifo? fifo?)
      (define file-link? symbolic-link?)
      (define file-socket? socket?)
      (define file-is-readable? file-read-access?)
      (define file-is-writable? file-write-access?)
      (define file-is-executable? file-execute-access?)
      (define (get-file-descriptor-flags fileno)
        (file-control fileno fcntl/getfd))
      (define (set-file-descriptor-flags! fileno x)
        (file-control fileno fcntl/setfd x))
      (define (get-file-descriptor-status fileno)
        (file-control fileno fcntl/getfl))
      (define (set-file-descriptor-status! fileno x)
        (file-control fileno fcntl/setfl x))
      (define open/read-write open/rdwr)
      (define open/create open/creat)
      (define open/exclusive open/excl)
      (define open/truncate open/trunc)
      (define open/non-block open/nonblock)
      (define chmod change-file-mode)
      (define is-a-tty? terminal-port?)
      (define (file-truncate port len)
        (%file-trunc (if (integer? port) port (port->fileno port)) len))
      (define (create-directory* dir)
        (create-directory dir #t))
      (define (directory-files dir)
        (cons "." (cons ".." (directory dir #t))))
      (define (directory-fold dir kons knil)
        (fold kons knil (directory-files dir)))
      (define (directory-fold-tree file down up here . o)
        (let ((knil (and (pair? o) (car o)))
              (down (or down (lambda (f acc) acc)))
              (up (or up (lambda (f acc) acc)))
              (here (or here (lambda (f acc) acc))))
          (let fold ((file file) (acc knil))
            (cond
             ((file-directory? file)
              (let lp ((ls (directory-files file)) (acc (down file acc)))
                (cond
                 ((null? ls) (up file acc))
                 ((member (car ls) '("." "..")) (lp (cdr ls) acc))
                 (else
                  (lp (cdr ls) (fold (string-append file "/" (car ls)) acc))))))
             (else
              (here file acc))))))
      (define (delete-file-hierarchy dir . o)
        (delete-directory dir #t))
      (define (renumber-file-descriptor old new)
        (and (duplicate-file-descriptor-to old new)
             (close-file-descriptor old)))
      (define (with-directory dir thunk)
        (let ((pwd (current-directory)))
          (dynamic-wind
            (lambda () (change-directory dir))
            thunk
            (lambda () (change-directory pwd)))))
      (define (file-modification-time/safe file)
        (guard (exn (else #f))
          (file-modification-time file)))
      ))
   (sagittarius
    (import (scheme base) (sagittarius))
    (begin
      (define (file-status x) x)
      (define file-link-status file-status)
      (define-syntax define-unimplemented
        (syntax-rules ()
          ((define-unimplemented def ...)
           (define (def . x) (error "unimplemented" 'def)) ...)))
      (define-unimplemented
        stat-dev stat-ino stat-mode stat-nlinks stat-uid stat-gid
        stat-rdev stat-blksize stat-blocks)
      (define (stat-size x) (file-size-in-bytes x))
      (define (stat-atime x) (file-stat-atime x))
      (define (stat-mtime x) (file-stat-mtime x))
      (define (stat-ctime x) (file-stat-ctime x))
      (define file-is-readable? file-readable?)
      (define file-is-writable? file-writable?)
      (define file-is-executable? file-executable?)
      (define file-link? file-symbolic-link?)

      (define-unimplemented
        duplicate-file-descriptor duplicate-file-descriptor-to
        close-file-descriptor open-input-file-descriptor
        open-output-file-descriptor)
      ))))
;; Copyright (c) 2010-2012 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

;;> \procedure{(make-address-info family socktype proto [hints])}

(define (make-address-info family socktype proto . o)
  (%make-address-info family socktype proto (if (pair? o) (car o) 0)))

;;> \procedure{(get-address-info host service [addrinfo])}

;;> Create and return a new addrinfo structure for the given host
;;> and service.  \var{host} should be a string and \var{service} a
;;> string or integer.  The optional \var{addrinfo} defaults to
;;> a TCP/IP stream setting.

(define (get-address-info host service . o)
  (%get-address-info host
                     (if (integer? service) (number->string service) service)
                     (if (and (pair? o) (car o))
                         (car o)
                         (make-address-info address-family/unspecified
                                            socket-type/stream
                                            ip-proto/ip
                                            ai/passive))))

;;> Opens a client net connection to \var{host}, a string,
;;> on port \var{service}, which can be a string such as
;;> \scheme{"http"} or an integer.  Returns a list of three
;;> values on success - the socket, an input port, and an
;;> output port - or \scheme{#f} on failure.

(define (open-net-io host service . o)
  (let lp ((addr (get-address-info host service)))
    (if (not addr)
        (error "couldn't find address" host service)
        (let ((sock (socket (address-info-family addr)
                            (address-info-socket-type addr)
                            (address-info-protocol addr))))
          (if (not (fileno? sock))
              (lp (address-info-next addr))
              (cond
               ((negative?
                 (connect sock
                          (address-info-address addr)
                          (address-info-address-length addr)))
                (lp (address-info-next addr)))
               (else
                (cond-expand
                 (threads
                  (if (not (and (pair? o) (car o)))
                      (let ((st (bitwise-ior (get-file-descriptor-status sock)
                                             open/non-block)))
                        (set-file-descriptor-status! sock st))))
                 (else #f))
                (list sock
                      (open-input-file-descriptor sock #t)
                      (open-output-file-descriptor sock #t)))))))))

;;> Convenience wrapper around \scheme{open-net-io}, opens
;;> the connection then calls \var{proc} with two arguments,
;;> the input port and the output port connected to the
;;> service, then closes the connection.  Returns the result
;;> of \var{proc}.  Raises an error if a connection can't
;;> be made.

(define (with-net-io host service proc)
  (let ((io (open-net-io host service)))
    (if (not (pair? io))
        (error "couldn't find address" host service)
        (let ((res (proc (cadr io) (car (cddr io)))))
          (close-input-port (cadr io))
          (close-output-port (car (cddr io)))
          (close-file-descriptor (car io))
          res))))

;;> \procedure{(make-listener-socket addrinfo [max-conn])}

;;> Convenience wrapper to call socket, bind and listen to return
;;> a socket suitable for accepting connections on the given
;;> \var{addrinfo}.  \var{max-conn} is the maximum number of pending
;;> connections, and defaults to 128.  Automatically specifies
;;> \scheme{socket-opt/reuseaddr}.

(define (make-listener-socket addrinfo . o)
  (let* ((max-connections (if (pair? o) (car o) 128))
         (sock (socket (address-info-family addrinfo)
                       (address-info-socket-type addrinfo)
                       (address-info-protocol addrinfo))))
    (cond
     ((not sock)
      (error "couldn't create socket for: " addrinfo))
     ((not (set-socket-option! sock level/socket socket-opt/reuseaddr 1))
      (close-file-descriptor sock)
      (error "couldn't set the socket to be reusable" addrinfo))
     ((not (bind sock
                 (address-info-address addrinfo)
                 (address-info-address-length addrinfo)))
      (close-file-descriptor sock)
      (error "couldn't bind socket" sock addrinfo))
     ((not (listen sock max-connections))
      (close-file-descriptor sock)
      (error "couldn't listen on socket" sock addrinfo))
     (else
      sock))))

;;> Returns the socket option of the given \var{name} for \var{socket}.
;;> \var{socket} should be a file descriptor, level the constant
;;> \scheme{level/socket}, and name one of the constants beginning with
;;> "socket-opt/".

(define (get-socket-option socket level name)
  (let ((res (getsockopt socket level name)))
    (and (pair? res) (car res))))

;;> Sends the bytevector \var{bv} to \var{socket} with sendto and
;;> returns the number of bytes sent, or a negative value on error.
;;> If \var{addrinfo} is unspecified, \var{socket} must previously
;;> have had a default address specified with \scheme{connect}.

(define (send socket bv . o)
  (apply send/non-blocking socket bv #f o))

;;> Equivalent to \scheme{send} but gives up and returns false if the
;;> packet can't be sent within \var{timeout} seconds.

(define (send/non-blocking socket bv timeout . o)
  (let* ((flags (if (pair? o) (car o) 0))
         (addrinfo (and (pair? o) (pair? (cdr o)) (cadr o)))
         (sockaddr (and addrinfo (address-info-address addrinfo)))
         (sockaddr-len (if addrinfo (address-info-address-length addrinfo) 0)))
    (%send socket bv flags sockaddr sockaddr-len timeout)))

;;> Recieves data from \var{socket} to fill the bytevector \var{bv} by
;;> calling recvfrom.  Returns the number of bytes read, or a negative
;;> value on error.  If \var{addrinfo} is unspecified, \var{socket}
;;> must previously have had a default address specified with
;;> \scheme{connect}.

(define (receive! socket bv . o)
  (apply receive!/non-blocking socket bv #f o))

;;> Equivalent to \scheme{receive!} but gives up and returns false if
;;> no packets are received within \var{timeout} seconds.

(define (receive!/non-blocking socket bv timeout . o)
  (let* ((flags (if (pair? o) (car o) 0))
         (addrinfo (and (pair? o) (pair? (cdr o)) (cadr o)))
         (sockaddr (and addrinfo (address-info-address addrinfo)))
         (sockaddr-len (if addrinfo (address-info-address-length addrinfo) 0)))
    (%receive! socket bv flags sockaddr sockaddr-len timeout)))

;;> Shortcut for \scheme{receive}, returning a newly created
;;> bytevector of length \var{n} on success and \scheme{#f} on
;;> failure.

(define (receive socket n . o)
  (let* ((bv (make-bytevector n))
         (m (apply receive! socket bv o)))
    (and (>= m 0)
         (subbytes bv 0 m))))

;;> Equivalent to \scheme{receive} but gives up and returns false if
;;> no packets are received within \var{timeout} seconds.

(define (receive/non-blocking socket n timeout . o)
  (let* ((bv (make-bytevector n))
         (m (apply receive!/non-blocking socket bv timeout o)))
    (and (>= m 0)
         (subbytes bv 0 m))))
(define-library (chibi doc-test)
  (export run-tests)
  (import (scheme base) (chibi doc) (chibi test))
  (begin
    (define (run-tests)
      (test-begin "doc")
      (test '(spec (args config))
          (get-optionals-signature
           '(spec . o)
           '((let ((args (or (and (pair? o) (car o)) (command-line)))
                   (config (and (pair? o) (pair? (cdr o)) (cadr o))))
               (foo)))))
      (test '(filename (port len))
          (get-optionals-signature
           '(filename . o)
           '((let ((port (if (pair? o) (car o) (open-input-file filename)))
                   (len (if (and (pair? o) (pair? (cdr o))) (cadr o) 4096)))
               (foo)))))
      (test '(f kons knil source (index))
          (get-optionals-signature
           '(f kons knil source . o)
           '((let lp ((p (if (string? source)
                             (string->parse-stream source)
                             source))
                      (index (if (pair? o) (car o) 0))
                      (acc knil))
               (f p index fk)))))
      (test "hello" (ansi->sxml "hello"))
      (test '(span "[ " (span (@ (style . "color:red")) "FAIL") "]")
          (ansi->sxml "[ \x1B;[31mFAIL\x1B;[39m]"))
      (test '(span (u "under " (span (@ (style . "color:red")) "red") " line"))
          (ansi->sxml "\x1B;[4munder \x1B;[31mred\x1B;[39m line\x1B;[24m"))
      (test '(span "plain "
                   (u "under "
                      (span (@ (style . "color:red")) "red")
                      " line"))
          (ansi->sxml
           "plain \x1B;[4munder \x1B;[31mred\x1B;[39m line\x1B;[24m"))
      (test '(code "(" "string?" " "
                   (span (@ (class . "string")) "\"hello\"")
                   ")")
          (expand-docs '(scheme "(string? \"hello\")")
                       (make-default-doc-env)))
      (test '(code "(" "string?" " "
                   (span (@ (class . "string")) "\"<hello>\"")
                   ")")
          (expand-docs '(scheme "(string? \"<hello>\")")
                       (make-default-doc-env)))
      (test-end))))

(define-library (chibi zlib)
  (export gzip-file gunzip-file gzip gunzip maybe-gunzip)
  (import (scheme base)
          (chibi temp-file))
  (cond-expand
   (chibi (import (chibi process)))
   (chicken
    (import (rename (chicken) (system %system))
            (only (data-structures) intersperse)
            (only (posix) process))
    (begin
      (define (system . args)
        (%system (apply string-append (intersperse args " "))))
      (define (process->bytevector cmd)
        (call-with-values (lambda ()
                            (if (pair? cmd)
                                (process (car cmd) (cdr cmd))
                                (process cmd)))
          (lambda (in out pid)
            (read-bytevector #f in)))))))
  (include "zlib.scm"))

(define-library (chibi uri)
  (export uri? uri->string make-uri string->uri string->path-uri uri-has-scheme?
          uri-scheme uri-user uri-host uri-port uri-path uri-query uri-fragment
          uri-with-scheme uri-with-user uri-with-host uri-with-path
          uri-with-query uri-with-fragment uri-resolve
          uri-encode uri-decode uri-query->alist uri-alist->query)
  (cond-expand
   (chibi
    (import (chibi) (srfi 9)))
   (else
    (import (except (scheme base) string-map string-for-each)
            (scheme char))
    (begin
      (define (string-concatenate ls)
        (apply string-append ls)))))
  (import (chibi string) (chibi pathname))
  (include "uri.scm"))
;; Copyright (c) 2009-2013 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

;;> Library for parsing and constructing URI objects.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; URI representation

(define-record-type Uri
  (%make-uri scheme user host port path query fragment)
  uri?
  (scheme uri-scheme)
  (user uri-user)
  (host uri-host)
  (port uri-port)
  (path uri-path)
  (query uri-query)
  (fragment uri-fragment))

;;> Accessors for the URI type.
;;/

;;> \procedure{(make-uri scheme [user host port path query fragment])}

(define (make-uri scheme . o)
  (let* ((user (if (pair? o) (car o) #f))
         (o (if (pair? o) (cdr o) '()))
         (host (if (pair? o) (car o) #f))
         (o (if (pair? o) (cdr o) '()))
         (port (if (pair? o) (car o) #f))
         (o (if (pair? o) (cdr o) '()))
         (path (if (pair? o) (car o) #f))
         (o (if (pair? o) (cdr o) '()))
         (query (if (pair? o) (car o) #f))
         (o (if (pair? o) (cdr o) '()))
         (fragment (and (pair? o) (car o))))
    (%make-uri scheme user host port path query fragment)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define (uri-with-scheme u scheme)
  (%make-uri scheme (uri-user u) (uri-host u) (uri-port u)
             (uri-path u) (uri-query u) (uri-fragment u)))

(define (uri-with-user u user)
  (%make-uri (uri-scheme u) user (uri-host u) (uri-port u)
             (uri-path u) (uri-query u) (uri-fragment u)))

(define (uri-with-host u host)
  (%make-uri (uri-scheme u) (uri-user u) host (uri-port u)
             (uri-path u) (uri-query u) (uri-fragment u)))

(define (uri-with-port u port)
  (%make-uri (uri-scheme u) (uri-user u) (uri-host u) port
             (uri-path u) (uri-query u) (uri-fragment u)))

(define (uri-with-path u path)
  (%make-uri (uri-scheme u) (uri-user u) (uri-host u) (uri-port u)
             path (uri-query u) (uri-fragment u)))

(define (uri-with-query u query)
  (%make-uri (uri-scheme u) (uri-user u) (uri-host u) (uri-port u)
             (uri-path u) query (uri-fragment u)))

(define (uri-with-fragment u fragment)
  (%make-uri (uri-scheme u) (uri-user u) (uri-host u) (uri-port u)
             (uri-path u) (uri-query u) fragment))

;;> Functional updaters - returns a new uri identical to \var{u}
;;> with only the specified field changed.
;;/

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; parsing - without :// we just split into scheme & path

(define (char-uri-scheme-unsafe? ch)
  (not (or (char-alphabetic? ch) (char-numeric? ch) (memv ch '(#\+ #\- #\.)))))

;;> Parses a string with a default scheme and returns a new URI
;;> object.  If the string does not begin with a scheme it is take to
;;> be a simple path URI with the default scheme.  This is a
;;> lightweight permissive parser.

(define (string->path-uri scheme str . o)
  (define decode? (and (pair? o) (car o)))
  (define decode (if decode? uri-decode (lambda (x) x)))
  (define decode-query
    (if (and (pair? o) (pair? (cdr o)) (cadr o))
        (if decode? (lambda (q) (uri-query->alist q #t)) uri-query->alist)
        decode))
  (if (uri? str)
      str
      (let* ((start (string-cursor-start str))
             (end (string-cursor-end str))
             (colon0 (string-find str #\:))
             (colon
              (if (string-cursor>=?
                   (string-find str char-uri-scheme-unsafe? start colon0)
                   colon0)
                  colon0
                  end)))
        (if (string-cursor>=? colon end)
            (and scheme
                 (let* ((quest (string-find str #\?))
                        (pound
                         (string-find
                          str
                          #\#
                          (if (string-cursor<? quest end) quest start))))
                   (make-uri scheme #f #f #f
                             (decode
                              (substring-cursor
                               str start (if (string-cursor<? quest end)
                                             quest
                                             pound)))
                             (and (string-cursor<? quest end)
                                  (decode-query
                                   (substring-cursor str (string-cursor-next str quest) pound)))
                             (and (string-cursor<? pound end)
                                  (decode
                                   (substring-cursor str (string-cursor-next str pound) end))))))
            (let ((sc1 (string-cursor-next str colon))
                  (scheme (string->symbol
                           (string-downcase-ascii
                            (substring-cursor str start colon)))))
              (if (string-cursor>=? sc1 end)
                  (make-uri scheme)
                  (if (or (string-cursor>=? (string-cursor-next str sc1) end)
                          (not
                           (and (eqv? #\/ (string-cursor-ref str sc1))
                                (eqv? #\/ (string-cursor-ref str (string-cursor-next str sc1))))))
                      (make-uri scheme #f #f #f (substring-cursor str sc1 end))
                      (if (string-cursor>=? (string-cursor-forward str sc1 2)
                                            end)
                          (make-uri scheme #f "")
                          (let* ((sc2 (string-cursor-forward str sc1 2))
                                 (slash (string-find str #\/ sc2))
                                 (at (string-find-right str #\@ sc2 slash))
                                 (colon3
                                  (string-find
                                   str #\: (if (string-cursor>? at sc2)
                                               at
                                               sc2)
                                   slash))
                                 (quest (string-find str #\? slash))
                                 (pound
                                  (string-find
                                   str #\# (if (string-cursor<? quest end)
                                               quest
                                               slash))))
                            (%make-uri
                             scheme
                             (and (string-cursor>? at sc2)
                                  (decode (substring-cursor str sc2 at)))
                             (decode
                              (substring-cursor
                               str
                               (if (string-cursor>? at sc2) (string-cursor-next str at) sc2)
                               (if (string-cursor<? colon3 slash)
                                   colon3
                                   slash)))
                             (and (string-cursor<? colon3 slash)
                                  (string->number
                                   (substring-cursor str (string-cursor-next str colon3) slash)))
                             (and (string-cursor<? slash end)
                                  (decode
                                   (substring-cursor
                                    str slash (if (string-cursor<? quest end)
                                                  quest
                                                  pound))))
                             (and (string-cursor<? quest end)
                                  (decode-query
                                   (substring-cursor str (string-cursor-next str quest) pound)))
                             (and (string-cursor<? pound end)
                                  (decode
                                   (substring-cursor str (string-cursor-next str pound) end)))
                             ))))))))))

;;> Parses a string and returns a new URI object.  If the string does
;;> not have a scheme, returns false.

(define (string->uri str . o)
  (apply string->path-uri #f str o))

;;> Convert a URI object to a string.  Returns #f if the uri has no scheme.

(define (uri->string uri . o)
  (define encode? (and (pair? o) (car o)))
  (define encode (if encode? uri-encode (lambda (x) x)))
  (if (string? uri)
      uri
      (let ((fragment (uri-fragment uri))
            (query (uri-query uri))
            (path (uri-path uri))
            (port (uri-port uri))
            (host (uri-host uri))
            (user (uri-user uri)))
        (string-append
         (if (and (not host) (memq (uri-scheme uri) '(http https)))
             ""
             (string-append (symbol->string (uri-scheme uri)) ":"))
         (if (or user host port) "//" "")
         (if user (encode user) "") (if user "@" "")
         (or host "")                   ; host shouldn't need encoding
         (if port ":" "") (if port (number->string port) "")
         (if path (encode path) "")
         (if query "?" "")
         (if (pair? query) (uri-alist->query query) (or query ""))
         (if fragment "#" "") (if fragment (encode fragment) "")))))

;;> Returns true iff the given URI string has a scheme.

(define uri-has-scheme?
  (let ((no-scheme (list 'no-scheme)))
    (lambda (url)
      (not (eq? no-scheme (uri-scheme (string->path-uri no-scheme url)))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; query encoding and decoding

(define (uri-safe-char? ch)
  (or (char-alphabetic? ch)
      (char-numeric? ch)
      (case ch
        ((#\- #\_ #\. #\! #\~ #\* #\' #\( #\)) #t)
        (else #f))))

(define (collect str from to res)
  (if (string-cursor>=? from to)
      res
      (cons (substring-cursor str from to) res)))

;;> \procedure{(uri-encode str [plus?])}

;;> Return the URI encoded version of the string \var{str},
;;> using hex escapes as needed and replacing spaces with "+"
;;> iff the optional argument \var{plus?} is true.

(define (uri-encode str . o)
  (define (encode-1-space ch)
    (if (eqv? ch #\space)
        "+"
        (encode-1-normal ch)))
  (define (encode-1-normal ch)
    (let* ((i (char->integer ch))
           (hex (number->string i 16)))
      (if (< i 16)
          (string-append "%0" hex)
          (string-append "%" hex))))
  (let ((start (string-cursor-start str))
        (end (string-cursor-end str))
        (encode-1 (if (and (pair? o) (car o))
                      encode-1-space
                      encode-1-normal)))
    (let lp ((from start) (to start) (res '()))
      (if (string-cursor>=? to end)
          (if (string-cursor<=? from start)
              str
              (string-concatenate (reverse (collect str from to res))))
          (let* ((ch (string-cursor-ref str to))
                 (next (string-cursor-next str to)))
            (if (uri-safe-char? ch)
                (lp from next res)
                (lp next next (cons (encode-1 ch)
                                    (collect str from to res)))))))))

;;> \procedure{(uri-decode str [plus?])}

;;> Decodes any URI hex escapes in the given string, and
;;> translates any pluses ("+") to space iff the optional
;;> argument \var{plus?} is true.

(define (uri-decode str . o)
  (let ((space-as-plus? (and (pair? o) (car o)))
        (start (string-cursor-start str))
        (end (string-cursor-end str)))
    (let lp ((from start) (to start) (res '()))
      (if (string-cursor>=? to end)
          (if (string-cursor<=? from start)
              str
              (string-concatenate (reverse (collect str from to res))))
          (let* ((ch (string-cursor-ref str to))
                 (next (string-cursor-next str to)))
            (cond
             ((eqv? ch #\%)
              (if (string-cursor>=? next end)
                  (lp next next (collect str from to res))
                  (let ((next2 (string-cursor-next str next)))
                    (if (string-cursor>=? next2 end)
                        (lp next2 next2 (collect str from to res))
                        (let* ((next3 (string-cursor-next str next2))
                               (hex (substring-cursor str next next3))
                               (i (string->number hex 16)))
                          (lp next3 next3 (cons (string (integer->char i))
                                                (collect str from to res))))))))
             ((and space-as-plus? (eqv? ch #\+))
              (lp next next (cons " " (collect str from to res))))
             (else
              (lp from next res))))))))

;;> \procedure{(uri-query->alist str [plus?])}

;;> Parses the query part of a URI as a delimited list of
;;> URI encoded \rawcode{VAR=VALUE} pairs, decodes them and
;;> returns the result as an alist.

(define (uri-query->alist str . o)
  (define (split-char? c) (if (eqv? c #\&) #t (eqv? c #\;)))
  (let ((end (string-cursor-end str))
        (plus? (and (pair? o) (car o))))
    (let lp ((i (string-cursor-start str)) (res '()))
      (if (string-cursor>=? i end)
          (reverse res)
          (let* ((j (string-find str split-char? i))
                 (k (string-find str #\= i j))
                 (cell
                  (if (string-cursor<? k end)
                      (cons (uri-decode (substring-cursor str i k) plus?)
                            (uri-decode (substring-cursor str (string-cursor-next str k) j) plus?))
                      (cons (uri-decode (substring-cursor str i j) plus?) #f))))
            (lp (string-cursor-next str j) (cons cell res)))))))

;;> \procedure{(uri-alist->query ls [plus?])}

;;> The reverse of the above, formats the alist as a URI
;;> query string.

(define (uri-alist->query ls . o)
  (define plus? (and (pair? o) (car o)))
  (define (encode key val res)
    (let ((res (cons (uri-encode key plus?) res)))
      (if val (cons (uri-encode val plus?) (cons "=" res)) res)))
  (if (null? ls)
      ""
      (let lp ((x (car ls)) (ls (cdr ls)) (res '()))
        (let ((res (encode (car x) (cdr x) res)))
          (if (null? ls)
              (string-concatenate (reverse res))
              (lp (car ls) (cdr ls) (cons "&" res)))))))

;;> Returns a new URI from \var{path}, a string or URI object, as
;;> would be interpreted from as a reference from \var{uri}.  Thus if
;;> any components of \var{path} are missing, or if \var{path} is a
;;> raw path, it is taken relative to \var{uri}.

(define (uri-resolve path orig-uri)
  (or (string->uri path)
      (let ((uri (string->uri orig-uri)))
        (if uri
            (uri-with-path
             (uri-with-fragment (uri-with-query uri #f) #f)
             (path-resolve path
                           (if (string-suffix? "/" (uri-path uri))
                               (uri-path uri)
                               (path-directory (uri-path uri)))))
            (path-resolve path orig-uri)))))

(define-library (chibi stty)
  (export stty with-stty with-raw-io
          get-terminal-width get-terminal-dimensions
          TCSANOW TCSADRAIN TCSAFLUSH
          winsize winsize? make-winsize winsize-row winsize-col
          termios term-attrs? make-term-attrs
          ;;term-attrs-iflag term-attrs-iflag-set!
          ;;term-attrs-oflag term-attrs-oflag-set!
          ;;term-attrs-cflag term-attrs-cflag-set!
          ;;term-attrs-lflag term-attrs-lflag-set!
          )
  (import (chibi) (srfi 69) (srfi 151))
  (include-shared "stty")
  (include "stty.scm"))

;;> Library for weak data structures.

;;> \procedure{(make-ephemeron key value)}

;;> Returns a new ephemeron.  This ephemeron holds a weak reference to
;;> \var{key}, such that \var{value} will only be traced by the GC if
;;> \var{key} is referenced from an external object.

;;> \procedure{(ephemeron? x)}
;;> Returns true iff \var{x} is an ephemeron.

;;> \procedure{(ephemeron-broken? ephemeron)}
;;> Returns true iff \var{ephemeron}s \var{key} has been GCed.

;;> \procedure{(ephemeron-key ephemeron)}
;;> Returns \var{ephemeron}s \var{key}, or \scheme{#f} if it has been GCed.

;;> \procedure{(ephemeron-value ephemeron)}
;;> Returns \var{ephemeron}s \var{value}.

(define-library (chibi weak)
  (export make-ephemeron ephemeron? ephemeron-broken?
          ephemeron-key ephemeron-value
          ;; make-weak-vector weak-vector? weak-vector-length
          ;; weak-vector-ref weak-vector-set!
          )
  (include-shared "weak"))

(define-library (chibi process)
  (export exit sleep alarm %fork fork kill execute waitpid system system?
          process-command-line  process-running?
          set-signal-action! make-signal-set
          signal-set? signal-set-contains?
          signal-set-fill! signal-set-add! signal-set-delete!
          current-signal-mask current-process-id parent-process-id
          signal-mask-block! signal-mask-unblock! signal-mask-set!
          signal/hang-up    signal/interrupt   signal/quit
          signal/illegal    signal/abort       signal/fpe
          signal/kill       signal/segv        signal/pipe
          signal/alarm      signal/term        signal/user1
          signal/user2      signal/child       signal/continue
          signal/stop       signal/tty-stop    signal/tty-input
          signal/tty-output wait/no-hang
          call-with-process-io process->bytevector
          process->string process->sexp process->string-list
          process->output+error process->output+error+status)
  (import (chibi) (chibi io) (chibi string) (chibi filesystem))
  (cond-expand (threads (import (srfi 18) (srfi 151))) (else #f))
  (cond-expand ((not windows) (include-shared "process")))
  (include "process.scm"))

(define-library (chibi tar)
  (import (scheme base) (scheme file) (scheme time) (srfi 1) (scheme write)
          (chibi string) (chibi binary-record) (chibi pathname)
          (chibi filesystem))
  (cond-expand
   ((library (srfi 151)) (import (srfi 151)))
   ((library (srfi 33)) (import (srfi 33)))
   (else (import (srfi 60))))
  (cond-expand
   (chibi
    (import (chibi system)))
   (chicken
    (import posix)
    (begin
      (define (user-name x) (if (pair? x) (car x) "nobody"))
      (define (group-name x) (if (pair? x) (car x) "nobody")))))
  (export
   ;; basic
   tar make-tar tar? read-tar write-tar
   ;; utilities
   tar-safe? tar-files tar-fold tar-extract tar-extract-file tar-create
   ;; accessors
   tar-path tar-path-prefix tar-mode tar-uid tar-gid
   tar-owner tar-group tar-size
   tar-time tar-type tar-link-name
   tar-path-set! tar-mode-set! tar-uid-set! tar-gid-set!
   tar-owner-set! tar-group-set! tar-size-set!
   tar-time-set! tar-type-set! tar-link-name-set!
   tar-device-major tar-device-major-set!
   tar-device-minor tar-device-minor-set!
   tar-ustar tar-ustar-set!)
  (include "tar.scm"))
;; app.scm -- unified option parsing and config
;; Copyright (c) 2012-2015 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

;;> The high-level interface.  Given an application spec \var{spec},
;;> parses the given command-line arguments \var{args} into a config
;;> object, prepended to the existing object \var{config} if given.
;;> Then runs the corresponding command (or sub-command) procedure
;;> from \var{spec}.
;;>
;;> The app spec should be a list of the form:
;;>
;;> \scheme{(<command> [<doc-string>] <clauses> ...)}
;;>
;;> where clauses can be any of:
;;>
;;> \itemlist[
;;> \item{\scheme{(@ <opt-spec>)} - option spec, described below}
;;> \item{\scheme{(begin: <begin-proc>)} - procedure to run before main}
;;> \item{\scheme{(end: <end-proc>)} - procedure to run after main}
;;> \item{\scheme{(types: (<type-name> <parser>) ...)} - additional types that can be used in argument parsing}
;;> \item{\scheme{(<proc> args ...)} - main procedure (args only for documentation)}
;;> \item{\scheme{<app-spec>} - a subcommand described by the nested spec}
;;> \item{\scheme{(or <app-spec> ...)} - an alternate list of subcommands}
;;> ]
;;>
;;> For subcommands the symbolic command name must match, though it is
;;> ignored for the initial spec (i.e. the application name is not
;;> checked).  The \scheme{begin} and \scheme{end} procedures can be
;;> useful for loading and saving state common to all subcommands.
;;>
;;> The \scheme{opt-spec} describes command-line options, and is a
;;> simple list with each opt of the form:
;;>
;;> \scheme{(<name> <type> [(<aliases> ...)] [<doc-string>])}
;;>
;;> where \scheme{<name>} is a symbol name, \scheme{<aliases>} is an
;;> optional list of strings (for long options) or characters (for
;;> short options) to serve as aliases in addition to the exact name.
;;> \scheme{type} can be any of:
;;>
;;> \itemlist[
;;> \item{\scheme{boolean} - boolean, associated value optional, allowing \scheme{--noname} to indicate \scheme{#false}}
;;> \item{\scheme{char} - a single character}
;;> \item{\scheme{integer} - an exact integer}
;;> \item{\scheme{real} - any real number}
;;> \item{\scheme{number} - any real or complex number}
;;> \item{\scheme{symbol} - a symbol}
;;> \item{\scheme{string} - a string}
;;> \item{\scheme{sexp} - a sexp parsed with \scheme{read}}
;;> \item{\scheme{(list <type>)} - a comma-delimited list of types}
;;> ]
;;>
;;> Note that the options specs are composed entirely of objects that
;;> can be read and written, thus for example optionally loaded from
;;> files, whereas the app specs include embedded procedure objects so
;;> are typically written with \scheme{quasiquote}.
;;>
;;> Complete Example:
;;>
;;> \schemeblock{
;;> (run-application
;;>   `(zoo
;;>     "Zookeeper Application"
;;>     (@
;;>      (animals (list symbol) "list of animals to act on (default all)")
;;>      (lions boolean (#\l) "also apply the action to lions"))
;;>     (or
;;>      (feed "feed the animals" () (,feed animals ...))
;;>      (wash "wash the animals" (@ (soap boolean)) (,wash animals ...))
;;>      (help "print help" (,app-help-command))))
;;>   (command-line)
;;>   (conf-load (string-append (get-environment-variable "HOME") "/.zoo")))
;;> }
;;>
;;> The second and third arguments here are optional, provided to show
;;> the common pattern of allowing the same options to be specified
;;> either in a file and/or on the command-line.  The above app can be
;;> run as:
;;>
;;> Feed all animals, including lions:
;;> \command{zoo -l feed}
;;>
;;> Wash the elephants with soap:
;;> \command{zoo --animals=elephant wash --soap}
;;>
;;> Print help:
;;> \command{zoo help}
;;>
;;> The application procedures themselves are of the form:
;;>
;;> \scheme{(proc cfg spec args ...)}
;;>
;;> where \var{cfg} is a config object from \scheme{(chibi config)}
;;> holding the parsed option info, \var{spec} is the original app
;;> spec, and \var{args} are the remaining non-option command-line
;;> arguments.
;;>
;;> To retrieve the options for the above example you can use:
;;>
;;> \itemlist[
;;> \item{\scheme{(conf-get cfg 'animals)}}
;;> \item{\scheme{(conf-get cfg 'lions)}}
;;> \item{\scheme{(conf-get cfg '(command wash soap))}}
;;> ]
;;>
;;> Notice that options for subcommands are nested under the
;;> \scheme{(command <name>)} prefix, so that you can use the same
;;> name for different subcommands without conflict.  This also means
;;> the subcommand options are distinct from the top-level options, so
;;> when using subcommands users must always write the command line
;;> as:
;;>
;;> \command{app [<general options>] <subcommand> [<sub options>]}
;;>
;;> The ~/.zoo file could then hold an sexp of the form:
;;>
;;> \schemeblock{
;;> ((animals (camel elephant rhinocerous))
;;>  (command
;;>   (wash
;;>    (soap #t))))
;;> }

(define (run-application spec . o)
  (let ((args (or (and (pair? o) (car o)) (command-line)))
        (config (and (pair? o) (pair? (cdr o)) (cadr o))))
    (cond
     ((parse-app '() (cdr spec) '() (cdr args) config #f #f '())
      => (lambda (v)
           (let ((proc (vector-ref v 0))
                 (cfg (vector-ref v 1))
                 (args (vector-ref v 2))
                 (init (vector-ref v 3))
                 (end (vector-ref v 4)))
             (if init (init cfg))
             (let ((res (apply proc cfg spec args)))
               (if end (end cfg))
               res))))
     ((null? (cdr args))
      (app-help spec args)
      (error "Expected a command"))
     (else
      (error "Unknown command" args)))))

;;> Parse a single command-line argument from \var{args} according to
;;> \var{conf-spec}, and returns a list of two values: the
;;> \scheme{(name value)} for the option, and a list of remaining
;;> unparsed args.  \scheme{name} will have the current \var{prefix}
;;> prepended.  If a parse error or unknown option is found, calls
;;> \var{fail} with a single string argument describing the error,
;;> returning that result.

(define (parse-option prefix conf-spec args types fail)
  (define (parse-value type str)
    (cond
     ((not (string? str))
      (list str #f))
     ((and (pair? type) (eq? 'list (car type)))
      (let ((res (map (lambda (x) (parse-value (cadr type) x))
                      (string-split str #\,))))
        (list (map car res) (any string? (map cdr res)))))
     (else
      (case type
        ((boolean)
         (list (not (member str '("#f" "#false" "#F" "#FALSE" "false" "FALSE")))
               #f))
        ((number integer real)
         (let ((n (string->number str)))
           (cond
            ((and (eq? type 'integer) (not (integer? n)))
             (list n "expected an integer"))
            ((and (eq? type 'real) (not (real? n)))
             (list n "expected a real number"))
            (else
             (list n #f)))))
        ((symbol)
         (list (string->symbol str) #f))
        ((char)
         (if (not (= 1 (string-length str)))
             (list #f "expected a single character")
             (list (string-ref str 0) #f)))
        ((sexp)
         (list (guard (exn (else str))
                 (let* ((in (open-input-string str))
                        (res (read in)))
                   (close-input-port in)
                   res))
               #f))
        (else
         (cond
          ((assq type types)
           => (lambda (cell) (list ((cadr cell) str) #f)))
          (else (list str #f))))))))
  (define (lookup-conf-spec conf-spec syms strs)
    (let ((sym (car syms))
          (str (car strs)))
      (cond
       ((= 1 (length syms))
        (let lp ((ls conf-spec))
          (and (pair? ls)
               (let ((x (car ls)))
                 (cond
                  ((eq? sym (car x)) x)
                  ((and (pair? (cddr x)) (pair? (third x))
                        (member str (third x)))
                   x)
                  ((and (pair? (cddr x)) (pair? (third x))
                        (member `(not ,str) (third x)))
                   `(not ,x))
                  (else (lp (cdr ls))))))))
       (else
        (let lp ((ls conf-spec))
          (and (pair? ls)
               (let ((x (car ls)))
                 (cond
                  ((or (eq? sym (car x))
                       (and (pair? (cddr x)) (pair? (third x))
                            (member str (third x))))
                   (let ((type (cadr x)))
                     (if (not (and (pair? type) (eq? 'conf (car type))))
                         (error "option prefix not a subconf" sym)
                         (lookup-conf-spec (cdr type) (cdr syms) (cdr strs)))))
                  (else (lp (cdr ls)))))))))))
  (define (lookup-short-option ch spec)
    (let lp ((ls spec))
      (and (pair? ls)
           (let ((x (car ls)))
             (cond
              ((and (pair? (cddr x)) (pair? (third x)) (memv ch (third x)))
               x)
              ((and (pair? (cddr x)) (pair? (third x))
                    (member `(not ,ch) (third x)))
               `(not ,x))
              (else (lp (cdr ls))))))))
  (define (parse-long-option str args fail)
    (let* ((fail-args (cons (string-append "--" str) args))
           (str+val (string-split str #\= 2))
           (str (car str+val))
           (args (if (pair? (cdr str+val)) (cons (cadr str+val) args) args))
           (strs (string-split str #\.))
           (syms (map string->symbol strs))
           (spec (lookup-conf-spec conf-spec syms strs)))
      (cond
       ((not spec)
        ;; check for 'no' prefix on boolean
        (if (not (string-prefix? "no" str))
            (fail prefix conf-spec (car fail-args) fail-args "unknown option")
            (let ((res (parse-long-option (substring str 2) args (lambda args #f))))
              (cond
               ((not res)
                (fail prefix conf-spec (car fail-args) fail-args
                      "unknown option"))
               ((not (boolean? (cdar res)))
                (error "'no' prefix only valid on boolean options"))
               (else
                `((,(caar res) . #f) ,@(cdr res)))))))
       ((and (pair? spec) (eq? 'not (car spec)))
        (cons (cons (append prefix (list (car spec))) #f) args))
       ((and (eq? 'boolean (cadr spec)) (null? (cdr str+val)))
        (cons (cons (append prefix (list (car spec))) #t) args))
       ((null? args)
        (fail prefix conf-spec (car fail-args) fail-args
              "missing argument to option"))
       (else
        (let ((val+err (parse-value (cadr spec) (car args))))
          (if (cadr val+err)
              (fail prefix conf-spec (car fail-args) fail-args (cadr val+err))
              (cons (cons (append prefix (drop-right syms 1) (list (car spec)))
                          (car val+err))
                    (cdr args))))))))
  (define (parse-short-option str args fail)
    (let* ((ch (string-ref str 0))
           (x (lookup-short-option ch conf-spec))
           (fail-args (cons (string-append "-" str) args)))
      (cond
       ((not x)
        (fail prefix conf-spec (car fail-args) fail-args "unknown option"))
       ((and (pair? x) (eq? 'not (car x)))
        (cons (cons (append prefix (list (car (cadr x)))) #f)
              (if (= 1 (string-length str))
                  args
                  (cons (string-append "-" (substring str 1)) args))))
       ((eq? 'boolean (cadr x))
        (cons (cons (append prefix (list (car x))) #t)
              (if (= 1 (string-length str))
                  args
                  (cons (string-append "-" (substring str 1)) args))))
       ((> (string-length str) 1)
        (let ((val+err (parse-value (cadr x) (substring str 1))))
          (if (cadr val+err)
              (fail prefix conf-spec (car args) args (cadr val+err))
              (cons (cons (append prefix (list (car x))) (car val+err))
                    args))))
       ((null? args)
        (fail prefix conf-spec (car fail-args) fail-args
              "missing argument to option"))
       (else
        (cons (cons (append prefix (list (car x))) (car args)) (cdr args))))))
  (if (eqv? #\- (string-ref (car args) 1))
      (parse-long-option (substring (car args) 2) (cdr args) fail)
      (parse-short-option (substring (car args) 1) (cdr args) fail)))

;;> Parse a list of command-line arguments into a config object.
;;> Returns a list whose head is the resulting config object, and tail
;;> is the list of remaining non-option arguments.  Calls fail on
;;> error and tries to continue processing from the result.

(define (parse-options prefix conf-spec orig-args types fail)
  (let lp ((args orig-args)
           (opts (make-conf '() #f (cons 'options orig-args) #f)))
    (cond
     ((null? args)
      (cons opts args))
     ((or (member (car args) '("" "-" "--"))
          (not (eqv? #\- (string-ref (car args) 0))))
      (cons opts (if (equal? (car args) "--") (cdr args) args)))
     (else
      (let ((val+args (parse-option prefix conf-spec args types fail)))
        (lp (cdr val+args)
            (conf-set opts (caar val+args) (cdar val+args))))))))

;;> Parses a list of command-line arguments \var{args} according to
;;> the application spec \var{opt-spec}.  Returns a vector of five
;;> elements:
;;>
;;> \itemlist[
;;> \item{\scheme{proc} - procedure to run the application}
;;> \item{\scheme{config} - a config object containing all parsed options}
;;> \item{\scheme{args} - a list of remaining unparsed command-line arguments}
;;> \item{\scheme{init} - an optional procedure to call before \scheme{proc}}
;;> \item{\scheme{end} - an optional procedure to call after \scheme{proc}}
;;> ]
;;>
;;> The config object is prepended to \var{config}, with option names
;;> all prefixed by \var{prefix}.  The original \var{spec} is used for
;;> \scheme{app-help}.

(define (parse-app prefix spec opt-spec args config init end types . o)
  (define (next-prefix prefix name)
    (append (if (null? prefix) '(command) prefix) (list name)))
  (define (prev-prefix prefix)
    (cond ((and (= 2 (length prefix))) '())
          ((null? prefix) '())
          (else (reverse (cdr (reverse  prefix))))))
  (define (all-opt-names opt-spec)
    ;; TODO: nested options
    (let lp ((ls opt-spec) (res '()))
      (if (null? ls)
          (map (lambda (x) (if (symbol? x) (symbol->string x) x))
               (remove char? (reverse res)))
          (let ((o (car ls)))
            (lp (cdr ls)
                (append (if (and (pair? (cddr o)) (pair? (third o)))
                            (third o)
                            '())
                        (cons (car o) res)))))))
  (let ((fail (if (pair? o)
                  (car o)
                  (lambda (prefix spec opt args reason)
                    (cond
                     ((and (string=? reason "unknown option")
                           (find-nearest-edits opt (all-opt-names spec)))
                      => (lambda (similar)
                           (if (pair? similar)
                               (error reason opt "Did you mean: " similar)
                               (error reason opt))))
                     (else
                      (error reason opt)))))))
    (cond
     ((null? spec)
      (error "no procedure in application spec"))
     ((or (null? (car spec)) (equal? '(@) (car spec)))
      (parse-app prefix (cdr spec) opt-spec args config init end types fail))
     ((pair? (car spec))
      (case (caar spec)
        ((@)
         (let* ((tail (cdar spec))
                (new-opt-spec
                 (cond
                  ((not (pair? tail))
                   '())
                  ((or (pair? (cdr tail))
                       (and (pair? (car tail)) (symbol? (caar tail))))
                   tail)
                  (else
                   (car tail))))
                (new-fail
                 (lambda (new-prefix new-spec new-opt new-args reason)
                   (parse-option (prev-prefix prefix) opt-spec new-args types fail)))
                (cfg+args (parse-options prefix new-opt-spec args types new-fail))
                (config (conf-append (car cfg+args) config))
                (args (cdr cfg+args)))
           (parse-app prefix (cdr spec) new-opt-spec args config
                      init end types new-fail)))
        ((or)
         (any (lambda (x) (parse-app prefix x opt-spec args config init end types))
              (cdar spec)))
        ((begin:)
         (parse-app prefix (cdr spec) opt-spec args config
                    (cadr (car spec)) end types fail))
        ((end:)
         (parse-app prefix (cdr spec) opt-spec args config
                    init (cadr (car spec)) types fail))
        ((types:)
         (parse-app prefix (cdr spec) opt-spec args config
                    init end (cdr (car spec)) fail))
        (else
         (if (procedure? (caar spec))
             (vector (caar spec) config args init end) ; TODO: verify
             (parse-app prefix (car spec) opt-spec args config
                        init end types fail)))))
     ((symbol? (car spec))
      (and (pair? args)
           (eq? (car spec) (string->symbol (car args)))
           (let ((prefix (next-prefix prefix (car spec))))
             (parse-app prefix (cdr spec) opt-spec (cdr args) config
                        init end types fail))))
     ((procedure? (car spec))
      (vector (car spec) config args init end))
     (else
      (if (not (string? (car spec)))
          (error "unknown application spec" (car spec)))
      (parse-app prefix (cdr spec) opt-spec args config init end types fail)))))

(define (print-command-help command out)
  (cond
   ((and (pair? command) (symbol? (car command)))
    (display "  " out)
    (display (car command) out)
    (cond
     ((find (lambda (x) (and (pair? x) (procedure? (car x)))) command)
      => (lambda (x)
           (let lp ((args (cdr x)) (opt-depth 0))
             (cond
              ((null? args)
               (display (make-string opt-depth #\]) out))
              ((pair? (car args))
               (display " [" out)
               (display (caar args) out)
               (lp (cdr args) (+ opt-depth 1)))
              (else
               (display " " out)
               (display (car args) out)
               (lp (cdr args) opt-depth)))))))
    (cond
     ((find string? command)
      => (lambda (doc-string) (display " - " out) (display doc-string out))))
    (newline out))))

(define (print-option-help option out)
  (let* ((str (symbol->string (car option)))
         (names (if (and (pair? (cdr option)) (pair? (cddr option)))
                    (car (cddr option))
                    '()))
         (pref-str (cond ((find string? names) => values) (else str)))
         (pref-ch (find char? names))
         (doc (find string? (cdr option))))
    ;; TODO: consider aligning these
    (cond
     (pref-ch (display "  -" out) (write-char pref-ch out))
     (else (display "    " out)))
    (cond
     (pref-str
      (display (if pref-ch ", " "  ") out)
      (display "--" out) (display pref-str out)))
    (cond (doc (display " - " out) (display doc out)))
    (newline out)))

(define (print-help name docs commands options . o)
  (let ((out (if (pair? o) (car o) (current-output-port))))
    (display "Usage: " out) (display name out)
    (if (pair? options) (display " [options]" out))
    (case (length commands)
      ((0) (newline out))
      (else
       (display " <command>\nCommands:\n" out)
       (for-each (lambda (c) (print-command-help c out)) commands))
      ((1) (print-command-help (car commands) out)))
    (if (pair? options) (display "Options:\n" out))
    (for-each (lambda (o) (print-option-help o out)) options)))

;;> Print a help summary for the given application spec \var{spec}.

(define (app-help spec args . o)
  (let ((out (if (pair? o) (car o) (current-output-port))))
    (let lp ((ls (cdr spec))
             (docs #f)
             (commands '())
             (options '()))
      (cond
       ((null? ls)
        (print-help (car spec) docs commands options out))
       ((or (string? (car ls))
            (and (pair? (car ls)) (memq (caar ls) '(begin: end:) )))
        (lp (cdr ls) (car ls) commands options))
       ((and (pair? (car ls)) (eq? '@ (caar ls)))
        (lp (cdr ls) docs commands (append options (cadr (car ls)))))
       ((and (pair? (car ls)) (symbol? (caar ls)))
        ;; don't print nested commands
        (if (pair? commands)
            (print-help (car spec) docs commands options out)
            (if (eq? 'or (caar ls))
                (lp (cdr ls) docs (cdar ls) options)
                (lp (cdr ls) docs (list (car ls)) options))))
       (else
        (lp (cdr ls) docs commands options))))))

;;> The subcommand form of \scheme{app-help}.  You can use this as a
;;> subcommand in an application spec, for example as:
;;> \schemeblock{(help "print help" (,app-help-command args ...))}

(define (app-help-command config spec . args)
  (app-help spec args (current-output-port)))

;; Table mapping traced procedures to their original untraced values.
(define all-traces
  (make-parameter (make-hash-table eq?)))

;; The current number of traced procedure frames on the stack.
(define active-trace-depth
  (make-parameter 0))

(define (show-trace cell args)
  (let ((out (current-error-port)))
    (do ((i 0 (+ i 1)))
        ((>= i (active-trace-depth)))
      (display "| " out))
    (display "> " out)
    (write/ss (cons (car cell) args) out)
    (newline out)))

(define (show-trace-result cell args res)
  (let ((out (current-error-port)))
    (do ((i 0 (+ i 1)))
        ((>= i (active-trace-depth)))
      (display "| " out))
    (write/ss res out)
    (newline out)))

(define (make-tracer cell)
  (let ((proc (cdr cell)))
    (if (macro? proc)
        (make-macro
         (lambda (expr use-env mac-env)
           (show-trace cell (strip-syntactic-closures (cdr expr)))
           (active-trace-depth (+ (active-trace-depth) 1))
           (let ((res ((macro-procedure proc) expr use-env mac-env)))
             (active-trace-depth (- (active-trace-depth) 1))
             (show-trace-result cell
                                (strip-syntactic-closures (cdr expr))
                                (strip-syntactic-closures res))
             res))
         (macro-env proc))
        (lambda args
          (show-trace cell args)
          (active-trace-depth (+ (active-trace-depth) 1))
          (let ((res (apply proc args)))
            (active-trace-depth (- (active-trace-depth) 1))
            (show-trace-result cell args res)
            res)))))

;;> Write a trace of all calls to the procedure \var{id} to
;;> \scheme{(current-error-port)}.

(define-syntax trace
  (syntax-rules ()
    ((trace id)
     (trace-cell (env-cell (interaction-environment) 'id)))))

;;> Remove any active traces on the procedure \var{id}.

(define-syntax untrace
  (syntax-rules ()
    ((untrace id)
     (untrace-cell (env-cell (interaction-environment) 'id)))))

(define (warn . args)
  (let ((out (current-error-port)))
    (display "WARNING: " out)
    (for-each (lambda (x) (display x out)) args)
    (newline out)))

;;> Trace a specific environment cell.

(define (trace-cell cell)
  (let ((tab (all-traces)))
    (cond
     ((not (pair? cell))
      (warn "No such binding."))
     ((hash-table-exists? tab cell)
      (warn "Procedure already being traced: " (car cell)))
     (else
      (hash-table-set! tab cell (cdr cell))
      (set-cdr! cell (make-tracer cell))))))

;;> Untrace an environment cell.

(define (untrace-cell cell)
  (let ((tab (all-traces)))
    (cond
     ((not (pair? cell))
      (warn "No such binding."))
     ((not (hash-table-exists? tab cell))
      (warn "Procedure not being traced: " (car cell)))
     (else
      (let ((proc (hash-table-ref tab cell)))
        (hash-table-delete! tab cell)
        (set-cdr! cell proc))))))

;;> Remove all active procedure traces.

(define (untrace-all)
  (hash-table-walk (all-traces) (lambda (cell proc) (set-cdr! cell proc)))
  (all-traces (make-hash-table eq?)))

(define current-time get-time-of-day)
(define (time? x) (timeval? (if (pair? x) (car x) x)))

(define (time->seconds x)
  (timeval-seconds (if (pair? x) (car x) x)))

(define (seconds->time x)
  (make-timeval (if (inexact? x) (inexact->exact (round x)) x) 0))

(define (timeout->seconds x)
  (if (time? x) (- (time->seconds x) (time->seconds (current-time))) x))

(define thread-yield! yield!)

(define (thread-result thread)
  (cond
   ((%thread-exception? thread)
    (raise (%thread-end-result thread)))
   (else
    (%thread-end-result thread))))

(define (thread-join! thread . o)
  (let ((timeout (and (pair? o) (car o))))
    (let lp ()
      (cond
       ((%thread-join! thread (timeout->seconds timeout))
        (thread-result thread))
       (else
        (thread-yield!)
        (cond
         ((and timeout (thread-timeout?))
          (if (and (pair? o) (pair? (cdr o)))
              (cadr o)
              (error "timed out waiting for thread" thread)))
         (else
          (lp))))))))

(define (thread-terminate! thread)
  (if (%thread-terminate! thread) ;; need to yield if terminating ourself
      (thread-yield!)))

(define (thread-sleep! timeout)
  (%thread-sleep! (timeout->seconds timeout))
  (thread-yield!))

(define (mutex-lock! mutex . o)
  (let ((timeout (and (pair? o) (car o)))
        (thread (if (and (pair? o) (pair? (cdr o))) (cadr o) #t)))
    (cond
     ((%mutex-lock! mutex (timeout->seconds timeout) thread))
     (else
      (thread-yield!)
      ;; If we timed out, fail.
      (if (thread-timeout?)
          #f
          ;; Otherwise the lock was released, try again.
          (mutex-lock! mutex timeout thread))))))

(define (mutex-unlock! mutex . o)
  (let ((condvar (and (pair? o) (car o)))
        (timeout (if (and (pair? o) (pair? (cdr o))) (cadr o) #f)))
    (cond
     ((%mutex-unlock! mutex condvar (timeout->seconds timeout)))
     (else
      (thread-yield!)
      (not (thread-timeout?))))))

(define (join-timeout-exception? x)
  (and (exception? x)
       (equal? (exception-message x) "timed out waiting for thread")))

;; XXXX flush out exception types
(define (abandoned-mutex-exception? x) #f)
(define (terminated-thread-exception? x) #f)
(define (uncaught-exception? x) #f)
(define (uncaught-exception-reason x) #f)

;; signal runner

(define (signal-runner)
  (let lp ()
    (let ((n (pop-signal!)))
      (cond
       ((integer? n)
        (let ((handler (get-signal-handler n)))
          (if (procedure? handler)
              (handler n))))
       (else
        (thread-sleep! #t))))
    (lp)))
;; types.scm -- thread types
;; Copyright (c) 2010-2011 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

(define-record-type Mutex
  (%make-mutex name specific thread lock)
  mutex?
  (name mutex-name)
  (specific mutex-specific mutex-specific-set!)
  (thread %mutex-thread %mutex-thread-set!)
  (lock %mutex-lock %mutex-lock-set!))

(define (make-mutex . o)
  (%make-mutex (and (pair? o) (car o)) #f #f #f))

(define-record-type Condition-Variable
  (%make-condition-variable name specific threads)
  condition-variable?
  (name condition-variable-name)
  (specific condition-variable-specific condition-variable-specific-set!)
  (threads %condition-variable-threads %condition-variable-threads-set!))

(define (make-condition-variable . o)
  (%make-condition-variable (and (pair? o) (car o)) #f #f))
(define-library (srfi 18 test)
  (export run-tests)
  (import (chibi) (srfi 18) (srfi 39) (chibi test))
  (begin
    (define (run-tests)
      (test-begin "srfi-18: threads")

      (test "no threads" 'ok (begin 'ok))

      (test "unstarted thread" 'ok
        (let ((t (make-thread (lambda () (error "oops"))))) 'ok))

      (test "ignored thread terminates" 'ok
        (let ((t (make-thread (lambda () 'oops)))) (thread-start! t) 'ok))

      (test "ignored thread hangs" 'ok
        (let ((t (make-thread (lambda () (let lp () (lp))))))
          (thread-start! t)
          'ok))

      (test "joined thread terminates" 'ok
        (let ((t (make-thread (lambda () 'oops))))
          (thread-start! t)
          (thread-join! t)
          'ok))

      (test "joined thread hangs, timeout" 'timeout
        (let ((t (make-thread (lambda () (let lp () (lp))))))
          (thread-start! t)
          (thread-join! t 0.1 'timeout)))

      (test "basic mutex" 'ok
        (let ((m (make-mutex)))
          (and (mutex? m) 'ok)))

      (test "mutex unlock" 'ok
        (let ((m (make-mutex)))
          (and (mutex-unlock! m) 'ok)))

      (test "mutex lock/unlock" 'ok
        (let ((m (make-mutex)))
          (and (mutex-lock! m)
               (mutex-unlock! m)
               'ok)))

      (test "mutex lock/lock" 'timeout
        (let ((m (make-mutex)))
          (and (mutex-lock! m)
               (if (mutex-lock! m 0.1) 'fail 'timeout))))

      (test "mutex lock timeout" 'timeout
        (let* ((m (make-mutex))
               (t (make-thread (lambda () (mutex-lock! m)))))
          (thread-start! t)
          (thread-yield!)
          (if (mutex-lock! m 0.1) 'fail 'timeout)))

      (test "mutex lock/unlock/lock/lock" 'timeout
        (let* ((m (make-mutex))
               (t (make-thread (lambda () (mutex-unlock! m)))))
          (mutex-lock! m)
          (thread-start! t)
          (if (mutex-lock! m 0.1)
              (if (mutex-lock! m 0.1) 'fail-second 'timeout)
              'bad-timeout)))

      (test "thread-join! end result" 5
        (let* ((th (make-thread (lambda () (+ 3 2)))))
          (thread-start! th)
          (thread-join! th)))

      (test-error "thread-join! exception"
                  (let* ((th (make-thread
                              (lambda ()
                                (parameterize ((current-error-port (open-output-string)))
                                  (+ 3 "2"))))))
                    (thread-start! th)
                    (thread-join! th)))

      (test-assert "make-condition-variable"
        (condition-variable? (make-condition-variable)))

      (test "condition-variable signal" 'ok
        (let* ((mutex (make-mutex))
               (cndvar (make-condition-variable))
               (th (make-thread
                    (lambda ()
                      (if (mutex-unlock! mutex cndvar 0.1) 'ok 'timeout1)))))
          (thread-start! th)
          (thread-yield!)
          (condition-variable-signal! cndvar)
          (thread-join! th 0.1 'timeout2)))

      (test "condition-variable broadcast" '(ok1 ok2)
        (let* ((mutex (make-mutex))
               (cndvar (make-condition-variable))
               (th1 (make-thread
                     (lambda ()
                       (mutex-lock! mutex)
                       (if (mutex-unlock! mutex cndvar 1.0) 'ok1 'timeout1))))
               (th2 (make-thread
                     (lambda ()
                       (mutex-lock! mutex)
                       (if (mutex-unlock! mutex cndvar 1.0) 'ok2 'timeout2)))))
          (thread-start! th1)
          (thread-start! th2)
          (thread-yield!)
          (mutex-lock! mutex)
          (condition-variable-broadcast! cndvar)
          (mutex-unlock! mutex)
          (list (thread-join! th1 0.1 'timeout3)
                (thread-join! th2 0.1 'timeout4))))

      (test-end))))

(define-library (srfi 188)
  (import (rename (chibi)
                  (let-syntax splicing-let-syntax)
                  (letrec-syntax splicing-letrec-syntax)))
  (export splicing-let-syntax splicing-letrec-syntax))

(define-library (srfi 134 test)
  (import (scheme base) (scheme char)
          (srfi 1) (srfi 121) (srfi 134)
          (chibi test))
  (export run-tests)
  (begin
    (define-syntax receive
      (syntax-rules ()
        ((_ binds mv-expr body ...)
         (let-values ((binds mv-expr)) body ...))))
    (define (run-tests)
      (test-group "srfi-134: ideque"

        (test-group "ideque/constructors"
          (test '() (ideque->list (ideque)))
          (test '() (ideque->list (list->ideque '())))
          (test '(1 2 3) (ideque->list (ideque 1 2 3)))
          (test '(4 5 6 7) (ideque->list (list->ideque '(4 5 6 7))))
          (test '(10 9 8 7 6 5 4 3 2 1)
              (ideque->list (ideque-unfold zero? values (lambda (n) (- n 1)) 10)))
          (test '(1 2 3 4 5 6 7 8 9 10)
              (ideque->list (ideque-unfold-right zero? values (lambda (n) (- n 1)) 10)))
          (test '(0 2 4 6 8 10)
              (ideque->list (ideque-tabulate 6 (lambda (n) (* n 2)))))
          
          ;; corner cases
          (test '() (ideque->list
                     (ideque-unfold (lambda (n) #t) values (lambda (n) (+ n 1)) 0)))
          (test '() (ideque->list
                     (ideque-unfold-right (lambda (n) #t) values (lambda (n) (+ n 1)) 0)))
          (test '() (ideque->list (ideque-tabulate 0 values)))
          )

        (test-group "ideque/predicates"
          (test-assert (ideque? (ideque)))
          (test-assert (not (ideque? 1)))
          (test-assert (ideque-empty? (ideque)))
          (test-assert (not (ideque-empty? (ideque 1))))
          (test-assert (ideque= eq?))
          (test-assert (ideque= eq? (ideque 1)))
          (test-assert (ideque= char-ci=? (ideque #\a #\b) (ideque #\A #\B)))
          (test-assert (ideque= char-ci=? (ideque) (ideque)))
          (test-assert (not (ideque= char-ci=? (ideque #\a #\b) (ideque #\A #\B #\c))))
          (test-assert (not (ideque= char-ci=? (ideque #\a #\b) (ideque #\A))))
          (test-assert (ideque= char-ci=? (ideque) (ideque) (ideque)))
          (test-assert (ideque= char-ci=? (ideque #\a #\b) (ideque #\A #\B) (ideque #\a #\B)))
          (test-assert (not (ideque= char-ci=? (ideque #\a #\b) (ideque #\A) (ideque #\a #\B))))
          (test-assert (not (ideque= char-ci=? (ideque #\a #\b) (ideque #\A #\B) (ideque #\A #\B #\c))))
          )

        (test-group "ideque/queue-operations"
          (test-error (ideque-front (ideque)))
          (test-error (ideque-back (ideque)))
          (test 1 (ideque-front (ideque 1 2 3)))
          (test 3 (ideque-back (ideque 1 2 3)))
          (test 2 (ideque-front (ideque-remove-front (ideque 1 2 3))))
          (test 2 (ideque-back (ideque-remove-back (ideque 1 2 3))))
          (test 1 (ideque-front (ideque-remove-back (ideque 1 2 3))))
          (test 3 (ideque-back (ideque-remove-front (ideque 1 2 3))))
          (test-assert (ideque-empty? (ideque-remove-front (ideque 1))))
          (test-assert (ideque-empty? (ideque-remove-back (ideque 1))))
          (test 0 (ideque-front (ideque-add-front (ideque 1 2 3) 0)))
          (test 0 (ideque-back (ideque-add-back (ideque 1 2 3) 0)))
          )

        (test-group "ideque/other-accessors"
          (define (check name ideque-op list-op n)
            (let* ((lis (iota n))
                   (dq (list->ideque lis)))
              (for-each (lambda (i)
                          (test (cons name i)
                              (receive xs (list-op lis i) xs)
                            (receive xs (ideque-op dq i)
                              (map ideque->list xs))))
                        lis)))
          (check 'ideque-take ideque-take take 7)
          (check 'ideque-drop ideque-drop drop 6)
          (check 'ideque-split-at ideque-split-at split-at 8)
          ;; out-of-range conditions
          (test-error (ideque->list (ideque-take (ideque 1 2 3 4 5 6 7) 10)))
          (test-error (ideque->list (ideque-take-right (ideque 1 2 3 4 5 6 7) 10)))
          (test-error (ideque-split-at (ideque 1 2 3 4 5 6 7) 10))

          (test '(3 2 1) (map (lambda (n) (ideque-ref (ideque 3 2 1) n)) '(0 1 2)))
          (test-error (ideque-ref (ideque 3 2 1) -1))
          (test-error (ideque-ref (ideque 3 2 1) 3))
          )

        (test-group "ideque/whole-ideque"
          (test 7 (ideque-length (ideque 1 2 3 4 5 6 7)))
          (test 0 (ideque-length (ideque)))
          (test '() (ideque->list (ideque-append)))
          (test '() (ideque->list (ideque-append (ideque) (ideque))))
          (test '(1 2 3 a b c d 5 6 7 8 9)
              (ideque->list (ideque-append (ideque 1 2 3)
                                           (ideque 'a 'b 'c 'd)
                                           (ideque)
                                           (ideque 5 6 7 8 9))))
          (test '() (ideque->list (ideque-reverse (ideque))))
          (test '(5 4 3 2 1) (ideque->list (ideque-reverse (ideque 1 2 3 4 5))))
          (test 0 (ideque-count odd? (ideque)))
          (test 3 (ideque-count odd? (ideque 1 2 3 4 5)))
          (test '((1 a) (2 b) (3 c))
              (ideque->list (ideque-zip (ideque 1 2 3) (ideque 'a 'b 'c 'd 'e))))
          (test '((1 a x) (2 b y) (3 c z))
              (ideque->list (ideque-zip (ideque 1 2 3 4 5)
                                        (ideque 'a 'b 'c 'd 'e)
                                        (ideque 'x 'y 'z))))
          (test '((1) (2) (3))
              (ideque->list (ideque-zip (ideque 1 2 3))))
          (test '()
              (ideque->list (ideque-zip (ideque 1 2 3) (ideque))))
          )

        (test-group "ideque/mapping"
          (test-assert (ideque-empty? (ideque-map list (ideque))))
          (test '(-1 -2 -3 -4 -5) (ideque->list (ideque-map - (ideque 1 2 3 4 5))))
          (test '(-1 -3 5 -8)
              (ideque->list (ideque-filter-map (lambda (x) (and (number? x) (- x)))
                                               (ideque 1 3 'a -5 8))))
          (test '(5 4 3 2 1)
              (let ((r '()))
                (ideque-for-each (lambda (n) (set! r (cons n r)))
                                 (ideque 1 2 3 4 5))
                r))
          (test '(1 2 3 4 5)
              (let ((r '()))
                (ideque-for-each-right (lambda (n) (set! r (cons n r)))
                                       (ideque 1 2 3 4 5))
                r))
          (test '(5 4 3 2 1 . z)
              (ideque-fold cons 'z (ideque 1 2 3 4 5)))
          (test '(1 2 3 4 5 . z)
              (ideque-fold-right cons 'z (ideque 1 2 3 4 5)))
          (test '(a a b b c c)
              (ideque->list (ideque-append-map (lambda (x) (list x x))
                                               (ideque 'a 'b 'c))))
          )

        (test-group "ideque/filtering"
          (test '(1 3 5)
              (ideque->list (ideque-filter odd? (ideque 1 2 3 4 5))))
          (test '(2 4)
              (ideque->list (ideque-remove odd? (ideque 1 2 3 4 5))))
          (test '((1 3 5) (2 4))
              (receive xs (ideque-partition odd? (ideque 1 2 3 4 5))
                (map ideque->list xs)))
          )

        (test-group "ideque/searching"
          (test 3 (ideque-find number? (ideque 'a 3 'b 'c 4 'd) (lambda () 'boo)))
          (test 'boo (ideque-find number? (ideque 'a 'b 'c 'd) (lambda () 'boo)))
          (test #f (ideque-find number? (ideque 'a 'b 'c 'd)))
          (test 4 (ideque-find-right number? (ideque 'a 3 'b 'c 4 'd) (lambda () 'boo)))
          (test 'boo (ideque-find-right number? (ideque 'a 'b 'c 'd) (lambda () 'boo)))
          (test #f (ideque-find-right number? (ideque 'a 'b 'c 'd)))
          (test '(1 3 2)
              (ideque->list (ideque-take-while (lambda (n) (< n 5))
                                               (ideque 1 3 2 5 8 4 6 3 4 2))))
          (test '(5 8 4 6 3 4 2)
              (ideque->list (ideque-drop-while (lambda (n) (< n 5))
                                               (ideque 1 3 2 5 8 4 6 3 4 2))))
          (test '(3 4 2)
              (ideque->list (ideque-take-while-right (lambda (n) (< n 5))
                                                     (ideque 1 3 2 5 8 4 6 3 4 2))))
          (test '(1 3 2 5 8 4 6)
              (ideque->list (ideque-drop-while-right (lambda (n) (< n 5))
                                                     (ideque 1 3 2 5 8 4 6 3 4 2))))
          (test '()
              (ideque->list (ideque-take-while (lambda (n) (< n 5))
                                               (ideque 5 8 4 6 3 4 2 9))))
          (test '()
              (ideque->list (ideque-drop-while (lambda (n) (< n 5))
                                               (ideque 1 4 3 2 3 4 2 1))))
          (test '()
              (ideque->list (ideque-take-while-right (lambda (n) (< n 5))
                                                     (ideque 5 8 4 6 3 4 2 9))))
          (test '()
              (ideque->list (ideque-drop-while-right (lambda (n) (< n 5))
                                                     (ideque 1 3 2 4 3 2 3 2))))
          (test '((1 3 2) (5 8 4 6 3 4 2))
              (receive xs (ideque-span (lambda (n) (< n 5))
                                       (ideque 1 3 2 5 8 4 6 3 4 2))
                (map ideque->list xs)))
          (test '((5 8) (4 6 3 4 2 9))
              (receive xs (ideque-break (lambda (n) (< n 5))
                                        (ideque 5 8 4 6 3 4 2 9))
                (map ideque->list xs)))
          (test 3 (ideque-any (lambda (x) (and (number? x) x))
                              (ideque 'a 3 'b 'c 4 'd 'e)))
          (test 5 (ideque-any (lambda (x) (and (number? x) x))
                              (ideque 'a 'b 'c 'd 'e 5)))
          (test #f (ideque-any (lambda (x) (and (number? x) x))
                               (ideque 'a 'b 'c 'd 'e)))
          (test 9 (ideque-every (lambda (x) (and (number? x) x))
                                (ideque 1 5 3 2 9)))
          (test #f (ideque-every (lambda (x) (and (number? x) x))
                                 (ideque 1 5 'a 2 9)))
          ;; check if we won't see further once we found the result
          (test 1 (ideque-any (lambda (x) (and (odd? x) x))
                              (ideque 2 1 'a 'b 'c 'd)))
          (test #f (ideque-every (lambda (x) (and (odd? x) x))
                                 (ideque 1 2 'a 'b 'c 'd)))

          (test '(1 2 3) (generator->list (ideque->generator (ideque 1 2 3))))
          (test '() (generator->list (ideque->generator (ideque))))
          (test '(1 2 3) (ideque->list (generator->ideque (generator 1 2 3))))
          (test '() (ideque->list (generator->ideque (generator))))
          )

        ))))
(define-library (srfi 227 definition)
  (export (rename define-opt define-optionals)
          (rename define-opt* define-optionals*))
  (import (chibi optional)))

(define-library (srfi 9)
  (export define-record-type)
  (import (chibi))
  (include "9.scm"))
(define-library (srfi 145)
  (export assume)
  (import (scheme base) (chibi assert))
  (cond-expand
    ((or elide-assumptions
         (and (not assumptions)
              (not debug)))
     (begin
       (define-syntax assume
         (syntax-rules ()
           ((assume expression objs ...)
            expression)
           ((assume)
            (syntax-error "assume requires an expression"))))))
    (else
     (begin
       (define-syntax assume
         (syntax-rules ()
           ((assume expression objs ...)
            (assert expression objs ...))
           ((assume)
            (syntax-error "assume requires an expression"))))))))
(define-library (srfi 128)
  (import (scheme base) (scheme char)
          (srfi 27) (srfi 69) (srfi 95) (srfi 98) (srfi 151)
          (only (chibi) fixnum? er-macro-transformer)
          (only (chibi ast) opcode? procedure? procedure-arity procedure-variadic?))
  (export
   ;; Predicates:
   comparator? comparator-ordered? comparator-hashable?
   ;; Constructors:
   make-comparator make-pair-comparator make-list-comparator
   make-vector-comparator make-eq-comparator make-eqv-comparator
   make-equal-comparator
   ;; Standard hash functions:
   boolean-hash char-hash char-ci-hash string-hash string-ci-hash
   symbol-hash number-hash
   ;; Bounds and salt:
   hash-bound hash-salt
   ;; Default comparators:
   make-default-comparator default-hash comparator-register-default!
   ;; Accessors and invokers:
   comparator-type-test-predicate comparator-equality-predicate
   comparator-ordering-predicate comparator-hash-function
   comparator-test-type comparator-check-type comparator-hash
   ;; Comparison predicates:
   =? <? >? <=? >=?
   ;;Syntax:
   comparator-if<=>
   ;;SRFI 162:
   comparator-max comparator-min
   comparator-max-in-list comparator-min-in-list
   default-comparator boolean-comparator real-comparator
   char-comparator char-ci-comparator
   string-comparator string-ci-comparator
   list-comparator vector-comparator
   eq-comparator eqv-comparator equal-comparator)
  (include "128/comparators.scm")
  (include "128/162-impl.scm")
  )

(define-library (srfi 99)
  (import (srfi 99 records))
  (export make-rtd rtd? rtd-constructor rtd-predicate rtd-accessor rtd-mutator
          record? record-rtd rtd-name rtd-parent
          rtd-field-names rtd-all-field-names rtd-field-mutable?
          define-record-type))
(define-library (srfi 26 test)
  (export run-tests)
  (import (chibi) (srfi 26) (chibi test))
  (begin
    (define (run-tests)
      (test-begin "srfi-26: cut")
      (let ((x 'orig))
        (let ((f (cute list x)))
          (set! x 'wrong)
          (test '(orig) (f))))
      (let ((x 'wrong))
        (let ((f (cut list x)))
          (set! x 'right)
          (test '(right) (f))))
      (test-end))))

(define-library (srfi 39)
  (export make-parameter parameterize)
  (import (chibi))
  (include-shared "39/param")
  (cond-expand
   (threads
    (include "39/syntax.scm"))
   (else
    (include "39/syntax-no-threads.scm"))))
(define-library (srfi 121)
  (export generator
          make-iota-generator
          make-range-generator
          make-coroutine-generator
          list->generator
          vector->generator
          reverse-vector->generator
          string->generator
          bytevector->generator
          make-for-each-generator
          make-unfold-generator
          gcons*
          gappend
          gcombine
          gfilter
          gremove
          gtake
          gdrop
          gtake-while
          gdrop-while
          gdelete
          gdelete-neighbor-dups
          gindex
          gselect
          generator->list
          generator->reverse-list
          generator->vector
          generator->vector!
          generator->string
          generator-fold
          generator-for-each
          generator-find
          generator-count
          generator-any
          generator-every
          generator-unfold)
  (import (scheme base) (srfi 130))
  (include "121/generators.scm"))

(define (list-sorted? < ls) (sorted? ls <))
(define (vector-sorted? < vec) (sorted? vec <))

(define (list-sort < ls) (sort ls <))
(define (list-stable-sort < ls) (sort ls <))

(define (vector-sort < vec . o)
  (if (pair? o) (sort (apply vector-copy vec o) <) (sort vec <)))
(define vector-stable-sort vector-sort)

(define (list-sort! < ls) (sort! ls <))
(define (list-stable-sort! < ls) (sort! ls <))

(define (vector-sort! < vec . o)
  (if (pair? o)
      (let ((v (vector-sort! < (apply vector-copy vec o))))
        (vector-copy! vec (car o) v)
        vec)
      (sort! vec <)))
(define vector-stable-sort! vector-sort!)

(define (list-merge < ls1 ls2) (merge ls1 ls2 <))
(define (list-merge! < ls1 ls2) (merge! ls1 ls2 <))

(define (vector-merge less vec1 vec2 . o)
  (if (pair? o)
      (if (pair? (cdr o))
          (vector-merge less
                        (vector-copy vec1 (car o) (cadr o))
                        (apply vector-copy vec2 (cddr o)))
          (vector-merge less (vector-copy vec1 (car o)) vec2))
      (let* ((e1 (vector-length vec1))
             (e2 (vector-length vec2))
             (res (make-vector (+ e1 e2))))
        (let lp ((i 0) (i1 0) (i2 0))
          (cond
           ((and (>= i1 e1) (>= i2 e2)) res)
           ((or (>= i1 e1)
                (and (< i2 e2)
                     (less (vector-ref vec2 i2) (vector-ref vec1 i1))))
            (vector-set! res i (vector-ref vec2 i2))
            (lp (+ i 1) i1 (+ i2 1)))
           (else
            (vector-set! res i (vector-ref vec1 i1))
            (lp (+ i 1) (+ i1 1) i2)))))))

(define (vector-merge! < to vec1 vec2 . o)
  (let ((start (if (pair? o) (car o) 0))
        (o (if (pair? o) (cdr o) '())))
    (let ((res (apply vector-merge < vec1 vec2 o)))
      (vector-copy! to start res))))

(define (list-delete-neighbor-dups eq ls)
  (let lp ((ls ls) (res '()))
    (cond ((null? ls) (reverse res))
          ((and (pair? res) (eq (car res) (car ls))) (lp (cdr ls) res))
          (else (lp (cdr ls) (cons (car ls) res))))))

(define (list-delete-neighbor-dups! eq ls)
  (if (pair? ls)
      (let lp ((ls (cdr ls)) (start ls))
        (cond ((null? ls) (set-cdr! start '()))
              ((eq (car start) (car ls)) (lp (cdr ls) start))
              (else (set-cdr! start ls) (lp (cdr ls) ls)))))
  ls)

(define (vector-delete-neighbor-dups eq vec . o)
  (if (zero? (vector-length vec))
      vec
      (let ((ls (if (and (pair? o) (pair? (cdr o)))
                    (vector->list vec (car o) (cadr o))
                    (apply vector->list vec o))))
        (list->vector (list-delete-neighbor-dups eq ls)))))

(define (vector-delete-neighbor-dups! eq vec . o)
  (let ((start (if (pair? o) (car o) 0))
        (end (if (and (pair? o) (pair? (cdr o))) (cadr o) (vector-length vec))))
    (cond
     ((<= end start) start)
     (else
      (let lp ((i (+ start 1))
               (fill (+ start 1)))
        (cond
         ((>= i end) fill)
         ((eq (vector-ref vec (- i 1)) (vector-ref vec i)) (lp (+ i 1) fill))
         (else
          (if (> i fill)
              (vector-set! vec fill (vector-ref vec i)))
          (lp (+ i 1) (+ fill 1)))))))))

;; Median of 3 (good in practice, use median-of-medians for guaranteed
;; linear time).
(define (choose-pivot < vec left right)
  (let* ((mid (quotient (+ left right) 2))
         (a (vector-ref vec left))
         (b (vector-ref vec mid))
         (c (vector-ref vec right)))
    (if (< a b)
        (if (< b c) mid (if (< a c) right left))
        (if (< a c) left (if (< b c) right mid)))))

;; Partitions around elt and returns the resulting median index.
(define (vector-partition! < vec left right pivot)
  (define (swap! i j)
    (let ((tmp (vector-ref vec i)))
      (vector-set! vec i (vector-ref vec j))
      (vector-set! vec j tmp)))
  (let ((elt (vector-ref vec pivot)))
    (swap! pivot right)
    (let lp ((i left)
             (j left))
      (cond
       ((= i right)
        (swap! i j)
        j)
       ((< (vector-ref vec i) elt)
        (swap! i j)
        (lp (+ i 1) (+ j 1)))
       (else
        (lp (+ i 1) j))))))

;; Permutes vec in-place to move the k smallest elements as ordered by
;; < to the beginning of the vector (unsorted).  Returns the nth smallest.
(define (vector-select! less vec k . o)
  (let* ((left (if (pair? o) (car o) 0))
         (k (+ k left)))
    (if (not (<= 0 k (vector-length vec)))
        (error "k out of range" vec k))
    (let select ((left left)
                 (right (- (if (and (pair? o) (pair? (cdr o)))
                               (cadr o)
                               (vector-length vec))
                           1)))
      (if (>= left right)
          (vector-ref vec left)
          (let* ((pivot (choose-pivot less vec left right))
                 (pivot-index (vector-partition! less vec left right pivot)))
            (cond
             ((= k pivot-index)
              (vector-ref vec k))
             ((< k pivot-index)
              (select left (- pivot-index 1)))
             (else
              (select (+ pivot-index 1) right))))))))

(define (vector-separate! < vec k . o)
  (apply vector-select! < vec k o)
  (if #f #f))

(define (vector-find-median! < vec knil . o)
  (vector-sort! < vec)  ; required by SRFI 132
  (let* ((len (vector-length vec))
         (mid (quotient len 2))
         (mean (if (pair? o) (car o) (lambda (a b) (/ (+ a b) 2)))))
    (cond
     ((zero? len) knil)
     ((odd? len) (vector-ref vec mid))
     (else (mean (vector-ref vec (- mid 1)) (vector-ref vec mid))))))

(define (vector-max less vec lo hi largest)
  (cond
   ((>= lo hi) largest)
   ((less largest (vector-ref vec lo))
    (vector-max less vec (+ lo 1) hi (vector-ref vec lo)))
   (else
    (vector-max less vec (+ lo 1) hi largest))))

(define (vector-find-median < vec knil . o)
  (let* ((vec (vector-copy vec))
         (len (vector-length vec))
         (mid (quotient len 2))
         (mean (if (pair? o) (car o) (lambda (a b) (/ (+ a b) 2)))))
    (cond
     ((zero? len) knil)
     (else
      (let ((mid-elt (vector-select! < vec mid)))
        (cond
         ((odd? len) mid-elt)
         (else
          (mean (vector-max < vec 0 (- mid 1) (vector-ref vec (- mid 1)))
                mid-elt))))))))
(define-library (srfi 132 test)
  (import (scheme base) (srfi 132) (chibi test))
  (export run-tests)
  (begin
    (define (run-tests)
      (test-begin "srfi-132: sorting")
      (test '()
          (list-sort > (list)))
      (test '(987)
          (list-sort > (list 987)))
      (test '(987 654)
          (list-sort > (list 987 654)))
      (test '(9 8 7 6 5 4 3 2 1 0)
          (list-sort > (list 9 8 6 3 0 4 2 5 7 1)))
      (test '()
          (list-stable-sort > (list)))
      (test '(987)
          (list-stable-sort > (list 987)))
      (test '(987 654)
          (list-stable-sort > (list 987 654)))
      (test '(9 8 7 6 5 4 3 2 1 0)
          (list-stable-sort > (list 9 8 6 3 0 4 2 5 7 1)))
      (test '(9 8 6 7 4 5 3 2 0 1)
          (list-stable-sort (lambda (x y)
                              (> (quotient x 2)
                                 (quotient y 2)))
                            (list 9 8 6 3 0 4 2 5 7 1)))
      (test '#()
          (let ((v (vector)))
            (vector-sort > v)))
      (test '#(987)
          (let ((v (vector 987)))
            (vector-sort > (vector 987))))
      (test '#(987 654)
          (let ((v (vector 987 654)))
            (vector-sort > v)))
      (test '#(9 8 7 6 5 4 3 2 1 0)
          (let ((v (vector 9 8 6 3 0 4 2 5 7 1)))
            (vector-sort > v)))
      (test '#()
          (let ((v (vector)))
            (vector-stable-sort > v)))
      (test '#(987)
          (let ((v (vector 987)))
            (vector-stable-sort > (vector 987))))
      (test '#(987 654)
          (let ((v (vector 987 654)))
            (vector-stable-sort > v)))
      (test '#(9 8 7 6 5 4 3 2 1 0)
          (let ((v (vector 9 8 6 3 0 4 2 5 7 1)))
            (vector-stable-sort > v)))
      (test '#(9 8 6 7 4 5 3 2 0 1)
          (let ((v (vector 9 8 6 3 0 4 2 5 7 1)))
            (vector-stable-sort (lambda (x y)
                                  (> (quotient x 2)
                                     (quotient y 2)))
                                v)))
      (test '#()
          (let ((v (vector)))
            (vector-sort > v 0)))
      (test '#()
          (let ((v (vector 987)))
            (vector-sort > (vector 987) 1)))
      (test '#(654)
          (let ((v (vector 987 654)))
            (vector-sort > v 1)))
      (test '#(7 5 4 3 2 1 0)
          (let ((v (vector 9 8 6 3 0 4 2 5 7 1)))
            (vector-sort > v 3)))
      (test '#()
          (let ((v (vector)))
            (vector-stable-sort > v 0)))
      (test '#()
          (let ((v (vector 987)))
            (vector-stable-sort > (vector 987) 1)))
      (test '#(654 987)
          (let ((v (vector 987 654)))
            (vector-stable-sort < v 0 2)))
      (test '#(7 5 4 3 2 1 0)
          (let ((v (vector 9 8 6 3 0 4 2 5 7 1)))
            (vector-stable-sort > v 3)))
      (test '#(7 4 5 3 2 0 1)
          (let ((v (vector 9 8 6 3 0 4 2 5 7 1)))
            (vector-stable-sort (lambda (x y)
                                  (> (quotient x 2)
                                     (quotient y 2)))
                                v
                                3)))
      (test '#()
          (let ((v (vector)))
            (vector-sort > v 0 0)))
      (test '#()
          (let ((v (vector 987)))
            (vector-sort > (vector 987) 1 1)))
      (test '#(654)
          (let ((v (vector 987 654)))
            (vector-sort > v 1 2)))
      (test '#(5 4 2 0)
          (let ((v (vector 9 8 6 3 0 4 2 5 7 1)))
            (vector-sort > v 4 8)))
      (test '#()
          (let ((v (vector)))
            (vector-stable-sort > v 0 0)))
      (test '#()
          (let ((v (vector 987)))
            (vector-stable-sort > (vector 987) 1 1)))
      (test '#(654)
          (let ((v (vector 987 654)))
            (vector-stable-sort > v 1 2)))
      (test '#(6 4 3 0)
          (let ((v (vector 9 8 6 3 0 4 2 5 7 1)))
            (vector-stable-sort > v 2 6)))
      (test '#(8 6 4 5 3 2 0)
          (let ((v (vector 9 8 6 3 0 4 2 5 7 1)))
            (vector-stable-sort (lambda (x y)
                                  (> (quotient x 2)
                                     (quotient y 2)))
                                v
                                1
                                8)))
      (test '()
          (list-sort! > (list)))
      (test '(987)
          (list-sort! > (list 987)))
      (test '(987 654)
          (list-sort! > (list 987 654)))
      (test '(9 8 7 6 5 4 3 2 1 0)
          (list-sort! > (list 9 8 6 3 0 4 2 5 7 1)))
      (test '()
          (list-stable-sort! > (list)))
      (test '(987)
          (list-stable-sort! > (list 987)))
      (test '(987 654)
          (list-stable-sort! > (list 987 654)))
      (test '(9 8 7 6 5 4 3 2 1 0)
          (list-stable-sort! > (list 9 8 6 3 0 4 2 5 7 1)))
      (test '(9 8 6 7 4 5 3 2 0 1)
          (list-stable-sort! (lambda (x y)
                               (> (quotient x 2)
                                  (quotient y 2)))
                             (list 9 8 6 3 0 4 2 5 7 1)))
      (test '#()
          (let ((v (vector)))
            (vector-sort! > v)
            v))
      (test '#(987)
          (let ((v (vector 987)))
            (vector-sort! > (vector 987))
            v))
      (test '#(987 654)
          (let ((v (vector 987 654)))
            (vector-sort! > v)
            v))
      (test '#(9 8 7 6 5 4 3 2 1 0)
          (let ((v (vector 9 8 6 3 0 4 2 5 7 1)))
            (vector-sort! > v)
            v))
      (test '#()
          (let ((v (vector)))
            (vector-stable-sort! > v)
            v))
      (test '#(987)
          (let ((v (vector 987)))
            (vector-stable-sort! > (vector 987))
            v))
      (test '#(987 654)
          (let ((v (vector 987 654)))
            (vector-stable-sort! > v)
            v))
      (test '#(9 8 7 6 5 4 3 2 1 0)
          (let ((v (vector 9 8 6 3 0 4 2 5 7 1)))
            (vector-stable-sort! > v)
            v))
      (test '#(9 8 6 7 4 5 3 2 0 1)
          (let ((v (vector 9 8 6 3 0 4 2 5 7 1)))
            (vector-stable-sort! (lambda (x y)
                                   (> (quotient x 2)
                                      (quotient y 2)))
                                 v)
            v))
      (test '#()
          (let ((v (vector)))
            (vector-sort! > v 0)
            v))
      (test '#(987)
          (let ((v (vector 987)))
            (vector-sort! > (vector 987) 1)
            v))
      (test '#(987 654)
          (let ((v (vector 987 654)))
            (vector-sort! > v 1)
            v))
      (test '#(9 8 6 7 5 4 3 2 1 0)
          (let ((v (vector 9 8 6 3 0 4 2 5 7 1)))
            (vector-sort! > v 3)
            v))
      (test '#()
          (let ((v (vector)))
            (vector-stable-sort! > v 0)
            v))
      (test '#(987)
          (let ((v (vector 987)))
            (vector-stable-sort! > (vector 987) 1)
            v))
      (test '#(654 987)
          (let ((v (vector 987 654)))
            (vector-stable-sort! < v 0 2)
            v))
      (test '#(9 8 6 7 5 4 3 2 1 0)
          (let ((v (vector 9 8 6 3 0 4 2 5 7 1)))
            (vector-stable-sort! > v 3)
            v))
      (test '#(9 8 6 7 4 5 3 2 0 1)
          (let ((v (vector 9 8 6 3 0 4 2 5 7 1)))
            (vector-stable-sort! (lambda (x y)
                                   (> (quotient x 2)
                                      (quotient y 2)))
                                 v
                                 3)
            v))
      (test '#()
          (let ((v (vector)))
            (vector-sort! > v 0 0)
            v))
      (test '#(987)
          (let ((v (vector 987)))
            (vector-sort! > (vector 987) 1 1)
            v))
      (test '#(987 654)
          (let ((v (vector 987 654)))
            (vector-sort! > v 1 2)
            v))
      (test '#(9 8 6 3 5 4 2 0 7 1)
          (let ((v (vector 9 8 6 3 0 4 2 5 7 1)))
            (vector-sort! > v 4 8)
            v))
      (test '#()
          (let ((v (vector)))
            (vector-stable-sort! > v 0 0)
            v))
      (test '#(987)
          (let ((v (vector 987)))
            (vector-stable-sort! > (vector 987) 1 1)
            v))
      (test '#(987 654)
          (let ((v (vector 987 654)))
            (vector-stable-sort! > v 1 2)
            v))
      (test '#(9 8 6 4 3 0 2 5 7 1)
          (let ((v (vector 9 8 6 3 0 4 2 5 7 1)))
            (vector-stable-sort! > v 2 6)
            v))
      (test '#(9 8 6 4 5 3 2 0 7 1)
          (let ((v (vector 9 8 6 3 0 4 2 5 7 1)))
            (vector-stable-sort! (lambda (x y)
                                   (> (quotient x 2)
                                      (quotient y 2)))
                                 v
                                 1
                                 8)
            v))
      (test (list-merge > (list) (list))
          '())
      (test '(9 6 3 0)
          (list-merge > (list) (list 9 6 3 0)))
      (test '(9 7 5 3 1)
          (list-merge > (list 9 7 5 3 1) (list)))
      (test '(9 9 7 6 5 3 3 1 0)
          (list-merge > (list 9 7 5 3 1) (list 9 6 3 0)))
      (test '()
          (list-merge! > (list) (list)))
      (test '(9 6 3 0)
          (list-merge! > (list) (list 9 6 3 0)))
      (test '(9 7 5 3 1)
          (list-merge! > (list 9 7 5 3 1) (list)))
      (test '(9 9 7 6 5 3 3 1 0)
          (list-merge! > (list 9 7 5 3 1) (list 9 6 3 0)))
      (test '#()
          (vector-merge > (vector) (vector)))
      (test '#(9 6 3 0)
          (vector-merge > (vector) (vector 9 6 3 0)))
      (test '#(9 7 5 3 1)
          (vector-merge > (vector 9 7 5 3 1) (vector)))
      (test '#(9 9 7 6 5 3 3 1 0)
          (vector-merge > (vector 9 7 5 3 1) (vector 9 6 3 0)))
      (test '#(#f #f #f #f #f #f #f #f #f #f #f #f)
          (let ((v (make-vector 12 #f)))
            (vector-merge! > v (vector) (vector))
            v))
      (test '#( 9  6  3  0 #f #f #f #f #f #f #f #f)
          (let ((v (make-vector 12 #f)))
            (vector-merge! > v (vector) (vector 9 6 3 0))
            v))
      (test '#( 9  7  5  3  1 #f #f #f #f #f #f #f)
          (let ((v (make-vector 12 #f)))
            (vector-merge! > v (vector 9 7 5 3 1) (vector))
            v))
      (test '#( 9  9  7  6  5  3  3  1  0 #f #f #f)
          (let ((v (make-vector 12 #f)))
            (vector-merge! > v (vector 9 7 5 3 1) (vector 9 6 3 0))
            v))
      (test '#(#f #f #f #f #f #f #f #f #f #f #f #f)
          (let ((v (make-vector 12 #f)))
            (vector-merge! > v (vector) (vector) 0)
            v))
      (test '#( 9  6  3  0 #f #f #f #f #f #f #f #f)
          (let ((v (make-vector 12 #f)))
            (vector-merge! > v (vector) (vector 9 6 3 0) 0)
            v))
      (test '#( 9  7  5  3  1 #f #f #f #f #f #f #f)
          (let ((v (make-vector 12 #f)))
            (vector-merge! > v (vector 9 7 5 3 1) (vector) 0)
            v))
      (test '#( 9  9  7  6  5  3  3  1  0 #f #f #f)
          (let ((v (make-vector 12 #f)))
            (vector-merge! > v (vector 9 7 5 3 1) (vector 9 6 3 0) 0)
            v))
      (test '#(#f #f #f #f #f #f #f #f #f #f #f #f)
          (let ((v (make-vector 12 #f)))
            (vector-merge! > v (vector) (vector) 2)
            v))
      (test '#(#f #f 9  6  3  0 #f #f #f #f #f #f)
          (let ((v (make-vector 12 #f)))
            (vector-merge! > v (vector) (vector 9 6 3 0) 2)
            v))
      (test '#(#f #f  9  7  5  3  1 #f #f #f #f #f)
          (let ((v (make-vector 12 #f)))
            (vector-merge! > v (vector 9 7 5 3 1) (vector) 2)
            v))
      (test '#(#f #f 9  9  7  6  5  3  3  1  0 #f)
          (let ((v (make-vector 12 #f)))
            (vector-merge! > v (vector 9 7 5 3 1) (vector 9 6 3 0) 2)
            v))
      (test '#()
          (vector-merge > (vector) (vector) 0))
      (test '#(9 6 3 0)
          (vector-merge > (vector) (vector 9 6 3 0) 0))
      (test '#(5 3 1)
          (vector-merge > (vector 9 7 5 3 1) (vector) 2))
      (test '#(9 6 5 3 3 1 0)
          (vector-merge > (vector 9 7 5 3 1) (vector 9 6 3 0) 2))
      (test '#(#f #f #f #f #f #f #f #f #f #f #f #f)
          (let ((v (make-vector 12 #f)))
            (vector-merge! > v (vector) (vector) 2 0)
            v))
      (test '#(#f #f 9  6  3  0 #f #f #f #f #f #f)
          (let ((v (make-vector 12 #f)))
            (vector-merge! > v (vector) (vector 9 6 3 0) 2 0)
            v))
      (test '#(#f #f 5  3  1 #f #f #f #f #f #f #f)
          (let ((v (make-vector 12 #f)))
            (vector-merge! > v (vector 9 7 5 3 1) (vector) 2 2)
            v))
      (test '#(#f #f  9   6  5  3  3  1  0 #f #f #f)
          (let ((v (make-vector 12 #f)))
            (vector-merge! > v (vector 9 7 5 3 1) (vector 9 6 3 0) 2 2)
            v))
      (test '#()
          (vector-merge > (vector) (vector) 0 0))
      (test '#(9 6 3 0)
          (vector-merge > (vector) (vector 9 6 3 0) 0 0))
      (test '#(5 3 1)
          (vector-merge > (vector 9 7 5 3 1) (vector) 2 5))
      (test '#(9 6 5 3 3 1 0)
          (vector-merge > (vector 9 7 5 3 1) (vector 9 6 3 0) 2 5))
      (test '#(#f #f #f #f #f #f #f #f #f #f #f #f)
          (let ((v (make-vector 12 #f)))
            (vector-merge! > v (vector) (vector) 2 0 0)
            v))
      (test '#(#f #f 9  6  3  0 #f #f #f #f #f #f)
          (let ((v (make-vector 12 #f)))
            (vector-merge! > v (vector) (vector 9 6 3 0) 2 0 0)
            v))
      (test '#(#f #f 5  3  1 #f #f #f #f #f #f #f)
          (let ((v (make-vector 12 #f)))
            (vector-merge! > v (vector 9 7 5 3 1) (vector) 2 2 5)
            v))
      (test '#(#f #f  9  6  5  3  3  1  0 #f #f #f)
          (let ((v (make-vector 12 #f)))
            (vector-merge! > v (vector 9 7 5 3 1) (vector 9 6 3 0) 2 2 5)
            v))
      (test '#()
          (vector-merge > (vector) (vector) 0 0))
      (test '#(9 6 3 0)
          (vector-merge > (vector) (vector 9 6 3 0) 0 0))
      (test '#(5 3)
          (vector-merge > (vector 9 7 5 3 1) (vector) 2 4))
      (test '#(9 6 5 3 3 0)
          (vector-merge > (vector 9 7 5 3 1) (vector 9 6 3 0) 2 4))
      (test '#(#f #f #f #f #f #f #f #f #f #f #f #f)
          (let ((v (make-vector 12 #f)))
            (vector-merge! > v (vector) (vector) 2 0 0)
            v))
      (test '#(#f #f 9  6  3  0 #f #f #f #f #f #f)
          (let ((v (make-vector 12 #f)))
            (vector-merge! > v (vector) (vector 9 6 3 0) 2 0 0)
            v))
      (test '#(#f #f 5  3 #f #f #f #f #f #f #f #f)
          (let ((v (make-vector 12 #f)))
            (vector-merge! > v (vector 9 7 5 3 1) (vector) 2 2 4)
            v))
      (test '#(#f #f  9  6  5  3  3  0 #f #f #f #f)
          (let ((v (make-vector 12 #f)))
            (vector-merge! > v (vector 9 7 5 3 1) (vector 9 6 3 0) 2 2 4)
            v))
      (test '#()
          (vector-merge > (vector) (vector) 0 0 0))
      (test '#(9 6 3 0)
          (vector-merge > (vector) (vector 9 6 3 0) 0 0 0))
      (test '#(5 3)
          (vector-merge > (vector 9 7 5 3 1) (vector) 2 4 0))
      (test '#(9 6 5 3 3 0)
          (vector-merge > (vector 9 7 5 3 1) (vector 9 6 3 0) 2 4 0))
      (test '#(#f #f #f #f #f #f #f #f #f #f #f #f)
          (let ((v (make-vector 12 #f)))
            (vector-merge! > v (vector) (vector) 2 0 0 0)
            v))
      (test '#(#f #f  9  6  3  0 #f #f #f #f #f #f)
          (let ((v (make-vector 12 #f)))
            (vector-merge! > v (vector) (vector 9 6 3 0) 2 0 0 0)
            v))
      (test '#(#f #f  5  3 #f #f #f #f #f #f #f #f)
          (let ((v (make-vector 12 #f)))
            (vector-merge! > v (vector 9 7 5 3 1) (vector) 2 2 4 0)
            v))
      (test '#(#f #f  9  6  5  3  3  0 #f #f #f #f)
          (let ((v (make-vector 12 #f)))
            (vector-merge! > v (vector 9 7 5 3 1) (vector 9 6 3 0) 2 2 4 0)
            v))
      (test '#()
          (vector-merge > (vector) (vector) 0 0 0))
      (test '#(6 3 0)
          (vector-merge > (vector) (vector 9 6 3 0) 0 0 1))
      (test '#(5 3)
          (vector-merge > (vector 9 7 5 3 1) (vector) 2 4 0))
      (test '#(6 5 3 3 0)
          (vector-merge > (vector 9 7 5 3 1) (vector 9 6 3 0) 2 4 1))
      (test '#(#f #f #f #f #f #f #f #f #f #f #f #f)
          (let ((v (make-vector 12 #f)))
            (vector-merge! > v (vector) (vector) 2 0 0 0)
            v))
      (test '#(#f #f  6  3  0 #f #f #f #f #f #f #f)
          (let ((v (make-vector 12 #f)))
            (vector-merge! > v (vector) (vector 9 6 3 0) 2 0 0 1)
            v))
      (test '#(#f #f  5  3 #f #f #f #f #f #f #f #f)
          (let ((v (make-vector 12 #f)))
            (vector-merge! > v (vector 9 7 5 3 1) (vector) 2 2 4 0)
            v))
      (test '#(#f #f  6  5  3  3  0 #f #f #f #f #f)
          (let ((v (make-vector 12 #f)))
            (vector-merge! > v (vector 9 7 5 3 1) (vector 9 6 3 0) 2 2 4 1)
            v))
      (test '#()
          (vector-merge > (vector) (vector) 0 0 0 0))
      (test '#(6 3 0)
          (vector-merge > (vector) (vector 9 6 3 0) 0 0 1 4))
      (test '#(5 3)
          (vector-merge > (vector 9 7 5 3 1) (vector) 2 4 0 0))
      (test '#(6 5 3 3 0)
          (vector-merge > (vector 9 7 5 3 1) (vector 9 6 3 0) 2 4 1 4))
      (test '#(#f #f #f #f #f #f #f #f #f #f #f #f)
          (let ((v (make-vector 12 #f)))
            (vector-merge! > v (vector) (vector) 2 0 0 0 0)
            v))
      (test '#(#f #f  6  3  0 #f #f #f #f #f #f #f)
          (let ((v (make-vector 12 #f)))
            (vector-merge! > v (vector) (vector 9 6 3 0) 2 0 0 1 4)
            v))
      (test '#(#f #f  5  3 #f #f #f #f #f #f #f #f)
          (let ((v (make-vector 12 #f)))
            (vector-merge! > v (vector 9 7 5 3 1) (vector) 2 2 4 0 0)
            v))
      (test '#(#f #f  6  5  3  3  0 #f #f #f #f #f)
          (let ((v (make-vector 12 #f)))
            (vector-merge! > v (vector 9 7 5 3 1) (vector 9 6 3 0) 2 2 4 1 4)
            v))
      (test '#()
          (vector-merge > (vector) (vector) 0 0 0 0))
      (test '#(6)
          (vector-merge > (vector) (vector 9 6 3 0) 0 0 1 2))
      (test '#(5 3)
          (vector-merge > (vector 9 7 5 3 1) (vector) 2 4 0 0))
      (test '#(6 5 3)
          (vector-merge > (vector 9 7 5 3 1) (vector 9 6 3 0) 2 4 1 2))
      (test '#(#f #f #f #f #f #f #f #f #f #f #f #f)
          (let ((v (make-vector 12 #f)))
            (vector-merge! > v (vector) (vector) 2 0 0 0 0)
            v))
      (test '#(#f #f  6 #f #f #f #f #f #f #f #f #f)
          (let ((v (make-vector 12 #f)))
            (vector-merge! > v (vector) (vector 9 6 3 0) 2 0 0 1 2)
            v))
      (test '#(#f #f  5  3 #f #f #f #f #f #f #f #f)
          (let ((v (make-vector 12 #f)))
            (vector-merge! > v (vector 9 7 5 3 1) (vector) 2 2 4 0 0)
            v))
      (test '#(#f #f  6  5  3 #f #f #f #f #f #f #f)
          (let ((v (make-vector 12 #f)))
            (vector-merge! > v (vector 9 7 5 3 1) (vector 9 6 3 0) 2 2 4 1 2)
            v))
      (test '()
          (list-delete-neighbor-dups char=? (list)))
      (test '(#\a)
          (list-delete-neighbor-dups char=? (list #\a)))
      (test '(#\a #\b #\a)
          (list-delete-neighbor-dups char=? (list #\a #\a #\a #\b #\b #\a)))
      (test '()
          (list-delete-neighbor-dups! char=? (list)))
      (test '(#\a)
          (list-delete-neighbor-dups! char=? (list #\a)))
      (test '(#\a #\b #\a)
          (list-delete-neighbor-dups! char=? (list #\a #\a #\a #\b #\b #\a)))
      (test '#()
          (let ((v (vector)))
            (vector-delete-neighbor-dups char=? v)))
      (test '#(#\a)
          (let ((v (vector #\a)))
            (vector-delete-neighbor-dups char=? v)))
      (test '#(#\a #\b #\a)
          (let ((v (vector #\a #\a #\a #\b #\b #\a)))
            (vector-delete-neighbor-dups char=? v)))
      (test '(0 #())
          (let ((v (vector)))
            (list (vector-delete-neighbor-dups! char=? v) v)))
      (test '(1 #(#\a))
          (let ((v (vector #\a)))
            (list (vector-delete-neighbor-dups! char=? v) v)))
      (test '(3 #(#\a #\b #\a #\b #\b #\a))
          (let ((v (vector #\a #\a #\a #\b #\b #\a)))
            (list (vector-delete-neighbor-dups! char=? v) v)))
      (test '#()
          (let ((v (vector)))
            (vector-delete-neighbor-dups char=? v 0)))
      (test '#(#\a)
          (let ((v (vector #\a)))
            (vector-delete-neighbor-dups char=? v 0)))
      (test '#(#\a #\b #\a)
          (let ((v (vector #\a #\a #\a #\b #\b #\a)))
            (vector-delete-neighbor-dups char=? v 0)))
      (test '(0 #())
          (let ((v (vector)))
            (list (vector-delete-neighbor-dups! char=? v 0) v)))
      (test '(1 #(#\a))
          (let ((v (vector #\a)))
            (list (vector-delete-neighbor-dups! char=? v 0) v)))
      (test '(3 #(#\a #\b #\a #\b #\b #\a))
          (let ((v (vector #\a #\a #\a #\b #\b #\a)))
            (list (vector-delete-neighbor-dups! char=? v 0) v)))
      (test '#()
          (let ((v (vector)))
            (vector-delete-neighbor-dups char=? v 0)))
      (test '#()
          (let ((v (vector #\a)))
            (vector-delete-neighbor-dups char=? v 1)))
      (test '#(#\b #\a)
          (let ((v (vector #\a #\a #\a #\b #\b #\a)))
            (vector-delete-neighbor-dups char=? v 3)))
      (test '(0 #())
          (let ((v (vector)))
            (list (vector-delete-neighbor-dups! char=? v 0) v)))
      (test '(1 #(#\a))
          (let ((v (vector #\a)))
            (list (vector-delete-neighbor-dups! char=? v 1) v)))
      (test '(5 #(#\a #\a #\a #\b #\a #\a))
          (let ((v (vector #\a #\a #\a #\b #\b #\a)))
            (list (vector-delete-neighbor-dups! char=? v 3) v)))
      (test '#()
          (let ((v (vector)))
            (vector-delete-neighbor-dups char=? v 0 0)))
      (test '#()
          (let ((v (vector #\a)))
            (vector-delete-neighbor-dups char=? v 1 1)))
      (test '#(#\b)
          (let ((v (vector #\a #\a #\a #\b #\b #\a)))
            (vector-delete-neighbor-dups char=? v 3 5)))
      (test '(0 #())
          (let ((v (vector)))
            (list (vector-delete-neighbor-dups! char=? v 0 0) v)))
      (test '(1 #(#\a))
          (let ((v (vector #\a)))
            (list (vector-delete-neighbor-dups! char=? v 0 1) v)))
      (test '(1 #(#\a))
          (let ((v (vector #\a)))
            (list (vector-delete-neighbor-dups! char=? v 1 1) v)))
      (test '(4 #(#\a #\a #\a #\b #\b #\a))
          (let ((v (vector #\a #\a #\a #\b #\b #\a)))
            (list (vector-delete-neighbor-dups! char=? v 3 5) v)))
      (let ((v (vector 0 0 0 1 1 2 2 3 3 4 4 5 5 6 6)))
        (test '(9 . #(0 0 0 1 2 3 4 5 6 4 4 5 5 6 6))
            (cons (vector-delete-neighbor-dups! = v 3) v)))
      (test "knil" (vector-find-median < (vector) "knil"))
      (test 17 (vector-find-median < (vector 17) "knil"))
      (test 12 (vector-find-median < (vector 18 1 12 14 12 5 18 2) "knil"))
      (test 23/2 (vector-find-median < (vector 18 1 11 14 12 5 18 2) "knil"))
      (test (list 12 12)
          (vector-find-median < (vector 18 1 12 14 12 5 18 2) "knil" list))
      (test (list 11 12)
          (vector-find-median < (vector 18 1 11 14 12 5 18 2) "knil" list))
      (test 7 (vector-find-median < (vector 7 6 9 3 1 18 15 7 8) "knil"))
      (test 7 (vector-find-median < (vector 7 6 9 3 1 18 15 7 8) "knil" list))
      (test 19
          (let ((v (vector 19)))
            (vector-select! < v 0)))
      (test 3
          (let ((v (vector 8 22 19 19 13 9 21 13 3 23)))
            (vector-select! < v 0)))
      (test 9
          (let ((v (vector 8 22 19 19 13 9 21 13 3 23)))
            (vector-select! < v 2)))
      (test 22
          (let ((v (vector 8 22 19 19 13 9 21 13 3 23)))
            (vector-select! < v 8)))
      (test 23
          (let ((v (vector 8 22 19 19 13 9 21 13 3 23)))
            (vector-select! < v 9)))
      (test 19
          (let ((v (vector 19)))
            (vector-select! < v 0 0)))
      (test 3
          (let ((v (vector 8 22 19 19 13 9 21 13 3 23)))
            (vector-select! < v 0 0)))
      (test 9
          (let ((v (vector 8 22 19 19 13 9 21 13 3 23)))
            (vector-select! < v 2 0)))
      (test 22
          (let ((v (vector 8 22 19 19 13 9 21 13 3 23)))
            (vector-select! < v 8 0)))
      (test 23
          (let ((v (vector 8 22 19 19 13 9 21 13 3 23)))
            (vector-select! < v 9 0)))
      (test 19
          (let ((v (vector 19)))
            (vector-select! < v 0 0 1)))
      (test 3
          (let ((v (vector 8 22 19 19 13 9 21 13 3 23)))
            (vector-select! < v 0 0 10)))
      (test 9
          (let ((v (vector 8 22 19 19 13 9 21 13 3 23)))
            (vector-select! < v 2 0 10)))
      (test 22
          (let ((v (vector 8 22 19 19 13 9 21 13 3 23)))
            (vector-select! < v 8 0 10)))
      (test 23
          (let ((v (vector 8 22 19 19 13 9 21 13 3 23)))
            (vector-select! < v 9 0 10)))
      (test 3
          (let ((v (vector 8 22 19 19 13 9 21 13 3 23)))
            (vector-select! < v 0 4 10)))
      (test 13
          (let ((v (vector 8 22 19 19 13 9 21 13 3 23)))
            (vector-select! < v 2 4 10)))
      (test 21
          (let ((v (vector 8 22 19 19 13 9 21 13 3 23)))
            (vector-select! < v 4 4 10)))
      (test 23
          (let ((v (vector 8 22 19 19 13 9 21 13 3 23)))
            (vector-select! < v 5 4 10)))
      (test 3
          (let ((v (vector 8 22 19 19 13 9 21 13 3 23)))
            (vector-select! < v 0 4 10)))
      (test 13
          (let ((v (vector 8 22 19 19 13 9 21 13 3 23)))
            (vector-select! < v 2 4 10)))
      (test 13
          (let ((v (vector 8 22 19 19 13 9 21 13 3 23)))
            (vector-select! < v 3 4 10)))
      (test 21
          (let ((v (vector 8 22 19 19 13 9 21 13 3 23)))
            (vector-select! < v 4 4 10)))
      (test 23
          (let ((v (vector 8 22 19 19 13 9 21 13 3 23)))
            (vector-select! < v 5 4 10)))
      (test 9
          (let ((v (vector 8 22 19 19 13 9 21 13 3 23)))
            (vector-select! < v 0 4 8)))
      (test 13
          (let ((v (vector 8 22 19 19 13 9 21 13 3 23)))
            (vector-select! < v 1 4 8)))
      (test 13
          (let ((v (vector 8 22 19 19 13 9 21 13 3 23)))
            (vector-select! < v 2 4 8)))
      (test 21
          (let ((v (vector 8 22 19 19 13 9 21 13 3 23)))
            (vector-select! < v 3 4 8)))
      (test 17.0
          (vector-find-median < '#(18. 11. 20. 15. 16. 9. 24. 15. 21. 20.) 0))
      (test-end))))

(define-record-type List-Queue
  (make-queue list last)
  list-queue?
  (list list-queue-list list-queue-list-set!)
  (last list-queue-last list-queue-last-set!))

(define (make-list-queue ls . o)
  (make-queue ls (if (pair? o) (car o) (if (pair? ls) (last-pair ls) '()))))

(define (list-queue . ls)
  (make-list-queue ls))

(define (list-queue-copy list-queue)
  (make-list-queue (list-copy (list-queue-list list-queue))))

(define (list-queue-unfold stop? mapper successor seed . o)
  (let ((ls (unfold stop? mapper successor seed)))
    (if (pair? o)
        (let ((queue (car o)))
          (list-queue-set-list! queue (append ls (list-queue-list queue)))
          queue)
        (make-list-queue ls))))

(define (list-queue-unfold-right stop? mapper successor seed . o)
  (let ((ls (unfold-right stop? mapper successor seed)))
    (if (pair? o)
        (let ((queue (car o)))
          (list-queue-set-list! queue (append (list-queue-list queue) ls))
          queue)
        (make-list-queue ls))))

(define (list-queue-empty? list-queue)
  (null? (list-queue-list list-queue)))

(define (list-queue-front list-queue)
  (car (list-queue-list list-queue)))

(define (list-queue-back list-queue)
  (car (list-queue-last list-queue)))

(define (list-queue-first-last list-queue)
  (values (list-queue-list list-queue) (list-queue-last list-queue)))

(define (list-queue-add-front! list-queue element)
  (list-queue-list-set! list-queue (cons element (list-queue-list list-queue)))
  (if (null? (list-queue-last list-queue))
      (list-queue-last-set! list-queue (list-queue-list list-queue))))

(define (list-queue-add-back! list-queue element)
  (let ((last (list-queue-last list-queue)))
    (cond
     ((pair? last)
      (set-cdr! last (list element))
      (list-queue-last-set! list-queue (cdr last)))
     (else
      (list-queue-list-set! list-queue (list element))
      (list-queue-last-set! list-queue (list-queue-list list-queue))))))

(define (list-queue-remove-front! list-queue)
  (let ((ls (list-queue-list list-queue)))
    (list-queue-list-set! list-queue (cdr ls))
    (if (null? (cdr ls))
        (list-queue-last-set! list-queue '()))
    (car ls)))

(define (list-queue-remove-back! list-queue)
  (let ((ls (list-queue-list list-queue)))
    (if (null? (cdr ls))
        (car (list-queue-remove-all! list-queue))
        (let lp ((head ls) (tail (cdr ls)))
          (cond
           ((null? (cdr tail))
            (set-cdr! head '())
            (car tail))
           (else
            (lp tail (cdr tail))))))))

(define (list-queue-remove-all! list-queue)
  (let ((res (list-queue-list list-queue)))
    (list-queue-list-set! list-queue '())
    (list-queue-last-set! list-queue '())
    res))

(define (list-queue-set-list! list-queue list . o)
  (list-queue-list-set! list-queue list)
  (list-queue-last-set! list-queue (if (pair? o) (car o) (last-pair list))))

(define (list-queue-concatenate list-of-queues)
  (make-list-queue (list-copy (append-map list-queue-list list-of-queues))))

(define (list-queue-append . list-of-queues)
  (list-queue-concatenate list-of-queues))

(define (list-queue-append! . list-of-queues)
  (make-list-queue (append-map list-queue-list list-of-queues)))

(define (list-queue-map proc list-queue)
  (make-list-queue (map proc (list-queue-list list-queue))))

(define (list-queue-map! proc list-queue)
  (list-queue-set-list! list-queue (map! proc (list-queue-list list-queue)))
  list-queue)

(define (list-queue-for-each proc list-queue)
  (for-each proc (list-queue-list list-queue)))
(define-library (srfi 117 test)
  (import (scheme base) (srfi 117) (chibi test))
  (export run-tests)
  (begin
    (define (run-tests)
      (test-begin "srfi-117: list-queues")

      (test-group "list-queues/simple"
        (define x (list-queue 1 2 3))
        (define x1 (list 1 2 3))
        (define x2 (make-list-queue x1 (cddr x1)))
        (define y (list-queue 4 5))
        (define z (list-queue-append x y))
        (define z2 (list-queue-append! x (list-queue-copy y)))
        (test '(1 1 1) (list-queue-list (make-list-queue '(1 1 1))))
        (test '(1 2 3) (list-queue-list x))
        (test 3 (list-queue-back x2))
        (test-assert (list-queue? y))
        (test '(1 2 3 4 5) (list-queue-list z))
        (test '(1 2 3 4 5) (list-queue-list z2))
        (test 1 (list-queue-front z))
        (test 5 (list-queue-back z))
        (list-queue-remove-front! y)
        (test '(5) (list-queue-list y))
        (list-queue-remove-back! y)
        (test-assert (list-queue-empty? y))
        (test-error (list-queue-remove-front! y))
        (test-error (list-queue-remove-back! y))
        (test '(1 2 3 4 5) (list-queue-list z))
        (test '(1 2 3 4 5) (list-queue-remove-all! z2))
        (test-assert (list-queue-empty? z2))
        (list-queue-remove-all! z)
        (list-queue-add-front! z 1)
        (list-queue-add-front! z 0)
        (list-queue-add-back! z 2)
        (list-queue-add-back! z 3)
        (test '(0 1 2 3) (list-queue-list z)))

      (test-group "list-queues/whole"
        (define a (list-queue 1 2 3))
        (define b (list-queue-copy a))
        (test '(1 2 3) (list-queue-list b))
        (list-queue-add-front! b 0)
        (test '(1 2 3) (list-queue-list a))
        (test 4 (length (list-queue-list b)))
        (test '(1 2 3 0 1 2 3)
            (list-queue-list (list-queue-concatenate (list a b)))))

      (test-group "list-queues/map"
        (define r (list-queue 1 2 3))
        (define s (list-queue-map (lambda (x) (* x 10)) r))
        (define sum 0)
        (test '(10 20 30) (list-queue-list s))
        (list-queue-map! (lambda (x) (+ x 1)) r)
        (test '(2 3 4) (list-queue-list r))
        (list-queue-for-each (lambda (x) (set! sum (+ sum x))) s)
        (test 60 sum))

      (test-group "list-queues/conversion"
        (define n (list-queue 5 6))
        (define d (list 1 2 3))
        (define e (cddr d))
        (define f (make-list-queue d e))
        (define g (make-list-queue d e))
        (define h (list-queue 5 6))
        (define-values (dx ex) (list-queue-first-last f))
        (list-queue-set-list! n (list 1 2))
        (test '(1 2) (list-queue-list n))
        (test-assert (eq? d dx))
        (test-assert (eq? e ex))
        (test '(1 2 3) (list-queue-list f))
        (list-queue-add-front! f 0)
        (list-queue-add-back! f 4)
        (test '(0 1 2 3 4) (list-queue-list f))
        (test '(1 2 3 4) (list-queue-list g))
        (list-queue-set-list! h d e)
        (test '(1 2 3 4) (list-queue-list h)))

      (test-group "list-queues/unfold"
        (define (double x) (* x 2))
        (define (done? x) (> x 3))
        (define (add1 x) (+ x 1))
        (define x (list-queue-unfold done? double add1 0))
        (define y (list-queue-unfold-right done? double add1 0))
        (define x0 (list-queue 8))
        (define x1 (list-queue-unfold done? double add1 0 x0))
        (define y0 (list-queue 8))
        (define y1 (list-queue-unfold-right done? double add1 0 y0))
        (test '(0 2 4 6) (list-queue-list x))
        (test '(6 4 2 0) (list-queue-list y))
        (test '(0 2 4 6 8) (list-queue-list x1))
        (test '(8 6 4 2 0) (list-queue-list y1)))

      (test-end))))

(define-library (srfi 159 unicode)
  (import (scheme base)
          (scheme char)
          (chibi show base)
          (srfi 130)
          (srfi 151))
  (export (rename terminal-aware as-unicode))
  (include "../166/width.scm" "../166/unicode.scm"))

(define-library (srfi 159 color)
  (import (scheme base) (srfi 159 base))
  (export as-red as-blue as-green as-cyan as-yellow
          as-magenta as-white as-black
          as-bold as-underline)
  (include "../166/color.scm"))
;; base.scm - base formatting monad
;; Copyright (c) 2013 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

;;> The minimal base formatting combinators and show interface.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;> The environment monad with some pre-defined fields for combinator
;;> formatting.

(define-environment-monad Show-Env
  (sequence: sequence)
  (bind: %fn)
  (bind-fork: forked)
  (local: %with)
  (local!: with!)
  (return: return)
  (run: run)
  (fields:
   (port env-port env-port-set!)
   (row env-row env-row-set!)
   (col env-col env-col-set!)
   (width env-width env-width-set!)
   (radix env-radix env-radix-set!)
   (precision env-precision env-precision-set!)
   (pad-char env-pad-char env-pad-char-set!)
   (decimal-sep env-decimal-sep env-decimal-sep-set!)
   (decimal-align env-decimal-align env-decimal-align-set!)
   (string-width env-string-width env-string-width-set!)
   (ellipsis env-ellipsis env-ellipsis-set!)
   (writer env-writer env-writer-set!)
   (output env-output env-output-set!)))

(define-syntax fn
  (syntax-rules ()
    ((fn vars expr ... fmt)
     (%fn vars expr ... (displayed fmt)))))

;; The base formatting handles outputting raw strings and a simple,
;; configurable handler for formatting objects.

;; Utility - default value of string-width.
(define (substring-length str . o)
  (let ((start (if (pair? o) (car o) 0))
        (end (if (and (pair? o) (pair? (cdr o))) (cadr o) (string-length str))))
    (- end start)))

(define (call-with-output-string proc)
  (let ((out (open-output-string)))
    (proc out)
    (let ((res (get-output-string out)))
      (close-output-port out)
      res)))

;; Raw output.  All primitive output should go through this operation.
;; Overridable, defaulting to output-default.
(define (output str)
  (fn (output) ((or output output-default) str)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;> \procedure{(show out [args ...])}
;;>
;;> Run the combinators \var{args}, accumulating the output to
;;> \var{out}, which is either an output port or a boolean, with
;;> \scheme{#t} indicating \scheme{current-output-port} and
;;> \scheme{#f} to collect the output as a string.
(define (show out . args)
  (let ((proc (each-in-list args)))
    (cond
     ((output-port? out)
      (show-run out proc))
     ((eq? #t out)
      (show-run (current-output-port) proc))
     ((eq? #f out)
      (let ((out (open-output-string)))
        (show-run out proc) 
        (get-output-string out)))
     (else
      (error "unknown output to show" out)))))

;; Run with an output port with initial default values.
(define (show-run out proc)
  (run (sequence (with! (port out)
                        (col 0)
                        (row 0)
                        (width 78)
                        (radix 10)
                        (pad-char #\space)
                        (output output-default)
                        (string-width substring-length))
                 proc)))

;;> Temporarily bind the parameters in the body \var{x}.

(define-syntax with
  (syntax-rules ()
    ((with params x ... y)
     (%with params (each x ... y)))))

;;> The noop formatter.  Generates no output and leaves the state
;;> unmodified.
(define nothing (fn () (with!)))

;;> Formats a displayed version of x - if a string or char, outputs the
;;> raw characters (as with `display'), if x is already a formatter
;;> defers to that, otherwise outputs a written version of x.
(define (displayed x)
  (cond
   ((procedure? x) x)
   ((string? x) (output x))
   ((char? x) (output (string x)))
   (else (written x))))

;;> Formats a written version of x, as with `write'.  The formatting
;;> can be updated with the \scheme{'writer} field.
(define (written x)
  (fn (writer) ((or writer written-default) x)))

;;> Takes a single list of formatters, combined in sequence with
;;> \scheme{each}.
(define (each-in-list args)
  (if (pair? args)
      (sequence (displayed (car args)) (each-in-list (cdr args)))
      nothing))

;;> Combines each of the formatters in a sequence using
;;> \scheme{displayed}, so that strings and chars will be output
;;> directly and other objects will be \scheme{written}.
(define (each . args)
  (each-in-list args))

;;> Raw output - displays str to the formatter output port and updates
;;> row and col.
(define (output-default str)
  (fn (port (r row) (c col) string-width)
    (let ((nl-index (string-index-right str #\newline)))
      (write-string str port)
      (if (string-cursor>? nl-index (string-cursor-start str))
          (with! (row (+ r (string-count str (lambda (ch) (eqv? ch #\newline)))))
                 (col (string-width str (string-cursor->index str nl-index))))
          (with! (col (+ c (string-width str))))))))

;;> Captures the output of \var{producer} and formats the result with
;;> \var{consumer}.
(define (call-with-output producer consumer)
  (let ((out (open-output-string)))
    (forked (with ((port out) (output output-default)) producer)
            (fn () (consumer (get-output-string out))))))

(define-library (srfi 159 base)
  (export
   show displayed written written-shared written-simply
   escaped maybe-escaped
   numeric numeric/comma numeric/si numeric/fitted
   nl fl space-to tab-to nothing each each-in-list
   joined joined/prefix joined/suffix joined/last joined/dot
   joined/range padded padded/right padded/both
   trimmed trimmed/right trimmed/both trimmed/lazy
   fitted fitted/right fitted/both output-default
   fn with with! forked call-with-output)
  (import (scheme base) (scheme write) (scheme complex) (scheme inexact)
          (srfi 1) (srfi 69) (srfi 130) (chibi monad environment)
          (chibi show shared))
  (cond-expand
   (chibi
    (import (only (chibi) let-optionals*)))
   (else
    (begin
      (define-syntax let-optionals*
        (syntax-rules ()
          ((let-optionals* opt-ls () . body)
           (begin . body))
          ((let-optionals* (op . args) vars . body)
           (let ((tmp (op . args)))
             (let-optionals* tmp vars . body)))
          ((let-optionals* tmp ((var default) . rest) . body)
           (let ((var (if (pair? tmp) (car tmp) default))
                 (tmp2 (if (pair? tmp) (cdr tmp) '())))
             (let-optionals* tmp2 rest . body)))
          ((let-optionals* tmp tail . body)
           (let ((tail tmp)) . body)))))))
  (include "base.scm")
  (include "../166/show.scm")
  (include "../166/write.scm"))

(define-library (srfi 159 columnar)
  (import (scheme base) (scheme char) (scheme file) (scheme write)
          (srfi 1) (srfi 117) (srfi 130) (srfi 159 base)
          (chibi optional))
  (export
   call-with-output-generator call-with-output-generators
   string->line-generator
   tabular columnar show-columns wrapped wrapped/list wrapped/char
   justified line-numbers from-file)
  (include "../166/column.scm"))
(define-library (srfi 143)
  (import (scheme base)
          (srfi 141)
          (rename (srfi 151)
                  (bitwise-not fxnot)
                  (bitwise-and fxand)
                  (bitwise-ior fxior)
                  (bitwise-xor fxxor)
                  (arithmetic-shift fxarithmetic-shift)
                  (arithmetic-shift-left fxarithmetic-shift)
                  (bit-count fxbit-count)
                  (integer-length fxlength)
                  (bitwise-if fxif)
                  (copy-bit fxcopy-bit)
                  (first-set-bit fxfirst-set-bit)
                  (bit-field fxbit-field)
                  (bit-field-rotate fxbit-field-rotate)
                  (bit-field-reverse fxbit-field-reverse))
          (only (chibi) fixnum?))
  (export
   fx-width fx-greatest fx-least fixnum?
   fx=? fx<? fx>? fx<=? fx>=?
   fxzero? fxpositive? fxnegative? fxodd? fxeven? fxmax fxmin
   fx+ fx- fxneg fx* fxabs fxsquare fxsqrt
   fxquotient fxremainder
   fx+/carry fx-/carry fx*/carry
   fxnot fxand fxior fxxor
   fxarithmetic-shift fxarithmetic-shift-left
   fxarithmetic-shift-right
   fxbit-count fxlength
   fxbit-field fxbit-field-rotate fxbit-field-reverse
   fxif fxbit-set? fxcopy-bit fxfirst-set-bit)
  (include "143/fixnum.scm"))
(define-library (srfi 130 test)
  (export run-tests)
  (import (scheme base) (scheme char)
          (chibi char-set) (chibi char-set full) (chibi test)
          (srfi 130))
  (begin
    (define (sc str c)
      (string-index->cursor str c))
    (define (string-index->index str pred . o)
      (string-cursor->index str (apply string-index str pred o)))
    (define (string-index-right->index str pred . o)
      (string-cursor->index str (apply string-index-right str pred o)))
    (define char-set:not-letter (char-set-complement char-set:letter))
    (define (run-tests)
      (test-begin "srfi-130: cursor-based string library")

      ;; tests adapted from Gauche's SRFI 13 tests, via Chicken

      (test "string-null?" #f (string-null? "abc"))
      (test "string-null?" #t (string-null? ""))
      (test "string-every" #t (string-every #\a ""))
      (test "string-every" #t (string-every #\a "aaaa"))
      (test "string-every" #f (string-every #\a "aaba"))
      (test "string-every" #t (string-every char-set:lower-case "aaba"))
      (test "string-every" #f (string-every char-set:lower-case "aAba"))
      (test "string-every" #t (string-every char-set:lower-case ""))
      (test "string-every" #t (string-every (lambda (x) (char->integer x)) "aAbA"))
      (test "string-every" #t (string-every (lambda (x) (error "hoge")) ""))
      (test "string-any" #t (string-any #\a "aaaa"))
      (test "string-any" #f (string-any #\a "Abcd"))
      (test "string-any" #f (string-any #\a ""))
      (test "string-any" #t (string-any char-set:lower-case "ABcD"))
      (test "string-any" #f (string-any char-set:lower-case "ABCD"))
      (test "string-any" #f (string-any char-set:lower-case ""))
      (test "string-any" (char->integer #\a)
        (string-any (lambda (x) (char->integer x)) "aAbA"))

      (test "string-tabulate" "0123456789"
        (string-tabulate (lambda (code)
                           (integer->char (+ code (char->integer #\0))))
                         10))
      (test "string-tabulate" ""
        (string-tabulate (lambda (code)
                           (integer->char (+ code (char->integer #\0))))
                         0))

      (test "reverse-list->string" "cBa"
        (reverse-list->string '(#\a #\B #\c)))
      (test "reverse-list->string" ""
        (reverse-list->string '()))

      (test "substring/cursors" "cde" (substring/cursors "abcde" 2 5))
      (test "substring/cursors" "cd"  (substring/cursors "abcde" 2 4))

      (test "string-copy!" "abCDEfg"
        (let ((x (string-copy "abcdefg")))
          (string-copy! x 2 "CDE")
          x))
      (test "string-copy!" "abCDEfg"
        (let ((x (string-copy "abcdefg")))
          (string-copy! x 2 "ZABCDE" 3)
          x))
      (test "string-copy!" "abCDEfg"
        (let ((x (string-copy "abcdefg")))
          (string-copy! x 2 "ZABCDEFG" 3 6)
          x))

      (test "string-take" "Pete S"  (string-take "Pete Szilagyi" 6))
      (test "string-take" ""        (string-take "Pete Szilagyi" 0))
      (test "string-take" "Pete Szilagyi" (string-take "Pete Szilagyi" 13))
      (test "string-drop" "zilagyi" (string-drop "Pete Szilagyi" 6))
      (test "string-drop" "Pete Szilagyi" (string-drop "Pete Szilagyi" 0))
      (test "string-drop" ""        (string-drop "Pete Szilagyi" 13))

      (test "string-take-right" "rules" (string-take-right "Beta rules" 5))
      (test "string-take-right" ""      (string-take-right "Beta rules" 0))
      (test "string-take-right" "Beta rules" (string-take-right "Beta rules" 10))
      (test "string-drop-right" "Beta " (string-drop-right "Beta rules" 5))
      (test "string-drop-right" "Beta rules" (string-drop-right "Beta rules" 0))
      (test "string-drop-right" ""      (string-drop-right "Beta rules" 10))

      (test "string-pad" "  325" (string-pad "325" 5))
      (test "string-pad" "71325" (string-pad "71325" 5))
      (test "string-pad" "71325" (string-pad "8871325" 5))
      (test "string-pad" "~~325" (string-pad "325" 5 #\~))
      (test "string-pad" "~~~25" (string-pad "325" 5 #\~ 1))
      (test "string-pad" "~~~~2" (string-pad "325" 5 #\~ 1 2))
      (test "string-pad-right" "325  " (string-pad-right "325" 5))
      (test "string-pad-right" "71325" (string-pad-right "71325" 5))
      (test "string-pad-right" "88713" (string-pad-right "8871325" 5))
      (test "string-pad-right" "325~~" (string-pad-right "325" 5 #\~))
      (test "string-pad-right" "25~~~" (string-pad-right "325" 5 #\~ 1))
      (test "string-pad-right" "2~~~~" (string-pad-right "325" 5 #\~ 1 2))

      (test "string-trim"  "a b c d  \n"
        (string-trim "  \t  a b c d  \n"))
      (test "string-trim"  "\t  a b c d  \n"
        (string-trim "  \t  a b c d  \n" #\space))
      (test "string-trim"  "a b c d  \n"
        (string-trim "4358948a b c d  \n" char-numeric?))

      (test "string-trim-right"  "  \t  a b c d"
        (string-trim-right "  \t  a b c d  \n"))
      (test "string-trim-right"  "  \t  a b c d  "
        (string-trim-right "  \t  a b c d  \n" (lambda (ch) (eqv? ch #\newline))))
      (test "string-trim-right"  "349853a b c d"
        (string-trim-right "349853a b c d03490" char-numeric?))

      (test "string-trim-both"  "a b c d"
        (string-trim-both "  \t  a b c d  \n"))
      (test "string-trim-both"  "  \t  a b c d  "
        (string-trim-both "  \t  a b c d  \n" (lambda (ch) (eqv? ch #\newline))))
      (test "string-trim-both"  "a b c d"
        (string-trim-both "349853a b c d03490" char-numeric?))

      ;; TODO: bunch of string= families

      (test "string-prefix-length" 5
        (string-prefix-length "cancaNCAM" "cancancan"))
      (test "string-suffix-length" 2
        (string-suffix-length "CanCan" "cankancan"))

      (test "string-prefix?" #t (string-prefix? "abcd" "abcdefg"))
      (test "string-prefix?" #f (string-prefix? "abcf" "abcdefg"))
      (test "string-suffix?" #t (string-suffix? "defg" "abcdefg"))
      (test "string-suffix?" #f (string-suffix? "aefg" "abcdefg"))

      (test "string-index #1" 4
        (string-index->index "abcd:efgh:ijkl" (lambda (ch) (eqv? ch #\:))))
      (test "string-index #2" 4
        (string-index->index "abcd:efgh;ijkl" (lambda (ch) (char-set-contains? char-set:not-letter ch))))
      (test "string-index #3" 14
        (string-index->index "abcd:efgh;ijkl" (lambda (ch) (char-set-contains? char-set:digit ch))))
      (test "string-index #4" 9
        (string-index->index "abcd:efgh:ijkl" (lambda (ch) (eqv? ch #\:)) 5))
      (test "string-index-right #1" 5
        (string-index-right->index "abcd:efgh;ijkl" (lambda (ch) (eqv? ch #\:))))
      (test "string-index-right #2" 10
        (string-index-right->index "abcd:efgh;ijkl" (lambda (ch) (char-set-contains? char-set:not-letter ch))))
      (test "string-index-right #3" 14
        (string-index-right->index "abcd:efgh;ijkl" char-alphabetic?))
      (test "string-index-right #4" 10
        (string-index-right->index "abcd:efgh;ijkl" (lambda (ch) (char-set-contains? char-set:not-letter ch)) 7))

      (test "string-count #1" 2
        (string-count "abc def\tghi jkl" (lambda (ch) (eqv? ch #\space))))
      (test "string-count #2" 3
        (string-count "abc def\tghi jkl" char-whitespace?))
      (test "string-count #3" 2
        (string-count "abc def\tghi jkl" char-whitespace? 4))
      (test "string-count #4" 1
        (string-count "abc def\tghi jkl" char-whitespace? 4 9))
      (let ((s "Ma mere l'oye"))
        (test-assert "string-contains"
          (string-contains s "mer"))
        (test "string-contains" #f
          (string-contains s "Mer"))
        (test-assert "string-contains"
          (string-contains s "mer" 1))
        (test-assert "string-contains"
          (string-contains s "mer" 1 8))
        (test-not "string-contains"
                  (string-contains s "mer" 4 8))
        (test-not "string-contains"
                  (string-contains s "mer" 1 5)))
      (let ((s "eek -- it's a geek."))
        (test 15 (string-cursor->index s (string-contains-right s "ee")))
        (test 15 (string-cursor->index s (string-contains-right s "ee" 12 18)))
        (test 19 (string-cursor->index s (string-contains-right s "")))
        (test 0 (string-cursor->index "" (string-contains-right "" "")))
        (test #f (string-contains-right s "kee" 12 18)))

      (test "string-reverse" "nomel on nolem on"
        (string-reverse "no melon no lemon"))
      (test "string-reverse" "nomel on"
        (string-reverse "no melon no lemon" 9))
      (test "string-reverse" "on"
        (string-reverse "no melon no lemon" 9 11))

      (test "string-append" #f
        (let ((s "test")) (eq? s (string-append s))))
      (test "string-concatenate" #f
        (let ((s "test")) (eq? s (string-concatenate (list s)))))
      (test "string-concatenate" "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
        (string-concatenate
         '("A" "B" "C" "D" "E" "F" "G" "H"
           "I" "J" "K" "L" "M" "N" "O" "P"
           "Q" "R" "S" "T" "U" "V" "W" "X" "Y" "Z"
           "a" "b" "c" "d" "e" "f" "g" "h"
           "i" "j" "k" "l" "m" "n" "o" "p"
           "q" "r" "s" "t" "u" "v" "w" "x" "y" "z")))
      (test "string-concatenate-reverse" "zyxwvutsrqponmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA"
        (string-concatenate-reverse
         '("A" "B" "C" "D" "E" "F" "G" "H"
           "I" "J" "K" "L" "M" "N" "O" "P"
           "Q" "R" "S" "T" "U" "V" "W" "X" "Y" "Z"
           "a" "b" "c" "d" "e" "f" "g" "h"
           "i" "j" "k" "l" "m" "n" "o" "p"
           "q" "r" "s" "t" "u" "v" "w" "x" "y" "z")))
      (test "string-concatenate-reverse" #f
        (let ((s "test"))
          (eq? s (string-concatenate-reverse (list s)))))

      (test "string-map" "svool"
        (string-map (lambda (c)
                      (integer->char (- 219 (char->integer c))))
                    "hello"))
      ;; (test "string-map" "vool"
      ;;   (string-map (lambda (c)
      ;;                 (integer->char (- 219 (char->integer c))))
      ;;               "hello" 1))
      ;; (test "string-map" "vo"
      ;;   (string-map (lambda (c)
      ;;                 (integer->char (- 219 (char->integer c))))
      ;;               "hello" 1 3))

      (test "string-fold" '(#\o #\l #\l #\e #\h . #t)
        (string-fold cons #t "hello"))
      (test "string-fold" '(#\l #\e . #t)
        (string-fold cons #t "hello" 1 3))
      (test "string-fold-right" '(#\h #\e #\l #\l #\o . #t)
        (string-fold-right cons #t "hello"))
      (test "string-fold-right" '(#\e #\l . #t)
        (string-fold-right cons #t "hello" 1 3))

      (test "string-unfold" "hello"
        (string-unfold null? car cdr '(#\h #\e #\l #\l #\o)))
      (test "string-unfold" "hi hello"
        (string-unfold null? car cdr '(#\h #\e #\l #\l #\o) "hi "))
      (test "string-unfold" "hi hello ho"
        (string-unfold null? car cdr
                       '(#\h #\e #\l #\l #\o) "hi "
                       (lambda (x) " ho")))

      (test "string-unfold-right" "olleh"
        (string-unfold-right null? car cdr '(#\h #\e #\l #\l #\o)))
      (test "string-unfold-right" "olleh hi"
        (string-unfold-right null? car cdr '(#\h #\e #\l #\l #\o) " hi"))
      (test "string-unfold-right" "ho olleh hi"
        (string-unfold-right null? car cdr
                             '(#\h #\e #\l #\l #\o) " hi"
                             (lambda (x) "ho ")))

      (test "string-for-each" "CLtL"
        (let ((out (open-output-string))
              (prev #f))
          (string-for-each (lambda (c)
                             (if (or (not prev)
                                     (char-whitespace? prev))
                                 (write-char c out))
                             (set! prev c))
                           "Common Lisp, the Language")

          (get-output-string out)))
      ;; (test "string-for-each" "oLtL"
      ;;   (let ((out (open-output-string))
      ;;         (prev #f))
      ;;     (string-for-each (lambda (c)
      ;;                        (if (or (not prev)
      ;;                                (char-whitespace? prev))
      ;;                            (write-char c out))
      ;;                        (set! prev c))
      ;;                      "Common Lisp, the Language" 1)
      ;;     (get-output-string out)))
      ;; (test "string-for-each" "oL"
      ;;   (let ((out (open-output-string))
      ;;         (prev #f))
      ;;     (string-for-each (lambda (c)
      ;;                        (if (or (not prev)
      ;;                                (char-whitespace? prev))
      ;;                            (write-char c out))
      ;;                        (set! prev c))
      ;;                      "Common Lisp, the Language" 1 10)
      ;;     (get-output-string out)))

      (test "string-for-each-cursor" '(4 3 2 1 0)
        (let ((r '()))
          (string-for-each-cursor (lambda (i) (set! r (cons i r))) "hello")
          (map (lambda (sc) (string-cursor->index "hello" sc)) r)))
      (test "string-for-each-cursor" '(4 3 2 1)
        (let ((r '()))
          (string-for-each-cursor (lambda (i) (set! r (cons i r))) "hello" 1)
          (map (lambda (sc) (string-cursor->index "hello" sc)) r)))
      (test "string-for-each-cursor" '(2 1)
        (let ((r '()))
          (string-for-each-cursor (lambda (i) (set! r (cons i r))) "hello" 1 3)
          (map (lambda (sc) (string-cursor->index "hello" sc)) r)))

      (test "string-replicate" "cdefab"
        (string-replicate "abcdef" 2 8))
      (test "string-replicate" "efabcd"
        (string-replicate "abcdef" -2 4))
      (test "string-replicate" "abcabca"
        (string-replicate "abc" 0 7))
      (test "string-replicate" "defdefd"
        (string-replicate "abcdefg" 0 7 3 6))
      (test "string-replicate" ""
        (string-replicate "abcdefg" 9 9 3 6))

      (test "string-replace" "abcdXYZghi"
        (string-replace "abcdefghi" "XYZ" 4 6))
      (test "string-replace" "abcdZghi"
        (string-replace "abcdefghi" "XYZ" 4 6 2))
      (test "string-replace" "abcdZefghi"
        (string-replace "abcdefghi" "XYZ" 4 4 2))
      (test "string-replace" "abcdefghi"
        (string-replace "abcdefghi" "XYZ" 4 4 1 1))
      (test "string-replace" "abcdhi"
        (string-replace "abcdefghi" "" 4 7))

      (test "string-filter" "rrrr"
        (string-filter (lambda (ch) (eqv? ch #\r))
                       "Help make programs run, run, RUN!"))
      (test "string-filter" "HelpmakeprogramsrunrunRUN"
        (string-filter char-alphabetic? "Help make programs run, run, RUN!"))

      (test "string-filter" "programsrunrun"
        (string-filter (lambda (c) (char-lower-case? c))
                       "Help make programs run, run, RUN!"
                       10))
      (test "string-filter" ""
        (string-filter (lambda (c) (char-lower-case? c)) ""))
      (test "string-remove" "Help make pogams un, un, RUN!"
        (string-remove (lambda (ch) (eqv? ch #\r))
                       "Help make programs run, run, RUN!"))
      (test "string-remove" "   , , !"
        (string-remove char-alphabetic? "Help make programs run, run, RUN!"))
      (test "string-remove" " , , RUN!"
        (string-remove (lambda (c) (char-lower-case? c))
                       "Help make programs run, run, RUN!"
                       10))
      (test "string-remove" ""
        (string-remove (lambda (c) (char-lower-case? c)) ""))

      (test "foo:bar:baz"
          (string-join '("foo" "bar" "baz") ":"))
      (test "foo:bar:baz:"
          (string-join '("foo" "bar" "baz") ":" 'suffix))
      (test "" (string-join '() ":"))
      (test "" (string-join '("") ":"))
      (test "" (string-join '() ":" 'suffix))
      (test ":" (string-join '("") ":" 'suffix))

      (test '("foo" "bar" "baz")
          (string-split "foo:bar:baz" ":"))
      (test '("foo" "bar" "baz" "")
          (string-split "foo:bar:baz:" ":"))
      (test '("foo" "bar" "baz")
          (string-split "foo:bar:baz:" ":" 'suffix))
      (test '("foo" "bar:baz:")
          (string-split "foo:bar:baz:" ":" 'suffix 1))
      (test '("foo" "bar" "baz:")
          (string-split "foo:bar:baz:" ":" 'suffix 2))
      (test '() (string-split "" ":"))
      (test '() (string-split "" ":" 'suffix))
      (test '("") (string-split ":" ":" 'suffix))
      (test '("foo" "bar" "baz")
          (string-split ":foo:bar:baz" ":" 'prefix))

      ;; from SRFI 130 test suite
      (test '() (string-split "" ""))
      (test '("a" "b" "c") (string-split "abc" ""))
      (test '("too" "" "much" "" "data")
          (string-split "too  much  data" " "))
      (test '("" "there" "ya" "go" "")
          (string-split "***there***ya***go***" "***"))
      (test '() (string-split "" "" 'infix))
      (test '("a" "b" "c") (string-split "abc" "" 'infix))
      (test '("too" "" "much" "" "data")
          (string-split "too  much  data" " " 'infix))
      (test '("" "there" "ya" "go" "")
          (string-split "***there***ya***go***" "***" 'infix))
      (test-error (string-split "" "" 'strict-infix))
      (test '("a" "b" "c") (string-split "abc" "" 'strict-infix))
      (test '("too" "" "much" "" "data")
          (string-split "too  much  data" " " 'strict-infix))
      (test '("" "there" "ya" "go" "")
          (string-split "***there***ya***go***" "***" 'strict-infix))
      (test '() (string-split "" "" 'prefix))
      (test '("a" "b" "c") (string-split "abc" "" 'prefix))
      (test '("too" "" "much" "" "data")
          (string-split "too  much  data" " " 'prefix))
      (test '("there" "ya" "go" "")
          (string-split "***there***ya***go***" "***" 'prefix))
      (test '() (string-split "" "" 'suffix))
      (test '("a" "b" "c") (string-split "abc" "" 'suffix))
      (test '("too" "" "much" "" "data")
          (string-split "too  much  data" " " 'suffix))
      (test '("" "there" "ya" "go")
          (string-split "***there***ya***go***" "***" 'suffix))
      (test '() (string-split "" "" 'infix #f))
      (test '("a" "b" "c") (string-split "abc" "" 'infix #f))
      (test '("too" "" "much" "" "data")
          (string-split "too  much  data" " " 'infix #f))
      (test '("" "there" "ya" "go" "")
          (string-split "***there***ya***go***" "***" 'infix #f))
      (test '("a" "b" "c") (string-split "abc" "" 'strict-infix #f))
      (test '("too" "" "much" "" "data")
          (string-split "too  much  data" " " 'strict-infix #f))
      (test '("" "there" "ya" "go" "")
          (string-split "***there***ya***go***" "***" 'strict-infix #f))
      (test '() (string-split "" "" 'prefix #f))
      (test '("a" "b" "c") (string-split "abc" "" 'prefix #f))
      (test '("too" "" "much" "" "data")
          (string-split "too  much  data" " " 'prefix #f))
      (test '("there" "ya" "go" "")
          (string-split "***there***ya***go***" "***" 'prefix #f))
      (test '() (string-split "" "" 'suffix #f))
      (test '("a" "b" "c") (string-split "abc" "" 'suffix #f))
      (test '("too" "" "much" "" "data")
          (string-split "too  much  data" " " 'suffix #f))
      (test '("" "there" "ya" "go")
          (string-split "***there***ya***go***" "***" 'suffix #f))
      (test-error (string-split "" "" 'strict-infix 3))
      (test '("a" "b" "c") (string-split "abc" "" 'strict-infix 3))
      (test '("too" "" "much" " data")
          (string-split "too  much  data" " " 'strict-infix 3))
      (test '("" "there" "ya" "go***")
          (string-split "***there***ya***go***" "***" 'strict-infix 3))
      (test '() (string-split "" "" 'prefix 3))
      (test '("a" "b" "c") (string-split "abc" "" 'prefix 3))
      (test '("too" "" "much" " data")
          (string-split "too  much  data" " " 'prefix 3))
      (test '("there" "ya" "go***")
          (string-split "***there***ya***go***" "***" 'prefix 3))
      (test '() (string-split "" "" 'suffix 3))
      (test '("a" "b" "c") (string-split "abc" "" 'suffix 3))
      (test '("too" "" "much" " data")
          (string-split "too  much  data" " " 'suffix 3))
      (test '("" "there" "ya" "go***")
          (string-split "***there***ya***go***" "***" 'suffix 3))
      (test-error (string-split "" "" 'strict-infix 3 0))
      (test '("b" "c") (string-split "abc" "" 'strict-infix 3 1))
      (test '("oo" "" "much" " data")
          (string-split "too  much  data" " " 'strict-infix 3 1))
      (test '("**there" "ya" "go" "")
          (string-split "***there***ya***go***" "***" 'strict-infix 3 1))
      (test '() (string-split "" "" 'prefix 3 0))
      (test '("b" "c") (string-split "abc" "" 'prefix 3 1))
      (test '("oo" "" "much" " data")
          (string-split "too  much  data" " " 'prefix 3 1))
      (test '("**there" "ya" "go" "")
          (string-split "***there***ya***go***" "***" 'prefix 3 1))
      (test '() (string-split "" "" 'suffix 3 0))
      (test '("b" "c") (string-split "abc" "" 'suffix 3 1))
      (test '("oo" "" "much" " data")
          (string-split "too  much  data" " " 'suffix 3 1))
      (test '("**there" "ya" "go")
          (string-split "***there***ya***go***" "***" 'suffix 3 1))
      (test-error (string-split "" "" 'strict-infix 3 0 0))
      (test '("b") (string-split "abc" "" 'strict-infix 3 1 2))
      (test '("oo" "" "much" " ")
          (string-split "too  much  data" " " 'strict-infix 3 1 11))
      (test '() (string-split "" "" 'prefix 3 0 0))
      (test '("b") (string-split "abc" "" 'prefix 3 1 2))
      (test '("oo" "" "much" " ")
          (string-split "too  much  data" " " 'prefix 3 1 11))
      (test '() (string-split "" "" 'suffix 3 0 0))
      (test '("b") (string-split "abc" "" 'suffix 3 1 2))
      (test '("oo" "" "much" " ")
          (string-split "too  much  data" " " 'suffix 3 1 11))

;;; Regression tests: check that reported bugs have been fixed

      ;; From: Matthias Radestock <matthias@sorted.org>
      ;; Date: Wed, 10 Dec 2003 21:05:22 +0100
                                        ;
      ;; Chris Double has found the following bug in the reference implementation:
                                        ;
      ;;  (string-contains "xabc" "ab") => 1    ;good
      ;;  (string-contains "aabc" "ab") => #f   ;bad
                                        ;
      ;; Matthias.

      (test "string-contains" 1
        (string-cursor->index "aabc" (string-contains "aabc" "ab")))

      (test "string-contains" 5
        (string-cursor->index "ababdabdabxxas" (string-contains "ababdabdabxxas" "abdabx")))

      ;; (message continues)
      ;;
      ;; PS: There is also an off-by-one error in the bounds check of the
      ;; unoptimized version of string-contains that is included as commented out
      ;; code in the reference implementation. This breaks things like
      ;; (string-contains "xab" "ab") and (string-contains "ab" "ab").

      ;; This off-by-one bug has been fixed in the comments of the version
      ;; of SRFI-13 shipped with Larceny.  In a version of the code without
      ;; the fix the following test will catch the bug:

      (test "string-contains" 0
        (string-cursor->index "ab" (string-contains "ab" "ab")))

      ;; even string-cursor->index/index->cursor are polymorphic :(
      (let* ((s "abc")
             (i 1)
             (sc (string-index->cursor s i)))
        (test i (string-cursor->index s sc))
        (test i (string-cursor->index s i))
        (test sc (string-index->cursor s sc))
        (test sc (string-index->cursor s i)))

      (test-end))))
;; Copyright (C) Marc Nieper-Wikirchen (2017).  All Rights Reserved.

;; Permission is hereby granted, free of charge, to any person
;; obtaining a copy of this software and associated documentation
;; files (the "Software"), to deal in the Software without
;; restriction, including without limitation the rights to use, copy,
;; modify, merge, publish, distribute, sublicense, and/or sell copies
;; of the Software, and to permit persons to whom the Software is
;; furnished to do so, subject to the following conditions:

;; The above copyright notice and this permission notice shall be
;; included in all copies or substantial portions of the Software.

;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
;; EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
;; MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
;; NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
;; BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
;; ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
;; CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
;; SOFTWARE.

(define-syntax closed-lambda
  (syntax-rules ()
    ((closed-lambda formals body)
     (let ((dynamic-environment (current-dynamic-environment)))
       (lambda formals
         (with-dynamic-environment dynamic-environment (lambda ()
                                                         body)))))))

(define-record-type <dynamic-environment>
  (make-dynamic-environment proc)
  dynamic-environment?
  (proc dynamic-environment-proc))


(define (current-dynamic-environment)
  (call-with-current-continuation
   (lambda (return)
     (let-values
         (((k thunk)
           (call-with-current-continuation
            (lambda (c)
              (return
               (make-dynamic-environment (lambda (thunk)
                                           (call-with-current-continuation
                                            (lambda (k)
                                              (c k thunk))))))))))
       (call-with-values thunk k)))))


(define (with-dynamic-environment dynamic-environment thunk)
  ((dynamic-environment-proc dynamic-environment) thunk))

(define-library (srfi 46)
  (import (chibi))
  (export syntax-rules))
;; Miscellaneous Functions

(define (vector-iota len start)
  (let ((res (make-vector len)))
    (do ((i 0 (+ i 1)))
        ((= i len) res)
      (vector-set! res i (+ i start)))))

(define (translation? x)
  (and (vector? x) (vector-every exact-integer? x)))

(define (permutation? x)
  (and (translation? x)
       (let* ((len (vector-length x))
              (seen (make-vector len 0)))
         (let lp ((i 0))
           (or (>= i len)
               (and (< -1 (vector-ref x i) len)
                    (zero? (vector-ref seen (vector-ref x i)))
                    (begin
                      (vector-set! seen (vector-ref x i) 1)
                      (lp (+ i 1)))))))))

(define (index-rotate n k)
  (list->vector (append (iota (- n k) k) (iota k))))

(define (index-first n k)
  (list->vector (cons k
                      (append (iota k)
                              (iota (- n (+ k 1)) (+ k 1))))))

(define (index-last n k)
  (list->vector (append (iota k)
                        (iota (- n (+ k 1)) (+ k 1))
                        (list k))))

(define (index-swap n i j)
  (let ((result (vector-iota n 0)))
    (vector-set! result i j)
    (vector-set! result j i)
    result))

;; Intervals

(define-record-type Interval
  (%%make-interval lb ub)
  interval?
  (lb interval-lb)
  (ub interval-ub))

(define (%make-interval lo hi)
  (assert (and (translation? lo)
               (translation? hi)
               (= (vector-length lo) (vector-length hi))
               (vector-every <= lo hi)))
  (%%make-interval lo hi))

(define (make-interval x . o)
  (if (pair? o)
      (%make-interval x (car o))
      (%make-interval (make-vector (vector-length x) 0) x)))

(define (interval-dimension iv)
  (vector-length (interval-lb iv)))

(define (interval-lower-bound iv i) (vector-ref (interval-lb iv) i))
(define (interval-upper-bound iv i) (vector-ref (interval-ub iv) i))
(define (interval-lower-bounds->list iv) (vector->list (interval-lb iv)))
(define (interval-upper-bounds->list iv) (vector->list (interval-ub iv)))
(define (interval-lower-bounds->vector iv) (vector-copy (interval-lb iv)))
(define (interval-upper-bounds->vector iv) (vector-copy (interval-ub iv)))

(define (interval-width iv i)
  (- (interval-upper-bound iv i) (interval-lower-bound iv i)))
(define (interval-widths iv)
  (vector-map - (interval-ub iv) (interval-lb iv)))

(define (interval= iv1 iv2)
  (assert (and (interval? iv1) (interval? iv2)))
  (and (equal? (interval-lb iv1) (interval-lb iv2))
       (equal? (interval-ub iv1) (interval-ub iv2))))

(define (interval-volume iv)
  (vector-fold (lambda (acc lower upper) (* acc (- upper lower)))
               1
               (interval-lb iv) (interval-ub iv)))

(define (interval-empty? iv)
  (zero? (interval-volume iv)))

(define (interval-subset? iv1 iv2)
  (assert (and (interval? iv1) (interval? iv2)
               (= (interval-dimension iv1) (interval-dimension iv2))))
  (and (vector-every >= (interval-lb iv1) (interval-lb iv2))
       (vector-every <= (interval-ub iv1) (interval-ub iv2))))

(define (interval-contains-multi-index? iv i0 . o)
  (assert (interval? iv))
  (let ((i (list->vector (cons i0 o))))
    (assert (and (= (interval-dimension iv) (vector-length i))
                 (vector-every integer? i)))
    (and (vector-every >= i (interval-lb iv))
         (vector-every < i (interval-ub iv)))))

(define (interval-projections iv rd)
  (values (make-interval (vector-copy (interval-lb iv) 0 rd)
                         (vector-copy (interval-ub iv) 0 rd))
          (make-interval (vector-copy (interval-lb iv) rd)
                         (vector-copy (interval-ub iv) rd))))

(define (rev-index-next! rev-index rev-lowers rev-uppers)
  (cond
   ((null? rev-index) #f)
   ((< (caar rev-index) (- (car rev-uppers) 1))
    (set-car! (car rev-index) (+ 1 (caar rev-index)))
    #t)
   (else
    (set-car! (car rev-index) (car rev-lowers))
    (rev-index-next! (cdr rev-index) (cdr rev-lowers) (cdr rev-uppers)))))

(define (interval-cursor iv)
  (let* ((rev-lowers (reverse (interval-lower-bounds->list iv)))
         (rev-uppers (reverse (interval-upper-bounds->list iv)))
         (multi-index (interval-lower-bounds->list iv))
         (rev-index (pair-fold cons '() multi-index)))
    (vector multi-index rev-index rev-lowers rev-uppers)))

(define (interval-cursor-get ivc)
  (vector-ref ivc 0))

(define (interval-cursor-next! ivc)
  (and (rev-index-next! (vector-ref ivc 1)
                        (vector-ref ivc 2)
                        (vector-ref ivc 3))
       (vector-ref ivc 0)))

(define (interval-cursor-next ivc)
  (let* ((multi-index (list-copy (vector-ref ivc 0)))
         (ivc (vector multi-index
                      (pair-fold cons '() multi-index)
                      (vector-ref ivc 2)
                      (vector-ref ivc 3))))
    (and (rev-index-next! (vector-ref ivc 1)
                          (vector-ref ivc 2)
                          (vector-ref ivc 3))
         (values ivc (vector-ref ivc 0)))))

(define (interval-fold-left f kons knil iv)
  (case (interval-dimension iv)
    ((1)
     (let ((end (interval-upper-bound iv 0)))
       (do ((i (interval-lower-bound iv 0) (+ i 1))
            (acc knil (kons acc (f i))))
           ((>= i end) acc))))
    ((2)
     (let ((end0 (interval-upper-bound iv 0))
           (start1 (interval-lower-bound iv 1))
           (end1 (interval-upper-bound iv 1)))
       (do ((i (interval-lower-bound iv 0) (+ i 1))
            (acc knil
                 (do ((j start1 (+ j 1))
                      (acc acc (kons acc (f i j))))
                     ((>= j end1) acc))))
           ((>= i end0) acc))))
    (else
     (let ((ivc (interval-cursor iv)))
       (let lp ((acc knil))
         (let ((acc (kons acc (apply f (interval-cursor-get ivc)))))
           (if (interval-cursor-next! ivc)
               (lp acc)
               acc)))))))

(define (interval-fold kons knil iv)
  (interval-fold-left list (lambda (acc idx) (apply kons acc idx)) knil iv))

(define (interval-fold-right f kons knil iv)
  (let ((ivc (interval-cursor iv)))
    (let lp ()
      (let ((item (apply f (interval-cursor-get ivc))))
        (if (interval-cursor-next! ivc)
            (kons item (lp))
            (kons item knil))))))

(define (interval-for-each f iv)
  (interval-fold (lambda (acc . multi-index) (apply f multi-index)) #f iv)
  (if #f #f))

(define (interval-dilate iv lower-diffs upper-diffs)
  (assert (= (interval-dimension iv)
             (vector-length lower-diffs)
             (vector-length upper-diffs)))
  (make-interval (vector-map + (interval-lb iv) lower-diffs)
                 (vector-map + (interval-ub iv) upper-diffs)))

(define (interval-intersect iv0 . o)
  (let ((ls (cons iv0 o)))
    (assert (and (every interval? ls)
                 (or (null? o) (apply = (map interval-dimension ls)))))
    (let ((lower (apply vector-map max (map interval-lb ls)))
          (upper (apply vector-map min (map interval-ub ls))))
      (and (vector-every < lower upper)
           (make-interval lower upper)))))

(define (interval-translate iv translation)
  (assert (translation? translation))
  (interval-dilate iv translation translation))

(define (interval-permute iv perm)
  (assert (and (interval? iv) (permutation? perm)))
  (let* ((len (interval-dimension iv))
         (lower (make-vector len))
         (upper (make-vector len)))
    (assert (= len (vector-length perm)))
    (do ((i 0 (+ i 1)))
        ((>= i len) (make-interval lower upper))
      (vector-set! lower i (interval-lower-bound iv (vector-ref perm i)))
      (vector-set! upper i (interval-upper-bound iv (vector-ref perm i))))))

(define (interval-scale iv scales)
  (assert (and (interval? iv)
               (vector? scales)
               (= (interval-dimension iv) (vector-length scales))
               (vector-every exact-integer? scales)
               (vector-every positive? scales)))
  (make-interval
   (vector-map (lambda (u s) (exact (ceiling (/ u s))))
               (interval-ub iv)
               scales)))

(define (interval-cartesian-product iv0 . o)
  (make-interval (apply vector-append (map interval-lb (cons iv0 o)))
                 (apply vector-append (map interval-ub (cons iv0 o)))))

;; Storage Classes

(define-record-type Storage-Class
  (make-storage-class getter setter checker maker copier length default data? data->body)
  storage-class?
  (getter storage-class-getter)
  (setter storage-class-setter)
  (checker storage-class-checker)
  (maker storage-class-maker)
  (copier storage-class-copier)
  (length storage-class-length)
  (default storage-class-default)
  (data? storage-class-data?)
  (data->body storage-class-data->body))

(define generic-storage-class
  (make-storage-class
   vector-ref vector-set! (lambda (x) #t) make-vector
   vector-copy! vector-length #f (lambda (data) #t) (lambda (data) data)))

;; Parameters

;; Note safety is ignored in this implementation.
(define specialized-array-default-safe?
  (make-parameter #f (lambda (x) (assert (boolean? x)) x)))

(define specialized-array-default-mutable?
  (make-parameter #t (lambda (x) (assert (boolean? x)) x)))

;; Arrays

(define-record-type Array
  (%%make-array domain getter setter storage body coeffs indexer safe? adjacent?)
  array?
  (domain array-domain)
  (getter array-getter)
  (setter array-setter %array-setter-set!)
  (storage array-storage-class)
  (body array-body)
  (coeffs array-coeffs)
  (indexer array-indexer)
  (safe? array-safe?)
  (adjacent? array-adjacent? array-adjacent?-set!))

(define (%make-array domain getter setter storage body coeffs
                     indexer safe? adjacent?)
  (assert (and (interval? domain)
               (procedure? getter)
               (or (not setter) (procedure? setter))
               (or (not storage) (storage-class? storage))))
  (%%make-array
   domain getter setter storage body coeffs indexer safe? adjacent?))

(define (make-array domain getter . o)
  (assert (and (interval? domain) (procedure? getter)))
  (%make-array domain getter (and (pair? o) (car o)) #f #f #f #f #f #f))

(define (array-dimension a)
  (interval-dimension (array-domain a)))

(define (mutable-array? x)
  (and (array? x) (array-setter x) #t))

(define (array-ref array . multi-index)
  (apply (array-getter array) multi-index))

(define (array-set! array val . multi-index)
  (apply (array-setter array) val multi-index))

(define (specialized-getter body indexer getter)
  (lambda multi-index
    (getter body (apply indexer multi-index))))

(define (specialized-setter body indexer setter)
  (lambda (val . multi-index)
    (setter body (apply indexer multi-index) val)))


;; Indexing

(define (indexer->coeffs indexer domain . o)
  (let* ((verify? (and (pair? o) (car o)))
         (res (make-vector (+ 1 (interval-dimension domain)) 0))
         (multi-index (interval-lower-bounds->list domain))
         (base (apply indexer multi-index)))
    (vector-set! res 0 base)
    (let lp ((i 1)
             (ls multi-index)
             (offset base)
             (count 0))
      (cond
       ((null? ls)
        (if (and verify? (zero? count))
            (lp 1 multi-index offset (+ count 1))
            res))
       ((= (+ 1 (interval-lower-bound domain (- i 1)))
           (interval-upper-bound domain (- i 1)))
        (lp (+ i 1) (cdr ls) offset count))
       (else
        (let ((dir (if (and (> count 0)
                            (= (+ (car ls) 1)
                               (interval-upper-bound domain (- i 1))))
                       -1
                       1)))
          (set-car! ls (+ (car ls) dir))
          (let* ((offset2 (apply indexer multi-index))
                 (coeff (* dir (- offset2 offset))))
            (cond
             ((> count 0)
              (and (= coeff (vector-ref res i))
                   (lp (+ i 1) (cdr ls) offset2 count)))
             (else
              (vector-set! res i coeff)
              (vector-set! res 0 (- (vector-ref res 0)
                                    (* coeff
                                       (interval-lower-bound domain (- i 1)))))
              (lp (+ i 1) (cdr ls) offset2 count))))))))))

(define (coeffs->indexer coeffs domain)
  (case (vector-length coeffs)
    ((2)
     (let ((a (vector-ref coeffs 0))
           (b (vector-ref coeffs 1)))
       (lambda (x) (+ a (* b x)))))
    ((3)
     (let ((a (vector-ref coeffs 0))
           (b (vector-ref coeffs 1))
           (c (vector-ref coeffs 2)))
       (lambda (x y) (+ a (* b x) (* c y)))))
    ((4)
     (let ((a (vector-ref coeffs 0))
           (b (vector-ref coeffs 1))
           (c (vector-ref coeffs 2))
           (d (vector-ref coeffs 3)))
       (lambda (x y z) (+ a (* b x) (* c y) (* d z)))))
    (else
     (lambda multi-index
       (let ((lim (vector-length coeffs)))
         (let lp ((ls multi-index)
                  (i 1)
                  (res (vector-ref coeffs 0)))
           (cond
            ((null? ls)
             (if (< i lim)
                 (error "multi-index too short for domain" multi-index domain)
                 res))
            ((>= i lim)
             (error "multi-index too long for domain" multi-index domain))
            (else
             (lp (cdr ls)
                 (+ i 1)
                 (+ res (* (car ls) (vector-ref coeffs i))))))))))))

(define (default-coeffs domain)
  (let* ((dim (interval-dimension domain))
         (res (make-vector (+ 1 dim))))
    (vector-set! res 0 0)
    (vector-set! res dim 1)
    (let lp ((i (- dim 1))
             (scale 1))
      (cond
       ((< i 0)
        res)
       ((= (+ 1 (interval-lower-bound domain i))
           (interval-upper-bound domain i))
        (vector-set! res (+ i 1) 0)
        (lp (- i 1) scale))
       (else
        (let ((coeff (* scale  (- (interval-upper-bound domain i)
                                  (interval-lower-bound domain i)))))
          (vector-set! res (+ i 1) scale)
          (vector-set! res 0 (- (vector-ref res 0)
                                (* scale (interval-lower-bound domain i))))
          (lp (- i 1) coeff)))))))

(define (default-indexer domain)
  (coeffs->indexer (default-coeffs domain) domain))

;; Converts the raw integer index to the multi-index in domain that
;; would map to it using the default indexer (i.e. iterating over the
;; possible multi-indices in domain in lexicographic order would
;; produce 0 through volume-1).
(define (invert-default-index domain raw-index)
  (let lp ((index raw-index)
           (i 0)
           (scale (/ (interval-volume domain)
                     (max 1
                          (- (interval-upper-bound domain 0)
                             (interval-lower-bound domain 0)))))
           (res '()))
    (cond
     ((>= (+ i 1) (interval-dimension domain))
      (reverse (cons (+ index (interval-lower-bound domain i)) res)))
     (else
      (let ((digit (quotient index scale)))
        (lp (- index (* digit scale))
            (+ i 1)
            (/ scale
               (max 1
                    (- (interval-upper-bound domain (+ i 1))
                       (interval-lower-bound domain (+ i 1)))))
            (cons (+ digit
                     (interval-lower-bound domain i))
                  res)))))))

;; Specialized arrays

(define (%make-specialized domain storage body coeffs indexer
                           safe? mutable? adjacent?)
  (%make-array
   domain
   (specialized-getter body indexer (storage-class-getter storage))
   (and mutable?
        (specialized-setter body indexer (storage-class-setter storage)))
   storage
   body
   coeffs
   indexer
   safe?
   adjacent?))

(define (make-specialized-array domain . o)
  (let* ((storage (if (pair? o) (car o) generic-storage-class))
         (safe? (if (and (pair? o) (pair? (cdr o)))
                    (cadr o)
                    (specialized-array-default-safe?)))
         (body ((storage-class-maker storage)
                (interval-volume domain)
                (storage-class-default storage)))
         (coeffs (default-coeffs domain))
         (indexer (coeffs->indexer coeffs domain)))
    (assert (boolean? safe?))
    (%make-specialized domain storage body coeffs indexer safe? #t #t)))

(define (make-specialized-array-from-data data . o)
  (let* ((storage (if (pair? o) (car o) generic-storage-class))
         (safe? (if (and (pair? o) (pair? (cdr o)))
                    (cadr o)
                    (specialized-array-default-safe?)))
         (domain (make-interval (vector ((storage-class-length storage) data))))
         (body ((storage-class-data->body storage) data))
         (coeffs (default-coeffs domain))
         (indexer (coeffs->indexer coeffs domain)))
    (assert (boolean? safe?))
    (%make-specialized domain storage body coeffs indexer safe? #t #t)))

(define (specialized-array? x)
  (and (array? x) (array-storage-class x) #t))

(define (compute-array-packed? array)
  (let ((indexer (array-indexer array)))
    (call-with-current-continuation
     (lambda (return)
       (interval-fold
        (lambda (prev . multi-index)
          (let ((i (apply indexer multi-index)))
            (if (and prev (not (= i (+ prev 1))))
                (return #f)
                i)))
        #f
        (array-domain array))
       #t))))

(define (array-packed? array)
  (assert (specialized-array? array))
  (let ((res (array-adjacent? array)))
    (when (eq? res 'unknown)
      (set! res (compute-array-packed? array))
      (array-adjacent?-set! array res))
    res))

(define (specialized-array-share array new-domain project)
  (assert (and (specialized-array? array) (interval? new-domain)))
  (let* ((body (array-body array))
         (coeffs
          (indexer->coeffs
           (lambda multi-index
             (call-with-values
                 (lambda () (apply project multi-index))
               (array-indexer array)))
           new-domain))
         (indexer
          (coeffs->indexer coeffs new-domain))
         (storage (array-storage-class array)))
    (%make-specialized new-domain storage body coeffs indexer
                       (array-safe? array) (array-setter array) 'unknown)))
;; Adapted from original SRFI reference test suite:

;; SRFI 179: Nonempty Intervals and Generalized Arrays (Updated)

;; Copyright 2016, 2018, 2020 Bradley J Lucier.
;; All Rights Reserved.

;; Permission is hereby granted, free of charge,
;; to any person obtaining a copy of this software
;; and associated documentation files (the "Software"),
;; to deal in the Software without restriction,
;; including without limitation the rights to use, copy,
;; modify, merge, publish, distribute, sublicense,
;; and/or sell copies of the Software, and to permit
;; persons to whom the Software is furnished to do so,
;; subject to the following conditions:

;; The above copyright notice and this permission notice
;; (including the next paragraph) shall be included in
;; all copies or substantial portions of the Software.

;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF
;; ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
;; LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
;; FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
;; EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
;; FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
;; AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
;; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
;; OTHER DEALINGS IN THE SOFTWARE.

;;; A test program for SRFI 179:
;;; Nonempty Intervals and Generalized Arrays (Updated)

(define-library (srfi 231 test)
  (import (scheme base) (scheme cxr) (scheme complex)
          (scheme file) (scheme list) (scheme read)
          (scheme sort) (scheme vector) (scheme write)
          (chibi test)
          (srfi 27) (srfi 143) (srfi 144) (srfi 160 base) (srfi 231))
  (export run-tests)
  (begin
    ;; Just run 1 pass of the randomized tests.
    ;; TODO: remove all randomized tests.
    (define tests 1)

    (define (interval-rotate iv dim)
      (let ((lower (interval-lower-bounds->vector iv))
            (upper (interval-upper-bounds->vector iv)))
        (make-interval (vector-append (vector-copy lower dim)
                                      (vector-copy lower 0 dim))
                       (vector-append (vector-copy upper dim)
                                      (vector-copy upper 0 dim)))))

    (define (array-rotate array dim)
      (let ((left (iota (- (array-dimension array) dim) dim))
            (right (iota dim)))
        (array-permute array (list->vector (append left right)))))

    (define (random a . b)
      (if (pair? b)
          (+ a (random-integer (- (car b) a)))
          (random-integer a)))

    (define (random-sample n . o)
      (let ((l (if (pair? o) (car o) 4)))
        (list->vector (map (lambda (i)
                             (random 1 l))
                           (iota n)))))

    (define (random-f64vector n)
      (let ((res (make-f64vector n)))
        (do ((i 0 (+ i 1)))
            ((= i n) res)
          (f64vector-set! res i (random-real)))))

    (define (f64vector->list vec)
      (do ((i (- (f64vector-length vec) 1) (- i 1))
           (res '() (cons (f64vector-ref vec i) res)))
          ((< i 0) res)))

    (define (random-permutation n)
      (let ((result (make-vector n)))
        ;; fill it
        (do ((i 0 (fx+ i 1)))
            ((fx=? i n))
          (vector-set! result i i))
        ;; permute it
        (do ((i 0 (fx+ i 1)))
            ((fx=? i n)
             ;;(write `(random-permutation ,n -> ,result)) (newline)
             result)
          (vector-swap! result i (random i n)))))

    (define (inverse-permutation permutation)
      (list->vector
       (map
        car
        (list-sort
         (lambda (a b) (< (cdr a) (cdr b)))
         (map cons
              (iota (vector-length permutation))
              (vector->list permutation))))))

    (define (vector-permute v permutation)
      (let* ((n (vector-length v))
             (result (make-vector n)))
        (do ((i 0 (+ i 1)))
            ((= i n) result)
          (vector-set! result i (vector-ref v (vector-ref permutation i))))))

    (define (in-order < l)
      (or (null? l)
          (null? (cdr l))
          (and (< (car l) (cadr l))
               (in-order < (cdr l)))))

    (define (local-iota a b)
      (if (= a b)
          '()
          (cons a (local-iota (+ a 1) b))))

    (define (all-elements lower upper)
      (if (null? (cdr lower))
          (map list (local-iota (car lower) (car upper)))
          (apply append (map (lambda (x)
                               (map (lambda (y)
                                      (cons x y))
                                    (all-elements (cdr lower) (cdr upper))))
                             (local-iota (car lower) (car upper))))))

    ;; define random-interval, random-multi-index

    (define (random-multi-index interval)
      (apply values
             (apply map
                    random
                    (map (lambda (bounds)
                           (bounds interval))
                         (list interval-lower-bounds->list
                               interval-upper-bounds->list)))))

    (define use-bignum-intervals #f)

    (define (random-interval . o)
      ;; a random interval with min <= dimension < max
      ;; positive and negative lower bounds
      (let* ((min (if (pair? o) (car o) 1))
             (max (if (and (pair? o) (pair? (cdr o))) (cadr o) 4))
             (lower
              (map (lambda (x)
                     (if use-bignum-intervals
                         (random (- (expt 2 90)) (expt 2 90))
                         (random -10 10)))
                   (vector->list (make-vector (random min max)))))
             (upper
              (map (lambda (x)
                     (+ (random 1 8) x))
                   lower)))
        (make-interval (list->vector lower)
                       (list->vector upper))))

    (define (random-subinterval interval)
      (let* ((lowers (interval-lower-bounds->vector interval))
             (uppers (interval-upper-bounds->vector interval))
             (new-lowers (vector-map random lowers uppers))
             (new-uppers (vector-map (lambda (x) (+ x 1))
                                     (vector-map random new-lowers uppers)))
             (subinterval (make-interval new-lowers new-uppers)))
        subinterval))

    (define (random-nonnegative-interval . o)
      ;; a random interval with min <= dimension < max
      (let* ((min (if (pair? o) (car o) 1))
             (max (if (and (pair? o) (pair? (cdr o))) (cadr o) 6))
             (lower
              (make-vector (random min max) 0))
             (upper
              (vector-map (lambda (x) (random 1 7)) lower)))
        (make-interval lower upper)))

    (define (random-positive-vector n . o)
      (let ((max (if (pair? o) (car o) 5)))
        (vector-map (lambda (x)
                      (random 1 max))
                    (make-vector n))))

    (define (random-boolean)
      (zero? (random 2)))

    (define (array-display A)
  
      (define (display-item x)
        (display x) (display "\t"))
  
      (newline)
      (case (array-dimension A)
        ((1) (array-for-each display-item A) (newline))
        ((2) (array-for-each (lambda (row)
                               (array-for-each display-item row)
                               (newline))
                             (array-curry A 1)))
        (else
         (error "array-display can't handle > 2 dimensions: " A))))

    (define (myindexer= indexer1 indexer2 interval)
      (array-foldl (lambda (x y) (and x y))
                   #t
                   (make-array interval
                               (lambda args
                                 (= (apply indexer1 args)
                                    (apply indexer2 args))))))

    (define (my-indexer base lower-bounds increments)
      (lambda indices
        (apply + base (map * increments (map - indices lower-bounds)))))

    (define (random-sign)
      (- 1 (* 2 (random 2))))

    (define (myarray= array1 array2)
      (and (interval= (array-domain array1)
                      (array-domain array2))
           (array-foldl (lambda (vs result)
                          (and (equal? (car vs)
                                       (cadr vs))
                               result))
                        #t
                        (array-map list array1 array2))))

    (define random-storage-class-and-initializer
      (let* ((storage-classes
              (vector
               ;; generic
               (list generic-storage-class
                     (lambda args (random-permutation (length args))))
               ;; signed integer
               (list s8-storage-class
                     (lambda args (random (- (expt 2 7)) (- (expt 2 7) 1))))
               (list s16-storage-class
                     (lambda args (random (- (expt 2 15)) (- (expt 2 15) 1))))
               (list s32-storage-class
                     (lambda args (random (- (expt 2 31)) (- (expt 2 31) 1))))
               (list s64-storage-class
                     (lambda args (random (- (expt 2 63)) (- (expt 2 63) 1))))
               ;; unsigned integer
               (list u1-storage-class
                     (lambda args (random (expt 2 1))))
               (list u8-storage-class
                     (lambda args (random (expt 2 8))))
               (list u16-storage-class
                     (lambda args (random (expt 2 16))))
               (list u32-storage-class
                     (lambda args (random (expt 2 32))))
               (list u64-storage-class
                     (lambda args (random (expt 2 64))))
               ;; float
               (list f32-storage-class
                     (lambda args (random-real)))
               (list f64-storage-class
                     (lambda args (random-real)))
               ;; complex-float
               (list c64-storage-class
                     (lambda args (make-rectangular (random-real) (random-real))))
               (list c128-storage-class
                     (lambda args (make-rectangular (random-real) (random-real))))))
             (n
              (vector-length storage-classes)))
        (lambda ()
          (vector-ref storage-classes (random n)))))

    ;; Elements of extracted arrays of newly created specialized
    ;; arrays are not in order unless
    ;; (1) the differences in the upper and lower bounds of the
    ;;     first dimensions all equal 1 *and*
    ;; (2) the next dimension doesn't matter *and*
    ;; (3) the upper and lower bounds of the latter dimensions
    ;;     of the original and extracted arrays are the same
    ;; Whew!

    (define (extracted-array-elements-in-order? base extracted)
      (let ((base-domain (array-domain base))
            (extracted-domain (array-domain extracted))
            (dim (array-dimension base)))
        (let loop-1 ((i 0))
          (or (= i (- dim 1))
              (or (and (= 1 (- (interval-upper-bound extracted-domain i)
                               (interval-lower-bound extracted-domain i)))
                       (loop-1 (+ i 1)))
                  (let loop-2 ((i (+ i 1)))
                    (or (= i dim)
                        (and (= (interval-upper-bound extracted-domain i)
                                (interval-upper-bound base-domain i))
                             (= (interval-lower-bound extracted-domain i)
                                (interval-lower-bound base-domain i))
                             (loop-2 (+ i 1))))))))))


    ;; A permuted array has elements in order iff all the dimensions with
    ;; sidelength > 1 are in the same order.
    (define (permuted-array-elements-in-order? array permutation)
      (let* ((domain
              (array-domain array))
             (axes-and-limits
              (vector-map list
                          (list->vector (iota (vector-length permutation)))
                          (interval-lower-bounds->vector domain)
                          (interval-upper-bounds->vector domain)))
             (permuted-axes-and-limits
              (vector->list (vector-permute axes-and-limits permutation))))
        (in-order (lambda (x y)
                    (< (car x) (car y)))
                  (filter (lambda (l)
                            (let ((i (car l))
                                  (l (cadr l))
                                  (u (caddr l)))
                              (< 1 (- u l))))
                          permuted-axes-and-limits))))

    ;; a sampled array has elements in order iff after a string of
    ;; dimensions with side-length 1 at the beginning, all the rest
    ;; of the dimensions have sidelengths the same as the original
    (define (sampled-array-elements-in-order? base scales)
      (let* ((domain
              (array-domain base))
             (sampled-base
              (array-sample base scales))
             (scaled-domain
              (array-domain sampled-base))
             (base-sidelengths
              (vector->list
               (vector-map -
                           (interval-upper-bounds->vector domain)
                           (interval-lower-bounds->vector domain))))
             (scaled-sidelengths
              (vector->list
               (vector-map -
                           (interval-upper-bounds->vector scaled-domain)
                           (interval-lower-bounds->vector scaled-domain)))))
        (let loop-1 ((base-lengths   base-sidelengths)
                     (scaled-lengths scaled-sidelengths))
          (or (null? base-lengths)
              (if (= (car scaled-lengths) 1)
                  (loop-1 (cdr base-lengths)
                          (cdr scaled-lengths))
                  (let loop-2 ((base-lengths   base-lengths)
                               (scaled-lengths scaled-lengths))
                    (or (null? base-lengths)
                        (and (= (car base-lengths) (car scaled-lengths))
                             (loop-2 (cdr base-lengths)
                                     (cdr scaled-lengths))))))))))

    (define (multi-index< ind1 ind2)
      (and (not (null? ind1))
           (not (null? ind2))
           (or (< (car ind1)
                  (car ind2))
               (and (= (car ind1)
                       (car ind2))
                    (multi-index< (cdr ind1)
                                  (cdr ind2))))))

    (define (indices-in-proper-order l)
      (or (null? l)
          (null? (cdr l))
          (and (multi-index< (car l)
                             (cadr l))
               (indices-in-proper-order (cdr l)))))

    ;; OK, how to test array-reduce?

    ;; Well, we take an associative, non-commutative operation,
    ;; multiplying 2x2 matrices, with data such that doing operations
    ;; in the opposite order gives the wrong answer, doing it for the
    ;; wrong interval (e.g., swapping axes) gives the wrong answer.

    ;; This is not in the same style as the other tests, which use random
    ;; data to a great extent, but I couldn't see how to choose random
    ;; data that would satisfy the constraints.

    (define matrix vector)

    (define (x2x2-multiply A B)
      (let ((a_11 (vector-ref A 0)) (a_12 (vector-ref A 1))
            (a_21 (vector-ref A 2)) (a_22 (vector-ref A 3))
            (b_11 (vector-ref B 0)) (b_12 (vector-ref B 1))
            (b_21 (vector-ref B 2)) (b_22 (vector-ref B 3)))
        (vector (+ (* a_11 b_11) (* a_12 b_21))
                (+ (* a_11 b_12) (* a_12 b_22))
                (+ (* a_21 b_11) (* a_22 b_21))
                (+ (* a_21 b_12) (* a_22 b_22)))))

    (define (my-array-translate Array translation)
      (let* ((array-copy (array-copy Array))
             (getter (array-getter array-copy))
             (setter (array-setter array-copy)))
        (make-array (interval-translate (array-domain Array)
                                        translation)
                    (lambda args
                      (apply getter
                             (map - args (vector->list translation))))
                    (lambda (v . args)
                      (apply setter
                             v
                             (map - args (vector->list translation)))))))

    (define (my-array-permute Array permutation)
      (let* ((array-copy (array-copy Array))
             (getter (array-getter array-copy))
             (setter (array-setter array-copy))
             (permutation-inverse (inverse-permutation permutation)))
        (make-array (interval-permute (array-domain Array)
                                      permutation)
                    (lambda args
                      (apply getter
                             (vector->list
                              (vector-permute (list->vector args)
                                              permutation-inverse))))
                    (lambda (v . args)
                      (apply setter
                             v
                             (vector->list
                              (vector-permute (list->vector args)
                                              permutation-inverse)))))))

    (define (my-interval-intersect . args)
      (define (fold-left operator ;; called with (op result-so-far (car list))
                         initial-value
                         list)
        (if (null? list)
            initial-value
            (fold-left operator
                       (operator initial-value (car list))
                       (cdr list))))
      (let ((new-uppers
             (let ((uppers (map interval-upper-bounds->vector args)))
               (fold-left (lambda (arg result)
                            (vector-map min arg result))
                          (car uppers)
                          uppers)))
            (new-lowers (let ((lowers (map interval-lower-bounds->vector args)))
                          (fold-left (lambda (arg result)
                                       (vector-map max arg result))
                                     (car lowers)
                                     lowers))))
        (and (vector-every < new-lowers new-uppers)
             (make-interval new-lowers new-uppers))))

    (define (my-interval-scale interval scales)
      (make-interval (interval-lower-bounds->vector interval)
                     (vector-map (lambda (u s)
                                   (quotient (+ u s -1) s))
                                 (interval-upper-bounds->vector interval)
                                 scales)))

    (define sparse-array
      (let ((domain (make-interval '#(1000000 1000000)))
            (sparse-rows (make-vector 1000000 '())))
        (make-array
         domain
         (lambda (i j)
           (cond ((assv j (vector-ref sparse-rows i))
                  => cdr)
                 (else
                  0.0)))
         (lambda (v i j)
           (cond
            ((assv j (vector-ref sparse-rows i))
             => (lambda (pair)
                  (set-cdr! pair v)))
            (else
             (vector-set! sparse-rows i (cons (cons j v)
                                              (vector-ref sparse-rows i)))))))))

    (define (myarray-sample array scales)
      (let ((scales-list (vector->list scales)))
        (cond ((specialized-array? array)
               (specialized-array-share
                array
                (interval-scale (array-domain array) scales)
                (lambda multi-index
                  (apply values (map * multi-index scales-list)))))
              ((mutable-array? array)
               (let ((getter (array-getter array))
                     (setter (array-setter array)))
                 (make-array
                  (interval-scale (array-domain array) scales)
                  (lambda multi-index
                    (apply getter (map * multi-index scales-list)))
                  (lambda (v . multi-index)
                    (apply setter v (map * multi-index scales-list))))))
              (else
               (let ((getter (array-getter array)))
                 (make-array
                  (interval-scale (array-domain array) scales)
                  (lambda multi-index
                    (apply getter (map * multi-index scales-list)))))))))

    (define (ceiling-quotient x d)
      ;; assumes x and d are positive
      (quotient (+ x d -1) d))

    (define (my-array-tile array sidelengths)
      ;; an alternate definition more-or-less from the srfi document
      (let* ((domain
              (array-domain array))
             (lowers
              (interval-lower-bounds->vector domain))
             (uppers
              (interval-upper-bounds->vector domain))
             (result-lowers
              (vector-map (lambda (x)
                            0)
                          lowers))
             (result-uppers
              (vector-map (lambda (l u s)
                            (ceiling-quotient (- u l) s))
                          lowers uppers sidelengths)))
        (make-array
         (make-interval result-lowers result-uppers)
         (lambda i
           (let* ((vec-i
                   (list->vector i))
                  (result-lowers
                   (vector-map (lambda (l i s)
                                 (+ l (* i s)))
                               lowers vec-i sidelengths))
                  (result-uppers
                   (vector-map (lambda (l u i s)
                                 (min u (+ l (* (+ i 1) s))))
                               lowers uppers vec-i sidelengths)))
             (array-extract array
                            (make-interval result-lowers result-uppers)))))))

    (define (myarray-reverse array flip?)
      (let* ((flips (vector->list flip?))
             (domain (array-domain array))
             (lowers (interval-lower-bounds->list domain))
             (uppers (interval-upper-bounds->list domain))
             (transform
              (lambda (multi-index)
                (map (lambda (i_k l_k u_k f_k?)
                       (if f_k?
                           (- (+ u_k l_k -1) i_k)
                           i_k))
                     multi-index lowers uppers flips))))
        (cond ((specialized-array? array)
               (specialized-array-share
                array
                domain
                (lambda multi-index
                  (apply values (transform multi-index)))))
              ((mutable-array? array)
               (let ((getter (array-getter array))
                     (setter (array-setter array)))
                 (make-array domain
                             (lambda multi-index
                               (apply getter (transform multi-index)))
                             (lambda (v . multi-index)
                               (apply setter v (transform multi-index))))))
              (else
               (let ((getter (array-getter array)))
                 (make-array domain
                             (lambda multi-index
                               (apply getter (transform multi-index)))))))))

    (define (my-interval-cartesian-product . args)
      (make-interval
       (list->vector (apply append (map interval-lower-bounds->list args)))
       (list->vector (apply append (map interval-upper-bounds->list args)))))

    (define make-pgm   cons)
    (define pgm-greys  car)
    (define pgm-pixels cdr)

    (define (read-pgm file)
      (define (read-pgm-object port)
        (skip-white-space port)
        (let ((o (read port)))
          (read-char port)    ; to skip the newline or next whitespace
          (if (eof-object? o)
              (error "reached end of pgm file")
              o)))
      (define (skip-to-end-of-line port)
        (let loop ((ch (read-char port)))
          (if (not (eq? ch #\newline))
              (loop (read-char port)))))
      (define (white-space? ch)
        (case ch
          ((#\newline #\space #\tab) #t)
          (else #f)))
      (define (skip-white-space port)
        (let ((ch (peek-char port)))
          (cond ((white-space? ch) (read-char port) (skip-white-space port))
                ((eq? ch #\#) (skip-to-end-of-line port)(skip-white-space port))
                (else #f))))
      (call-with-input-file file
        (lambda (port)
          ;; We're going to read text for a while,
          ;; then switch to binary.
          ;; So we need to turn off buffering until
          ;; we switch to binary.
          ;;(port-settings-set! port '(buffering: #f))
          (let* ((header (read-pgm-object port))
                 (columns (read-pgm-object port))
                 (rows (read-pgm-object port))
                 (greys (read-pgm-object port)))

            ;; now we switch back to buffering
            ;; to speed things up
            ;; (port-settings-set! port '(buffering: #t))
            (make-pgm greys
                      (array-copy
                       (make-array
                        (make-interval (vector rows columns))
                        (cond ((or (eq? header 'p5) ;; pgm binary
                                   (eq? header 'P5))
                               (if (< greys 256)
                                   (lambda (i j) ;; one byte/pixel
                                     (char->integer (read-char port)))
                                   (lambda (i j) ;; two bytes/pixel, little-endian
                                     (let* ((first-byte
                                             (char->integer (read-char port)))
                                            (second-byte
                                             (char->integer (read-char port))))
                                       (+ (* second-byte 256) first-byte)))))
                              ((or (eq? header 'p2) ;; pgm ascii
                                   (eq? header 'P2))
                               (lambda (i j)
                                 (read port)))
                              (else
                               (error "read-pgm: not a pgm file"))))))))))

    (define (write-pgm pgm-data file . force-ascii)
      (call-with-output-file file
        (lambda (port)
          (let* ((greys
                  (pgm-greys pgm-data))
                 (pgm-array
                  (pgm-pixels pgm-data))
                 (domain
                  (array-domain pgm-array))
                 (rows
                  (fx- (interval-upper-bound domain 0)
                       (interval-lower-bound domain 0)))
                 (columns
                  (fx- (interval-upper-bound domain 1)
                       (interval-lower-bound domain 1))))
            (if (and (pair? force-ascii) (car force-ascii))
                (display "P2" port)
                (display "P5" port))
            (newline port)
            (display columns port) (display " " port)
            (display rows port) (newline port)
            (display greys port) (newline port)
            (array-for-each
             (if (and (pair? force-ascii) (car force-ascii))
                 (let ((next-pixel-in-line 1))
                   (lambda (p)
                     (write p port)
                     (if (fxzero? (fxand next-pixel-in-line 15))
                         (begin
                           (newline port)
                           (set! next-pixel-in-line 1))
                         (begin
                           (display " " port)
                           (set! next-pixel-in-line
                                 (fx+ 1 next-pixel-in-line))))))
                 (if (fx<? greys 256)
                     (lambda (p)
                       (write-u8 p port))
                     (lambda (p)
                       (write-u8 (fxand p 255) port)
                       (write-u8 (fxarithmetic-shift-right p 8) port))))
             pgm-array)))))

    ;;(define test-pgm (read-pgm "girl.pgm"))

    (define (array-dot-product a b)
      (array-foldl (lambda (x y)
                     (+ x y))
                   0
                   (array-map
                    (lambda (x y)
                      (* x y))
                    a b)))

    (define (array-convolve source filter)
      (let* ((source-domain
              (array-domain source))
             (S_
              (array-getter source))
             (filter-domain
              (array-domain filter))
             (F_
              (array-getter filter))
             (result-domain
              (interval-dilate
               source-domain
               ;; left bound of an interval is an equality,
               ;; right bound is an inequality, hence the
               ;; the difference in the following two expressions
               (vector-map -
                           (interval-lower-bounds->vector filter-domain))
               (vector-map (lambda (x)
                             (- 1 x))
                           (interval-upper-bounds->vector filter-domain)))))
        (make-array
         result-domain
         (lambda (i j)
           (array-foldl
            (lambda (p q)
              (+ p q))
            0
            (make-array
             filter-domain
             (lambda (k l)
               (* (S_ (+ i k)
                      (+ j l))
                  (F_ k l)))))))))

    ;; (define sharpen-filter
    ;;   (list->array
    ;;    '(0 -1  0
    ;;        -1  5 -1
    ;;        0 -1  0)
    ;;    (make-interval '#(-1 -1) '#(2 2))))

    ;; (define edge-filter
    ;;   (list->array
    ;;    '(0 -1  0
    ;;        -1  4 -1
    ;;        0 -1  0)
    ;;    (make-interval '#(-1 -1) '#(2 2))))

    (define (round-and-clip pixel max-grey)
      (max 0 (min (exact (round pixel)) max-grey)))

    (define (array-sum a)
      (array-foldl + 0 a))
    (define (array-max a)
      (array-foldl max -inf.0 a))

    (define (max-norm a)
      (array-max (array-map abs a)))
    (define (one-norm a)
      (array-sum (array-map abs a)))

    (define (operator-max-norm a)
      (max-norm (array-map one-norm (array-curry (array-permute a '#(1 0)) 1))))
    (define (operator-one-norm a)
      ;; The "permutation" to apply here is the identity, so we omit it.
      (max-norm (array-map one-norm (array-curry a 1))))

    (define (make-separable-transform ~1D-transform)
      (lambda (a)
        (let ((n (array-dimension a)))
          (do ((d 0 (fx+ d 1)))
              ((fx=? d n))
            (array-for-each
             ~1D-transform
             (array-curry (array-rotate a d) 1))))))

    (define (recursively-apply-transform-and-downsample transform)
      (lambda (a)
        (let ((sample-vector (make-vector (array-dimension a) 2)))
          (define (helper a)
            (if (fx<? 1 (interval-upper-bound (array-domain a) 0))
                (begin
                  (transform a)
                  (helper (array-sample a sample-vector)))))
          (helper a))))

    (define (recursively-downsample-and-apply-transform transform)
      (lambda (a)
        (let ((sample-vector (make-vector (array-dimension a) 2)))
          (define (helper a)
            (if (fx<? 1 (interval-upper-bound (array-domain a) 0))
                (begin
                  (helper (array-sample a sample-vector))
                  (transform a))))
          (helper a))))

    (define (~1D-Haar-loop a)
      (let ((a_ (array-getter a))
            (a! (array-setter a))
            (n (interval-upper-bound (array-domain a) 0)))
        (do ((i 0 (fx+ i 2)))
            ((fx=? i n))
          (let* ((a_i               (a_ i))
                 (a_i+1             (a_ (fx+ i 1)))
                 (scaled-sum        (fl/ (fl+ a_i a_i+1) (flsqrt 2.0)))
                 (scaled-difference (fl/ (fl- a_i a_i+1) (flsqrt 2.0))))
            (a! scaled-sum i)
            (a! scaled-difference (fx+ i 1))))))

    (define ~1D-Haar-transform
      (recursively-apply-transform-and-downsample ~1D-Haar-loop))

    (define ~1D-Haar-inverse-transform
      (recursively-downsample-and-apply-transform ~1D-Haar-loop))

    (define hyperbolic-Haar-transform
      (make-separable-transform ~1D-Haar-transform))

    (define hyperbolic-Haar-inverse-transform
      (make-separable-transform ~1D-Haar-inverse-transform))

    (define Haar-transform
      (recursively-apply-transform-and-downsample
       (make-separable-transform ~1D-Haar-loop)))

    (define Haar-inverse-transform
      (recursively-downsample-and-apply-transform
       (make-separable-transform ~1D-Haar-loop)))

    (define (LU-decomposition A)
      ;; Assumes the domain of A is [0,n)\\times [0,n)
      ;; and that Gaussian elimination can be applied
      ;; without pivoting.
      (let ((n
             (interval-upper-bound (array-domain A) 0))
            (A_
             (array-getter A)))
        (do ((i 0 (fx+ i 1)))
            ((= i (fx- n 1)) A)
          (let* ((pivot
                  (A_ i i))
                 (column/row-domain
                  ;; both will be one-dimensional
                  (make-interval (vector (+ i 1))
                                 (vector n)))
                 (column
                  ;; the column below the (i,i) entry
                  (specialized-array-share A
                                           column/row-domain
                                           (lambda (k)
                                             (values k i))))
                 (row
                  ;; the row to the right of the (i,i) entry
                  (specialized-array-share A
                                           column/row-domain
                                           (lambda (k)
                                             (values i k))))
                 ;; the subarray to the right and
                 ;;below the (i,i) entry
                 (subarray
                  (array-extract
                   A (make-interval
                      (vector (fx+ i 1) (fx+ i 1))
                      (vector n         n)))))
            ;; compute multipliers
            (array-assign!
             column
             (array-map (lambda (x)
                          (/ x pivot))
                        column))
            ;; subtract the outer product of i'th
            ;; row and column from the subarray
            (array-assign!
             subarray
             (array-map -
                        subarray
                        (array-outer-product * column row)))))))

    ;; We'll define a brief, not-very-efficient matrix multiply routine.
    (define (matrix-multiply a b)
      (let ((a-rows
             ;; We copy this array because its elements are accessed
             ;; multiple times.
             (array-copy (array-curry a 1)))
            (b-columns
             ;; We copy this array because its elements are accessed
             ;; multiple times.
             (array-copy (array-curry (array-rotate b 1) 1))))
        (array-outer-product array-dot-product a-rows b-columns)))

    (define (inner-product A f g B)
      (array-outer-product
       (lambda (a b)
         (array-reduce f (array-map g a b)))
       (array-copy (array-curry A 1))
       (array-copy (array-curry (array-rotate B 1) 1))))

    (define (x2x2-matrix-multiply-into! A B C)
      (let ((C! (array-setter C))
            (A_ (array-getter A))
            (B_ (array-getter B)))
        (C! (+ (* (A_ 0 0) (B_ 0 0))
               (* (A_ 0 1) (B_ 1 0)))
            0 0)
        (C! (+ (* (A_ 0 0) (B_ 0 1))
               (* (A_ 0 1) (B_ 1 1)))
            0 1)
        (C! (+ (* (A_ 1 0) (B_ 0 0))
               (* (A_ 1 1) (B_ 1 0)))
            1 0)
        (C! (+ (* (A_ 1 0) (B_ 0 1))
               (* (A_ 1 1) (B_ 1 1)))
            1 1)))

    (define (run-tests)

      (random-source-pseudo-randomize! default-random-source 7 23)

      (test-begin "srfi-179: nonempty intervals and generalized arrays")

      (test-group "interval tests"
        (test-error (make-interval 1 '#(3 4)))
        (test-error (make-interval '#(1 1)  3))
        (test-error (make-interval '#(1 1)  '#(3)))
        (test-assert (interval? (make-interval '#() '#())))
        (test-error (make-interval '#(1.)  '#(1)))
        (test-error (make-interval '#(1 #f)  '#(1 2)))
        (test-error (make-interval '#(1)  '#(1.)))
        (test-error (make-interval '#(1 1)  '#(1 #f)))
        (test-assert (interval? (make-interval '#(1)  '#(1))))
        (test-assert (interval? (make-interval '#(1 2 3)  '#(4 2 6))))
        (test-error (make-interval 1))
        (test-assert (interval? (make-interval '#())))
        (test-error (make-interval '#(1.)))
        (test-error (make-interval '#(-1)))

        (test (make-interval '#(11111)  '#(11112))
            (make-interval '#(11111) '#(11112)))

        (test (make-interval '#(1 2 3)  '#(4 5 6))
            (make-interval '#(1 2 3) '#(4 5 6)))

        (test-not (interval? #t))

        (test-assert (interval? (make-interval '#(1 2 3) '#(4 5 6))))

        (test-error (interval-dimension 1))

        (test 3
            (interval-dimension (make-interval '#(1 2 3) '#(4 5 6))))

        (test-error
         (interval-lower-bound 1 0))
        (test-error
         (interval-lower-bound (make-interval '#(1 2 3) '#(4 5 6)) #f))
        (test-error
         (interval-lower-bound (make-interval '#(1 2 3) '#(4 5 6)) 1.))
        (test-error
         (interval-lower-bound (make-interval '#(1 2 3) '#(4 5 6)) -1))
        (test-error
         (interval-lower-bound (make-interval '#(1 2 3) '#(4 5 6)) 3))
        (test-error
         (interval-lower-bound (make-interval '#(1 2 3) '#(4 5 6)) 4))
        (test-error
         (interval-upper-bound 1 0))
        (test-error
         (interval-upper-bound (make-interval '#(1 2 3) '#(4 5 6)) #f))
        (test-error
         (interval-upper-bound (make-interval '#(1 2 3) '#(4 5 6)) 1.))
        (test-error
         (interval-upper-bound (make-interval '#(1 2 3) '#(4 5 6)) -1))
        (test-error
         (interval-upper-bound (make-interval '#(1 2 3) '#(4 5 6)) 3))
        (test-error
         (interval-upper-bound (make-interval '#(1 2 3) '#(4 5 6)) 4))
        (test-error
         (interval-lower-bounds->list 1))
        (test-error
         (interval-upper-bounds->list #f))

        (do ((i 0 (+ i 1)))
            ((= i tests))
          (let* ((lower (map (lambda (x) (random 10))
                             (vector->list (make-vector (random 1 11)))))
                 (upper (map (lambda (x) (+ (random 1 11) x))
                             lower)))
            (let ((interval (make-interval (list->vector lower)
                                           (list->vector upper)))
                  (offset (random (length lower))))
              (test (list-ref lower offset)
                  (interval-lower-bound interval offset))
              (test (list-ref upper offset)
                  (interval-upper-bound interval offset))
              (test lower
                  (interval-lower-bounds->list interval))
              (test upper
                  (interval-upper-bounds->list interval)))))

        (test-error (interval-lower-bounds->vector 1))
        (test-error (interval-upper-bounds->vector #f))

        (do ((i 0 (+ i 1)))
            ((= i tests))
          (let* ((lower (map (lambda (x) (random 10))
                             (vector->list (make-vector (random 1 11)))))
                 (upper (map (lambda (x) (+ (random 1 11) x))
                             lower)))
            (let ((interval (make-interval (list->vector lower)
                                           (list->vector upper)))
                  (offset (random (length lower))))
              (test (list-ref lower offset)
                  (interval-lower-bound interval offset))
              (test (list-ref upper offset)
                  (interval-upper-bound interval offset))
              (test (list->vector lower)
                  (interval-lower-bounds->vector interval))
              (test (list->vector upper)
                  (interval-upper-bounds->vector interval)))))

        (test-error (interval-projections 1 1))
        (test-error (interval-projections (make-interval '#(0) '#(1)) #t))
        (test-error (interval-projections (make-interval '#(0 0) '#(1 1)) 1/2))
        (test-error (interval-projections (make-interval '#(0 0) '#(1 1)) 1.))
        (test-assert (interval-projections (make-interval '#(0 0) '#(1 1)) 0))
        (test-assert (interval-projections (make-interval '#(0 0) '#(1 1)) 2))

        (do ((i 0 (+ i 1)))
            ((= i tests))
          (let* ((lower (map (lambda (x) (random 10))
                             (vector->list (make-vector (random 3 11)))))
                 (upper (map (lambda (x) (+ (random 1 11) x))
                             lower))
                 (left-dimension (random 1 (- (length lower) 1)))
                 (right-dimension (- (length lower) left-dimension)))
            (test-values
             (interval-projections (make-interval (list->vector lower)
                                                  (list->vector upper))
                                   right-dimension)
             (values
              (make-interval (list->vector (take lower right-dimension))
                             (list->vector (take upper right-dimension)))
              (make-interval (list->vector (drop lower right-dimension))
                             (list->vector (drop upper right-dimension))))
             )))

        (test-error (interval-volume #f))

        (do ((i 0 (+ i 1)))
            ((= i tests))
          (let* ((lower (map (lambda (x) (random 10))
                             (vector->list (make-vector (random 1 11)))))
                 (upper (map (lambda (x) (+ (random 1 11) x))
                             lower)))
            (test (apply * (map - upper lower))
                (interval-volume (make-interval (list->vector lower)
                                                (list->vector upper))))))

        (test-error (interval= #f (make-interval '#(1 2 3) '#(4 5 6))))
        (test-error (interval= (make-interval '#(1 2 3) '#(4 5 6)) #f))

        (do ((i 0 (+ i 1)))
            ((= i tests))
          (let* ((lower1 (map (lambda (x) (random 2))
                              (vector->list (make-vector (random 1 6)))))
                 (upper1 (map (lambda (x) (+ (random 1 3) x)) lower1))
                 (lower2 (map (lambda (x) (random 2)) lower1))
                 (upper2 (map (lambda (x) (+ 1 (random 1 3) x)) lower2)))
            (test (and (equal? lower1 lower2) ; prob ~1/16
                       (equal? upper1 upper2))
                (interval= (make-interval (list->vector lower1)
                                          (list->vector upper1))
                           (make-interval (list->vector lower2)
                                          (list->vector upper2))))))

        (test-error (interval-subset? #f (make-interval '#(1 2 3) '#(4 5 6))))
        (test-error (interval-subset? (make-interval '#(1 2 3) '#(4 5 6)) #f))
        (test-error (interval-subset? (make-interval '#(1) '#(2))
                                      (make-interval '#(0 0) '#(1 2))))

        (do ((i 0 (+ i 1)))
            ((= i tests))
          (let* ((lower1 (map (lambda (x) (random 2))
                              (vector->list (make-vector (random 1 6)))))
                 (upper1 (map (lambda (x) (+ (random 1 3) x)) lower1))
                 (lower2 (map (lambda (x) (random 2)) lower1))
                 (upper2 (map (lambda (x) (+ (random 1 3) x)) lower2)))
            (test (and (every (lambda (x) (>= (car x) (cdr x)))
                              (map cons lower1 lower2))
                       (every (lambda (x) (<= (car x) (cdr x)))
                              (map cons upper1 upper2)))
                (interval-subset? (make-interval (list->vector lower1)
                                                 (list->vector upper1))
                                  (make-interval (list->vector lower2)
                                                 (list->vector upper2))))))

        (test-error (interval-contains-multi-index? 1 1))
        (test-error (interval-contains-multi-index?
                     (make-interval '#(1 2 3) '#(4 5 6)) 1))
        (test-error (interval-contains-multi-index?
                     (make-interval '#(1 2 3) '#(4 5 6)) 1 1/2 0.1))

        (let ((interval   (make-interval '#(1 2 3) '#(4 5 6)))
              (interval-2 (make-interval '#(10 11 12) '#(13 14 15))))
          (test-assert
              (array-every
               (lambda (x)
                 (apply interval-contains-multi-index? interval x))
               (make-array interval list)))
          (test-assert
              (array-every
               (lambda (x)
                 (not (apply interval-contains-multi-index? interval x)))
               (make-array interval-2 list))))

        (test-error (interval-for-each (lambda (x) x) 1))
        (test-error (interval-for-each 1 (make-interval '#(3) '#(4))))

        (do ((i 0 (+ i 1)))
            ((= i tests))
          (let* ((lower (map (lambda (x) (random 10))
                             (vector->list (make-vector (random 1 7)))))
                 (upper (map (lambda (x) (+ (random 1 4) x))
                             lower)))
            (let ((result '()))
              (define (f . args)
                (set! result (cons args result)))
              (test (reverse (all-elements lower upper))
                  (begin
                    (interval-for-each f
                                       (make-interval (list->vector lower)
                                                      (list->vector upper)))
                    result)))))

        (let ((interval (make-interval '#(0 0) '#(100 100))))
          (test-error (interval-dilate interval 'a '#(-10 10)))
          (test-error (interval-dilate 'a '#(10 10) '#(-10 -10)))
          (test-error (interval-dilate interval '#(10 10) 'a))
          (test-error (interval-dilate interval '#(10) '#(-10 -10)))
          (test-error (interval-dilate interval '#(10 10) '#( -10)))
          (test-error (interval-dilate interval '#(100 100) '#(-100 -100))))
        )

      (test-group "basic"
        (test-error (make-array 1 values))
        (test-error (make-array (make-interval '#(3) '#(4)) 1))

        ;; (let ((getter (lambda args 1.)))
        ;;   (test (make-array (make-interval '#(3) '#(4)) getter)
        ;;       (make-%%array (make-interval '#(3) '#(4))
        ;;                     getter
        ;;                     #f
        ;;                     #f
        ;;                     #f
        ;;                     #f
        ;;                     #f
        ;;                     %%order-unknown)))

        (test-error (array-domain #f))
        (test-error (array-getter #f))

        (let* ((getter (lambda args 1.))
               (array    (make-array (make-interval '#(3) '#(4)) getter)))
          (test-not (array? #f))
          (test-assert (array? array))
          (test (make-interval '#(3) '#(4))
              (array-domain array))
          (test getter
              (array-getter array)))

        ;; (let ((result #f))
        ;;   (let ((getter (lambda (i) result))
        ;;         (setter   (lambda (v i) (set! result v)))
        ;;         (domain   (make-interval '#(3) '#(4))))
        ;;     (test (make-array domain
        ;;                       getter
        ;;                       setter)
        ;;         (make-%%array domain
        ;;                       getter
        ;;                       setter
        ;;                       #f
        ;;                       #f
        ;;                       #f
        ;;                       #f
        ;;                       %%order-unknown))))

        (test-error (array-setter #f))

        (let ((result (cons #f #f)))
          (let ((getter (lambda (i) (car result)))
                (setter   (lambda (v i) (set-car! result v)))
                (domain   (make-interval '#(3) '#(4))))
            (let ((array (make-array domain
                                     getter
                                     setter)))
              (test-assert (array? array))
              (test-assert (mutable-array? array))
              (test-not (mutable-array? 1))
              (test setter
                  (array-setter array))
              (test getter
                  (array-getter array))
              (test domain
                  (array-domain array)))))

        ;; (do ((i 0 (+ i 1)))
        ;;     ((= i tests))
        ;;   (let* ((lower-bounds
        ;;           (map (lambda (x) (random 2))
        ;;                (vector->list (make-vector (random 1 7)))))
        ;;          (upper-bounds
        ;;           (map (lambda (x) (+ x (random 1 3)))
        ;;                lower-bounds))
        ;;          (new-domain
        ;;           (make-interval (list->vector lower-bounds)
        ;;                          (list->vector upper-bounds)))
        ;;          (new-domain-dimension
        ;;           (interval-dimension new-domain))
        ;;          (old-domain-dimension
        ;;           (random 1 7))
        ;;          (base
        ;;           (random 100))
        ;;          (coefficients
        ;;           (map (lambda (x) (* (random-sign)
        ;;                           (random 20)))
        ;;                (local-iota 0 old-domain-dimension)))
        ;;          (old-indexer
        ;;           (lambda args
        ;;             (apply + base (map * args coefficients))))
        ;;          (new-domain->old-domain-coefficients
        ;;           (map (lambda (x)
        ;;                  (map (lambda (x) (* (random-sign) (random 10)))
        ;;                       (local-iota 0 new-domain-dimension)))
        ;;                (local-iota 0 old-domain-dimension)))
        ;;          (new-domain->old-domain
        ;;           (lambda args
        ;;             (apply values (map (lambda (row)
        ;;                                  (apply + (map * row args)))
        ;;                                new-domain->old-domain-coefficients)))))
        ;;     (if (not (and (myindexer=
        ;;                    (lambda args
        ;;                      (call-with-values
        ;;                          (lambda () (apply new-domain->old-domain args))
        ;;                        old-indexer))
        ;;                    (%%compose-indexers old-indexer new-domain
        ;;                                        new-domain->old-domain)
        ;;                    new-domain)))
        ;;         (error (list new-domain
        ;;                      old-domain-dimension
        ;;                      base
        ;;                      coefficients
        ;;                      new-domain->old-domain-coefficients))
        ;;         )))

        ;; errors are not required to signal
        ;; (let ((a (make-array (make-interval '#(0 0) '#(1 1)) ;; not valid
        ;;                      values
        ;;                      values)))
        ;;   (test-error (array-body a))
        ;;   (test-error (array-indexer a))
        ;;   (test-error (array-storage-class a))
        ;;   (test-error (array-safe? a)))

        (test-error (make-specialized-array  'a))
        (test-error (make-specialized-array (make-interval '#(0) '#(10)) 'a))
        (test-error (make-specialized-array
                     (make-interval '#(0) '#(10))
                     generic-storage-class
                     'a))

        ;; We'll use specialized arrays with u1-storage-class---we never
        ;; use the array contents, just the indexers, and it saves storage.

        (test-error (array-packed? 1))
        (test-error (array-packed?
                     (make-array (make-interval '#(1 2)) list)))
        (test-error (array-packed?
                     (make-array (make-interval '#(1 2)) list list)))

        ;; all these are true, we'll have to see how to screw it up later.
        ;; (do ((i 0 (+ i 1)))
        ;;     ((= i tests))
        ;;   (let ((array
        ;;          (make-specialized-array (random-interval)
        ;;                                  u1-storage-class)))
        ;;     (test-assert (array-packed? array))))

        (let ((array
               (make-specialized-array (make-interval '#(0 0) '#(2 3)))))
          (test 2 (array-dimension array))
          (test 6 (interval-volume (array-domain array)))
          (do ((i 0 (+ i 1)))
              ((= i 2))
            (do ((j 0 (+ j 1)))
                ((= j 3))
              (array-set! array (+ j (* i 3)) i j)
              (test (+ j (* i 3))
                  (array-ref array i j)))))

        (let ((array
               (make-specialized-array (make-interval '#(-2 -1 3) '#(0 2 5)))))
          (test 3 (array-dimension array))
          (test 12 (interval-volume (array-domain array)))
          (do ((i -2 (+ i 1)))
              ((= i 0))
            (do ((j -1 (+ j 1)))
                ((= j 2))
              (do ((k 3 (+ k 1)))
                  ((= k 5))
                (let ((cell (+ k (* 2 (+ j (* i 3))))))
                  (array-set! array cell i j k)
                  (test cell (array-ref array i j k)))))))

        ;; the elements of curried arrays are in order
        (do ((i 0 (+ i 1)))
            ((= i tests))
          (let* ((base
                  (make-specialized-array (random-interval 2 5)
                                          u1-storage-class))
                 (curried
                  (array-curry base (random 1 (array-dimension base)))))
            (test-assert (array-every array-packed? curried))))

        (do ((i 0 (+ i 1)))
            ((= i tests))
          (let* ((base
                  (make-specialized-array (random-interval 2 6)
                                          u1-storage-class))
                 (extracted
                  (array-extract base (random-subinterval (array-domain base)))))
            (test (array-packed? extracted)
                (extracted-array-elements-in-order? base extracted))))

        ;; Should we do reversed now?
        (do ((i 0 (+ i 1)))
            ((= i tests))
          (let* ((base
                  (make-specialized-array (random-interval)
                                          u1-storage-class))
                 (domain
                  (array-domain base))
                 (reversed-dimensions
                  (vector-map (lambda args (random-boolean))
                              (make-vector (array-dimension base))))
                 (reversed
                  (array-reverse base reversed-dimensions)))
            (test (vector-every
                   (lambda (lower upper reversed?)
                     (or (= (+ 1 lower) upper) ;; side-length 1
                         (not reversed?))) ;; dimension not reversed
                   (interval-lower-bounds->vector domain)
                   (interval-upper-bounds->vector domain)
                   reversed-dimensions)
                (array-packed? reversed))))

        ;; permutations

        (do ((i 0 (+ i 1)))
            ((= i tests))
          (let* ((base
                  (make-specialized-array (random-interval)
                                          u1-storage-class))
                 (domain
                  (array-domain base))
                 (permutation
                  (random-permutation (array-dimension base)))
                 (permuted
                  (array-permute base permutation)))
            (test (permuted-array-elements-in-order? base permutation)
                (array-packed? permuted))))

        (do ((i 0 (+ i 1)))
            ((= i tests))
          (let* ((base
                  (make-specialized-array (random-nonnegative-interval 1 6)
                                          u1-storage-class))
                 (scales
                  (random-positive-vector (array-dimension base) 4))
                 (sampled
                  (array-sample base scales)))
            (test (sampled-array-elements-in-order? base scales)
                (array-packed? sampled))))

        ;; Now we need to test the precomputation and caching of
        ;; array-packed?
        ;; The only places we precompute are
        ;; 1.  after creating a new specialized array
        ;; 2.  in %%specialized-array-translate
        ;; 3.  in %%specialized-array-curry
        ;; 4.  reshaping a specialized array in place.
        ;; So we need to check these situations.

        ;; (let ((array (array-copy (make-array (make-interval '#(3 5)) list))))
        ;;   (test-assert (and (array-packed? array)
        ;;                     (%%compute-array-elements-in-order?
        ;;                      (%%array-domain array) (%%array-indexer array)))))

        ;; (do ((i 0 (+ i 1)))
        ;;     ((= i tests))
        ;;   (let* ((array
        ;;           (make-specialized-array (random-nonnegative-interval)
        ;;                                   u8-storage-class))
        ;;          (ignore ;; compute and cache the results
        ;;           (array-packed? array))
        ;;          (sampled-array
        ;;           (array-sample array (random-sample (array-dimension array))))
        ;;          (ignore ;; compute and cache the results
        ;;           ;; possibly not in order
        ;;           (array-packed? sampled-array))
        ;;          (translated-array
        ;;           (array-translate array
        ;;                            (vector-map (lambda (x) (random 10))
        ;;                                        (make-vector
        ;;                                         (array-dimension array)))))
        ;;          (translated-sampled-array
        ;;           (array-translate sampled-array
        ;;                            (vector-map (lambda (x) (random 10))
        ;;                                        (make-vector
        ;;                                         (array-dimension array))))))
        ;;     (test (%%compute-array-elements-in-order?
        ;;            (%%array-domain translated-array)
        ;;            (%%array-indexer translated-array))
        ;;         (array-packed? translated-array))
        ;;     (test (%%compute-array-elements-in-order?
        ;;            (%%array-domain translated-sampled-array)
        ;;            (%%array-indexer translated-sampled-array))
        ;;         (array-packed? translated-sampled-array))))

        ;; (do ((i 0 (+ i 1)))
        ;;     ((= i tests))
        ;;   (let* ((array
        ;;           (make-specialized-array (random-nonnegative-interval 2 4)
        ;;                                   u8-storage-class))
        ;;          (d-1
        ;;           (- (array-dimension array) 1))
        ;;          (ignore
        ;;           ;; compute and cache the result, in order
        ;;           (array-packed? array))
        ;;          (rotated-array
        ;;           (array-rotate array 1))
        ;;          (ignore ;; compute and cache the results
        ;;           ;; possibly not in order
        ;;           (array-packed? rotated-array))
        ;;          (sampled-array
        ;;           (array-sample array (list->vector (cons 2 (make-list d-1 1)))))
        ;;          (ignore
        ;;           ;; almost definitely not in order, but if we curry it
        ;;           ;; with dimension 1 the subarrays are in order.
        ;;           (array-packed? sampled-array))
        ;;          (curried-array
        ;;           (array-ref (array-curry array d-1)
        ;;                      (interval-lower-bound (array-domain array) 0)))
        ;;          (curried-rotated-array
        ;;           (array-ref
        ;;            (array-curry rotated-array d-1)
        ;;            (interval-lower-bound (array-domain rotated-array) 0)))
        ;;          (curried-sampled-array
        ;;           (array-ref
        ;;            (array-curry sampled-array d-1)
        ;;            (interval-lower-bound (array-domain sampled-array) 0))))
        ;;     (test (%%compute-array-elements-in-order?
        ;;            (%%array-domain curried-array)
        ;;            (%%array-indexer curried-array))
        ;;         (array-packed? curried-array))
        ;;     (test (%%compute-array-elements-in-order?
        ;;            (%%array-domain curried-rotated-array)
        ;;            (%%array-indexer curried-rotated-array))
        ;;         (array-packed? curried-rotated-array))
        ;;     (test (%%compute-array-elements-in-order?
        ;;            (%%array-domain curried-sampled-array)
        ;;            (%%array-indexer curried-sampled-array))
        ;;         (array-packed? curried-sampled-array))))
         
        ;; FIXME: array-reshape tests.

        ;; error tests

        ;; (test-error
        ;;  (%%move-array-elements
        ;;   (array-reverse (make-specialized-array (make-interval '#(2 2))))
        ;;   (make-array (make-interval '#(1 4)) list)
        ;;   ""))

        ;; (test-error
        ;;  (%%move-array-elements
        ;;   (make-specialized-array (make-interval '#(2 2)))
        ;;   (make-array (make-interval '#(1 5)) list)
        ;;   ""))

        ;; (test-error
        ;;  (%%move-array-elements
        ;;   (make-array (make-interval '#(2 2)) list list) ;; not a valid setter
        ;;   (make-array (make-interval '#(1 4)) list)
        ;;   ""))

        ;; (do ((d 1 (fx+ d 1)))
        ;;     ((= d 6))
        ;;   (let* ((uppers-list
        ;;           (iota d 2))
        ;;          (domain
        ;;           (make-interval (list->vector uppers-list)))
        ;;          (reversed-domain
        ;;           (make-interval (list->vector (reverse uppers-list)))))
        ;;     (do ((i 0 (fx+ i 1)))
        ;;         ;; distribute "tests" results over five dimensions
        ;;         ((= i (quotient tests 5)))
        ;;       (let* ((storage-class-and-initializer
        ;;               (random-storage-class-and-initializer))
        ;;              (storage-class
        ;;               (car storage-class-and-initializer))
        ;;              (initializer
        ;;               (cadr storage-class-and-initializer))
        ;;              (specialized-source
        ;;               (array-copy
        ;;                (make-array domain
        ;;                            (lambda args
        ;;                              (initializer)))
        ;;                storage-class))
        ;;              (rotated-specialized-source
        ;;               (array-rotate specialized-source (- d 1)))
        ;;              (specialized-reversed-source
        ;;               (array-copy
        ;;                (make-array reversed-domain
        ;;                            (lambda args
        ;;                              (initializer)))
        ;;                storage-class))
        ;;              (specialized-destination
        ;;               (make-specialized-array domain
        ;;                                       storage-class))
        ;;              (specialized-reversed-destination
        ;;               (make-specialized-array reversed-domain
        ;;                                       storage-class))
        ;;              (source
        ;;               (make-array domain
        ;;                           (array-getter
        ;;                            (array-reverse specialized-source))))
        ;;              (destination
        ;;               (make-array (array-domain specialized-destination)
        ;;                           (array-getter specialized-destination)
        ;;                           (array-setter specialized-destination)))
        ;;              (rotated-specialized-source
        ;;               (array-rotate specialized-source (- d 1)))
        ;;              (rotated-source
        ;;               (array-rotate source (- d 1)))
        ;;              (reversed-source
        ;;               (make-array reversed-domain
        ;;                           (array-getter specialized-reversed-source)))
        ;;              (reversed-destination
        ;;               (make-array reversed-domain
        ;;                           (array-getter specialized-reversed-source)
        ;;                           (array-setter specialized-reversed-source))))
        ;;         ;; specialized-to-specialized, use fast copy
        ;;         (test-error (%%move-array-elements specialized-destination
        ;;                                            specialized-source "test: "))
        ;;         (test-assert
        ;;             (myarray= specialized-source specialized-destination))
        ;;         ;; fast copying between specialized of the same volume
        ;;         (test-error (%%move-array-elements specialized-destination
        ;;                                            specialized-reversed-source
        ;;                                            "test: "))
        ;;         ;; copy to adjacent elements of destination, checking needed
        ;;         (test-error
        ;;          (%%move-array-elements specialized-destination source "test: "))
        ;;         (test-assert (myarray= source specialized-destination))
        ;;         ;; copy to adjacent elements of destination, no checking needed
        ;;         ;; arrays of different shapes
        ;;         (test-error (%%move-array-elements specialized-destination
        ;;                                            rotated-specialized-source
        ;;                                            "test: "))
        ;;         (test (array->list rotated-specialized-source)
        ;;             (array->list specialized-destination))
        ;;         ;; copy to adjacent elements of destination, checking needed
        ;;         ;; arrays of different shapes
        ;;         (test-error (%%move-array-elements specialized-destination
        ;;                                            rotated-source "test: "))
        ;;         (test (array->list rotated-source)
        ;;             (array->list specialized-destination))
        ;;         ;; copy to non-adjacent elements of destination, no
        ;;         ;; checking needed
        ;;         (test-error (%%move-array-elements
        ;;                      (array-reverse specialized-destination)
        ;;                      specialized-source "test: "))
        ;;         (test-assert (myarray= specialized-source
        ;;                                (array-reverse specialized-destination)))
        ;;         ;; copy to non-specialized array
        ;;         (test-error (%%move-array-elements destination source "test: "))
        ;;         (test-assert (myarray= destination source))
        ;;         ))))

        (test-error (array-copy #f generic-storage-class))
        (test-error (array-copy (make-array (make-interval '#(1) '#(2))
                                            list)
                                #f))
        (test-error (array-copy (make-array (make-interval '#(1) '#(2))
                                            list)
                                generic-storage-class
                                'a))
        (test-error (array-copy (make-array (make-interval '#(1) '#(2))
                                            list)
                                generic-storage-class
                                (make-interval '#(10))))
        (test-error (array-copy (make-array (make-interval '#(1) '#(2))
                                            list)
                                generic-storage-class
                                #f
                                'a))

        ;; (test-error (array-copy (make-array (make-interval '#(1) '#(2))
        ;;                                     list)
        ;;                         generic-storage-class
        ;;                         #f
        ;;                         #f
        ;;                         'a))

        ;; We gotta make sure than the error checks work in all dimensions ...
        (test-error (array-copy (make-array (make-interval '#(1) '#(2))
                                            list)
                                u16-storage-class))
        (test-error (array-copy (make-array (make-interval '#(1 1) '#(2 2))
                                            list)
                                u16-storage-class))
        (test-error (array-copy (make-array (make-interval '#(1 1 1) '#(2 2 2))
                                            list)
                                u16-storage-class))
        (test-error (array-copy (make-array (make-interval '#(1 1 1 1)
                                                           '#(2 2 2 2))
                                            list)
                                u16-storage-class))
        (test-error (array-copy (make-array (make-interval '#(1 1 1 1 1)
                                                           '#(2 2 2 2 2))
                                            list)
                                u16-storage-class))
        (test-error (specialized-array-default-safe? 'a))
        (test-error (specialized-array-default-mutable? 'a))

        ;; (let ((mutable-default (specialized-array-default-mutable?)))
        ;;   (specialized-array-default-mutable? #f)
        ;;   (do ((i 1 (+ i 1)))
        ;;       ((= i 6))
        ;;     (let ((A (array-copy (make-array (make-interval (make-vector i 2))
        ;;                                      (lambda args 10)))))
        ;;       (test-error (apply array-set! A 0 (make-list i 0)))
        ;;       (test-error (array-assign! A A))))
        ;;   (specialized-array-default-mutable? mutable-default))

        (specialized-array-default-safe? #t)

        ;; (do ((i 0 (+ i 1)))
        ;;     ((= i tests))
        ;;   (let* ((domain
        ;;           (random-interval))
        ;;          (lower-bounds
        ;;           (interval-lower-bounds->list domain))
        ;;          (upper-bounds
        ;;           (interval-upper-bounds->list domain))
        ;;          (array1
        ;;           (let ((alist '()))
        ;;             (make-array
        ;;              domain
        ;;              (lambda indices
        ;;                (cond ((assoc indices alist)
        ;;                       => cdr)
        ;;                      (else
        ;;                       indices)))
        ;;              (lambda (value . indices)
        ;;                (cond ((assoc indices alist)
        ;;                       =>(lambda (entry)
        ;;                           (set-cdr! entry value)))
        ;;                      (else
        ;;                       (set! alist (cons (cons indices value)
        ;;                                         alist))))))))
        ;;          (array2
        ;;           (array-copy array1 generic-storage-class))
        ;;          (setter1
        ;;           (array-setter array1))
        ;;          (setter2
        ;;           (array-setter array2)))
        ;;     (do ((j 0 (+ j 1)))
        ;;         ((= j 25))
        ;;       (let ((v (random 1000))
        ;;             (indices (map random lower-bounds upper-bounds)))
        ;;         (apply setter1 v indices)
        ;;         (apply setter2 v indices)))
        ;;     (test-assert (myarray= array1 array2))
        ;;     (test-assert (myarray= (array-copy array1 generic-storage-class)
        ;;                            array2))
        ;;     ))

        (specialized-array-default-safe? #f)

        ;; (do ((i 0 (+ i 1)))
        ;;     ((= i tests))
        ;;   (let* ((domain
        ;;           (random-interval))
        ;;          (lower-bounds
        ;;           (interval-lower-bounds->list domain))
        ;;          (upper-bounds
        ;;           (interval-upper-bounds->list domain))
        ;;          (array1
        ;;           (let ((alist '()))
        ;;             (make-array
        ;;              domain
        ;;              (lambda indices
        ;;                (cond ((assoc indices alist)
        ;;                       => cdr)
        ;;                      (else
        ;;                       indices)))
        ;;              (lambda (value . indices)
        ;;                (cond ((assoc indices alist)
        ;;                       =>(lambda (entry)
        ;;                           (set-cdr! entry value)))
        ;;                      (else
        ;;                       (set! alist (cons (cons indices value)
        ;;                                         alist))))))))
        ;;          (array2
        ;;           (array-copy array1 generic-storage-class ))
        ;;          (setter1
        ;;           (array-setter array1))
        ;;          (setter2
        ;;           (array-setter array2)))
        ;;     (do ((j 0 (+ j 1)))
        ;;         ((= j 25))
        ;;       (let ((v (random 1000))
        ;;             (indices (map random lower-bounds upper-bounds)))
        ;;         (apply setter1 v indices)
        ;;         (apply setter2 v indices)))
        ;;     (test-assert (myarray= array1 array2))
        ;;     (test-assert (myarray= (array-copy array1 generic-storage-class)
        ;;                            array2))
        ;;     ))

        (test-error (array-map 1 #f))
        (test-error (array-map list 1 (make-array (make-interval '#(3) '#(4))
                                                  list)))
        (test-error (array-map list (make-array (make-interval '#(3) '#(4))
                                                list) 1))
        (test-error (array-map list
                               (make-array (make-interval '#(3) '#(4))
                                           list)
                               (make-array (make-interval '#(3 4) '#(4 5))
                                           list)))
        (test-error (array-every 1 2))
        (test-error (array-every list 1))
        (test-error (array-every list
                                 (make-array (make-interval '#(3) '#(4))
                                             list)
                                 1))
        (test-error (array-every list
                                 (make-array (make-interval '#(3) '#(4))
                                             list)
                                 (make-array (make-interval '#(3 4) '#(4 5))
                                             list)))
        (test-error (array-any 1 2))
        (test-error (array-any list 1))
        (test-error (array-any list
                               (make-array (make-interval '#(3) '#(4))
                                           list)
                               1))
        (test-error (array-any list
                               (make-array (make-interval '#(3) '#(4))
                                           list)
                               (make-array (make-interval '#(3 4) '#(4 5))
                                           list)))

        ;; (do ((i 0 (+ i 1)))
        ;;     ((= i tests))
        ;;   (let* ((interval
        ;;           (random-nonnegative-interval 1 6))
        ;;          (n
        ;;           (interval-volume interval))
        ;;          (separator
        ;;           ;; I want to make sure that the last item is chosen at least
        ;;           ;; once for each random
        ;;           (random (max 0 (- n 10)) n))
        ;;          (indexer
        ;;           (%%interval->basic-indexer interval))
        ;;          (arguments-1
        ;;           '())
        ;;          (array-1
        ;;           (make-array
        ;;            interval
        ;;            (lambda args
        ;;              (set! arguments-1 (cons args
        ;;                                      arguments-1))
        ;;              (let ((index (apply indexer args)))
        ;;                (cond
        ;;                 ((< index separator)
        ;;                  #f)
        ;;                 ((= index separator)
        ;;                  1)
        ;;                 (else
        ;;                  (error "The array should never be called with these args"
        ;;                         interval
        ;;                         separator
        ;;                         args
        ;;                         index)))))))
        ;;          (arguments-2
        ;;           '())
        ;;          (array-2
        ;;           (make-array
        ;;            interval
        ;;            (lambda args
        ;;              (set! arguments-2 (cons args
        ;;                                      arguments-2))
        ;;              (let ((index (apply indexer args)))
        ;;                (cond
        ;;                 ((< index separator)
        ;;                  #t)
        ;;                 ((= index separator)
        ;;                  #f)
        ;;                 (else
        ;;                  (error "The array should never be called with these args"
        ;;                         interval
        ;;                         separator
        ;;                         args
        ;;                         index))))))))
        ;;     (test 1
        ;;         (array-any values array-1))
        ;;     (test-not (array-every values array-2))
        ;;     (test-assert (indices-in-proper-order (reverse arguments-1)))
        ;;     (test-assert (indices-in-proper-order (reverse arguments-2)))
        ;;     ))

        (test-error (array-foldl 1 1 1))
        (test-error (array-foldl list 1 1))
        (test-error (array-foldr 1 1 1))
        (test-error (array-foldr list 1 1))
        (test-error (array-for-each 1 #f))
        (test-error (array-for-each list 1 (make-array (make-interval '#(3) '#(4))
                                                       list)))
        (test-error (array-for-each list (make-array (make-interval '#(3) '#(4))
                                                     list) 1))
        (test-error (array-for-each list
                                    (make-array (make-interval '#(3) '#(4))
                                                list)
                                    (make-array (make-interval '#(3 4) '#(4 5))
                                                list)))

        (specialized-array-default-safe? #t)

        ;; (let ((array-builders
        ;;        (vector
        ;;         (list u1-storage-class      (lambda indices (random 0 (expt 2 1))))
        ;;         (list u8-storage-class      (lambda indices (random 0 (expt 2 8))))
        ;;         (list u16-storage-class     (lambda indices (random 0 (expt 2 16))))
        ;;         (list u32-storage-class     (lambda indices (random 0 (expt 2 32))))
        ;;         (list u64-storage-class     (lambda indices (random 0 (expt 2 64))))
        ;;         (list s8-storage-class
        ;;               (lambda indices (random (- (expt 2 7))  (expt 2 7))))
        ;;         (list s16-storage-class
        ;;               (lambda indices (random (- (expt 2 15)) (expt 2 15))))
        ;;         (list s32-storage-class
        ;;               (lambda indices (random (- (expt 2 31)) (expt 2 31))))
        ;;         (list s64-storage-class
        ;;               (lambda indices (random (- (expt 2 63)) (expt 2 63))))
        ;;         (list f32-storage-class
        ;;               (lambda indices (random-real)))
        ;;         (list f64-storage-class
        ;;               (lambda indices (random-real)))
        ;;         (list c64-storage-class
        ;;               (lambda indices (make-rectangular (random-real) (random-real))))
        ;;         (list c128-storage-class
        ;;               (lambda indices (make-rectangular (random-real) (random-real))))
        ;;         (list generic-storage-class
        ;;               (lambda indices indices)))))
        ;;   (do ((i 0 (+ i 1)))
        ;;       ((= i tests))
        ;;     (let* ((domain
        ;;             (random-interval))
        ;;            (lower-bounds
        ;;             (interval-lower-bounds->list domain))
        ;;            (upper-bounds
        ;;             (interval-upper-bounds->list domain))
        ;;            (array-length
        ;;             (lambda (a)
        ;;               (let ((upper-bounds
        ;;                      (interval-upper-bounds->list (array-domain a)))
        ;;                     (lower-bounds
        ;;                      (interval-lower-bounds->list (array-domain a))))
        ;;                 (apply * (map - upper-bounds lower-bounds)))))
        ;;            (arrays
        ;;             (map (lambda (ignore)
        ;;                    (let ((array-builder
        ;;                           (vector-ref array-builders
        ;;                                       (random
        ;;                                        (vector-length array-builders)))))
        ;;                      (array-copy (make-array domain
        ;;                                              (cadr array-builder))
        ;;                                  (car array-builder))))
        ;;                  (local-iota 0 (random 1 7))))
        ;;            (result-array-1
        ;;             (apply array-map
        ;;                    list
        ;;                    arrays))
        ;;            (result-array-2
        ;;             (array-copy
        ;;              (apply array-map
        ;;                     list
        ;;                     arrays)))
        ;;            (getters
        ;;             (map array-getter arrays))
        ;;            (result-array-3
        ;;             (make-array domain
        ;;                         (lambda indices
        ;;                           (map (lambda (g) (apply g indices)) getters)))))
        ;;       (test-assert
        ;;           (and (myarray= result-array-1 result-array-2)
        ;;                (myarray= result-array-2 result-array-3)
        ;;                (equal? (vector->list (array-body result-array-2))
        ;;                        (reverse (array-fold (lambda (x y) (cons x y))
        ;;                                             '()
        ;;                                             result-array-2)))
        ;;                (equal? (vector->list (array-body result-array-2))
        ;;                        (reverse (let ((result '()))
        ;;                                   (array-for-each
        ;;                                    (lambda (f)
        ;;                                      (set! result (cons f result)))
        ;;                                    result-array-2)
        ;;                                   result)))
        ;;                (equal?  (map array-length arrays)
        ;;                         (map (lambda (array)
        ;;                                ((storage-class-length
        ;;                                  (array-storage-class array))
        ;;                                 (array-body array)))
        ;;                              arrays))))
        ;;       )))

        (specialized-array-default-safe? #f)

        ;; (let ((array-builders
        ;;        (vector
        ;;         (list u1-storage-class      (lambda indices (random (expt 2 1))))
        ;;         (list u8-storage-class      (lambda indices (random (expt 2 8))))
        ;;         (list u16-storage-class     (lambda indices (random (expt 2 16))))
        ;;         (list u32-storage-class     (lambda indices (random (expt 2 32))))
        ;;         (list u64-storage-class     (lambda indices (random (expt 2 64))))
        ;;         (list s8-storage-class
        ;;               (lambda indices (random (- (expt 2 7))  (expt 2 7))))
        ;;         (list s16-storage-class
        ;;               (lambda indices (random (- (expt 2 15)) (expt 2 15))))
        ;;         (list s32-storage-class
        ;;               (lambda indices (random (- (expt 2 31)) (expt 2 31))))
        ;;         (list s64-storage-class
        ;;               (lambda indices (random (- (expt 2 63)) (expt 2 63))))
        ;;         (list f32-storage-class
        ;;               (lambda indices (random-real)))
        ;;         (list f64-storage-class
        ;;               (lambda indices (random-real)))
        ;;         (list c64-storage-class
        ;;               (lambda indices (make-rectangular (random-real) (random-real))))
        ;;         (list c128-storage-class
        ;;               (lambda indices (make-rectangular (random-real) (random-real))))
        ;;         (list generic-storage-class (lambda indices indices)))))
        ;;   (do ((i 0 (+ i 1)))
        ;;       ((= i tests))
        ;;     (let* ((domain
        ;;             (random-interval))
        ;;            ;;(_ (begin (write `(domain: ,domain)) (newline)))
        ;;            (lower-bounds
        ;;             (interval-lower-bounds->list domain))
        ;;            (upper-bounds
        ;;             (interval-upper-bounds->list domain))
        ;;            (arrays
        ;;             (map (lambda (ignore)
        ;;                    (let ((array-builder
        ;;                           (vector-ref array-builders
        ;;                                       (random
        ;;                                        (vector-length array-builders)))))
        ;;                      (array-copy (make-array domain
        ;;                                              (cadr array-builder))
        ;;                                  (car array-builder))))
        ;;                  (local-iota 0 (random 1 7))))
        ;;            (result-array-1
        ;;             (apply array-map
        ;;                    list
        ;;                    arrays))
        ;;            (result-array-2
        ;;             (array-copy
        ;;              (apply array-map
        ;;                     list
        ;;                     arrays)))
        ;;            (getters
        ;;             (map array-getter arrays))
        ;;            (result-array-3
        ;;             (make-array domain
        ;;                         (lambda indices
        ;;                           (map (lambda (g) (apply g indices)) getters)))))
        ;;       (test-assert
        ;;           (and (myarray= result-array-1 result-array-2)
        ;;                (myarray= result-array-2 result-array-3)
        ;;                (equal? (vector->list (array-body result-array-2))
        ;;                        (reverse (array-fold cons
        ;;                                             '()
        ;;                                             result-array-2)))
        ;;                (equal? (vector->list (array-body result-array-2))
        ;;                        (reverse (let ((result '()))
        ;;                                   (array-for-each
        ;;                                    (lambda (f)
        ;;                                      (set! result (cons f result)))
        ;;                                    result-array-2)
        ;;                                   result))))))))

        (test-error (array-reduce 'a 'a))
        (test-error (array-reduce 'a (make-array (make-interval '#(1) '#(3))
                                                 list)))

        (let ((A (make-array (make-interval '#(1) '#(11))
                             (lambda (i)
                               (if (even? i)
                                   (matrix 1 i
                                           0 1)
                                   (matrix 1 0
                                           i 1))))))
          (test (array-foldr x2x2-multiply (matrix 1 0 0 1) A)
              (array-reduce x2x2-multiply A))
          (test-not (equal? (array-reduce x2x2-multiply A)
                            (array-foldl x2x2-multiply (matrix 1 0 0 1) A))))

        (let ((A_2 (make-array (make-interval '#(1 1) '#(3 7))
                               (lambda (i j)
                                 (if (and (even? i) (even? j))
                                     (matrix 1 i
                                             j 1)
                                     (matrix 1 j
                                             i -1))))))
          (test (array-foldr x2x2-multiply (matrix 1 0 0 1) A_2)
              (array-reduce x2x2-multiply A_2))
          (test-not (equal? (array-reduce x2x2-multiply A_2)
                            (array-foldl x2x2-multiply (matrix 1 0 0 1) A_2)))
          (test-not (equal? (array-reduce x2x2-multiply A_2)
                            (array-reduce x2x2-multiply (array-rotate A_2 1)))))

        (let ((A_3 (make-array (make-interval '#(1 1 1) '#(3 5 4))
                               (lambda (i j k)
                                 (if (and (even? i) (even? j))
                                     (matrix 1 i
                                             j k)
                                     (matrix k j
                                             i -1))))))
          (test (array-foldr x2x2-multiply (matrix 1 0 0 1) A_3)
              (array-reduce x2x2-multiply A_3))
          (test-not (equal? (array-reduce x2x2-multiply A_3)
                            (array-foldl x2x2-multiply (matrix 1 0 0 1) A_3)))
          (test-not (equal? (array-reduce x2x2-multiply A_3)
                            (array-reduce x2x2-multiply (array-rotate A_3 1)))))

        (let ((A_4 (make-array (make-interval '#(1 1 1 1) '#(3 2 4 3))
                               (lambda (i j k l)
                                 (if (and (even? i) (even? j))
                                     (matrix l i
                                             j k)
                                     (matrix l k
                                             i j))))))
          (test (array-foldr x2x2-multiply (matrix 1 0 0 1) A_4)
              (array-reduce x2x2-multiply A_4))
          (test-not (equal? (array-reduce x2x2-multiply A_4)
                            (array-foldl x2x2-multiply (matrix 1 0 0 1) A_4)))
          (test-not (equal? (array-reduce x2x2-multiply A_4)
                            (array-reduce x2x2-multiply (array-rotate A_4 1)))))

        (let ((A_5 (make-array (make-interval '#(1 1 1 1 1) '#(3 2 4 3 3))
                               (lambda (i j k l m)
                                 (if (even? m)
                                     (matrix (+ m l) i
                                             j k)
                                     (matrix (- l m) k
                                             i j))))))
          (test (array-foldr x2x2-multiply (matrix 1 0 0 1) A_5)
              (array-reduce x2x2-multiply A_5))
          (test-not (equal? (array-reduce x2x2-multiply A_5)
                            (array-foldl x2x2-multiply (matrix 1 0 0 1) A_5)))
          (test-not (equal? (array-reduce x2x2-multiply A_5)
                            (array-reduce x2x2-multiply (array-rotate A_5 1)))))

        (test-error (array-curry 'a 1))
        (test-error
         (array-curry (make-array (make-interval '#(0) '#(1)) list)  'a))
        ;; (test-error
        ;;  (array-curry (make-array (make-interval '#(0 0) '#(1 1)) list)  0))
        ;; (test-error
        ;;  (array-curry (make-array (make-interval '#(0 0) '#(1 1)) list)  2))

        ;; (let ((array-builders
        ;;        (vector
        ;;         (list u1-storage-class      (lambda indices (random (expt 2 1))))
        ;;         (list u8-storage-class      (lambda indices (random (expt 2 8))))
        ;;         (list u16-storage-class     (lambda indices (random (expt 2 16))))
        ;;         (list u32-storage-class     (lambda indices (random (expt 2 32))))
        ;;         (list u64-storage-class     (lambda indices (random (expt 2 64))))
        ;;         (list s8-storage-class
        ;;               (lambda indices (random (- (expt 2 7))  (expt 2 7))))
        ;;         (list s16-storage-class
        ;;               (lambda indices (random (- (expt 2 15)) (expt 2 15))))
        ;;         (list s32-storage-class
        ;;               (lambda indices (random (- (expt 2 31)) (expt 2 31))))
        ;;         (list s64-storage-class
        ;;               (lambda indices (random (- (expt 2 63)) (expt 2 63))))
        ;;         (list f32-storage-class
        ;;               (lambda indices (random-real)))
        ;;         (list f64-storage-class
        ;;               (lambda indices (random-real)))
        ;;         (list c64-storage-class
        ;;               (lambda indices (make-rectangular (random-real) (random-real))))
        ;;         (list c128-storage-class
        ;;               (lambda indices (make-rectangular (random-real) (random-real))))
        ;;         (list generic-storage-class
        ;;               (lambda indices indices)))))
        ;;   (do ((i 0 (+ i 1)))
        ;;       ((= i tests))
        ;;     (let* ((domain
        ;;             (random-interval 2 7))
        ;;            (lower-bounds
        ;;             (interval-lower-bounds->list domain))
        ;;            (upper-bounds
        ;;             (interval-upper-bounds->list domain))
        ;;            (array-builder
        ;;             (vector-ref array-builders
        ;;                         (random (vector-length array-builders))))
        ;;            (random-array-element
        ;;             (cadr array-builder))
        ;;            (storage-class
        ;;             (car array-builder))
        ;;            (Array
        ;;             (array-copy (make-array domain
        ;;                                     random-array-element)
        ;;                         storage-class))
        ;;            (copied-array
        ;;             (array-copy Array
        ;;                         storage-class))
        ;;            (inner-dimension
        ;;             (random 1 (interval-dimension domain)))
        ;;            (domains
        ;;             (call-with-values
        ;;                 (lambda () (interval-projections domain inner-dimension))
        ;;               list))
        ;;            (outer-domain
        ;;             (car domains))
        ;;            (inner-domain
        ;;             (cadr domains))
        ;;            (immutable-curry
        ;;             (array-curry (make-array (array-domain Array)
        ;;                                      (array-getter Array))
        ;;                          inner-dimension))
        ;;            (mutable-curry
        ;;             (array-curry (make-array (array-domain Array)
        ;;                                      (array-getter Array)
        ;;                                      (array-setter Array))
        ;;                          inner-dimension))
        ;;            (specialized-curry
        ;;             (array-curry Array inner-dimension))
        ;;            (immutable-curry-from-definition
        ;;             (call-with-values
        ;;                 (lambda () (interval-projections (array-domain Array)
        ;;                                              inner-dimension))
        ;;               (lambda (outer-interval inner-interval)
        ;;                 (make-array
        ;;                  outer-interval
        ;;                  (lambda outer-multi-index
        ;;                    (make-array
        ;;                     inner-interval
        ;;                     (lambda inner-multi-index
        ;;                       (apply (array-getter Array)
        ;;                              (append outer-multi-index
        ;;                                      inner-multi-index)))))))))
        ;;            (mutable-curry-from-definition
        ;;             (call-with-values
        ;;                 (lambda () (interval-projections (array-domain Array)
        ;;                                              inner-dimension))
        ;;               (lambda (outer-interval inner-interval)
        ;;                 (make-array
        ;;                  outer-interval
        ;;                  (lambda outer-multi-index
        ;;                    (make-array
        ;;                     inner-interval
        ;;                     (lambda inner-multi-index
        ;;                       (apply (array-getter Array)
        ;;                              (append outer-multi-index
        ;;                                      inner-multi-index)))
        ;;                     (lambda (v . inner-multi-index)
        ;;                       (apply (array-setter Array) v
        ;;                              (append outer-multi-index
        ;;                                      inner-multi-index)))))))))
        ;;            (specialized-curry-from-definition
        ;;             (call-with-values
        ;;                 (lambda () (interval-projections (array-domain Array)
        ;;                                              inner-dimension))
        ;;               (lambda (outer-interval inner-interval)
        ;;                 (make-array
        ;;                  outer-interval
        ;;                  (lambda outer-multi-index
        ;;                    (specialized-array-share
        ;;                     Array
        ;;                     inner-interval
        ;;                     (lambda inner-multi-index
        ;;                       (apply values
        ;;                              (append outer-multi-index
        ;;                                      inner-multi-index))))))))))
        ;;       ;; mutate the curried array
        ;;       (for-each
        ;;        (lambda (curried-array)
        ;;          (let ((outer-getter
        ;;                 (array-getter curried-array)))
        ;;            (do ((i 0 (+ i 1)))
        ;;                ((= i 50)) ;; used to be tests, not 50, but 50 will do fine
        ;;              (call-with-values
        ;;                  (lambda ()
        ;;                    (random-multi-index outer-domain))
        ;;                (lambda outer-multi-index
        ;;                  (let ((inner-setter
        ;;                         (array-setter (apply outer-getter
        ;;                                              outer-multi-index))))
        ;;                    (call-with-values
        ;;                        (lambda ()
        ;;                          (random-multi-index inner-domain))
        ;;                      (lambda inner-multi-index
        ;;                        (let ((new-element
        ;;                               (random-array-element)))
        ;;                          (apply inner-setter
        ;;                                 new-element
        ;;                                 inner-multi-index)
        ;;                          ;; mutate the copied array without currying
        ;;                          (apply (array-setter copied-array)
        ;;                                 new-element
        ;;                                 (append outer-multi-index
        ;;                                         inner-multi-index)))))))))))
        ;;        (list mutable-curry
        ;;              specialized-curry
        ;;              mutable-curry-from-definition
        ;;              specialized-curry-from-definition
        ;;              ))

        ;;       (and (or (myarray= Array copied-array) (error "Arggh"))
        ;;            (or (array-every array? immutable-curry) (error "Arggh"))
        ;;            (or (array-every (lambda (a) (not (mutable-array? a)))
        ;;                             immutable-curry)
        ;;                (error "Arggh"))
        ;;            (or (array-every mutable-array? mutable-curry) (error "Arggh"))
        ;;            (or (array-every (lambda (a) (not (specialized-array? a)))
        ;;                             mutable-curry)
        ;;                (error "Arggh"))
        ;;            (or (array-every specialized-array? specialized-curry)
        ;;                (error "Arggh"))
        ;;            (or (array-every
        ;;                 (lambda (xy) (apply myarray= xy))
        ;;                 (array-map list immutable-curry
        ;;                            immutable-curry-from-definition))
        ;;                (error "Arggh"))
        ;;            (or (array-every
        ;;                 (lambda (xy) (apply myarray= xy))
        ;;                 (array-map list mutable-curry
        ;;                            mutable-curry-from-definition))
        ;;                (error "Arggh"))
        ;;            (or (array-every
        ;;                 (lambda (xy) (apply myarray= xy))
        ;;                 (array-map list specialized-curry
        ;;                            specialized-curry-from-definition))
        ;;                (error "Arggh"))))))

        (test-error (specialized-array-share 1 1 1))
        (test-error (specialized-array-share
                     (make-specialized-array (make-interval '#(1) '#(2)))
                     1 1))
        ;; (test-error (specialized-array-share
        ;;              (make-specialized-array (make-interval '#(1) '#(2)))
        ;;              (make-interval '#(0) '#(1))
        ;;              1))

        (test-assert
            (myarray= (list->array (make-interval '#(0) '#(10))
                                   (reverse (local-iota 0 10)))
                      (specialized-array-share
                       (list->array (make-interval '#(0) '#(10))
                                    (local-iota 0 10))
                       (make-interval '#(0) '#(10))
                       (lambda (i)
                         (- 9 i)))))

        ;; (do ((i 0 (+ i 1)))
        ;;     ((= i tests))
        ;;   (let* ((n (random 1 11))
        ;;          (permutation (random-permutation n))
        ;;          (input-vec
        ;;           (list->vector (f64vector->list (random-f64vector n)))))
        ;;     (test (%%vector-permute input-vec permutation)
        ;;         (vector-permute input-vec permutation))
        ;;     (test (vector-permute input-vec permutation)
        ;;         (list->vector (%%vector-permute->list input-vec permutation)))))

        (specialized-array-default-safe? #t)

        ;; (do ((i 0 (+ i 1)))
        ;;     ((= i tests))
        ;;   (let* ((interval (random-interval))
        ;;          (axes (local-iota 0 (interval-dimension interval)))
        ;;          (lower-bounds (interval-lower-bounds->vector interval))
        ;;          (upper-bounds (interval-upper-bounds->vector interval))
        ;;          (a (array-copy (make-array interval list)))
        ;;          (new-axis-order
        ;;           (vector-permute (list->vector axes)
        ;;                           (random-permutation (length axes))))
        ;;          (reverse-order?
        ;;           (list->vector (map (lambda (x) (zero? (random 2))) axes))))
        ;;     (let ((b (make-array
        ;;               (make-interval (vector-permute lower-bounds new-axis-order)
        ;;                              (vector-permute upper-bounds new-axis-order))
        ;;               (lambda multi-index
        ;;                 (apply
        ;;                  (array-getter a)
        ;;                  (let* ((n (vector-length new-axis-order))
        ;;                         (multi-index-vector
        ;;                          (list->vector multi-index))
        ;;                         (result (make-vector n)))
        ;;                    (do ((i 0 (+ i 1)))
        ;;                        ((= i n) (vector->list result))
        ;;                      (vector-set!
        ;;                       result
        ;;                       (vector-ref new-axis-order i)
        ;;                       (if (vector-ref reverse-order?
        ;;                                       (vector-ref new-axis-order i))
        ;;                           (+ (vector-ref lower-bounds
        ;;                                          (vector-ref new-axis-order i))
        ;;                              (- (vector-ref upper-bounds
        ;;                                             (vector-ref new-axis-order i))
        ;;                                 (vector-ref multi-index-vector i)
        ;;                                 1))
        ;;                           (vector-ref multi-index-vector i)))))))))
        ;;           (c (specialized-array-share
        ;;               a
        ;;               (make-interval (vector-permute lower-bounds new-axis-order)
        ;;                              (vector-permute upper-bounds new-axis-order))
        ;;               (lambda multi-index
        ;;                 (apply
        ;;                  values
        ;;                  (let* ((n (vector-length new-axis-order))
        ;;                         (multi-index-vector (list->vector multi-index))
        ;;                         (result (make-vector n)))
        ;;                    (do ((i 0 (+ i 1)))
        ;;                        ((= i n) (vector->list result))
        ;;                      (vector-set!
        ;;                       result
        ;;                       (vector-ref new-axis-order i)
        ;;                       (if (vector-ref reverse-order?
        ;;                                       (vector-ref new-axis-order i))
        ;;                           (+ (vector-ref lower-bounds
        ;;                                          (vector-ref new-axis-order i))
        ;;                              (- (vector-ref upper-bounds
        ;;                                             (vector-ref new-axis-order i))
        ;;                                 (vector-ref multi-index-vector i)
        ;;                                 1))
        ;;                           (vector-ref multi-index-vector i))))))))))
        ;;       (test-assert (myarray= b c)))))

        (specialized-array-default-safe? #f)

        ;; (do ((i 0 (+ i 1)))
        ;;     ((= i tests))
        ;;   (let* ((interval (random-interval))
        ;;          (axes (local-iota 0 (interval-dimension interval)))
        ;;          (lower-bounds (interval-lower-bounds->vector interval))
        ;;          (upper-bounds (interval-upper-bounds->vector interval))
        ;;          (a (array-copy (make-array interval list)))
        ;;          (new-axis-order
        ;;           (vector-permute (list->vector axes)
        ;;                           (random-permutation (length axes))))
        ;;          (reverse-order?
        ;;           (list->vector (map (lambda (x) (zero? (random 2))) axes))))
        ;;     (let ((b (make-array
        ;;               (make-interval (vector-permute lower-bounds new-axis-order)
        ;;                              (vector-permute upper-bounds new-axis-order))
        ;;               (lambda multi-index
        ;;                 (apply
        ;;                  (array-getter a)
        ;;                  (let* ((n (vector-length new-axis-order))
        ;;                         (multi-index-vector (list->vector multi-index))
        ;;                         (result (make-vector n)))
        ;;                    (do ((i 0 (+ i 1)))
        ;;                        ((= i n) (vector->list result))
        ;;                      (vector-set!
        ;;                       result
        ;;                       (vector-ref new-axis-order i)
        ;;                       (if (vector-ref reverse-order?
        ;;                                       (vector-ref new-axis-order i))
        ;;                           (+ (vector-ref lower-bounds
        ;;                                          (vector-ref new-axis-order i))
        ;;                              (- (vector-ref upper-bounds
        ;;                                             (vector-ref new-axis-order i))
        ;;                                 (vector-ref multi-index-vector i)
        ;;                                 1))
        ;;                           (vector-ref multi-index-vector i)))))))))
        ;;           (c (specialized-array-share
        ;;               a
        ;;               (make-interval
        ;;                (vector-permute lower-bounds new-axis-order)
        ;;                (vector-permute upper-bounds new-axis-order))
        ;;               (lambda multi-index
        ;;                 (apply
        ;;                  values
        ;;                  (let* ((n (vector-length new-axis-order))
        ;;                         (multi-index-vector (list->vector multi-index))
        ;;                         (result (make-vector n)))
        ;;                    (do ((i 0 (+ i 1)))
        ;;                        ((= i n) (vector->list result))
        ;;                      (vector-set!
        ;;                       result
        ;;                       (vector-ref new-axis-order i)
        ;;                       (if (vector-ref reverse-order?
        ;;                                       (vector-ref new-axis-order i))
        ;;                           (+ (vector-ref lower-bounds
        ;;                                          (vector-ref new-axis-order i))
        ;;                              (- (vector-ref upper-bounds
        ;;                                             (vector-ref new-axis-order i))
        ;;                                 (vector-ref multi-index-vector i)
        ;;                                 1))
        ;;                           (vector-ref multi-index-vector i))))))))))
        ;;       (test-assert (myarray= b c)))))

        (let ((int (make-interval '#(0 0) '#(10 10)))
              (translation '#(10 -2)))
          (test-error (interval-translate 'a 10))
          (test-error (interval-translate int 10))
          (test-error (interval-translate int '#(a b)))
          (test-error (interval-translate int '#(1. 2.)))
          (test-error (interval-translate int '#(1)))
          (do ((i 0 (+ i 1)))
              ((= i tests))
            (let* ((int (random-interval))
                   (lower-bounds (interval-lower-bounds->vector int))
                   (upper-bounds (interval-upper-bounds->vector int))
                   (translation
                    (list->vector
                     (map (lambda (x)
                            (random -10 10))
                          (local-iota 0 (vector-length lower-bounds))))))
              (interval= (interval-translate int translation)
                         (make-interval
                          (vector-map + lower-bounds translation)
                          (vector-map + upper-bounds translation)))))
          )

        (let* ((specialized-array
                (array-copy (make-array (make-interval '#(0 0) '#(10 12))
                                        list)))
               (mutable-array (let ((temp (array-copy specialized-array)))
                                (make-array (array-domain temp)
                                            (array-getter temp)
                                            (array-setter temp))))
               (immutable-array (make-array (array-domain mutable-array)
                                            (array-getter mutable-array)))
               (translation '#(10 -2)))

          (test-error (array-translate 'a 1))
          (test-error (array-translate immutable-array '#(1.)))
          (test-error (array-translate immutable-array '#(0 2 3)))
          (let ((specialized-result
                 (array-translate specialized-array translation)))
            (test-assert (specialized-array? specialized-result)))
          (let ((mutable-result (array-translate mutable-array translation)))
            (test-assert (and (mutable-array? mutable-array)
                              (not (specialized-array? mutable-array))
                              (mutable-array? mutable-result)
                              (not (specialized-array? mutable-result)))))
          (let ((immutable-result (array-translate immutable-array translation)))
            (test-assert (and (array? immutable-array)
                              (not (mutable-array? immutable-array))
                              (array? immutable-result)
                              (not (mutable-array? immutable-result)))))

          ;; (do ((i 0 (+ i 1)))
          ;;     ((= i tests))
          ;;   (let* ((domain (random-interval))
          ;;          (Array (let ((temp (make-array domain list)))
          ;;                   (case (random-integer 3)
          ;;                     ((0) temp)
          ;;                     ((1) (array-copy temp))
          ;;                     ((2) (let ((temp (array-copy temp)))
          ;;                            (make-array (array-domain temp)
          ;;                                        (array-getter temp)
          ;;                                        (array-setter temp)))))))
          ;;          (translation
          ;;           (list->vector
          ;;            (map (lambda (x) (random -10 10))
          ;;                 (vector->list (%%interval-lower-bounds domain))))))
          ;;     (let ((translated-array       (array-translate Array translation))
          ;;           (my-translated-array (my-array-translate Array translation)))
          ;;       (if (mutable-array? Array)
          ;;           (let ((translated-domain
          ;;                  (interval-translate domain translation)))
          ;;             (do ((j 0 (+ j 1)))
          ;;                 ((= j 50))
          ;;               (call-with-values
          ;;                   (lambda ()
          ;;                     (random-multi-index translated-domain))
          ;;                 (lambda multi-index
          ;;                   (let ((value (random-integer 10000)))
          ;;                     (apply (array-setter translated-array)
          ;;                            value multi-index)
          ;;                     (apply (array-setter my-translated-array)
          ;;                            value multi-index)))))))
          ;;       (test-assert
          ;;           (myarray= (array-translate Array translation)
          ;;                     (my-array-translate Array translation))))))
          )
        (test 2 ;; no list
            (array->list* (make-array (make-interval '#()) (lambda () 2))))
        (test '()
            (array->list* (make-array (make-interval '#(0)) error)))
        (test '()
            (array->list* (make-array (make-interval '#(0 0)) error)))
        (test '(() ())
            (array->list* (make-array (make-interval '#(2 0)) error)))
        (test '()
            (array->list* (make-array (make-interval '#(0 2)) error)))

        (test 2 ;; no vector
            (array->vector* (make-array (make-interval '#()) (lambda () 2))))
        (test '#()
            (array->vector* (make-array (make-interval '#(0)) error)))
        (test '#()
            (array->vector* (make-array (make-interval '#(0 0)) error)))
        (test '#(#() #())
            (array->vector* (make-array (make-interval '#(2 0)) error)))
        )

      (test-group "permutation tests"
        (let* ((specialized
                (make-specialized-array (make-interval '#(0 0 0 0 0)
                                                       '#(1 1 1 1 1))))
               (mutable (make-array (array-domain specialized)
                                    (array-getter specialized)
                                    (array-setter specialized)))
               (A (array-translate  mutable '#(0 0 0 0 0))))
          (test-error ((array-getter A) 0 0))
          (test-error ((array-setter A) 'a 0 0)))

        (let ((int (make-interval '#(0 0) '#(10 10)))
              (permutation '#(1 0)))
          (test-error (interval-permute 'a 10))
          (test-error (interval-permute int 10))
          (test-error (interval-permute int '#(a b)))
          (test-error (interval-permute int '#(1. 2.)))
          (test-error (interval-permute int '#(10 -2)))
          (test-error (interval-permute int '#(0)))
          (do ((i 0 (+ i 1)))
              ((= i tests))
            (let* ((int (random-interval))
                   (lower-bounds (interval-lower-bounds->vector int))
                   (upper-bounds (interval-upper-bounds->vector int))
                   (permutation
                    (random-permutation (vector-length lower-bounds))))
              (interval=
               (interval-permute int permutation)
               (make-interval (vector-permute lower-bounds permutation)
                              (vector-permute upper-bounds permutation))))))

        (let* ((specialized-array
                (array-copy (make-array (make-interval '#(0 0) '#(10 12))
                                        list)))
               (mutable-array (let ((temp (array-copy specialized-array)))
                                (make-array (array-domain temp)
                                            (array-getter temp)
                                            (array-setter temp))))
               (immutable-array (make-array (array-domain mutable-array)
                                            (array-getter mutable-array)))
               (permutation '#(1 0)))

          (test-error (array-permute 'a 1))
          (test-error (array-permute immutable-array '#(1.)))
          (test-error (array-permute immutable-array '#(2)))
          (test-error (array-permute immutable-array '#(0 1 2)))
          (let ((specialized-result
                 (array-permute specialized-array permutation)))
            (test-assert (specialized-array? specialized-result)))
          (let ((mutable-result (array-permute mutable-array permutation)))
            (test-assert (and (mutable-array? mutable-array)
                              (not (specialized-array? mutable-array))
                              (mutable-array? mutable-result)
                              (not (specialized-array? mutable-result)))))
          (let ((immutable-result (array-permute immutable-array permutation)))
            (test-assert (and (array? immutable-array)
                              (not (mutable-array? immutable-array))
                              (array? immutable-result)
                              (not (mutable-array? immutable-result)))))

          (specialized-array-default-safe? #t)

          (do ((i 0 (+ i 1)))
              ((= i tests))
            (let* ((domain (random-interval))
                   (Array (let ((temp (make-array domain list)))
                            (case (random-integer 3)
                              ((0) temp)
                              ((1) (array-copy temp))
                              ((2) (let ((temp (array-copy temp)))
                                     (make-array (array-domain temp)
                                                 (array-getter temp)
                                                 (array-setter temp)))))))
                   (permutation
                    (random-permutation (interval-dimension domain))))
              (let* ((permuted-array       (array-permute Array permutation))
                     (my-permuted-array (my-array-permute Array permutation)))
                (let ((permuted-domain (interval-permute domain permutation)))
                  (do ((j 0 (+ j 1)))
                      ((= j 50))
                    (call-with-values
                        (lambda ()
                          (random-multi-index permuted-domain))
                      (lambda multi-index
                        (test (apply (array-getter my-permuted-array)
                                     multi-index)
                            (apply (array-getter permuted-array)
                                   multi-index))))))
                (if (mutable-array? Array)
                    (let ((permuted-domain
                           (interval-permute domain permutation)))
                      (do ((j 0 (+ j 1)))
                          ((= j 50))
                        (call-with-values
                            (lambda ()
                              (random-multi-index permuted-domain))
                          (lambda multi-index
                            (let ((value (random-integer 10000)))
                              (apply (array-setter permuted-array) value
                                     multi-index)
                              (apply (array-setter my-permuted-array) value
                                     multi-index)))))))
                (test-assert (myarray= permuted-array
                                       my-permuted-array)))))

          (specialized-array-default-safe? #f)

          (do ((i 0 (+ i 1)))
              ((= i tests))
            (let* ((domain (random-interval))
                   (Array (let ((temp (make-array domain list)))
                            (case (random-integer 3)
                              ((0) temp)
                              ((1) (array-copy temp))
                              ((2) (let ((temp (array-copy temp)))
                                     (make-array (array-domain temp)
                                                 (array-getter temp)
                                                 (array-setter temp)))))))
                   (permutation
                    (random-permutation (interval-dimension domain)))
                   (permuted-array       (array-permute Array permutation))
                   (my-permuted-array (my-array-permute Array permutation))
                   (permuted-domain (interval-permute domain permutation)))
              ;;(write `(permuted: ,permuted-array my-permuted: ,my-permuted-array)) (newline)
              (do ((j 0 (+ j 1)))
                  ((= j 50))
                (call-with-values
                    (lambda () (random-multi-index permuted-domain))
                  (lambda multi-index
                    ;;(write `(multi-index: ,multi-index domain: ,permuted-domain)) (newline)
                    (test (apply (array-getter my-permuted-array) multi-index)
                        (apply (array-getter permuted-array) multi-index)))))
              (if (mutable-array? Array)
                  (let ((permuted-domain
                         (interval-permute domain permutation)))
                    (do ((j 0 (+ j 1)))
                        ((= j 50))
                      (call-with-values
                          (lambda ()
                            (random-multi-index permuted-domain))
                        (lambda multi-index
                          (let ((value (random-integer 10000)))
                            (apply (array-setter permuted-array) value
                                   multi-index)
                            (apply (array-setter my-permuted-array) value
                                   multi-index)))))))
              (test-assert (myarray= permuted-array
                                     my-permuted-array))))
          )

        ;; because array-rotate is built using the array-permute
        ;; infrastructure, we won't test as much

        (test-error (array-rotate 1 1))
        (test-error
         (array-rotate (make-array (make-interval '#(0 0) '#(2 3)) list) 'a))
        (test-error
         (array-rotate (make-array (make-interval '#(0 0) '#(2 3)) list) 1.))
        (test-error
         (array-rotate (make-array (make-interval '#(0 0) '#(2 3)) list) 1/2))
        (test-error
         (array-rotate (make-array (make-interval '#(0 0) '#(2 3)) list) -1))
        (test-error
         (array-rotate (make-array (make-interval '#(0 0) '#(2 3)) list) 4))
        (test-error (interval-rotate 1 1))
        (test-error (interval-rotate (make-interval '#(0 0) '#(2 3)) 'a))
        (test-error (interval-rotate (make-interval '#(0 0) '#(2 3)) 1.))
        (test-error (interval-rotate (make-interval '#(0 0) '#(2 3)) 37))

        (for-each
         (lambda (n)
           (let* ((upper-bounds (make-vector n 2))
                  (lower-bounds (make-vector n 0))
                  (domain (make-interval lower-bounds upper-bounds))
                  (A (array-copy (make-array domain list)))
                  (immutable-A
                   (let ((A (array-copy A))) ;; copy A
                     (make-array domain
                                 (array-getter A))))
                  (mutable-A
                   (let ((A (array-copy A))) ;; copy A
                     (make-array domain
                                 (array-getter A)
                                 (array-setter A)))))
             (for-each (lambda (dim)
                         (let ((permutation
                                (list->vector
                                 (append
                                  (local-iota dim n)
                                  (local-iota 0 dim)))))
                           (let ((rA
                                  (array-rotate A dim))
                                 (pA
                                  (array-permute A permutation)))
                             (if (not (and (specialized-array? rA)
                                           (specialized-array? pA)
                                           (myarray= rA pA)))
                                 (error "blah rotate specialized")))
                           (let ((rA
                                  (array-rotate immutable-A dim))
                                 (pA
                                  (array-permute immutable-A permutation)))
                             (if (not (and (array? rA)
                                           (array? pA)
                                           (myarray= rA pA)))
                                 (error "blah rotate immutable")))
                           (let ((rA
                                  (array-rotate mutable-A dim))
                                 (pA
                                  (array-permute mutable-A permutation)))
                             (if (not (and (mutable-array? rA)
                                           (mutable-array? pA)
                                           (myarray= rA pA)))
                                 (error "blah rotate mutable")))
                           (test (array-domain (array-rotate mutable-A dim))
                               (interval-rotate (array-domain A) dim))))
                       (iota n))))
         (iota 5 1))
        )

      (test-group "intersect/scale/sample"
        (let ((a (make-interval '#(0 0) '#(10 10)))
              (b (make-interval '#(0) '#(10)))
              (c (make-interval '#(10 10) '#(20 20))))
          (test-error (interval-intersect 'a))
          (test-error (interval-intersect  a 'a))
          (test-error (interval-intersect a b)))

        (do ((i 0 (+ i 1)))
            ((= i tests))
          (let* ((dimension (random 1 6))
                 (number-of-intervals (random 1 4))
                 (intervals (map (lambda (x)
                                   (random-interval dimension (+ dimension 1)))
                                 (local-iota 0 number-of-intervals))))
            (test (apply interval-intersect intervals)
                (apply my-interval-intersect intervals))))

        (test-error (interval-scale 1 'a))
        (test-error (interval-scale (make-interval '#(1) '#(2)) 'a))
        (test-error (interval-scale (make-interval '#(0) '#(1)) 'a))
        (test-error (interval-scale (make-interval '#(0) '#(1)) '#(a)))
        (test-error (interval-scale (make-interval '#(0) '#(1)) '#(0)))
        (test-error (interval-scale (make-interval '#(0) '#(1)) '#(1.)))
        (test-error (interval-scale (make-interval '#(0) '#(1)) '#(1 2)))

        (do ((i 0 (fx+ i 1)))
            ((fx=? i tests))
          (let* ((interval (random-nonnegative-interval))
                 (scales (random-positive-vector (interval-dimension interval))))
            (test (my-interval-scale interval scales)
                (interval-scale interval scales))))

        (test-error (array-sample 'a 'a))
        (test-error
         (array-sample (make-array (make-interval '#(1) '#(2)) list) 'a))
        (test-error
         (array-sample (make-array (make-interval '#(0) '#(2)) list) 'a))
        (test-error
         (array-sample (make-array (make-interval '#(0) '#(2)) list) '#(1.)))
        (test-error
         (array-sample (make-array (make-interval '#(0) '#(2)) list) '#(0)))
        (test-error
         (array-sample (make-array (make-interval '#(0) '#(2)) list) '#(2 1)))

        (do ((i 0 (+ i 1)))
            ((= i tests))
          (let* ((domain (random-nonnegative-interval 1 6))
                 (Array (let ((temp (make-array domain list)))
                          (case (random-integer 3)
                            ((0) temp)
                            ((1) (array-copy temp))
                            ((2) (let ((temp (array-copy temp)))
                                   (make-array (array-domain temp)
                                               (array-getter temp)
                                               (array-setter temp)))))))
                 (scales (random-positive-vector (interval-dimension domain)))
                 (sampled-array (array-sample Array scales))
                 (my-sampled-array (myarray-sample Array scales)))

            (if (mutable-array? Array)
                (let ((scaled-domain (interval-scale domain scales)))
                  (do ((j 0 (+ j 1)))
                      ((= j 50))
                    (call-with-values
                        (lambda ()
                          (random-multi-index scaled-domain))
                      (lambda multi-index
                        (let ((value (random-integer 10000)))
                          (apply (array-setter sampled-array) value multi-index)
                          (apply (array-setter my-sampled-array) value
                                 multi-index)))))))
            (test-assert (myarray= sampled-array
                                   my-sampled-array))))

        (test-error
         (array-extract (make-array (make-interval '#(0 0) '#(1 1)) list)
                        'a))
        (test-error (array-extract 'a (make-interval '#(0 0) '#(1 1))))
        (test-error
         (array-extract (make-array (make-interval '#(0 0) '#(1 1)) list)
                        (make-interval '#(0) '#(1))))
        (test-error
         (array-extract (make-array (make-interval '#(0 0) '#(1 1)) list)
                        (make-interval '#(0 0) '#(1 3))))
        (do ((i 0 (fx+ i 1)))
            ((fx=? i tests))
          (let* ((domain (random-interval))
                 (subdomain (random-subinterval domain))
                 (spec-A (array-copy (make-array domain list)))
                 (spec-A-extract (array-extract spec-A subdomain))
                 (mut-A (let ((A-prime (array-copy spec-A)))
                          (make-array domain
                                      (array-getter A-prime)
                                      (array-setter A-prime))))
                 (mut-A-extract (array-extract mut-A subdomain))
                 (immutable-A (let ((A-prime (array-copy spec-A)))
                                (make-array domain
                                            (array-getter A-prime))))
                 (immutable-A-extract (array-extract immutable-A subdomain))
                 (spec-B (array-copy (make-array domain list)))
                 (spec-B-extract (array-extract spec-B subdomain))
                 (mut-B (let ((B-prime (array-copy spec-B)))
                          (make-array domain
                                      (array-getter B-prime)
                                      (array-setter B-prime))))
                 (mut-B-extract (array-extract mut-B subdomain)))
            ;; test that the extracts are the same kind of arrays as the original
            (if (not (and (specialized-array? spec-A)
                          (specialized-array? spec-A-extract)
                          (mutable-array? mut-A)
                          (mutable-array? mut-A-extract)
                          (not (specialized-array? mut-A))
                          (not (specialized-array? mut-A-extract))
                          (array? immutable-A)
                          (array? immutable-A-extract)
                          (not (mutable-array? immutable-A))
                          (not (mutable-array? immutable-A-extract))
                          (equal? (array-domain spec-A-extract) subdomain)
                          (equal? (array-domain mut-A-extract) subdomain)
                          (equal? (array-domain immutable-A-extract) subdomain)))
                (error "extract: Aargh!"))
            ;; test that applying the original setter to arguments in
            ;; the subdomain gives the same answer as applying the
            ;; setter of the extracted array to the same arguments.
            (for-each (lambda (A B A-extract B-extract)
                        (let ((A-setter (array-setter A))
                              (B-extract-setter (array-setter B-extract)))
                          (do ((i 0 (fx+ i 1)))
                              ((fx=? i 100)
                               (test-assert (myarray= spec-A spec-B))
                               (test-assert
                                   (myarray= spec-A-extract spec-B-extract)))
                            (call-with-values
                                (lambda ()
                                  (random-multi-index subdomain))
                              (lambda multi-index
                                (let ((val (random-real)))
                                  (apply A-setter val multi-index)
                                  (apply B-extract-setter val multi-index)))))))
                      (list spec-A mut-A)
                      (list spec-B mut-B)
                      (list spec-A-extract mut-A-extract)
                      (list spec-B-extract mut-B-extract))))
        )

      (test-group "tile/reverse/flip"
        (test-error (array-tile 'a '#(10)))
        (test-error
         (array-tile (make-array (make-interval '#(0 0) '#(10 10)) list)
                     'a))
        (test-error
         (array-tile (make-array (make-interval '#(0 0) '#(10 10)) list)
                     '#(a a)))
        (test-error
         (array-tile (make-array (make-interval '#(0 0) '#(10 10)) list)
                     '#(-1 1)))
        (test-error
         (array-tile (make-array (make-interval '#(0 0) '#(10 10)) list)
                     '#(10)))

        (do ((d 1 (fx+ d 1)))
            ((fx=? d 6))
          (let* ((A (make-array (make-interval (make-vector d 100)) list))
                 (B (array-tile A (make-vector d 10)))
                 (index (make-list d 12)))
            (test-error (apply (array-getter B) index))))

        (do ((i 0 (fx+ i 1)))
            ((fx=? i tests))
          (let* ((domain
                  (random-interval))
                 (array
                  (let ((res (make-array domain list)))
                    (case (random-integer 3)
                      ;; immutable
                      ((0) res)
                      ;; specialized
                      ((1) (array-copy res))
                      (else
                       ;; mutable, but not specialized
                       (let ((res (array-copy res)))
                         (make-array domain
                                     (array-getter res)
                                     (array-setter res)))))))
                 (lowers
                  (interval-lower-bounds->vector domain))
                 (uppers
                  (interval-upper-bounds->vector domain))
                 (sidelengths
                  (vector-map (lambda (l u)
                                (let ((dim (- u l)))
                                  (random 1 (ceiling-quotient (* dim 7) 5))))
                              lowers uppers))
                 (result
                  (array-tile array sidelengths))
                 (test-result
                  (my-array-tile array sidelengths)))

            ;; extract-array is tested independently, so we just make
            ;; a few tests.

            ;; test all the subdomain tiles are the same
            (test-assert
                (array-every (lambda (r t)
                               (equal? (array-domain r) (array-domain t)))
                             result test-result))
            ;; test that the subarrays are the same type
            (test-assert
                (array-every
                 (lambda (r t)
                   (and
                    (eq? (mutable-array? r) (mutable-array? t))
                    (eq? (mutable-array? r) (mutable-array? array))
                    (eq? (specialized-array? r) (specialized-array? t))
                    (eq? (specialized-array? r) (specialized-array? array))))
                 result test-result))
            ;; test that the first tile has the right values
            (test-assert
                (myarray= (apply (array-getter result)
                                 (make-list (vector-length lowers) 0))
                          (apply (array-getter test-result)
                                 (make-list (vector-length lowers) 0))))
            ))

        (test-error (array-reverse 'a 'a))
        (test-error
         (array-reverse (make-array (make-interval '#(0 0) '#(2 2)) list)
                        'a))
        (test-error
         (array-reverse (make-array (make-interval '#(0 0) '#(2 2)) list)
                        '#(1 0)))
        (test-error
         (array-reverse (make-array (make-interval '#(0 0) '#(2 2)) list)
                        '#(#t)))

        (do ((i 0 (+ i 1)))
            ((= i tests))
          (let* ((domain (random-interval))
                 (Array (let ((temp (make-array domain list)))
                          (case (random-integer 3)
                            ((0) temp)
                            ((1) (array-copy temp))
                            ((2) (let ((temp (array-copy temp)))
                                   (make-array (array-domain temp)
                                               (array-getter temp)
                                               (array-setter temp)))))))
                 (flips (vector-map (lambda (x) (random-boolean))
                                    (make-vector (interval-dimension domain))))
                 (reversed-array (array-reverse Array flips))
                 (my-reversed-array (myarray-reverse Array flips)))

            (if (mutable-array? Array)
                (do ((j 0 (+ j 1)))
                    ((= j 50))
                  (call-with-values
                      (lambda ()
                        (random-multi-index domain))
                    (lambda multi-index
                      (let ((value (random-integer 10000)))
                        (apply (array-setter reversed-array) value multi-index)
                        (apply (array-setter my-reversed-array) value
                               multi-index))))))
            (test-assert (myarray= reversed-array
                                   my-reversed-array))))

        ;; next test that the optional flip? argument is computed correctly.

        (for-each
         (lambda (n)
           (let* ((upper-bounds (make-vector n 2))
                  (lower-bounds (make-vector n 0))
                  (domain (make-interval lower-bounds upper-bounds))
                  (A (array-copy (make-array domain list)))
                  (immutable-A
                   (let ((A (array-copy A))) ;; copy A
                     (make-array domain
                                 (array-getter A))))
                  (mutable-A
                   (let ((A (array-copy A))) ;; copy A
                     (make-array domain
                                 (array-getter A)
                                 (array-setter A))))
                  (flip? (make-vector n #t)))
             (let ((r1 (array-reverse A))
                   (r2 (array-reverse A flip?)))
               (test-assert (and (specialized-array? r1)
                                 (specialized-array? r2)
                                 (myarray= r1 r2))))
             (let ((r1 (array-reverse mutable-A))
                   (r2 (array-reverse mutable-A flip?)))
               (test-assert (and (mutable-array? r1)
                                 (mutable-array? r2)
                                 (myarray= r1 r2))))
             (let ((r1 (array-reverse immutable-A))
                   (r2 (array-reverse immutable-A flip?)))
               (test-assert (and (array? r1)
                                 (array? r2)
                                 (myarray= r1 r2))))))
         (iota 5 1))

        (test-error (array-assign! 'a 'a))
        (test-error
         (array-assign! (make-array (make-interval '#(0 0) '#(1 1)) values) 'a))
        (test-error
         (array-assign! (array-copy (make-array (make-interval '#(0 0) '#(1 1))
                                                values))
                        'a))
        (test-error
         (array-assign! (array-copy (make-array (make-interval '#(0 0) '#(1 1))
                                                values))
                        (make-array (make-interval '#(0 0) '#(2 1)) values)))
        (test-error
         (array-assign! (make-array (make-interval '#(1 2)) list list) ; invalid
                        (make-array (make-interval '#(0 0) '#(2 1)) values)))
        (test-error
         (array-assign! (array-rotate
                         (array-copy (make-array (make-interval '#(2 3))
                                                 list ))
                         1)
                        (make-array (make-interval '#(2 3)) list)))
        )

      (test-group "stack/block"
        (let* ((a
                (make-array (make-interval '#(4 10)) list))
               (a-column
                (array-getter ;; the getter of ...
                 (array-curry ;; a 1-D array of the columns of A
                  (array-permute a '#(1 0))
                  1))))
          (test '(((0 1)   (0 2)   (0 5)   (0 8))
                  ((1 1)   (1 2)   (1 5)   (1 8))
                  ((2 1)   (2 2)   (2 5)   (2 8))
                  ((3 1)   (3 2)   (3 5)   (3 8)))
              (array->list*
               (array-stack ;; stack into a new 2-D array ...
                1           ;; along axis 1 (i.e., columns) ...
                (map a-column '(1 2 5 8)))) ;; the columns of A you want
            ))
        '(test '((0 1 4 6 7 8)
                (2 3 5 9 10 11)
                (12 13 14 15 16 17))
            (array->list*
             (array-block (list*->array
                           2
                           (list (list (list*->array 2 '((0 1)
                                                         (2 3)))
                                       (list*->array 2 '((4)
                                                         (5)))
                                       (list*->array 2 '((6 7 8)
                                                         (9 10 11))))
                                 (list (list*->array 2 '((12 13)))
                                       (list*->array 2 '((14)))
                                       (list*->array 2 '((15 16 17)))))))))
        )

      (test-group "assign/product"
        (do ((d 1 (fx+ d 1)))
            ((= d 6))
          (let* ((unsafe-specialized-destination
                  (make-specialized-array (make-interval (make-vector d 10))
                                          u1-storage-class))
                 (safe-specialized-destination
                  (make-specialized-array (make-interval (make-vector d 10))
                                          u1-storage-class
                                          #t))
                 (mutable-destination
                  (make-array (array-domain safe-specialized-destination)
                              (array-getter safe-specialized-destination)
                              (array-setter safe-specialized-destination)))
                 (source
                  (make-array (array-domain safe-specialized-destination)
                              (lambda args 100)))) ;; not 0 or 1
            (test-error (array-assign! unsafe-specialized-destination source))
            (test-error (array-assign! safe-specialized-destination source))
            (test-error (array-assign! mutable-destination source))))

        (do ((i 0 (fx+ i 1)))
            ((fx=? i tests))
          (let* ((interval
                  (random-interval))
                 (subinterval
                  (random-subinterval interval))
                 (storage-class-and-initializer
                  (random-storage-class-and-initializer))
                 (storage-class
                  (car storage-class-and-initializer))
                 (initializer
                  (cadr storage-class-and-initializer))
                 (specialized-array
                  (array-copy
                   (make-array interval initializer)
                   storage-class))
                 (mutable-array
                  (let ((specialized-array
                         (array-copy
                          (make-array interval initializer)
                          storage-class)))
                    (make-array interval
                                (array-getter specialized-array)
                                (array-setter specialized-array))))
                 (specialized-subarray
                  (array-extract specialized-array subinterval))
                 (mutable-subarray
                  (array-extract mutable-array subinterval))
                 (new-subarray
                  (array-copy
                   (make-array subinterval initializer)
                   storage-class)))
            (array-assign! specialized-subarray new-subarray)
            (array-assign! mutable-subarray new-subarray)
            (test-assert
                (myarray=
                 specialized-array
                 (make-array
                  interval
                  (lambda multi-index
                    (if (apply interval-contains-multi-index? subinterval
                               multi-index)
                        (apply (array-getter new-subarray) multi-index)
                        (apply (array-getter specialized-array) multi-index))))))
            (test-assert
                (myarray=
                 mutable-array
                 (make-array
                  interval
                  (lambda multi-index
                    (if (apply interval-contains-multi-index? subinterval
                               multi-index)
                        (apply (array-getter new-subarray) multi-index)
                        (apply (array-getter mutable-array) multi-index)))))
              )))

        (test-error (make-array (make-interval '#(0 0) '#(10 10)) list 'a))
        (test-error (array-dimension 'a))
        (test-assert
            (array-safe?
             (array-copy (make-array (make-interval '#(0 0) '#(10 10)) list)
                         generic-storage-class
                         #f
                         #t)))
        (test-not
         (array-safe?
          (array-copy (make-array (make-interval '#(0 0) '#(10 10)) list)
                      generic-storage-class
                      #f
                      #f)))

        (let ((array-builders
               (vector
                (list u1-storage-class
                      (lambda indices (let ((res (random (expt 2 1)))) res))
                      '(a -1))
                (list u8-storage-class
                      (lambda indices (random (expt 2 8)))
                      '(a -1))
                (list u16-storage-class
                      (lambda indices (random (expt 2 16)))
                      '(a -1))
                (list u32-storage-class
                      (lambda indices (random (expt 2 32)))
                      '(a -1))
                (list u64-storage-class
                      (lambda indices (random (expt 2 64)))
                      '(a -1))
                (list s8-storage-class
                      (lambda indices (random (- (expt 2 7))  (expt 2 7)))
                      `(a ,(expt 2 8)))
                (list s16-storage-class
                      (lambda indices (random (- (expt 2 15)) (expt 2 15)))
                      `(a ,(expt 2 16)))
                (list s32-storage-class
                      (lambda indices (random (- (expt 2 31)) (expt 2 31)))
                      `(a ,(expt 2 32)))
                (list s64-storage-class
                      (lambda indices (random (- (expt 2 63)) (expt 2 63)))
                      `(a ,(expt 2 64)))
                (list f32-storage-class
                      (lambda indices (random-real))
                      `(a 1))
                (list f64-storage-class
                      (lambda indices (random-real))
                      `(a 1))
                (list c64-storage-class
                      (lambda indices (make-rectangular (random-real) (random-real)))
                      `(a 1))
                (list c128-storage-class
                      (lambda indices (make-rectangular (random-real) (random-real)))
                      `(a 1))
                )))
          (do ((i 0 (+ i 1)))
              ((= i tests))
            (let* ((domain (random-interval))
                   (builders (vector-ref array-builders
                                         0
                                         #; (random-integer
                                         (vector-length array-builders))
                                         ))
                   (storage-class (car builders))
                   (random-entry (cadr builders))
                   (invalid-entry (list-ref (caddr builders) (random 2)))
                   (Array (array-copy (make-array domain random-entry)
                                      storage-class
                                      #f
                                      #t   ; mutable
                                      #t)) ; safe
                   (getter (array-getter Array))
                   (setter (array-setter Array))
                   (dimension (interval-dimension domain))
                   (valid-args (call-with-values
                                   (lambda ()
                                     (random-multi-index domain))
                                 list)))
              (test-error (apply setter invalid-entry valid-args))
              (set-car! valid-args 'a)
              (test-error (apply getter valid-args))
              (test-error (apply setter 10 valid-args))
              ;; outside the range of any random-interval
              (set-car! valid-args 10000)
              (test-error (apply getter valid-args))
              (test-error (apply setter 10 valid-args))
              (if (< 4 dimension)
                  (begin
                    (set! valid-args (cons 1 valid-args))
                    (test-error (apply getter valid-args))
                    (test-error (apply setter 10 valid-args)))))))

        (test-error (array->list 'a))
        (test-error (list->array 'a 'b))
        (test-error (list->array '(0) 'b))
        (test-error (list->array '(0) (make-interval '#(0) '#(1)) 'a))
        (test-error (list->array '(0) (make-interval '#(0) '#(1))
                                 generic-storage-class 'a))
        (test-error (list->array '(0) (make-interval '#(0) '#(1))
                                 generic-storage-class #t 'a))

        ;; (list->array '(0) (make-interval '#(0) '#(10)))

        (test-error (list->array '(0) (make-interval '#(0) '#(10))))
        (test-error
         (list->array '(a) (make-interval '#(0) '#(1)) u1-storage-class))
        (test-error (list->array '(a) (make-interval '#(10))))

        (let ((array-builders
               (vector
                (list u1-storage-class      (lambda indices (random 0 (expt 2 1))))
                (list u8-storage-class      (lambda indices (random 0 (expt 2 8))))
                (list u16-storage-class     (lambda indices (random 0 (expt 2 16))))
                (list u32-storage-class     (lambda indices (random 0 (expt 2 32))))
                (list u64-storage-class     (lambda indices (random 0 (expt 2 64))))
                (list s8-storage-class
                      (lambda indices (random (- (expt 2 7))  (expt 2 7))))
                (list s16-storage-class
                      (lambda indices (random (- (expt 2 15)) (expt 2 15))))
                (list s32-storage-class
                      (lambda indices (random (- (expt 2 31)) (expt 2 31))))
                (list s64-storage-class
                      (lambda indices (random (- (expt 2 63)) (expt 2 63))))
                (list f32-storage-class
                      (lambda indices (random-real)))
                (list f64-storage-class
                      (lambda indices (random-real)))
                (list c64-storage-class
                      (lambda indices (make-rectangular (random-real) (random-real))))
                (list c128-storage-class
                      (lambda indices (make-rectangular (random-real) (random-real))))
                (list generic-storage-class (lambda indices indices)))))
          (do ((i 0 (+ i 1)))
              ((= i tests))
            (let* ((domain (random-interval))
                   (builders
                    (vector-ref array-builders
                                (random-integer (vector-length array-builders))))
                   (storage-class (car builders))
                   (random-entry (cadr builders))
                   (Array (array-copy (make-array domain random-entry)
                                      storage-class
                                      #f
                                      #t)) ; safe
                   (l (array->list Array))
                   (new-array
                    (list->array domain l storage-class
                                 (zero? (random-integer 2)))))
              (test-assert (myarray= Array new-array)))))

        (test-error (interval-cartesian-product 'a))
        (test-error (interval-cartesian-product (make-interval '#(0) '#(1)) 'a))

        (do ((i 0 (+ i 1)))
            ((= i tests))
          (let* ((intervals
                  (map (lambda (ignore)
                         (random-interval 1 4))
                       (make-list (random 1 3)))))
            (test (apply my-interval-cartesian-product intervals)
                (apply interval-cartesian-product intervals))))

        (let ((test-array (make-array  (make-interval '#(0) '#(1)) list)))
          (test-error (array-outer-product 'a test-array test-array))
          (test-error (array-outer-product append 'a test-array))
          (test-error (array-outer-product append test-array 'a)))

        (do ((i 0 (+ i 1)))
            ((= i tests))
          (let* ((arrays
                  (map (lambda (ignore)
                         (make-array (random-interval 1 5) list))
                       (make-list 2))))
            (test-assert
                (myarray= (apply array-outer-product append arrays)
                          (make-array (apply my-interval-cartesian-product
                                             (map array-domain arrays))
                                      list))))))

      (test-group "reshape tests"
        (specialized-array-default-safe? #t)
        (let ((A-ref
               (array-copy
                (make-array (make-interval '#(10 10))
                            (lambda (i j) (if (= i j) 1 0)))))
              (B-set!
               (array-copy
                (make-array (make-interval '#(10 10))
                            (lambda (i j) (if (= i j) 1 0)))
                u1-storage-class)))
          (do ((i 1 (+ i 1)))
              ((= i 6))
            (test-error (apply array-ref 1 (make-list i 0))))
          (test-error (array-ref A-ref 1))
          (test-error (array-ref A-ref 1 1001))
          (test 1 (array-ref A-ref 4 4))
          (test 0 (array-ref A-ref 4 5))

          (test-error (array-set! 1 1 1))
          (test-error (array-set! B-set!))
          (test-error (array-set! B-set! 2))
          (test-error (array-set! B-set! 2 1))
          (test-error (array-set! B-set! 2 1 1))
          (array-set! B-set! 1 1 2)
          (array-set! B-set! 0 2 2)
          ;;(array-display B-set!)

          (test-error (specialized-array-reshape 'a 1))
          (test-error (specialized-array-reshape A-ref 'a))
          (test-error (specialized-array-reshape A-ref (make-interval '#(5))))
          )

        (let ((array (array-copy (make-array (make-interval '#(2 1 3 1)) list))))
          (test (array->list array)
              (array->list
               (specialized-array-reshape array (make-interval '#(6))))))

        (let ((array (array-copy (make-array (make-interval '#(2 1 3 1)) list))))
          (test (array->list array)
              (array->list
               (specialized-array-reshape array (make-interval '#(3 2))))))

        (let ((array
               (array-reverse
                (array-copy (make-array (make-interval '#(2 1 3 1)) list)))))
          (test (array->list array)
              (array->list
               (specialized-array-reshape array (make-interval '#(6))))))

        (let ((array
               (array-reverse
                (array-copy (make-array (make-interval '#(2 1 3 1)) list)))))
          (test (array->list
                 (specialized-array-reshape array (make-interval '#(3 2))))
              (array->list array)))

        (let ((array
               (array-reverse
                (array-copy (make-array (make-interval '#(2 1 3 1)) list))
                '#(#f #f #f #t))))
          (test (array->list
                 (specialized-array-reshape array (make-interval '#(3 2))))
              (array->list array)))

        (let ((array (array-reverse
                      (array-copy (make-array (make-interval '#(2 1 3 1)) list))
                      '#(#f #f #f #t))))
          (test (array->list
                 (specialized-array-reshape array (make-interval '#(3 1 2))))
              (array->list array)))

        (let ((array (array-reverse
                      (array-copy (make-array (make-interval '#(2 1 3 1)) list))
                      '#(#f #f #f #t))))
          (test (array->list
                 (specialized-array-reshape array (make-interval '#(1 1 1 3 2))))
              (array->list array)))

        (let ((array (array-reverse
                      (array-copy (make-array (make-interval '#(2 1 3 1)) list))
                      '#(#f #f #f #t))))
          (test (array->list
                 (specialized-array-reshape array (make-interval '#(3 2 1 1 1))))
              (array->list array)))

        (let ((array (array-reverse
                      (array-copy (make-array (make-interval '#(2 1 3 1)) list))
                      '#(#f #f #f #t))))
          (test (array->list
                 (specialized-array-reshape array (make-interval '#(3 1 1 2))))
              (array->list array)))

        (let ((array (array-reverse
                      (array-copy (make-array (make-interval '#(2 1 3 1)) list))
                      '#(#f #f #f #t))))
          (test (array->list
                 (specialized-array-reshape array (make-interval '#(3 1 2 1))))
              (array->list array)))

        (let ((array
               (array-sample
                (array-reverse
                 (array-copy (make-array (make-interval '#(2 1 4 1)) list))
                 '#(#f #f #f #t))
                '#(1 1 2 1))))
          (test (array->list
                 (specialized-array-reshape array (make-interval '#(4))))
              (array->list array)))

        (let ((array
               (array-sample
                (array-reverse
                 (array-copy (make-array (make-interval '#(2 1 4 1)) list))
                 '#(#t #f #t #t))
                '#(1 1 2 1))))
          (test (array->list
                 (specialized-array-reshape array (make-interval '#(4))))
              (array->list array)))

        (test-error
         (specialized-array-reshape
          (array-reverse
           (array-copy (make-array (make-interval '#(2 1 3 1)) list))
           '#(#t #f #f #f))
          (make-interval '#(6))))

        (test-error
         (specialized-array-reshape
          (array-reverse
           (array-copy (make-array (make-interval '#(2 1 3 1)) list))
           '#(#t #f #f #f))
          (make-interval '#(3 2))))

        (test-error
         (specialized-array-reshape
          (array-reverse
           (array-copy (make-array (make-interval '#(2 1 3 1)) list))
           '#(#f #f #t #f))
          (make-interval '#(6))))

        (test-error
         (specialized-array-reshape
          (array-reverse
           (array-copy (make-array (make-interval '#(2 1 3 1)) list))
           '#(#f #f #t #t))
          (make-interval '#(3 2))))

        (test-error
         (specialized-array-reshape
          (array-sample
           (array-reverse
            (array-copy (make-array (make-interval '#(2 1 3 1)) list))
            '#(#f #f #f #t))
           '#(1 1 2 1))
          (make-interval '#(4))))

        (test-error
         (specialized-array-reshape
          (array-sample
           (array-reverse
            (array-copy (make-array (make-interval '#(2 1 4 1)) list))
            '#(#f #f #t #t))
           '#(1 1 2 1))
          (make-interval '#(4))))
        )

      (test-group "curry tests"
        (test-assert
            (interval=
             (interval-dilate (make-interval '#(100 100)) '#(1 1) '#(1 1))
             (make-interval '#(1 1) '#(101 101))))

        (test-assert
            (interval=
             (interval-dilate (make-interval '#(100 100)) '#(-1 -1) '#(1 1))
             (make-interval '#(-1 -1) '#(101 101))))

        (test-assert
            (interval=
             (interval-dilate (make-interval '#(100 100))  '#(0 0) '#(-50 -50))
             (make-interval '#(50 50))))

        (test-error
         (interval-dilate (make-interval '#(100 100)) '#(0 0) '#(-500 -50)))

        (let ((a (make-array (make-interval '#(1 1) '#(11 11))
                             (lambda (i j)
                               (if (= i j)
                                   1
                                   0)))))
          (test 1
              ((array-getter a) 3 3))
          (test 0
              ((array-getter a) 2 3)))

        (let ((a (make-array (make-interval '#(0 0) '#(10 10))
                             list)))
          (test '(3 4)
              ((array-getter a) 3 4))
          (let ((curried-a (array-curry a 1)))
            (test '(3 4)
                ((array-getter ((array-getter curried-a) 3)) 4))
            (test (array->list a)
                (array->list (array-decurry curried-a)))))

        (test 0.
            ((array-getter sparse-array) 12345 6789))

        (test 0.
            ((array-getter sparse-array) 0 0))

        ((array-setter sparse-array) 1.0 0 0)

        (test 0.
            ((array-getter sparse-array) 12345 6789))

        (test 1.
            ((array-getter sparse-array) 0 0))
        )

      (test-group "misc"
        (let ()
          (define a
            (array-copy
             (make-array (make-interval '#(5 10))
                         list)))
          (define b
            (specialized-array-share
             a
             (make-interval '#(5 5))
             (lambda (i j)
               (values i (+ i j)))))
          ;; Print the \"rows\" of b
          ;; (array-for-each (lambda (row)
          ;;                   (pretty-print (array->list row)))
          ;;                 (array-curry b 1))
  
          ;; which prints
          ;; ((0 0) (0 1) (0 2) (0 3) (0 4))
          ;; ((1 1) (1 2) (1 3) (1 4) (1 5))
          ;; ((2 2) (2 3) (2 4) (2 5) (2 6))
          ;; ((3 3) (3 4) (3 5) (3 6) (3 7))
          ;; ((4 4) (4 5) (4 6) (4 7) (4 8))
          )

        '(let ()
           (define (palindrome? s)
             (let ((n (string-length s)))
               (or (< n 2)
                   (let* ((a
                           ;; an array accessing the characters of s
                           (make-array (make-interval (vector n))
                                       (lambda (i)
                                         (string-ref s i))))
                          (ra
                           ;; the array in reverse order
                           (array-reverse a))
                          (half-domain
                           (make-interval (vector (quotient n 2)))))
                     (array-every
                      char=?
                      ;; the first half of s
                      (array-extract a half-domain)
                      ;; the second half of s
                      (array-extract ra half-domain))))))
           (for-each
            (lambda (s)
              (for-each display
                        (list "(palindrome? \""
                              s
                              "\") => "
                              (palindrome? s)
                              #\newline)))
            '("" "a" "aa" "ab" "aba" "abc" "abba" "abca" "abbc")))

        ;; (let ((greys (pgm-greys test-pgm)))
        ;;   (write-pgm
        ;;    (make-pgm
        ;;     greys
        ;;     (array-map (lambda (p)
        ;;                  (round-and-clip p greys))
        ;;                (array-convolve
        ;;                 (pgm-pixels test-pgm)
        ;;                 sharpen-filter)))
        ;;    "sharper-test.pgm"))

        ;; (let* ((greys (pgm-greys test-pgm))
        ;;        (edge-array
        ;;         (array-copy
        ;;          (array-map
        ;;           abs
        ;;           (array-convolve
        ;;            (pgm-pixels test-pgm)
        ;;            edge-filter))))
        ;;        (max-pixel
        ;;         (array-foldl max 0 edge-array))
        ;;        (normalizer
        ;;         (inexact (/ greys max-pixel))))
        ;;   (write-pgm
        ;;    (make-pgm
        ;;     greys
        ;;     (array-map (lambda (p)
        ;;                  (- greys
        ;;                     (round-and-clip (* p normalizer) greys)))
        ;;                edge-array))
        ;;    "edge-test.pgm"))

      
        (let ((m
               (array-copy (make-array (make-interval '#(0 0) '#(40 30))
                                       (lambda (i j) (inexact (+ i j)))))))
          (test 1940. (operator-max-norm m))
          (test 1605. (operator-one-norm m)))

        (let ((image
               (array-copy
                (make-array (make-interval '#(4 4))
                            (lambda (i j)
                              (case i
                                ((0) 1.)
                                ((1) -1.)
                                (else 0.)))))))
          ;; (display "\nInitial image: \n")
          ;; (pretty-print (list (array-domain image)
          ;;                     (array->list image)))
          ;; (hyperbolic-Haar-transform image)
          ;; (display "\nArray of hyperbolic Haar wavelet coefficients: \n")
          ;; (pretty-print (list (array-domain image)
          ;;                     (array->list image)))
          ;; (hyperbolic-Haar-inverse-transform image)
          ;; (display "\nReconstructed image: \n")
          ;; (pretty-print (list (array-domain image)
          ;;                     (array->list image)))
          #f)


        ;; (let ((image
        ;;        (array-copy
        ;;         (make-array (make-interval '#(4 4))
        ;;                     (lambda (i j)
        ;;                       (case i
        ;;                         ((0) 1.)
        ;;                         ((1) -1.)
        ;;                         (else 0.)))))))
        ;;   (display "\nInitial image: \n")
        ;;   (pretty-print (list (array-domain image)
        ;;                       (array->list image)))
        ;;   (Haar-transform image)
        ;;   (display "\nArray of Haar wavelet coefficients: \n")
        ;;   (pretty-print (list (array-domain image)
        ;;                       (array->list image)))
        ;;   (Haar-inverse-transform image)
        ;;   (display "\nReconstructed image: \n")
        ;;   (pretty-print (list (array-domain image)
        ;;                       (array->list image))))

        ;; (define A
        ;;   ;; A Hilbert matrix
        ;;   (array-copy
        ;;    (make-array (make-interval '#(4 4))
        ;;                (lambda (i j)
        ;;                  (/ (+ 1 i j))))))

        ;; (display "\nHilbert matrix:\n\n")
        ;; (array-display A)

        ;; (LU-decomposition A)

        ;; (display "\nLU decomposition of Hilbert matrix:\n\n")

        ;; (array-display A)

        ;; Functions to extract the lower- and upper-triangular
        ;; matrices of the LU decomposition of A.

        ;; (define (L a)
        ;;   (let ((a_ (array-getter a))
        ;;         (d  (array-domain a)))
        ;;     (make-array
        ;;      d
        ;;      (lambda (i j)
        ;;        (cond ((= i j) 1)        ;; diagonal
        ;;              ((> i j) (a_ i j)) ;; below diagonal
        ;;              (else 0))))))      ;; above diagonal

        ;; (define (U a)
        ;;   (let ((a_ (array-getter a))
        ;;         (d  (array-domain a)))
        ;;     (make-array
        ;;      d
        ;;      (lambda (i j)
        ;;        (cond ((<= i j) (a_ i j)) ;; diagonal and above
        ;;              (else 0))))))       ;; below diagonal

        ;; ;; Lower triangular matrix of decomposition of Hilbert matrix
        ;; (array-display (L A))

        ;; ;; Upper triangular matrix of decomposition of Hilbert matrix
        ;; (array-display (U A))

        ;; We'll check that the product of the result of LU
        ;; decomposition of A is again A.

        ;; (define product (matrix-multiply (L A) (U A)))

        ;; (display "\nProduct of lower and upper triangular matrices ")
        ;; (display "of LU decomposition of Hilbert matrix:\n\n")
        ;; (array-display product)

        ;; Examples from
        ;; http://microapl.com/apl_help/ch_020_020_880.htm

        (let ((TABLE1
               (list->array
                (make-interval '#(3 2))
                '(1 2
                    5 4
                    3 0)))
              (TABLE2
               (list->array
                (make-interval '#(2 4))
                '(6 2 3 4
                    7 0 1 8))))
          (test '(20 2 5 20
                     58 10 19 52
                     18 6 9 12)
              (array->list (inner-product TABLE1 + * TABLE2))))

        (let ((X ;; a "row vector"
               (list->array (make-interval '#(1 4)) '(1 3 5 7)))
              (Y ;; a "column vector"
               (list->array (make-interval '#(4 1)) '(2 3 6 7))))
          (test '(2)
              (array->list (inner-product X + (lambda (x y) (if (= x y) 1 0)) Y))))

        ;; (let* ((A (array-copy (make-array (make-interval '#(3 4)) list)))
        ;;        (B (array-sample A '#(2 1))))
        ;;   (test-error
        ;;    (specialized-array-reshape B (make-interval '#(8)))))

        '(let* ((interval-flat (make-interval '#(100 100 4)))
                (interval-2x2  (make-interval '#(100 100 2 2)))
                (A (array-copy (make-array interval-flat
                                           (lambda args (random-integer 5)))))
                (B (array-copy (make-array interval-flat
                                           (lambda args (random-integer 5)))))
                (C (array-copy (make-array interval-flat
                                           (lambda args 0)))))
           (array-for-each
            x2x2-matrix-multiply-into!
            (array-curry (specialized-array-reshape A interval-2x2) 2)
            (array-curry (specialized-array-reshape B interval-2x2) 2)
            (array-curry (specialized-array-reshape C interval-2x2) 2))
           (array-for-each
            (lambda (A B C)
              (array-assign! C (matrix-multiply A B)))
            (array-curry (specialized-array-reshape A interval-2x2) 2)
            (array-curry (specialized-array-reshape B interval-2x2) 2)
            (array-curry (specialized-array-reshape C interval-2x2) 2))
           '(array-display ((array-getter
                             (array-curry
                              (specialized-array-reshape A interval-2x2)
                              2))
                            0 0))
           '(array-display ((array-getter
                             (array-curry
                              (specialized-array-reshape B interval-2x2)
                              2))
                            0 0))
           '(array-display ((array-getter
                             (array-curry
                              (specialized-array-reshape C interval-2x2)
                              2))
                            0 0))

           (let ((a2x2 (make-interval '#(2 2))))
             (array-for-each (lambda (A B C)
                               (x2x2-matrix-multiply-into!
                                (specialized-array-reshape A a2x2)
                                (specialized-array-reshape B a2x2)
                                (specialized-array-reshape C a2x2)))
                             (array-curry A 1)
                             (array-curry B 1)
                             (array-curry C 1))
             (array-for-each (lambda (A B C)
                               (array-assign!
                                (specialized-array-reshape C a2x2)
                                (matrix-multiply
                                 (specialized-array-reshape A a2x2)
                                 (specialized-array-reshape B a2x2))))
                             (array-curry A 1)
                             (array-curry B 1)
                             (array-curry C 1)))

           '(array-display ((array-getter
                             (array-curry
                              (specialized-array-reshape A interval-2x2)
                              2))
                            0 0))
           '(array-display ((array-getter
                             (array-curry
                              (specialized-array-reshape B interval-2x2)
                              2))
                            0 0))
           '(array-display ((array-getter
                             (array-curry
                              (specialized-array-reshape C interval-2x2)
                              2))
                            0 0))
           )
        )

      (test-end)
      )))

;; Homogeneous storage classes

;; Define a storage class with an optimized -copy!
(define-syntax define-storage-class
  (syntax-rules ()
    ((define-storage-class name ref set elt? make len default)
     (define name
       (make-storage-class
        ref set elt? make
        (lambda (to at from start end)
          (let ((limit (min end (+ start (- (len to) at)))))
            (if (<= at start)
                (do ((i at (+ i 1)) (j start (+ j 1)))
                    ((>= j limit))
                  (set to i (ref from j)))
                (do ((i (+ at (- end start 1)) (- i 1)) (j (- limit 1) (- j 1)))
                    ((< j start))
                  (set to i (ref from j))))))
        len default (lambda (data) #t) (lambda (data) data))))))

(define-storage-class s8-storage-class
  s8vector-ref s8vector-set! s8? make-s8vector s8vector-length 0)

(define-storage-class s16-storage-class
  s16vector-ref s16vector-set! s16? make-s16vector s16vector-length 0)

(define-storage-class s32-storage-class
  s32vector-ref s32vector-set! s32? make-s32vector s32vector-length 0)

(define-storage-class s64-storage-class
  s64vector-ref s64vector-set! s64? make-s64vector s64vector-length 0)

(define-storage-class u1-storage-class
  u1vector-ref u1vector-set! u1? make-u1vector u1vector-length 0)

(define-storage-class u8-storage-class
  u8vector-ref u8vector-set! u8? make-u8vector u8vector-length 0)

(define-storage-class u16-storage-class
  u16vector-ref u16vector-set! u16? make-u16vector u16vector-length 0)

(define-storage-class u32-storage-class
  u32vector-ref u32vector-set! u32? make-u32vector u32vector-length 0)

(define-storage-class u64-storage-class
  u64vector-ref u64vector-set! u64? make-u64vector u64vector-length 0)

(define-storage-class f32-storage-class
  f32vector-ref f32vector-set! f32? make-f32vector f32vector-length 0)

(define-storage-class f64-storage-class
  f64vector-ref f64vector-set! f64? make-f64vector f64vector-length 0)

(define-storage-class c64-storage-class
  c64vector-ref c64vector-set! c64? make-c64vector c64vector-length 0)

(define-storage-class c128-storage-class
  c128vector-ref c128vector-set! c128? make-c128vector c128vector-length 0)

(define-storage-class char-storage-class
  (lambda (vec i) (integer->char (u32vector-ref vec i)))
  (lambda (vec i ch) (u32vector-set! vec i (char->integer ch)))
  char? make-u32vector u32vector-length 0)

;; TODO: implement
(define f8-storage-class #f)
(define f16-storage-class #f)

;; Array transformations

(define (array-copy array . o)
  (assert (array? array))
  (let ((specialized? (specialized-array? array))
        (domain (array-domain array)))
    (let* ((storage (cond ((pair? o) (car o))
                          (specialized? (array-storage-class array))
                          (else  generic-storage-class)))
           (o (if (pair? o) (cdr o) '()))
           (mutable? (cond ((pair? o) (car o))
                           (specialized? (and (array-setter array) #t))
                           (else (specialized-array-default-mutable?))))
           (o (if (pair? o) (cdr o) '()))
           (safe? (cond ((pair? o) (car o))
                        (specialized? (array-safe? array))
                        (else (specialized-array-default-safe?)))))
      (assert
       (and (storage-class? storage) (boolean? mutable?) (boolean? safe?)))
      (let* ((body ((storage-class-maker storage)
                    (interval-volume domain)
                    (storage-class-default storage)))
             (coeffs (default-coeffs domain))
             (indexer (coeffs->indexer coeffs domain))
             (getter (specialized-getter body indexer
                                         (storage-class-getter storage)))
             (setter (specialized-setter body indexer
                                         (storage-class-setter storage)))
             (res (%make-specialized domain storage body coeffs indexer
                                     safe? #t #t)))
        (array-assign! res array)
        (unless mutable?
          (%array-setter-set! res #f))
        res))))

(define array-copy! array-copy)

(define (array-curry array inner-dimension)
  (call-with-values
      (lambda () (interval-projections (array-domain array) inner-dimension))
    (lambda (outer-domain inner-domain)
      (cond
       ((specialized-array? array)
        (make-array
         outer-domain
         (lambda outer-index
           (specialized-array-share
            array
            inner-domain
            (lambda inner-index
              (apply values (append outer-index inner-index)))))))
       (else
        (make-array
         outer-domain
         (lambda outer-index
           (make-array
            inner-domain
            (lambda inner-index
              (apply array-ref array (append outer-index inner-index)))
            (and
             (mutable-array? array)
             (lambda (val . inner-index)
               (apply array-set! array val (append outer-index inner-index))
               ))))))))))

(define (array-extract array new-domain)
  (assert (and (array? array)
               (interval? new-domain)
               (interval-subset? new-domain (array-domain array))))
  (if (specialized-array? array)
      (specialized-array-share array new-domain values)
      (make-array new-domain (array-getter array) (array-setter array))))

(define (array-tile array sizes)
  (assert (and (array? array)
               (vector? sizes)
               (= (array-dimension array) (vector-length sizes))
               (vector-every exact-integer? sizes)
               (vector-every <= sizes (interval-ub (array-domain array)))))
  (let ((domain (make-interval
                 (vector-map
                  (lambda (lo hi s) (exact (ceiling (/ (- hi lo) s))))
                  (interval-lb (array-domain array))
                  (interval-ub (array-domain array))
                  sizes))))
    (make-array
     domain
     (lambda multi-index
       (array-extract
        array
        (make-interval
         (vector-map
          (lambda (i lo s) (+ lo (* i s)))
          (list->vector multi-index)
          (interval-lb (array-domain array))
          sizes)
         (vector-map
          (lambda (i lo hi s)
            (min hi (+ lo (* (+ i 1) s))))
          (list->vector multi-index)
          (interval-lb (array-domain array))
          (interval-ub (array-domain array))
          sizes)))))))

(define (array-translate array translation)
  (let ((new-domain (interval-translate (array-domain array) translation))
        (translation-ls (vector->list translation)))
    (if (specialized-array? array)
        (specialized-array-share
         array
         new-domain
         (lambda multi-index
           (apply values (map - multi-index translation-ls))))
        (make-array
         new-domain
         (lambda multi-index
           (apply array-ref array (map - multi-index translation-ls)))
         (and (mutable-array? array)
              (lambda (val . multi-index)
                (apply array-set! array val
                       (map - multi-index translation-ls))))))))

(define (permute ls permutation)
  (let ((vec (list->vector ls))
        (len (vector-length permutation)))
    (do ((i (- len 1) (- i 1))
         (res '() (cons (vector-ref vec (vector-ref permutation i)) res)))
        ((< i 0) res))))

(define (inverse-permutation permutation)
  (list->vector
   (map car
        (list-sort (lambda (a b) (< (cdr a) (cdr b)))
                   (map cons
                        (iota (vector-length permutation))
                        (vector->list permutation))))))

(define (array-permute array permutation)
  (assert (permutation? permutation))
  (let ((new-domain (interval-permute (array-domain array) permutation))
        (perm^-1 (inverse-permutation permutation)))
    (if (specialized-array? array)
        (specialized-array-share
         array
         new-domain
         (lambda multi-index
           (let ((perm-index (permute multi-index perm^-1)))
             (apply values perm-index))))
        (make-array
         new-domain
         (lambda multi-index
           (let ((perm-index (permute multi-index perm^-1)))
             (apply array-ref array perm-index)))
         (and (mutable-array? array)
              (lambda (val . multi-index)
                (apply array-set! array val (permute multi-index perm^-1))))))))

(define (array-reverse array . o)
  (assert (array? array))
  (let ((flip? (if (pair? o) (car o) (make-vector (array-dimension array) #t))))
    (assert (and (vector? flip?)
                 (= (array-dimension array) (vector-length flip?))
                 (vector-every boolean? flip?)))
    (let* ((flips (vector->list flip?))
           (domain (array-domain array))
           (lowers (interval-lower-bounds->list domain))
           (uppers (interval-upper-bounds->list domain))
           (flip-multi-index
            (lambda (multi-index)
              (map (lambda (i flip-i? lo hi)
                     (if flip-i? (- (+ lo hi -1) i) i))
                   multi-index
                   flips
                   lowers
                   uppers))))
      (if (specialized-array? array)
          (specialized-array-share array
                                   domain
                                   (lambda multi-index
                                     (apply values
                                            (flip-multi-index multi-index))))
          (make-array
           domain
           (lambda multi-index
             (apply array-ref array (flip-multi-index multi-index)))
           (and
            (mutable-array? array)
            (lambda (val . multi-index)
              (apply array-set! array val (flip-multi-index multi-index))
              )))))))

(define (array-sample array scales)
  (unless (vector-every zero?
                        (interval-lower-bounds->vector (array-domain array)))
    (error "can only sample an array with zero lower bounds" array))
  (let ((scales-ls (vector->list scales))
        (new-domain (interval-scale (array-domain array) scales)))
    (if (specialized-array? array)
        (specialized-array-share
         array
         new-domain
         (lambda multi-index
           (apply values (map * multi-index scales-ls))))
        (make-array
         new-domain
         (lambda multi-index
           (apply array-ref array (map * multi-index scales-ls)))
         (and
          (mutable-array? array)
          (lambda (val . multi-index)
            (apply array-set! array val (map * multi-index scales-ls))))))))

(define (array-outer-product op array1 array2)
  (assert (and (procedure? op) (array? array1) (array? array2)))
  (make-array (interval-cartesian-product (array-domain array1)
                                          (array-domain array2))
              (let ((getter1 (array-getter array1))
                    (getter2 (array-getter array2))
                    (dim1 (array-dimension array1)))
                (lambda multi-index
                  (op (apply getter1 (take multi-index dim1))
                      (apply getter2 (drop multi-index dim1)))))))

(define (array-inner-product A f g B)
  (array-outer-product
   (lambda (a b) (array-reduce f (array-map g a b)))
   (array-copy (array-curry A 1))
   (array-copy
    (array-curry (array-permute B (index-rotate (array-dimension B) 1))))))

(define (same-dimensions? ls)
  (or (null? ls)
      (null? (cdr ls))
      (and (equal? (array-dimension (car ls)) (array-dimension (cadr ls)))
           (same-dimensions? (cdr ls)))))

(define (same-domains? ls)
  (or (null? ls)
      (null? (cdr ls))
      (and (interval= (array-domain (car ls)) (array-domain (cadr ls)))
           (same-domains? (cdr ls)))))

(define (array-map f array . arrays)
  (make-array (array-domain array)
              (let* ((ls (cons array arrays))
                     (getters (map array-getter ls)))
                (assert (same-dimensions? ls))
                (lambda multi-index
                  (apply f (map (lambda (g) (apply g multi-index)) getters))))))

(define (array-for-each f array . arrays)
  (if (null? arrays)
      (interval-for-each
       (let ((g (array-getter array)))
         (case (array-dimension array)
           ((1)
            (lambda (i) (f (g i))))
           ((2)
            (lambda (i j) (f (g i j))))
           (else
            (lambda multi-index
              (f (apply g multi-index))))))
       (array-domain array))
      (interval-for-each
       (let* ((lower (interval-lower-bounds->list (array-domain array)))
              (ls (cons array arrays))
              (getters
               (cons (array-getter (car ls))
                     (map (lambda (ar)
                            (let ((getter (array-getter ar)))
                              (lambda multi-index
                                (apply getter multi-index))))
                          (cdr ls)))))
         (assert (same-domains? ls))
         (lambda multi-index
           (apply f (map (lambda (g) (apply g multi-index)) getters))))
       (array-domain array))))

(define (array-foldl kons knil array)
  (interval-fold (lambda (acc . multi-index)
                   (kons (apply array-ref array multi-index) acc))
                 knil
                 (array-domain array)))

(define (array-foldr kons knil array)
  (fold-right kons knil (array->list array)))

(define (array-reduce op array)
  (let* ((domain (array-domain array))
         (init-index (interval-lower-bounds->list domain))
         (knil (list 'first-element)))
    (interval-fold
     (lambda (acc . multi-index)
       (if (eq? acc knil)
           (apply array-ref array multi-index)
           (op acc (apply array-ref array multi-index))))
     knil
     domain)))

(define (array-any pred array . arrays)
  (assert (same-dimensions? (cons array arrays)))
  (call-with-current-continuation
   (lambda (return)
     (apply array-for-each
            (lambda args (cond ((apply pred args) => return)))
            #f
            array
            arrays)
     #f)))

(define (array-every pred array . arrays)
  (assert (same-dimensions? (cons array arrays)))
  (call-with-current-continuation
   (lambda (return)
     (interval-fold
      (let ((getters (map array-getter (cons array arrays))))
        (lambda (acc . multi-index)
          (or (apply pred (map (lambda (g) (apply g multi-index)) getters))
              (return #f))))
      #t
      (array-domain array)))))

(define (array->list array)
  (reverse (array-foldl cons '() array)))

(define (list->array domain ls . o)
  (let* ((storage (if (pair? o) (car o) generic-storage-class))
         (mutable? (if (and (pair? o) (pair? (cdr o)))
                       (cadr o)
                       (specialized-array-default-mutable?)))
         (safe? (if (and (pair? o) (pair? (cdr o)) (pair? (cddr o)))
                    (car (cddr o))
                    (specialized-array-default-safe?)))
         (res (make-specialized-array domain storage safe?)))
    (assert (and (interval? domain) (storage-class? storage)
                 (boolean? mutable?) (boolean? safe?)))
    (interval-fold
     (lambda (ls . multi-index)
       (apply array-set! res (car ls) multi-index)
       (cdr ls))
     ls
     domain)
    res))

(define (array->vector array)
  (list->vector (array->list array)))

(define (vector->array domain vec . o)
  (apply list->array domain (vector->list vec o)))

(define (array-assign! destination source)
  (assert (and (mutable-array? destination) (array? source)
               (interval= (array-domain destination) (array-domain source))))
  (let ((getter (array-getter source))
        (setter (array-setter destination)))
    (interval-for-each
     (case (array-dimension destination)
       ((1) (lambda (i) (setter (getter i) i)))
       ((2) (lambda (i j) (setter (getter i j) i j)))
       ((3) (lambda (i j k) (setter (getter i j k) i j k)))
       (else
        (lambda multi-index
          (apply setter (apply getter multi-index) multi-index))))
     (array-domain source))
    destination))

(define (reshape-without-copy array new-domain)
  (let* ((domain (array-domain array))
         (orig-indexer (array-indexer array))
         (tmp-indexer (default-indexer new-domain))
         (new-indexer
          (lambda multi-index
            (apply orig-indexer
                   (invert-default-index domain
                                         (apply tmp-indexer multi-index)))))
         (new-coeffs (indexer->coeffs new-indexer new-domain #t))
         (flat-indexer (coeffs->indexer new-coeffs new-domain))
         (new-indexer (coeffs->indexer new-coeffs new-domain))
         (body (array-body array))
         (storage (array-storage-class array))
         (res
          (%make-specialized new-domain storage body new-coeffs flat-indexer
                             (array-safe? array) (array-setter array)
                             (array-adjacent? array))))
    (let ((multi-index (interval-lower-bounds->list domain))
          (orig-default-indexer (default-indexer domain)))
      (let lp ((i 0)
               (ls multi-index))
        (let ((reshaped-index
               (invert-default-index
                new-domain
                (apply orig-default-indexer multi-index))))
          (cond
           ((not (equal? (apply flat-indexer reshaped-index)
                         (apply orig-indexer multi-index)))
            #f)
           ((null? ls)
            res)
           ((= (+ 1 (interval-lower-bound domain i))
               (interval-upper-bound domain i))
            (lp (+ i 1) (cdr ls)))
           (else
            (set-car! ls (+ 1 (car ls)))
            (lp (+ i 1) (cdr ls)))))))))

(define (specialized-array-reshape array new-domain . o)
  (assert (and (specialized-array? array)
               (= (interval-volume (array-domain array))
                  (interval-volume new-domain))))
  (let ((copy-on-failure? (and (pair? o) (car o))))
    (cond
     ((reshape-without-copy array new-domain))
     (copy-on-failure?
      (let ((res (make-specialized-array
                  new-domain
                  (array-storage-class array)
                  (array-safe? array))))
        (array-assign! res array)
        res))
     (else
      (error "can't reshape" array new-domain)))))

(define (flatten ls)
  (if (pair? (car ls))
      (append-map flatten ls)
      ls))

(define (list*->array dimension nested-ls . o)
  (let lp ((ls nested-ls) (lens '()) (d dimension))
    (cond
     ((positive? d)
      (lp (car ls) (cons (length ls) lens) (- d 1)))
     (else
      (apply list->array
             (make-interval (list->vector (reverse lens)))
             (flatten nested-ls)
             o)))))

(define (array->list* a)
  (case (array-dimension a)
    ((0) (array-ref a))
    ((1)
     (let ((domain (array-domain a)))
       (map (lambda (i) (array-ref a i))
            (iota (interval-width domain 0)
                  (interval-lower-bound domain 0)))))
    (else
     (let ((domain (array-domain a))
           (b (array-curry a 1)))
       (map (lambda (i) (array->list* (array-ref b i)))
            (iota (interval-width domain 0)
                  (interval-lower-bound domain 0)))))))

(define (array->vector* a)
  (case (array-dimension a)
    ((0) (array-ref a))
    ((1)
     (let ((domain (array-domain a)))
       (vector-map (lambda (i) (array-ref a i))
                   (vector-iota (interval-width domain 0)
                                (interval-lower-bound domain 0)))))
    (else
     (let ((domain (array-domain a))
           (b (array-curry a 1)))
       (vector-map (lambda (i) (array->vector* (array-ref b i)))
                   (vector-iota (interval-width domain 0)
                                (interval-lower-bound domain 0)))))))

(define (flatten-vec vec)
  (if (vector? (vector-ref vec 0))
      (append-map flatten-vec vec)
      (vector->list vec)))

(define (vector*->array dimension nested-vec . o)
  (let lp ((vec nested-vec) (lens '()) (d dimension))
    (cond
     ((positive? d)
      (lp (vector-ref vec 0) (cons (vector-length vec) lens) (- d 1)))
     (else
      (apply list->array
             (make-interval (list->vector (reverse lens)))
             (flatten-vec nested-vec)
             o)))))

(define (dimensions-compatible? a-domain b-domain axis)
  (and (= (interval-dimension a-domain) (interval-dimension b-domain))
       (let lp ((d (- (interval-dimension a-domain) 1)))
         (or (negative? d)
             (and (or (= d axis)
                      (= (- (interval-upper-bound a-domain d)
                            (interval-lower-bound a-domain d))
                         (- (interval-upper-bound b-domain d)
                            (interval-lower-bound b-domain d))))
                  (lp (- d 1)))))))

(define (array-append axis arrays . o)
  (assert (and (exact-integer? axis)
               (pair? arrays)
               (every array? arrays)
               (< -1 axis (array-dimension (car arrays)))))
  (let* ((a (car arrays))
         (a-domain (array-domain a))
         (storage (if (pair? o) (car o) generic-storage-class))
         (mutable? (if (and (pair? o) (pair? (cdr o)))
                       (cadr o)
                       (specialized-array-default-mutable?)))
         (safe? (if (and (pair? o) (pair? (cdr o)) (pair? (cddr o)))
                    (car (cddr o))
                    (specialized-array-default-safe?))))
    (assert (every (lambda (b)
                     (dimensions-compatible? a-domain (array-domain b) axis))
                   (cdr arrays)))
    (let* ((a-lo (interval-lower-bounds->vector a-domain))
           (c-lo (make-vector (interval-dimension a-domain) 0))
           (c-hi (interval-widths a-domain)))
      (vector-set! c-hi
                   axis
                   (fold (lambda (b sum)
                           (+ sum (interval-width (array-domain b) axis)))
                         (vector-ref c-hi axis)
                         (cdr arrays)))
      (let* ((c-domain (make-interval c-lo c-hi))
             (c (make-specialized-array c-domain storage mutable? safe?))
             (b-trans (make-vector (array-dimension a) 0)))
        (array-assign!
         (array-extract c (make-interval c-lo (interval-widths a-domain)))
         (array-translate a (vector-map - a-lo)))
        (let lp ((arrays (cdr arrays))
                 (b-offset (- (interval-upper-bound a-domain axis)
                              (interval-lower-bound a-domain axis))))
          (if (null? arrays)
              c
              (let* ((b (car arrays))
                     (b-domain (array-domain b))
                     (b-offset2 (+ b-offset (interval-width b-domain axis)))
                     (b-lo (make-vector (interval-dimension b-domain) 0))
                     (b-hi (interval-widths b-domain)))
                (vector-set! b-lo axis b-offset)
                (vector-set! b-hi axis b-offset2)
                (vector-set! b-trans axis (- b-offset))
                (let ((view (array-translate
                             (array-extract c (make-interval b-lo b-hi))
                             b-trans)))
                  (array-assign! view b)
                  (lp (cdr arrays) b-offset2)))))))))

(define array-append! array-append)

(define (array-stack axis arrays . o)
  (assert (and (exact-integer? axis)
               (pair? arrays)
               (every array? arrays)
               (<= 0 axis (array-dimension (car arrays)))))
  (let ((a (car arrays))
        (storage (if (pair? o) (car o) generic-storage-class))
        (mutable? (if (and (pair? o) (pair? (cdr o)))
                      (cadr o)
                      (specialized-array-default-mutable?)))
        (safe? (if (and (pair? o) (pair? (cdr o)) (pair? (cddr o)))
                   (car (cddr o))
                   (specialized-array-default-safe?))))
    (assert (every (lambda (b)
                     (interval= (array-domain a)
                                (array-domain b)))
                   (cdr arrays)))
    (let* ((a-lbs (interval-lower-bounds->list (array-domain a)))
           (a-ubs (interval-upper-bounds->list (array-domain a)))
           (domain
            (make-interval
             `#(,@(take a-lbs axis) 0 ,@(drop a-lbs axis))
             `#(,@(take a-ubs axis) ,(length arrays) ,@(drop a-ubs axis))))
           (res (make-specialized-array domain
                                        (or (array-storage-class a)
                                            generic-storage-class)))
           (perm `#(,axis ,@(delete axis (iota (+ 1 (array-dimension a))))))
           (permed (if (zero? axis) res (array-permute res perm)))
           (curried (array-curry permed 1))
           (get-view (array-getter curried)))
      (let lp ((ls arrays) (i 0))
        (cond
         ((null? ls) res)
         (else
          (array-assign! (get-view i) (car ls))
          (lp (cdr ls) (+ i 1))))))))

(define array-stack! array-stack)

(define (array-block a . o)
  (let ((storage (if (pair? o) (car o) generic-storage-class))
        (mutable? (if (and (pair? o) (pair? (cdr o)))
                      (cadr o)
                      (specialized-array-default-mutable?)))
        (safe? (if (and (pair? o) (pair? (cdr o)) (pair? (cddr o)))
                   (car (cddr o))
                   (specialized-array-default-safe?))))
    (assert (and (array? a) (not (interval-empty? (array-domain a)))))
    (let* ((a-domain (array-domain a))
           (get (array-getter a))
           (tile0 (apply get (interval-lower-bounds->list a-domain))))
      (assert (array? tile0))
      (let* ((domain (make-interval
                      (vector-append (interval-widths a-domain)
                                     (interval-widths (array-domain tile0)))))
             (scales (vector->list (interval-widths a-domain)))
             (res (make-specialized-array domain storage mutable? safe?)))
        (error "TODO: array-block copy data unimplemented")
        res))))

(define array-block! array-block)

(define (array-decurry a . o)
  (let* ((storage (if (pair? o) (car o) generic-storage-class))
         (mutable? (if (and (pair? o) (pair? (cdr o)))
                       (cadr o)
                       (specialized-array-default-mutable?)))
         (safe? (if (and (pair? o) (pair? (cdr o)) (pair? (cddr o)))
                    (car (cddr o))
                    (specialized-array-default-safe?)))
         (a-domain (array-domain a))
         (elt0 (apply array-ref a (interval-lower-bounds->list a-domain)))
         (elt-domain (array-domain elt0))
         (domain (interval-cartesian-product a-domain elt-domain))
         (res (make-specialized-array domain storage mutable? safe?))
         (curried-res (array-curry res (interval-dimension elt-domain))))
    ;; Prepare a res with the flattened domain, create a new curried
    ;; view of the res with the same domain as a, and assign each
    ;; curried view from a to the res.
    (array-for-each array-assign! curried-res a)
    res))

(define array-decurry! array-decurry)

;;> The base array definitions of SRFI 231, plus some extra internal
;;> bindings.

(define-library (srfi 231 base)
  (import (scheme base)
          (scheme list)
          (scheme vector)
          (chibi assert))
  (export
   ;; Miscellaneous Functions
   vector-iota
   translation? permutation?
   ;; Intervals
   make-interval interval? interval-dimension interval-lb interval-ub
   interval-lower-bound interval-upper-bound interval-lower-bounds->list
   interval-upper-bounds->list interval-lower-bounds->vector
   interval-upper-bounds->vector interval= interval-volume
   interval-subset? interval-contains-multi-index? interval-projections
   interval-fold-left interval-fold-right
   interval-for-each interval-dilate interval-intersect
   interval-translate interval-permute
   interval-scale interval-cartesian-product
   interval-width interval-widths
   interval-empty?
   ;; Indexing
   index-rotate index-first index-last index-swap
   indexer->coeffs coeffs->indexer default-indexer default-coeffs
   invert-default-index interval-cursor interval-cursor-next!
   interval-cursor-next interval-cursor-get interval-fold
   ;; Storage Classes
   make-storage-class storage-class? storage-class-getter
   storage-class-setter storage-class-checker storage-class-maker
   storage-class-copier storage-class-length storage-class-default
   generic-storage-class
   storage-class-data? storage-class-data->body
   ;; Arrays
   make-array array? array-domain array-getter array-dimension
   mutable-array? array-setter specialized-array-default-safe?
   specialized-array-default-mutable?
   make-specialized-array make-specialized-array-from-data
   specialized-array? array-storage-class array-indexer array-body
   array-safe? array-coeffs array-adjacent? array-packed?
   specialized-array-share array-ref array-set!
   %make-specialized %array-setter-set!
   specialized-getter specialized-setter
   )
  (include "base.scm"))

(define-library (srfi 159)
  (import (srfi 159 base) (srfi 159 columnar)
          (srfi 159 unicode) (srfi 159 color))
  (export
   ;; base
   show fn forked with with! each each-in-list call-with-output
   displayed written written-simply
   numeric numeric/comma numeric/si numeric/fitted
   nothing nl fl space-to tab-to escaped maybe-escaped
   padded padded/right padded/both
   trimmed trimmed/right trimmed/both trimmed/lazy
   fitted fitted/right fitted/both
   joined joined/prefix joined/suffix joined/last joined/dot joined/range
   ;; columnar
   call-with-output-generator call-with-output-generators
   string->line-generator
   tabular columnar show-columns wrapped wrapped/list wrapped/char
   justified line-numbers from-file
   ;; unicode
   as-unicode
   ;; color
   as-red as-blue as-green as-cyan as-yellow
   as-magenta as-white as-black
   as-bold as-underline
   ))
;; Copyright (C) Marc Nieper-Wikirchen (2019).  All Rights Reserved.

;; Permission is hereby granted, free of charge, to any person
;; obtaining a copy of this software and associated documentation
;; files (the "Software"), to deal in the Software without
;; restriction, including without limitation the rights to use, copy,
;; modify, merge, publish, distribute, sublicense, and/or sell copies
;; of the Software, and to permit persons to whom the Software is
;; furnished to do so, subject to the following conditions:

;; The above copyright notice and this permission notice (including
;; the next paragraph) shall be included in all copies or substantial
;; portions of the Software.

;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
;; EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
;; MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
;; NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
;; BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
;; ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
;; CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
;; SOFTWARE.

(define-library (srfi 165)
  (export make-computation-environment-variable
          make-computation-environment computation-environment-ref
          computation-environment-update
          computation-environment-update! computation-environment-copy
          make-computation computation-each computation-each-in-list
          computation-pure computation-bind computation-sequence
          computation-run computation-ask computation-local
          computation-fn computation-with computation-with!
          computation-forked computation-bind/forked
          default-computation
          define-computation-type)
  (import (scheme base)
          (srfi 1)
          (srfi 111)
          (srfi 125)
          (srfi 128)
          (srfi 146))
  (include "165.scm"))

(define-library (srfi 38)
  (import (chibi) (srfi 69) (chibi ast))
  (export write-with-shared-structure write/ss
          read-with-shared-structure read/ss)
  (include "38.scm")
  (cond-expand
   (uvector
    )
   (else
    (begin
      (define (list->uvector etype ls)
        (if (eq? etype U8)
            (let* ((len (length ls))
                   (bv (make-bytevector len)))
              (do ((i 0 (+ i 1)) (ls ls (cdr ls)))
                  ((null? ls) bv)
                (bytevector-u8-set! bv i (car ls))))
            (list->vector ls)))))))
(define-library (srfi 139 test)
  (export run-tests)
  (import (scheme base)
          (chibi test)
          (srfi 139))
  (begin
    (define-syntax-parameter abort
      (syntax-rules ()
        ((_ . _)
         (syntax-error "abort used outside of a loop"))))

    (define-syntax-parameter foo
      (syntax-rules ()
        ((foo) 'old)))

    (define-syntax forever
      (syntax-rules ()
        ((forever body1 body2 ...)
         (call-with-current-continuation
          (lambda (escape) 
            (syntax-parameterize
             ((abort
               (syntax-rules ()
                 ((abort value (... ...))
                  (escape value (... ...))))))
             (let loop ()
               body1 body2 ... (loop))))))))

    (define (run-tests)
      (test-begin "srfi-139: syntax parameters")

      (test (list 'old 'new)
          (let ((new
                 (syntax-parameterize
                  ((foo (syntax-rules ()
                          ((foo) 'new))))
                  (foo))))
            (list (foo) new)))

      (test 10
          (let ((i 0))
            (forever
             (set! i (+ 1 i))
             (when (= i 10)
               (abort)))
            i))

      (test-end))))
;;; Copyright (C) William D Clinger (2016).
;;; 
;;; Permission is hereby granted, free of charge, to any person
;;; obtaining a copy of this software and associated documentation
;;; files (the "Software"), to deal in the Software without
;;; restriction, including without limitation the rights to use,
;;; copy, modify, merge, publish, distribute, sublicense, and/or
;;; sell copies of the Software, and to permit persons to whom the
;;; Software is furnished to do so, subject to the following
;;; conditions:
;;; 
;;; The above copyright notice and this permission notice shall be
;;; included in all copies or substantial portions of the Software.
;;; 
;;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
;;; EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
;;; OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
;;; NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
;;; HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
;;; WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
;;; FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
;;; OTHER DEALINGS IN THE SOFTWARE. 

(define-library (srfi 135 kernel8)

  (export

   ;; for internal use only

   complain               ; for reporting illegal arguments

   text-rtd               ; FIXME: for debugging only
   %new-text              ; FIXME: for debugging only
   text.k text.chunks     ; FIXME: for debugging only

   %text-length           ; non-checking version
   %text-ref              ; non-checking version
;  %subtext               ; non-checking version
   %string->text          ; 1-argument version

   N                      ; preferred text size for pieces of long texts
   the-empty-text         ; there should be only one empty text

   ;; will be exported by (srfi 135)

   text?
   text-tabulate
   text-length
   text-ref
   subtext
   textual-concatenate
   )

  (import (scheme base))

  (include "kernel8.body.scm"))

;; Adapted from the reference implementation test suite.

;;; Copyright (C) William D Clinger (2016).
;;; 
;;; Permission is hereby granted, free of charge, to any person
;;; obtaining a copy of this software and associated documentation
;;; files (the "Software"), to deal in the Software without
;;; restriction, including without limitation the rights to use,
;;; copy, modify, merge, publish, distribute, sublicense, and/or
;;; sell copies of the Software, and to permit persons to whom the
;;; Software is furnished to do so, subject to the following
;;; conditions:
;;; 
;;; The above copyright notice and this permission notice shall be
;;; included in all copies or substantial portions of the Software.
;;; 
;;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
;;; EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
;;; OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
;;; NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
;;; HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
;;; WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
;;; FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
;;; OTHER DEALINGS IN THE SOFTWARE. 

(define-library (srfi 135 test)
  (import (scheme base)
          (scheme write)
          (scheme char)
          (srfi 135)
          (chibi test))
  (export run-tests)
  (begin
    (define (run-tests)
      ;; Help functions for testing.
      (define (as-text . args)
        (textual-concatenate
         (map (lambda (x)
                (cond ((text? x) x)
                      ((string? x) (string->text x))
                      ((char? x) (text x))
                      (else
                       (error "as-text: illegal argument" x))))
              args)))
      (define (result=? str txt)
        (and (text? txt)
             (textual=? str txt)))

      (define-syntax test-text
        (syntax-rules ()
          ((test-text expect expr)
           (test-equal result=? expect expr))))

      ;; Unicode is a strong motivation for immutable texts, so we ought
      ;; to use at least some non-ASCII strings for testing.
      ;; Some systems would blow up if this file were to contain non-ASCII
      ;; characters, however, so we have to be careful here.
      ;;
      ;; FIXME: need more tests with really high code points

      (cond-expand
       ((or sagittarius
            chibi
            full-unicode-strings)
        (define ABC
          (as-text
           (list->string (map integer->char
                              '(#x3b1 #x3b2 #x3b3)))))
        (define ABCDEF
          (as-text
           (list->string (map integer->char
                              '(#x0c0 #x062 #x0c7 #x064 #x0c9 #x066)))))
        (define DEFABC
          (as-text
           (list->string (map integer->char
                              '(#x064 #x0c9 #x066 #x0c0 #x062 #x0c7)))))
        (define eszett (integer->char #xDF))
        (define fuss (text #\F #\u eszett))
        (define chaos0
          (as-text
           (list->string (map integer->char
                              '(#x39E #x391 #x39F #x3A3)))))
        (define chaos1
          (as-text
           (list->string (map integer->char
                              '(#x3BE #x3B1 #x3BF #x3C2)))))
        (define chaos2
          (as-text
           (list->string (map integer->char
                              '(#x3BE #x3B1 #x3BF #x3C3)))))
        (define beyondBMP
          (as-text
           (list->string (map integer->char
                              '(#x61 #xc0 #x3bf
                                     #x1d441 #x1d113 #x1d110 #x7a))))))
       (else
        (define ABC (as-text "abc"))
        (define ABCDEF (as-text "ABCdef"))
        (define DEFABC (as-text "defabc"))))

      (test-begin "srfi-135: immutable texts")

      ;; Predicates

      (test-assert (text? (text)))
      (test-assert (not (text? (string))))
      (test-not (text? #\a))
      (test-assert (textual? (text)))
      (test-assert (textual? (string)))
      (test-not (textual? #\a))
      (test-assert (textual-null? (text)))
      (test-not (textual-null? ABC))

      (test-assert (textual-every (lambda (c) (if (char? c) c #f))
                                  (text)))

      (test #\c (textual-every (lambda (c) (if (char? c) c #f))
                               (as-text "abc")))

      (test-not (textual-every (lambda (c) (if (char>? c #\b) c #f))
                               (as-text "abc")))

      (test #\c (textual-every (lambda (c) (if (char>? c #\b) c #f))
                               (as-text "abc") 2))

      (test-assert (textual-every (lambda (c) (if (char>? c #\b) c #f))
                                  (as-text "abc") 1 1))

      (test-not (textual-any (lambda (c) (if (char? c) c #f))
                             (text)))

      (test #\a (textual-any (lambda (c) (if (char? c) c #f))
                             (as-text "abc")))

      (test #\c (textual-any (lambda (c) (if (char>? c #\b) c #f))
                             (as-text "abc")))

      (test #\c (textual-any (lambda (c) (if (char>? c #\b) c #f))
                             (as-text "abc") 2))

      (test-not (textual-any (lambda (c) (if (char>? c #\b) c #f))
                             (as-text "abc") 0 2))

      (test-assert (textual-every (lambda (c) (if (char? c) c #f)) ""))

      (test #\c (textual-every (lambda (c) (if (char? c) c #f)) "abc"))

      (test-not (textual-every (lambda (c) (if (char>? c #\b) c #f)) "abc"))

      (test #\c (textual-every (lambda (c) (if (char>? c #\b) c #f)) "abc" 2))

      (test-assert (textual-every (lambda (c) (if (char>? c #\b) c #f)) "abc" 1 1))

      (test-not (textual-any (lambda (c) (if (char? c) c #f)) ""))

      (test-assert #\a (textual-any (lambda (c) (if (char? c) c #f)) "abc"))

      (test #\c (textual-any (lambda (c) (if (char>? c #\b) c #f)) "abc"))

      (test #\c (textual-any (lambda (c) (if (char>? c #\b) c #f)) "abc" 2))

      (test-not (textual-any (lambda (c) (if (char>? c #\b) c #f)) "abc" 0 2))

      ;; Constructors

      (test-text ""
                 (text-tabulate (lambda (i)
                                  (integer->char (+ i (char->integer #\a))))
                                0))

      (test-text "abc"
                 (text-tabulate (lambda (i)
                                  (integer->char (+ i (char->integer #\a))))
                                3))

      (test-text "abc"
                 (let ((p (open-input-string "abc")))
                   (text-unfold eof-object?
                                values
                                (lambda (x) (read-char p))
                                (read-char p))))

      (test-text "" (text-unfold null? car cdr '()))

      (test-text "abc"
                 (text-unfold null? car cdr (string->list "abc")))

      (test-text "def"
                 (text-unfold null? car cdr '() (string->text "def")))

      (test-text "defabcG"
                 (text-unfold null?
                              car
                              cdr
                              (string->list "abc")
                              (string->text "def")
                              (lambda (x) (if (null? x) (text #\G) ""))))

      (test-text "" (text-unfold-right null? car cdr '()))

      (test-text "cba"
                 (text-unfold-right null? car cdr (string->list "abc")))

      (test-text "def"
                 (text-unfold-right null? car cdr '() (string->text "def")))

      (test-text "Gcbadef"
                 (text-unfold-right null?
                                    car
                                    cdr
                                    (string->list "abc")
                                    (string->text "def")
                                    (lambda (x) (if (null? x) (text #\G) ""))))


      (test-text "def"
                 (text-unfold null? car cdr '() "def"))

      (test-text "defabcG"
                 (text-unfold null?
                              car
                              cdr
                              (string->list "abc")
                              "def"
                              (lambda (x) (if (null? x) "G" ""))))

      (test-text "dabcG"
                 (text-unfold null?
                              car
                              cdr
                              (string->list "abc")
                              #\d
                              (lambda (x) (if (null? x) "G" ""))))

      (test-text (string-append "%="
                                (make-string 200 #\*)
                                "A B C D E F G H I J K L M "
                                "N O P Q R S T U V W X Y Z "
                                (make-string (* 200 (- (char->integer #\a)
                                                       (char->integer #\Z)
                                                       1))
                                             #\*)
                                "abcdefghijklmnopqrstuvwxyz"
                                " ")
                 (text-unfold (lambda (n) (char>? (integer->char n) #\z))
                              (lambda (n)
                                (let ((c (integer->char n)))
                                  (cond ((char<=? #\a c #\z) c)
                                        ((char<=? #\A c #\Z) (text c #\space))
                                        (else (make-string 200 #\*)))))
                              (lambda (n) (+ n 1))
                              (char->integer #\@)
                              "%="
                              (lambda (n) #\space)))

      (test-text "def"
                 (text-unfold-right null? car cdr '() "def"))

      (test-text "Gcbadef"
                 (text-unfold-right null?
                                    car
                                    cdr
                                    (string->list "abc")
                                    "def"
                                    (lambda (x) (if (null? x) "G" ""))))

      (test-text "Gcbad"
                 (text-unfold-right null?
                                    car
                                    cdr
                                    (string->list "abc")
                                    #\d
                                    (lambda (x) (if (null? x) "G" ""))))

      (test-text (string-append " "
                                (list->string
                                 (reverse
                                  (string->list "abcdefghijklmnopqrstuvwxyz")))
                                (make-string (* 200 (- (char->integer #\a)
                                                       (char->integer #\Z)
                                                       1))
                                             #\*)
                                "Z Y X W V U T S R Q P O N "
                                "M L K J I H G F E D C B A "
                                (make-string 200 #\*)
                                "%=")
                 (text-unfold-right
                  (lambda (n) (char>? (integer->char n) #\z))
                  (lambda (n)
                    (let ((c (integer->char n)))
                      (cond ((char<=? #\a c #\z) c)
                            ((char<=? #\A c #\Z) (text c #\space))
                            (else (make-string 200 #\*)))))
                  (lambda (n) (+ n 1))
                  (char->integer #\@)
                  "%="
                  (lambda (n) #\space)))

      (test-text " The English alphabet: abcdefghijklmnopqrstuvwxyz "
                 (text-unfold-right (lambda (n) (< n (char->integer #\A)))
                                    (lambda (n)
                                      (char-downcase (integer->char n)))
                                    (lambda (n) (- n 1))
                                    (char->integer #\Z)
                                    #\space
                                    (lambda (n) " The English alphabet: ")))


      ;; Conversion

      (test-text "str" (textual->text "str"))

      (test-text "str" (textual->text (text #\s #\t #\r)))

      (test-text "str" (textual->text "str" "not a textual"))

      (test-text "str" (textual->text (text #\s #\t #\r) "bad textual"))


      (test "" (textual->string (text)))

      (test "" (textual->string (text) 0))

      (test "" (textual->string (text) 0 0))

      (test "abc" (textual->string (text #\a #\b #\c)))

      (test "" (textual->string (text #\a #\b #\c) 3))

      (test "bc" (textual->string (text #\a #\b #\c) 1 3))


      (test "" (textual->string ""))

      (test "" (textual->string "" 0))

      (test "" (textual->string "" 0 0))

      (test "abc" (textual->string "abc"))

      (test "" (textual->string "abc" 3))

      (test "bc" (textual->string "abc" 1 3))


      (test '#() (textual->vector (text)))

      (test '#() (textual->vector (text) 0))

      (test '#() (textual->vector (text) 0 0))

      (test '#(#\a #\b #\c) (textual->vector (text #\a #\b #\c)))

      (test '#() (textual->vector (text #\a #\b #\c) 3))

      (test '#(#\b #\c) (textual->vector (text #\a #\b #\c) 1 3))


      (test '#() (textual->vector ""))

      (test '#() (textual->vector "" 0))

      (test '#() (textual->vector "" 0 0))

      (test '#(#\a #\b #\c) (textual->vector "abc"))

      (test '#() (textual->vector "abc" 3))

      (test '#(#\b #\c) (textual->vector "abc" 1 3))


      (test '() (textual->list (text)))

      (test '() (textual->list (text) 0))

      (test '() (textual->list (text) 0 0))

      (test '(#\a #\b #\c) (textual->list (text #\a #\b #\c)))

      (test '() (textual->list (text #\a #\b #\c) 3))

      (test '(#\b #\c) (textual->list (text #\a #\b #\c) 1 3))


      (test '() (textual->list ""))

      (test '() (textual->list "" 0))

      (test '() (textual->list "" 0 0))

      (test '(#\a #\b #\c) (textual->list "abc"))

      (test '() (textual->list "abc" 3))

      (test '(#\b #\c) (textual->list "abc" 1 3))


      (test-text "" (string->text ""))

      (test-text "" (string->text "" 0))

      (test-text "" (string->text "" 0 0))

      (test-text "abc" (string->text "abc"))

      (test-text "bc" (string->text "abc" 1))

      (test-text "" (string->text "abc" 3))

      (test-text "b" (string->text "abc" 1 2))

      (test-text "bc" (string->text "abc" 1 3))


      (test-text "" (vector->text '#()))

      (test-text "" (vector->text '#() 0))

      (test-text "" (vector->text '#() 0 0))

      (test-text "abc" (vector->text '#(#\a #\b #\c)))

      (test-text "bc" (vector->text '#(#\a #\b #\c) 1))

      (test-text "" (vector->text '#(#\a #\b #\c) 3))

      (test-text "b" (vector->text '#(#\a #\b #\c) 1 2))

      (test-text "bc" (vector->text '#(#\a #\b #\c) 1 3))


      (test-text "" (list->text '()))

      (test-text "" (list->text '() 0))

      (test-text "" (list->text '() 0 0))

      (test-text "abc" (list->text '(#\a #\b #\c)))

      (test-text "bc" (list->text '(#\a #\b #\c) 1))

      (test-text "" (list->text '(#\a #\b #\c) 3))

      (test-text "b" (list->text '(#\a #\b #\c) 1 2))

      (test-text "bc" (list->text '(#\a #\b #\c) 1 3))


      (test-text "" (reverse-list->text '()))

      (test-text "cba" (reverse-list->text '(#\a #\b #\c)))


      (test '#u8(97 98 99)
        (textual->utf8 (as-text "abc")))

      (test '#u8(97 98 99)
        (textual->utf8 "abc"))

      (test '#u8(97 98 99 121 121 121 122 122 122)
        (textual->utf8 (as-text "xxxabcyyyzzz") 3))

      (test '#u8(97 98 99 121 121 121 122 122 122)
        (textual->utf8 "xxxabcyyyzzz" 3))

      (test '#u8(97 98 99)
        (textual->utf8 (as-text "xxxabcyyyzzz") 3 6))

      (test '#u8(97 98 99)
        (textual->utf8 "xxxabcyyyzzz" 3 6))


      (test '#u8(254 255 0 97 0 98 0 99)
        (textual->utf16 (as-text "abc")))

      (test '#u8(254 255 0 97 0 98 0 99)
        (textual->utf16 "abc"))

      (test '#u8(254 255 0 97 0 98 0 99 0 121 0 121 0 121 0 122 0 122 0 122)
        (textual->utf16 (as-text "xxxabcyyyzzz") 3))

      (test '#u8(254 255 0 97 0 98 0 99 0 121 0 121 0 121 0 122 0 122 0 122)
        (textual->utf16 "xxxabcyyyzzz" 3))

      (test '#u8(254 255 0 97 0 98 0 99)
        (textual->utf16 (as-text "xxxabcyyyzzz") 3 6))

      (test '#u8(254 255 0 97 0 98 0 99)
        (textual->utf16 "xxxabcyyyzzz" 3 6))


      (test '#u8(0 97 0 98 0 99)
        (textual->utf16be (as-text "abc")))

      (test '#u8(0 97 0 98 0 99)
        (textual->utf16be "abc"))

      (test '#u8(0 97 0 98 0 99 0 121 0 121 0 121 0 122 0 122 0 122)
        (textual->utf16be (as-text "xxxabcyyyzzz") 3))

      (test '#u8(0 97 0 98 0 99 0 121 0 121 0 121 0 122 0 122 0 122)
        (textual->utf16be "xxxabcyyyzzz" 3))

      (test '#u8(0 97 0 98 0 99)
        (textual->utf16be (as-text "xxxabcyyyzzz") 3 6))

      (test '#u8(0 97 0 98 0 99)
        (textual->utf16be "xxxabcyyyzzz" 3 6))


      (test '#u8(97 0 98 0 99 0)
        (textual->utf16le (as-text "abc")))

      (test '#u8(97 0 98 0 99 0)
        (textual->utf16le "abc"))

      (test '#u8(97 0 98 0 99 0 121 0 121 0 121 0 122 0 122 0 122 0)
        (textual->utf16le (as-text "xxxabcyyyzzz") 3))

      (test '#u8(97 0 98 0 99 0 121 0 121 0 121 0 122 0 122 0 122 0)
        (textual->utf16le "xxxabcyyyzzz" 3))

      (test '#u8(97 0 98 0 99 0)
        (textual->utf16le (as-text "xxxabcyyyzzz") 3 6))

      (test '#u8(97 0 98 0 99 0)
        (textual->utf16le "xxxabcyyyzzz" 3 6))


      (test-text "abc"
                 (utf8->text '#u8(97 98 99)))

      (test-text "abcyyyzzz"
                 (utf8->text '#u8(0 1 2 97 98 99 121 121 121 122 122 122) 3))

      (test-text "abc"
                 (utf8->text '#u8(41 42 43 97 98 99 100 101 102) 3 6))


      (test-text "abc"
                 (utf16->text '#u8(254 255 0 97 0 98 0 99)))

      (test-text "abc"
                 (utf16->text '#u8(255 254 97 0 98 0 99 0)))

      (test-text "abc"
                 (utf16->text (textual->utf16 "abc") 2))

      (test-text "bcdef"
                 (utf16->text (textual->utf16 "abcdef") 4))

      (test-text "bcd"
                 (utf16->text (textual->utf16 "abcdef") 4 10))


      (test-text "abc"
                 (utf16be->text '#u8(0 97 0 98 0 99)))

      (test-text "bc"
                 (utf16be->text (textual->utf16be "abc") 2))

      (test-text "bcd"
                 (utf16be->text (textual->utf16be "abcdef") 2 8))


      (test-text "abc"
                 (utf16le->text '#u8(97 0 98 0 99 0)))

      (test-text "bc"
                 (utf16le->text (textual->utf16le "abc") 2))

      (test-text "bcd"
                 (utf16le->text (textual->utf16le "abcdef") 2 8))


      (cond-expand
       ((or sagittarius
            chibi
            full-unicode-strings)

        (test
            '#u8(97 195 128 206 191
                    240 157 145 129 240 157 132 147 240 157 132 144 122)
          (textual->utf8 beyondBMP))

        (let ((bv (textual->utf16 beyondBMP)))
          (test-assert
              (or (equal? bv
                          '#u8(254 255 0 97 0 192 3 191
                                   216 53 220 65 216 52 221 19 216 52 221 16 0 122))
                  (equal? bv
                          '#u8(255 254 97 0 192 0 191 3
                                   53 216 65 220 52 216 19 221 52 216 16 221 122 0)))))

        (test
            '#u8(0 97 0 192 3 191 216 53 220 65 216 52 221 19 216 52 221 16 0 122)
          (textual->utf16be beyondBMP))

        (test
            '#u8(97 0 192 0 191 3 53 216 65 220 52 216 19 221 52 216 16 221 122 0)
          (textual->utf16le beyondBMP))

        (test-assert
            (textual=?
             beyondBMP
             (utf8->text
              '#u8(97 195 128 206 191
                      240 157 145 129 240 157 132 147 240 157 132 144 122))))

        (test-assert (textual=? beyondBMP (utf16->text (textual->utf16 beyondBMP))))

        (test-assert (textual=? beyondBMP
                                (utf16->text (textual->utf16 beyondBMP) 2)))
        
        (test-assert (textual=? beyondBMP (utf16be->text (textual->utf16be beyondBMP))))

        (test-assert (textual=? beyondBMP (utf16le->text (textual->utf16le beyondBMP))))

        (test-assert (result=? (string-append (string (integer->char #xfeff)) "abc")
                               (utf16be->text '#u8(254 255 0 97 0 98 0 99))))

        (test-assert (result=? (string-append (string (integer->char #xfeff)) "abc")
                               (utf16le->text '#u8(255 254 97 0 98 0 99 0))))
        )

       (else))

      ;; Selection

      (test 0 (text-length (text)))

      (test 6 (text-length ABCDEF))

      (test 1234 (text-length (make-text 1234 (text-ref ABC 0))))


      (test #\a (text-ref (text #\a #\b #\c) 0))

      (test #\c (text-ref (text #\a #\b #\c) 2))

      (test (string-ref (textual->string ABCDEF) 3)
          (text-ref ABCDEF 3))


      (test 0 (textual-length (text)))

      (test 6 (textual-length ABCDEF))

      (test 1234 (textual-length (make-text 1234 (text-ref ABC 0))))


      (test #\a (textual-ref (text #\a #\b #\c) 0))

      (test #\c (textual-ref (text #\a #\b #\c) 2))

      (test (string-ref (textual->string ABCDEF) 3)
          (textual-ref ABCDEF 3))


      (test-text ""
                 (subtext (text) 0 0))

      (test-text ""
                 (subtext (string->text "abcdef") 0 0))

      (test-text ""
                 (subtext (string->text "abcdef") 4 4))

      (test-text ""
                 (subtext (string->text "abcdef") 6 6))

      (test-text "abcd"
                 (subtext (string->text "abcdef") 0 4))

      (test-text "cde"
                 (subtext (string->text "abcdef") 2 5))

      (test-text "cdef"
                 (subtext (string->text "abcdef") 2 6))

      (test-text "abcdef"
                 (subtext (string->text "abcdef") 0 6))


      (test-text ""
                 (subtextual (text) 0 0))

      (test-text ""
                 (subtextual (string->text "abcdef") 0 0))

      (test-text ""
                 (subtextual (string->text "abcdef") 4 4))

      (test-text ""
                 (subtextual (string->text "abcdef") 6 6))

      (test-text "abcd"
                 (subtextual (string->text "abcdef") 0 4))

      (test-text "cde"
                 (subtextual (string->text "abcdef") 2 5))

      (test-text "cdef"
                 (subtextual (string->text "abcdef") 2 6))

      (test-text "abcdef"
                 (subtextual (string->text "abcdef") 0 6))


      (test-text ""
                 (subtextual "" 0 0))

      (test-text ""
                 (subtextual "abcdef" 0 0))

      (test-text ""
                 (subtextual "abcdef" 4 4))

      (test-text ""
                 (subtextual "abcdef" 6 6))

      (test-text "abcd"
                 (subtextual "abcdef" 0 4))

      (test-text "cde"
                 (subtextual "abcdef" 2 5))

      (test-text "cdef"
                 (subtextual "abcdef" 2 6))

      (test-text "abcdef"
                 (subtextual "abcdef" 0 6))


      (test-text ""
                 (textual-copy (text)))

      (test-assert (let* ((txt (string->text "abcdef"))
                          (copy (textual-copy txt)))
                     (and (result=? "abcdef"
                                    copy)
                          (not (eqv? txt copy)))))


      (test-text ""
                 (textual-copy ""))

      (test-text "abcdef"
                 (textual-copy "abcdef"))


      (test-text ""
                 (textual-copy (text) 0))

      (test-text "abcdef"
                 (textual-copy (string->text "abcdef") 0))

      (test-text "ef"
                 (textual-copy (string->text "abcdef") 4))

      (test-text ""
                 (textual-copy (string->text "abcdef") 6))


      (test-text ""
                 (textual-copy "" 0))

      (test-text "abcdef"
                 (textual-copy "abcdef" 0))

      (test-text "ef"
                 (textual-copy "abcdef" 4))

      (test-text ""
                 (textual-copy "abcdef" 6))


      (test-text ""
                 (textual-copy (text) 0 0))

      (test-text ""
                 (textual-copy (string->text "abcdef") 0 0))

      (test-text ""
                 (textual-copy (string->text "abcdef") 4 4))

      (test-text ""
                 (textual-copy (string->text "abcdef") 6 6))

      (test-text "abcd"
                 (textual-copy (string->text "abcdef") 0 4))

      (test-text "cde"
                 (textual-copy (string->text "abcdef") 2 5))

      (test-text "cdef"
                 (textual-copy (string->text "abcdef") 2 6))

      (test-text "abcdef"
                 (textual-copy (string->text "abcdef") 0 6))


      (test-text ""
                 (textual-copy "" 0 0))

      (test-text ""
                 (textual-copy "abcdef" 0 0))

      (test-text ""
                 (textual-copy "abcdef" 4 4))

      (test-text ""
                 (textual-copy "abcdef" 6 6))

      (test-text "abcd"
                 (textual-copy "abcdef" 0 4))

      (test-text "cde"
                 (textual-copy "abcdef" 2 5))

      (test-text "cdef"
                 (textual-copy "abcdef" 2 6))

      (test-text "abcdef"
                 (textual-copy "abcdef" 0 6))


      (test-text "" (textual-take (text) 0))

      (test-text "" (textual-take (string->text "abcdef") 0))

      (test-text "ab" (textual-take (string->text "abcdef") 2))

      (test-text "" (textual-drop (string->text "") 0))

      (test-text "abcdef" (textual-drop (string->text "abcdef") 0))

      (test-text "cdef" (textual-drop (string->text "abcdef") 2))

      (test-text "" (textual-take-right (text) 0))

      (test-text "" (textual-take-right (string->text "abcdef") 0))

      (test-text "ef" (textual-take-right (string->text "abcdef") 2))

      (test-text "" (textual-drop-right (text) 0))

      (test-text "abcdef"
                 (textual-drop-right (string->text "abcdef") 0))

      (test-text "abcd"
                 (textual-drop-right (string->text "abcdef") 2))


      (test-text "" (textual-take "" 0))

      (test-text "" (textual-take "abcdef" 0))

      (test-text "ab" (textual-take "abcdef" 2))

      (test-text "" (textual-drop "" 0))

      (test-text "abcdef" (textual-drop "abcdef" 0))

      (test-text "cdef" (textual-drop "abcdef" 2))

      (test-text "" (textual-take-right "" 0))

      (test-text "" (textual-take-right "abcdef" 0))

      (test-text "ef" (textual-take-right "abcdef" 2))

      (test-text "" (textual-drop-right "" 0))

      (test-text "abcdef" (textual-drop-right "abcdef" 0))

      (test-text "abcd" (textual-drop-right "abcdef" 2))


      (test-text "" 
                 (textual-pad (string->text "") 0))

      (test-text "     " 
                 (textual-pad (string->text "") 5))

      (test-text "  325" 
                 (textual-pad (string->text "325") 5))

      (test-text "71325" 
                 (textual-pad (string->text "71325") 5))

      (test-text "71325" 
                 (textual-pad (string->text "8871325") 5))

      (test-text "" 
                 (textual-pad (string->text "") 0 #\*))

      (test-text "*****" 
                 (textual-pad (string->text "") 5 #\*))

      (test-text "**325" 
                 (textual-pad (string->text "325") 5 #\*))

      (test-text "71325" 
                 (textual-pad (string->text "71325") 5 #\*))

      (test-text "71325" 
                 (textual-pad (string->text "8871325") 5 #\*))

      (test-text "" 
                 (textual-pad (string->text "") 0 #\* 0))

      (test-text "*****" 
                 (textual-pad (string->text "") 5 #\* 0))

      (test-text "**325" 
                 (textual-pad (string->text "325") 5 #\* 0))

      (test-text "71325" 
                 (textual-pad (string->text "71325") 5 #\* 0))

      (test-text "71325" 
                 (textual-pad (string->text "8871325") 5 #\* 0))

      (test-text "***25" 
                 (textual-pad (string->text "325") 5 #\* 1))

      (test-text "*1325" 
                 (textual-pad (string->text "71325") 5 #\* 1))

      (test-text "71325" 
                 (textual-pad (string->text "8871325") 5 #\* 1))

      (test-text "" 
                 (textual-pad (string->text "") 0 #\* 0 0))

      (test-text "*****" 
                 (textual-pad (string->text "") 5 #\* 0 0))

      (test-text "**325" 
                 (textual-pad (string->text "325") 5 #\* 0 3))

      (test-text "**713" 
                 (textual-pad (string->text "71325") 5 #\* 0 3))

      (test-text "**887" 
                 (textual-pad (string->text "8871325") 5 #\* 0 3))

      (test-text "***25" 
                 (textual-pad (string->text "325") 5 #\* 1 3))

      (test-text "**132" 
                 (textual-pad (string->text "71325") 5 #\* 1 4))

      (test-text "*8713" 
                 (textual-pad (string->text "8871325") 5 #\* 1 5))

      (test-text "" 
                 (textual-pad-right (string->text "") 0))

      (test-text "     " 
                 (textual-pad-right (string->text "") 5))

      (test-text "325  " 
                 (textual-pad-right (string->text "325") 5))

      (test-text "71325" 
                 (textual-pad-right (string->text "71325") 5))

      (test-text "88713" 
                 (textual-pad-right (string->text "8871325") 5))

      (test-text "" 
                 (textual-pad-right (string->text "") 0 #\*))

      (test-text "*****" 
                 (textual-pad-right (string->text "") 5 #\*))

      (test-text "325**" 
                 (textual-pad-right (string->text "325") 5 #\*))

      (test-text "71325" 
                 (textual-pad-right (string->text "71325") 5 #\*))

      (test-text "88713" 
                 (textual-pad-right (string->text "8871325") 5 #\*))

      (test-text "" 
                 (textual-pad-right (string->text "") 0 #\* 0))

      (test-text "*****" 
                 (textual-pad-right (string->text "") 5 #\* 0))

      (test-text "325**" 
                 (textual-pad-right (string->text "325") 5 #\* 0))

      (test-text "71325" 
                 (textual-pad-right (string->text "71325") 5 #\* 0))

      (test-text "88713" 
                 (textual-pad-right (string->text "8871325") 5 #\* 0))

      (test-text "25***" 
                 (textual-pad-right (string->text "325") 5 #\* 1))

      (test-text "1325*" 
                 (textual-pad-right (string->text "71325") 5 #\* 1))

      (test-text "87132" 
                 (textual-pad-right (string->text "8871325") 5 #\* 1))

      (test-text "" 
                 (textual-pad-right (string->text "") 0 #\* 0 0))

      (test-text "*****" 
                 (textual-pad-right (string->text "") 5 #\* 0 0))

      (test-text "325**" 
                 (textual-pad-right (string->text "325") 5 #\* 0 3))

      (test-text "713**" 
                 (textual-pad-right (string->text "71325") 5 #\* 0 3))

      (test-text "887**" 
                 
                 (textual-pad-right (string->text "8871325") 5 #\* 0 3))

      (test-text "25***" 
                 (textual-pad-right (string->text "325") 5 #\* 1 3))

      (test-text "132**" 
                 (textual-pad-right (string->text "71325") 5 #\* 1 4))

      (test-text "8713*" 
                 
                 (textual-pad-right (string->text "8871325") 5 #\* 1 5))


      (test-text "" (textual-pad "" 0))

      (test-text "     " (textual-pad "" 5))

      (test-text "  325" (textual-pad "325" 5))

      (test-text "71325" (textual-pad "71325" 5))

      (test-text "71325" (textual-pad "8871325" 5))

      (test-text "" (textual-pad "" 0 #\*))

      (test-text "*****" (textual-pad "" 5 #\*))

      (test-text "**325" (textual-pad "325" 5 #\*))

      (test-text "71325" (textual-pad "71325" 5 #\*))

      (test-text "71325" (textual-pad "8871325" 5 #\*))

      (test-text "" (textual-pad "" 0 #\* 0))

      (test-text "*****" (textual-pad "" 5 #\* 0))

      (test-text "**325" (textual-pad "325" 5 #\* 0))

      (test-text "71325" (textual-pad "71325" 5 #\* 0))

      (test-text "71325" (textual-pad "8871325" 5 #\* 0))

      (test-text "***25" (textual-pad "325" 5 #\* 1))

      (test-text "*1325" (textual-pad "71325" 5 #\* 1))

      (test-text "71325" (textual-pad "8871325" 5 #\* 1))

      (test-text "" (textual-pad "" 0 #\* 0 0))

      (test-text "*****" (textual-pad "" 5 #\* 0 0))

      (test-text "**325" (textual-pad "325" 5 #\* 0 3))

      (test-text "**713" (textual-pad "71325" 5 #\* 0 3))

      (test-text "**887" (textual-pad "8871325" 5 #\* 0 3))

      (test-text "***25" (textual-pad "325" 5 #\* 1 3))

      (test-text "**132" (textual-pad "71325" 5 #\* 1 4))

      (test-text "*8713" (textual-pad "8871325" 5 #\* 1 5))

      (test-text "" (textual-pad-right "" 0))

      (test-text "     " (textual-pad-right "" 5))

      (test-text "325  " (textual-pad-right "325" 5))

      (test-text "71325" (textual-pad-right "71325" 5))

      (test-text "88713" (textual-pad-right "8871325" 5))

      (test-text "" (textual-pad-right "" 0 #\*))

      (test-text "*****" (textual-pad-right "" 5 #\*))

      (test-text "325**" (textual-pad-right "325" 5 #\*))

      (test-text "71325" (textual-pad-right "71325" 5 #\*))

      (test-text "88713" (textual-pad-right "8871325" 5 #\*))

      (test-text "" (textual-pad-right "" 0 #\* 0))

      (test-text "*****" (textual-pad-right "" 5 #\* 0))

      (test-text "325**" (textual-pad-right "325" 5 #\* 0))

      (test-text "71325" (textual-pad-right "71325" 5 #\* 0))

      (test-text "88713" (textual-pad-right "8871325" 5 #\* 0))

      (test-text "25***" (textual-pad-right "325" 5 #\* 1))

      (test-text "1325*" (textual-pad-right "71325" 5 #\* 1))

      (test-text "87132" (textual-pad-right "8871325" 5 #\* 1))

      (test-text "" (textual-pad-right "" 0 #\* 0 0))

      (test-text "*****" (textual-pad-right "" 5 #\* 0 0))

      (test-text "325**" (textual-pad-right "325" 5 #\* 0 3))

      (test-text "713**" (textual-pad-right "71325" 5 #\* 0 3))

      (test-text "887**" (textual-pad-right "8871325" 5 #\* 0 3))

      (test-text "25***" (textual-pad-right "325" 5 #\* 1 3))

      (test-text "132**" (textual-pad-right "71325" 5 #\* 1 4))

      (test-text "8713*" (textual-pad-right "8871325" 5 #\* 1 5))


      (test-text ""
                 (textual-trim (string->text "")))

      (test-text "a  b  c  "
                 (textual-trim (string->text "  a  b  c  ")))

      (test-text ""
                 (textual-trim (string->text "") char-whitespace?))

      (test-text "a  b  c  "
                 (textual-trim (string->text "  a  b  c  ") char-whitespace?))

      (test-text ""
                 (textual-trim (string->text "  a  b  c  ") char?))

      (test-text ""
                 (textual-trim (string->text "") char-whitespace? 0))

      (test-text "a  b  c  "
                 (textual-trim (string->text "  a  b  c  ") char-whitespace? 0))

      (test-text ""
                 (textual-trim (string->text "  a  b  c  ") char? 0))

      (test-text "b  c  "
                 (textual-trim (string->text "  a  b  c  ") char-whitespace? 3))

      (test-text ""
                 (textual-trim (string->text "  a  b  c  ") char? 3))

      (test-text ""
                 (textual-trim (string->text "  a  b  c  ") char? 0 11))

      (test-text "b  c  "
                 (textual-trim (string->text "  a  b  c  ")
                               char-whitespace? 3 11))

      (test-text ""
                 (textual-trim (string->text "  a  b  c  ") char? 3 11))

      (test-text ""
                 (textual-trim (string->text "  a  b  c  ") char? 0 8))

      (test-text "b  "
                 (textual-trim (string->text "  a  b  c  ")
                               char-whitespace? 3 8))

      (test-text ""
                 (textual-trim (string->text "  a  b  c  ") char? 3 8))


      (test-text ""
                 (textual-trim-right (string->text "")))

      (test-text "  a  b  c"
                 (textual-trim-right (string->text "  a  b  c  ")))

      (test-text ""
                 (textual-trim-right (string->text "") char-whitespace?))

      (test-text "  a  b  c"
                 (textual-trim-right (string->text "  a  b  c  ")
                                     char-whitespace?))

      (test-text ""
                 (textual-trim-right (string->text "  a  b  c  ") char?))

      (test-text ""
                 (textual-trim-right (string->text "") char-whitespace? 0))

      (test-text "  a  b  c"
                 (textual-trim-right (string->text "  a  b  c  ")
                                     char-whitespace? 0))

      (test-text ""
                 (textual-trim-right (string->text "  a  b  c  ") char? 0))

      (test-text "  b  c"
                 (textual-trim-right (string->text "  a  b  c  ")
                                     char-whitespace? 3))

      (test-text ""
                 (textual-trim-right (string->text "  a  b  c  ") char? 3))

      (test-text ""
                 (textual-trim-right (string->text "  a  b  c  ") char? 0 11))

      (test-text "  b  c"
                 (textual-trim-right (string->text "  a  b  c  ")
                                     char-whitespace? 3 11))

      (test-text ""
                 (textual-trim-right (string->text "  a  b  c  ") char? 3 11))

      (test-text ""
                 (textual-trim-right (string->text "  a  b  c  ") char? 0 8))

      (test-text "  b"
                 (textual-trim-right (string->text "  a  b  c  ")
                                     char-whitespace? 3 8))

      (test-text ""
                 (textual-trim-right (string->text "  a  b  c  ") char? 3 8))


      (test-text ""
                 (textual-trim-both (string->text "")))

      (test-text "a  b  c"
                 (textual-trim-both (string->text "  a  b  c  ")))

      (test-text ""
                 (textual-trim-both (string->text "") char-whitespace?))

      (test-text "a  b  c"
                 (textual-trim-both (string->text "  a  b  c  ")
                                    char-whitespace?))

      (test-text ""
                 (textual-trim-both (string->text "  a  b  c  ") char?))

      (test-text ""
                 (textual-trim-both (string->text "") char-whitespace? 0))

      (test-text "a  b  c"
                 (textual-trim-both (string->text "  a  b  c  ")
                                    char-whitespace? 0))

      (test-text ""
                 (textual-trim-both (string->text "  a  b  c  ") char? 0))

      (test-text "b  c"
                 (textual-trim-both (string->text "  a  b  c  ")
                                    char-whitespace? 3))

      (test-text ""
                 (textual-trim-both (string->text "  a  b  c  ") char? 3))

      (test-text ""
                 (textual-trim-both (string->text "  a  b  c  ") char? 0 11))

      (test-text "b  c"
                 (textual-trim-both (string->text "  a  b  c  ")
                                    char-whitespace? 3 11))

      (test-text ""
                 (textual-trim-both (string->text "  a  b  c  ") char? 3 11))

      (test-text ""
                 (textual-trim-both (string->text "  a  b  c  ") char? 0 8))

      (test-text "b"
                 (textual-trim-both (string->text "  a  b  c  ")
                                    char-whitespace? 3 8))

      (test-text ""
                 (textual-trim-both (string->text "  a  b  c  ") char? 3 8))


      (test-text ""
                 (textual-trim ""))

      (test-text "a  b  c  "
                 (textual-trim "  a  b  c  "))

      (test-text ""
                 (textual-trim "" char-whitespace?))

      (test-text "a  b  c  "
                 (textual-trim "  a  b  c  " char-whitespace?))

      (test-text ""
                 (textual-trim "  a  b  c  " char?))

      (test-text ""
                 (textual-trim "" char-whitespace? 0))

      (test-text "a  b  c  "
                 (textual-trim "  a  b  c  " char-whitespace? 0))

      (test-text ""
                 (textual-trim "  a  b  c  " char? 0))

      (test-text "b  c  "
                 (textual-trim "  a  b  c  " char-whitespace? 3))

      (test-text ""
                 (textual-trim "  a  b  c  " char? 3))

      (test-text ""
                 (textual-trim "  a  b  c  " char? 0 11))

      (test-text "b  c  "
                 (textual-trim "  a  b  c  " char-whitespace? 3 11))

      (test-text ""
                 (textual-trim "  a  b  c  " char? 3 11))

      (test-text ""
                 (textual-trim "  a  b  c  " char? 0 8))

      (test-text "b  "
                 (textual-trim "  a  b  c  " char-whitespace? 3 8))

      (test-text ""
                 (textual-trim "  a  b  c  " char? 3 8))


      (test-text ""
                 (textual-trim-right ""))

      (test-text "  a  b  c"
                 (textual-trim-right "  a  b  c  "))

      (test-text ""
                 (textual-trim-right "" char-whitespace?))

      (test-text "  a  b  c"
                 (textual-trim-right "  a  b  c  " char-whitespace?))

      (test-text ""
                 (textual-trim-right "  a  b  c  " char?))

      (test-text ""
                 (textual-trim-right "" char-whitespace? 0))

      (test-text "  a  b  c"
                 (textual-trim-right "  a  b  c  " char-whitespace? 0))

      (test-text ""
                 (textual-trim-right "  a  b  c  " char? 0))

      (test-text "  b  c"
                 (textual-trim-right "  a  b  c  " char-whitespace? 3))

      (test-text ""
                 (textual-trim-right "  a  b  c  " char? 3))

      (test-text ""
                 (textual-trim-right "  a  b  c  " char? 0 11))

      (test-text "  b  c"
                 (textual-trim-right "  a  b  c  " char-whitespace? 3 11))

      (test-text ""
                 (textual-trim-right "  a  b  c  " char? 3 11))

      (test-text ""
                 (textual-trim-right "  a  b  c  " char? 0 8))

      (test-text "  b"
                 (textual-trim-right "  a  b  c  " char-whitespace? 3 8))

      (test-text ""
                 (textual-trim-right "  a  b  c  " char? 3 8))


      (test-text ""
                 (textual-trim-both ""))

      (test-text "a  b  c"
                 (textual-trim-both "  a  b  c  "))

      (test-text ""
                 (textual-trim-both "" char-whitespace?))

      (test-text "a  b  c"
                 (textual-trim-both "  a  b  c  " char-whitespace?))

      (test-text ""
                 (textual-trim-both "  a  b  c  " char?))

      (test-text ""
                 (textual-trim-both "" char-whitespace? 0))

      (test-text "a  b  c"
                 (textual-trim-both "  a  b  c  " char-whitespace? 0))

      (test-text ""
                 (textual-trim-both "  a  b  c  " char? 0))

      (test-text "b  c"
                 (textual-trim-both "  a  b  c  " char-whitespace? 3))

      (test-text ""
                 (textual-trim-both "  a  b  c  " char? 3))

      (test-text ""
                 (textual-trim-both "  a  b  c  " char? 0 11))

      (test-text "b  c"
                 (textual-trim-both "  a  b  c  " char-whitespace? 3 11))

      (test-text ""
                 (textual-trim-both "  a  b  c  " char? 3 11))

      (test-text ""
                 (textual-trim-both "  a  b  c  " char? 0 8))

      (test-text "b"
                 (textual-trim-both "  a  b  c  " char-whitespace? 3 8))

      (test-text ""
                 (textual-trim-both "  a  b  c  " char? 3 8))


      ;; Replacement

      (test-text "It's lots of fun to code it up in Scheme."
                 (textual-replace (as-text "It's easy to code it up in Scheme.")
                                  (as-text "lots of fun")
                                  5 9))

      (test-text "The miserable perl programmer endured daily ridicule."
                 (textual-replace "The TCL programmer endured daily ridicule."
                                  (as-text "another miserable perl drone")
                                  4 7 8 22))

      (test-text "It's really easy to code it up in Scheme."
                 (textual-replace (as-text "It's easy to code it up in Scheme.")
                                  "really "
                                  5 5))

      (test-text "Runs in O(1) time." ; for texts (using sample implementations)
                 (textual-replace "Runs in O(n) time." (text #\1) 10 11))

      ;; Comparison
      ;;
      ;; The comparison tests aren't perfectly black-box because the
      ;; specification of these comparison procedures allows them to
      ;; use an ordering other than the usual lexicographic ordering.
      ;; The sample implementations use lexicographic ordering, however,
      ;; and a test program that discourages implementations from using
      ;; orderings that differ from the usual on such simple cases is
      ;; probably doing a public service.

      (test #t (textual=? (as-text "Strasse") (as-text "Strasse")))

      (test #t (textual=? "Strasse" (as-text "Strasse") "Strasse"))

      (test #f (textual<? (as-text "z") (as-text "z")))
      (test #t (textual<? (as-text "z") "zz"))
      (test #f (textual<? (as-text "z") (as-text "Z")))
      (test #t (textual<=? (as-text "z") "zz"))
      (test #f (textual<=? "z" "Z"))
      (test #t (textual<=? "z" (as-text "z")))

      (test #f (textual<? "z" (as-text "z")))
      (test #f (textual>? (as-text "z") "zz"))
      (test #t (textual>? "z" (as-text "Z")))
      (test #f (textual>=? (as-text "z") "zz"))
      (test #t (textual>=? "z" "Z"))
      (test #t (textual>=? (as-text "z") (as-text "z")))


      (let* ((w "a")
             (x "abc")
             (y "def")
             (z (text #\a #\b #\c)))

        (test #f                           (textual=? x y z))
        (test #t                           (textual=? x x z))
        (test #f                           (textual=? w x y))
        (test #f                           (textual=? y x w))

        (test #f                           (textual<? x y z))
        (test #f                           (textual<? x x z))
        (test #t                           (textual<? w x y))
        (test #f                           (textual<? y x w))

        (test #f                           (textual>? x y z))
        (test #f                           (textual>? x x z))
        (test #f                           (textual>? w x y))
        (test #t                           (textual>? y x w))

        (test #f                          (textual<=? x y z))
        (test #t                          (textual<=? x x z))
        (test #t                          (textual<=? w x y))
        (test #f                          (textual<=? y x w))

        (test #f                          (textual>=? x y z))
        (test #t                          (textual>=? x x z))
        (test #f                          (textual>=? w x y))
        (test #t                          (textual>=? y x w))


        (test #t                             (textual=? x x))
        (test #f                             (textual=? w x))
        (test #f                             (textual=? y x))

        (test #f                             (textual<? x x))
        (test #t                             (textual<? w x))
        (test #f                             (textual<? y x))

        (test #f                             (textual>? x x))
        (test #f                             (textual>? w x))
        (test #t                             (textual>? y x))

        (test #t                            (textual<=? x x))
        (test #t                            (textual<=? w x))
        (test #f                            (textual<=? y x))

        (test #t                            (textual>=? x x))
        (test #f                            (textual>=? w x))
        (test #t                            (textual>=? y x)))


      (test #t (textual-ci<? "a" "Z"))
      (test #t (textual-ci<? "A" "z"))
      (test #f (textual-ci<? "Z" "a"))
      (test #f (textual-ci<? "z" "A"))
      (test #f (textual-ci<? "z" "Z"))
      (test #f (textual-ci<? "Z" "z"))
      (test #f (textual-ci>? "a" "Z"))
      (test #f (textual-ci>? "A" "z"))
      (test #t (textual-ci>? "Z" "a"))
      (test #t (textual-ci>? "z" "A"))
      (test #f (textual-ci>? "z" "Z"))
      (test #f (textual-ci>? "Z" "z"))
      (test #t (textual-ci=? "z" "Z"))
      (test #f (textual-ci=? "z" "a"))
      (test #t (textual-ci<=? "a" "Z"))
      (test #t (textual-ci<=? "A" "z"))
      (test #f (textual-ci<=? "Z" "a"))
      (test #f (textual-ci<=? "z" "A"))
      (test #t (textual-ci<=? "z" "Z"))
      (test #t (textual-ci<=? "Z" "z"))
      (test #f (textual-ci>=? "a" "Z"))
      (test #f (textual-ci>=? "A" "z"))
      (test #t (textual-ci>=? "Z" "a"))
      (test #t (textual-ci>=? "z" "A"))
      (test #t (textual-ci>=? "z" "Z"))
      (test #t (textual-ci>=? "Z" "z"))

      ;; The full-unicode feature doesn't imply full Unicode in strings,
      ;; so these tests might fail even in a conforming implementation.
      ;; Implementations that support full Unicode strings often have
      ;; this feature, however, even though it isn't listed in the R7RS.

      (cond-expand
       (full-unicode-strings
        (test #f (textual=? ABCDEF DEFABC))
        (test #f (textual=? DEFABC ABCDEF))
        (test #t (textual=? DEFABC DEFABC))

        (test #f (textual<? ABCDEF DEFABC))
        (test #t (textual<? DEFABC ABCDEF))
        (test #f (textual<? DEFABC DEFABC))

        (test #t (textual>? ABCDEF DEFABC))
        (test #f (textual>? DEFABC ABCDEF))
        (test #f (textual>? DEFABC DEFABC))

        (test #f (textual<=? ABCDEF DEFABC))
        (test #t (textual<=? DEFABC ABCDEF))
        (test #t (textual<=? DEFABC DEFABC))

        (test #t (textual>=? ABCDEF DEFABC))
        (test #f (textual>=? DEFABC ABCDEF))
        (test #t (textual>=? DEFABC DEFABC))

        (test #f (textual=? "Fuss" fuss))
        (test #f (textual=? "Fuss" "Fuss" fuss))
        (test #f (textual=? "Fuss" fuss "Fuss"))
        (test #f (textual=? fuss "Fuss" "Fuss"))
        (test #t (textual<? "z" (as-text eszett)))
        (test #f (textual<? (as-text eszett) "z"))
        (test #t (textual<=? "z" (as-text eszett)))
        (test #f (textual<=? (as-text eszett) "z"))
        (test #f (textual>? "z" (as-text eszett)))
        (test #t (textual>? (as-text eszett) "z"))
        (test #f (textual>=? "z" (as-text eszett)))
        (test #t (textual>=? (as-text eszett) "z"))
        (test-assert (textual-ci=? fuss "Fuss"))
        (test-assert (textual-ci=? fuss "FUSS"))
        (test-assert (textual-ci=? chaos0 chaos1 chaos2)))
       (else))

      ;; Prefixes and suffixes

      (test 0 (textual-prefix-length ABC ABCDEF))

      (test 0 (textual-prefix-length ABCDEF ABC))

      (test 0 (textual-prefix-length ABCDEF DEFABC))

      (test 6 (textual-prefix-length DEFABC DEFABC))

      (test 6 (textual-prefix-length (textual->string DEFABC) DEFABC))

      (test 6 (textual-prefix-length DEFABC (textual->string DEFABC)))

      (test 6 (textual-prefix-length (textual->string DEFABC)
                                     (textual->string DEFABC)))

      (test 0 (textual-prefix-length (as-text "") (as-text "")))

      (test 0 (textual-prefix-length (as-text "") (as-text "aabbccddee")))

      (test 0 (textual-prefix-length (as-text "aisle") (as-text "")))

      (test 0 (textual-prefix-length (as-text "") (as-text "aabbccddee")))

      (test 1 (textual-prefix-length (as-text "aisle") (as-text "aabbccddee")))

      (test 0 (textual-prefix-length (as-text "bail") (as-text "aabbccddee")))

      (test 4 (textual-prefix-length (as-text "prefix") (as-text "preface")))

      (test 0 (textual-prefix-length (as-text "") (as-text "") 0))

      (test 0 (textual-prefix-length (as-text "") (as-text "aabbccddee") 0))

      (test 0 (textual-prefix-length (as-text "aisle") (as-text "") 0))

      (test 1 (textual-prefix-length (as-text "aisle") (as-text "aabbccddee") 0))

      (test 0 (textual-prefix-length (as-text "bail") (as-text "aabbccddee") 0))

      (test 4 (textual-prefix-length (as-text "prefix") (as-text "preface") 0))

      (test 0 (textual-prefix-length (as-text "aisle") (as-text "") 1))

      (test 0 (textual-prefix-length (as-text "aisle") (as-text "aabbccddee") 1))

      (test 1 (textual-prefix-length (as-text "bail") (as-text "aabbccddee") 1))

      (test 0 (textual-prefix-length (as-text "prefix") (as-text "preface") 1))

      (test 0 (textual-prefix-length (as-text "") (as-text "") 0 0))

      (test 0 (textual-prefix-length (as-text "") (as-text "aabbccddee") 0 0))

      (test 0 (textual-prefix-length (as-text "aisle") (as-text "") 0 4))

      (test 1 (textual-prefix-length (as-text "aisle") (as-text "aabbccddee") 0 4))

      (test 0 (textual-prefix-length (as-text "bail") (as-text "aabbccddee") 0 1))

      (test 0 (textual-prefix-length (as-text "aisle") (as-text "") 1 4))

      (test 0 (textual-prefix-length (as-text "aisle") (as-text "aabbccddee") 1 4))

      (test 1 (textual-prefix-length (as-text "bail") (as-text "aabbccddee") 1 4))

      (test 0 (textual-prefix-length (as-text "prefix") (as-text "preface") 1 5))

      (test 0 (textual-prefix-length (as-text "") (as-text "") 0 0 0))

      (test 0 (textual-prefix-length (as-text "") (as-text "aabbccddee") 0 0 0))

      (test 0 (textual-prefix-length (as-text "aisle") (as-text "") 0 4 0))

      (test 0 (textual-prefix-length (as-text "aisle") (as-text "aabbccddee") 0 4 2))

      (test 1 (textual-prefix-length (as-text "bail") (as-text "aabbccddee") 0 1 2))

      (test 0 (textual-prefix-length (as-text "prefix") (as-text "preface") 0 5 1))

      (test 0 (textual-prefix-length (as-text "aisle") (as-text "") 1 4 0))

      (test 0 (textual-prefix-length (as-text "aisle") (as-text "aabbccddee") 1 4 3))

      (test 0 (textual-prefix-length (as-text "bail") (as-text "aabbccddee") 1 4 3))

      (test 3 (textual-prefix-length (as-text "prefix") (as-text "preface") 1 5 1))

      (test 0 (textual-prefix-length (as-text "") (as-text "") 0 0 0 0))

      (test 0 (textual-prefix-length (as-text "") (as-text "aabbccddee") 0 0 0 0))

      (test 0 (textual-prefix-length (as-text "aisle") (as-text "") 0 4 0 0))

      (test 0 (textual-prefix-length (as-text "aisle") "aabbccddee" 0 4 2 10))

      (test 1 (textual-prefix-length (as-text "bail") (as-text "aabbccddee") 0 1 2 10))

      (test 0 (textual-prefix-length (as-text "prefix") (as-text "preface") 0 5 1 6))

      (test 0 (textual-prefix-length (as-text "aisle") (as-text "") 1 4 0 0))

      (test 0 (textual-prefix-length (as-text "aisle") (as-text "aabbccddee") 1 4 3 3))

      (test 0 (textual-prefix-length (as-text "bail") (as-text "aabbccddee") 1 4 3 6))

      (test 3 (textual-prefix-length (as-text "prefix") (as-text "preface") 1 5 1 7))


      (test 0 (textual-suffix-length ABC ABCDEF))

      (test 0 (textual-suffix-length ABCDEF ABC))

      (test 0 (textual-suffix-length ABCDEF DEFABC))

      (test 6 (textual-suffix-length DEFABC DEFABC))

      (test 6 (textual-suffix-length (textual->string DEFABC) DEFABC))

      (test 6 (textual-suffix-length DEFABC (textual->string DEFABC)))

      (test 6 (textual-suffix-length (textual->string DEFABC) (textual->string DEFABC)))

      (test 0 (textual-suffix-length (as-text "") (as-text "")))

      (test 0 (textual-suffix-length (as-text "") (as-text "aabbccddee")))

      (test 0 (textual-suffix-length (as-text "aisle") (as-text "")))

      (test 0 (textual-suffix-length (as-text "") (as-text "aabbccddee")))

      (test 1 (textual-suffix-length (as-text "aisle") (as-text "aabbccddee")))

      (test 0 (textual-suffix-length (as-text "bail") (as-text "aabbccddee")))

      (test 3 (textual-suffix-length (as-text "place") (as-text "preface")))

      (test 0 (textual-suffix-length (as-text "") (as-text "") 0))

      (test 0 (textual-suffix-length (as-text "") (as-text "aabbccddee") 0))

      (test 0 (textual-suffix-length (as-text "aisle") (as-text "") 0))

      (test 1 (textual-suffix-length (as-text "aisle") (as-text "aabbccddee") 0))

      (test 0 (textual-suffix-length (as-text "bail") (as-text "aabbccddee") 0))

      (test 3 (textual-suffix-length (as-text "place") (as-text "preface") 0))

      (test 0 (textual-suffix-length (as-text "aisle") (as-text "") 1))

      (test 1 (textual-suffix-length (as-text "aisle") (as-text "aabbccddee") 1))

      (test 0 (textual-suffix-length (as-text "bail") (as-text "aabbccddee") 1))

      (test 3 (textual-suffix-length (as-text "place") (as-text "preface") 1))

      (test 0 (textual-suffix-length (as-text "") (as-text "") 0 0))

      (test 0 (textual-suffix-length (as-text "") (as-text "aabbccddee") 0 0))

      (test 0 (textual-suffix-length (as-text "aisle") (as-text "") 0 4))

      (test 0 (textual-suffix-length (as-text "aisle") (as-text "aabbccddee") 0 4))

      (test 0 (textual-suffix-length (as-text "bail") (as-text "aabbccddee") 0 1))

      (test 0 (textual-suffix-length (as-text "aisle") (as-text "") 1 4))

      (test 0 (textual-suffix-length (as-text "aisle") (as-text "aabbccddee") 1 4))

      (test 1 (textual-suffix-length (as-text "aisle") (as-text "aabbccddee") 1 5))

      (test 0 (textual-suffix-length (as-text "bail") (as-text "aabbccddee") 1 4))

      (test 3 (textual-suffix-length (as-text "place") (as-text "preface") 1 5))

      (test 0 (textual-suffix-length (as-text "") (as-text "") 0 0 0))

      (test 0 (textual-suffix-length (as-text "") (as-text "aabbccddee") 0 0 0))

      (test 0 (textual-suffix-length (as-text "aisle") (as-text "") 0 4 0))

      (test 0 (textual-suffix-length (as-text "aisle") (as-text "aabbccddee") 0 4 2))

      (test 0 (textual-suffix-length (as-text "bail") (as-text "aabbccddee") 0 1 2))

      (test 3 (textual-suffix-length (as-text "place") (as-text "preface") 0 5 1))

      (test 0 (textual-suffix-length (as-text "aisle") (as-text "") 1 4 0))

      (test 0 (textual-suffix-length (as-text "aisle") (as-text "aabbccddee") 1 4 3))

      (test 0 (textual-suffix-length (as-text "bail") (as-text "aabbccddee") 1 4 3))

      (test 3 (textual-suffix-length (as-text "place") (as-text "preface") 1 5 1))

      (test 0 (textual-suffix-length (as-text "") (as-text "") 0 0 0 0))

      (test 0 (textual-suffix-length (as-text "") (as-text "aabbccddee") 0 0 0 0))

      (test 0 (textual-suffix-length (as-text "aisle") (as-text "") 0 4 0 0))

      (test 1 (textual-suffix-length "aisle" (as-text "aabbccddee") 0 5 2 10))

      (test 1 (textual-suffix-length (as-text "bail") (as-text "aabbccddee") 0 1 2 4))

      (test 0 (textual-suffix-length (as-text "place") (as-text "preface") 0 5 1 6))

      (test 2 (textual-suffix-length (as-text "place") (as-text "preface") 0 4 1 6))

      (test 0 (textual-suffix-length (as-text "aisle") (as-text "") 1 4 0 0))

      (test 0 (textual-suffix-length (as-text "aisle") (as-text "aabbccddee") 1 4 3 3))

      (test 0 (textual-suffix-length (as-text "bail") (as-text "aabbccddee") 1 4 3 6))

      (test 3 (textual-suffix-length (as-text "place") (as-text "preface") 1 5 1 7))


      (test-assert (eq? #f (textual-prefix? ABC ABCDEF)))

      (test-assert (eq? #f (textual-prefix? ABCDEF ABC)))

      (test-assert (eq? #f (textual-prefix? ABCDEF DEFABC)))

      (test-assert (eq? #t (textual-prefix? DEFABC DEFABC)))

      (test-assert (eq? #t (textual-prefix? (textual->string DEFABC) DEFABC)))

      (test-assert (eq? #t (textual-prefix? DEFABC (textual->string DEFABC))))

      (test-assert (eq? #t (textual-prefix? (textual->string DEFABC) (textual->string DEFABC))))

      (test-assert (eq? #t (textual-prefix? (as-text "") (as-text ""))))

      (test-assert (eq? #t (textual-prefix? (as-text "") (as-text "abc"))))

      (test-assert (eq? #t (textual-prefix? (as-text "a") (as-text "abc"))))

      (test-assert (eq? #f (textual-prefix? (as-text "c") (as-text "abc"))))

      (test-assert (eq? #t (textual-prefix? (as-text "ab") (as-text "abc"))))

      (test-assert (eq? #f (textual-prefix? (as-text "ac") (as-text "abc"))))

      (test-assert (eq? #t (textual-prefix? (as-text "abc") (as-text "abc"))))

      (test-assert (eq? #f (textual-suffix? ABC ABCDEF)))

      (test-assert (eq? #f (textual-suffix? ABCDEF ABC)))

      (test-assert (eq? #f (textual-suffix? ABCDEF DEFABC)))

      (test-assert (eq? #t (textual-suffix? DEFABC DEFABC)))

      (test-assert (eq? #t (textual-suffix? (textual->string DEFABC) DEFABC)))

      (test-assert (eq? #t (textual-suffix? DEFABC (textual->string DEFABC))))

      (test-assert (eq? #t (textual-suffix? (as-text "") (as-text ""))))

      (test-assert (eq? #t (textual-suffix? (as-text "") (as-text "abc"))))

      (test-assert (eq? #f (textual-suffix? (as-text "a") (as-text "abc"))))

      (test-assert (eq? #t (textual-suffix? (as-text "c") (as-text "abc"))))

      (test-assert (eq? #f (textual-suffix? (as-text "ac") (as-text "abc"))))

      (test-assert (eq? #t (textual-suffix? (as-text "bc") (as-text "abc"))))

      (test-assert (eq? #t (textual-suffix? (as-text "abc") (as-text "abc"))))

      (test-assert (eq? #t (textual-prefix? (as-text "") (as-text "") 0)))

      (test-assert (eq? #t (textual-prefix? (as-text "") (as-text "abc") 0)))

      (test-assert (eq? #t (textual-prefix? (as-text "a") (as-text "abc") 0)))

      (test-assert (eq? #f (textual-prefix? (as-text "c") (as-text "abc") 0)))

      (test-assert (eq? #t (textual-prefix? (as-text "ab") (as-text "abc") 0)))

      (test-assert (eq? #f (textual-prefix? (as-text "ac") (as-text "abc") 0)))

      (test-assert (eq? #t (textual-prefix? (as-text "abc") (as-text "abc") 0)))

      (test-assert (eq? #t (textual-suffix? (as-text "") (as-text "") 0)))

      (test-assert (eq? #t (textual-suffix? (as-text "") (as-text "abc") 0)))

      (test-assert (eq? #f (textual-suffix? (as-text "a") (as-text "abc") 0)))

      (test-assert (eq? #t (textual-suffix? (as-text "c") (as-text "abc") 0)))

      (test-assert (eq? #f (textual-suffix? (as-text "ac") (as-text "abc") 0)))

      (test-assert (eq? #t (textual-suffix? (as-text "bc") (as-text "abc") 0)))

      (test-assert (eq? #t (textual-suffix? (as-text "abc") (as-text "abc") 0)))

      (test-assert (eq? #t (textual-prefix? (as-text "ab") (as-text "abc") 2)))

      (test-assert (eq? #t (textual-prefix? (as-text "ac") (as-text "abc") 2)))

      (test-assert (eq? #f (textual-prefix? (as-text "abc") (as-text "abc") 2)))

      (test-assert (eq? #t (textual-suffix? (as-text "ac") (as-text "abc") 2)))

      (test-assert (eq? #t (textual-suffix? (as-text "bc") (as-text "abc") 2)))

      (test-assert (eq? #t (textual-suffix? (as-text "abc") (as-text "abc") 2)))


      (test-assert (eq? #t (textual-prefix? (as-text "") (as-text "") 0 0)))

      (test-assert (eq? #t (textual-prefix? (as-text "") (as-text "abc") 0 0)))

      (test-assert (eq? #t (textual-prefix? (as-text "a") (as-text "abc") 0 0)))

      (test-assert (eq? #f (textual-prefix? (as-text "c") (as-text "abc") 0 1)))

      (test-assert (eq? #t (textual-prefix? (as-text "ab") (as-text "abc") 0 1)))

      (test-assert (eq? #t (textual-prefix? (as-text "ab") (as-text "abc") 0 2)))

      (test-assert (eq? #f (textual-prefix? (as-text "ac") (as-text "abc") 0 2)))

      (test-assert (eq? #t (textual-prefix? (as-text "abc") (as-text "abc") 0 3)))

      (test-assert (eq? #t (textual-suffix? (as-text "") (as-text "") 0 0)))

      (test-assert (eq? #t (textual-suffix? (as-text "") (as-text "abc") 0 0)))

      (test-assert (eq? #f (textual-suffix? (as-text "a") (as-text "abc") 0 1)))

      (test-assert (eq? #t (textual-suffix? (as-text "c") (as-text "abc") 0 1)))

      (test-assert (eq? #t (textual-suffix? (as-text "ac") (as-text "abc") 1 2)))

      (test-assert (eq? #f (textual-suffix? (as-text "ac") (as-text "abc") 0 2)))

      (test-assert (eq? #t (textual-suffix? (as-text "bc") (as-text "abc") 0 2)))

      (test-assert (eq? #t (textual-suffix? (as-text "abc") (as-text "abc") 0 3)))

      (test-assert (eq? #t (textual-prefix? (as-text "ab") (as-text "abc") 2 2)))

      (test-assert (eq? #t (textual-prefix? (as-text "ac") (as-text "abc") 2 2)))

      (test-assert (eq? #f (textual-prefix? (as-text "abc") (as-text "abc") 2 3)))

      (test-assert (eq? #t (textual-suffix? (as-text "ac") (as-text "abc") 2 2)))

      (test-assert (eq? #t (textual-suffix? (as-text "bc") (as-text "abc") 2 2)))

      (test-assert (eq? #t (textual-suffix? (as-text "abc") (as-text "abc") 2 3)))


      (test-assert (eq? #t (textual-prefix? (as-text "") (as-text "") 0 0 0)))

      (test-assert (eq? #t (textual-prefix? (as-text "") (as-text "abc") 0 0 0)))

      (test-assert (eq? #t (textual-prefix? (as-text "a") (as-text "abc") 0 0 0)))

      (test-assert (eq? #f (textual-prefix? (as-text "c") (as-text "abc") 0 1 0)))

      (test-assert (eq? #t (textual-prefix? (as-text "ab") (as-text "abc") 0 1 0)))

      (test-assert (eq? #t (textual-prefix? (as-text "ab") (as-text "abc") 0 2 0)))

      (test-assert (eq? #f (textual-prefix? (as-text "ac") (as-text "abc") 0 2 0)))

      (test-assert (eq? #t (textual-prefix? (as-text "abc") (as-text "abc") 0 3 0)))

      (test-assert (eq? #t (textual-suffix? (as-text "") (as-text "") 0 0 0)))

      (test-assert (eq? #t (textual-suffix? (as-text "") (as-text "abc") 0 0 0)))

      (test-assert (eq? #f (textual-suffix? (as-text "a") (as-text "abc") 0 1 0)))

      (test-assert (eq? #t (textual-suffix? (as-text "c") (as-text "abc") 0 1 0)))

      (test-assert (eq? #t (textual-suffix? (as-text "ac") (as-text "abc") 1 2 0)))

      (test-assert (eq? #f (textual-suffix? (as-text "ac") (as-text "abc") 0 2 0)))

      (test-assert (eq? #t (textual-suffix? (as-text "bc") (as-text "abc") 0 2 0)))

      (test-assert (eq? #t (textual-suffix? (as-text "abc") (as-text "abc") 0 3 0)))

      (test-assert (eq? #t (textual-prefix? (as-text "ab") (as-text "abc") 2 2 0)))

      (test-assert (eq? #t (textual-prefix? (as-text "ac") (as-text "abc") 2 2 0)))

      (test-assert (eq? #f (textual-prefix? (as-text "abc") (as-text "abc") 2 3 0)))

      (test-assert (eq? #t (textual-suffix? (as-text "ac") (as-text "abc") 2 2 0)))

      (test-assert (eq? #t (textual-suffix? (as-text "bc") (as-text "abc") 2 2 0)))

      (test-assert (eq? #t (textual-suffix? (as-text "abc") (as-text "abc") 2 3 0)))

      (test-assert (eq? #t (textual-prefix? (as-text "") (as-text "abc") 0 0 1)))

      (test-assert (eq? #t (textual-prefix? (as-text "a") (as-text "abc") 0 0 1)))

      (test-assert (eq? #t (textual-prefix? (as-text "c") (as-text "abc") 0 1 2)))

      (test-assert (eq? #f (textual-prefix? (as-text "ab") (as-text "abc") 0 1 2)))

      (test-assert (eq? #f (textual-prefix? (as-text "ab") (as-text "abc") 0 2 1)))

      (test-assert (eq? #f (textual-prefix? (as-text "ac") (as-text "abc") 0 2 1)))

      (test-assert (eq? #f (textual-prefix? (as-text "abc") (as-text "abc") 0 3 1)))

      (test-assert (eq? #f (textual-suffix? (as-text "a") (as-text "abc") 0 1 2)))

      (test-assert (eq? #t (textual-suffix? (as-text "c") (as-text "abc") 0 1 1)))

      (test-assert (eq? #t (textual-suffix? (as-text "ac") (as-text "abc") 1 2 2)))

      (test-assert (eq? #t (textual-suffix? (as-text "bc") (as-text "abc") 0 2 1)))

      (test-assert (eq? #f (textual-suffix? (as-text "bc") (as-text "abc") 0 2 2)))


      (test-assert (eq? #t (textual-prefix? (as-text "") (as-text "") 0 0 0 0)))

      (test-assert (eq? #t (textual-prefix? (as-text "") (as-text "abc") 0 0 0 3)))

      (test-assert (eq? #t (textual-prefix? (as-text "a") (as-text "abc") 0 0 0 3)))

      (test-assert (eq? #f (textual-prefix? (as-text "c") (as-text "abc") 0 1 0 3)))

      (test-assert (eq? #t (textual-prefix? (as-text "ab") (as-text "abc") 0 1 0 3)))

      (test-assert (eq? #t (textual-prefix? (as-text "ab") (as-text "abc") 0 2 0 3)))

      (test-assert (eq? #f (textual-prefix? (as-text "ac") (as-text "abc") 0 2 0 3)))

      (test-assert (eq? #t (textual-prefix? (as-text "abc") (as-text "abc") 0 3 0 3)))

      (test-assert (eq? #t (textual-suffix? (as-text "") (as-text "abc") 0 0 0 3)))

      (test-assert (eq? #f (textual-suffix? (as-text "a") (as-text "abc") 0 1 0 3)))

      (test-assert (eq? #t (textual-suffix? (as-text "c") (as-text "abc") 0 1 0 3)))

      (test-assert (eq? #t (textual-suffix? (as-text "ac") (as-text "abc") 1 2 0 3)))

      (test-assert (eq? #f (textual-suffix? (as-text "ac") (as-text "abc") 0 2 0 3)))

      (test-assert (eq? #t (textual-suffix? (as-text "bc") (as-text "abc") 0 2 0 3)))

      (test-assert (eq? #t (textual-suffix? (as-text "abc") (as-text "abc") 0 3 0 3)))

      (test-assert (eq? #t (textual-prefix? (as-text "ab") (as-text "abc") 2 2 0 3)))

      (test-assert (eq? #t (textual-prefix? (as-text "ac") (as-text "abc") 2 2 0 3)))

      (test-assert (eq? #f (textual-prefix? (as-text "abc") (as-text "abc") 2 3 0 3)))

      (test-assert (eq? #t (textual-suffix? (as-text "ac") (as-text "abc") 2 2 0 3)))

      (test-assert (eq? #t (textual-suffix? (as-text "bc") (as-text "abc") 2 2 0 3)))

      (test-assert (eq? #t (textual-suffix? (as-text "abc") (as-text "abc") 2 3 0 3)))

      (test-assert (eq? #t (textual-prefix? (as-text "") (as-text "abc") 0 0 1 3)))

      (test-assert (eq? #t (textual-prefix? (as-text "a") (as-text "abc") 0 0 1 3)))

      (test-assert (eq? #t (textual-prefix? (as-text "c") (as-text "abc") 0 1 2 3)))

      (test-assert (eq? #f (textual-prefix? (as-text "ab") (as-text "abc") 0 1 2 3)))

      (test-assert (eq? #f (textual-prefix? (as-text "ab") (as-text "abc") 0 2 1 3)))

      (test-assert (eq? #f (textual-prefix? (as-text "ac") (as-text "abc") 0 2 1 3)))

      (test-assert (eq? #f (textual-prefix? (as-text "abc") (as-text "abc") 0 3 1 3)))

      (test-assert (eq? #f (textual-suffix? (as-text "a") (as-text "abc") 0 1 2 3)))

      (test-assert (eq? #t (textual-suffix? (as-text "c") (as-text "abc") 0 1 1 3)))

      (test-assert (eq? #t (textual-suffix? (as-text "ac") (as-text "abc") 1 2 2 3)))

      (test-assert (eq? #t (textual-suffix? (as-text "bc") (as-text "abc") 0 2 1 3)))

      (test-assert (eq? #f (textual-suffix? (as-text "bc") (as-text "abc") 0 2 2 3)))


      (test-assert (eq? #t (textual-prefix? (as-text "") (as-text "abc") 0 0 0 2)))

      (test-assert (eq? #t (textual-prefix? (as-text "a") (as-text "abc") 0 0 0 2)))

      (test-assert (eq? #f (textual-prefix? (as-text "c") (as-text "abc") 0 1 0 2)))

      (test-assert (eq? #t (textual-prefix? (as-text "ab") (as-text "abc") 0 1 0 2)))

      (test-assert (eq? #f (textual-prefix? (as-text "abc") (as-text "abc") 0 3 0 2)))

      (test-assert (eq? #t (textual-suffix? (as-text "") (as-text "abc") 0 0 0 2)))

      (test-assert (eq? #f (textual-suffix? (as-text "c") (as-text "abc") 0 1 0 2)))

      (test-assert (eq? #f (textual-suffix? (as-text "ac") (as-text "abc") 1 2 0 2)))

      ;; Searching

      (test-assert (eqv? #f (textual-index (as-text "") char?)))

      (test-assert (eqv? 0 (textual-index (as-text "abcdef") char?)))

      (test-assert (eqv? 4 (textual-index (as-text "abcdef") (lambda (c) (char>? c #\d)))))

      (test-assert (eqv? #f (textual-index (as-text "abcdef") char-whitespace?)))

      (test-assert (eqv? #f (textual-index-right (as-text "") char?)))

      (test-assert (eqv? 5 (textual-index-right (as-text "abcdef") char?)))

      (test-assert (eqv? 5 (textual-index-right (as-text "abcdef")
                                                (lambda (c) (char>? c #\d)))))


      (test-assert (eqv? #f (textual-index-right (as-text "abcdef") char-whitespace?)))

      (test-assert (eqv? #f (textual-skip (as-text "") string?)))

      (test-assert (eqv? 0 (textual-skip (as-text "abcdef") string?)))

      (test-assert (eqv? 4 (textual-skip (as-text "abcdef") (lambda (c) (char<=? c #\d)))))

      (test-assert (eqv? #f (textual-skip (as-text "abcdef") char?)))

      (test-assert (eqv? #f (textual-skip-right (as-text "") string?)))

      (test-assert (eqv? 5 (textual-skip-right (as-text "abcdef") string?)))

      (test-assert (eqv? 5 (textual-skip-right (as-text "abcdef")
                                               (lambda (c) (char<=? c #\d)))))

      (test-assert (eqv? #f (textual-skip-right (as-text "abcdef") char?)))


      (test-assert (eqv? 2 (textual-index "abcdef" char? 2)))

      (test-assert (eqv? 4 (textual-index "abcdef" (lambda (c) (char>? c #\d)) 2)))

      (test-assert (eqv? #f (textual-index "abcdef" char-whitespace? 2)))

      (test-assert (eqv? 5 (textual-index-right "abcdef" char? 2)))

      (test-assert (eqv? 5 (textual-index-right "abcdef"
                                                (lambda (c)
                                                  (char>? c #\d)) 2)))

      (test-assert (eqv? #f (textual-index-right "abcdef" char-whitespace? 2)))

      (test-assert (eqv? 2 (textual-skip "abcdef" string? 2)))

      (test-assert (eqv? 4 (textual-skip "abcdef"
                                         (lambda (c)
                                           (char<=? c #\d)) 2)))

      (test-assert (eqv? #f (textual-skip "abcdef" char? 2)))

      (test-assert (eqv? 5 (textual-skip-right "abcdef" string? 2)))

      (test-assert (eqv? 5 (textual-skip-right "abcdef"
                                               (lambda (c)
                                                 (char<=? c #\d)) 2)))

      (test-assert (eqv? #f (textual-skip-right "abcdef" char? 2)))


      (test-assert (eqv? 2 (textual-index (as-text "abcdef") char? 2 5)))

      (test-assert (eqv? 4 (textual-index (as-text "abcdef")
                                          (lambda (c) (char>? c #\d)) 2 5)))

      (test-assert (eqv? #f (textual-index (as-text "abcdef") char-whitespace? 2 5)))

      (test-assert (eqv? 4 (textual-index-right (as-text "abcdef") char? 2 5)))

      (test-assert (eqv? 4 (textual-index-right (as-text "abcdef")
                                                (lambda (c)
                                                  (char>? c #\d)) 2 5)))

      (test-assert (eqv? #f (textual-index-right (as-text "abcdef")
                                                 char-whitespace? 2 5)))


      (test-assert (eqv? 2 (textual-skip (as-text "abcdef") string? 2 5)))

      (test-assert (eqv? 4 (textual-skip (as-text "abcdef")
                                         (lambda (c) (char<=? c #\d)) 2 5)))

      (test-assert (eqv? #f (textual-skip (as-text "abcdef") char? 2 5)))

      (test-assert (eqv? 4 (textual-skip-right (as-text "abcdef") string? 2 5)))

      (test-assert (eqv? 4 (textual-skip-right (as-text "abcdef")
                                               (lambda (c)
                                                 (char<=? c #\d)) 2 5)))

      (test-assert (eqv? #f (textual-skip-right (as-text "abcdef") char? 2 5)))


      (test-assert (eqv? 0 (textual-contains (as-text "") (as-text ""))))

      (test-assert (eqv? 0 (textual-contains (as-text "abcdeffffoo") (as-text ""))))

      (test-assert (eqv? 0 (textual-contains (as-text "abcdeffffoo") (as-text "a"))))

      (test-assert (eqv? 5 (textual-contains (as-text "abcdeffffoo") (as-text "ff"))))

      (test-assert (eqv? 4 (textual-contains (as-text "abcdeffffoo") (as-text "eff"))))

      (test-assert (eqv? 8 (textual-contains (as-text "abcdeffffoo") (as-text "foo"))))

      (test-assert (eqv? #f (textual-contains (as-text "abcdeffffoo") (as-text "efffoo"))))

      (test-assert (eqv? 0 (textual-contains-right (as-text "") (as-text ""))))

      (test-assert (eqv? 11 (textual-contains-right (as-text "abcdeffffoo") (as-text ""))))

      (test-assert (eqv? 0 (textual-contains-right (as-text "abcdeffffoo") (as-text "a"))))

      (test-assert (eqv? 7 (textual-contains-right (as-text "abcdeffffoo") (as-text "ff"))))

      (test-assert (eqv? 4 (textual-contains-right (as-text "abcdeffffoo") (as-text "eff"))))

      (test-assert (eqv? 8 (textual-contains-right (as-text "abcdeffffoo") (as-text "foo"))))

      (test-assert (eqv? #f (textual-contains-right (as-text "abcdeffffoo")
                                                    (as-text "efffoo"))))


      (test-assert (eqv? 0 (textual-contains "" "" 0)))

      (test-assert (eqv? 2 (textual-contains "abcdeffffoo" "" 2)))

      (test-assert (eqv? #f (textual-contains "abcdeffffoo" "a" 2)))

      (test-assert (eqv? 5 (textual-contains "abcdeffffoo" "ff" 2)))

      (test-assert (eqv? 4 (textual-contains "abcdeffffoo" "eff" 2)))

      (test-assert (eqv? 8 (textual-contains "abcdeffffoo" "foo" 2)))

      (test-assert (eqv? #f (textual-contains "abcdeffffoo" "efffoo" 2)))

      (test-assert (eqv? 0 (textual-contains-right "" "" 0)))

      (test-assert (eqv? 11 (textual-contains-right "abcdeffffoo" "" 2)))

      (test-assert (eqv? #f (textual-contains-right "abcdeffffoo" "a" 2)))

      (test-assert (eqv? 7 (textual-contains-right "abcdeffffoo" "ff" 2)))

      (test-assert (eqv? 4 (textual-contains-right "abcdeffffoo" "eff" 2)))

      (test-assert (eqv? 8 (textual-contains-right "abcdeffffoo" "foo" 2)))

      (test-assert (eqv? #f (textual-contains-right "abcdeffffoo" "efffoo" 2)))


      (test-assert (eqv? 0 (textual-contains (as-text "") (as-text "") 0 0)))

      (test-assert (eqv? 2 (textual-contains (as-text "abcdeffffoo") (as-text "") 2 10)))

      (test-assert (eqv? #f (textual-contains (as-text "abcdeffffoo") (as-text "a") 2 10)))

      (test-assert (eqv? 5 (textual-contains (as-text "abcdeffffoo") (as-text "ff") 2 10)))

      (test-assert (eqv? 4 (textual-contains (as-text "abcdeffffoo") (as-text "eff") 2 10)))

      (test-assert (eqv? #f (textual-contains (as-text "abcdeffffoo") (as-text "foo") 2 10)))

      (test-assert (eqv? #f (textual-contains (as-text "abcdeffffoo") (as-text "efffoo") 2 10)))

      (test-assert (eqv? 0 (textual-contains-right (as-text "") (as-text "") 0 0)))

      (test-assert (eqv? 10 (textual-contains-right (as-text "abcdeffffoo") (as-text "") 2 10)))

      (test-assert (eqv? #f (textual-contains-right (as-text "abcdeffffoo") (as-text "a") 2 10)))

      (test-assert (eqv? 7 (textual-contains-right (as-text "abcdeffffoo") (as-text "ff") 2 10)))

      (test-assert (eqv? 4 (textual-contains-right (as-text "abcdeffffoo") (as-text "eff") 2 10)))

      (test-assert (eqv? #f (textual-contains-right (as-text "abcdeffffoo") "foo" 2 10)))

      (test-assert (eqv? #f (textual-contains-right "abcdeffffoo" (as-text "efffoo") 2 10)))


      (test-assert (eqv? 0 (textual-contains "" "" 0 0 0)))

      (test-assert (eqv? 2 (textual-contains "abcdeffffoo" "" 2 10 0)))

      (test-assert (eqv? 2 (textual-contains "abcdeffffoo" "a" 2 10 1)))

      (test-assert (eqv? 5 (textual-contains "abcdeffffoo" "ff" 2 10 1)))

      (test-assert (eqv? 5 (textual-contains "abcdeffffoo" "eff" 2 10 1)))

      (test-assert (eqv? #f (textual-contains "abcdeffffoo" "foo" 2 10 1)))

      (test-assert (eqv? #f (textual-contains "abcdeffffoo" "efffoo" 2 10 1)))

      (test-assert (eqv? 0 (textual-contains-right "" "" 0 0 0)))

      (test-assert (eqv? 10 (textual-contains-right "abcdeffffoo" "" 2 10 0)))

      (test-assert (eqv? 10 (textual-contains-right "abcdeffffoo" "a" 2 10 1)))

      (test-assert (eqv? 8 (textual-contains-right "abcdeffffoo" "ff" 2 10 1)))

      (test-assert (eqv? 7 (textual-contains-right "abcdeffffoo" "eff" 2 10 1)))

      (test-assert (eqv? #f (textual-contains-right "abcdeffffoo" "foo" 2 10 1)))

      (test-assert (eqv? #f (textual-contains-right "abcdeffffoo" "efffoo" 2 10 1)))


      (test-assert (eqv? 0 (textual-contains "" "" 0 0 0 0)))

      (test-assert (eqv? 2 (textual-contains "abcdeffffoo" "" 2 10 0 0)))

      (test-assert (eqv? 2 (textual-contains "abcdeffffoo" "a" 2 10 1 1)))

      (test-assert (eqv? 5 (textual-contains "abcdeffffoo" "ff" 2 10 1 2)))

      (test-assert (eqv? 5 (textual-contains "abcdeffffoo" "eff" 2 10 1 2)))

      (test-assert (eqv? 9 (textual-contains "abcdeffffoo" "foo" 2 10 1 2)))

      (test-assert (eqv? 4 (textual-contains "abcdeffffoo" "efffoo" 2 10 0 2)))

      (test-assert (eqv? 0 (textual-contains-right "" "" 0 0 0 0)))

      (test-assert (eqv? 10 (textual-contains-right "abcdeffffoo" "" 2 10 0 0)))

      (test-assert (eqv? 10 (textual-contains-right "abcdeffffoo" "a" 2 10 1 1)))

      (test-assert (eqv? 8  (textual-contains-right "abcdeffffoo" "ff" 2 10 1 2)))

      (test-assert (eqv? 8 (textual-contains-right "abcdeffffoo" "eff" 2 10 1 2)))

      (test-assert (eqv? 9 (textual-contains-right "abcdeffffoo" "foo" 2 10 1 2)))

      (test-assert (eqv? 7 (textual-contains-right "abcdeffffoo" "efffoo" 2 10 1 3)))


      ;; Case conversion

      ;; FIXME: should test some non-ASCII cases here.

      (test-text "1234STRIKES" (textual-upcase (as-text "1234Strikes")))

      (test-text "1234STRIKES" (textual-upcase (as-text "1234strikes")))

      (test-text "1234STRIKES" (textual-upcase (as-text "1234STRIKES")))

      (test-text "1234strikes" (textual-downcase (as-text "1234Strikes")))

      (test-text "1234strikes" (textual-downcase (as-text "1234strikes")))

      (test-text "1234strikes" (textual-downcase (as-text "1234STRIKES")))

      (test-text "1234strikes" (textual-foldcase (as-text "1234Strikes")))

      (test-text "1234strikes" (textual-foldcase (as-text "1234strikes")))

      (test-text "1234strikes" (textual-foldcase (as-text "1234STRIKES")))

      (test-text "And With Three Strikes You Are Out"
                 (textual-titlecase
                  (as-text "and with THREE STRIKES you are oUT")))

      ;; Concatenation

      (test-text "" (textual-append))

      (test-text "abcdef"
                 (textual-append (as-text "")
                                 (as-text "a")
                                 (as-text "bcd")
                                 "" "ef" "" ""))

      (test-text "" (textual-concatenate '()))

      (test-text "abcdef"
                 (textual-concatenate
                  (map string->text '("" "a" "bcd" "" "ef" "" ""))))

      ;; textual-concatenate is likely to have special cases for longer texts.

      (let* ((alphabet "abcdefghijklmnopqrstuvwxyz")
             (str1 alphabet)
             (str10 (apply string-append (vector->list (make-vector 10 str1))))
             (str100 (apply string-append (vector->list (make-vector 10 str10))))
             (str100-500 (substring str100 100 500))
             (str600-999 (substring str100 600 999))
             (alph1 (textual-copy alphabet))
             (alph10 (textual-concatenate (vector->list (make-vector 10 alph1))))
             (alph100 (textual-concatenate (vector->list (make-vector 10 alph10))))
             (t100-500 (subtext alph100 100 500))
             (t600-999 (subtext alph100 600 999)))

        (test-assert (result=? str10 alph10))

        (test-assert (result=? str100 alph100))

        (test-assert (result=? str100-500 t100-500))

        (test-assert (result=? str600-999 t600-999))

        ;; concatenating a short text with a long text

        (test-text (string-append str1 str600-999)
                   (textual-concatenate (list alph1 t600-999)))

        (test-text (string-append str1 str600-999)
                   (textual-concatenate (list alph1 (textual-copy t600-999))))

        (test-text (string-append str600-999 str1)
                   (textual-concatenate (list t600-999 alph1)))

        (test-text (string-append str600-999 str1)
                   (textual-concatenate (list (textual-copy t600-999) alph1))))


      (test-text "" (textual-concatenate-reverse '()))

      (test-text "efbcda"
                 (textual-concatenate-reverse
                  (map string->text '("" "a" "bcd" "" "ef" "" ""))))

      (test-text "huh?"
                 (textual-concatenate-reverse '() "huh?"))

      (test-text "efbcdaxy"
                 (textual-concatenate-reverse '("" "a" "bcd" "" "ef" "" "") "xy"))

      (test-text "huh"
                 (textual-concatenate-reverse '() "huh?" 3))

      (test-text "efbcdax"
                 (textual-concatenate-reverse
                  '("" "a" "bcd" "" "ef" "" "") "x" 1))


      (test-text "" (textual-join '()))

      (test-text " ab cd  e f "
                 (textual-join (map string->text '("" "ab" "cd" "" "e" "f" ""))))

      (test-text ""
                 (textual-join '() ""))

      (test-text "abcdef"
                 (textual-join '("" "ab" "cd" "" "e" "f" "") ""))

      (test-text ""
                 (textual-join '() "xyz"))

      (test-text "xyzabxyzcdxyzxyzexyzfxyz"
                 (textual-join '("" "ab" "cd" "" "e" "f" "") "xyz"))

      (test-text ""
                 (textual-join '() "" 'infix))

      (test-text "abcdef"
                 (textual-join '("" "ab" "cd" "" "e" "f" "") "" 'infix))

      (test-text ""
                 (textual-join '() "xyz" 'infix))

      (test-text "xyzabxyzcdxyzxyzexyzfxyz"
                 (textual-join '("" "ab" "cd" "" "e" "f" "") (as-text "xyz") 'infix))

      (test-assert (equal? 'horror
                           (guard (exn (#t 'horror))
                             (textual-join '() "" 'strict-infix))))

      (test-text "abcdef"
                 (textual-join '("" "ab" "cd" "" "e" "f" "") "" 'strict-infix))

      (test-assert (equal? 'wham
                           (guard (exn (else 'wham))
                             (textual-join '() "xyz" 'strict-infix))))

      (test-text "xyzabxyzcdxyzxyzexyzfxyz"
                 (textual-join '("" "ab" "cd" "" "e" "f" "") "xyz" 'strict-infix))

      (test-text ""
                 (textual-join '() "" 'suffix))

      (test-text "abcdef"
                 (textual-join '("" "ab" "cd" "" "e" "f" "") "" 'suffix))

      (test-text ""
                 (textual-join '() "xyz" 'suffix))

      (test-text "xyzabxyzcdxyzxyzexyzfxyzxyz"
                 (textual-join '("" "ab" "cd" "" "e" "f" "") "xyz" 'suffix))

      (test-text ""
                 (textual-join '() "" 'prefix))

      (test-text "abcdef"
                 (textual-join '("" "ab" "cd" "" "e" "f" "") "" 'prefix))

      (test-text ""
                 (textual-join '() "xyz" 'prefix))

      (test-text "xyzxyzabxyzcdxyzxyzexyzfxyz"
                 (textual-join '("" "ab" "cd" "" "e" "f" "") "xyz" 'prefix))


      ;; Fold & map & friends

      (test-assert (= 8
                      (textual-fold (lambda (c count)
                                      (if (char-whitespace? c)
                                          (+ count 1)
                                          count))
                                    0
                                    (as-text " ...a couple of spaces in this one... "))))

      (test-assert (= 7
                      (textual-fold (lambda (c count)
                                      (if (char-whitespace? c)
                                          (+ count 1)
                                          count))
                                    0
                                    " ...a couple of spaces in this one... "
                                    1)))

      (test-assert (= 6
                      (textual-fold (lambda (c count)
                                      (if (char-whitespace? c)
                                          (+ count 1)
                                          count))
                                    0
                                    " ...a couple of spaces in this one... "
                                    1
                                    32)))

      (test-assert (equal? (string->list "abcdef")
                           (textual-fold-right cons '() "abcdef")))

      (test-assert (equal? (string->list "def")
                           (textual-fold-right cons '() (as-text "abcdef") 3)))

      (test-assert (equal? (string->list "cde")
                           (textual-fold-right cons '() (as-text "abcdef") 2 5)))

      (test-assert (string=? "aabraacaadaabraa"
                             (let* ((s (as-text "abracadabra"))
                                    (ans-len (textual-fold (lambda (c sum)
                                                             (+ sum (if (char=? c #\a) 2 1)))
                                                           0 s))
                                    (ans (make-string ans-len)))
                               (textual-fold (lambda (c i)
                                               (let ((i (if (char=? c #\a)
                                                            (begin (string-set! ans i #\a)
                                                                   (+ i 1))
                                                            i)))
                                                 (string-set! ans i c)
                                                 (+ i 1)))
                                             0 s)
                               ans)))


      (test-text "abc" (textual-map string (as-text "abc")))

      (test-text "ABC" (textual-map char-upcase "abc"))

      (test-text "Hear-here!"
                 (textual-map (lambda (c0 c1 c2)
                                (case c0
                                  ((#\1) c1)
                                  ((#\2) (string c2))
                                  ((#\-) (text #\- c1))))
                              (string->text "1222-1111-2222")
                              (string->text "Hi There!")
                              (string->text "Dear John")))

      (test-assert (string=? "abc"
                             (let ((q (open-output-string)))
                               (textual-for-each (lambda (c) (write-char c q))
                                                 (as-text "abc"))
                               (get-output-string q))))

      (test-assert (equal? '("cfi" "beh" "adg")
                           (let ((x '()))
                             (textual-for-each (lambda (c1 c2 c3)
                                                 (set! x (cons (string c1 c2 c3) x)))
                                               "abc"
                                               (as-text "defxyz")
                                               (as-text "ghijklmnopqrstuvwxyz"))
                             x)))

      (test-text "abc"
                 (textual-map-index (lambda (i)
                                      (integer->char (+ i (char->integer #\a))))
                                    "xyz"))

      (test-text "def"
                 (textual-map-index (lambda (i)
                                      (integer->char (+ i (char->integer #\a))))
                                    "xyz***" 3))

      (test-text "cde"
                 (textual-map-index (lambda (i)
                                      (integer->char (+ i (char->integer #\a))))
                                    "......" 2 5))

      (test-assert (equal? '(101 100 99 98 97)
                           (let ((s (as-text "abcde"))
                                 (v '()))
                             (textual-for-each-index
                              (lambda (i)
                                (set! v (cons (char->integer (textual-ref s i)) v)))
                              s)
                             v)))

      (test-assert (equal? '(101 100 99)
                           (let ((s (as-text "abcde"))
                                 (v '()))
                             (textual-for-each-index
                              (lambda (i)
                                (set! v (cons (char->integer (textual-ref s i)) v)))
                              s 2)
                             v)))

      (test-assert (equal? '(99 98)
                           (let ((s (as-text "abcde"))
                                 (v '()))
                             (textual-for-each-index
                              (lambda (i)
                                (set! v (cons (char->integer (textual-ref s i)) v)))
                              s 1 3)
                             v)))

      (test-assert (= 6 (textual-count "abcdef" char?)))

      (test-assert (= 4 (textual-count "counting  whitespace, again " char-whitespace? 5)))

      (test-assert (= 3 (textual-count "abcdefwxyz"
                                       (lambda (c) (odd? (char->integer c)))
                                       2 8)))


      (test-text "aiueaaaoi"
                 (textual-filter (lambda (c) (memv c (textual->list "aeiou")))
                                 (as-text "What is number, that man may know it?")))

      (test-text "And wmn, tht sh my knw nmbr?"
                 (textual-remove (lambda (c) (memv c (textual->list "aeiou")))
                                 "And woman, that she may know number?"))

      (test-text "iueaaaoi"
                 (textual-filter (lambda (c) (memv c (textual->list "aeiou")))
                                 (as-text "What is number, that man may know it?")
                                 4))

      (test-text "mn, tht sh my knw nmbr?"
                 (textual-remove (lambda (c) (memv c (textual->list "aeiou")))
                                 "And woman, that she may know number?"
                                 6))

      (test-text "aaao"
                 (textual-filter (lambda (c) (memv c (textual->list "aeiou")))
                                 (as-text "What is number, that man may know it?")
                                 16 32))

      (test-text "And woman, that sh may know"
                 (textual-remove (lambda (c) (memv c (textual->list "eiu")))
                                 "And woman, that she may know number?"
                                 0 28))

      ;; Replication and splitting           ; ; ;

      (test-text "cdefabcdefabcd"
                 (textual-replicate "abcdef" -4 10))

      (test-text "bcdefbcdefbcd"
                 (textual-replicate "abcdef" 90 103 1))

      (test-text "ecdecdecde"
                 (textual-replicate "abcdef" -13 -3 2 5))

      (test-assert (equal? '() (map textual->string (textual-split "" ""))))

      (test-assert (equal? '("a" "b" "c") (map textual->string (textual-split "abc" ""))))

      (test-assert (equal? '("too" "" "much" "" "data")
                           (map textual->string
                                (textual-split "too  much  data" " "))))

      (test-assert (equal? '("" "there" "ya" "go" "")
                           (map textual->string
                                (textual-split "***there***ya***go***" "***"))))

      (test-assert (equal? '() (map textual->string (textual-split "" "" 'infix))))

      (test-assert (equal? '("a" "b" "c")
                           (map textual->string (textual-split "abc" "" 'infix))))

      (test-assert (equal? '("too" "" "much" "" "data")
                           (map textual->string
                                (textual-split "too  much  data" " " 'infix))))

      (test-assert (equal? '("" "there" "ya" "go" "")
                           (map textual->string
                                (textual-split "***there***ya***go***" "***" 'infix))))

      (test-assert (equal? 'error
                           (guard (exn (else 'error))
                             (map textual->string
                                  (textual-split "" "" 'strict-infix)))))

      (test-assert (equal? '("a" "b" "c")
                           (map textual->string
                                (textual-split "abc" "" 'strict-infix))))

      (test-assert (equal? '("too" "" "much" "" "data")
                           (map textual->string
                                (textual-split "too  much  data" " " 'strict-infix))))

      (test-assert (equal? '("" "there" "ya" "go" "")
                           (map textual->string
                                (textual-split "***there***ya***go***" "***" 'strict-infix))))

      (test-assert (equal? '()
                           (map textual->string
                                (textual-split "" "" 'prefix))))

      (test-assert (equal? '("a" "b" "c")
                           (map textual->string
                                (textual-split "abc" "" 'prefix))))

      (test-assert (equal? '("too" "" "much" "" "data")
                           (map textual->string
                                (textual-split "too  much  data" " " 'prefix))))

      (test-assert (equal? '("there" "ya" "go" "")
                           (map textual->string
                                (textual-split "***there***ya***go***" "***" 'prefix))))

      (test-assert (equal? '()
                           (map textual->string
                                (textual-split "" "" 'suffix))))

      (test-assert (equal? '("a" "b" "c")
                           (map textual->string
                                (textual-split "abc" "" 'suffix))))

      (test-assert (equal? '("too" "" "much" "" "data")
                           (map textual->string
                                (textual-split "too  much  data" " " 'suffix))))

      (test-assert (equal? '("" "there" "ya" "go")
                           (map textual->string
                                (textual-split "***there***ya***go***" "***" 'suffix))))


      (test-assert (equal? '()
                           (map textual->string
                                (textual-split "" "" 'infix #f))))

      (test-assert (equal? '("a" "b" "c")
                           (map textual->string
                                (textual-split "abc" "" 'infix #f))))

      (test-assert (equal? '("too" "" "much" "" "data")
                           (map textual->string
                                (textual-split "too  much  data" " " 'infix #f))))

      (test-assert (equal? '("" "there" "ya" "go" "")
                           (map textual->string
                                (textual-split "***there***ya***go***" "***" 'infix #f))))

      (test-assert (equal? 'error
                           (guard (exn (else 'error))
                             (map textual->string
                                  (textual-split "" "" 'strict-infix #f)))))

      (test-assert (equal? '("a" "b" "c")
                           (map textual->string
                                (textual-split "abc" "" 'strict-infix #f))))

      (test-assert (equal? '("too" "" "much" "" "data")
                           (map textual->string
                                (textual-split "too  much  data" " " 'strict-infix #f))))

      (test-assert (equal? '("" "there" "ya" "go" "")
                           (map textual->string
                                (textual-split "***there***ya***go***" "***" 'strict-infix #f))))

      (test-assert (equal? '()
                           (map textual->string
                                (textual-split "" "" 'prefix #f))))

      (test-assert (equal? '("a" "b" "c")
                           (map textual->string
                                (textual-split "abc" "" 'prefix #f))))

      (test-assert (equal? '("too" "" "much" "" "data")
                           (map textual->string
                                (textual-split "too  much  data" " " 'prefix #f))))

      (test-assert (equal? '("there" "ya" "go" "")
                           (map textual->string
                                (textual-split "***there***ya***go***" "***" 'prefix #f))))

      (test-assert (equal? '()
                           (map textual->string
                                (textual-split "" "" 'suffix #f))))

      (test-assert (equal? '("a" "b" "c")
                           (map textual->string
                                (textual-split "abc" "" 'suffix #f))))

      (test-assert (equal? '("too" "" "much" "" "data")
                           (map textual->string
                                (textual-split "too  much  data" " " 'suffix #f))))

      (test-assert (equal? '("" "there" "ya" "go")
                           (map textual->string
                                (textual-split "***there***ya***go***" "***" 'suffix #f))))


      (test-assert (equal? 'error
                           (guard (exn (else 'error))
                             (map textual->string
                                  (textual-split "" "" 'strict-infix 3)))))

      (test-assert (equal? '("a" "b" "c")
                           (map textual->string
                                (textual-split "abc" "" 'strict-infix 3))))

      (test-assert (equal? '("too" "" "much" " data")
                           (map textual->string
                                (textual-split "too  much  data" " " 'strict-infix 3))))

      (test-assert (equal? '("" "there" "ya" "go***")
                           (map textual->string
                                (textual-split "***there***ya***go***" "***" 'strict-infix 3))))

      (test-assert (equal? '()
                           (map textual->string
                                (textual-split "" "" 'prefix 3))))

      (test-assert (equal? '("a" "b" "c")
                           (map textual->string
                                (textual-split "abc" "" 'prefix 3))))

      (test-assert (equal? '("too" "" "much" " data")
                           (map textual->string
                                (textual-split "too  much  data" " " 'prefix 3))))

      (test-assert (equal? '("there" "ya" "go***")
                           (map textual->string
                                (textual-split "***there***ya***go***" "***" 'prefix 3))))

      (test-assert (equal? '()
                           (map textual->string
                                (textual-split "" "" 'suffix 3))))

      (test-assert (equal? '("a" "b" "c")
                           (map textual->string
                                (textual-split "abc" "" 'suffix 3))))

      (test-assert (equal? '("too" "" "much" " data")
                           (map textual->string
                                (textual-split "too  much  data" " " 'suffix 3))))

      (test-assert (equal? '("" "there" "ya" "go***")
                           (map textual->string
                                (textual-split "***there***ya***go***" "***" 'suffix 3))))


      (test-assert (equal? 'error
                           (guard (exn (else 'error))
                             (map textual->string
                                  (textual-split "" "" 'strict-infix 3 0)))))

      (test-assert (equal? '("b" "c")
                           (map textual->string
                                (textual-split "abc" "" 'strict-infix 3 1))))

      (test-assert (equal? '("oo" "" "much" " data")
                           (map textual->string
                                (textual-split "too  much  data" " " 'strict-infix 3 1))))

      (test-assert (equal? '("**there" "ya" "go" "")
                           (map textual->string
                                (textual-split "***there***ya***go***" "***" 'strict-infix 3 1))))

      (test-assert (equal? '()
                           (map textual->string
                                (textual-split "" "" 'prefix 3 0))))

      (test-assert (equal? '("b" "c")
                           (map textual->string
                                (textual-split "abc" "" 'prefix 3 1))))

      (test-assert (equal? '("oo" "" "much" " data")
                           (map textual->string
                                (textual-split "too  much  data" " " 'prefix 3 1))))

      (test-assert (equal? '("**there" "ya" "go" "")
                           (map textual->string
                                (textual-split "***there***ya***go***" "***" 'prefix 3 1))))

      (test-assert (equal? '()
                           (map textual->string
                                (textual-split "" "" 'suffix 3 0))))

      (test-assert (equal? '("b" "c")
                           (map textual->string
                                (textual-split "abc" "" 'suffix 3 1))))

      (test-assert (equal? '("oo" "" "much" " data")
                           (map textual->string
                                (textual-split "too  much  data" " " 'suffix 3 1))))

      (test-assert (equal? '("**there" "ya" "go")
                           (map textual->string
                                (textual-split "***there***ya***go***" "***" 'suffix 3 1))))


      (test-assert (equal? 'error
                           (guard (exn (else 'error))
                             (map textual->string
                                  (textual-split "" "" 'strict-infix 3 0 0)))))

      (test-assert (equal? '("b")
                           (map textual->string
                                (textual-split "abc" "" 'strict-infix 3 1 2))))

      (test-assert (equal? '("oo" "" "much" " ")
                           (map textual->string
                                (textual-split "too  much  data" " " 'strict-infix 3 1 11))))

      (test-assert (equal? '()
                           (map textual->string
                                (textual-split "" "" 'prefix 3 0 0))))

      (test-assert (equal? '("b")
                           (map textual->string
                                (textual-split "abc" "" 'prefix 3 1 2))))

      (test-assert (equal? '("oo" "" "much" " ")
                           (map textual->string
                                (textual-split "too  much  data" " " 'prefix 3 1 11))))

      (test-assert (equal? '()
                           (map textual->string
                                (textual-split "" "" 'suffix 3 0 0))))

      (test-assert (equal? '("b")
                           (map textual->string
                                (textual-split "abc" "" 'suffix 3 1 2))))

      (test-assert (equal? '("oo" "" "much" " ")
                           (map textual->string
                                (textual-split "too  much  data" " " 'suffix 3 1 11))))

      (test-end))))

;; Local variables:
;; eval: (put 'test-text 'scheme-indent-function 1)
;; End:
;;; Copyright (C) William D Clinger (2016).
;;; 
;;; Permission is hereby granted, free of charge, to any person
;;; obtaining a copy of this software and associated documentation
;;; files (the "Software"), to deal in the Software without
;;; restriction, including without limitation the rights to use,
;;; copy, modify, merge, publish, distribute, sublicense, and/or
;;; sell copies of the Software, and to permit persons to whom the
;;; Software is furnished to do so, subject to the following
;;; conditions:
;;; 
;;; The above copyright notice and this permission notice shall be
;;; included in all copies or substantial portions of the Software.
;;; 
;;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
;;; EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
;;; OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
;;; NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
;;; HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
;;; WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
;;; FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
;;; OTHER DEALINGS IN THE SOFTWARE. 

;;; FIXME: these utilities should be in a separate file

(define (complain name . args)
  (apply error
         (string-append (symbol->string name) ": illegal arguments")
         args))

(define (list->bytevector bytes)
  (let* ((n (length bytes))
         (bv (make-bytevector n)))
    (do ((i 0 (+ i 1))
         (bytes bytes (cdr bytes)))
        ((= i n))
      (bytevector-u8-set! bv i (car bytes)))
    bv))

;;; 1-argument version for internal use

(define (%string->text s)
  (if (string? s)
      (text-tabulate (lambda (i) (string-ref s i))
                     (string-length s))
      (complain 'string->text s)))

;;; A portable implementation can't rely on inlining,
;;; but it can rely on macros.

(define N 128)

(define (length&i0 len i0)
  (+ (* N len) i0))

#;
(define (length&i0.length k)
  (quotient k N))

#;
(define (length&i0.i0 k)
  (remainder k N))

(define-syntax length&i0.length
  (syntax-rules ()
   ((_ k)
    (quotient k N))))

(define-syntax length&i0.i0
  (syntax-rules ()
   ((_ k)
    (remainder k N))))

(define-record-type text-rtd
  (new-text0 k chunks)
  text?
  (k      text.k)
  (chunks text.chunks))

(define (%new-text len i0 chunks)
  (new-text0 (length&i0 len i0) chunks))

(define the-empty-text
  (%new-text 0 0 (vector (make-bytevector 0))))

;;; text? is defined by the record definition above.

(define (text-length txt)
  (if (text? txt)
      (length&i0.length (text.k txt))
      (error "text-length: not a text" txt)))

(define (text-ref txt i)
  (if (and (text? txt)
           (exact-integer? i)
           (<= 0 i))
      (let* ((k      (text.k txt))
             (chunks (text.chunks txt))
             (len    (length&i0.length k))
             (i0     (length&i0.i0 k))
             (i+i0   (+ i i0))
             (j      (quotient i+i0 N))
             (ii     (remainder i+i0 N)))
        (if (< i len)
            (let* ((sj (vector-ref chunks j))
                   (sjn (bytevector-length sj)))
              (if (if (< j (- (vector-length chunks) 1))
                      (= sjn N)
                      (= sjn (remainder (+ i0 len) N)))
                  (integer->char (bytevector-u8-ref sj ii))
                  (%utf8-ref sj ii)))
            (error "text-ref: index out of range" txt i)))
      (error "text-ref: illegal arguments" txt i)))

;;; Non-checking versions for internal use.

(define (%text-length txt)
  (length&i0.length (text.k txt)))

(define (%text-ref txt i)
  (let* ((k      (text.k txt))
         (chunks (text.chunks txt))
         (len    (length&i0.length k))
         (i0     (length&i0.i0 k))
         (i+i0   (+ i i0))
         (j      (quotient i+i0 N))
         (ii     (remainder i+i0 N))
         (sj     (vector-ref chunks j))
         (sjn    (bytevector-length sj)))
    (if (if (< j (- (vector-length chunks) 1))
            (= sjn N)
            (= sjn (remainder (+ i0 len) N)))
        (integer->char (bytevector-u8-ref sj ii))
        (%utf8-ref sj ii))))

;;; Returns character i of the UTF-8.

(define (%utf8-ref bv i)
  (let loop ((j 0)     ; character index of (bytevector-u8-ref bv k)
             (k 0))    ; byte index into bv
    (if (= i j)
        (%utf8-char-at bv k)
        (let ((byte (bytevector-u8-ref bv k)))
          (cond ((< byte 128)
                 (loop (+ j 1) (+ k 1)))
                ((< byte #b11100000)
                 (loop (+ j 1) (+ k 2)))
                ((< byte #b11110000)
                 (loop (+ j 1) (+ k 3)))
                (else
                 (loop (+ j 1) (+ k 4))))))))

(define (%utf8-char-at bv k)
  (let ((byte (bytevector-u8-ref bv k)))
    (cond ((< byte 128)
           (integer->char byte))
          ((< byte #b11100000)
           (let* ((byte2 (bytevector-u8-ref bv (+ k 1)))
                  (bits1 (- byte  #b11000000))
                  (bits2 (- byte2 #b10000000))
                  (cp    (+ (* 64 bits1) bits2)))
             (integer->char cp)))
          ((< byte #b11110000)
           (let* ((byte2 (bytevector-u8-ref bv (+ k 1)))
                  (byte3 (bytevector-u8-ref bv (+ k 2)))
                  (bits1 (- byte  #b11100000))
                  (bits2 (- byte2 #b10000000))
                  (bits3 (- byte3 #b10000000))
                  (cp    (+ (* 64 64 bits1) (* 64 bits2) bits3)))
             (integer->char cp)))
          (else
           (let* ((byte2 (bytevector-u8-ref bv (+ k 1)))
                  (byte3 (bytevector-u8-ref bv (+ k 2)))
                  (byte4 (bytevector-u8-ref bv (+ k 3)))
                  (bits1 (- byte  #b11110000))
                  (bits2 (- byte2 #b10000000))
                  (bits3 (- byte3 #b10000000))
                  (bits4 (- byte4 #b10000000))
                  (cp    (+ (* 64 64 64 bits1)
                            (* 64 64 bits2)
                            (* 64 bits3)
                            bits4)))
             (integer->char cp))))))

;;; text-tabulate avoids side effects (in case proc returns more than once)

(define (text-tabulate proc len)
  (if (= 0 len)
      the-empty-text
      (let loop ((i len)       ; highest index that's been tabulated
                 (chunks '())
                 (bytes '()))
        (cond ((= 0 i)
               (%new-text len
                           0
                           (list->vector
                            (cons (list->bytevector bytes)
                                  chunks))))
              ((and (= 0 (remainder i N))
                    (not (null? bytes)))
               (loop i
                     (cons (list->bytevector bytes) chunks)
                     '()))
              (else
               (let* ((i-1 (- i 1))
                      (c (proc i-1)))
                 (if (char? c)
                     (let ((cp (char->integer c)))
                       (loop i-1
                             chunks
                             (cond ((< cp #x0080)
                                    (cons cp bytes))
                                   ((< cp #x0800)
                                    (let* ((bits1 (quotient cp 64))
                                           (bits2 (remainder cp 64))
                                           (byte1 (+ bits1 #b11000000))
                                           (byte2 (+ bits2 #b10000000)))
                                      (cons byte1 (cons byte2 bytes))))
                                   ((< cp #x10000)
                                    (let* ((bits1 (quotient cp (* 64 64)))
                                           (bits2 (quotient
                                                   (remainder cp (* 64 64))
                                                   64))
                                           (bits3 (remainder cp 64))
                                           (byte1 (+ bits1 #b11100000))
                                           (byte2 (+ bits2 #b10000000))
                                           (byte3 (+ bits3 #b10000000)))
                                      (cons byte1
                                            (cons byte2
                                                  (cons byte3 bytes)))))
                                   (else
                                    (let* ((bits1 (quotient cp (* 64 64 64)))
                                           (bits2 (quotient
                                                   (remainder cp (* 64 64 64))
                                                   (* 64 64)))
                                           (bits3 (quotient
                                                   (remainder cp (* 64 64))
                                                   64))
                                           (bits4 (remainder cp 64))
                                           (byte1 (+ bits1 #b11110000))
                                           (byte2 (+ bits2 #b10000000))
                                           (byte3 (+ bits3 #b10000000))
                                           (byte4 (+ bits4 #b10000000)))
                                      (cons byte1
                                            (cons byte2
                                                  (cons byte3
                                                        (cons byte4
                                                              bytes)))))))))
                     (error "text-tabulate: proc returned a non-character"
                            proc len c))))))))

;;; FIXME: should the fast case do something different
;;; if the length of the result is sufficiently small?
;;; Probably not: splitting a 100-character text into
;;; 100 1-character texts should be fast, and programmers
;;; can now use text-copy instead if they're worried about it.
;;;
;;; subtext is now defined only for texts; use subtextual
;;; if the first argument might be a string.

(define (subtext txt start end)
  (cond ((and (text? txt)
              (exact-integer? start)
              (exact-integer? end)
              (<= 0 start end))
         (%subtext txt start end))
#;      ((string? txt)
         (%string->text (substring txt start end)))
        (else
         (complain 'subtext txt start end))))         

(define (%subtext txt start end)
  (let* ((k      (text.k txt))
         (chunks (text.chunks txt))
         (len    (length&i0.length k))
         (i0     (length&i0.i0 k))
         (i+i0   (+ start i0))
         (end+i0 (+ end i0))
         (len+i0 (+ len i0))
         (jstart (quotient i+i0 N))
         (jend   (quotient end+i0 N))
         (jlen   (quotient len N)))
    (if (<= end len)
        (cond ((= start end)
               the-empty-text)
              ((and (= 0 jstart)
                    (= jlen jend))
               ;; the fast case
               (%new-text (- end start) i+i0 chunks))
              (else
               (let* ((v (make-vector (+ 1 (- jend jstart)))))
                 (do ((j jstart (+ j 1)))
                     ((> j jend))
                   (vector-set! v (- j jstart) (vector-ref chunks j)))
                 (%new-text (- end start)
                            (remainder i+i0 N)
                            v))))
        (error "subtext: end out of range" txt start end))))

;;; There are a lot of special cases that could be exploited here:
;;;     share the characters of the longest text
;;;     share the characters of the longest run of texts
;;;         whose characters don't have to be copied
;;;             if (text-length txt1) is a multiple of N,
;;;                 and txt2 starts at offset 0,
;;;                 then txt1 and txt2 can be concatenated
;;;                 without copying any of their characters
;;;
;;; That's a partial list.
;;; It would be easy to spend more time detecting special cases
;;; than would be saved on average.
;;; In the interest of simplicity and reliability, this code
;;; currently implements only two special cases:
;;;     share the full chunks of the longest text
;;;         provided
;;;             it contains at least N characters
;;;             it contains at least half the characters of the result
;;;             its characters start at offset zero
;;;     share the full chunks of the first text
;;;         provided
;;;             it contains at least N characters
;;;             its characters start at offset zero

(define (textual-concatenate texts)
  (cond ((not (list? texts))
         (complain 'textual-concatenate texts))
        ((null? texts) the-empty-text)
        ((null? (cdr texts))
         (let ((txt (car texts)))
           (cond ((text? txt) txt)
                 ((string? txt)
                  (%string->text txt))
                 (else (complain 'textual-concatenate texts)))))
        (else
         (let loop ((items (reverse texts))
                    (real-texts '())
                    (n 0)
                    (longest #f)
                    (longest-length 0))
           (cond ((null? items)
                  (%text-concatenate-n real-texts n longest longest-length))
                 ((text? (car items))
                  (let* ((txt (car items))
                         (k (%text-length txt)))
                    (loop (cdr items)
                          (cons txt real-texts)
                          (+ n k)
                          (if (> k longest-length) txt longest)
                          (max k longest-length))))
                 ((string? (car items))
                  (loop (cons (%string->text (car items)) (cdr items))
                        real-texts n longest longest-length))
                 (else
                  (complain 'textual-concatenate texts)))))))

;;; All of the texts are really texts.  No strings.
;;; n is the length of the result.
;;; longest is #f or the longest of the texts, and
;;; longest-length is its length (or zero).

(define (%text-concatenate-n texts n longest longest-length)
  (if (and longest
           (> longest-length N)
           (< n (+ longest-length longest-length))
           (= 0 (length&i0.i0 (text.k longest))))
      (if (eq? longest (car texts))
          (%%text-concatenate-n texts n)
          (let loop ((texts texts)
                     (front '())
                     (front-length 0))
            (cond ((eq? longest (car texts))
                   (%%text-concatenate-front
                    (reverse front)
                    (%%text-concatenate-n texts (- n front-length))
                    front-length
                    n))
                  (else
                   (let ((txt (car texts)))
                     (loop (cdr texts)
                           (cons txt front)
                           (+ front-length (%text-length txt))))))))
      (%%text-concatenate-n texts n)))

;;; texts is a non-empty list of texts, with no strings.
;;; n is the length of the result.
;;;
;;; The text returned has a start index of zero.
;;;
;;; Special case:
;;; If the first text has a start index of zero,
;;; then its full chunks don't have to be copied.

(define (%%text-concatenate-n texts n)
  (if (= 0 n)
      the-empty-text
      (let* ((n/N     (quotient n N))
             (m       (remainder n N))
             (nchunks (+ n/N (if (= 0 m) 0 1)))
             (chunks  (make-vector nchunks 'bug-in-text-concatenate))
             (txt (car texts))
             (k   (text.k txt))
             (len (length&i0.length k))
             (i0  (length&i0.i0 k)))
        (if (and (> len N)
                 (= 0 i0))
            (let* ((j (quotient len N))
                   (ti (* j N))
                   (chunks0 (text.chunks txt)))
              (do ((i 0 (+ i 1)))
                  ((= i j))
                (vector-set! chunks i (vector-ref chunks0 i)))
              (%%text-concatenate-finish n 0 chunks j texts ti))
            (%%text-concatenate-finish n 0 chunks 0 texts 0)))))

;;; All of the texts are really texts.  No strings.
;;; The second argument is a text that starts at offset zero.
;;; k is the total length of the texts passed as first argument.
;;; n is the length of the result.
;;;
;;; Returns the texts concatenated with the second argument,
;;; without copying any chunks of the second argument.

(define (%%text-concatenate-front texts txt k n)
  (let* ((k/N     (quotient k N))
         (mk      (remainder k N))
         (i0      (if (= 0 mk) 0 (- N mk)))  ; start offset for result
         (kchunks (+ k/N (if (= 0 mk) 0 1))) ; number of new chunks
         (n-k     (- n k))
         (n-k/N   (quotient n-k N))
         (m       (remainder n-k N))
         (nchunks (+ kchunks
                     n-k/N
                     (if (= 0 m) 0 1)))
         (chunks  (make-vector nchunks 'bug-in-text-concatenate))
         (chunks2 (text.chunks txt)))

    ;; copy extant chunks

    (do ((i kchunks (+ i 1)))
        ((= i nchunks))
      (vector-set! chunks i (vector-ref chunks2 (- i kchunks))))

    (%%text-concatenate-finish n i0 chunks 0 texts 0)))

;;; Given:
;;;
;;;     n      : the length of a text to be created
;;;     i0     : start offset for the text to be created
;;;     chunks : the vector of chunks for that new text
;;;     j      : vector index of first uninitialized chunk
;;;     texts  : a non-empty list of texts to be copied into the chunks
;;;     ti     : index of first uncopied character in the first text
;;;
;;; Creates new chunks as necessary, copies the texts into those chunks
;;; and returns a new text.
;;; The given texts may not fill the chunks because the chunks
;;; of some shared text may already have been copied into some
;;; tail of the chunks vector.

(define (%%text-concatenate-finish n i0 chunks j texts ti)
  (let loop ((texts (cdr texts))
             (txt (car texts))
             (j j)    ; index into chunks
             (k i0)   ; index into (vector-ref chunks j)
             (ti ti)  ; index into txt
             (bytes (make-list i0 0))) ; bytes being collected for next chunk
    (cond ((= k N)
           (let ((bv (list->bytevector (reverse bytes))))
             (vector-set! chunks j bv))
           (loop texts txt (+ j 1) 0 ti '()))
          ((= ti (%text-length txt))
           (if (null? texts)
               (begin (if (not (null? bytes))
                          (let ((bv (list->bytevector (reverse bytes))))
                            (vector-set! chunks j bv)))
                      (%new-text n i0 chunks))
               (loop (cdr texts) (car texts) j k 0 bytes)))
          (else
           (let* ((cp (char->integer (%text-ref txt ti)))
                  (bytes (cond ((< cp #x0080)
                                (cons cp bytes))
                               ((< cp #x0800)
                                (let* ((bits1 (quotient cp 64))
                                       (bits2 (remainder cp 64))
                                       (byte1 (+ bits1 #b11000000))
                                       (byte2 (+ bits2 #b10000000)))
                                  (cons byte2 (cons byte1 bytes))))
                               ((< cp #x10000)
                                (let* ((bits1 (quotient cp (* 64 64)))
                                       (bits2 (quotient
                                               (remainder cp (* 64 64))
                                               64))
                                       (bits3 (remainder cp 64))
                                       (byte1 (+ bits1 #b11100000))
                                       (byte2 (+ bits2 #b10000000))
                                       (byte3 (+ bits3 #b10000000)))
                                  (cons byte3
                                        (cons byte2
                                              (cons byte1 bytes)))))
                               (else
                                (let* ((bits1 (quotient cp (* 64 64 64)))
                                       (bits2 (quotient
                                               (remainder cp (* 64 64 64))
                                               (* 64 64)))
                                       (bits3 (quotient
                                               (remainder cp (* 64 64))
                                               64))
                                       (bits4 (remainder cp 64))
                                       (byte1 (+ bits1 #b11110000))
                                       (byte2 (+ bits2 #b10000000))
                                       (byte3 (+ bits3 #b10000000))
                                       (byte4 (+ bits4 #b10000000)))
                                  (cons byte4
                                        (cons byte3
                                              (cons byte2
                                                    (cons byte1
                                                          bytes)))))))))
             (loop texts txt j (+ k 1) (+ ti 1) bytes))))))
;; param.scm -- SRFI-39 parameters
;; Copyright (c) 2010 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

(define (parameter-convert param value)
  (let ((proc (parameter-converter param)))
    (if (procedure? proc)
        (proc value)
        value)))

(define (make-parameter init . o)
  (let ((conv (and (pair? o) (car o))))
    (%make-parameter (if conv (conv init) init) conv)))

(define-syntax parameterize
  (syntax-rules ()
    ((parameterize ("step") old cons-new ((param value ptmp vtmp) ...) () body)
     (let ((ptmp param) ...)
       (let ((vtmp (parameter-convert ptmp value)) ...)
         (let ((old (thread-parameters)))
           (let ((new cons-new))
             (dynamic-wind
                 (lambda () (thread-parameters-set! new))
                 (lambda () . body)
                 (lambda () (thread-parameters-set! old))))))))
    ((parameterize ("step") old cons-new args ((param value) . rest) body)
     (parameterize ("step") old (cons (cons ptmp vtmp) cons-new) ((param value ptmp vtmp) . args) rest body))
    ((parameterize ((param value) ...) . body)
     (parameterize ("step") old (thread-parameters) () ((param value) ...) body))))
;; param.scm -- SRFI-39 parameters
;; Copyright (c) 2010-2011 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

(define (parameter-convert param value)
  (let ((proc (parameter-converter param)))
    (if (procedure? proc)
        (proc value)
        value)))

(define (make-parameter init . o)
  (let ((conv (and (pair? o) (car o))))
    (%make-parameter (if conv (conv init) init) conv)))

(define-syntax parameterize
  (syntax-rules ()
    ((parameterize ("step")
                   ((param value p old new) ...)
                   ()
                   body)
     (let ((p param) ...)
       (let ((old (p)) ...
             (new (parameter-convert p value)) ...)
         (dynamic-wind
          (lambda () (p new) ...)
          (lambda () . body)
          (lambda () (p old) ...)))))
    ((parameterize ("step")
                   args
                   ((param value) . rest)
                   body)
     (parameterize ("step")
                   ((param value p old new) . args)
                   rest
                   body))
    ((parameterize ((param value) ...) . body)
     (parameterize ("step")
                   ()
                   ((param value) ...)
                   body))))

(define-record-type Set (make-set table comparator) set?
  (table set-table)
  (comparator set-comparator))

(define (set comparator . elts)
  (let ((res (make-hash-table comparator)))
    (for-each (lambda (x) (hash-table-set! res x x)) elts)
    (make-set res comparator)))

(define (set-unfold comparator stop? mapper successor seed)
  (let ((mapper (lambda (acc) (let ((elt (mapper acc))) (values elt elt)))))
    (make-set (hash-table-unfold stop? mapper successor seed comparator)
              comparator)))

(define (set-contains? set element)
  (hash-table-contains? (set-table set) element))

(define (set-empty? set)
  (zero? (set-size set)))

(define (set-disjoint? set1 set2)
  (if (< (hash-table-size (set-table set2))
         (hash-table-size (set-table set1)))
      (set-disjoint? set2 set1)
      (let ((ht (set-table set2)))
        (not (hash-table-find (lambda (key value) (hash-table-contains? ht key))
                              (set-table set1)
                              (lambda () #f))))))

(define (set-member set element default)
  (hash-table-ref/default (set-table set) element default))

(define (set-element-comparator set)
  (set-comparator set))

(define (set-adjoin set . elts)
  (apply set-adjoin! (set-copy set) elts))

(define (set-adjoin! set . elts)
  (for-each (lambda (elt) (hash-table-set! (set-table set) elt elt)) elts)
  set)

(define (set-replace set element)
  (set-replace! (set-copy set) element))

(define (set-replace! set element)
  (when (hash-table-contains? (set-table set) element)
    (hash-table-delete! (set-table set) element)
    (hash-table-set! (set-table set) element element))
  set)

(define (set-delete set . elts)
  (set-delete-all set elts))

(define (set-delete! set . elts)
  (set-delete-all! set elts))

(define (set-delete-all set element-list)
  (set-delete-all! (set-copy set) element-list))

(define (set-delete-all! set element-list)
  (for-each (lambda (elt) (hash-table-delete! (set-table set) elt))
            element-list)
  set)

(define set-search!
  (let ((not-found (list 'not-found)))
    (lambda (set element failure success)
      (let ((elt (hash-table-ref/default (set-table set) element not-found)))
        (if (eq? elt not-found)
            (failure (lambda (obj)
                       (hash-table-set! (set-table set) element element)
                       (values set obj))
                     (lambda (obj)
                       (values set obj)))
            (success elt
                     (lambda (new-element obj)
                       (hash-table-delete! (set-table set) elt)
                       (hash-table-set! (set-table set) new-element new-element)
                       (values set obj))
                     (lambda (obj)
                       (hash-table-delete! (set-table set) element)
                       (values set obj))))))))

(define (set-size set)
  (hash-table-size (set-table set)))

(define (set-find predicate set failure)
  (call-with-current-continuation
   (lambda (return)
     (hash-table-for-each
      (lambda (elt _) (if (predicate elt) (return elt)))
      (set-table set))
     (failure))))

(define (set-count predicate set)
  (hash-table-count (lambda (key value) (predicate key)) (set-table set)))

(define (set-any? predicate set)
  (and (hash-table-find (lambda (key value) (predicate key))
                        (set-table set)
                        (lambda () #f))
       #t))

(define (set-every? predicate set)
  (not (set-any? (lambda (x) (not (predicate x))) set)))

(define (set-map comparator proc s)
  (set-fold (lambda (elt res) (set-adjoin! res (proc elt)))
            (set comparator)
            s))

(define (set-for-each proc set)
  (hash-table-for-each (lambda (elt _) (proc elt)) (set-table set)))

(define (set-fold proc nil set)
  (hash-table-fold (lambda (elt _ acc) (proc elt acc)) nil (set-table set)))

(define (set-filter predicate st)
  (set-fold (lambda (elt res)
              (if (predicate elt) (set-adjoin! res elt) res))
            (set (set-comparator st))
            st))

(define set-filter! set-filter)

(define (set-remove predicate set)
  (set-filter (lambda (elt) (not (predicate elt))) set))

(define set-remove! set-remove)

(define (set-partition predicate set)
  (values (set-filter predicate set)
          (set-remove predicate set)))

(define set-partition! set-partition)

(define (set-copy set)
  (make-set (hash-table-copy (set-table set))
            (set-comparator set)))

(define (set->list set)
  (hash-table-keys (set-table set)))

(define (list->set comparator list)
  (fold (lambda (elt set) (set-adjoin! set elt)) (set comparator) list))

(define (list->set! set list)
  (fold (lambda (elt set) (set-adjoin! set elt)) set list))

(define (comparable-sets? set1 set2)
  (or (eq? (set-comparator set1) (set-comparator set2))
      (error "can't compare sets with different comparators" set1 set2)))

(define (set=? set1 . sets)
  (or (null? sets)
      (and (comparable-sets? set1 (car sets))
           (= (set-size set1) (set-size (car sets)))
           (set-every? (lambda (elt) (set-contains? set1 elt)) (car sets))
           (apply set=? sets))))

(define (set<? set1 . sets)
  (or (null? sets)
      (and (comparable-sets? set1 (car sets))
           (< (set-size set1) (set-size (car sets)))
           (set-every? (lambda (elt) (set-contains? (car sets) elt)) set1)
           (apply set<? sets))))

(define (set>? . sets)
  (apply set<? (reverse sets)))

(define (set<=? set1 . sets)
  (or (null? sets)
      (and (comparable-sets? set1 (car sets))
           (<= (set-size set1) (set-size (car sets)))
           (set-every? (lambda (elt) (set-contains? (car sets) elt)) set1)
           (apply set<=? sets))))

(define (set>=? . sets)
  (apply set<=? (reverse sets)))

(define (set-union set1 . sets)
  (apply set-union! (set-copy set1) sets))

(define (set-intersection set1 . sets)
  (apply set-intersection! (set-copy set1) sets))

(define (set-difference set1 . sets)
  (apply set-difference! (set-copy set1) sets))

(define (set-xor set1 set2)
  (set-xor! (set-copy set1) set2))

(define (set-union! set1 . sets)
  (if (null? sets)
      set1
      (and (comparable-sets? set1 (car sets))
           (apply set-union!
                  (set-fold (lambda (elt set) (set-adjoin! set elt)) set1 (car sets))
                  (cdr sets)))))

(define (set-intersection! set1 . sets)
  (if (null? sets)
      set1
      (and (comparable-sets? set1 (car sets))
           (apply set-intersection!
                  (set-filter! (lambda (elt) (set-contains? (car sets) elt)) set1)
                  (cdr sets)))))

(define (set-difference! set1 . sets)
  (if (null? sets)
      set1
      (and (comparable-sets? set1 (car sets))
           (apply set-difference!
                  (set-remove! (lambda (elt) (set-contains? (car sets) elt)) set1)
                  (cdr sets)))))

(define (set-xor! set1 set2)
  (and (comparable-sets? set1 set2)
       (set-union (set-remove (lambda (elt) (set-contains? set2 elt)) set1)
                  (set-remove (lambda (elt) (set-contains? set1 elt)) set2))))

(define the-set-comparator
  (make-comparator set? set=? set<? hash))

(define-record-type Bag (make-bag table comparator) bag?
  (table bag-table)
  (comparator bag-comparator))

(define (bag comparator . elts)
  (let ((res (make-bag (make-hash-table comparator) comparator)))
    (for-each (lambda (x) (bag-adjoin! res x)) elts)
    res))

(define (bag-unfold comparator stop? mapper successor seed)
  (let ((mapper (lambda (acc) (let ((elt (mapper acc))) (values elt 1)))))
    (make-bag (hash-table-unfold stop? mapper successor seed comparator)
              comparator)))

(define (bag-contains? bag element)
  (hash-table-contains? (bag-table bag) element))

(define (bag-empty? bag)
  (zero? (bag-size bag)))

(define (bag-disjoint? bag1 bag2)
  (if (< (hash-table-size (bag-table bag2))
         (hash-table-size (bag-table bag1)))
      (bag-disjoint? bag2 bag1)
      (let ((ht (bag-table bag2)))
        (not (hash-table-find (lambda (key value) (hash-table-contains? ht key))
                              (bag-table bag1)
                              (lambda () #f))))))

(define (bag-member bag element default)
  ;; (let ((cell (hash-table-cell (bag-table bag) element #f)))
  ;;   (if cell (car cell) default))
  (if (hash-table-contains? (bag-table bag) element)
      element
      default))

(define (bag-element-comparator bag)
  (bag-comparator bag))

(define (bag-adjoin bag . elts)
  (apply bag-adjoin! (bag-copy bag) elts))

(define (bag-adjoin! bag . elts)
  (for-each (lambda (elt)
              (hash-table-update!/default (bag-table bag)
                                          elt
                                          (lambda (count) (+ 1 count))
                                          0))
            elts)
  bag)

(define (bag-replace bag element)
  (bag-replace! (bag-copy bag) element))

(define (bag-replace! bag element)
  (when (hash-table-contains? (bag-table bag) element)
    (hash-table-delete! (bag-table bag) element)
    (hash-table-set! (bag-table bag) element 1))
  bag)

(define (bag-delete bag . elts)
  (bag-delete-all bag elts))

(define (bag-delete! bag . elts)
  (bag-delete-all! bag elts))

(define (bag-delete-all bag element-list)
  (bag-delete-all! (bag-copy bag) element-list))

(define (bag-delete-all! bag element-list)
  (let ((ht (bag-table bag)))
    (for-each (lambda (elt)
                (let ((count (- (hash-table-ref/default ht elt 0) 1)))
                  (cond
                   ((positive? count) (hash-table-set! ht elt count))
                   ((zero? count) (hash-table-delete! ht elt)))))
              element-list))
  bag)

(define bag-search!
  (let ((not-found (list 'not-found)))
    (lambda (bag element failure success)
      (let ((elt (hash-table-ref/default (bag-table bag) element not-found)))
        (if (eq? elt not-found)
            (failure (lambda (obj)
                       (hash-table-set! (bag-table bag) element 1)
                       (values bag obj))
                     (lambda (obj)
                       (values bag obj)))
            (success elt
                     (lambda (new-element obj)
                       (hash-table-delete! (bag-table bag) element)
                       (bag-adjoin! bag new-element)
                       (values bag obj))
                     (lambda (obj)
                       (hash-table-delete! (bag-table bag) element)
                       (values bag obj))))))))

(define (bag-size bag)
  (hash-table-fold (bag-table bag) (lambda (elt count acc) (+ count acc)) 0))

(define (bag-find predicate bag failure)
  (call-with-current-continuation
   (lambda (return)
     (hash-table-for-each
      (lambda (elt count) (if (predicate elt) (return elt)))
      (bag-table bag))
     (failure))))

(define (bag-count predicate bag)
  (hash-table-fold (lambda (elt count acc) (+ acc (if (predicate elt) count 0)))
                   0
                   (bag-table bag)))

(define (bag-any? predicate bag)
  (and (hash-table-find (lambda (key value) (predicate key))
                        (bag-table bag)
                        (lambda () #f))
       #t))

(define (bag-every? predicate bag)
  (not (bag-any? (lambda (x) (not (predicate x))) bag)))

(define (bag-map comparator proc s)
  (bag-fold (lambda (elt res) (bag-adjoin! res (proc elt)))
            (bag comparator)
            s))

(define (bag-for-each proc bag)
  (hash-table-for-each (lambda (elt count)
                         (let lp ((i count))
                           (when (positive? i)
                             (proc elt)
                             (lp (- i 1)))))
                       (bag-table bag)))

(define (bag-fold proc nil bag)
  (hash-table-fold (lambda (elt count acc)
                     (let lp ((i count) (acc acc))
                       (if (zero? i)
                           acc
                           (lp (- i 1) (proc elt acc)))))
                   nil
                   (bag-table bag)))

(define (bag-filter predicate st)
  (bag-fold (lambda (elt res)
              (if (predicate elt) (bag-adjoin! res elt) res))
            (bag (bag-comparator st))
            st))

(define bag-filter! bag-filter)

(define (bag-remove predicate bag)
  (bag-filter (lambda (elt) (not (predicate elt))) bag))

(define bag-remove! bag-remove)

(define (bag-partition predicate bag)
  (values (bag-filter predicate bag)
          (bag-remove predicate bag)))

(define bag-partition! bag-partition)

(define (bag-copy bag)
  (make-bag (hash-table-copy (bag-table bag))
            (bag-comparator bag)))

(define (bag->list bag)
  (hash-table-keys (bag-table bag)))

(define (list->bag comparator list)
  (fold (lambda (elt bag) (bag-adjoin! bag elt)) (bag comparator) list))

(define (list->bag! bag list)
  (fold (lambda (elt bag) (bag-adjoin! bag elt)) bag list))

(define (comparable-bags? bag1 bag2)
  (or (eq? (bag-comparator bag1) (bag-comparator bag2))
      (error "can't compare bags with different comparators" bag1 bag2)))

(define (bag=? bag1 . bags)
  (or (null? bags)
      (and (comparable-bags? bag1 (car bags))
           (= (bag-size bag1) (bag-size (car bags)))
           (bag-every? (lambda (elt) (bag-contains? bag1 elt)) (car bags))
           (apply bag=? bags))))

(define (bag<? bag1 . bags)
  (or (null? bags)
      (and (comparable-bags? bag1 (car bags))
           (< (bag-size bag1) (bag-size (car bags)))
           (bag-every? (lambda (elt) (bag-contains? (car bags) elt)) bag1)
           (apply bag<? bags))))

(define (bag>? . bags)
  (apply bag<? (reverse bags)))

(define (bag<=? bag1 . bags)
  (or (null? bags)
      (and (comparable-bags? bag1 (car bags))
           (<= (bag-size bag1) (bag-size (car bags)))
           (bag-every? (lambda (elt) (bag-contains? (car bags) elt)) bag1)
           (apply bag<=? bags))))

(define (bag>=? . bags)
  (apply bag<=? (reverse bags)))

(define (bag-union bag1 . bags)
  (apply bag-union! (bag-copy bag1) bags))

(define (bag-intersection bag1 . bags)
  (apply bag-intersection! (bag-copy bag1) bags))

(define (bag-difference bag1 . bags)
  (apply bag-difference! (bag-copy bag1) bags))

(define (bag-xor bag1 bag2)
  (bag-xor! (bag-copy bag1) bag2))

(define (bag-union! bag1 . bags)
  (if (null? bags)
      bag1
      (and (comparable-bags? bag1 (car bags))
           (begin
             (hash-table-for-each
              (lambda (elt count)
                (hash-table-update!/default (bag-table bag1)
                                            elt
                                            (lambda (c) (max c count))
                                            count))
              (bag-table (car bags)))
             (apply bag-union! bag1 (cdr bags))))))

(define (bag-intersection! bag1 . bags)
  (if (null? bags)
      bag1
      (and (comparable-bags? bag1 (car bags))
           (let ((ht (bag-table (car bags))))
             (hash-table-for-each
              (lambda (elt count)
                (let ((count2 (min count (hash-table-ref/default ht elt 0))))
                  (if (positive? count2)
                      (hash-table-set! (bag-table bag1) elt count2)
                      (hash-table-delete! (bag-table bag1) elt))))
              (bag-table bag1))
             (apply bag-intersection! bag1 (cdr bags))))))

(define (bag-difference! bag1 . bags)
  (if (null? bags)
      bag1
      (and (comparable-bags? bag1 (car bags))
           (let ((ht (bag-table (car bags))))
             (hash-table-for-each
              (lambda (elt count)
                (let ((count2 (- count (hash-table-ref/default ht elt 0))))
                  (if (positive? count2)
                      (hash-table-set! (bag-table bag1) elt count2)
                      (hash-table-delete! (bag-table bag1) elt))))
              (bag-table bag1))
             (apply bag-difference! bag1 (cdr bags))))))

(define (bag-xor! bag1 bag2)
  (and (comparable-bags? bag1 bag2)
       (let ((ht1 (bag-table bag1))
             (ht2 (bag-table bag2)))
         (hash-table-for-each
          (lambda (elt count)
            (let ((count2 (abs (- count (hash-table-ref/default ht1 elt 0)))))
              (if (positive? count2)
                  (hash-table-set! ht1 elt count2)
                  (hash-table-delete! ht1 elt))))
          ht2)
         bag1)))

(define (bag-sum bag1 . bags)
  (apply bag-sum! (bag-copy bag1) bags))

(define (bag-sum! bag1 . bags)
  (if (null? bags)
      bag1
      (and (comparable-bags? bag1 (car bags))
           (begin
             (hash-table-for-each
              (lambda (elt count)
                (hash-table-update!/default (bag-table bag1)
                                            elt
                                            (lambda (c) (+ c count))
                                            count))
              (bag-table (car bags)))
             (apply bag-sum! bag1 (cdr bags))))))

(define (bag-product n bag)
  (bag-product! n (bag-copy bag)))

(define (bag-product! n bag)
  (for-each
   (lambda (elt)
     (hash-table-update! (bag-table bag) elt (lambda (count) (* n count))))
   (hash-table-keys (bag-table bag)))
  bag)

(define (bag-unique-size bag)
  (hash-table-size (bag-table bag)))

(define (bag-element-count bag element)
  (hash-table-ref/default (bag-table bag) element 0))

(define (bag-for-each-unique proc bag)
  (hash-table-for-each proc (bag-table bag)))

(define (bag-fold-unique proc nil bag)
  (hash-table-fold proc nil (bag-table bag)))

(define (bag-increment! bag element count)
  (let* ((ht (bag-table bag))
         (count2 (+ count (hash-table-ref/default ht element 0))))
    (if (positive? count2)
        (hash-table-set! ht element count2)
        (hash-table-delete! ht element))))

(define (bag-decrement! bag element count)
  (bag-increment! bag element (- count)))

(define (bag->set bag)
  (let ((ht (hash-table-copy (bag-table bag))))
    (hash-table-map! (lambda (key count) key) ht)
    (make-set ht (bag-comparator bag))))

(define (set->bag set)
  (set->bag! (bag (set-comparator set)) set))

(define (set->bag! bag set)
  (set-for-each (lambda (elt) (bag-adjoin! bag elt)) set)
  bag)

(define (bag->alist bag)
  (hash-table->alist (bag-table bag)))

(define (alist->bag comparator alist)
  (let ((res (bag comparator)))
    (for-each (lambda (x) (bag-increment! res (car x) (cdr x))) alist)
    res))

(define the-bag-comparator
  (make-comparator bag? bag=? bag<? hash))
;; adapted from the reference implementation

(define-library (srfi 113 test)
  (import (scheme base) (scheme char) (srfi 113) (srfi 128) (chibi test))
  (export run-tests)
  (begin
    (define equal-comparator (make-equal-comparator))
    (define eqv-comparator (make-eqv-comparator))
    (define eq-comparator (make-eq-comparator))
    (define number-comparator
      (make-comparator real? = < (lambda (x . o) (exact (abs (round x))))))
    (define char-comparator
      (make-comparator char? char=? char<? char-hash))
    (define string-ci-comparator
      (make-comparator string? string-ci=? string-ci<? string-ci-hash))
    (define (run-tests)
      (test-group "srfi-113: sets"
        (define (big x) (> x 5))

        (test-group "sets/simple"
          (define nums (set number-comparator))
          ;; nums is now {}
          (define syms (set eq-comparator 'a 'b 'c 'd))
          ;; syms is now {a, b, c, d}
          (define nums2 (set-copy nums))
          ;; nums2 is now {}
          (define syms2 (set-copy syms))
          ;; syms2 is now {a, b, c, d}
          (define esyms (set eq-comparator))
          ;; esyms is now {}
          (define total 0)
          (test-assert (set-empty? esyms))
          (test-assert (set? nums))
          (test-assert (set? syms))
          (test-assert (set? nums2))
          (test-assert (set? syms2))
          (test-assert (not (set? 'a)))
          (set! nums (set-adjoin! nums 2))
          (set! nums (set-adjoin! nums 3))
          (set! nums (set-adjoin! nums 4))
          (set! nums (set-adjoin! nums 4))
          ;; nums is now {2, 3, 4}
          (test 4 (set-size (set-adjoin nums 5)))
          (test 3 (set-size nums))
          (test 3 (set-size (set-delete syms 'd)))
          (test 2 (set-size (set-delete-all syms '(c d))))
          (test 4 (set-size syms))
          (set! syms (set-adjoin! syms 'e 'f))
          ;; syms is now {a, b, c, d, e, f}
          (test 4 (set-size (set-delete-all! syms '(e f))))
          ;; syms is now {a, b, c, d}
          (test 0 (set-size nums2))
          (test 4 (set-size syms2))
          (set! nums (set-delete! nums 2))
          ;; nums is now {3, 4}
          (test 2 (set-size nums))
          (set! nums (set-delete! nums 1))
          (test-assert (set-contains? nums 3))
          (test 2 (set-size nums))
          (set! nums2 (set-map number-comparator (lambda (x) (* 10 x)) nums))
          ;; nums2 is now {30, 40}
          (test-assert (set-contains? nums2 30))
          (test-assert (not (set-contains? nums2 3)))
          (set-for-each (lambda (x) (set! total (+ total x))) nums2)
          (test 70 total)
          (test 10 (set-fold + 3 nums))
          (set! nums (set eqv-comparator 10 20 30 40 50))
          ;; nums is now {10, 20, 30, 40, 50}
          (test-assert
              (set=? nums (set-unfold
                           eqv-comparator
                           (lambda (i) (= i 0))
                           (lambda (i) (* i 10))
                           (lambda (i) (- i 1))
                           5)))
          (test '(a) (set->list (set eq-comparator 'a)))
          (set! syms2 (list->set eq-comparator '(e f)))
          ;; syms2 is now {e, f}
          (test 2 (set-size syms2))
          (test-assert (set-contains? syms2 'e))
          (test-assert (set-contains? syms2 'f))
          (test 4 (set-size (list->set! syms2 '(a b))))
          )

        (test-group "sets/search"
          (define yam (set char-comparator #\y #\a #\m))
          (define (failure/insert insert ignore)
            (insert 1))
          (define (failure/ignore insert ignore)
            (ignore 2))
          (define (success/update element update remove)
            (update #\b 3))
          (define (success/remove element update remove)
            (remove 4))
          (define yam! (set char-comparator #\y #\a #\m #\!))
          (define bam (set char-comparator #\b #\a #\m))
          (define ym (set char-comparator #\y #\m))
          (define-values (set1 obj1)
            (set-search! (set-copy yam) #\! failure/insert error))
          (define-values (set2 obj2)
            (set-search! (set-copy yam) #\! failure/ignore error))
          (define-values (set3 obj3)
            (set-search! (set-copy yam) #\y error success/update))
          (define-values (set4 obj4)
            (set-search! (set-copy yam) #\a error success/remove))
          (test-assert (set=? yam! set1))
          (test 1 obj1)
          (test-assert (set=? yam set2))
          (test 2 obj2)
          (test-assert (set=? bam set3))
          (test 3 obj3)
          (test-assert (set=? ym set4))
          (test 4 obj4)
          )

        (test-group "sets/subsets"
          (define set2 (set number-comparator 1 2))
          (define other-set2 (set number-comparator 1 2))
          (define set3 (set number-comparator 1 2 3))
          (define set4 (set number-comparator 1 2 3 4))
          (define setx (set number-comparator 10 20 30 40))
          (test-assert (set=? set2 other-set2))
          (test-assert (not (set=? set2 set3)))
          (test-assert (not (set=? set2 set3 other-set2)))
          (test-assert (set<? set2 set3 set4))
          (test-assert (not (set<? set2 other-set2)))
          (test-assert (set<=? set2 other-set2 set3))
          (test-assert (not (set<=? set2 set3 other-set2)))
          (test-assert (set>? set4 set3 set2))
          (test-assert (not (set>? set2 other-set2)))
          (test-assert (set>=? set3 other-set2 set2))
          (test-assert (not (set>=? other-set2 set3 set2)))
          )

        (test-group "sets/ops"
          ;; Potentially mutable
          (define abcd (set eq-comparator 'a 'b 'c 'd))
          (define efgh (set eq-comparator 'e 'f 'g 'h))
          (define abgh (set eq-comparator 'a 'b 'g 'h))
          ;; Never get a chance to be mutated
          (define other-abcd (set eq-comparator 'a 'b 'c 'd))
          (define other-efgh (set eq-comparator 'e 'f 'g 'h))
          (define other-abgh (set eq-comparator 'a 'b 'g 'h))
          (define all (set eq-comparator 'a 'b 'c 'd 'e 'f 'g 'h))
          (define none (set eq-comparator))
          (define ab (set eq-comparator 'a 'b))
          (define cd (set eq-comparator 'c 'd))
          (define ef (set eq-comparator 'e 'f))
          (define gh (set eq-comparator 'g 'h))
          (define cdgh (set eq-comparator 'c 'd 'g 'h))
          (define abcdgh (set eq-comparator 'a 'b 'c 'd 'g 'h))
          (define abefgh (set eq-comparator 'a 'b 'e 'f 'g 'h))
          (test-assert (set-disjoint? abcd efgh))
          (test-assert (not (set-disjoint? abcd ab)))
          (parameterize ((current-test-comparator set=?))
            (test abcd (set-union abcd))
            (test all (set-union abcd efgh))
            (test abcdgh (set-union abcd abgh))
            (test abefgh (set-union efgh abgh))
            (let ((efgh2 (set-copy efgh)))
              (set-union! efgh2)
              (test efgh efgh2)
              (set-union! efgh2 abgh)
              (test abefgh efgh2))
            (test abcd (set-intersection abcd))
            (test none (set-intersection abcd efgh))
            ;; (let ((abcd2 (set-copy abcd)))
            ;;   (set-intersection! abcd2)
            ;;   (test abcd abcd2)
            ;;   (set-intersection! abcd2 efgh)
            ;;   (test none abcd2))
            (test ab (set-intersection abcd abgh))
            (test ab (set-intersection abgh abcd))
            (test abcd (set-difference abcd))
            (test cd (set-difference abcd ab))
            (test abcd (set-difference abcd gh))
            (test none (set-difference abcd abcd))
            ;; (let ((abcd3 (set-copy abcd)))
            ;;   (set-difference! abcd3)
            ;;   (test abcd abcd3)
            ;;   (set-difference! abcd3 abcd)
            ;;   (test none abcd3))
            (test cdgh (set-xor abcd abgh))
            (test all (set-xor abcd efgh))
            (test none (set-xor abcd other-abcd))
            ;; don't test xor! effect
            (test none (set-xor! (set-copy abcd) other-abcd))
            (test "abcd smashed?" other-abcd abcd)
            (test "efgh smashed?" other-efgh efgh)
            (test "abgh smashed?" other-abgh abgh))
          )

        (test-group "sets/mismatch"
          (define nums (set number-comparator 1 2 3))
          (define syms (set eq-comparator 'a 'b 'c))
          (test-error (set=? nums syms))
          (test-error (set<? nums syms))
          (test-error (set<=? nums syms))
          (test-error (set>? nums syms))
          (test-error (set>=? nums syms))
          (test-error (set-union nums syms))
          (test-error (set-intersection nums syms))
          (test-error (set-difference nums syms))
          (test-error (set-xor nums syms))
          (test-error (set-union! nums syms))
          (test-error (set-intersection! nums syms))
          (test-error (set-difference! nums syms))
          (test-error (set-xor! nums syms))
          )

        (test-group "sets/whole"
          (define whole (set eqv-comparator 1 2 3 4 5 6 7 8 9 10))
          (define whole2 (set-copy whole))
          (define whole3 (set-copy whole))
          (define whole4 (set-copy whole))
          (define bottom (set eqv-comparator 1 2 3 4 5))
          (define top (set eqv-comparator 6 7 8 9 10))
          (define-values (topx bottomx)
            (set-partition big whole))
          ;; (set-partition! big whole4)
          (parameterize ((current-test-comparator set=?))
            (test top (set-filter big whole))
            (test bottom (set-remove big whole))
            ;; (set-filter! big whole2)
            ;; (test-assert (not (set-contains? whole2 1)))
            ;; (set-remove! big whole3)
            ;; (test-assert (not (set-contains? whole3 10)))
            ;; (test top topx)
            ;; (test bottom bottomx)
            ;; (test top whole4)
            )
          (test 5 (set-count big whole))
          (let ((hetero (set eqv-comparator 1 2 'a 3 4))
                (homo (set eqv-comparator 1 2 3 4 5)))
            (test 'a (set-find symbol? hetero (lambda () (error "wrong"))))
            (test-error  (set-find symbol? homo (lambda () (error "wrong"))))
            (test-assert (set-any? symbol? hetero))
            (test-assert (set-any? number? hetero))
            (test-assert (not (set-every? symbol? hetero)))
            (test-assert (not (set-every? number? hetero)))
            (test-assert (not (set-any? symbol? homo)))
            (test-assert (set-every? number? homo)))
          )

        (test-group "sets/lowlevel"
          (define bucket (set string-ci-comparator "abc" "def"))
          (define nums (set number-comparator 1 2 3))
          ;; nums is now {1, 2, 3}
          (define nums2 (set-replace nums 2.0))
          ;; nums2 is now {1, 2.0, 3}
          (test string-ci-comparator (set-element-comparator bucket))
          (test-assert (set-contains? bucket "abc"))
          (test-assert (set-contains? bucket "ABC"))
          (test "def" (set-member bucket "DEF" "fqz"))
          (test "fqz" (set-member bucket "lmn" "fqz"))
          (test-assert (set-any? inexact? nums2))
          (set! nums (set-replace! nums 2.0))
          ;; nums is now {1, 2.0, 3}
          (test-assert (set-any? inexact? nums))
          (let ((sos
                 (set set-comparator
                      (set equal-comparator '(2 . 1) '(1 . 1) '(0 . 2) '(0 . 0))
                      (set equal-comparator '(2 . 1) '(1 . 1) '(0 . 0) '(0 . 2)))))
            (test 1 (set-size sos)))
          )

        (test-group "bags/simple"
          (define nums (bag number-comparator))
          ;; nums is now {}
          (define syms (bag eq-comparator 'a 'b 'c 'd))
          ;; syms is now {a, b, c, d}
          (define nums2 (bag-copy nums))
          ;; nums2 is now {}
          (define syms2 (bag-copy syms))
          ;; syms2 is now {a, b, c, d}
          (define esyms (bag eq-comparator))
          ;; esyms is now {}
          (test-assert (bag-empty? esyms))
          (test-assert (bag? nums))
          (test-assert (bag? syms))
          (test-assert (bag? nums2))
          (test-assert (bag? syms2))
          (test-assert (not (bag? 'a)))
          (bag-adjoin! nums 2)
          (bag-adjoin! nums 3)
          (bag-adjoin! nums 4)
          ;; nums is now {2, 3, 4}
          (test 4 (bag-size (bag-adjoin nums 5)))
          (test 3 (bag-size nums))
          (test 3 (bag-size (bag-delete syms 'd)))
          (test 2 (bag-size (bag-delete-all syms '(c d))))
          (test 4 (bag-size syms))
          (bag-adjoin! syms 'e 'f)
          ;; syms is now {a, b, c, d, e, f}
          (test 4 (bag-size (bag-delete-all! syms '(e f))))
          ;; syms is now {a, b, c, d}
          (test 3 (bag-size nums))
          (bag-delete! nums 1)
          (test 3 (bag-size nums))
          (set! nums2 (bag-map number-comparator (lambda (x) (* 10 x)) nums))
          ;; nums2 is now {20, 30, 40}
          (test-assert (bag-contains? nums2 30))
          (test-assert (not (bag-contains? nums2 3)))
          (let ((total 0))
            (bag-for-each (lambda (x) (set! total (+ total x))) nums2)
            (test 90 total))
          (test 12 (bag-fold + 3 nums))
          (set! nums (bag eqv-comparator 10 20 30 40 50))
          ;; nums is now {10, 20, 30, 40, 50}
          (test-assert
              (bag=? nums (bag-unfold
                           eqv-comparator
                           (lambda (i) (= i 0))
                           (lambda (i) (* i 10))
                           (lambda (i) (- i 1))
                           5)))
          (test '(a) (bag->list (bag eq-comparator 'a)))
          (set! syms2 (list->bag eq-comparator '(e f)))
          ;; syms2 is now {e, f}
          (test 2 (bag-size syms2))
          (test-assert (bag-contains? syms2 'e))
          (test-assert (bag-contains? syms2 'f))
          (list->bag! syms2 '(e f))
          ;; syms2 is now {e, e, f, f}
          (test 4 (bag-size syms2))
          )

        (test-group "bags/search"
          (define yam (bag char-comparator #\y #\a #\m))
          (define (failure/insert insert ignore)
            (insert 1))
          (define (failure/ignore insert ignore)
            (ignore 2))
          (define (success/update element update remove)
            (update #\b 3))
          (define (success/remove element update remove)
            (remove 4))
          (define yam! (bag char-comparator #\y #\a #\m #\!))
          (define bam (bag char-comparator #\b #\a #\m))
          (define ym (bag char-comparator #\y #\m))
          (define-values (bag1 obj1)
            (bag-search! (bag-copy yam) #\! failure/insert error))
          (define-values (bag2 obj2)
            (bag-search! (bag-copy yam) #\! failure/ignore error))
          (define-values (bag3 obj3)
            (bag-search! (bag-copy yam) #\y error success/update))
          (define-values (bag4 obj4)
            (bag-search! (bag-copy yam) #\a error success/remove))
          (test-assert (bag=? yam! bag1))
          (test 1 obj1)
          (test-assert (bag=? yam bag2))
          (test 2 obj2)
          (test-assert (bag=? bam bag3))
          (test 3 obj3)
          (test-assert (bag=? ym bag4))
          (test 4 obj4)
          )

        (test-group "bags/elemcount"
          (define mybag (bag eqv-comparator 1 1 1 1 1 2 2))
          (test 5 (bag-element-count mybag 1))
          (test 0 (bag-element-count mybag 3)))

        (test-group "bags/subbags"
          (define bag2 (bag number-comparator 1 2))
          (define other-bag2 (bag number-comparator 1 2))
          (define bag3 (bag number-comparator 1 2 3))
          (define bag4 (bag number-comparator 1 2 3 4))
          (define bagx (bag number-comparator 10 20 30 40))
          (test-assert (bag=? bag2 other-bag2))
          (test-assert (not (bag=? bag2 bag3)))
          (test-assert (not (bag=? bag2 bag3 other-bag2)))
          (test-assert (bag<? bag2 bag3 bag4))
          (test-assert (not (bag<? bag2 other-bag2)))
          (test-assert (bag<=? bag2 other-bag2 bag3))
          (test-assert (not (bag<=? bag2 bag3 other-bag2)))
          (test-assert (bag>? bag4 bag3 bag2))
          (test-assert (not (bag>? bag2 other-bag2)))
          (test-assert (bag>=? bag3 other-bag2 bag2))
          (test-assert (not (bag>=? other-bag2 bag3 bag2))))

        (test-group "bags/multi"
          (define one (bag eqv-comparator 10))
          (define two (bag eqv-comparator 10 10))
          (test-assert (not (bag=? one two)))
          (test-assert (bag<? one two))
          (test-assert (not (bag>? one two)))
          (test-assert (bag<=? one two))
          (test-assert (not (bag>? one two)))
          (test-assert (bag=? two two))
          (test-assert (not (bag<? two two)))
          (test-assert (not (bag>? two two)))
          (test-assert (bag<=? two two))
          (test-assert (bag>=? two two))
          (test '((10 . 2))
              (let ((result '()))
                (bag-for-each-unique
                 (lambda (x y) (set! result (cons (cons x y) result)))
                 two)
                result))
          (test 25 (bag-fold + 5 two))
          (test 12 (bag-fold-unique (lambda (k n r) (+ k n r)) 0 two)))

        (test-group "bags/ops"
          ;; Potentially mutable
          (define abcd (bag eq-comparator 'a 'b 'c 'd))
          (define efgh (bag eq-comparator 'e 'f 'g 'h))
          (define abgh (bag eq-comparator 'a 'b 'g 'h))
          ;; Never get a chance to be mutated
          (define other-abcd (bag eq-comparator 'a 'b 'c 'd))
          (define other-efgh (bag eq-comparator 'e 'f 'g 'h))
          (define other-abgh (bag eq-comparator 'a 'b 'g 'h))
          (define all (bag eq-comparator 'a 'b 'c 'd 'e 'f 'g 'h))
          (define none (bag eq-comparator))
          (define ab (bag eq-comparator 'a 'b))
          (define cd (bag eq-comparator 'c 'd))
          (define ef (bag eq-comparator 'e 'f))
          (define gh (bag eq-comparator 'g 'h))
          (define cdgh (bag eq-comparator 'c 'd 'g 'h))
          (define abcdgh (bag eq-comparator 'a 'b 'c 'd 'g 'h))
          (define abefgh (bag eq-comparator 'a 'b 'e 'f 'g 'h))
          (test-assert (bag-disjoint? abcd efgh))
          (test-assert (not (bag-disjoint? abcd ab)))
          (parameterize ((current-test-comparator bag=?))
            (test abcd (bag-union abcd))
            (test all (bag-union abcd efgh))
            (test abcdgh (bag-union abcd abgh))
            (test abefgh (bag-union efgh abgh))
            (let ((efgh2 (bag-copy efgh)))
              (bag-union! efgh2)
              (test efgh efgh2)
              (bag-union! efgh2 abgh)
              (test abefgh efgh2))
            (test abcd (bag-intersection abcd))
            (test none (bag-intersection abcd efgh))
            (let ((abcd2 (bag-copy abcd)))
              (bag-intersection! abcd2)
              (test abcd abcd2)
              (bag-intersection! abcd2 efgh)
              (test none abcd2))
            (test ab (bag-intersection abcd abgh))
            (test ab (bag-intersection abgh abcd))
            (test abcd (bag-difference abcd))
            (test cd (bag-difference abcd ab))
            (test abcd (bag-difference abcd gh))
            (test none (bag-difference abcd abcd))
            (let ((abcd3 (bag-copy abcd)))
              (bag-difference! abcd3)
              (test abcd abcd3)
              (bag-difference! abcd3 abcd)
              (test none abcd3))
            (test cdgh (bag-xor abcd abgh))
            (test all (bag-xor abcd efgh))
            (test none (bag-xor abcd other-abcd))
            (test none (bag-xor! (bag-copy abcd) other-abcd))
            (let ((abab (bag eq-comparator 'a 'b 'a 'b))
                  (ab2 (bag-copy ab)))
              (test ab (bag-sum ab))
              (test ab (bag-sum! ab2))
              (test abab (bag-sum! ab2 ab))
              (test abab ab2)
              (test abab (bag-product 2 ab))
              (let ((ab3 (bag-copy ab)))
                (bag-product! 2 ab3)
                (test abab ab3)))
            (test "abcd smashed?" other-abcd abcd)
            (test "abcd smashed?" other-abcd abcd)
            (test "efgh smashed?" other-efgh efgh)
            (test "abgh smashed?" other-abgh abgh)))

        (test-group "bags/mismatch"
          (define nums (bag number-comparator 1 2 3))
          (define syms (bag eq-comparator 'a 'b 'c))
          (test-error (bag=? nums syms))
          (test-error (bag<? nums syms))
          (test-error (bag<=? nums syms))
          (test-error (bag>? nums syms))
          (test-error (bag>=? nums syms))
          (test-error (bag-union nums syms))
          (test-error (bag-intersection nums syms))
          (test-error (bag-difference nums syms))
          (test-error (bag-xor nums syms))
          (test-error (bag-union! nums syms))
          (test-error (bag-intersection! nums syms))
          (test-error (bag-difference! nums syms)))

        (test-group "bags/whole"
          (define whole (bag eqv-comparator 1 2 3 4 5 6 7 8 9 10))
          (define whole2 (bag-copy whole))
          (define whole3 (bag-copy whole))
          (define whole4 (bag-copy whole))
          (define bottom (bag eqv-comparator 1 2 3 4 5))
          (define top (bag eqv-comparator 6 7 8 9 10))
          (define-values (topx bottomx)
            (bag-partition big whole))
          (call-with-values (lambda () (bag-partition! big whole4))
            (lambda (pass fail) (set! whole4 pass)))
          (parameterize ((current-test-comparator bag=?))
            (test top (bag-filter big whole))
            (test bottom (bag-remove big whole))
            (set! whole2 (bag-filter! big whole2))
            (test-assert (not (bag-contains? whole2 1)))
            (set! whole3 (bag-remove! big whole3))
            (test-assert (not (bag-contains? whole3 10)))
            (test top topx)
            (test bottom bottomx)
            (test top whole4))
          (test 5 (bag-count big whole))
          (let ((hetero (bag eqv-comparator 1 2 'a 3 4))
                (homo (bag eqv-comparator 1 2 3 4 5)))
            (test 'a (bag-find symbol? hetero (lambda () (error "wrong"))))
            (test-error  (bag-find symbol? homo (lambda () (error "wrong"))))
            (test-assert (bag-any? symbol? hetero))
            (test-assert (bag-any? number? hetero))
            (test-assert (not (bag-every? symbol? hetero)))
            (test-assert (not (bag-every? number? hetero)))
            (test-assert (not (bag-any? symbol? homo)))
            (test-assert (bag-every? number? homo))))

        (test-group "bags/lowlevel"
          (define bucket (bag string-ci-comparator "abc" "def"))
          (define nums (bag number-comparator 1 2 3))
          ;; nums is now {1, 2, 3}
          (define nums2 (bag-replace nums 2.0))
          ;; nums2 is now {1, 2.0, 3}
          (test string-ci-comparator (bag-element-comparator bucket))
          (test-assert (bag-contains? bucket "abc"))
          (test-assert (bag-contains? bucket "ABC"))
          ;;(test "def" (bag-member bucket "DEF" "fqz"))
          (test "fqz" (bag-member bucket "lmn" "fqz"))
          (test-assert (bag-any? inexact? nums2))
          (bag-replace! nums 2.0)
          ;; nums is now {1, 2.0, 3}
          (test-assert (bag-any? inexact? nums))
          (let ((bob
                 (bag bag-comparator
                      (bag eqv-comparator 1 2)
                      (bag eqv-comparator 1 2))))
            (test 2 (bag-size bob))))

        (test-group "bags/semantics"
          (define mybag (bag number-comparator 1 2))
          ;; mybag is {1, 2}
          (test 2 (bag-size mybag))
          (bag-adjoin! mybag 1)
          ;; mybag is {1, 1, 2}
          (test 3 (bag-size mybag))
          (test 2 (bag-unique-size mybag))
          (bag-delete! mybag 2)
          ;; mybag is {1, 1}
          (bag-delete! mybag 2)
          (test 2 (bag-size mybag))
          (bag-increment! mybag 1 3)
          ;; mybag is {1, 1, 1, 1, 1}
          (test 5 (bag-size mybag))
          (test-assert (bag-decrement! mybag 1 2))
          ;; mybag is {1, 1, 1}
          (test 3 (bag-size mybag))
          (bag-decrement! mybag 1 5)
          ;; mybag is {}
          (test 0 (bag-size mybag)))

        (test-group "bags/convert"
          (define multi (bag eqv-comparator 1 2 2 3 3 3))
          (define single (bag eqv-comparator 1 2 3))
          (define singleset (set eqv-comparator 1 2 3))
          (define minibag (bag eqv-comparator 'a 'a))
          (define alist '((a . 2)))
          (test alist (bag->alist minibag))
          (test-assert (bag=? minibag (alist->bag eqv-comparator alist)))
          (test-assert (set=? singleset (bag->set single)))
          (test-assert (set=? singleset (bag->set multi)))
          (test-assert (bag=? single (set->bag singleset)))
          (test-assert (not (bag=? multi (set->bag singleset))))
          (set->bag! minibag singleset)
          ;; minibag is now {a, a, a, a, 1, 2, 3}
          (test-assert (bag-contains? minibag 1)))

        (test-group "bags/sumprod"
          (define abb (bag eq-comparator 'a 'b 'b))
          (define aab (bag eq-comparator 'a 'a 'b))
          (define total (bag-sum abb aab))
          (test 3 (bag-count (lambda (x) (eqv? x 'a)) total))
          (test 3 (bag-count (lambda (x) (eqv? x 'b)) total))
          (test 12 (bag-size (bag-product 2 total)))
          (let ((bag1 (bag eqv-comparator 1)))
            (bag-sum! bag1 bag1)
            (test 2 (bag-size bag1))
            (bag-product! 2 bag1)
            (test 4 (bag-size bag1)))
          )

        (test-group "comparators"
          (define a (set number-comparator 1 2 3))
          (define b (set number-comparator 1 2 4))
          (define aa (bag number-comparator 1 2 3))
          (define bb (bag number-comparator 1 2 4))
          (test-assert (not (=? set-comparator a b)))
          (test-assert (=? set-comparator a (set-copy a)))
          ;;(test-error (<? set-comparator a b))
          (test-assert (not (=? bag-comparator aa bb)))
          (test-assert (=? bag-comparator aa (bag-copy aa)))
          ;;(test-error (<? bag-comparator aa bb))
          (test-assert (not (=? (make-default-comparator) a aa)))
          ))
      )))

(define-library (srfi 151)
  (export bitwise-not
          bitwise-and   bitwise-ior 
          bitwise-xor   bitwise-eqv
          bitwise-nand  bitwise-nor 
          bitwise-andc1 bitwise-andc2
          bitwise-orc1  bitwise-orc2 
          arithmetic-shift bit-count integer-length
          bitwise-if
          bit-set? any-bit-set? every-bit-set?
          first-set-bit
          bit-field bit-field-any? bit-field-every?
          bit-field-clear bit-field-set
          bit-field-replace bit-field-replace-same
          bit-field-rotate bit-field-reverse
          copy-bit bits->list list->bits
          bits->vector vector->bits
          bits bit-swap
          bitwise-fold bitwise-for-each bitwise-unfold
          make-bitwise-generator)
  (import (chibi))
  (include-shared "151/bit")
  (include "151/bitwise.scm"))
;;; Copyright (C) William D Clinger (2016).
;;; 
;;; Permission is hereby granted, free of charge, to any person
;;; obtaining a copy of this software and associated documentation
;;; files (the "Software"), to deal in the Software without
;;; restriction, including without limitation the rights to use,
;;; copy, modify, merge, publish, distribute, sublicense, and/or
;;; sell copies of the Software, and to permit persons to whom the
;;; Software is furnished to do so, subject to the following
;;; conditions:
;;; 
;;; The above copyright notice and this permission notice shall be
;;; included in all copies or substantial portions of the Software.
;;; 
;;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
;;; EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
;;; OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
;;; NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
;;; HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
;;; WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
;;; FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
;;; OTHER DEALINGS IN THE SOFTWARE. 

(define-library (srfi 135)

  (export

   ;; Predicates

   text?                 textual?
   textual-null? 
   textual-every         textual-any

   ;; Constructors

   make-text             text
   text-tabulate
   text-unfold           text-unfold-right

   ;; Conversion

   textual->text
   textual->string       textual->vector      textual->list
   string->text          vector->text         list->text    reverse-list->text
   textual->utf8         textual->utf16be
   textual->utf16        textual->utf16le
   utf8->text            utf16be->text
   utf16->text           utf16le->text

   ;; Selection

   text-length           textual-length
   text-ref              textual-ref
   subtext               subtextual
   textual-copy
   textual-take          textual-take-right
   textual-drop          textual-drop-right
   textual-pad           textual-pad-right 
   textual-trim          textual-trim-right   textual-trim-both

   ;; Replacement

   textual-replace

   ;; Comparison

   textual=?             textual-ci=?
   textual<?             textual-ci<?
   textual>?             textual-ci>?
   textual<=?            textual-ci<=?
   textual>=?            textual-ci>=?

   ;; Prefixes & suffixes

   textual-prefix-length textual-suffix-length
   textual-prefix?       textual-suffix?    

   ;; Searching

   textual-index         textual-index-right
   textual-skip          textual-skip-right
   textual-contains      textual-contains-right

   ;; Case conversion

   textual-upcase        textual-downcase
   textual-foldcase      textual-titlecase

   ;; Concatenation

   textual-append        textual-concatenate  textual-concatenate-reverse
   textual-join

   ;; Fold & map & friends

   textual-fold          textual-fold-right
   textual-map           textual-for-each
   textual-map-index     textual-for-each-index
   textual-count
   textual-filter        textual-remove
;  textual-reverse

   ;; Replication & splitting

   textual-replicate     textual-split
   )

  (import (scheme base)
          (scheme case-lambda)
          (scheme char)
          (srfi 135 kernel8))

  (cond-expand
   ((library (rnrs unicode))
    (import (only (rnrs unicode) string-titlecase)))
   ((library (srfi 129))
    (import (only (srfi 129) string-titlecase)))
   (else
    (begin
     (define (string-titlecase s)
       (%string-titlecase s)))))

  ;; textual-replicate needs a sensible mod procedure

  (cond-expand
   ((library (rnrs base))
    (import (only (rnrs base) div mod)))
   (else
    (begin

      (define (assertion-violation procname msg . irritants)
        (apply error msg irritants))

      ;; Restricted to exact integers, which is all we need here.

      (define (div-and-mod x y)
        (cond ((and (exact-integer? x) (exact-integer? y))
               (cond ((= y 0)
                      (error "mod: zero divisor" x y))
                     ((>= x 0)
                      (values (quotient x y) (remainder x y)))
                     ((< y 0)
                                        ; x < 0, y < 0
                      (let* ((q (quotient x y))
                             (r (- x (* q y))))
                        (if (= r 0)
                            (values q 0)
                            (values (+ q 1) (- r y)))))
                     (else
                                        ; x < 0, y > 0
                      (let* ((q (quotient x y))
                             (r (- x (* q y))))
                        (if (= r 0)
                            (values q 0)
                            (values (- q 1) (+ r y)))))))
              (else
               (error "div or mod: illegal arguments" x y))))

      (define (div x y)
        (cond ((and (exact-integer? x)
                    (exact-integer? y)
                    (>= x 0))
               (quotient x y))
              (else
               (call-with-values
                   (lambda () (div-and-mod x y))
                 (lambda (q r) q)))))

      (define (mod x y)
        (cond ((and (exact-integer? x)
                    (exact-integer? y)
                    (>= x 0))
               (remainder x y))
              (else
               (call-with-values
                   (lambda () (div-and-mod x y))
                 (lambda (q r) r))))))))

  ;; To run texts-search-test.sps, change the (or) to (and).

  (cond-expand ((or)
                (export
                 %textual-contains:naive
                 %textual-contains:rabin-karp
                 %textual-contains:boyer-moore

                 %textual-contains-right:naive
                 %textual-contains-right:boyer-moore
                 ))
               (else))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  ;;; The recommended external syntax cannot be implemented portably.
  ;;; Here is Larceny-specific code that generates the recommended
  ;;; syntax for output, but does not make the changes necessary to
  ;;; accept that recommended syntax for input or as a literal in
  ;;; programs.

  (cond-expand (larceny
                (import (scheme write)
                        (primitives rtd-printer-set!)))
               (else))

  (cond-expand (larceny
                (begin
                 (define (text-write txt p)
                   (let* ((q (open-output-string))
                          (s (begin (write (textual->string txt) q)
                                    (get-output-string q))))
                     (write-char (integer->char #x00ab) p)
                     (write-string (substring s 1 (- (string-length s) 1)) p)
                     (write-char (integer->char #x00bb) p)))

                 (define ignored-result-from-rtd-printer-set!    ; for R6RS
                   (rtd-printer-set! text-rtd text-write))))
               (else))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (include "135.scm"))

;;; eof

(define-library (srfi 11)
  (export let-values let*-values)
  (import (chibi))
  (begin
   (define-syntax let*-values
     (syntax-rules ()
       ((let*-values () . body)
        (let () . body))
       ((let*-values (((a) expr) . rest) . body)
        (let ((a expr)) (let*-values rest . body)))
       ((let*-values ((params expr) . rest) . body)
        (call-with-values (lambda () expr)
          (lambda params (let*-values rest . body))))))
   (define-syntax let-values
     (syntax-rules ()
       ((let-values () . body)
        (let () . body))
       ((let-values ("step") (binds ...) bind expr maps () () . body)
        (let*-values (binds ... (bind expr)) (let maps . body)))
       ((let-values ("step") (binds ...) bind old-expr maps () ((params expr) . rest) . body)
        (let-values ("step") (binds ... (bind old-expr)) () expr maps params rest . body))
       ((let-values ("step") binds (bind ...) expr (maps ...) (x . y) rest . body)
        (let-values ("step") binds (bind ... tmp) expr (maps ... (x tmp)) y rest . body))
       ((let-values ("step") binds (bind ...) expr (maps ...) x rest . body)
        (let-values ("step") binds (bind ... . tmp) expr (maps ... (x tmp)) () rest . body))
       ((let-values ((params expr) . rest) . body)
        (let-values ("step") () () expr () params rest . body))))))
(define-library (srfi 124)
  (export make-ephemeron ephemeron? ephemeron-broken?
          ephemeron-key ephemeron-datum reference-barrier)
  (import (rename (chibi weak) (ephemeron-value ephemeron-datum))
          (only (scheme base) define if))
  (begin
    (define (reference-barrier k) (if #f #f))))
;; sort.scm -- SRFI-95 sorting utilities
;; Copyright (c) 2009 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

(define (copy seq)
  (if (vector? seq)
      (let* ((len (vector-length seq))
             (res (make-vector len)))
        (do ((i (- len 1) (- i 1)))
            ((< i 0) res)
          (vector-set! res i (vector-ref seq i))))
      (map (lambda (x) x) seq)))

(define (sort seq . o)
  (let ((less (and (pair? o) (car o)))
        (key (and (pair? o) (pair? (cdr o)) (car (cdr o)))))
    (sort! (copy seq) less key)))

(define (sorted? seq less . o)
  (let ((key (if (pair? o) (car o) (lambda (x) x))))
    (cond
     ((vector? seq)
      (let ((len (- (vector-length seq) 1)))
        (let lp ((i 0))
          (cond
           ((>= i len) #t)
           ((less (key (vector-ref seq (+ i 1)))
                  (key (vector-ref seq i)))
            #f)
           (else (lp (+ i 1)))))))
     ((null? seq)
      #t)
     ((pair? seq)
      (let lp ((ls1 seq) (ls2 (cdr seq)))
        (cond ((null? ls2) #t)
              ((less (key (car ls2)) (key (car ls1))) #f)
              (else (lp ls2 (cdr ls2))))))
     (else
      (error "sorted?: not a list or vector" seq)))))

(define (merge! ls1 ls2 less . o)
  (let ((key (if (pair? o) (car o) (lambda (x) x))))
    (define (lp prev ls1 ls2 a b less key)
      (cond
       ((less a b)
        (if (null? (cdr ls1))
            (set-cdr! ls1 ls2)
            (lp ls1 (cdr ls1) ls2 (key (car (cdr ls1))) b less key)))
       (else
        (set-cdr! prev ls2)
        (if (null? (cdr ls2))
            (set-cdr! ls2 ls1)
            (lp ls2 (cdr ls2) ls1 (key (car (cdr ls2))) a less key)))))
    (cond
     ((null? ls1) ls2)
     ((null? ls2) ls1)
     (else
      (let ((a (key (car ls1)))
            (b (key (car ls2))))
        (cond
         ((less a b)
          (if (null? (cdr ls1))
              (set-cdr! ls1 ls2)
              (lp ls1 (cdr ls1) ls2 (key (car (cdr ls1))) b less key))
          ls1)
         (else
          (if (null? (cdr ls2))
              (set-cdr! ls2 ls1)
              (lp ls2 (cdr ls2) ls1 (key (car (cdr ls2))) a less key))
          ls2)))))))

(define (merge ls1 ls2 less . o)
  (let ((key (if (pair? o) (car o) (lambda (x) x))))
    (merge! (copy ls1) (copy ls2) less key)))
(define-library (srfi 95 test)
  (export run-tests)
  (import (chibi) (srfi 95) (only (chibi test) test-begin test test-end))
  (begin
    (define (run-tests)

      (test-begin "srfi-95: sorting")

      (test "sort null" '() (sort '()))
      (test "sort null <" '() (sort '() <))
      (test "sort null < car" '() (sort '() < car))
      (test "sort equal list" '(0 0 0 0 0 0 0 0 0) (sort '(0 0 0 0 0 0 0 0 0)))
      (test "sort equal list cmp" '(0 0 0 0 0 0 0 0 0)
        (sort '(0 0 0 0 0 0 0 0 0) (lambda (a b) (< a b))))
      (test "sort ordered list" '(1 2 3 4 5 6 7 8 9) (sort '(1 2 3 4 5 6 7 8 9)))
      (test "sort reversed list" '(1 2 3 4 5 6 7 8 9) (sort '(9 8 7 6 5 4 3 2 1)))
      (test "sort random list 1" '(1 2 3 4 5 6 7 8 9) (sort '(7 5 2 8 1 6 4 9 3)))
      (test "sort random list 2" '(1 2 3 4 5 6 7 8) (sort '(5 3 4 1 7 6 8 2)))
      (test "sort random list 3" '(1 2 3 4 5 6 7 8 9) (sort '(5 3 4 1 7 9 6 8 2)))
      (test "sort short equal list" '(0 0 0) (sort '(0 0 0)))
      (test "sort short random list" '(1 2 3) (sort '(2 1 3)))
      (test "sort short random list cmp" '(1 2 3) (sort '(2 1 3) (lambda (a b) (< a b))))
      (test "sort numeric list <" '(1 2 3 4 5 6 7 8 9)
        (sort '(7 5 2 8 1 6 4 9 3) <))
      (test "sort numeric list < car" '((1) (2) (3) (4) (5) (6) (7) (8) (9))
        (sort '((7) (5) (2) (8) (1) (6) (4) (9) (3)) < car))
      (test "sort list (lambda (a b) (< (car a) (car b)))"
          '((1) (2) (3) (4) (5) (6) (7) (8) (9))
        (sort '((7) (5) (2) (8) (1) (6) (4) (9) (3))
              (lambda (a b) (< (car a) (car b)))))
      (test "sort 1-char symbols" '(a b c d e f g h i j k)
        (sort '(h b k d a c j i e g f)))
      (test "sort short symbols" '(a aa b c d e ee f g h i j k)
        (sort '(h b aa k d a ee c j i e g f)))
      (test "sort long symbol"
          '(a aa b bzzzzzzzzzzzzzzzzzzzzzzz c d e ee f g h i j k)
        (sort '(h b aa k d a ee c j i bzzzzzzzzzzzzzzzzzzzzzzz e g f)))
      (test "sort long symbols"
          '(a aa b bzzzzzzzzzzzzzzzzzzzzzzz czzzzzzzzzzzzz dzzzzzzzz e ee f g h i j k)
        (sort '(h b aa k dzzzzzzzz a ee czzzzzzzzzzzzz j i bzzzzzzzzzzzzzzzzzzzzzzz e g f)))
      (test "sort strings"
          '("ape" "bear" "cat" "dog" "elephant" "fox" "goat" "hawk")
        (sort '("elephant" "cat" "dog" "ape" "goat" "fox" "hawk" "bear")))
      (test "sort strings string-ci<?"
          '("ape" "Bear" "CaT" "DOG" "elephant" "Fox" "GoAt" "HAWK")
        (sort '("elephant" "CaT" "DOG" "ape" "GoAt" "Fox" "HAWK" "Bear")
              string-ci<?))

      (test "sort lists"
          '((chibi) (scheme r5rs) (scheme write))
        (sort '((chibi) (scheme r5rs) (scheme write))
              (lambda (a b)
                (string<? (call-with-output-string (lambda (out) (write a out)))
                          (call-with-output-string (lambda (out) (write b out)))))))

      (test "sort numeric inexact vector <" '#(1.1 2.2 3.3 4.4 5.5 6.6 7.7 8.8 9.9)
        (sort '#(7.7 5.5 2.2 8.8 1.1 6.6 4.4 9.9 3.3) <))
      (test "sort numeric signed inexact vector <"
          '#(-9.9 -7.7 -5.5 -3.3 -1.1 2.2 4.4 6.6 8.8)
        (sort '#(-7.7 -5.5 2.2 8.8 -1.1 6.6 4.4 -9.9 -3.3) <))
      (test "sort numeric same whole number inexact vector"
          '#(-5.2155
             -4.3817
             -4.3055
             -4.0415
             -3.5883
             -3.5714
             -3.4059
             -2.7829
             -2.6406
             -2.4985
             -2.4607
             -1.2487
             -0.537800000000001
             -0.481999999999999
             -0.469100000000001
             -0.0932999999999993
             0.0066999999999986)
        (sort '#(-5.2155
                 -3.5714
                 -4.3817
                 -3.5883
                 -4.3055
                 -2.4985
                 -4.0415
                 -3.4059
                 -0.0932999999999993
                 -0.537800000000001
                 -2.6406
                 -0.481999999999999
                 -2.7829
                 -2.4607
                 -1.2487
                 -0.469100000000001
                 0.0066999999999986)
              <))

      (test "sort watson no dups"
          '#(-0.3096 -0.307000000000002 -0.303800000000003 -0.301600000000001
                     -0.300599999999999 -0.3003 -0.3002 -0.2942)
        (sort '#(-0.3096 -0.307000000000002 -0.303800000000003 -0.301600000000001
                         -0.300599999999999 -0.2942 -0.3003 -0.3002)))

      (test "sort watson"
          '#(-0.3096 -0.307000000000002 -0.303800000000003 -0.301600000000001
                     -0.300599999999999 -0.3003 -0.3003 -0.3002 -0.2942)
        (sort '#(-0.3096 -0.307000000000002 -0.303800000000003 -0.301600000000001
                         -0.300599999999999 -0.2942 -0.3003 -0.3003 -0.3002)))

      (test "sort ratios" '(1/5 1/4 1/3 2/5 1/2 3/5 2/3 3/4 4/5)
        (sort '(1/2 1/3 1/4 1/5 2/3 3/4 2/5 3/5 4/5)))

      (test "sort complex" '(1+1i 1+2i 1+3i 2+2i 3+3i 4+4i 5+5i 6+6i 7+7i 8+8i 9+9i)
        (sort '(7+7i 1+2i 5+5i 2+2i 8+8i 1+1i 6+6i 4+4i 9+9i 1+3i 3+3i)))

      (test "sort mixed exactness" '(1 1.5 2 3)
        (sort '(1 2 3 1.5) <))

      (test "sort integer and rational" '(1 2 5/2 3)
        (sort '(1 2 3 5/2) <))

      (test "sort various mixed" '(3 3.14 355/113 22/7 4)
        (sort '(355/113 4 22/7 3 3.14)))

      ;; (test "sort complex" '(3 3.14 355/113 22/7 3.14+0.0i 3.14+3.14i)
      ;;   (sort '(3.14+3.14i 355/113 3 22/7 3.14+0.0i 3.14)))

      (test "sort stable" '((0 2) (0 3) (0 4) (1 1) (1 2) (1 3) (2 1) (2 2))
        (sort '((1 1) (0 2) (1 2) (2 1) (0 3) (2 2) (0 4) (1 3)) < car))

      (test "sort stable complex" '(2i 3i 4i 1+i 1+2i 2+i 2+2i)
        (sort '(1+i 2i 1+2i 2+i 3i 2+2i 4i) < real-part))

      (test-end))))

(define-library (srfi 160 s64)
  (export
   make-s64vector
   s64?
   s64vector?
   s64vector-ref
   s64vector-set!
   s64vector-length
   (rename uvector-unfold s64vector-unfold)
   (rename uvector-unfold-right s64vector-unfold-right)
   (rename vector-copy s64vector-copy)
   (rename vector-reverse-copy s64vector-reverse-copy)
   (rename vector-append s64vector-append)
   (rename vector-concatenate s64vector-concatenate)
   (rename vector-append-subvectors s64vector-append-subvectors)
   (rename vector-empty? s64vector-empty?)
   (rename vector= s64vector=)
   (rename vector-take s64vector-take)
   (rename vector-take-right s64vector-take-right)
   (rename vector-drop s64vector-drop)
   (rename vector-drop-right s64vector-drop-right)
   (rename vector-segment s64vector-segment)
   (rename vector-fold s64vector-fold)
   (rename vector-fold-right s64vector-fold-right)
   (rename vector-map s64vector-map)
   (rename vector-map! s64vector-map!)
   (rename vector-for-each s64vector-for-each)
   (rename vector-count s64vector-count)
   (rename vector-cumulate s64vector-cumulate)
   (rename vector-take-while s64vector-take-while)
   (rename vector-take-while-right s64vector-take-while-right)
   (rename vector-drop-while s64vector-drop-while)
   (rename vector-drop-while-right s64vector-drop-while-right)
   (rename vector-index s64vector-index)
   (rename vector-index-right s64vector-index-right)
   (rename vector-skip s64vector-skip)
   (rename vector-skip-right s64vector-skip-right)
   (rename vector-binary-search s64vector-binary-search)
   (rename vector-any s64vector-any)
   (rename vector-every s64vector-every)
   (rename vector-partition s64vector-partition)
   (rename vector-filter s64vector-filter)
   (rename vector-remove s64vector-remove)
   (rename vector-swap! s64vector-swap!)
   (rename vector-fill! s64vector-fill!)
   (rename vector-reverse! s64vector-reverse!)
   (rename vector-copy! s64vector-copy!)
   (rename vector-reverse-copy! s64vector-reverse-copy!)
   (rename reverse-vector->list reverse-s64vector->list)
   (rename reverse-list->vector reverse-list->s64vector)
   (rename uvector->vector s64vector->vector)
   (rename vector->uvector vector->s64vector)
   (rename make-vector-generator make-s64vector-generator)
   (rename write-vector write-s64vector))
  (import (except (scheme base)
                  vector-append vector-copy vector-copy!
                  vector-map vector-for-each)
          (scheme write)
          (srfi 160 base))
  (begin
    (define uvector? s64vector?)
    (define make-uvector make-s64vector)
    (define vector s64vector)
    (define uvector->list s64vector->list)
    (define list->uvector list->s64vector)
    (define uvector->list s64vector->list)
    (define uvector-length s64vector-length)
    (define uvector-ref s64vector-ref)
    (define uvector-set! s64vector-set!))
  (include "uvector.scm"))

(define-library (srfi 160 u8)
  (export
   make-u8vector
   u8?
   u8vector?
   u8vector-ref
   u8vector-set!
   u8vector-length
   (rename uvector-unfold u8vector-unfold)
   (rename uvector-unfold-right u8vector-unfold-right)
   (rename vector-copy u8vector-copy)
   (rename vector-reverse-copy u8vector-reverse-copy)
   (rename vector-append u8vector-append)
   (rename vector-concatenate u8vector-concatenate)
   (rename vector-append-subvectors u8vector-append-subvectors)
   (rename vector-empty? u8vector-empty?)
   (rename vector= u8vector=)
   (rename vector-take u8vector-take)
   (rename vector-take-right u8vector-take-right)
   (rename vector-drop u8vector-drop)
   (rename vector-drop-right u8vector-drop-right)
   (rename vector-segment u8vector-segment)
   (rename vector-fold u8vector-fold)
   (rename vector-fold-right u8vector-fold-right)
   (rename vector-map u8vector-map)
   (rename vector-map! u8vector-map!)
   (rename vector-for-each u8vector-for-each)
   (rename vector-count u8vector-count)
   (rename vector-cumulate u8vector-cumulate)
   (rename vector-take-while u8vector-take-while)
   (rename vector-take-while-right u8vector-take-while-right)
   (rename vector-drop-while u8vector-drop-while)
   (rename vector-drop-while-right u8vector-drop-while-right)
   (rename vector-index u8vector-index)
   (rename vector-index-right u8vector-index-right)
   (rename vector-skip u8vector-skip)
   (rename vector-skip-right u8vector-skip-right)
   (rename vector-binary-search u8vector-binary-search)
   (rename vector-any u8vector-any)
   (rename vector-every u8vector-every)
   (rename vector-partition u8vector-partition)
   (rename vector-filter u8vector-filter)
   (rename vector-remove u8vector-remove)
   (rename vector-swap! u8vector-swap!)
   (rename vector-fill! u8vector-fill!)
   (rename vector-reverse! u8vector-reverse!)
   (rename vector-copy! u8vector-copy!)
   (rename vector-reverse-copy! u8vector-reverse-copy!)
   (rename reverse-vector->list reverse-u8vector->list)
   (rename reverse-list->vector reverse-list->u8vector)
   (rename uvector->vector u8vector->vector)
   (rename vector->uvector vector->u8vector)
   (rename make-vector-generator make-u8vector-generator)
   (rename write-vector write-u8vector))
  (import (except (scheme base)
                  vector-append vector-copy vector-copy!
                  vector-map vector-for-each)
          (scheme write)
          (srfi 160 base))
  (begin
    (define uvector? u8vector?)
    (define make-uvector make-u8vector)
    (define vector u8vector)
    (define uvector->list u8vector->list)
    (define list->uvector list->u8vector)
    (define uvector-length u8vector-length)
    (define uvector-ref u8vector-ref)
    (define uvector-set! u8vector-set!))
  (include "uvector.scm"))

(define-library (srfi 160 c64)
  (export
   make-c64vector
   c64?
   c64vector?
   c64vector-ref
   c64vector-set!
   c64vector-length
   (rename uvector-unfold c64vector-unfold)
   (rename uvector-unfold-right c64vector-unfold-right)
   (rename vector-copy c64vector-copy)
   (rename vector-reverse-copy c64vector-reverse-copy)
   (rename vector-append c64vector-append)
   (rename vector-concatenate c64vector-concatenate)
   (rename vector-append-subvectors c64vector-append-subvectors)
   (rename vector-empty? c64vector-empty?)
   (rename vector= c64vector=)
   (rename vector-take c64vector-take)
   (rename vector-take-right c64vector-take-right)
   (rename vector-drop c64vector-drop)
   (rename vector-drop-right c64vector-drop-right)
   (rename vector-segment c64vector-segment)
   (rename vector-fold c64vector-fold)
   (rename vector-fold-right c64vector-fold-right)
   (rename vector-map c64vector-map)
   (rename vector-map! c64vector-map!)
   (rename vector-for-each c64vector-for-each)
   (rename vector-count c64vector-count)
   (rename vector-cumulate c64vector-cumulate)
   (rename vector-take-while c64vector-take-while)
   (rename vector-take-while-right c64vector-take-while-right)
   (rename vector-drop-while c64vector-drop-while)
   (rename vector-drop-while-right c64vector-drop-while-right)
   (rename vector-index c64vector-index)
   (rename vector-index-right c64vector-index-right)
   (rename vector-skip c64vector-skip)
   (rename vector-skip-right c64vector-skip-right)
   (rename vector-binary-search c64vector-binary-search)
   (rename vector-any c64vector-any)
   (rename vector-every c64vector-every)
   (rename vector-partition c64vector-partition)
   (rename vector-filter c64vector-filter)
   (rename vector-remove c64vector-remove)
   (rename vector-swap! c64vector-swap!)
   (rename vector-fill! c64vector-fill!)
   (rename vector-reverse! c64vector-reverse!)
   (rename vector-copy! c64vector-copy!)
   (rename vector-reverse-copy! c64vector-reverse-copy!)
   (rename reverse-vector->list reverse-c64vector->list)
   (rename reverse-list->vector reverse-list->c64vector)
   (rename uvector->vector c64vector->vector)
   (rename vector->uvector vector->c64vector)
   (rename make-vector-generator make-c64vector-generator)
   (rename write-vector write-c64vector))
  (import (except (scheme base)
                  vector-append vector-copy vector-copy!
                  vector-map vector-for-each)
          (scheme write)
          (srfi 160 base))
  (begin
    (define uvector? c64vector?)
    (define make-uvector make-c64vector)
    (define vector c64vector)
    (define uvector->list c64vector->list)
    (define list->uvector list->c64vector)
    (define uvector-length c64vector-length)
    (define uvector-ref c64vector-ref)
    (define uvector-set! c64vector-set!))
  (include "uvector.scm"))

(define-library (srfi 160 s8)
  (export
   make-s8vector
   s8?
   s8vector?
   s8vector-ref
   s8vector-set!
   s8vector-length
   (rename uvector-unfold s8vector-unfold)
   (rename uvector-unfold-right s8vector-unfold-right)
   (rename vector-copy s8vector-copy)
   (rename vector-reverse-copy s8vector-reverse-copy)
   (rename vector-append s8vector-append)
   (rename vector-concatenate s8vector-concatenate)
   (rename vector-append-subvectors s8vector-append-subvectors)
   (rename vector-empty? s8vector-empty?)
   (rename vector= s8vector=)
   (rename vector-take s8vector-take)
   (rename vector-take-right s8vector-take-right)
   (rename vector-drop s8vector-drop)
   (rename vector-drop-right s8vector-drop-right)
   (rename vector-segment s8vector-segment)
   (rename vector-fold s8vector-fold)
   (rename vector-fold-right s8vector-fold-right)
   (rename vector-map s8vector-map)
   (rename vector-map! s8vector-map!)
   (rename vector-for-each s8vector-for-each)
   (rename vector-count s8vector-count)
   (rename vector-cumulate s8vector-cumulate)
   (rename vector-take-while s8vector-take-while)
   (rename vector-take-while-right s8vector-take-while-right)
   (rename vector-drop-while s8vector-drop-while)
   (rename vector-drop-while-right s8vector-drop-while-right)
   (rename vector-index s8vector-index)
   (rename vector-index-right s8vector-index-right)
   (rename vector-skip s8vector-skip)
   (rename vector-skip-right s8vector-skip-right)
   (rename vector-binary-search s8vector-binary-search)
   (rename vector-any s8vector-any)
   (rename vector-every s8vector-every)
   (rename vector-partition s8vector-partition)
   (rename vector-filter s8vector-filter)
   (rename vector-remove s8vector-remove)
   (rename vector-swap! s8vector-swap!)
   (rename vector-fill! s8vector-fill!)
   (rename vector-reverse! s8vector-reverse!)
   (rename vector-copy! s8vector-copy!)
   (rename vector-reverse-copy! s8vector-reverse-copy!)
   (rename reverse-vector->list reverse-s8vector->list)
   (rename reverse-list->vector reverse-list->s8vector)
   (rename uvector->vector s8vector->vector)
   (rename vector->uvector vector->s8vector)
   (rename make-vector-generator make-s8vector-generator)
   (rename write-vector write-s8vector))
  (import (except (scheme base)
                  vector-append vector-copy vector-copy!
                  vector-map vector-for-each)
          (scheme write)
          (srfi 160 base))
  (begin
    (define uvector? s8vector?)
    (define make-uvector make-s8vector)
    (define vector s8vector)
    (define uvector->list s8vector->list)
    (define list->uvector list->s8vector)
    (define uvector-length s8vector-length)
    (define uvector-ref s8vector-ref)
    (define uvector-set! s8vector-set!))
  (include "uvector.scm"))

(define (vector-empty? vec)
  (zero? (uvector-length vec)))

(define (vector= . vecs)
  (let lp1 ((ls vecs))
    (or (null? ls)
        (null? (cdr ls))
        (let* ((v1 (car ls))
               (v2 (cadr ls))
               (len (uvector-length v1)))
          (and (= len (uvector-length v2))
               (let lp2 ((i 0))
                 (or (>= i len)
                     (and (= (uvector-ref v1 i)
                             (uvector-ref v2 i))
                          (lp2 (+ i 1)))))
               (lp1 (cdr ls)))))))

(define (reverse-list->uvector ls)
  (list->uvector (reverse ls)))

(define (uvector-unfold f len seed)
  (let ((res (make-uvector len)))
    (let lp ((i 0) (seed seed))
      (if (>= i len)
          res
          (call-with-values (lambda () (f i seed))
            (lambda (x seed)
              (uvector-set! res i x)
              (lp (+ i 1) seed)))))))

(define (uvector-unfold-right f len seed)
  (let ((res (make-uvector len)))
    (let lp ((i (- len 1)) (seed seed))
      (if (< i 0)
          res
          (call-with-values (lambda () (f i seed))
            (lambda (x seed)
              (uvector-set! res i x)
              (lp (- i 1) seed)))))))

(define (vector-copy vec . o)
  (let ((start (if (pair? o) (car o) 0))
        (end (if (and (pair? o) (pair? (cdr o)))
                 (cadr o)
                 (uvector-length vec))))
    (uvector-unfold (lambda (i _) (values (uvector-ref vec (+ i start)) _))
                    (- end start)
                    #f)))

(define (vector-reverse-copy vec . o)
  (let ((start (if (pair? o) (car o) 0))
        (end (if (and (pair? o) (pair? (cdr o)))
                 (cadr o)
                 (uvector-length vec))))
    (uvector-unfold (lambda (i _) (values (uvector-ref vec (- end i 1)) _))
                    (- end start)
                    #f)))

(define (vector-concatenate vecs)
  (let* ((len (apply + (map uvector-length vecs)))
         (res (make-uvector len)))
    (let lp ((ls vecs) (i 0))
      (if (null? ls)
          res
          (let ((v-len (uvector-length (car ls))))
            (vector-copy! res i (car ls))
            (lp (cdr ls) (+ i v-len)))))))

(define (vector-append . vecs)
  (vector-concatenate vecs))

(define (vector-append-subvectors . o)
  (let lp ((ls o) (vecs '()))
    (if (null? ls)
        (vector-concatenate (reverse vecs))
        (lp (cdr (cddr ls))
            (cons (vector-copy (car ls) (cadr ls) (car (cddr ls)))
                  vecs)))))

(define (vector-fill! vec x . o)
  (let ((start (if (pair? o) (car o) 0))
        (end (if (and (pair? o) (pair? (cdr o)))
                 (cadr o)
                 (uvector-length vec))))
    (let lp ((i (- end 1)))
      (when (>= i start)
        (uvector-set! vec i x)
        (lp (- i 1))))))

(define (vector-swap! vec i j)
  (let ((tmp (uvector-ref vec i)))
    (uvector-set! vec i (uvector-ref vec j))
    (uvector-set! vec j tmp)))

(define (vector-reverse! vec . o)
  (let lp ((left (if (pair? o) (car o) 0))
           (right (- (if (and (pair? o) (pair? (cdr o)))
                         (cadr o)
                         (uvector-length vec))
                     1)))
    (cond
     ((>= left right) (if #f #f))
     (else
      (vector-swap! vec left right)
      (lp (+ left 1) (- right 1))))))

(define (vector-copy! to at from . o)
  (let* ((start (if (pair? o) (car o) 0))
         (end (if (and (pair? o) (pair? (cdr o)))
                  (cadr o)
                  (uvector-length from)))
         (limit (min end (+ start (- (uvector-length to) at)))))
    (if (<= at start)
        (do ((i at (+ i 1)) (j start (+ j 1)))
            ((>= j limit))
          (uvector-set! to i (uvector-ref from j)))
        (do ((i (+ at (- end start 1)) (- i 1))
             (j (- limit 1) (- j 1)))
            ((< j start))
          (uvector-set! to i (uvector-ref from j))))))

(define (vector-reverse-copy! to at from . o)
  (let ((start (if (pair? o) (car o) 0))
        (end (if (and (pair? o) (pair? (cdr o)))
                 (cadr o)
                 (uvector-length from))))
    (vector-copy! to at from start end)
    (vector-reverse! to at (+ at (- end start)))))

(define (vector-take vec n)
  (vector-copy vec 0 n))

(define (vector-take-right vec n)
  (vector-copy vec (- (uvector-length vec) n)))

(define (vector-drop vec n)
  (vector-copy vec n))

(define (vector-drop-right vec n)
  (vector-copy vec 0 (- (uvector-length vec) n)))

(define (vector-segment vec n)
  (let ((len (uvector-length vec)))
    (let lp ((i 0) (res '()))
      (if (>= i len)
          (reverse res)
          (lp (+ i n)
              (cons (vector-copy vec i (min (+ i n) len)) res))))))

(define (vector-fold kons knil vec1 . o)
  (let ((len (uvector-length vec1)))
    (if (null? o)
        (let lp ((i 0) (acc knil))
          (if (>= i len)
              acc
              (lp (+ i 1) (kons acc (uvector-ref vec1 i)))))
        (let lp ((i 0) (acc knil))
          (if (>= i len)
              acc
              (lp (+ i 1)
                  (apply kons acc (uvector-ref vec1 i)
                         (map (lambda (v) (uvector-ref v i)) o))))))))

(define (vector-fold-right kons knil vec1 . o)
  (let ((len (uvector-length vec1)))
    (if (null? o)
        (let lp ((i (- len 1)) (acc knil))
          (if (negative? i)
              acc
              (lp (- i 1) (kons acc (uvector-ref vec1 i)))))
        (let lp ((i (- len 1)) (acc knil))
          (if (negative? i)
              acc
              (lp (- i 1)
                  (apply kons acc (uvector-ref vec1 i)
                         (map (lambda (v) (uvector-ref v i)) o))))))))

(define (vector-map! f vec1 . o)
  (apply vector-fold
         (lambda (i . o)
           (uvector-set! vec1 i (apply f o))
           (+ i 1))
         0 vec1 o))

(define (vector-map f vec1 . o)
  (let ((res (vector-copy vec1)))
    (apply vector-map! f res o)
    res))

(define (vector-for-each f vec1 . o)
  (apply vector-fold (lambda (acc . o) (apply f o) acc) (if #f #f) vec1 o))

(define (vector-count f vec1 . o)
  (apply vector-fold
         (lambda (sum . o) (+ sum (if (apply f o) 1 0)))
         0 vec1 o))

(define (vector-cumulate f knil vec)
  (let* ((len (uvector-length vec))
         (res (make-uvector len)))
    (let lp ((i 0) (acc knil))
      (if (>= i len)
          res
          (let ((acc (f acc (uvector-ref vec i))))
            (uvector-set! res i acc)
            (lp (+ i 1) acc))))))

(define (vector-index pred vec)
  (let ((len (uvector-length vec)))
    (let lp ((i 0))
      (cond ((>= i len) #f)
            ((pred (uvector-ref vec i)) i)
            (else (lp (+ i 1)))))))

(define (vector-index-right pred vec)
  (let lp ((i (- (uvector-length vec) 1)))
    (cond ((negative? i) #f)
          ((pred (uvector-ref vec i)) i)
          (else (lp (- i 1))))))

(define (vector-skip pred vec)
  (vector-index (lambda (x) (not (pred x))) vec))

(define (vector-skip-right pred vec)
  (vector-index-right (lambda (x) (not (pred x))) vec))

(define (vector-take-while vec pred)
  (vector-copy vec 0 (or (vector-skip pred vec)
                         (uvector-length vec))))

(define (vector-take-while-right vec pred)
  (vector-copy vec (or (vector-skip-right pred vec) 0)))

(define (vector-drop-while vec pred)
  (vector-copy vec (or (vector-index pred vec) 0)))

(define (vector-drop-while-right vec pred)
  (vector-copy vec 0 (or (vector-index-right pred vec)
                         (uvector-length vec))))

(define (vector-binary-search vec value cmp)
  (let lp ((lo 0) (hi (- (uvector-length vec) 1)))
    (and (<= lo hi)
         (let* ((mid (quotient (+ lo hi) 2))
                (x (uvector-ref vec mid))
                (y (cmp value x)))
           (cond
            ((< y 0) (lp lo (- mid 1)))
            ((> y 0) (lp (+ mid 1) hi))
            (else mid))))))

(define (vector-any pred? vec1 . o)
  (let ((len (apply min (uvector-length vec1)
                    (map uvector-length o))))
    (let lp ((i 0))
      (and (< i len)
           (or (apply pred? (uvector-ref vec1 i)
                      (map (lambda (v) (uvector-ref v i)) o))
               (lp (+ i 1)))))))

(define (vector-every pred? vec1 . o)
  (let ((len (apply min (uvector-length vec1)
                    (map uvector-length o))))
    (let lp ((i 0))
      (let ((x (apply pred? (uvector-ref vec1 i)
                      (map (lambda (v) (uvector-ref v i)) o))))
        (if (= i (- len 1))
            x
            (and x (lp (+ i 1))))))))

(define (vector-partition pred? vec)
  (let* ((len (uvector-length vec))
         (res (make-uvector len)))
    (let lp ((i 0) (left 0) (right (- len 1)))
      (cond
       ((= i len)
        (if (< left len)
            (vector-reverse! res left))
        (values res left))
       (else
        (let ((x (uvector-ref vec i)))
          (cond
           ((pred? x)
            (uvector-set! res left x)
            (lp (+ i 1) (+ left 1) right))
           (else
            (uvector-set! res right x)
            (lp (+ i 1) left (- right 1))))))))))

(define (vector-filter pred vec)
  (list->uvector
   (reverse
    (vector-fold (lambda (ls elt) (if (pred elt) (cons elt ls) ls))
                 '() vec))))

(define (vector-remove pred vec)
  (vector-filter (lambda (x) (not (pred x))) vec))

(define (reverse-vector->list vec . o)
  (let ((vec (if (pair? o) (apply vector-copy vec o) vec)))
    (vector-fold (lambda (ls x) (cons x ls)) '() vec)))

(define (reverse-list->vector ls)
  (list->uvector (reverse ls)))

(define (uvector->vector vec . o)
  (list->vector (apply uvector->list vec o)))

(define (vector->uvector vec . o)
  (list->uvector (apply vector->list vec o)))

(define make-vector-generator
  (let ((eof (read-char (open-input-string ""))))
    (lambda (vec)
      (let ((i 0) (len (uvector-length vec)))
        (lambda ()
          (if (>= i len)
              eof
              (let ((res (uvector-ref vec i)))
                (set! i (+ i 1))
                res)))))))

(define write-vector write)

(define-library (srfi 160 s16)
  (export
   make-s16vector
   s16?
   s16vector?
   s16vector-ref
   s16vector-set!
   s16vector-length
   (rename uvector-unfold s16vector-unfold)
   (rename uvector-unfold-right s16vector-unfold-right)
   (rename vector-copy s16vector-copy)
   (rename vector-reverse-copy s16vector-reverse-copy)
   (rename vector-append s16vector-append)
   (rename vector-concatenate s16vector-concatenate)
   (rename vector-append-subvectors s16vector-append-subvectors)
   (rename vector-empty? s16vector-empty?)
   (rename vector= s16vector=)
   (rename vector-take s16vector-take)
   (rename vector-take-right s16vector-take-right)
   (rename vector-drop s16vector-drop)
   (rename vector-drop-right s16vector-drop-right)
   (rename vector-segment s16vector-segment)
   (rename vector-fold s16vector-fold)
   (rename vector-fold-right s16vector-fold-right)
   (rename vector-map s16vector-map)
   (rename vector-map! s16vector-map!)
   (rename vector-for-each s16vector-for-each)
   (rename vector-count s16vector-count)
   (rename vector-cumulate s16vector-cumulate)
   (rename vector-take-while s16vector-take-while)
   (rename vector-take-while-right s16vector-take-while-right)
   (rename vector-drop-while s16vector-drop-while)
   (rename vector-drop-while-right s16vector-drop-while-right)
   (rename vector-index s16vector-index)
   (rename vector-index-right s16vector-index-right)
   (rename vector-skip s16vector-skip)
   (rename vector-skip-right s16vector-skip-right)
   (rename vector-binary-search s16vector-binary-search)
   (rename vector-any s16vector-any)
   (rename vector-every s16vector-every)
   (rename vector-partition s16vector-partition)
   (rename vector-filter s16vector-filter)
   (rename vector-remove s16vector-remove)
   (rename vector-swap! s16vector-swap!)
   (rename vector-fill! s16vector-fill!)
   (rename vector-reverse! s16vector-reverse!)
   (rename vector-copy! s16vector-copy!)
   (rename vector-reverse-copy! s16vector-reverse-copy!)
   (rename reverse-vector->list reverse-s16vector->list)
   (rename reverse-list->vector reverse-list->s16vector)
   (rename uvector->vector s16vector->vector)
   (rename vector->uvector vector->s16vector)
   (rename make-vector-generator make-s16vector-generator)
   (rename write-vector write-s16vector))
  (import (except (scheme base)
                  vector-append vector-copy vector-copy!
                  vector-map vector-for-each)
          (scheme write)
          (srfi 160 base))
  (begin
    (define uvector? s16vector?)
    (define make-uvector make-s16vector)
    (define vector s16vector)
    (define uvector->list s16vector->list)
    (define list->uvector list->s16vector)
    (define uvector-length s16vector-length)
    (define uvector-ref s16vector-ref)
    (define uvector-set! s16vector-set!))
  (include "uvector.scm"))

(define-library (srfi 160 uvector)
  (import (scheme base) (scheme write))
  (export define-uvector-procedures)
  (begin
    (define-syntax define-uvector-procedures
      (syntax-rules ()
        ((define-uvector-procedures
           ;; primitives supplied
           u? uvector? make-uvector
           uvector-length uvector-ref uvector-set!
           ;; derived
           uvector uvector-unfold uvector-unfold-right
           uvector-copy uvector-reverse-copy uvector-append
           uvector-concatenate uvector-append-subvectors
           uvector-empty? uvector=
           uvector-take uvector-take-right
           uvector-drop uvector-drop-right
           uvector-segment uvector-fold uvector-fold-right
           uvector-map uvector-map! uvector-for-each
           uvector-count uvector-cumulate
           uvector-take-while uvector-take-while-right
           uvector-drop-while uvector-drop-while-right
           uvector-index uvector-index-right
           uvector-skip uvector-skip-right
           uvector-binary-search uvector-any uvector-every
           uvector-partition uvector-filter uvector-remove
           uvector-swap! uvector-fill!
           uvector-reverse! uvector-copy! uvector-reverse-copy!
           uvector->list reverse-uvector->list list->uvector
           uvector->vector vector->uvector
           make-uvector-generator write-uvector)
         (begin

           ))))))

(define-library (srfi 160 f64)
  (export
   make-f64vector
   f64?
   f64vector?
   f64vector-ref
   f64vector-set!
   f64vector-length
   (rename uvector-unfold f64vector-unfold)
   (rename uvector-unfold-right f64vector-unfold-right)
   (rename vector-copy f64vector-copy)
   (rename vector-reverse-copy f64vector-reverse-copy)
   (rename vector-append f64vector-append)
   (rename vector-concatenate f64vector-concatenate)
   (rename vector-append-subvectors f64vector-append-subvectors)
   (rename vector-empty? f64vector-empty?)
   (rename vector= f64vector=)
   (rename vector-take f64vector-take)
   (rename vector-take-right f64vector-take-right)
   (rename vector-drop f64vector-drop)
   (rename vector-drop-right f64vector-drop-right)
   (rename vector-segment f64vector-segment)
   (rename vector-fold f64vector-fold)
   (rename vector-fold-right f64vector-fold-right)
   (rename vector-map f64vector-map)
   (rename vector-map! f64vector-map!)
   (rename vector-for-each f64vector-for-each)
   (rename vector-count f64vector-count)
   (rename vector-cumulate f64vector-cumulate)
   (rename vector-take-while f64vector-take-while)
   (rename vector-take-while-right f64vector-take-while-right)
   (rename vector-drop-while f64vector-drop-while)
   (rename vector-drop-while-right f64vector-drop-while-right)
   (rename vector-index f64vector-index)
   (rename vector-index-right f64vector-index-right)
   (rename vector-skip f64vector-skip)
   (rename vector-skip-right f64vector-skip-right)
   (rename vector-binary-search f64vector-binary-search)
   (rename vector-any f64vector-any)
   (rename vector-every f64vector-every)
   (rename vector-partition f64vector-partition)
   (rename vector-filter f64vector-filter)
   (rename vector-remove f64vector-remove)
   (rename vector-swap! f64vector-swap!)
   (rename vector-fill! f64vector-fill!)
   (rename vector-reverse! f64vector-reverse!)
   (rename vector-copy! f64vector-copy!)
   (rename vector-reverse-copy! f64vector-reverse-copy!)
   (rename reverse-vector->list reverse-f64vector->list)
   (rename reverse-list->vector reverse-list->f64vector)
   (rename uvector->vector f64vector->vector)
   (rename vector->uvector vector->f64vector)
   (rename make-vector-generator make-f64vector-generator)
   (rename write-vector write-f64vector))
  (import (except (scheme base)
                  vector-append vector-copy vector-copy!
                  vector-map vector-for-each)
          (scheme write)
          (srfi 160 base))
  (begin
    (define uvector? f64vector?)
    (define make-uvector make-f64vector)
    (define vector f64vector)
    (define uvector->list f64vector->list)
    (define list->uvector list->f64vector)
    (define uvector-length f64vector-length)
    (define uvector-ref f64vector-ref)
    (define uvector-set! f64vector-set!))
  (include "uvector.scm"))

(define-library (srfi 160 u32)
  (export
   make-u32vector
   u32?
   u32vector?
   u32vector-ref
   u32vector-set!
   u32vector-length
   (rename uvector-unfold u32vector-unfold)
   (rename uvector-unfold-right u32vector-unfold-right)
   (rename vector-copy u32vector-copy)
   (rename vector-reverse-copy u32vector-reverse-copy)
   (rename vector-append u32vector-append)
   (rename vector-concatenate u32vector-concatenate)
   (rename vector-append-subvectors u32vector-append-subvectors)
   (rename vector-empty? u32vector-empty?)
   (rename vector= u32vector=)
   (rename vector-take u32vector-take)
   (rename vector-take-right u32vector-take-right)
   (rename vector-drop u32vector-drop)
   (rename vector-drop-right u32vector-drop-right)
   (rename vector-segment u32vector-segment)
   (rename vector-fold u32vector-fold)
   (rename vector-fold-right u32vector-fold-right)
   (rename vector-map u32vector-map)
   (rename vector-map! u32vector-map!)
   (rename vector-for-each u32vector-for-each)
   (rename vector-count u32vector-count)
   (rename vector-cumulate u32vector-cumulate)
   (rename vector-take-while u32vector-take-while)
   (rename vector-take-while-right u32vector-take-while-right)
   (rename vector-drop-while u32vector-drop-while)
   (rename vector-drop-while-right u32vector-drop-while-right)
   (rename vector-index u32vector-index)
   (rename vector-index-right u32vector-index-right)
   (rename vector-skip u32vector-skip)
   (rename vector-skip-right u32vector-skip-right)
   (rename vector-binary-search u32vector-binary-search)
   (rename vector-any u32vector-any)
   (rename vector-every u32vector-every)
   (rename vector-partition u32vector-partition)
   (rename vector-filter u32vector-filter)
   (rename vector-remove u32vector-remove)
   (rename vector-swap! u32vector-swap!)
   (rename vector-fill! u32vector-fill!)
   (rename vector-reverse! u32vector-reverse!)
   (rename vector-copy! u32vector-copy!)
   (rename vector-reverse-copy! u32vector-reverse-copy!)
   (rename reverse-vector->list reverse-u32vector->list)
   (rename reverse-list->vector reverse-list->u32vector)
   (rename uvector->vector u32vector->vector)
   (rename vector->uvector vector->u32vector)
   (rename make-vector-generator make-u32vector-generator)
   (rename write-vector write-u32vector))
  (import (except (scheme base)
                  vector-append vector-copy vector-copy!
                  vector-map vector-for-each)
          (scheme write)
          (srfi 160 base))
  (begin
    (define uvector? u32vector?)
    (define make-uvector make-u32vector)
    (define vector u32vector)
    (define uvector->list u32vector->list)
    (define list->uvector list->u32vector)
    (define uvector-length u32vector-length)
    (define uvector-ref u32vector-ref)
    (define uvector-set! u32vector-set!))
  (include "uvector.scm"))

(define-library (srfi 160 u16)
  (export
   make-u16vector
   u16?
   u16vector?
   u16vector-ref
   u16vector-set!
   u16vector-length
   (rename uvector-unfold u16vector-unfold)
   (rename uvector-unfold-right u16vector-unfold-right)
   (rename vector-copy u16vector-copy)
   (rename vector-reverse-copy u16vector-reverse-copy)
   (rename vector-append u16vector-append)
   (rename vector-concatenate u16vector-concatenate)
   (rename vector-append-subvectors u16vector-append-subvectors)
   (rename vector-empty? u16vector-empty?)
   (rename vector= u16vector=)
   (rename vector-take u16vector-take)
   (rename vector-take-right u16vector-take-right)
   (rename vector-drop u16vector-drop)
   (rename vector-drop-right u16vector-drop-right)
   (rename vector-segment u16vector-segment)
   (rename vector-fold u16vector-fold)
   (rename vector-fold-right u16vector-fold-right)
   (rename vector-map u16vector-map)
   (rename vector-map! u16vector-map!)
   (rename vector-for-each u16vector-for-each)
   (rename vector-count u16vector-count)
   (rename vector-cumulate u16vector-cumulate)
   (rename vector-take-while u16vector-take-while)
   (rename vector-take-while-right u16vector-take-while-right)
   (rename vector-drop-while u16vector-drop-while)
   (rename vector-drop-while-right u16vector-drop-while-right)
   (rename vector-index u16vector-index)
   (rename vector-index-right u16vector-index-right)
   (rename vector-skip u16vector-skip)
   (rename vector-skip-right u16vector-skip-right)
   (rename vector-binary-search u16vector-binary-search)
   (rename vector-any u16vector-any)
   (rename vector-every u16vector-every)
   (rename vector-partition u16vector-partition)
   (rename vector-filter u16vector-filter)
   (rename vector-remove u16vector-remove)
   (rename vector-swap! u16vector-swap!)
   (rename vector-fill! u16vector-fill!)
   (rename vector-reverse! u16vector-reverse!)
   (rename vector-copy! u16vector-copy!)
   (rename vector-reverse-copy! u16vector-reverse-copy!)
   (rename reverse-vector->list reverse-u16vector->list)
   (rename reverse-list->vector reverse-list->u16vector)
   (rename uvector->vector u16vector->vector)
   (rename vector->uvector vector->u16vector)
   (rename make-vector-generator make-u16vector-generator)
   (rename write-vector write-u16vector))
  (import (except (scheme base)
                  vector-append vector-copy vector-copy!
                  vector-map vector-for-each)
          (scheme write)
          (srfi 160 base))
  (begin
    (define uvector? u16vector?)
    (define make-uvector make-u16vector)
    (define vector u16vector)
    (define uvector->list u16vector->list)
    (define list->uvector list->u16vector)
    (define uvector-length u16vector-length)
    (define uvector-ref u16vector-ref)
    (define uvector-set! u16vector-set!))
  (include "uvector.scm"))

(define-library (srfi 160 s32)
  (export
   make-s32vector
   s32?
   s32vector?
   s32vector-ref
   s32vector-set!
   s32vector-length
   (rename uvector-unfold s32vector-unfold)
   (rename uvector-unfold-right s32vector-unfold-right)
   (rename vector-copy s32vector-copy)
   (rename vector-reverse-copy s32vector-reverse-copy)
   (rename vector-append s32vector-append)
   (rename vector-concatenate s32vector-concatenate)
   (rename vector-append-subvectors s32vector-append-subvectors)
   (rename vector-empty? s32vector-empty?)
   (rename vector= s32vector=)
   (rename vector-take s32vector-take)
   (rename vector-take-right s32vector-take-right)
   (rename vector-drop s32vector-drop)
   (rename vector-drop-right s32vector-drop-right)
   (rename vector-segment s32vector-segment)
   (rename vector-fold s32vector-fold)
   (rename vector-fold-right s32vector-fold-right)
   (rename vector-map s32vector-map)
   (rename vector-map! s32vector-map!)
   (rename vector-for-each s32vector-for-each)
   (rename vector-count s32vector-count)
   (rename vector-cumulate s32vector-cumulate)
   (rename vector-take-while s32vector-take-while)
   (rename vector-take-while-right s32vector-take-while-right)
   (rename vector-drop-while s32vector-drop-while)
   (rename vector-drop-while-right s32vector-drop-while-right)
   (rename vector-index s32vector-index)
   (rename vector-index-right s32vector-index-right)
   (rename vector-skip s32vector-skip)
   (rename vector-skip-right s32vector-skip-right)
   (rename vector-binary-search s32vector-binary-search)
   (rename vector-any s32vector-any)
   (rename vector-every s32vector-every)
   (rename vector-partition s32vector-partition)
   (rename vector-filter s32vector-filter)
   (rename vector-remove s32vector-remove)
   (rename vector-swap! s32vector-swap!)
   (rename vector-fill! s32vector-fill!)
   (rename vector-reverse! s32vector-reverse!)
   (rename vector-copy! s32vector-copy!)
   (rename vector-reverse-copy! s32vector-reverse-copy!)
   (rename reverse-vector->list reverse-s32vector->list)
   (rename reverse-list->vector reverse-list->s32vector)
   (rename uvector->vector s32vector->vector)
   (rename vector->uvector vector->s32vector)
   (rename make-vector-generator make-s32vector-generator)
   (rename write-vector write-s32vector))
  (import (except (scheme base)
                  vector-append vector-copy vector-copy!
                  vector-map vector-for-each)
          (scheme write)
          (srfi 160 base))
  (begin
    (define uvector? s32vector?)
    (define make-uvector make-s32vector)
    (define vector s32vector)
    (define uvector->list s32vector->list)
    (define list->uvector list->s32vector)
    (define uvector-length s32vector-length)
    (define uvector-ref s32vector-ref)
    (define uvector-set! s32vector-set!))
  (include "uvector.scm"))

(define-library (srfi 160 u64)
  (export
   make-u64vector
   u64?
   u64vector?
   u64vector-ref
   u64vector-set!
   u64vector-length
   (rename uvector-unfold u64vector-unfold)
   (rename uvector-unfold-right u64vector-unfold-right)
   (rename vector-copy u64vector-copy)
   (rename vector-reverse-copy u64vector-reverse-copy)
   (rename vector-append u64vector-append)
   (rename vector-concatenate u64vector-concatenate)
   (rename vector-append-subvectors u64vector-append-subvectors)
   (rename vector-empty? u64vector-empty?)
   (rename vector= u64vector=)
   (rename vector-take u64vector-take)
   (rename vector-take-right u64vector-take-right)
   (rename vector-drop u64vector-drop)
   (rename vector-drop-right u64vector-drop-right)
   (rename vector-segment u64vector-segment)
   (rename vector-fold u64vector-fold)
   (rename vector-fold-right u64vector-fold-right)
   (rename vector-map u64vector-map)
   (rename vector-map! u64vector-map!)
   (rename vector-for-each u64vector-for-each)
   (rename vector-count u64vector-count)
   (rename vector-cumulate u64vector-cumulate)
   (rename vector-take-while u64vector-take-while)
   (rename vector-take-while-right u64vector-take-while-right)
   (rename vector-drop-while u64vector-drop-while)
   (rename vector-drop-while-right u64vector-drop-while-right)
   (rename vector-index u64vector-index)
   (rename vector-index-right u64vector-index-right)
   (rename vector-skip u64vector-skip)
   (rename vector-skip-right u64vector-skip-right)
   (rename vector-binary-search u64vector-binary-search)
   (rename vector-any u64vector-any)
   (rename vector-every u64vector-every)
   (rename vector-partition u64vector-partition)
   (rename vector-filter u64vector-filter)
   (rename vector-remove u64vector-remove)
   (rename vector-swap! u64vector-swap!)
   (rename vector-fill! u64vector-fill!)
   (rename vector-reverse! u64vector-reverse!)
   (rename vector-copy! u64vector-copy!)
   (rename vector-reverse-copy! u64vector-reverse-copy!)
   (rename reverse-vector->list reverse-u64vector->list)
   (rename reverse-list->vector reverse-list->u64vector)
   (rename uvector->vector u64vector->vector)
   (rename vector->uvector vector->u64vector)
   (rename make-vector-generator make-u64vector-generator)
   (rename write-vector write-u64vector))
  (import (except (scheme base)
                  vector-append vector-copy vector-copy!
                  vector-map vector-for-each)
          (scheme write)
          (srfi 160 base))
  (begin
    (define uvector? u64vector?)
    (define make-uvector make-u64vector)
    (define vector u64vector)
    (define uvector->list u64vector->list)
    (define list->uvector list->u64vector)
    (define uvector->list u64vector->list)
    (define uvector-length u64vector-length)
    (define uvector-ref u64vector-ref)
    (define uvector-set! u64vector-set!))
  (include "uvector.scm"))

(define-library (srfi 160 c128)
  (export
   make-c128vector
   c128?
   c128vector?
   c128vector-ref
   c128vector-set!
   c128vector-length
   (rename uvector-unfold c128vector-unfold)
   (rename uvector-unfold-right c128vector-unfold-right)
   (rename vector-copy c128vector-copy)
   (rename vector-reverse-copy c128vector-reverse-copy)
   (rename vector-append c128vector-append)
   (rename vector-concatenate c128vector-concatenate)
   (rename vector-append-subvectors c128vector-append-subvectors)
   (rename vector-empty? c128vector-empty?)
   (rename vector= c128vector=)
   (rename vector-take c128vector-take)
   (rename vector-take-right c128vector-take-right)
   (rename vector-drop c128vector-drop)
   (rename vector-drop-right c128vector-drop-right)
   (rename vector-segment c128vector-segment)
   (rename vector-fold c128vector-fold)
   (rename vector-fold-right c128vector-fold-right)
   (rename vector-map c128vector-map)
   (rename vector-map! c128vector-map!)
   (rename vector-for-each c128vector-for-each)
   (rename vector-count c128vector-count)
   (rename vector-cumulate c128vector-cumulate)
   (rename vector-take-while c128vector-take-while)
   (rename vector-take-while-right c128vector-take-while-right)
   (rename vector-drop-while c128vector-drop-while)
   (rename vector-drop-while-right c128vector-drop-while-right)
   (rename vector-index c128vector-index)
   (rename vector-index-right c128vector-index-right)
   (rename vector-skip c128vector-skip)
   (rename vector-skip-right c128vector-skip-right)
   (rename vector-binary-search c128vector-binary-search)
   (rename vector-any c128vector-any)
   (rename vector-every c128vector-every)
   (rename vector-partition c128vector-partition)
   (rename vector-filter c128vector-filter)
   (rename vector-remove c128vector-remove)
   (rename vector-swap! c128vector-swap!)
   (rename vector-fill! c128vector-fill!)
   (rename vector-reverse! c128vector-reverse!)
   (rename vector-copy! c128vector-copy!)
   (rename vector-reverse-copy! c128vector-reverse-copy!)
   (rename reverse-vector->list reverse-c128vector->list)
   (rename reverse-list->vector reverse-list->c128vector)
   (rename uvector->vector c128vector->vector)
   (rename vector->uvector vector->c128vector)
   (rename make-vector-generator make-c128vector-generator)
   (rename write-vector write-c128vector))
  (import (except (scheme base)
                  vector-append vector-copy vector-copy!
                  vector-map vector-for-each)
          (scheme write)
          (srfi 160 base))
  (begin
    (define uvector? c128vector?)
    (define make-uvector make-c128vector)
    (define vector c128vector)
    (define uvector->list c128vector->list)
    (define list->uvector list->c128vector)
    (define uvector-length c128vector-length)
    (define uvector-ref c128vector-ref)
    (define uvector-set! c128vector-set!))
  (include "uvector.scm"))
(define-library (srfi 160 test)
  (import (scheme base)
          (srfi 160 base) (srfi 160 u32) (srfi 160 u64) (srfi 160 s64)
          (chibi test))
  (export run-tests)
  (begin
    (define (run-tests)
      (test-begin "srfi-160: uniform vectors")
      (test-group "uvectors/constructors"
        (define a2i '#u32(0 1 2 3 4 5 6 7 8))
        (test '#u8(0 1 2 3 4) (u8vector 0 1 2 3 4))
        (test '#u32(0 1 2 3 4) (u32vector 0 1 2 3 4))
        (test '#u32(0 1 2 3 4 5 6 7 8 9)
          (u32vector-unfold (lambda (i x) (values x (+ x 1))) 10 0))
        (test '#u32(0 1 2 3 4 5 6) (u32vector-unfold values 7 #f))
        (test a2i (u32vector-copy a2i))
        (test-assert (not (eqv? a2i (u32vector-copy a2i))))
        (test '#u32(6 7 8) (u32vector-copy a2i 6))
        (test '#u32(3 4 5) (u32vector-copy a2i 3 6))
        (test '#u32(4 3 1) (u32vector-reverse-copy (u32vector 1 3 4)))
        (test '#u32(1 2 3 4) (u32vector-reverse-copy '#u32(5 4 3 2 1 0) 1 5))
        (test '(#u32(#x01 #x02) #u32(#x03 #x04))
            (u32vector-segment #u32(1 2 3 4) 2))
        (test '#u32(0 1) (u32vector-append '#u32(0) '#u32(1)))
        (test '#u32(0 1 2 3) (u32vector-append '#u32(0) '#u32(1 2 3)))
        (test '#u64(0 1 2 3) (u64vector-append '#u64(0) '#u64(1 2 3)))
        (test '#s64(0 -1 2 -3) (s64vector-append '#s64(0) '#s64(-1 2 -3)))
        (test '#u32(0 1 2 3) (u32vector-concatenate '(#u32(0 1) #u32(2 3))))
        (test '#u32(0 1 6 7)
          (u32vector-append-subvectors '#u32(0 1 2 3 4) 0 2 '#u32(4 5 6 7 8) 2 4))
        (test '#u32(1 2)
          (vector->u32vector '#(0 1 2 3) 1 3))
        (test '#(1 2)
          (u32vector->vector '#u32(0 1 2 3) 1 3))
        )

      (test-group "uvectors/predicates"
        (test #f (u32vector-empty? '#u32(0)))
        (test-assert (u32vector-empty? '#u32()))
        (test-assert (u32vector= '#u32(0 1 2 3) '#u32(0 1 2 3)))
        (test #t (u32vector= '#u32(0 1 2 3) '#u32(0 1 2 3)))
        (test #f (u32vector= '#u32(1 2 3 4 5) '#u32(1 2 3 4)))
        (test-assert (u32vector=))
        (test-assert (u32vector= '#u32(0)))
        (test-assert (u32vector= (u32vector 0) (u32vector 0)))
        )

      (test-group "uvectors/iteration"
        (define vec '#u32(0 1 2 3 4 5))
        (define vec2 (u32vector 0 1 2 3 4))
        (define vec3 (u32vector 1 2 3 4 5))
        (test '(5 4 3 2 1 0)
            (u32vector-fold (lambda (tail elt) (cons elt tail)) '() vec))
        (test 3 (u32vector-fold (lambda (ctr n) (if (even? n) (+ ctr 1) ctr)) 0 vec))
        (test '(0 1 2 3) (u32vector-fold-right (lambda (tail elt) (cons elt tail))
                                               '() '#u32(0 1 2 3)))
        (test '#u32(1 4 9 16) (u32vector-map square '#u32(1 2 3 4)))
        (test '#u32(5 8 9 8 5) (u32vector-map * '#u32(1 2 3 4 5) '#u32(5 4 3 2 1)))
        (u32vector-map! square vec2)
        (test '#u32(0 1 4 9 16) (u32vector-copy vec2))
        (u32vector-map! * vec2 vec3)
        (test '#u32(0 2 12 36 80) (u32vector-copy vec2))
        (let ((result '()))
          (u32vector-for-each (lambda (x) (set! result (cons x result))) vec)
          (test '(5 4 3 2 1 0) result))
        (test 3 (u32vector-count even? '#u32(3 1 4 1 5 9 2 5 6)))
        (test 2 (u32vector-count < '#u32(1 3 6 9) '#u32(2 4 6 8 10 12)))
        (test '#u32(3 4 8 9 14 23 25 30 36) (u32vector-cumulate + 0 '#u32(3 1 4 1 5 9 2 5 6)))
        )

      (test-group "uvectors/searching"
        (define (cmp a b)
          (cond
           ((< a b) -1)
           ((= a b) 0)
           (else 1)))
        (define v '#u32(0 2 4 6 8 10 12))
        (test 2 (u32vector-index even? '#u32(3 1 4 1 5 9 6)))
        (test 5 (u32vector-index-right odd? '#u32(3 1 4 1 5 9 6)))
        (test 2 (u32vector-skip odd? '#u32(1 3 2 5 7 1 1 8 9)))
        (test 7 (u32vector-skip-right odd? '#u32(1 3 2 5 7 1 1 8 9)))
        (test 0 (u32vector-binary-search v 0 cmp))
        (test 3 (u32vector-binary-search v 6 cmp))
        (test #f (u32vector-binary-search v 1 cmp))
        (test-assert (u32vector-any even? '#u32(1 2 3 4 5)))
        (test-assert (u32vector-any < '#u32(1 2 3 4 5) '#u32(2 1 3 4 5)))
        (test #f (u32vector-any odd? '#u32(2 4 6 8)))
        (test #f (u32vector-any > '#u32(1 2 3 4 5) '#u32(1 2 3 4 5)))
        (test #f (u32vector-every odd? '#u32(1 2 3 4 5)))
        (test-assert (u32vector-every number? '#u32(1 2 3 4 5)))
        (test #f (u32vector-every < '#u32(1 2 3) '#u32(2 3 3)))
        (test-assert (u32vector-every < '#u32(1 2 3) '#u32(2 3 4)))
        (test 'yes (u32vector-any (lambda (x) (if (even? x) 'yes #f)) '#u32(1 3 2 5 7)))
        (let-values (((new off) (u32vector-partition odd? '#u32(1 2 3 4 5 6))))
          (test '#u32(1 3 5 2 4 6) (u32vector-copy new))
          (test 3 off))
        )

      (test-group "uvectors/mutation"
        (define vs (u32vector 1 2 3))
        (define vf0 (u32vector 1 2 3))
        (define vf1 (u32vector 1 2 3))
        (define vf2 (u32vector 1 2 3))
        (define vr0 (u32vector 1 2 3))
        (define vr1 (u32vector 1 2 3))
        (define vr2 (u32vector 1 2 3))
        (define vc0 (u32vector 1 2 3 4 5))
        (define vc1 (u32vector 1 2 3 4 5))
        (define vc2 (u32vector 1 2 3 4 5))
        (define vrc0 (u32vector 1 2 3 4 5))
        (define vrc1 (u32vector 1 2 3 4 5))
        (define vrc2 (u32vector 1 2 3 4 5))
        (define vu0 (u32vector 1 2 3 4 5))
        (define vu1 (u32vector 1 2 3 4 5))
        (define vu2 (u32vector 1 2 3 4 5))
        (define vur0 (u32vector 1 2 3 4 5))
        (define vur1 (u32vector 1 2 3 4 5))
        (define vur2 (u32vector 1 2 3 4 5))
        (u32vector-swap! vs 0 1)
        (test '#u32(2 1 3) (u32vector-copy vs))
        (u32vector-fill! vf0 0)
        (test '#u32(0 0 0) (u32vector-copy vf0))
        (u32vector-fill! vf1 0 1)
        (test '#u32(1 0 0) (u32vector-copy vf1))
        (u32vector-fill! vf2 0 0 1)
        (test '#u32(0 2 3) (u32vector-copy vf2))
        (u32vector-reverse! vr0)
        (test '#u32(3 2 1) (u32vector-copy vr0))
        (u32vector-reverse! vr1 1)
        (test '#u32(1 3 2) (u32vector-copy vr1))
        (u32vector-reverse! vr2 0 2)
        (test '#u32(2 1 3) (u32vector-copy vr2))
        (u32vector-copy! vc0 1 '#u32(10 20 30))
        (test '#u32(1 10 20 30 5) (u32vector-copy vc0))
        (u32vector-copy! vc1 1 '#u32(0 10 20 30 40) 1)
        (test '#u32(1 10 20 30 40) (u32vector-copy vc1))
        (u32vector-copy! vc2 1 '#u32(0 10 20 30 40) 1 4)
        (test '#u32(1 10 20 30 5) (u32vector-copy vc2))
        (u32vector-reverse-copy! vrc0 1 '#u32(10 20 30))
        (test '#u32(1 30 20 10 5) (u32vector-copy vrc0))
        (u32vector-reverse-copy! vrc1 1 '#u32(0 10 20 30 40) 1)
        (test '#u32(1 40 30 20 10) (u32vector-copy vrc1))
        (u32vector-reverse-copy! vrc2 1 '#u32(0 10 20 30 40) 1 4)
        (test '#u32(1 30 20 10 5) (u32vector-copy vrc2))
        (let ((uv (make-u64vector 2 0)))
          (u64vector-set! uv 0 10631884467263188874)
          (test '#u64(10631884467263188874 0) uv))
        )

      (test-group "uvectors/conversion"
        (test '(1 2 3) (u32vector->list '#u32(1 2 3)))
        (test '(2 3) (u32vector->list '#u32(1 2 3) 1))
        (test '(1 2) (u32vector->list '#u32(1 2 3) 0 2))
        (test '#u32(1 2 3) (list->u32vector '(1 2 3)))
        (test '(3 2 1) (reverse-u32vector->list '#u32(1 2 3)))
        (test '(3 2) (reverse-u32vector->list '#u32(1 2 3) 1))
        (test '(2 1) (reverse-u32vector->list '#u32(1 2 3) 0 2))
        (test '#u32(3 2 1) (reverse-list->u32vector '(1 2 3)))
        )

      (test-group "bitvectors"
        (let ((uv #u1(0 1 0 1 0 1 0)))
          (test 0 (u1vector-ref uv 0))
          (test 1 (u1vector-ref uv 1))
          (test 0 (u1vector-ref uv 2))
          (test 1 (u1vector-ref uv 3))
          (test 0 (u1vector-ref uv 4))
          (test 1 (u1vector-ref uv 5))
          (test 0 (u1vector-ref uv 6))
          (test-error (u1vector-ref uv -1))
          (test-error (u1vector-ref uv 7)))
        (let ((uv #u1(1 0 1 0 1 0 1 0)))
          (test 1 (u1vector-ref uv 0))
          (test 0 (u1vector-ref uv 1))
          (test 1 (u1vector-ref uv 2))
          (test 0 (u1vector-ref uv 3))
          (test 1 (u1vector-ref uv 4))
          (test 0 (u1vector-ref uv 5))
          (test 1 (u1vector-ref uv 6))
          (test 0 (u1vector-ref uv 7))
          (test-error (u1vector-ref uv -1))
          (test-error (u1vector-ref uv 8)))
        (let ((uv #u1(0 1 0 1 0 1 0 1 0)))
          (test 0 (u1vector-ref uv 0))
          (test 1 (u1vector-ref uv 1))
          (test 0 (u1vector-ref uv 2))
          (test 1 (u1vector-ref uv 3))
          (test 0 (u1vector-ref uv 4))
          (test 1 (u1vector-ref uv 5))
          (test 0 (u1vector-ref uv 6))
          (test 1 (u1vector-ref uv 7))
          (test 0 (u1vector-ref uv 8))
          (test-error (u1vector-ref uv -1))
          (test-error (u1vector-ref uv 9)))
        )

      (test-end))))

(define-library (srfi 160 base)
  (import (scheme base)
          (only (chibi) list->uvector make-uvector))
  (export
   ;;
   make-u1vector u1vector u1? u1vector?
   u1vector-ref u1vector-set! u1vector-length
   u1vector->list list->u1vector
   ;;
   make-u8vector u8vector u8? u8vector?
   u8vector-ref u8vector-set! u8vector-length
   u8vector->list list->u8vector
   ;;
   make-s8vector s8vector s8? s8vector?
   s8vector-ref s8vector-set! s8vector-length
   s8vector->list list->s8vector
   ;;
   make-u16vector u16vector u16? u16vector?
   u16vector-ref u16vector-set! u16vector-length
   u16vector->list list->u16vector
   ;;
   make-s16vector s16vector s16? s16vector?
   s16vector-ref s16vector-set! s16vector-length
   s16vector->list list->s16vector
   ;;
   make-u32vector u32vector u32? u32vector?
   u32vector-ref u32vector-set! u32vector-length
   u32vector->list list->u32vector
   ;;
   make-s32vector s32vector s32? s32vector?
   s32vector-ref s32vector-set! s32vector-length
   s32vector->list list->s32vector
   ;;
   make-u64vector u64vector u64? u64vector?
   u64vector-ref u64vector-set! u64vector-length
   u64vector->list list->u64vector
   ;;
   make-s64vector s64vector s64? s64vector?
   s64vector-ref s64vector-set! s64vector-length
   s64vector->list list->s64vector
   ;;
   make-f32vector f32vector f32? f32vector?
   f32vector-ref f32vector-set! f32vector-length
   f32vector->list list->f32vector
   ;;
   make-f64vector f64vector f64? f64vector?
   f64vector-ref f64vector-set! f64vector-length
   f64vector->list list->f64vector
   ;;
   make-c64vector c64vector c64? c64vector?
   c64vector-ref c64vector-set! c64vector-length
   c64vector->list list->c64vector
   ;;
   make-c128vector c128vector c128? c128vector?
   c128vector-ref c128vector-set! c128vector-length
   c128vector->list list->c128vector
   )
  (cond-expand
   (uvector
    (include-shared "uvprims"))
   (else
    (begin
      )))
  (begin
    (define u8vector? bytevector?)
    (define u8vector-ref bytevector-u8-ref)
    (define u8vector-set! bytevector-u8-set!)
    (define (u1? x) (memq x '(0 1)))
    (define (u8? x) (and (exact-integer? x) (<= 0 x 255)))
    (define (s8? x) (and (exact-integer? x) (<= -128 x 127)))
    (define (u16? x) (and (exact-integer? x) (<= 0 x 65536)))
    (define (s16? x) (and (exact-integer? x) (<= -32768 x 32767)))
    (define (u32? x) (and (exact-integer? x) (<= 0 x 4294967296)))
    (define (s32? x) (and (exact-integer? x) (<= -2147483648 x 2147483647)))
    (define (u64? x) (and (exact-integer? x) (<= 0 x 18446744073709551616)))
    (define (s64? x)
      (and (exact-integer? x) (<= -9223372036854775808 x 9223372036854775807)))
    (define (f32? x) (and (real? x) (inexact? x)))
    (define (f64? x) (and (real? x) (inexact? x)))
    (define (c64? x) (and (complex? x) (inexact? x)))
    (define (c128? x) (and (complex? x) (inexact? x)))
    (define u1vector-length uvector-length)
    (define u8vector-length bytevector-length)
    (define s8vector-length uvector-length)
    (define u16vector-length uvector-length)
    (define s16vector-length uvector-length)
    (define u32vector-length uvector-length)
    (define s32vector-length uvector-length)
    (define u64vector-length uvector-length)
    (define s64vector-length uvector-length)
    (define f32vector-length uvector-length)
    (define f64vector-length uvector-length)
    (define c64vector-length uvector-length)
    (define c128vector-length uvector-length)
    (define (list->u1vector ls) (list->uvector SEXP_U1 ls))
    (define (list->u8vector ls)
      (let* ((len (length ls))
             (res (make-bytevector len)))
        (do ((ls ls (cdr ls))
             (i 0 (+ i 1)))
            ((null? ls) res)
          (bytevector-u8-set! res i (car ls)))))
    (define (list->s8vector ls) (list->uvector SEXP_S8 ls))
    (define (list->u16vector ls) (list->uvector SEXP_U16 ls))
    (define (list->s16vector ls) (list->uvector SEXP_S16 ls))
    (define (list->u32vector ls) (list->uvector SEXP_U32 ls))
    (define (list->s32vector ls) (list->uvector SEXP_S32 ls))
    (define (list->u64vector ls) (list->uvector SEXP_U64 ls))
    (define (list->s64vector ls) (list->uvector SEXP_S64 ls))
    (define (list->f32vector ls) (list->uvector SEXP_F32 ls))
    (define (list->f64vector ls) (list->uvector SEXP_F64 ls))
    (define (list->c64vector ls) (list->uvector SEXP_C64 ls))
    (define (list->c128vector ls) (list->uvector SEXP_C128 ls))
    (define (u1vector . ls) (list->u1vector ls))
    (define (u8vector . ls) (list->u8vector ls))
    (define (s8vector . ls) (list->s8vector ls))
    (define (u16vector . ls) (list->u16vector ls))
    (define (s16vector . ls) (list->s16vector ls))
    (define (u32vector . ls) (list->u32vector ls))
    (define (s32vector . ls) (list->s32vector ls))
    (define (u64vector . ls) (list->u64vector ls))
    (define (s64vector . ls) (list->s64vector ls))
    (define (f32vector . ls) (list->f32vector ls))
    (define (f64vector . ls) (list->f64vector ls))
    (define (c64vector . ls) (list->c64vector ls))
    (define (c128vector . ls) (list->c128vector ls))
    (define (make-u1vector len . o)
      (let ((res (make-uvector SEXP_U1 len)))
        (if (and (pair? o) (not (zero? (car o))))
            (do ((i 0 (+ i 1)))
                ((>= i len))
              (u1vector-set! res i 1)))
        res))
    (define make-u8vector make-bytevector)
    (define (make-s8vector len . o)
      (let ((res (make-uvector SEXP_S8 len)))
        (if (and (pair? o) (not (zero? (car o))))
            (do ((i 0 (+ i 1)))
                ((>= i len))
              (s8vector-set! res i (car o))))
        res))
    (define (make-u16vector len . o)
      (let ((res (make-uvector SEXP_U16 len)))
        (if (and (pair? o) (not (zero? (car o))))
            (do ((i 0 (+ i 1)))
                ((>= i len))
              (u16vector-set! res i (car o))))
        res))
    (define (make-s16vector len . o)
      (let ((res (make-uvector SEXP_S16 len)))
        (if (and (pair? o) (not (zero? (car o))))
            (do ((i 0 (+ i 1)))
                ((>= i len))
              (s16vector-set! res i (car o))))
        res))
    (define (make-u32vector len . o)
      (let ((res (make-uvector SEXP_U32 len)))
        (if (and (pair? o) (not (zero? (car o))))
            (do ((i 0 (+ i 1)))
                ((>= i len))
              (u32vector-set! res i (car o))))
        res))
    (define (make-s32vector len . o)
      (let ((res (make-uvector SEXP_S32 len)))
        (if (and (pair? o) (not (zero? (car o))))
            (do ((i 0 (+ i 1)))
                ((>= i len))
              (s32vector-set! res i (car o))))
        res))
    (define (make-u64vector len . o)
      (let ((res (make-uvector SEXP_U64 len)))
        (if (and (pair? o) (not (zero? (car o))))
            (do ((i 0 (+ i 1)))
                ((>= i len))
              (u64vector-set! res i (car o))))
        res))
    (define (make-s64vector len . o)
      (let ((res (make-uvector SEXP_S64 len)))
        (if (and (pair? o) (not (zero? (car o))))
            (do ((i 0 (+ i 1)))
                ((>= i len))
              (s64vector-set! res i (car o))))
        res))
    (define (make-f32vector len . o)
      (let ((res (make-uvector SEXP_F32 len)))
        (if (and (pair? o) (not (zero? (car o))))
            (do ((i 0 (+ i 1)))
                ((>= i len))
              (f32vector-set! res i (car o))))
        res))
    (define (make-f64vector len . o)
      (let ((res (make-uvector SEXP_F64 len)))
        (if (and (pair? o) (not (zero? (car o))))
            (do ((i 0 (+ i 1)))
                ((>= i len))
              (f64vector-set! res i (car o))))
        res))
    (define (make-c64vector len . o)
      (let ((res (make-uvector SEXP_C64 len)))
        (if (and (pair? o) (not (zero? (car o))))
            (do ((i 0 (+ i 1)))
                ((>= i len))
              (c64vector-set! res i (car o))))
        res))
    (define (make-c128vector len . o)
      (let ((res (make-uvector SEXP_C128 len)))
        (if (and (pair? o) (not (zero? (car o))))
            (do ((i 0 (+ i 1)))
                ((>= i len))
              (c128vector-set! res i (car o))))
        res))
    (define-syntax define-uvector->list
      (syntax-rules ()
        ((define-uvector->list uv->list len ref)
         (define (uv->list uv . o)
           (let ((start (if (pair? o) (car o) 0))
                 (end (if (and (pair? o) (pair? (cdr o))) (cadr o) (len uv))))
             (do ((i (- end 1) (- i 1))
                 (res '() (cons (ref uv i) res)))
                ((< i start) res)))))))
    (define-uvector->list u1vector->list u1vector-length u1vector-ref)
    (define-uvector->list u8vector->list bytevector-length bytevector-u8-ref)
    (define-uvector->list s8vector->list s8vector-length s8vector-ref)
    (define-uvector->list u16vector->list u16vector-length u16vector-ref)
    (define-uvector->list s16vector->list s16vector-length s16vector-ref)
    (define-uvector->list u32vector->list u32vector-length u32vector-ref)
    (define-uvector->list s32vector->list s32vector-length s32vector-ref)
    (define-uvector->list u64vector->list u64vector-length u64vector-ref)
    (define-uvector->list s64vector->list s64vector-length s64vector-ref)
    (define-uvector->list f32vector->list f32vector-length f32vector-ref)
    (define-uvector->list f64vector->list f64vector-length f64vector-ref)
    (define-uvector->list c64vector->list c64vector-length c64vector-ref)
    (define-uvector->list c128vector->list c128vector-length c128vector-ref)
    ))

(define-library (srfi 160 f32)
  (export
   make-f32vector
   f32?
   f32vector?
   f32vector-ref
   f32vector-set!
   f32vector-length
   (rename uvector-unfold f32vector-unfold)
   (rename uvector-unfold-right f32vector-unfold-right)
   (rename vector-copy f32vector-copy)
   (rename vector-reverse-copy f32vector-reverse-copy)
   (rename vector-append f32vector-append)
   (rename vector-concatenate f32vector-concatenate)
   (rename vector-append-subvectors f32vector-append-subvectors)
   (rename vector-empty? f32vector-empty?)
   (rename vector= f32vector=)
   (rename vector-take f32vector-take)
   (rename vector-take-right f32vector-take-right)
   (rename vector-drop f32vector-drop)
   (rename vector-drop-right f32vector-drop-right)
   (rename vector-segment f32vector-segment)
   (rename vector-fold f32vector-fold)
   (rename vector-fold-right f32vector-fold-right)
   (rename vector-map f32vector-map)
   (rename vector-map! f32vector-map!)
   (rename vector-for-each f32vector-for-each)
   (rename vector-count f32vector-count)
   (rename vector-cumulate f32vector-cumulate)
   (rename vector-take-while f32vector-take-while)
   (rename vector-take-while-right f32vector-take-while-right)
   (rename vector-drop-while f32vector-drop-while)
   (rename vector-drop-while-right f32vector-drop-while-right)
   (rename vector-index f32vector-index)
   (rename vector-index-right f32vector-index-right)
   (rename vector-skip f32vector-skip)
   (rename vector-skip-right f32vector-skip-right)
   (rename vector-binary-search f32vector-binary-search)
   (rename vector-any f32vector-any)
   (rename vector-every f32vector-every)
   (rename vector-partition f32vector-partition)
   (rename vector-filter f32vector-filter)
   (rename vector-remove f32vector-remove)
   (rename vector-swap! f32vector-swap!)
   (rename vector-fill! f32vector-fill!)
   (rename vector-reverse! f32vector-reverse!)
   (rename vector-copy! f32vector-copy!)
   (rename vector-reverse-copy! f32vector-reverse-copy!)
   (rename reverse-vector->list reverse-f32vector->list)
   (rename reverse-list->vector reverse-list->f32vector)
   (rename uvector->vector f32vector->vector)
   (rename vector->uvector vector->f32vector)
   (rename make-vector-generator make-f32vector-generator)
   (rename write-vector write-f32vector))
  (import (except (scheme base)
                  vector-append vector-copy vector-copy!
                  vector-map vector-for-each)
          (scheme write)
          (srfi 160 base))
  (begin
    (define uvector? f32vector?)
    (define make-uvector make-f32vector)
    (define vector f32vector)
    (define uvector->list f32vector->list)
    (define list->uvector list->f32vector)
    (define uvector-length f32vector-length)
    (define uvector-ref f32vector-ref)
    (define uvector-set! f32vector-set!))
  (include "uvector.scm"))

(define-library (srfi 2)
  (export and-let*)
  (import (chibi))
  (begin
   (define-syntax and-let*
     (syntax-rules ()
       ((and-let* ())
        #t)
       ((and-let* () . body)
        (let () . body))
       ((and-let* ((var expr)))
        expr)
       ((and-let* ((expr)))
        expr)
       ((and-let* (expr))  ; Extension: in SRFI-2 this can only be a var ref
        expr)
       ((and-let* ((var expr) . rest) . body)
        (let ((var expr))
          (and var (and-let* rest . body))))
       ((and-let* ((expr) . rest) . body)
        (and expr (and-let* rest . body)))
       ((and-let* (expr . rest) . body)   ; Same extension as above
        (let ((tmp expr))
          (and tmp (and-let* rest . body))))))))

(define-library (srfi 229 test)
  (import (scheme base) (srfi 229) (chibi test))
  (export run-tests)
  (begin
    (define (run-tests . o)
      (test-begin "(srfi 229)")
      (let ()
        (define f
          (lambda/tag 42
                      (x)
                      (* x x)))
        (define f*
          (lambda/tag 43
                      (x)
                      (* x x)))
        (define g
          (lambda/tag 44 args (apply list args)))
        (test-assert (procedure/tag? f))
        (test-not (procedure/tag? (lambda (x) (* x x))))
        (test-not (procedure/tag? +))
        (test 9 (f 3))
        (test 42 (procedure-tag f))
        (test-not (eqv? f f*))
        (test 43 (procedure-tag f*))
        (test 44 (procedure-tag g))
        (test '(1) (g 1))
        (test '(1 2 3) (g 1 2 3)))
      (test-end))))
;; Adapted for R7RS by Alex Shinn 2018.

;; SRFI 101: Purely Functional Random-Access Pairs and Lists
;; Copyright (c) David Van Horn 2009.  All Rights Reserved.

;; Permission is hereby granted, free of charge, to any person obtaining
;; a copy of this software and associated documentation
;; files (the "Software"), to deal in the Software without restriction,
;; including without limitation the rights to use, copy, modify, merge,
;; publish, distribute, sublicense, and/or sell copies of the Software,
;; and to permit persons to whom the Software is furnished to do so,
;; subject to the following conditions:

;; The above copyright notice and this permission notice shall be
;; included in all copies or substantial portions of the Software.

;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
;; EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
;; MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
;; NONINFRINGEMENT. REMEMBER, THERE IS NO SCHEME UNDERGROUND. IN NO EVENT
;; SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
;; DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
;; OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
;; THE USE OR OTHER DEALINGS IN THE SOFTWARE.

(define-record-type kons
  (make-kons size tree rest)
  kons?
  (size kons-size)
  (tree kons-tree)
  (rest kons-rest))

(define-record-type node
  (make-node val left right)
  node?
  (val node-val)
  (left node-left)
  (right node-right))

(define-syntax assert
  (syntax-rules ()
    ((assert expr ...)
     (begin (unless expr (error "assertion failed" 'expr)) ...))))

;; Nat -> Nat
(define (sub1 n) (- n 1))
(define (add1 n) (+ n 1))

;; [Tree X] -> X
(define (tree-val t)
  (if (node? t) 
      (node-val t)
      t))

;; [X -> Y] [Tree X] -> [Tree Y]
(define (tree-map f t)
  (if (node? t)
      (make-node (f (node-val t))
                 (tree-map f (node-left t))
                 (tree-map f (node-right t)))
      (f t)))

;; [X -> Y] [Tree X] -> unspecified
(define (tree-for-each f t)
  (if (node? t)
      (begin (f (node-val t))
             (tree-for-each f (node-left t))
             (tree-for-each f (node-right t)))
      (f t)))

;; [X Y Z ... -> R] [List [Tree X] [Tree Y] [Tree Z] ...] -> [Tree R]
(define (tree-map/n f ts)
  (let recr ((ts ts))
    (if (and (pair? ts)
             (node? (car ts)))
        (make-node (apply f (map node-val ts))
                   (recr (map node-left ts))
                   (recr (map node-right ts)))
        (apply f ts))))

;; [X Y Z ... -> R] [List [Tree X] [Tree Y] [Tree Z] ...] -> unspecified
(define (tree-for-each/n f ts)
  (let recr ((ts ts))
    (if (and (pair? ts)
             (node? (car ts)))
        (begin (apply f (map node-val ts))
               (recr (map node-left ts))
               (recr (map node-right ts)))
        (apply f ts))))

;; Nat [Nat -> X] -> [Tree X]
;; like build-list, but for complete binary trees
(define (build-tree i f) ;; i = 2^j-1
  (let rec ((i i) (o 0))
    (if (= 1 i) 
        (f o)
        (let ((i/2 (half i)))
          (make-node (f o)
                     (rec i/2 (add1 o))
                     (rec i/2 (+ 1 o i/2)))))))

;; Consumes n = 2^i-1 and produces 2^(i-1)-1.
;; Nat -> Nat
(define (half n)
  (bitwise-arithmetic-shift n -1))

;; Nat X -> [Tree X]
(define (tr:make-tree i x) ;; i = 2^j-1
  (let recr ((i i))
    (if (= 1 i) 
        x
        (let ((n (recr (half i))))
          (make-node x n n)))))

;; Nat [Tree X] Nat [X -> X] -> X [Tree X]
(define (tree-ref/update mid t i f)
  (cond ((zero? i)
         (if (node? t) 
             (values (node-val t)
                     (make-node (f (node-val t))
                                (node-left t)
                                (node-right t)))
             (values t (f t))))
        ((<= i mid)
         (let-values (((v* t*) (tree-ref/update (half (sub1 mid)) 
                                                (node-left t) 
                                                (sub1 i) 
                                                f)))
           (values v* (make-node (node-val t) t* (node-right t)))))
        (else           
         (let-values (((v* t*) (tree-ref/update (half (sub1 mid)) 
                                                (node-right t) 
                                                (sub1 (- i mid)) 
                                                f)))
           (values v* (make-node (node-val t) (node-left t) t*))))))

;; Special-cased above to avoid logarathmic amount of cons'ing
;; and any multi-values overhead.  Operates in constant space.
;; [Tree X] Nat Nat -> X
;; invariant: (= mid (half (sub1 (tree-count t))))
(define (tree-ref/a t i mid) 
  (cond ((zero? i) (tree-val t))
        ((<= i mid) 
         (tree-ref/a (node-left t) 
                     (sub1 i) 
                     (half (sub1 mid))))
        (else 
         (tree-ref/a (node-right t) 
                     (sub1 (- i mid)) 
                     (half (sub1 mid))))))

;; Nat [Tree X] Nat -> X
;; invariant: (= size (tree-count t))
(define (tree-ref size t i)
  (if (zero? i)
      (tree-val t)
      (tree-ref/a t i (half (sub1 size)))))

;; Nat [Tree X] Nat [X -> X] -> [Tree X]
(define (tree-update size t i f)
  (let recr ((mid (half (sub1 size))) (t t) (i i))
    (cond ((zero? i)
           (if (node? t)
               (make-node (f (node-val t))
                          (node-left t)
                          (node-right t))
               (f t)))
          ((<= i mid)
           (make-node (node-val t) 
                      (recr (half (sub1 mid))
                            (node-left t) 
                            (sub1 i)) 
                      (node-right t)))
          (else
           (make-node (node-val t) 
                      (node-left t) 
                      (recr (half (sub1 mid))
                            (node-right t) 
                            (sub1 (- i mid))))))))

;; ------------------------
;; Random access lists

;; [RaListof X]
(define ra:null (quote ()))

;; [Any -> Boolean]
(define ra:pair? kons?)

;; [Any -> Boolean]
(define ra:null? null?)

;; X [RaListof X] -> [RaListof X]  /\
;; X Y -> [RaPair X Y]
(define (ra:cons x ls)
  (if (kons? ls)
      (let ((s (kons-size ls)))
        (if (and (kons? (kons-rest ls))
                 (= (kons-size (kons-rest ls))
                    s))
            (make-kons (+ 1 s s) 
                       (make-node x 
                                  (kons-tree ls)
                                  (kons-tree (kons-rest ls)))
                       (kons-rest (kons-rest ls)))
            (make-kons 1 x ls)))
      (make-kons 1 x ls)))


;; [RaPair X Y] -> X Y
(define ra:car+cdr 
  (lambda (p)
    (assert (kons? p))
    (if (node? (kons-tree p))
        (let ((s* (half (kons-size p))))
          (values (tree-val (kons-tree p))
                  (make-kons s* 
                             (node-left (kons-tree p))
                             (make-kons s*
                                        (node-right (kons-tree p))
                                        (kons-rest p)))))
        (values (kons-tree p) (kons-rest p)))))

;; [RaPair X Y] -> X
(define (ra:car p)
  (call-with-values (lambda () (ra:car+cdr p))
                    (lambda (car cdr) car)))

;; [RaPair X Y] -> Y
(define (ra:cdr p)
  (call-with-values (lambda () (ra:car+cdr p))
                    (lambda (car cdr) cdr)))

;; [RaListof X] Nat [X -> X] -> X [RaListof X]
(define (ra:list-ref/update ls i f)
  ;(assert (< i (ra:length ls)))
  (let recr ((xs ls) (j i))
    (if (< j (kons-size xs))
        (let-values (((v* t*) 
                      (tree-ref/update (half (sub1 (kons-size xs))) 
                                       (kons-tree xs) j f)))
          (values v* (make-kons (kons-size xs) 
                                t* 
                                (kons-rest xs))))
        (let-values (((v* r*) 
                      (recr (kons-rest xs) 
                            (- j (kons-size xs)))))
          (values v* (make-kons (kons-size xs) 
                                (kons-tree xs) 
                                r*))))))

;; [RaListof X] Nat [X -> X] -> [RaListof X]
(define (ra:list-update ls i f)
  ;(assert (< i (ra:length ls)))
  (let recr ((xs ls) (j i))
    (let ((s (kons-size xs)))
      (if (< j s) 
          (make-kons s (tree-update s (kons-tree xs) j f) (kons-rest xs))
          (make-kons s (kons-tree xs) (recr (kons-rest xs) (- j s)))))))

;; [RaListof X] Nat X -> (values X [RaListof X])
(define (ra:list-ref/set ls i v)
  (ra:list-ref/update ls i (lambda (_) v)))

;; X ... -> [RaListof X]
(define (ra:list . xs)
  (fold-right ra:cons ra:null xs))

;; Nat X -> [RaListof X]
(define ra:make-list
  (case-lambda
   ((k) (ra:make-list k 0))
   ((k obj)
    (let loop ((n k) (a ra:null))
      (cond ((zero? n) a)
            (else 
             (let ((t (largest-skew-binary n)))
               (loop (- n t)
                     (make-kons t (tr:make-tree t obj) a)))))))))

;; A Skew is a Nat 2^k-1 with k > 0.

;; Skew -> Skew
(define (skew-succ t) (add1 (bitwise-arithmetic-shift t 1)))

;; Computes the largest skew binary term t <= n.
;; Nat -> Skew
(define (largest-skew-binary n)
  (if (= 1 n) 
      1
      (let* ((t (largest-skew-binary (half n)))
             (s (skew-succ t)))
        (if (> s n) t s))))  

;; [Any -> Boolean]
;; Is x a PROPER list?
(define (ra:list? x)
  (or (ra:null? x)
      (and (kons? x)
           (ra:list? (kons-rest x)))))

(define ra:caar (lambda (ls) (ra:car (ra:car ls))))
(define ra:cadr (lambda (ls) (ra:car (ra:cdr ls))))
(define ra:cddr (lambda (ls) (ra:cdr (ra:cdr ls))))
(define ra:cdar (lambda (ls) (ra:cdr (ra:car ls))))

(define ra:caaar (lambda (ls) (ra:car (ra:car (ra:car ls)))))
(define ra:caadr (lambda (ls) (ra:car (ra:car (ra:cdr ls)))))
(define ra:caddr (lambda (ls) (ra:car (ra:cdr (ra:cdr ls)))))
(define ra:cadar (lambda (ls) (ra:car (ra:cdr (ra:car ls)))))
(define ra:cdaar (lambda (ls) (ra:cdr (ra:car (ra:car ls)))))
(define ra:cdadr (lambda (ls) (ra:cdr (ra:car (ra:cdr ls)))))
(define ra:cdddr (lambda (ls) (ra:cdr (ra:cdr (ra:cdr ls)))))
(define ra:cddar (lambda (ls) (ra:cdr (ra:cdr (ra:car ls)))))

(define ra:caaaar (lambda (ls) (ra:car (ra:car (ra:car (ra:car ls))))))
(define ra:caaadr (lambda (ls) (ra:car (ra:car (ra:car (ra:cdr ls))))))
(define ra:caaddr (lambda (ls) (ra:car (ra:car (ra:cdr (ra:cdr ls))))))
(define ra:caadar (lambda (ls) (ra:car (ra:car (ra:cdr (ra:car ls))))))
(define ra:cadaar (lambda (ls) (ra:car (ra:cdr (ra:car (ra:car ls))))))
(define ra:cadadr (lambda (ls) (ra:car (ra:cdr (ra:car (ra:cdr ls))))))
(define ra:cadddr (lambda (ls) (ra:car (ra:cdr (ra:cdr (ra:cdr ls))))))
(define ra:caddar (lambda (ls) (ra:car (ra:cdr (ra:cdr (ra:car ls))))))
(define ra:cdaaar (lambda (ls) (ra:cdr (ra:car (ra:car (ra:car ls))))))
(define ra:cdaadr (lambda (ls) (ra:cdr (ra:car (ra:car (ra:cdr ls))))))
(define ra:cdaddr (lambda (ls) (ra:cdr (ra:car (ra:cdr (ra:cdr ls))))))
(define ra:cdadar (lambda (ls) (ra:cdr (ra:car (ra:cdr (ra:car ls))))))
(define ra:cddaar (lambda (ls) (ra:cdr (ra:cdr (ra:car (ra:car ls))))))
(define ra:cddadr (lambda (ls) (ra:cdr (ra:cdr (ra:car (ra:cdr ls))))))
(define ra:cddddr (lambda (ls) (ra:cdr (ra:cdr (ra:cdr (ra:cdr ls))))))
(define ra:cdddar (lambda (ls) (ra:cdr (ra:cdr (ra:cdr (ra:car ls))))))

;; [RaList X] -> Nat
(define (ra:length ls)
  (assert (ra:list? ls))
  (let recr ((ls ls))
    (if (kons? ls)
        (+ (kons-size ls) (recr (kons-rest ls)))
        0)))

(define (ra:length<=? ls k)
  (let lp ((ls ls) (k k))
    (if (positive? k)
        (and (ra:pair? ls)
             (lp (ra:cdr ls) (- k 1)))
        #t)))

(define (make-foldl empty? first rest)
  (letrec ((f (lambda (cons empty ls)
                (if (empty? ls) 
                    empty
                    (f cons
                       (cons (first ls) empty) 
                       (rest ls))))))
    f))

(define (make-foldr empty? first rest)
  (letrec ((f (lambda (cons empty ls)
                (if (empty? ls) 
                    empty
                    (cons (first ls)
                          (f cons empty (rest ls)))))))
    f))

;; [X Y -> Y] Y [RaListof X] -> Y
(define ra:foldl/1 (make-foldl ra:null? ra:car ra:cdr))
(define ra:foldr/1 (make-foldr ra:null? ra:car ra:cdr))

;; [RaListof X] ... -> [RaListof X]
(define (ra:append . lss)
  (cond ((null? lss) ra:null)
        (else (let recr ((lss lss))
                (cond ((null? (cdr lss)) (car lss))
                      (else (ra:foldr/1 ra:cons
                                        (recr (cdr lss))
                                        (car lss))))))))

;; [RaListof X] -> [RaListof X]
(define (ra:reverse ls)
  (ra:foldl/1 ra:cons ra:null ls))

;; [RaListof X] Nat -> [RaListof X]
(define (ra:list-tail ls i)
  (let loop ((xs ls) (j i))
    (cond ((zero? j) xs)
          (else (loop (ra:cdr xs) (sub1 j))))))

;; [RaListof X] Nat -> X
;; Special-cased above to avoid logarathmic amount of cons'ing
;; and any multi-values overhead.  Operates in constant space.
(define (ra:list-ref ls i)
  ;(assert (< i (ra:length ls)))
  (let loop ((xs ls) (j i))
    (if (< j (kons-size xs))
        (tree-ref (kons-size xs) (kons-tree xs) j)
        (loop (kons-rest xs) (- j (kons-size xs))))))

;; [RaListof X] Nat X -> [RaListof X]
(define (ra:list-set ls i v)
  (let-values (((_ l*) (ra:list-ref/set ls i v))) l*))

;; [X ... -> y] [RaListof X] ... -> [RaListof Y]
;; Takes advantage of the fact that map produces a list of equal size.
(define ra:map
  (case-lambda 
    ((f ls)
     (let recr ((ls ls))
       (if (kons? ls)
           (make-kons (kons-size ls) 
                      (tree-map f (kons-tree ls)) 
                      (recr (kons-rest ls)))
           ra:null)))
    ((f . lss)
     ;(check-nary-loop-args 'ra:map (lambda (x) x) f lss)
     (let recr ((lss lss))
       (cond ((ra:null? (car lss)) ra:null)
             (else
              ;; IMPROVE ME: make one pass over lss.
              (make-kons (kons-size (car lss))
                         (tree-map/n f (map kons-tree lss))
                         (recr (map kons-rest lss)))))))))


;; [X ... -> Y] [RaListof X] ... -> unspecified
(define ra:for-each
  (case-lambda 
    ((f ls)
     (when (kons? ls)
       (tree-for-each f (kons-tree ls))
       (ra:for-each f (kons-rest ls))))
    ((f . lss)
     ;(check-nary-loop-args 'ra:map (lambda (x) x) f lss)
     (let recr ((lss lss))
       (when (ra:pair? (car lss))
         (tree-map/n f (map kons-tree lss))
         (recr (map kons-rest lss)))))))

;; [RaListof X] -> [Listof X]
(define (ra:random-access-list->linear-access-list x)
  (ra:foldr/1 cons '() x))

;; [Listof X] -> [RaListof X]
(define (ra:linear-access-list->random-access-list x)
  (fold-right ra:cons '() x))

;; This code based on code written by Abdulaziz Ghuloum
;; http://ikarus-scheme.org/pipermail/ikarus-users/2009-September/000595.html
(define get-cached
  (let ((h (make-hash-table eq?)))
    (lambda (x)
      (define (f x)
        (cond
         ((pair? x) (ra:cons (f (car x)) (f (cdr x))))
         ((vector? x) (vector-map f x))
         (else x)))
      (cond
       ((not (or (pair? x) (vector? x))) x)
       ((hash-table-ref/default h x #f))
       (else
        (let ((v (f x)))
          (hash-table-set! h x v)
          v))))))

(define-syntax ra:quote
  (syntax-rules ()
    ((ra:quote datum) (get-cached 'datum)))) 

(define-library (srfi 127)
  (import (scheme base) (srfi 1))
  (export
   ;; Constructors
   generator->lseq 
   ;; Predicates
   lseq?         lseq=?
   ;; Selectors
   lseq-car     lseq-cdr
   lseq-first   lseq-rest lseq-ref
   lseq-take    lseq-drop   
   ;; The whole lazy sequence
   lseq-realize lseq->generator
   lseq-length
   lseq-append  lseq-zip
   ;; Mapping and filtering
   lseq-map        lseq-for-each
   lseq-filter     lseq-remove
   ;; Searching
   lseq-find         lseq-find-tail 
   lseq-any          lseq-every
   lseq-index
   lseq-take-while   lseq-drop-while
   lseq-member       lseq-memq     lseq-memv)
  (include "127.scm"))

(define-library (srfi 229)
  (import (scheme base) (scheme case-lambda) (chibi ast) (only (chibi) opcode?))
  (export case-lambda/tag lambda/tag procedure/tag? procedure-tag)
  (begin
    (define procedure-tag-object (list 'procedure-tag))
    (define (procedure->tagged f tag)
      (make-procedure (procedure-flags f)
                      (procedure-arity f)
                      (procedure-code f)
                      (vector-append (or (procedure-vars f) '#())
                                     (vector tag procedure-tag-object))))
    (define-syntax lambda/tag
      (syntax-rules ()
        ((lambda/tag tag-expr formals . body)
         (procedure->tagged (lambda formals . body) tag-expr))))
    (define-syntax case-lambda/tag
      (syntax-rules ()
        ((case-lambda/tag tag-expr . clauses)
         (procedure->tagged (case-lambda . clauses) tag-expr))))
    (define (procedure/tag? f)
      (and (procedure? f)
           (not (opcode? f))
           (let ((vars (procedure-vars f)))
             (and (vector? vars)
                  (> (vector-length vars) 1)
                  (eq? procedure-tag-object
                       (vector-ref vars (- (vector-length vars) 1)))))))
    (define (procedure-tag f)
      (let ((vars (procedure-vars f)))
        (vector-ref vars (- (vector-length vars) 2))))))
(define-library (srfi 179)
  (import (scheme base)
          (scheme list)
          (scheme vector)
          (scheme sort)
          (srfi 160 base)
          (srfi 179 base)
          (chibi assert))
  (export
   ;; Miscellaneous Functions
   translation? permutation?
   ;; Intervals
   make-interval interval? interval-dimension interval-lower-bound
   interval-upper-bound interval-lower-bounds->list
   interval-upper-bounds->list interval-lower-bounds->vector
   interval-upper-bounds->vector interval= interval-volume
   interval-subset? interval-contains-multi-index? interval-projections
   interval-for-each interval-dilate interval-intersect
   interval-translate interval-permute interval-rotate
   interval-scale interval-cartesian-product
   ;; Storage Classes
   make-storage-class storage-class? storage-class-getter
   storage-class-setter storage-class-checker storage-class-maker
   storage-class-copier storage-class-length storage-class-default
   generic-storage-class s8-storage-class s16-storage-class
   s32-storage-class s64-storage-class u1-storage-class
   u8-storage-class u16-storage-class u32-storage-class
   u64-storage-class f8-storage-class f16-storage-class
   f32-storage-class f64-storage-class
   c64-storage-class c128-storage-class
   ;; Arrays
   make-array array? array-domain array-getter array-dimension
   mutable-array? array-setter specialized-array-default-safe?
   specialized-array-default-mutable? make-specialized-array
   specialized-array? array-storage-class array-indexer array-body
   array-safe? array-elements-in-order? specialized-array-share
   array-copy array-curry array-extract array-tile array-translate
   array-permute array-rotate array-reverse array-sample
   array-outer-product array-map array-for-each array-fold
   array-fold-right array-reduce array-any array-every
   array->list list->array array-assign! array-ref array-set!
   specialized-array-reshape
   )
  (include "179/transforms.scm"))
(define-library (srfi 219)
  (export define)
  (import (rename (scheme base) (define native-define)))
  (begin  (define-syntax define
            (syntax-rules ()
              ((define ((name . outer-args) . args) . body)
               (define (name . outer-args) (lambda args . body)))
              ((define head . body)
               (native-define head . body))))))

(define-library (srfi 99 records)
  (import (srfi 99 records procedural)
          (srfi 99 records inspection)
          (srfi 99 records syntactic))
  (export make-rtd rtd? rtd-constructor rtd-predicate rtd-accessor rtd-mutator
          record? record-rtd rtd-name rtd-parent
          rtd-field-names rtd-all-field-names rtd-field-mutable?
          define-record-type))
(define-library (srfi 99 test)
  (export run-tests)
  (import (chibi)
          (srfi 99)
          (only (chibi test) test-begin test-assert test test-end))
  (begin
    (define (run-tests)
      (define-record-type organism
        (make-organism name)
        organism?
        (name name-of set-name-of!))

      ;; kingdom
      (define-record-type (animal organism)
        (make-animal name food)
        animal?
        ;; all animals eat
        (food food-of set-food-of!))

      ;; phylum
      (define-record-type (chordate animal)
        (make-chordate name food)
        chordate?)

      ;; class
      (define-record-type (mammal chordate)
        (make-mammal name food num-nipples)
        mammal?
        ;; all mammals have nipples
        (num-nipples num-nipples-of set-num-nipples-of!))

      ;; order
      (define-record-type (carnivore mammal)
        (make-carnivore name food num-nipples)
        carnivore?)

      (define-record-type (rodent mammal)
        (make-rodent name food num-nipples)
        rodent?)

      ;; family
      (define-record-type (felidae carnivore)
        (make-felidae name food num-nipples)
        felidae?)

      (define-record-type (muridae rodent)
        (make-muridae name food num-nipples)
        muridae?)

      ;; genus
      (define-record-type (felis felidae)
        (make-felis name food num-nipples)
        felis?)

      (define-record-type (mus muridae)
        (make-mus name food num-nipples)
        mus?)

      ;; species
      (define-record-type (cat felis)
        (make-cat name food num-nipples breed color)
        cat?
        (breed breed-of set-breed-of!)
        (color color-of set-color-of!))

      (define-record-type (mouse mus)
        (make-mouse name food num-nipples)
        mouse?)

      (define mickey (make-mouse "Mickey" "cheese" 10))
      (define felix (make-cat "Felix" mickey 8 'mixed '(and black white)))

      (test-begin "srfi-99: records")

      (test-assert (organism? mickey))
      (test-assert (animal? mickey))
      (test-assert (chordate? mickey))
      (test-assert (mammal? mickey))
      (test-assert (rodent? mickey))
      (test-assert (muridae? mickey))
      (test-assert (mus? mickey))
      (test-assert (mouse? mickey))

      (test-assert (not (carnivore? mickey)))
      (test-assert (not (felidae? mickey)))
      (test-assert (not (felis? mickey)))
      (test-assert (not (cat? mickey)))

      (test-assert (organism? felix))
      (test-assert (animal? felix))
      (test-assert (chordate? felix))
      (test-assert (mammal? felix))
      (test-assert (carnivore? felix))
      (test-assert (felidae? felix))
      (test-assert (felis? felix))
      (test-assert (cat? felix))

      (test-assert (not (rodent? felix)))
      (test-assert (not (muridae? felix)))
      (test-assert (not (mus? felix)))
      (test-assert (not (mouse? felix)))

      (test "Mickey" (name-of mickey))
      (test "cheese" (food-of mickey))
      (test 10 (num-nipples-of mickey))

      (test "Felix" (name-of felix))
      (test mickey (food-of felix))
      (test 8 (num-nipples-of felix))
      (test 'mixed (breed-of felix))
      (test '(and black white) (color-of felix))

      ;;; See issue #494.
      (test-assert
          (let-syntax
              ((foo
                (syntax-rules ()
                  ((foo)
                   (let ()
                     (define-record-type record
                       #t
                       #t)
                     (record? (make-record)))))))
            (foo)))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

      (let ()
        (define-record-type person #t #t (name) (sex) (age))
        (define-record-type (employee person) #t #t (department) (salary))

        (define bob (make-employee "Bob" 'male 28 'hr 50000.0))
        (define alice (make-employee "Alice" 'female 32 'research 100000.0))

        (test-assert (person? bob))
        (test-assert (employee? bob))
        (test "Bob" (person-name bob))
        (test 'male (person-sex bob))
        (test 28 (person-age bob))
        (test 'hr (employee-department bob))
        (test 50000.0 (employee-salary bob))

        (test-assert (person? alice))
        (test-assert (employee? alice))
        (test "Alice" (person-name alice))
        (test 'female (person-sex alice))
        (test 32 (person-age alice))
        (test 'research (employee-department alice))
        (test 100000.0 (employee-salary alice))

        ;; After a trip to Thailand...
        (person-sex-set! bob 'female)
        (person-name-set! bob "Roberta")

        ;; Then Roberta quits!
        (employee-department-set! bob #f)
        (employee-salary-set! bob 0.0)

        (test "Roberta" (person-name bob))
        (test 'female (person-sex bob))
        (test 28 (person-age bob))
        (test #f (employee-department bob))
        (test 0.0 (employee-salary bob))

        ;; SRFI-99 forbids this, but we currently do it anyway.
        (test-assert (equal? (make-employee "Chuck" 'male 20 'janitorial 50000.0)
                             (make-employee "Chuck" 'male 20 'janitorial 50000.0)))

        (test-assert (record? alice))
        (test 'person (rtd-name person))
        (let* ((constructor (rtd-constructor person))
               (trent (constructor "Trent" 'male 44)))
          (test "Trent" (person-name trent))
          (test 'male (person-sex trent))
          (test 44 ((rtd-accessor person 'age) trent))
          ((rtd-mutator person 'age) trent 45)
          (test 45 (person-age trent)))

        (test-assert (rtd-field-mutable? employee 'department)))

      ;; We do not retain mutability information ATM.
      ;; (define-record-type foo
      ;;   (make-foo x)
      ;;   foo?
      ;;   (x foo-x))
      ;;
      ;; (test-assert (not (rtd-field-mutable? foo 'x)))

      (let ()
        (define point (make-rtd 'point #(x y)))
        (define make-point (rtd-constructor point #(x y)))
        (define point-x (rtd-accessor point 'x))
        (test 'point (rtd-name point))
        (test 3 (point-x (make-point 3 2))))

      ;; Name conflicts - make sure we rename

      (let ()
        (define-record-type example make-example #t example)
        (test-assert (example? (make-example 3)))
        (test 3 (example-example (make-example 3))))

      ;; record types definitions with #f passed as either the constructor or
      ;; predicate argument should not create the corresponding function

      (let ()
        (define-record-type abstract
          #f #t)

        (define-record-type (derived abstract)
          #t #f)

        (define instance (make-derived))

        (test #f (memq 'make-abstract (env-exports (current-environment))))
        (test-assert (abstract? instance))
        (test #f (memq 'derived? (env-exports (current-environment)))))

      (let ()
        (define-record-type container
          #t #t
          default-immutable
          (default-mutable)
          (named-immutable get-container-immutable)
          (named-mutable get-container-mutable set-container-mutable!))

        (define container-instance (make-container 1 2 3 4))

        (test 1 (container-default-immutable container-instance))
        (test 2 (container-default-mutable container-instance))
        (test 3 (get-container-immutable container-instance))
        (test 4 (get-container-mutable container-instance))

        (container-default-mutable-set! container-instance #t)
        (test #t (container-default-mutable container-instance))

        (set-container-mutable! container-instance #t)
        (test #t (get-container-mutable container-instance)))

      ;; test child constructor sets parent field
      (let ()
        (define-record-type <parent>
          #f
          parent?
          (field1 parent-field set-parent-field!))
        (define-record-type (<child> <parent>)
          (constructor field1 field2)
          child?
          (field2 child-field))
        (let ((record (constructor 'a 'b)))
          (test 'a (parent-field record))
          (test 'b (child-field record))
          (set-parent-field! record 'c)
          (test 'c (parent-field record))))

      (test-end))))

(define-syntax define-record-type
  (er-macro-transformer
   (lambda (expr rename compare)
     (let* ((id->string (lambda (x) (symbol->string (identifier->symbol x))))
            (name+parent (cadr expr))
            (name (if (pair? name+parent) (car name+parent) name+parent))
            (parent (and (pair? name+parent) (cadr name+parent)))
            (name-str (id->string name))
            (procs (cddr expr))
            (make (car procs))
            (make-name
             (if (eq? make #t)
                 (datum->syntax
                  name
                  (string->symbol (string-append "make-" name-str)))
                 (if (pair? make) (car make) make)))
            (pred (cadr procs))
            (pred-name
             (if (eq? pred #t)
                 (datum->syntax
                  name
                  (string->symbol (string-append name-str "?")))
                 pred))
            (fields (cddr procs))
            (field-names (map (lambda (x) (if (pair? x) (car x) x)) fields))
            (make-fields (if (pair? make) (cdr make) (and (not parent) field-names)))
            (_make (rename '%make))
            (_define (rename 'define))
            (_lambda (rename 'lambda))
            (_let (rename 'let))
            (_register (rename 'register-simple-type))
            (_slot-set! (rename 'slot-set!))
            (_vector->list (rename 'vector->list))
            (_type_slot_offset (rename 'type-slot-offset))
            (_rtd-all-field-names (rename 'rtd-all-field-names)))
       `(,(rename 'begin)
         ;; type
         (,_define ,name (,_register ,name-str ,parent ',field-names))
         ;; predicate
         ,@(if pred-name
               `((,_define ,pred-name
                   (,(rename 'make-type-predicate)
                    ,(id->string pred-name)
                    ,name)))
               '())
         ;; accessors
         ,@(map (lambda (f)
                  (let ((g (if (and (pair? f) (pair? (cdr f)))
                               (cadr f)
                               (string->symbol
                                 (string-append name-str
                                                "-"
                                                (id->string (if (pair? f) (car f) f)))))))
                    (and g
                         `(,_define ,g
                            (,(rename 'make-getter)
                             ,(id->string g)
                             ,name
                             (,_type_slot_offset ,name ',(if (pair? f) (car f) f)))))))
                fields)
         ,@(map (lambda (f)
                  (let ((s (and (pair? f)
                                (if (and (pair? (cdr f)) (pair? (cddr f)))
                                    (car (cddr f))
                                    (string->symbol
                                      (string-append name-str
                                                     "-"
                                                     (id->string (car f))
                                                     "-set!"))))))
                    (and s
                         `(,_define ,s
                            (,(rename 'make-setter)
                             ,(id->string s)
                             ,name
                             (,_type_slot_offset ,name ',(if (pair? f) (car f) f)))))))
                fields)
         ;; constructor
         ,@(if make-name
              (if make-fields
                (let ((fields (map (lambda (f) (cons (rename f) f)) make-fields)))
                  `((,_define ,make-name
                     ,(let lp ((ls fields) (sets '()))
                        (cond
                         ((null? ls)
                          `(,_let ((,_make (,(rename 'make-constructor)
                                            ,(id->string make-name)
                                            ,name)))
                             (,_lambda ,(map car fields)
                               (,_let ((res (,_make)))
                                 ,@sets
                                 res))))
                         (else
                          (let ((field (assq (cdar ls) fields)))
                            (cond
                             ((and (pair? field) (pair? (cdr field)) (pair? (cddr field)))
                              (lp (cdr ls)
                                  (cons (list (car (cddr field)) 'res (cdar ls)) sets)))
                             (else
                              (lp (cdr ls)
                                  (cons `(,_slot-set! ,name res (,_type_slot_offset ,name ',(cdar ls)) ,(caar ls)) sets)))))))))))
                `((,_define ,make-name
                   (,_let ((,_make (,(rename 'make-constructor)
                                    ,(id->string make-name)
                                    ,name)))
                     (,_lambda args
                       (,_let ((res (,_make)))
                         (let lp ((a args)
                                  (p (,_vector->list (,_rtd-all-field-names ,name))))
                           (cond
                            ((null? a)
                             (if (null? p)
                                 res
                                 (error ,(string-append "not enough arguments to " (id->string make-name) ": missing")
                                        p)))
                            ((null? p)
                             (error ,(string-append "too many arguments to " (id->string make-name))
                                    a))
                            (else
                             (,_slot-set! ,name res (,_type_slot_offset ,name (car p)) (car a))
                             (lp (cdr a) (cdr p)))))))))))
              '()))))))

(define-library (srfi 99 records procedural)
  (export make-rtd rtd? rtd-constructor rtd-predicate rtd-accessor rtd-mutator)
  (import (chibi) (chibi ast) (srfi 99 records inspection))
  (include "procedural.scm"))

(define (make-rtd name fields . o)
  (let ((parent (and (pair? o) (car o))))
    (register-simple-type (if (symbol? name) (symbol->string name) name)
                          parent
                          (vector->list fields))))

(define (rtd? x)
  (type? x))

(define (rtd-constructor rtd . o)
  (let ((fields (vector->list (if (pair? o) (car o) (rtd-all-field-names rtd))))
        (make (make-constructor (type-name rtd) rtd)))
    (lambda args
      (let ((res (make)))
        (let lp ((a args) (p fields))
          (cond
           ((null? a) (if (null? p) res (error "not enough args" p)))
           ((null? p) (error "too many args" a))
           (else
            (slot-set! rtd res (rtd-field-offset rtd (car p)) (car a))
            (lp (cdr a) (cdr p)))))))))

(define (rtd-predicate rtd)
  (make-type-predicate (type-name rtd) rtd))

(define (field-index-of ls field)
  (let lp ((i 0) (ls ls))
    (cond ((null? ls ) #f)
          ((if (pair? (car ls))
               (eq? field (car (cdar ls)))
               (eq? field (car ls)))
           i)
          (else (lp (+ i 1) (cdr ls))))))

(define (rtd-field-offset rtd field)
  (let ((p (type-parent rtd)))
    (or (and (type? p)
             (rtd-field-offset p field))
        (let ((i (field-index-of (type-slots rtd) field)))
          (and i
               (if (type? p)
                   (+ i (vector-length (rtd-all-field-names p)))
                   i))))))

(define (rtd-accessor rtd field)
  (make-getter (type-name rtd) rtd (rtd-field-offset rtd field)))

(define (rtd-mutator rtd field)
  (if (rtd-field-mutable? rtd field)
      (make-setter (type-name rtd) rtd (rtd-field-offset rtd field))
      (error "can't make mutator for immutable field" rtd field)))


(define-library (srfi 99 records inspection)
  (export record? record-rtd rtd-name rtd-parent
          rtd-field-names rtd-all-field-names rtd-field-mutable?)
  (import (chibi) (chibi ast))
  (include "inspection.scm"))

(define (record? x)
  (is-a? x Object))

(define (record-rtd x)
  (type-of x))

(define (rtd-name x) (string->symbol (type-name x)))

(define (rtd-parent x) (type-parent x))

(define (rtd-field-names x)
  (list->vector
   (map (lambda (x) (if (pair? x) (cadr x) x)) (type-slots x))))

(define (rtd-all-field-names x)
  (let lp ((x x) (res '()))
    (let ((res (append (vector->list (rtd-field-names x)) res)))
      (let ((p (type-parent x)))
        (if (type? p)
            (lp p res)
            (list->vector res))))))

(define (rtd-field-mutable? rtd x)
  (let lp ((ls (type-slots rtd)))
    (cond ((null? ls)
           (let ((p (type-parent rtd)))
             (if (type? p)
                 (rtd-field-mutable? p x)
                 (error "unknown field" rtd x))))
          ((eq? x (car ls)))
          ((and (pair? (car ls)) (eq? x (cadr (car ls))))
           (not (eq? 'immutable (caar ls))))
          (else (lp (cdr ls))))))

(define-library (srfi 99 records syntactic)
  (export define-record-type)
  (import (chibi) (srfi 99 records inspection))
  (include "syntactic.scm"))

(define-library (srfi 193)
  (export command-line command-name command-args script-file script-directory)
  (import (scheme base) (chibi filesystem) (chibi pathname)
          (only (chibi) command-line)
          (only (meta) raw-script-file))
  (begin

    (define (command-name)
      (let ((filename (car (command-line))))
        (and (not (= 0 (string-length filename)))
             (path-strip-extension (path-strip-directory filename)))))

    (define (command-args)
      (cdr (command-line)))

    (define (script-file)
      (and raw-script-file
           (path-normalize
            (path-resolve raw-script-file (current-directory)))))

    (define (script-directory)
      (let ((filename (script-file)))
        (and filename (string-append (path-directory filename) "/"))))))
(define-library (srfi 117)
  (import (scheme base) (srfi 1))
  (export
   make-list-queue list-queue list-queue-copy list-queue-unfold
   list-queue-unfold-right list-queue? list-queue-empty?
   list-queue-front list-queue-back list-queue-list list-queue-first-last
   list-queue-add-front! list-queue-add-back! list-queue-remove-front!
   list-queue-remove-back! list-queue-remove-all! list-queue-set-list!
   list-queue-append list-queue-append! list-queue-concatenate
   list-queue-map list-queue-map! list-queue-for-each)
  (include "117/queue.scm"))

(define eof-object (read-char (open-input-string "")))

(define (generator->lseq gen)
  (let ((val (gen)))
    (if (eof-object? val)
        '()
        (cons val gen))))

(define lseq-car car)
(define lseq-first car)

(define (lseq-cdr lseq)
  (if (procedure? (cdr lseq))
      (let ((val ((cdr lseq))))
        (cond
         ((eof-object? val)
          (set-cdr! lseq '())
          '())
         (else
          (let ((cell (cons val (cdr lseq))))
            (set-cdr! lseq cell)
            cell))))
      (cdr lseq)))

(define lseq-rest lseq-cdr)

(define (lseq? x)
  (if (pair? x)
      (or (procedure? (cdr x))
          (lseq? (cdr x)))
      (null? x)))

(define (lseq=? eq lseq1 lseq2)
  (let lp ((ls1 lseq1) (ls2 lseq2))
    (cond
     ((null? ls1) (null? ls2))
     ((null? ls2) #f)
     ((eq (lseq-car ls1) (lseq-car ls2))
      (lp (lseq-cdr ls1) (lseq-cdr ls2)))
     (else #f))))

(define (lseq-drop lseq k)
  (if (positive? k)
      (lseq-drop (lseq-cdr lseq) (- k 1))
      lseq))

(define (lseq-drop-while pred lseq)
  (if (and (pair? lseq) (pred (lseq-car lseq)))
      (lseq-drop-while pred (lseq-cdr lseq))
      lseq))

(define (lseq-take lseq k)
  (generator->lseq
   (lambda ()
     (if (positive? k)
         (let ((val (lseq-car lseq)))
           (set! lseq (lseq-cdr lseq))
           (set! k (- k 1))
           val)
         eof-object))))

(define (lseq-take-while pred lseq)
  (generator->lseq
   (lambda ()
     (if (and (pair? lseq) (pred (lseq-car lseq)))
         (let ((val (lseq-car lseq)))
           (set! lseq (lseq-cdr lseq))
           val)
         eof-object))))

(define (lseq-ref lseq k)
  (lseq-first (lseq-drop lseq k)))

(define (lseq-realize lseq)
  (let lp ((lseq lseq) (ls '()))
    (if (null? lseq)
        (reverse ls)
        (lp (lseq-cdr lseq) (cons (lseq-car lseq) ls)))))

(define (lseq->generator lseq)
  (lambda ()
    (if (null? lseq)
        eof-object
        (let ((val (lseq-car lseq)))
          (set! lseq (lseq-cdr lseq))
          val))))

(define (lseq-length lseq)
  (let lp ((lseq lseq) (len 0))
    (if (null? lseq) len (lp (lseq-cdr lseq) (+ len 1)))))

(define (lseq-append . lseqs)
  (if (every null? lseqs)
      '()
      (let ((lseq1 (car lseqs))
            (ls (cdr lseqs)))
        (define (gen)
          (cond
           ((pair? lseq1)
            (let ((val (lseq-car lseq1)))
              (set! lseq1 (cdr lseq1))
              val))
           ((pair? ls)
            (set! lseq1 (car ls))
            (set! ls (cdr ls))
            (gen))
           (else
            eof-object)))
        (generator->lseq gen))))

(define (lseq-zip . lseqs)
  (generator->lseq
   (lambda ()
     (if (any null? lseqs)
         eof-object
         (let ((val (map lseq-car lseqs)))
           (set! lseqs (map lseq-cdr lseqs))
           val)))))

(define (lseq-map proc lseq . o)
  (if (or (null? lseq) (any null? o))
      '()
      (let ((gen (lseq->generator lseq)))
        (generator->lseq
         (if (null? o)
             (lambda ()
               (let ((val (gen)))
                 (if (eof-object? val)
                     val
                     (proc val))))
             (let ((gens (map lseq->generator o)))
               (lambda ()
                 (let ((val (gen))
                       (vals (map (lambda (f) (f)) gens)))
                   (if (or (eof-object? val)
                           (any eof-object? vals))
                       eof-object
                       (apply proc val vals))))))))))

(define (lseq-for-each proc lseq . o)
  (let lp ((lseq (apply lseq-map proc lseq o)))
    (when (pair? lseq)
      (lseq-car lseq)
      (lp (lseq-cdr lseq)))))

(define (lseq-filter pred lseq)
  (let ((gen (lseq->generator lseq)))
    (define (filt)
      (let ((val (gen)))
        (if (or (eof-object? val) (pred val))
            val
            (filt))))
    (generator->lseq filt)))

(define (lseq-remove pred lseq)
  (lseq-filter (lambda (x) (not (pred x))) lseq))

(define (lseq-find-tail pred lseq)
  (and (pair? lseq)
       (if (pred (lseq-car lseq))
           lseq
           (lseq-find-tail pred (lseq-cdr lseq)))))

(define (lseq-find pred lseq)
  (cond ((lseq-find-tail pred lseq) => lseq-car) (else #f)))

(define (lseq-any pred lseq . o)
  (if (null? o)
      (let any ((lseq lseq))
        (and (pair? lseq)
             (or (pred (lseq-car lseq))
                 (any (lseq-cdr lseq)))))
      (let any ((lseqs (cons lseq o)))
        (and (every pair? lseqs)
             (or (apply pred (map lseq-car lseqs))
                 (any (map lseq-cdr lseqs)))))))

(define (lseq-every pred lseq . o)
  (if (null? o)
      (let every ((lseq lseq) (last #t))
        (if (null? lseq)
            last
            (let ((val (pred (lseq-car lseq))))
              (and val (every (lseq-cdr lseq) val)))))
      (let every ((lseqs (cons lseq o)) (last #t))
        (if (any null? lseqs)
            last
            (let ((val (apply pred (map lseq-car lseqs))))
              (and val (every (map lseq-cdr lseqs) val)))))))

(define (lseq-index pred lseq . o)
  (let ((i -1))
    (and (apply lseq-any (lambda args (set! i (+ i 1)) (apply pred args)) lseq o)
         i)))

(define (lseq-member elt lseq . o)
  (let* ((eq (if (pair? o) (car o) equal?))
         (res (lseq-drop-while (lambda (x) (not (eq x elt))) lseq)))
    (and (pair? res) res)))

(define (lseq-memq elt lseq) (lseq-member elt lseq eq?))
(define (lseq-memv elt lseq) (lseq-member elt lseq eqv?))

(define-record-type Comparator
  (%make-comparator% type-test equality ordering hash)
  comparator?
  (type-test comparator-type-test-predicate)
  (equality comparator-equality-predicate)
  (ordering comparator-ordering-predicate)
  (hash comparator-hash-function))

(define (make-comparator type-test equality ordering hash)
  (%make-comparator%
    type-test
    equality
    ordering
    (if (or (opcode? hash)
            (not (procedure? hash))
            (procedure-variadic? hash)
            (> (procedure-arity hash) 1))
        hash
        (lambda (x . o) (hash x)))))

(define-syntax hash-bound
  (er-macro-transformer
   (lambda (expr rename compare)
     (if (fixnum? (- (expt 2 62) 1))
         (- (expt 2 62) 1)
         (- (expt 2 30) 1)))))

(define-syntax hash-salt
  (er-macro-transformer
   (let ((salt (or (string->number
                    (or (get-environment-variable "CHIBI_HASH_SALT") ""))
                   (random-integer (hash-bound)))))
     (lambda (expr rename compare)
       salt))))

(define-syntax comparator-if<=>
  (syntax-rules ()
    ((comparator-if<=> comparator obj1 obj2 less equal greater)
     (let ((cmp comparator)
           (o1 obj1)
           (o2 obj2))
       (cond
        (((comparator-equality-predicate cmp) o1 o2) equal)
        (((comparator-ordering-predicate cmp) o1 o2) less)
        (else greater))))
    ((comparator-if<=> obj1 obj2 less equal greater)
     (comparator-if<=> (make-default-comparator) obj1 obj2 less equal greater))))

(define (comparator-ordered? comparator)
  (and (comparator-ordering-predicate comparator) #t))

(define (comparator-hashable? comparator)
  (and (comparator-hash-function comparator) #t))

(define (comparator-test-type comparator obj)
  ((comparator-type-test-predicate comparator) obj))

(define (comparator-check-type comparator obj)
  (or (comparator-test-type comparator obj)
      (error "not an object of the comparator type" comparator obj)))

(define (comparator-hash comparator obj)
  ((comparator-hash-function comparator) obj))

(define default-comparators
  (make-parameter '()))

(define (comparator-register-default! comparator)
  (default-comparators (cons comparator (default-comparators))))

(define (make-pair-comparator car-comparator cdr-comparator)
  (make-comparator
   (lambda (x)
     (and (pair? x)
          ((comparator-type-test-predicate car-comparator) (car x))
          ((comparator-type-test-predicate cdr-comparator) (cdr x))))
   (lambda (x y)
     (and ((comparator-equality-predicate car-comparator) (car x) (car y))
          ((comparator-equality-predicate cdr-comparator) (cdr x) (cdr y))))
   (lambda (x y)
     (if ((comparator-equality-predicate car-comparator) (car x) (car y))
         ((comparator-ordering-predicate cdr-comparator) (cdr x) (cdr y))
         ((comparator-ordering-predicate car-comparator) (car x) (car y))))
   (lambda (x)
     (bitwise-xor ((comparator-hash-function car-comparator) (car x))
                  ((comparator-hash-function cdr-comparator) (cdr x))))))

(define (make-list-comparator element-comparator type-test empty? head tail)
  (make-comparator
   (lambda (x)
     (and (type-test x)
          (let lp ((ls x))
            (or (empty? ls)
                (and ((comparator-type-test-predicate element-comparator) (head ls))
                     (lp (tail ls)))))))
   (lambda (x y)
     (let lp ((ls1 x) (ls2 y))
       (cond
        ((empty? ls1) (empty? ls2))
        ((empty? ls2) #f)
        (else
         (and ((comparator-equality-predicate element-comparator) (head ls1) (head ls2))
              (lp (tail ls1) (tail ls2)))))))
   (lambda (x y)
     (let lp ((ls1 x) (ls2 y))
       (cond
        ((empty? ls1) (not (empty? ls2)))
        ((empty? ls2) #f)
        (else
         (let ((a (head ls1)) (b (head ls2)))
           (if ((comparator-equality-predicate element-comparator) a b)
               (lp (tail ls1) (tail ls2))
               ((comparator-ordering-predicate element-comparator) a b)))))))
   (lambda (x)
     (let lp ((ls x) (acc 0))
       (if (empty? ls)
           acc
           (lp (tail ls)
               (bitwise-xor ((comparator-hash-function element-comparator) (head ls))
                            acc)))))
   ))

(define (make-vector-comparator element-comparator type-test length ref)
  (make-comparator
   (lambda (x)
     (and (type-test x)
          (let ((len (length x)))
            (let lp ((i 0))
              (or (>= i len)
                  (and ((comparator-type-test-predicate element-comparator) (ref x i))
                       (lp (+ i 1))))))))
   (lambda (x y)
     (let ((lenx (length x)) (leny (length y)))
       (and
        (= lenx leny)
        (let lp ((i 0))
          (or (>= i lenx)
              (let ((a (ref x i)) (b (ref y i)))
                (and ((comparator-equality-predicate element-comparator) a b)
                     (lp (+ i 1)))))))))
   (lambda (x y)
     (let ((lenx (length x)) (leny (length y)))
       (cond
        ((< lenx leny) #t)
        ((> lenx leny) #f)
        (else
         (let lp ((i 0))
           (and (< i lenx)
                (let ((a (ref x i)) (b (ref y i)))
                  (if ((comparator-equality-predicate element-comparator) a b)
                      (lp (+ i 1))
                      ((comparator-ordering-predicate element-comparator) a b)))))))))
   (lambda (x)
     (let ((len (length x)))
       (let lp ((i 0) (acc 0))
         (if (>= i len)
             acc
             (lp (+ i 1)
                 (bitwise-xor ((comparator-hash-function element-comparator) (ref x i))
                              acc))))))
   ))

(define (make-eq-comparator)
  (make-comparator (lambda (x) #t) eq? object-cmp hash-by-identity))

(define (make-eqv-comparator)
  (make-comparator (lambda (x) #t) eqv? object-cmp hash))

(define (make-equal-comparator)
  (make-comparator (lambda (x) #t) equal? object-cmp hash))

(define boolean-hash hash)

(define char-hash hash)

(define (char-ci-hash ch)
  (hash (char-foldcase ch)))

(define symbol-hash hash)

(define number-hash hash)

(define (default-hash x . o)
  (if (string? x) (string-hash x) (hash x)))

(define default-comparator
  (make-comparator
   (lambda (x) #t)
   (lambda (x y)
     (let lp ((ls (default-comparators)))
       (cond ((null? ls)
              (if (number? x)
                  (and (number? y) (= x y))
                  (equal? x y)))
             ((and (comparator-test-type (car ls) x)
                   (comparator-test-type (car ls) y))
              ((comparator-equality-predicate (car ls)) x y))
             (else
              (lp (cdr ls))))))
   (lambda (x y)
     (let lp ((ls (default-comparators)))
       (cond ((null? ls)
              (negative? (object-cmp x y)))
             ((and (comparator-test-type (car ls) x)
                   (comparator-test-type (car ls) y))
              ((comparator-ordering-predicate (car ls)) x y))
             (else
              (lp (cdr ls))))))
   default-hash))

(define (make-default-comparator)
  default-comparator)

(define (=? comparator o1 o2 . o)
  (let ((eq (comparator-equality-predicate comparator)))
    (and (eq o1 o2)
         (let lp ((ls o))
           (or (null? ls)
               (and (eq o1 (car ls))
                    (lp (cdr ls))))))))

(define (<? comparator o1 o2 . o)
  (let ((less (comparator-ordering-predicate comparator)))
    (and (less o1 o2)
         (let lp ((prev o2) (ls o))
           (or (null? ls)
               (and (less prev (car ls))
                    (lp (car ls) (cdr ls))))))))

(define (<=? comparator o1 o2 . o)
  (let ((less (comparator-ordering-predicate comparator)))
    (and (not (less o2 o1))
         (let lp ((prev o2) (ls o))
           (or (null? ls)
               (and (not (less (car ls) prev))
                    (lp (car ls) (cdr ls))))))))

(define (>? comparator . o)
  (apply <? comparator (reverse o)))

(define (>=? comparator . o)
  (apply <=? comparator (reverse o)))
(define (comparator-max-in-list comp list)
  (let ((< (comparator-ordering-predicate comp)))
    (let loop ((max (car list)) (list (cdr list)))
      (if (null? list)
        max
        (if (< max (car list))
          (loop (car list) (cdr list))
          (loop max (cdr list)))))))

(define (comparator-min-in-list comp list)
  (let ((< (comparator-ordering-predicate comp)))
    (let loop ((min (car list)) (list (cdr list)))
      (if (null? list)
        min
        (if (< min (car list))
          (loop min (cdr list))
          (loop (car list) (cdr list)))))))

(define (comparator-max comp . args)
  (comparator-max-in-list comp args))

(define (comparator-min comp . args)
  (comparator-min-in-list comp args))

#;
(define default-comparator   ;Defined in comparators.scm
  (make-default-comparator))

(define boolean-comparator
  (make-comparator
    boolean?
    boolean=?
    (lambda (x y) (and (not x) y))
    boolean-hash))

(define real-comparator
  (make-comparator
    real?
    =
    <
    number-hash))

(define char-comparator
  (make-comparator
    char?
    char=?
    char<?
    (lambda (c) (number-hash (char->integer c)))))

(define char-ci-comparator
  (make-comparator
    char?
    char-ci=?
    char-ci<?
    (lambda (c) (number-hash (char->integer (char-downcase c))))))

(define string-comparator
  (make-comparator
    string?
    string=?
    string<?
    string-hash))

(define string-ci-comparator
  (make-comparator
    string?
    string-ci=?
    string-ci<?
    string-ci-hash))

(define pair-comparator
  (make-pair-comparator
    default-comparator
    default-comparator))

(define list-comparator
  (make-list-comparator
    default-comparator
    list?
    null?
    car
    cdr))

(define vector-comparator
  (make-vector-comparator
    default-comparator
    vector?
    vector-length
    vector-ref))

(define eq-comparator (make-eq-comparator))
(define eqv-comparator (make-eqv-comparator))
(define equal-comparator (make-equal-comparator))
(define-library (srfi 128 test)
  (export run-tests)
  (import (scheme base) (srfi 128) (chibi test))
  (begin
    (define degenerate-comparator (make-comparator (lambda (x) #t) equal? #f #f))
    (define bool-pair-comparator
      (make-pair-comparator boolean-comparator boolean-comparator))
    (define num-list-comparator
      (make-list-comparator real-comparator list? null? car cdr))
    (define num-vector-comparator
      (make-vector-comparator real-comparator vector? vector-length vector-ref))
    (define (vector-cdr vec)
      (let* ((len (vector-length vec))
             (result (make-vector (- len 1))))
        (let loop ((n 1))
          (cond
           ((= n len) result)
           (else (vector-set! result (- n 1) (vector-ref vec n))
                 (loop (+ n 1)))))))
    (define vector-qua-list-comparator
      (make-list-comparator
       real-comparator
       vector?
       (lambda (vec) (= 0 (vector-length vec)))
       (lambda (vec) (vector-ref vec 0))
       vector-cdr))
    (define list-qua-vector-comparator
      (make-vector-comparator default-comparator list? length list-ref))
    (define symbol-comparator
      (make-comparator
       symbol?
       eq?
       (lambda (a b) (string<? (symbol->string a) (symbol->string b)))
       symbol-hash))
    (define (run-tests)
      (test-group "srfi-128: comparators"
        (test '#(2 3 4) (vector-cdr '#(1 2 3 4)))
        (test '#() (vector-cdr '#(1)))

        (test-group "comparators/predicates"
          (test-assert (comparator? real-comparator))
          (test-assert (not (comparator? =)))
          (test-assert (comparator-ordered? real-comparator))
          (test-assert (comparator-hashable? real-comparator))
          (test-assert (not (comparator-ordered? degenerate-comparator)))
          (test-assert (not (comparator-hashable? degenerate-comparator)))
          )                              ; end comparators/predicates

        (test-group "comparators/constructors"
          (test-assert (=? boolean-comparator #t #t))
          (test-assert (not (=? boolean-comparator #t #f)))
          (test-assert (<? boolean-comparator #f #t))
          (test-assert (not (<? boolean-comparator #t #t)))
          (test-assert (not (<? boolean-comparator #t #f)))

          (test-assert (comparator-test-type bool-pair-comparator '(#t . #f)))
          (test-assert (not (comparator-test-type bool-pair-comparator 32)))
          (test-assert (not (comparator-test-type bool-pair-comparator '(32 . #f))))
          (test-assert (not (comparator-test-type bool-pair-comparator '(#t . 32))))
          (test-assert (not (comparator-test-type bool-pair-comparator '(32 . 34))))
          (test-assert (=? bool-pair-comparator '(#t . #t) '(#t . #t)))
          (test-assert (not (=? bool-pair-comparator '(#t . #t) '(#f . #t))))
          (test-assert (not (=? bool-pair-comparator '(#t . #t) '(#t . #f))))
          (test-assert (<? bool-pair-comparator '(#f . #t) '(#t . #t)))
          (test-assert (<? bool-pair-comparator '(#t . #f) '(#t . #t)))
          (test-assert (not (<? bool-pair-comparator '(#t . #t) '(#t . #t))))
          (test-assert (not (<? bool-pair-comparator '(#t . #t) '(#f . #t))))
          (test-assert (not (<? bool-pair-comparator '(#f . #t) '(#f . #f))))

          (test-assert (comparator-test-type num-vector-comparator '#(1 2 3)))
          (test-assert (comparator-test-type num-vector-comparator '#()))
          (test-assert (not (comparator-test-type num-vector-comparator 1)))
          (test-assert (not (comparator-test-type num-vector-comparator '#(a 2 3))))
          (test-assert (not (comparator-test-type num-vector-comparator '#(1 b 3))))
          (test-assert (not (comparator-test-type num-vector-comparator '#(1 2 c))))
          (test-assert (=? num-vector-comparator '#(1 2 3) '#(1 2 3)))
          (test-assert (not (=? num-vector-comparator '#(1 2 3) '#(4 5 6))))
          (test-assert (not (=? num-vector-comparator '#(1 2 3) '#(1 5 6))))
          (test-assert (not (=? num-vector-comparator '#(1 2 3) '#(1 2 6))))
          (test-assert (<? num-vector-comparator '#(1 2) '#(1 2 3)))
          (test-assert (<? num-vector-comparator '#(1 2 3) '#(2 3 4)))
          (test-assert (<? num-vector-comparator '#(1 2 3) '#(1 3 4)))
          (test-assert (<? num-vector-comparator '#(1 2 3) '#(1 2 4)))
          (test-assert (<? num-vector-comparator '#(3 4) '#(1 2 3)))
          (test-assert (not (<? num-vector-comparator '#(1 2 3) '#(1 2 3))))
          (test-assert (not (<? num-vector-comparator '#(1 2 3) '#(1 2))))
          (test-assert (not (<? num-vector-comparator '#(1 2 3) '#(0 2 3))))
          (test-assert (not (<? num-vector-comparator '#(1 2 3) '#(1 1 3))))

          (test-assert (not (<? vector-qua-list-comparator '#(3 4) '#(1 2 3))))
          (test-assert (<? list-qua-vector-comparator '(3 4) '(1 2 3)))

          (let ((bool-pair (cons #t #f))
                (bool-pair-2 (cons #t #f))
                (reverse-bool-pair (cons #f #t)))
            (test-assert (=? eq-comparator #t #t))
            (test-assert (not (=? eq-comparator #f #t)))
            (test-assert (=? eqv-comparator bool-pair bool-pair))
            (test-assert (not (=? eqv-comparator bool-pair bool-pair-2)))
            (test-assert (=? equal-comparator bool-pair bool-pair-2))
            (test-assert (not (=? equal-comparator bool-pair reverse-bool-pair))))
          )                              ; end comparators/constructors

        (test-group "comparators/hash"
          (test-assert (exact-integer? (boolean-hash #f)))
          (test-assert (not (negative? (boolean-hash #t))))
          (test-assert (exact-integer? (char-hash #\a)))
          (test-assert (not (negative? (char-hash #\b))))
          (test-assert (exact-integer? (char-ci-hash #\a)))
          (test-assert (not (negative? (char-ci-hash #\b))))
          (test-assert (= (char-ci-hash #\a) (char-ci-hash #\A)))
          (test-assert (exact-integer? (string-hash "f")))
          (test-assert (not (negative? (string-hash "g"))))
          (test-assert (exact-integer? (string-ci-hash "f")))
          (test-assert (not (negative? (string-ci-hash "g"))))
          (test-assert (= (string-ci-hash "f") (string-ci-hash "F")))
          (test-assert (exact-integer? (symbol-hash 'f)))
          (test-assert (not (negative? (symbol-hash 't))))
          (test-assert (exact-integer? (number-hash 3)))
          (test-assert (not (negative? (number-hash 3))))
          (test-assert (exact-integer? (number-hash -3)))
          (test-assert (not (negative? (number-hash -3))))
          (test-assert (exact-integer? (number-hash 3.0)))
          (test-assert (not (negative? (number-hash 3.0))))
          (test-assert (exact-integer? (number-hash 3.47)))
          (test-assert (not (negative? (number-hash 3.47))))
          (test-assert (exact-integer? (default-hash '())))
          (test-assert (not (negative? (default-hash '()))))
          (test-assert (exact-integer? (default-hash '(a "b" #\c #(dee) 2.718))))
          (test-assert (not (negative? (default-hash '(a "b" #\c #(dee) 2.718)))))
          (test-assert (exact-integer? (default-hash '#u8())))
          (test-assert (not (negative? (default-hash '#u8()))))
          (test-assert (exact-integer? (default-hash '#u8(8 6 3))))
          (test-assert (not (negative? (default-hash '#u8(8 6 3)))))
          (test-assert (exact-integer? (default-hash '#())))
          (test-assert (not (negative? (default-hash '#()))))
          (test-assert (exact-integer? (default-hash '#(a "b" #\c #(dee) 2.718))))
          (test-assert (not (negative? (default-hash '#(a "b" #\c #(dee) 2.718)))))

          )                              ; end comparators/hash

        (test-group "comparators/default"
          (test-assert (<? default-comparator '() '(a)))
          (test-assert (not (=? default-comparator '() '(a))))
          (test-assert (=? default-comparator #t #t))
          (test-assert (not (=? default-comparator #t #f)))
          (test-assert (<? default-comparator #f #t))
          (test-assert (not (<? default-comparator #t #t)))
          (test-assert (=? default-comparator #\a #\a))
          (test-assert (<? default-comparator #\a #\b))
          (test-assert (=? default-comparator 1 1))
          (test-assert (=? default-comparator 1 1.0))

          (test-assert (comparator-test-type default-comparator '()))
          (test-assert (comparator-test-type default-comparator #t))
          (test-assert (comparator-test-type default-comparator #\t))
          (test-assert (comparator-test-type default-comparator '(a)))
          (test-assert (comparator-test-type default-comparator 'a))
          (test-assert (comparator-test-type default-comparator (make-bytevector 10)))
          (test-assert (comparator-test-type default-comparator 10))
          (test-assert (comparator-test-type default-comparator 10.0))
          (test-assert (comparator-test-type default-comparator "10.0"))
          (test-assert (comparator-test-type default-comparator '#(10)))

          (test-assert (=? default-comparator '(#t . #t) '(#t . #t)))
          (test-assert (not (=? default-comparator '(#t . #t) '(#f . #t))))
          (test-assert (not (=? default-comparator '(#t . #t) '(#t . #f))))
          (test-assert (<? default-comparator '(#f . #t) '(#t . #t)))
          (test-assert (<? default-comparator '(#t . #f) '(#t . #t)))
          (test-assert (not (<? default-comparator '(#t . #t) '(#t . #t))))
          (test-assert (not (<? default-comparator '(#t . #t) '(#f . #t))))
          (test-assert (not (<? default-comparator '#(#f #t) '#(#f #f))))

          (test-assert (=? default-comparator '#(#t #t) '#(#t #t)))
          (test-assert (not (=? default-comparator '#(#t #t) '#(#f #t))))
          (test-assert (not (=? default-comparator '#(#t #t) '#(#t #f))))
          (test-assert (<? default-comparator '#(#f #t) '#(#t #t)))
          (test-assert (<? default-comparator '#(#t #f) '#(#t #t)))
          (test-assert (not (<? default-comparator '#(#t #t) '#(#t #t))))
          (test-assert (not (<? default-comparator '#(#t #t) '#(#f #t))))
          (test-assert (not (<? default-comparator '#(#f #t) '#(#f #f))))

          (test-assert (= (comparator-hash default-comparator #t) (boolean-hash #t)))
          (test-assert (= (comparator-hash default-comparator #\t) (char-hash #\t)))
          (test-assert (= (comparator-hash default-comparator "t") (string-hash "t")))
          (test-assert (= (comparator-hash default-comparator 't) (symbol-hash 't)))
          (test-assert (= (comparator-hash default-comparator 10) (number-hash 10)))
          (test-assert (= (comparator-hash default-comparator 10.0) (number-hash 10.0)))

          (comparator-register-default!
           (make-comparator procedure? (lambda (a b) #t) (lambda (a b) #f) (lambda (obj) 200)))
          (test-assert (=? default-comparator (lambda () #t) (lambda () #f)))
          (test-assert (not (<? default-comparator (lambda () #t) (lambda () #f))))
          ;;(test 200 (comparator-hash default-comparator (lambda () #t)))

          )                              ; end comparators/default

        ;; SRFI 128 does not actually require a comparator's four procedures
        ;; to be eq? to the procedures originally passed to make-comparator.
        ;; For interoperability/interchangeability between the comparators
        ;; of SRFI 114 and SRFI 128, some of the procedures passed to
        ;; make-comparator may need to be wrapped inside another lambda
        ;; expression before they're returned by the corresponding accessor.
        ;;
        ;; So this next group of tests is incorrect, hence commented out
        ;; and replaced by a slightly less naive group of tests.

        #;
        (test-group "comparators/accessors"
        (define ttp (lambda (x) #t))
        (define eqp (lambda (x y) #t))
        (define orp (lambda (x y) #t))
        (define hf (lambda (x) 0))
        (define comp (make-comparator ttp eqp orp hf))
        (test ttp (comparator-type-test-predicate comp))
        (test eqp (comparator-equality-predicate comp))
        (test orp (comparator-ordering-predicate comp))
        (test hf (comparator-hash-function comp))
        )                                ; end comparators/accessors

        (test-group "comparators/accessors"
          (define x1 0)
          (define x2 0)
          (define x3 0)
          (define x4 0)
          (define ttp (lambda (x) (set! x1 111) #t))
          (define eqp (lambda (x y) (set! x2 222) #t))
          (define orp (lambda (x y) (set! x3 333) #t))
          (define hf (lambda (x) (set! x4 444) 0))
          (define comp (make-comparator ttp eqp orp hf))
          (test #t (and ((comparator-type-test-predicate comp) x1)   (= x1 111)))
          (test #t (and ((comparator-equality-predicate comp) x1 x2) (= x2 222)))
          (test #t (and ((comparator-ordering-predicate comp) x1 x3) (= x3 333)))
          (test #t (and (zero? ((comparator-hash-function comp) x1)) (= x4 444)))
          )                              ; end comparators/accessors

        (test-group "comparators/invokers"
          (test-assert (comparator-test-type real-comparator 3))
          (test-assert (comparator-test-type real-comparator 3.0))
          (test-assert (not (comparator-test-type real-comparator "3.0")))
          (test-assert (comparator-check-type boolean-comparator #t))
          (test-error (comparator-check-type boolean-comparator 't))
          )                              ; end comparators/invokers

        (test-group "comparators/comparison"
          (test-assert (=? real-comparator 2 2.0 2))
          (test-assert (<? real-comparator 2 3.0 4))
          (test-assert (>? real-comparator 4.0 3.0 2))
          (test-assert (<=? real-comparator 2.0 2 3.0))
          (test-assert (>=? real-comparator 3 3.0 2))
          (test-assert (not (=? real-comparator 1 2 3)))
          (test-assert (not (<? real-comparator 3 1 2)))
          (test-assert (not (>? real-comparator 1 2 3)))
          (test-assert (not (<=? real-comparator 4 3 3)))
          (test-assert (not (>=? real-comparator 3 4 4.0)))

          )                              ; end comparators/comparison

        (test-group "comparators/syntax"
          (test 'less (comparator-if<=> real-comparator 1 2 'less 'equal 'greater))
          (test 'equal (comparator-if<=> real-comparator 1 1 'less 'equal 'greater))
          (test 'greater (comparator-if<=> real-comparator 2 1 'less 'equal 'greater))
          (test 'less (comparator-if<=> "1" "2" 'less 'equal 'greater))
          (test 'equal (comparator-if<=> "1" "1" 'less 'equal 'greater))
          (test 'greater (comparator-if<=> "2" "1" 'less 'equal 'greater))

          )                              ; end comparators/syntax

        (test-group "comparators/bound-salt"
          (test-assert (exact-integer? (hash-bound)))
          (test-assert (exact-integer? (hash-salt)))
          (test-assert (< (hash-salt) (hash-bound)))
          #;  (test (hash-salt) (fake-salt-hash #t))  ; no such thing as fake-salt-hash
          )                              ; end comparators/bound-salt


        (test-group "comparators/min-max"
          (test 5 (comparator-max real-comparator 1 5 3 2 -2))
          (test -2 (comparator-min real-comparator 1 5 3 2 -2))
          (test 5 (comparator-max-in-list real-comparator '(1 5 3 2 -2)))
          (test -2 (comparator-min-in-list real-comparator '(1 5 3 2 -2)))
          )                             ; end comparators/min-max

        (test-group "comparators/variables"
          ;; Most of the variables have been tested above.
          (test-assert (=? char-comparator #\C #\C))
          (test-assert (=? char-ci-comparator #\c #\C))
          (test-assert (=? string-comparator "ABC" "ABC"))
          (test-assert (=? string-ci-comparator "abc" "ABC"))
          (test-assert (=? eq-comparator 32 32))
          (test-assert (=? eqv-comparator 32 32))
          (test-assert (=? equal-comparator "ABC" "ABC"))
          )                             ; end comparators/variables

        ))))                             ; end comparators
(define-library (srfi 227)
  (export opt-lambda
          (rename opt-lambda* opt*-lambda)
          let-optionals
          let-optionals*)
  (import (chibi optional)))
;; bitwise.scm -- high-level bitwise functions
;; Copyright (c) 2009-2017 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

(define (bitwise-not i) (- -1 i))

(define (bitwise-complement f) (lambda args (bitwise-not (apply f args))))

(define (make-nary proc2 default)
  (lambda args
    (if (null? args)
        default
        (let lp ((i (car args)) (ls (cdr args)))
          (if (null? ls)
              i
              (lp (proc2 i (car ls)) (cdr ls)))))))

(define bitwise-and  (make-nary bit-and  -1))
(define bitwise-ior  (make-nary bit-ior   0))
(define bitwise-xor  (make-nary bit-xor   0))

(define bitwise-eqv  (bitwise-complement (make-nary bit-xor -1)))
(define bitwise-nand (bitwise-complement (make-nary bit-and  0)))
(define bitwise-nor  (bitwise-complement (make-nary bit-ior -1)))

(define (bitwise-andc1 i j) (bit-and (bitwise-not i) j))
(define (bitwise-andc2 i j) (bit-and i (bitwise-not j)))
(define (bitwise-orc1 i j)  (bit-ior (bitwise-not i) j))
(define (bitwise-orc2 i j)  (bit-ior i (bitwise-not j)))

(define (any-bit-set? test-bits i)
  (not (zero? (bitwise-and test-bits i))))
(define (every-bit-set? test-bits i)
  (= test-bits (bitwise-and test-bits i)))

(define (first-set-bit i)
  (if (zero? i)
      -1
      (- (integer-length (- i (bit-and i (- i 1)))) 1)))

(define (mask len)
  (- (arithmetic-shift 1 len) 1))

(define (range start end)
  (arithmetic-shift (mask (- end start)) start))

(define (bitwise-if mask m n)
  (bit-ior (bit-and mask m)
           (bit-and (bitwise-not mask) n)))

(define (bit-field n start end)
  (bit-and (arithmetic-shift n (- start)) (mask (- end start))))

(define (bit-field-any? n start end)
  (not (zero? (bit-and (arithmetic-shift n (- start))
                       (mask (- end start))))))

(define (bit-field-every? n start end)
  (let ((lo (mask (- end start))))
    (= (bit-and lo (arithmetic-shift n (- start)))
       lo)))

(define (copy-bit index i boolean)
  (bit-field-replace i (if boolean 1 0) index (+ index 1)))

(define (bit-swap i1 i2 i)
  (let ((b1 (bit-set? i1 i))
        (b2 (bit-set? i2 i)))
    (copy-bit i2 (copy-bit i1 i b2) b1)))

(define (bit-field-clear n start end)
  (bit-field-replace n 0 start end))

(define (bit-field-set n start end)
  (bit-ior n (range start end)))

(define (bit-field-replace dst src start end)
  (bit-field-replace-same dst (arithmetic-shift src start) start end))

(define (bit-field-replace-same dst src start end)
  (bitwise-if (range start end) src dst))

(define (bit-field-rotate n count start end)
  (let* ((width (- end start))
         (count (modulo count width))
         (mask (bitwise-not (arithmetic-shift -1 width)))
         (n^ (bitwise-and mask (arithmetic-shift n (- start)))))
    (bit-ior (arithmetic-shift
              (bit-ior (bit-and mask (arithmetic-shift n^ count))
                       (arithmetic-shift n^ (- count width)))
              start)
             (bit-and (bitwise-not (arithmetic-shift mask start)) n))))

(define (bit-reverse n len)
  (let lp ((n n) (i 1) (res 0))
    (if (> i len)
        res
        (lp (arithmetic-shift n -1)
            (+ i 1)
            (bit-ior (arithmetic-shift res 1)
                     (bit-and n 1))))))

(define (bit-field-reverse i start end)
  (bitwise-if (range start end)
              (arithmetic-shift (bit-reverse (bit-field i start end)
                                             (- end start))
                                start)
              i))

(define (vector->bits vec)
  (let ((len (vector-length vec)))
    (let lp ((i 0) (exp 1) (res 0))
      (cond
       ((= i len) res)
       ((vector-ref vec i) (lp (+ i 1) (* exp 2) (+ res exp)))
       (else (lp (+ i 1) (* exp 2) res))))))

(define (bits->vector n . o)
  (let* ((len (if (pair? o) (car o) (integer-length n)))
         (res (make-vector len #f)))
    (let lp ((n n) (i 0))
      (cond
       ((>= i len)
        res)
       (else
        (if (odd? n)
            (vector-set! res i #t))
        (lp (arithmetic-shift n -1) (+ i 1)))))))

(define (list->bits ls)
  (vector->bits (list->vector ls)))

(define (bits->list n . o)
  (vector->list (apply bits->vector n o)))

(define (bits . o) (list->bits o))

(define (bitwise-fold kons knil i)
  (let lp ((i i) (acc knil))
    (if (zero? i)
        acc
        (lp (arithmetic-shift i -1) (kons (odd? i) acc)))))

(define (bitwise-for-each proc i)
  (bitwise-fold (lambda (b acc) (proc b)) #f i))

(define (bitwise-unfold stop? mapper successor seed)
  (let lp ((state seed) (exp 1) (i 0))
    (if (stop? state)
        i
        (lp (successor state)
            (* exp 2)
            (if (mapper state) (+ i exp) i)))))

(define make-bitwise-generator
  (let ((eof (read-char (open-input-string ""))))
    (lambda (i)
      (lambda ()
        (let ((res (odd? i)))
          (set! i (arithmetic-shift i -1))
          res)))))
(define-library (srfi 151 test)
  (export run-tests)
  (import (scheme base) (srfi 151) (chibi test))
  (begin
    (define (run-tests)
      (test-begin "srfi-151: bitwise operations")

      (test 0 (integer-length #b0))
      (test 1 (integer-length #b1))
      (test 2 (integer-length #b10))
      (test 3 (integer-length #b100))
      (test 4 (integer-length #b1000))
      (test 5 (integer-length #b10000))
      (test 6 (integer-length #b110000))
      (test 0 (bitwise-and #b0 #b1))
      (test 1 (bitwise-and #b1 #b1))
      (test 0 (bitwise-and #b1 #b10))
      (test #b10 (bitwise-and #b11 #b10))
      (test #b101 (bitwise-and #b101 #b111))
      (test #b111 (bitwise-and -1 #b111))
      (test #b110 (bitwise-and -2 #b111))
      (test 3769478 (bitwise-and -4290775858 1694076839))
      (test 1680869008 (bitwise-and -193073517 1689392892))
      (test -4294967295 (bitwise-ior 1 (- -1 #xffffffff)))
      (test -18446744073709551615 (bitwise-ior 1 (- -1 #xffffffffffffffff)))
      (test -4294967126 (bitwise-xor #b10101010 (- -1 #xffffffff)))
      (test -18446744073709551446 (bitwise-xor #b10101010 (- -1 #xffffffffffffffff)))
      (test -2600468497 (bitwise-ior 1694076839 -4290775858))
      (test -184549633 (bitwise-ior -193073517 1689392892))
      (test -167776621 (bitwise-ior -193073517 1689392892000000000000))
      (test -18446744073709551616
          (bitwise-ior -18446744073709551616
                       340282366920938463463374607431768211456))
      (test 340282366920938463481821351505477763072
          (bitwise-ior 18446744073709551616
                       340282366920938463463374607431768211456))
      (test -7090566332214939648
          (bitwise-ior -193073517000000000000 1689392892000000000000))
      (test -351599414102633810746018680881203758247936
          (bitwise-ior -1930735170000000000001689392892000000000000
                       1689392892000000000000193073517000000000000))
      (test -2604237975 (bitwise-xor 1694076839 -4290775858))
      (test -1865418641 (bitwise-xor -193073517 1689392892))
      (test -1689392892000142479725
          (bitwise-xor -193073517 1689392892000000000000))
      (test -1510500507664429879296
          (bitwise-xor -193073517000000000000 1689392892000000000000))
      (test -1510500507664429879296
          (bitwise-xor -193073517000000000000 1689392892000000000000))
      (test -461856550205267621490541042387407516495872
          (bitwise-xor -1930735170000000000001689392892000000000000
                       1689392892000000000000193073517000000000000))
      (test -461856550205267621490541042387407516495872
          (bitwise-xor 1689392892000000000000193073517000000000000
                       -1930735170000000000001689392892000000000000))
      (test 461856550205267621490541042387407516495872
          (bitwise-xor -1930735170000000000001689392892000000000000
                       -1689392892000000000000193073517000000000000))
      (test 3769478 (bitwise-and 1694076839 -4290775858))
      (test 1680869008 (bitwise-and -193073517 1689392892))
      (test 340282366920938463463374607431768211456
          (bitwise-and 340282366920938463463374607431768211456
                       (bitwise-not 18446744073709551616)))

      (test 1 (arithmetic-shift 1 0))
      (test 2 (arithmetic-shift 1 1))
      (test 4 (arithmetic-shift 1 2))
      (test 8 (arithmetic-shift 1 3))
      (test 16 (arithmetic-shift 1 4))
      (test (expt 2 31) (arithmetic-shift 1 31))
      (test (expt 2 32) (arithmetic-shift 1 32))
      (test (expt 2 33) (arithmetic-shift 1 33))
      (test (expt 2 63) (arithmetic-shift 1 63))
      (test (expt 2 64) (arithmetic-shift 1 64))
      (test (expt 2 65) (arithmetic-shift 1 65))
      (test (expt 2 127) (arithmetic-shift 1 127))
      (test (expt 2 128) (arithmetic-shift 1 128))
      (test (expt 2 129) (arithmetic-shift 1 129))
      (test 3028397001194014464 (arithmetic-shift 11829675785914119 8))

      (test -1 (arithmetic-shift -1 0))
      (test -2 (arithmetic-shift -1 1))
      (test -4 (arithmetic-shift -1 2))
      (test -8 (arithmetic-shift -1 3))
      (test -16 (arithmetic-shift -1 4))
      (test (- (expt 2 31)) (arithmetic-shift -1 31))
      (test (- (expt 2 32)) (arithmetic-shift -1 32))
      (test (- (expt 2 33)) (arithmetic-shift -1 33))
      (test (- (expt 2 63)) (arithmetic-shift -1 63))
      (test (- (expt 2 64)) (arithmetic-shift -1 64))
      (test (- (expt 2 65)) (arithmetic-shift -1 65))
      (test (- (expt 2 127)) (arithmetic-shift -1 127))
      (test (- (expt 2 128)) (arithmetic-shift -1 128))
      (test (- (expt 2 129)) (arithmetic-shift -1 129))

      (test 0 (arithmetic-shift 1 -63))
      (test 0 (arithmetic-shift 1 -64))
      (test 0 (arithmetic-shift 1 -65))

      (test #x1000000000000000100000000000000000000000000000000
          (arithmetic-shift #x100000000000000010000000000000000 64))
      (test #x8e73b0f7da0e6452c810f32b809079e5
          (arithmetic-shift #x8e73b0f7da0e6452c810f32b809079e562f8ead2522c6b7b -64))
      (test -79 (arithmetic-shift -100000000000000000000000000000000 -100))
      (test 78 (arithmetic-shift 100000000000000000000000000000000 -100))
      (test -200000000000000000000000000000000
          (arithmetic-shift -100000000000000000000000000000000 1))

      (test-not (bit-set? 64 1))
      (test-assert (bit-set? 64 #x10000000000000000))
      (test-assert (bit-set? 1000000 -1))
      (test-assert (bit-set? 1000 -1))

      (test #b1010 (bit-field #b1101101010 0 4))
      (test #b101101 (bit-field #b1101101010 3 9))
      (test #b10110 (bit-field #b1101101010 4 9))
      (test #b110110 (bit-field #b1101101010 4 10))

      (test 0 (bitwise-if 1 2 1))
      (test 3 (bitwise-if 1 1 2))
      (test 9 (bitwise-if 3 1 8))
      (test 0 (bitwise-if 3 8 1))
      (test #b00110011 (bitwise-if #b00111100 #b11110000 #b00001111))

      (test #b1 (copy-bit 0 0 #t))
      (test #b100 (copy-bit 2 0 #t))
      (test #b1011 (copy-bit 2 #b1111 #f))

      (test #b1110 (bit-swap 0 1 #b1101))
      (test #b1011 (bit-swap 1 2 #b1101))
      (test #b1011 (bit-swap 2 1 #b1101))
      (test #b10000000101 (bit-swap 3 10 #b1101))

      (test '(#t #t #t #f #t #f #t) (bits->list #b1010111))
      (test '(#t #t #t #f #t) (bits->list #b1010111 5))
      (test '(#t #t #t #f #t #f #t #f #f) (bits->list #b1010111 9))
      (test '#(#t #t #t #f #t #f #t) (bits->vector #b1010111))
      (test '#(#t #t #t #f #t #f #t #f #f) (bits->vector #b1010111 9))

      (test #b1010111 (list->bits '(#t #t #t #f #t #f #t)))
      (test #b1010111 (list->bits '(#t #t #t #f #t #f #t #f #f)))
      (test #b1010111 (vector->bits '#(#t #t #t #f #t #f #t)))
      (test #b1010111 (vector->bits '#(#t #t #t #f #t #f #t #f #f)))
      (test #b1010111 (bits #t #t #t #f #t #f #t))
      (test #b1010111 (bits #t #t #t #f #t #f #t #f #f))

      (test 0 (first-set-bit 1))
      (test 1 (first-set-bit 2))
      (test -1 (first-set-bit 0))
      (test 3 (first-set-bit 40))
      (test 2 (first-set-bit -28))
      (test 99 (first-set-bit (expt  2 99)))
      (test 99 (first-set-bit (expt -2 99)))

      (test '(#t #f #t #f #t #t #t) (bitwise-fold cons '() #b1010111))

      (test 5
          (let ((count 0))
            (bitwise-for-each (lambda (b) (if b (set! count (+ count 1))))
                              #b1010111)
            count))

      (test #b101010101
          (bitwise-unfold (lambda (i) (= i 10)) even? (lambda (i) (+ i 1)) 0))

      (test #b110  (bit-field-rotate #b110 1 1 2))
      (test #b1010 (bit-field-rotate #b110 1 2 4))
      (test #b1011 (bit-field-rotate #b0111 -1 1 4))
      (test #b0  (bit-field-rotate #b0 128 0 256))
      (test #b1  (bit-field-rotate #b1 128 1 256))
      (test #x100000000000000000000000000000000 
          (bit-field-rotate #x100000000000000000000000000000000 128 0 64))
      (test #x100000000000000000000000000000008 
          (bit-field-rotate #x100000000000000000000000000000001 3 0 64))
      (test #x100000000000000002000000000000000 
          (bit-field-rotate #x100000000000000000000000000000001 -3 0 64))
      (test #b110 (bit-field-rotate #b110 0 0 10))
      (test #b110 (bit-field-rotate #b110 0 0 256))
      (test 1 (bit-field-rotate #x100000000000000000000000000000000 1 0 129))

      (test 6 (bit-field-reverse 6 1 3))
      (test 12 (bit-field-reverse 6 1 4))
      (test #x80000000 (bit-field-reverse 1 0 32))
      (test #x40000000 (bit-field-reverse 1 0 31))
      (test #x20000000 (bit-field-reverse 1 0 30))
      (test (bitwise-ior (arithmetic-shift -1 32) #xFBFFFFFF) 
        (bit-field-reverse -2 0 27))
      (test (bitwise-ior (arithmetic-shift -1 32) #xF7FFFFFF) 
        (bit-field-reverse -2 0 28))
      (test (bitwise-ior (arithmetic-shift -1 32) #xEFFFFFFF) 
        (bit-field-reverse -2 0 29))
      (test (bitwise-ior (arithmetic-shift -1 32) #xDFFFFFFF) 
        (bit-field-reverse -2 0 30))
      (test (bitwise-ior (arithmetic-shift -1 32) #xBFFFFFFF) 
        (bit-field-reverse -2 0 31))
      (test (bitwise-ior (arithmetic-shift -1 32) #x7FFFFFFF) 
        (bit-field-reverse -2 0 32))
      (test 5 (bit-field-reverse #x140000000000000000000000000000000 0 129))

      (test-assert (bit-field-any? #b1001001 1 6))
      (test-not    (bit-field-any? #b1000001 1 6))
      (test-assert (bit-field-every? 45 2 4))
      (test-assert (bit-field-every? 45 0 1))
      (test-assert (bit-field-every? #b1011110 1 5))
      (test-not    (bit-field-every? #b1011010 1 5))

      (test-end))))
(define-library (srfi 132)
  (import (scheme base) (srfi 95))
  (export
   list-sorted? vector-sorted?
   list-sort list-stable-sort
   list-sort! list-stable-sort!
   vector-sort vector-stable-sort
   vector-sort! vector-stable-sort!
   list-merge list-merge!
   vector-merge vector-merge!
   list-delete-neighbor-dups
   list-delete-neighbor-dups!
   vector-delete-neighbor-dups
   vector-delete-neighbor-dups!
   vector-find-median
   vector-find-median!
   vector-select!
   vector-separate!)
  (include "132/sort.scm"))
;;;; srfi-38.scm - reading and writing shared structures
;;
;; This code was written by Alex Shinn in 2009 and placed in the
;; Public Domain.  All warranties are disclaimed.

(define (raise-typed-error type)
  (lambda (msg . args) (raise (make-exception type msg args #f #f))))
(define read-error (raise-typed-error 'read))
(define read-incomplete-error (raise-typed-error 'read-incomplete))

(define (extract-shared-objects x cyclic-only?)
  (let ((seen (make-hash-table eq?)))
    ;; find shared references
    (let find ((x x))
      (let ((type (type-of x)))
        (cond ;; only interested in pairs, vectors and records
         ((or (pair? x) (vector? x) (and type (type-printer type)))
          ;; increment the count
          (hash-table-update!/default seen x (lambda (n) (+ n 1)) 0)
          ;; walk if this is the first time
          (cond
           ((> (hash-table-ref seen x) 1))
           ((pair? x)
            (find (car x))
            (find (cdr x)))
           ((vector? x)
            (do ((i 0 (+ i 1)))
                ((= i (vector-length x)))
              (find (vector-ref x i))))
           (else
            (let ((num-slots (type-num-slots type)))
              (let lp ((i 0))
                (cond ((< i num-slots)
                       (find (slot-ref type x i))
                       (lp (+ i 1))))))))
          ;; delete if this shouldn't count as a shared reference
          (if (and cyclic-only?
                   (<= (hash-table-ref/default seen x 0) 1))
              (hash-table-delete! seen x))))))
    ;; extract shared references
    (let ((res (make-hash-table eq?)))
      (hash-table-walk
       seen
       (lambda (k v) (if (> v 1) (hash-table-set! res k #t))))
      res)))

(define (write-with-shared-structure x . o)
  (let ((out (if (pair? o) (car o) (current-output-port)))
        (shared
         (extract-shared-objects x (and (pair? o) (pair? (cdr o)) (cadr o))))
        (count 0))
    (define (check-shared x prefix cont)
      (let ((index (hash-table-ref/default shared x #f)))
        (cond ((integer? index)
               (display prefix out)
               (display "#" out)
               (write index out)
               (display "#" out))
              (else
               (cond (index
                      (display prefix out)
                      (display "#" out)
                      (write count out)
                      (display "=" out)
                      (hash-table-set! shared x count)
                      (set! count (+ count 1))))
               (cont x index)))))
    (let wr ((x x))
      (define (wr-one x shared?)
        (cond
         ((pair? x)
          (display "(" out)
          (wr (car x))
          (let lp ((ls (cdr x)))
            (check-shared
             ls
             " . "
             (lambda (ls shared?)
               (cond ((null? ls))
                     ((pair? ls)
                      (cond
                       (shared?
                        (display "(" out)
                        (wr (car ls))
                        (check-shared
                         (cdr ls)
                         " . "
                         (lambda (ls shared?) (lp ls)))
                        (display ")" out))
                       (else
                        (display " " out)
                        (wr (car ls))
                        (lp (cdr ls)))))
                     (shared?  ;; shared dotted tail
                      (wr-one ls #f))
                     (else
                      (display " . " out)
                      (wr ls))))))
          (display ")" out))
         ((vector? x)
          (display "#(" out)
          (let ((len (vector-length x)))
            (cond ((> len 0)
                   (wr (vector-ref x 0))
                   (do ((i 1 (+ i 1)))
                       ((= i len))
                     (display " " out)
                     (wr (vector-ref x i))))))
          (display ")" out))
         ((let ((type (type-of x)))
            (and (type? type) (type-printer type)))
          => (lambda (printer) (printer x wr out)))
         ((null? x) (display "()" out))
         ((char? x) (display "#\\" out) (write-char x out))
         ((symbol? x) (write x out))
         ((number? x) (display (number->string x) out))
         ((eq? x #t) (display "#t" out))
         ((eq? x #f) (display "#f" out))
         (else
          ;; (display "#<unknown>" out)
          (write x out))))
      (check-shared x "" wr-one))))

(define write/ss write-with-shared-structure)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define (skip-line in)
  (let ((c (read-char in)))
    (if (not (or (eof-object? c) (eqv? c #\newline)))
        (skip-line in))))

(define (skip-horizontal-whitespace in)
  (case (peek-char in)
    ((#\space #\tab)
     (read-char in)
     (skip-horizontal-whitespace in))))

(define (skip-whitespace in)
  (case (peek-char in)
    ((#\space #\tab #\newline #\return)
     (read-char in)
     (skip-whitespace in))))

(define (skip-whitespace-and-line-comments in)
  (case (peek-char in)
    ((#\space #\tab #\newline #\return)
     (read-char in)
     (skip-whitespace-and-line-comments in))
    ((#\;)
     (skip-line in)
     (skip-whitespace-and-line-comments in))))

(define (skip-comment in depth)
  (case (read-char in)
    ((#\#) (skip-comment in (if (eqv? #\| (peek-char in)) (+ depth 1) depth)))
    ((#\|) (if (eqv? #\# (peek-char in))
               (if (zero? depth) (read-char in) (skip-comment in (- depth 1)))
               (skip-comment in depth)))
    (else (if (eof-object? (peek-char in))
              (read-incomplete-error "unterminated #| comment")
              (skip-comment in depth)))))

;; returns #f if a trailing # was consumed
(define (skip-whitespace-and-sexp-comments in read)
  (skip-whitespace-and-line-comments in)
  (cond
   ((eqv? #\# (peek-char in))
    (read-char in)
    (cond ((eqv? #\; (peek-char in))
           (read-char in)
           (read in)
           (skip-whitespace-and-sexp-comments in read))
          ((eqv? #\| (peek-char in))
           (skip-comment in 0)
           (skip-whitespace-and-sexp-comments in read))
          (else #f)))
   (else
    #t)))

(define delimiters
  '(#\; #\" #\| #\( #\) #\{ #\} #\space #\tab #\newline #\return))

(define named-chars
  `(("newline" . #\newline)
    ("return" . #\return)
    ("space" . #\space)
    ("tab" . #\tab)
    ("null" . ,(integer->char 0))
    ("alarm" . ,(integer->char 7))
    ("backspace" . ,(integer->char 8))
    ("escape" . ,(integer->char 27))
    ("delete" . ,(integer->char 127))))

(define U1 1)
(define S8 2)
(define U8 3)
(define S16 4)
(define U16 5)
(define S32 6)
(define U32 7)
(define S64 8)
(define U64 9)
(define F32 10)
(define F64 11)
(define C64 12)
(define C128 13)

(define (resolve-uniform-type c prec)
  (or
   (case prec
     ((1) (and (eqv? c #\u) U1))
     ((8) (case c ((#\u) U8) ((#\s) S8) (else #f)))
     ((16) (case c ((#\u) U16) ((#\s) S16) (else #f)))
     ((32) (case c ((#\u) U32) ((#\s) S32) ((#\f) F32) (else #f)))
     ((64) (case c ((#\u) U64) ((#\s) S64) ((#\f) F64) ((#\c) C64) (else #f)))
     ((128) (case c ((#\c) C128) (else #f)))
     (else #f))
   (error "invalid uniform type" c prec)))

(define read-with-shared-structure
  (let ((read read))
    (lambda o
      (let ((in (if (pair? o) (car o) (current-input-port)))
            (shared '()))
        (define (read-label res)
          (let ((c (peek-char in)))
            (cond
             ((and (not (eof-object? c))
                   (or (char-numeric? c)
                       (memv (char-downcase c)
                             '(#\- #\+ #\a #\b #\c #\d #\e #\f #\i))))
              (read-label (cons (read-char in) res)))
             ((and (eqv? c #\/) (not (memv #\/ res)))
              (read-label (cons (read-char in) res)))
             ((and (eqv? c #\@) (not (memv #\@ res)))
              (read-label (cons (read-char in) res)))
             (else
              (list->string (reverse res))))))
        (define (read-numeric-hashes res)
          (if (eqv? #\# (peek-char in))
              (let* ((res (cons (read-char in) res))
                     (c (read-char in)))
                (if (memv c '(#\b #\d #\o #\x #\e #\i))
                    (read-numeric-hashes (cons c res))
                    (error "invalid numeric hash escape #" c)))
              res))
        (define (read-number base)
          (let* ((str (read-label (read-numeric-hashes '())))
                 (n (string->number str base))
                 (c (peek-char in)))
            (if (or (not n) (not (or (eof-object? c) (memv c delimiters))))
                (read-error "read error: invalid number syntax" str c)
                n)))
        (define (read-float-tail in) ;; called only after a leading period
          (let lp ((res 0.0) (k 0.1))
            (let ((c (peek-char in)))
              (cond
               ((char-numeric? c)
                (lp (+ res (* (- (char->integer (read-char in))
                                 (char->integer #\0))
                              k))
                    (* k 0.1)))
               ((or (eof-object? c) (memv c delimiters)) res)
               (else (read-error "invalid char in float syntax" c))))))
        (define (read-name c in)
          (let lp ((ls (if (char? c) (list c) '())))
            (let ((c (peek-char in)))
              (cond ((or (eof-object? c) (memv c delimiters))
                     (list->string (reverse ls)))
                    (else (lp (cons (read-char in) ls)))))))
        (define (read-named-char c in)
          (let ((name (read-name c in)))
            (cond ((assoc name named-chars string-ci=?) => cdr)
                  ((and (or (eqv? c #\x) (eqv? c #\X))
                        (string->number (substring name 1 (string-length name))
                                        16))
                   => integer->char)
                  (else (read-error "unknown char name" name)))))
        (define (read-type-id in)
          (let ((ch (peek-char in)))
            (cond
             ((eqv? ch #\#)
              (read-char in)
              (let ((id (read in)))
                (cond ((eq? id 't) #t)
                      ((integer? id) id)
                      (else (read-error "invalid type identifier" id)))))
             ((eqv? ch #\")
              (read in))
             (else
              (read-error "invalid type identifier syntax" ch)))))
        (define (read-escape-sequence)
          (let ((ch (read-char in)))
            (cond
             ((eof-object? ch) (read-incomplete-error "incomplete escape"))
             (else
              (case ch
                ((#\a) #\alarm) ((#\b) #\backspace)
                ((#\n) #\newline) ((#\r) #\return)
                ((#\t) #\tab)
                ((#\newline) (skip-horizontal-whitespace in) #f)
                ((#\space #\tab)
                 (skip-line in) (skip-horizontal-whitespace in) #f)
                ((#\x #\X)
                 (let* ((n (read-number 16))
                        (ch2 (read-char in)))
                   (if (not (and n (eqv? ch2 #\;)))
                       (read-error "invalid string escape" n ch2)
                       (integer->char n))))
                (else ch))))))
        (define (read-delimited terminal)
          (let ((out (open-output-string)))
            (let lp ()
              (let ((ch (read-char in)))
                (cond
                 ((eof-object? ch) (read-incomplete-error "incomplete string"))
                 ((eqv? ch terminal) (get-output-string out))
                 ((eqv? ch #\\)
                  (let ((ch2 (read-escape-sequence)))
                    (if ch2 (write-char ch2 out))
                    (lp)))
                 (else (write-char ch out) (lp)))))))
        (define (read-object)
          (let ((name (read-name #f in)))
            (skip-whitespace-and-line-comments in)
            (let* ((id (read-type-id in))
                   (type (lookup-type name id)))
              (let lp ((ls '()))
                (skip-whitespace-and-line-comments in)
                (cond
                 ((eof-object? (peek-char in))
                  (read-error "missing closing }"))
                 ((eqv? #\} (peek-char in))
                  (read-char in)
                  (let ((res ((make-constructor #f type))))
                    (let lp ((ls (reverse ls)) ( i 0))
                      (cond
                       ((null? ls)
                        res)
                       (else
                        (slot-set! type res i (car ls))
                        (lp (cdr ls) (+ i 1)))))))
                 (else (lp (cons (read-one in) ls))))))))
        (define (read-hash in)
          (if (eof-object? (peek-char in))
              (read-error "read error: incomplete # found at end of input"))
          (case (char-downcase (peek-char in))
            ((#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9)
             (let* ((str (read-label '()))
                    (n (string->number str)))
               (if (not n)
                   (read-error "read error: invalid reference" str))
               (cond
                ((eqv? #\= (peek-char in))
                 (if (assv n shared)
                     (read-error "read error: duplicate label" str))
                 (read-char in)
                 (let* ((cell (list #f))
                        (thunk (lambda () (car cell))))
                   (set! shared (cons (cons n thunk) shared))
                   (let ((x (read-one in)))
                     (if (hole? x)
                         (read-error "read error: self label reference" n))
                     (set-car! cell x)
                     x)))
                ((eqv? #\# (peek-char in))
                 (read-char in)
                 (cond
                  ((assv n shared) => cdr)
                  (else (read-error "read error: unknown reference" n))))
                (else
                 (read-error "read error: expected # after #n"
                             (read-char in))))))
            ((#\;)
             (read-char in)
             (read-one in) ;; discard
             (read-one in))
            ((#\|)
             (skip-comment in 0)
             (read-one in))
            ((#\!)
             (read-char in)
             (let ((c (peek-char in)))
               (cond
                ((or (char-whitespace? c) (eqv? c #\/))
                 (skip-line in)
                 (read-one in))
                (else
                 (let ((name (read-name #f in)))
                   (cond
                    ((string-ci=? name "fold-case")
                     (set-port-fold-case! in #t))
                    ((string-ci=? name "no-fold-case")
                     (set-port-fold-case! in #f))
                    (else            ;; assume a #!/bin/bash line
                     (read-error "unknown #! symbol" name)))
                   (read-one in))))))
            ((#\() (list->vector (read-one in)))
            ((#\') (read-char in) (list 'syntax (read-one in)))
            ((#\`) (read-char in) (list 'quasisyntax (read-one in)))
            ((#\,) (read-char in)
             (let ((sym (if (eqv? #\@ (peek-char in))
                            (begin (read-char in) 'unsyntax-splicing)
                            'unsyntax)))
               (list sym (read-one in))))
            ((#\t)
             (let ((s (read-name #f in)))
               (or (string-ci=? s "t") (string-ci=? s "true")
                   (read-error "bad # syntax" s))))
            ((#\f)
             (let ((s (read-name #f in)))
               (cond
                ((or (string-ci=? s "f") (string-ci=? s "false"))
                 #f)
                ((member s '("f32" "F32"))
                 (list->uvector F32 (read in)))
                ((member s '("f64" "F64"))
                 (list->uvector F64 (read in)))
                (else
                 (read-error "bad # syntax" s)))))
            ((#\d) (read-char in) (read in))
            ((#\x) (read-char in) (read-number 16))
            ((#\o) (read-char in) (read-number 8))
            ((#\b) (read-char in) (read-number 2))
            ((#\i) (read-char in) (exact->inexact (read-one in)))
            ((#\e)
             (let ((s (read-name #\# in)))
               (or (string->number s)
                   (read-one (open-input-string (substring s 2))))))
            ((#\u #\v #\s #\c)
             (if (char-ci=? #\v (peek-char in))
                 (read-char in))
             (let* ((c (char-downcase (read-char in)))
                    (prec (read-number 10))
                    (etype (resolve-uniform-type c prec))
                    (ls (read-one in)))
               (if (not (list? ls))
                   (read-error "invalid uniform vector syntax" ls))
               (list->uvector etype ls)))
            ((#\\)
             (read-char in)
             (let* ((c1 (read-char in))
                    (c2 (peek-char in)))
               (if (or (eof-object? c2) (memv c2 delimiters))
                   c1
                   (read-named-char c1 in))))
            (else
             (read-error "unknown # syntax: " (peek-char in)))))
        (define (read-one in)
          (cond
           ((not (skip-whitespace-and-sexp-comments in read-one))
            (read-hash in))
           (else
            (case (peek-char in)
              ((#\#)
               (read-char in)
               (read-hash in))
              ((#\()
               (read-char in)
               (let lp ((res '()))
                 (cond
                  ((not (skip-whitespace-and-sexp-comments in read-one))
                   (lp (cons (read-hash in) res)))
                  (else
                   (let ((c (peek-char in)))
                     (case c
                       ((#\))
                        (read-char in)
                        (reverse res))
                       ((#\.)
                        (read-char in)
                        (cond
                         ((memv (peek-char in) delimiters)
                          (let ((tail (read-one in)))
                            (cond
                             ((null? res)
                              (read-error "dot before any elements in list"))
                             ((and (skip-whitespace-and-sexp-comments
                                    in read-one)
                                   (eqv? #\) (peek-char in)))
                              (read-char in)
                              (append (reverse res) tail))
                             ((eof-object? (peek-char in))
                              (read-incomplete-error
                               "unterminated dotted list"))
                             (else
                              (read-error "expected end of list after dot")))))
                         ((char-numeric? (peek-char in))
                          (lp (cons (read-float-tail in) res)))
                         (else
                          (lp (cons (string->symbol (read-name #\. in)) res)))))
                       (else
                        (if (eof-object? c)
                            (read-incomplete-error "unterminated list")
                            (lp (cons (read-one in) res))))))))))
              ((#\{)
               (read-char in)
               (read-object))
              ((#\")
               (read-char in)
               (read-delimited #\"))
              ((#\|)
               (read-char in)
               (string->symbol (read-delimited #\|)))
              ((#\') (read-char in) (list 'quote (read-one in)))
              ((#\`) (read-char in) (list 'quasiquote (read-one in)))
              ((#\,)
               (read-char in)
               (let ((sym (if (eqv? #\@ (peek-char in))
                              (begin (read-char in) 'unquote-splicing)
                              'unquote)))
                 (list sym (read-one in))))
              (else
               (read in))))))
        ;; body
        (let ((res (read-one in)))
          (if (pair? shared)
              (patch res))
          res)))))

(define (hole? x) (procedure? x))
(define (fill-hole x) (if (hole? x) (fill-hole (x)) x))

(define (patch x)
  (cond
   ((pair? x)
    (if (hole? (car x)) (set-car! x (fill-hole (car x))) (patch (car x)))
    (if (hole? (cdr x)) (set-cdr! x (fill-hole (cdr x))) (patch (cdr x))))
   ((vector? x)
    (do ((i (- (vector-length x) 1) (- i 1)))
        ((< i 0))
      (let ((elt (vector-ref x i)))
        (if (hole? elt)
            (vector-set! x i (fill-hole elt))
            (patch elt)))))
   (else
    (let* ((type (type-of x))
           (slots (and type (type-slots type))))
      (cond
       (slots
        (let lp ((i 0) (ls slots))
          (cond
           ((pair? ls)
            (let ((elt (slot-ref type x i)))
              (if (hole? elt)
                  (slot-set! type x i (fill-hole elt))
                  (patch elt))
              (lp (+ i 1) (cdr ls))))))))))))

(define read/ss read-with-shared-structure)

(define-library (srfi 95)
  (export sorted? merge merge! sort sort! object-cmp)
  (import (chibi))
  (include-shared "95/qsort")
  (include "95/sort.scm"))
(define-library (srfi 231)
  (import (scheme base)
          (scheme list)
          (scheme vector)
          (scheme sort)
          (srfi 160 base)
          (srfi 231 base)
          (chibi assert))
  (export
   ;; Miscellaneous Functions
   translation? permutation?
   ;; Indexes
   index-rotate index-first index-last index-swap
   ;; Intervals
   make-interval interval? interval-dimension interval-lower-bound
   interval-upper-bound interval-lower-bounds->list
   interval-upper-bounds->list interval-lower-bounds->vector
   interval-upper-bounds->vector interval= interval-volume
   interval-subset? interval-contains-multi-index? interval-projections
   interval-fold-left interval-fold-right
   interval-for-each interval-dilate interval-intersect
   interval-translate interval-permute
   interval-scale interval-cartesian-product
   interval-width interval-widths
   interval-empty?
   ;; Storage Classes
   make-storage-class storage-class? storage-class-getter
   storage-class-setter storage-class-checker storage-class-maker
   storage-class-copier storage-class-length storage-class-default
   generic-storage-class s8-storage-class s16-storage-class
   s32-storage-class s64-storage-class u1-storage-class
   u8-storage-class u16-storage-class u32-storage-class
   u64-storage-class f8-storage-class f16-storage-class
   f32-storage-class f64-storage-class
   c64-storage-class c128-storage-class
   storage-class-data? storage-class-data->body
   ;; Arrays
   make-array array? array-domain array-getter array-dimension
   mutable-array? array-setter specialized-array-default-safe?
   specialized-array-default-mutable? make-specialized-array
   make-specialized-array-from-data
   specialized-array? array-storage-class array-indexer array-body
   array-safe? array-packed? specialized-array-share
   array-copy array-curry array-extract array-tile array-translate
   array-permute array-reverse array-sample
   array-outer-product array-map array-for-each array-foldl
   array-foldr array-reduce array-any array-every
   array-inner-product array-stack array-append array-block
   array->list list->array array->vector vector->array
   array->list* list*->array array->vector* vector*->array
   array-assign! array-ref array-set! array-decurry
   specialized-array-reshape
   array-copy! array-stack! array-decurry! array-append! array-block!
   )
  (include "231/transforms.scm"))
(define-library (srfi 125)
  (import (scheme base)
          (srfi 128)
          (rename (srfi 69)
                  (make-hash-table %make-hash-table)
                  (alist->hash-table %alist->hash-table)
                  (hash-table-copy %hash-table-copy)
                  (hash-table-set! %hash-table-set!)
                  (hash-table-delete! %hash-table-delete!)
                  (hash-table-fold %hash-table-fold))
          (only (chibi ast) immutable? make-immutable!))
  (export
   ;; Constructors:
   make-hash-table hash-table hash-table-unfold alist->hash-table
   ;; Predicates:
   hash-table? hash-table-contains? hash-table-exists?
   hash-table-empty? hash-table=? hash-table-mutable?
   ;; Accessors:
   hash-table-ref hash-table-ref/default
   ;; Mutators:
   hash-table-set! hash-table-delete! hash-table-intern!
   hash-table-update! hash-table-update!/default hash-table-pop!
   hash-table-clear!
   ;; The whole hash table:
   hash-table-size hash-table-keys hash-table-values
   hash-table-entries hash-table-find hash-table-count
   ;; Mapping and folding:
   hash-table-map hash-table-for-each hash-table-walk
   hash-table-map! hash-table-map->list hash-table-fold hash-table-prune!
   ;; Copying and conversion:
   hash-table-copy hash-table-empty-copy hash-table->alist
   ;; Hash tables as sets:
   hash-table-union! hash-table-merge!
   hash-table-intersection! hash-table-difference! hash-table-xor!
   ;; Hash functions and reflectivity:
   hash string-hash string-ci-hash hash-by-identity
   hash-table-equivalence-function hash-table-hash-function)
  (include "125/hash.scm"))

(define fl=? =)
(define fl<? <)
(define fl>? >)
(define fl<=? <=)
(define fl>=? >=)
(define flodd? odd?)
(define fleven? even?)
(define (flunordered? x y) (or (flnan? x) (flnan? y)))
(define flinteger? integer?)
(define flzero? zero?)
(define flpositive? positive?)
(define flnegative? negative?)
(define flonum exact->inexact)

(define fl+ +)
(define fl- -)
(define fl* *)
(define fl/ /)
(define (flmax . args) (if (null? args) -inf.0 (apply max args)))
(define (flmin . args) (if (null? args) +inf.0 (apply min args)))
(define (flabsdiff x y) (abs (- x y)))
(define flnumerator numerator)
(define fldenominator denominator)
(define flround round)

(define (flsquare x) (fl* x x))

(define (flsgn x) (flcopysign 1.0 x))

(define (fldenormalized? x)
  (eqv? FP_SUBNORMAL (fpclassify x)))

(define (flatan x . o)
  (if (pair? o)
      (flatan2 x (car o))
      (flatan1 x)))

(define (flinteger-fraction x)
  (let ((ls (modf x))) (values (cadr ls) (car ls))))

(define (flnormalized-fraction-exponent x)
  (apply values (frexp x)))

(define (flremquo x y)
  (apply values (remquo x y)))

(define (flloggamma x)
  (apply values (lgamma_r x)))
(define-library (srfi 144 test)
  (import (scheme base) (chibi test) (srfi 144))
  (export run-tests)
  (begin
    ;; note default (current-test-epsilon) for (chibi test) test is 1e-5
    (define (run-tests)
      (test-begin "srfi-144: flonums")
      (test-assert (flonum? (flonum 5)))
      (test 5. (fl+ 2. 3.))
      (test -1. (fl- 2. 3.))
      (test 6. (fl* 2. 3.))
      (test 0.6666666666 (fl/ 2. 3.))
      (test 10. (fl+* 2. 3. 4.))
      (test 0. (fladjacent -0. 1.))
      (test -0. (flcopysign 0. -1.))
      (test 3. (make-flonum 3. 0))
      (test 6. (make-flonum 3. 1))
      (test 3072. (make-flonum 3. 10))
      (call-with-values (lambda () (flinteger-fraction 12.345))
        (lambda (int frac)
          (test 12. int)
          (test .345 frac)))
      (test 0. (flexponent 1.))
      (test 255. (flexponent 1e77))
      (test 255 (flinteger-exponent 1e77))
      (test 0 (sign-bit 0.))
      (test 0 (sign-bit 1.))
      (test 0 (sign-bit +inf.0))
      (test 1 (sign-bit -0.))
      (test 1 (sign-bit -1.))
      (test 1 (sign-bit -inf.0))
      (test-not (flunordered? 0. 1.))
      (test-not (flunordered? 0. -inf.0))
      (test-assert (flunordered? +nan.0 0.))
      (test-assert (flunordered? 0. +nan.0))
      (test-assert (flinteger? 42.))
      (test-not (flinteger? 42.1))
      (test-assert (flzero? -0.))
      (test-assert (flzero? 0.))
      (test-not (flzero? 0.1))
      (test-not (flzero? +nan.0))
      (test-assert (flpositive? 1.))
      (test-assert (flpositive? +inf.0))
      (test-not (flpositive? -1.))
      (test-assert (flnegative? -1.))
      (test-assert (flnegative? -inf.0))
      (test-not (flnegative? 1.))
      (test-assert (flodd? 1.))
      (test-not (flodd? 2.))
      (test-not (fleven? 3.))
      (test-assert (fleven? 4.))
      (test-assert (flfinite? 5.))
      (test-assert (flinfinite? -inf.0))
      (test-assert (flnan? +nan.0))
      (test-assert (flnormalized? 1.))
      (test-assert (fldenormalized? (fladjacent 0. +inf.0)))
      (test 1. (flabsdiff 2. 3.))
      (test 1. (flabsdiff 3. 2.))
      (test 0. (flposdiff 2. 3.))
      (test 1. (flsgn 0.))
      (test -1. (flsgn -0.))
      (test 1. (flexp 0.))
      (test 2.718281828 (flexp 1.))
      (test 8. (flexp2 3.))
      (test 1.718281828 (flexp-1 1.))
      (test 9. (flsquare 3.))
      (test 1.414213562 (flsqrt 2.))
      (test 1.259921050 (flcbrt 2.))
      (test 5. (flhypot 3. 4.))
      (test 81. (flexpt 3. 4.))
      (test 1.098612289 (fllog 3.))
      (test 0.693147186 (fllog1+ 1.))
      (test 2.807354922 (fllog2 7.))
      (test 10. (fllog2 1024.))
      (test 3.010299957 (fllog10 1024.))
      (test 0.841470985 (flsin 1.))
      (test 0.540302306 (flcos -1.))
      (test 1.557407725 (fltan 1.))
      (test 1.570796327 (flasin 1.))
      (test fl-pi (flacos -1.))
      (test 0.785398163 (flatan 1.))
      (test 0.463647609 (flatan 1. 2.))
      (test 1.175201194 (flsinh 1.))
      (test 1.543080635 (flcosh -1.))
      (test 0.761594156 (fltanh 1.))
      (test 0.881373587 (flasinh 1.))
      (test 0. (flacosh 1.))
      (test +inf.0 (flatanh 1.))
      (test 24. (flgamma 5.))
      (call-with-values (lambda () (flloggamma 0.1))
        (lambda (res sign)
          (test 2.252713 res)
          (test 1 sign)))
      (test 0.440050586 (flfirst-bessel 1 1.))
      (test -0.781212821 (flsecond-bessel 1 1.))
      (test 0.842700793 (flerf 1.))
      (test 0.157299207 (flerfc 1.))
      (test #t (< 0.0
                  fl-least
                  fl-epsilon
                  1.0
                  (+ 1.0 fl-epsilon)
                  fl-greatest
                  +inf.0))
      (test +inf.0 (flmin))
      (test -inf.0 (flmax))
      (test-end))))
;; constructors.scm -- list construction utilities
;; Copyright (c) 2009-2012 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

(define (xcons a b) (cons b a))

(define (cons* x . args)
  (let lp ((rev '()) (x x) (ls args))
    (if (null? ls)
        (append-reverse rev x)
        (lp (cons x rev) (car ls) (cdr ls)))))

(define (list-tabulate n proc)
  (let lp ((n (- n 1)) (res '()))
    (if (< n 0) res (lp (- n 1) (cons (proc n) res)))))

(define (circular-list x . args)
  (let ((res (cons x args)))
    (set-cdr! (last-pair res) res)
    res))

(define (iota count . o)
  (let ((start (if (pair? o) (car o) 0))
        (step (if (and (pair? o) (pair? (cdr o))) (cadr o) 1)))
    (let lp ((i count) (res '()))
      (if (<= i 0)
          res
          (lp (- i 1) (cons (+ start (* (- i 1) step)) res))))))
;; alist.scm -- association list utilities
;; Copyright (c) 2009 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

(define (alist-cons key value ls) (cons (cons key value) ls))

(define (alist-copy ls) (map (lambda (x) (cons (car x) (cdr x))) ls))

(define (alist-delete key ls . o)
  (let ((eq (if (pair? o) (car o) equal?)))
    (remove (lambda (x) (eq key (car x))) ls)))

(define alist-delete! alist-delete)

;; predicates.scm -- list prediates
;; Copyright (c) 2009 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

(define (proper-list? x)
  (cond ((null? x) #t)
        ((pair? x) (proper-list? (cdr x)))
        (else #f)))

(define (circular-list? x)
  (and (pair? x) (pair? (cdr x))
       (let race ((hare (cdr x)) (tortoise x))
         (or (eq? hare tortoise)
             (and (pair? hare) (pair? (cdr hare))
                  (race (cddr hare) (cdr tortoise)))))))

(define (dotted-list? x)
  (not (proper-list? x)))

(define (not-pair? x) (not (pair? x)))

(define (null-list? x) (null? x)) ; no error

(define (list= eq . lists)
  (let lp1 ((lists lists))
    (or (null? lists)
        (null? (cdr lists))
        (let lp2 ((ls1 (car lists)) (ls2 (cadr lists)))
          (if (null? ls1)
              (and (null? ls2)
                   (lp1 (cdr lists)))
              (and (pair? ls2)
                   (eq (car ls1) (car ls2))
                   (lp2 (cdr ls1) (cdr ls2))))))))

(define (length+ x)
  (if (not (pair? x))
      0
      (let lp ((hare (cdr x)) (tortoise x) (res 1))
        (and (not (eq? hare tortoise))
             (if (pair? hare)
                 (if (not (pair? (cdr hare)))
                     (+ res 1)
                     (lp (cddr hare) (cdr tortoise) (+ res 2)))
                 res)))))
;; lset.scm -- list set library
;; Copyright (c) 2009-2012 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

(define (lset<= eq . sets)
  (if (null? sets)
      #t
      (let lp1 ((set1 (car sets)) (sets (cdr sets)))
        (if (null? sets)
            #t
            (let ((set2 (car sets)))
              (let lp2 ((ls set1))
                (if (pair? ls)
                    (and (member (car ls) set2 eq) (lp2 (cdr ls)))
                    (lp1 set2 (cdr sets)))))))))

(define (lset= eq . sets)
  (and (apply lset<= eq sets)
       (apply lset<= (lambda (b a) (eq a b)) (reverse sets))))

(define (lset-adjoin eq set . elts)
  (lset-union2 eq set elts))

(define (lset-union2 eq a b)
  (if (null? b)
      a
      (lset-union2 eq (if (member (car b) a eq) a (cons (car b) a)) (cdr b))))

(define (lset-union eq . sets)
  (reduce (lambda (a b) (lset-union2 eq b a)) '() sets))

(define (lset-intersection eq . sets)
  (reduce (lambda (a b) (filter (lambda (x) (member x a eq)) b)) '() sets))

(define (lset-diff2 eq a b)
  (remove (lambda (x) (member x a eq)) b))

(define (lset-difference eq . sets)
  (reduce (lambda (a b) (lset-diff2 eq a b)) '() sets))

(define (lset-xor eq . sets)
  (reduce (lambda (a b) (append (lset-diff2 eq a b) (lset-diff2 eq b a)))
          '()
          sets))

(define (lset-diff+intersection eq . sets)
  (values (apply lset-difference eq sets) (apply lset-intersection eq sets)))

(define lset-diff+intersection! lset-diff+intersection)
(define lset-xor! lset-xor)
(define lset-difference! lset-difference)
(define lset-intersection! lset-intersection)
(define lset-union! lset-union)
;; deletion.scm -- list deletion utilities
;; Copyright (c) 2009-2012 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

(define (delete x ls . o)
  (let ((eq (if (pair? o) (car o) equal?)))
    (if (eq? eq eq?)
        (let lp ((ls ls) (rev '())) ;; fast path for delq
          (let ((tail (memq x ls)))
            (if tail
                (lp (cdr tail) (take-up-to-reverse ls tail rev))
                (if (pair? rev) (append-reverse! rev ls) ls))))
        (remove (lambda (y) (eq x y)) ls))))

(define delete! delete)

(define (delete-duplicates ls . o)
  (let ((eq (if (pair? o) (car o) equal?)))
    (let lp ((ls ls) (res '()))
      (if (pair? ls)
          (lp (cdr ls) (if (member (car ls) res eq) res (cons (car ls) res)))
          (reverse! res)))))

(define delete-duplicates! delete-duplicates)

(define-library (srfi 1 immutable)
  (export
   caaaar caaadr caadar caaddr cadaar cadadr caddar cadddr
   cdaaar cdaadr cdadar cdaddr cddaar cddadr cdddar cddddr
   caaar caadr cadar caddr cdaar cdadr cddar cdddr
   caar cadr cdar cddr car cdr
   pair? list?
   list-ref length apply map for-each member memv memq assoc assv assq
   cons list xcons cons* make-list list-tabulate list-copy circular-list iota
   proper-list? circular-list? dotted-list? not-pair? null-list? list=
   first second third fourth fifth sixth seventh eighth ninth tenth
   car+cdr take drop take-right drop-right split-at
   last last-pair length+ concatenate append-reverse append reverse
   zip unzip1 unzip2 unzip3 unzip4 unzip5 count
   fold unfold pair-fold reduce fold-right unfold-right
   pair-fold-right reduce-right
   append-map pair-for-each filter-map map-in-order
   filter partition remove find find-tail any every
   list-index take-while drop-while span break
   delete delete-duplicates
   alist-cons alist-copy alist-delete
   lset<= lset= lset-adjoin lset-union lset-intersection
   lset-difference lset-xor lset-diff+intersection)
  (import (rename (chibi)
                  (cons mcons)
                  (list mlist)
                  (reverse mreverse)
                  (append mappend)
                  (map mmap))
          (scheme cxr)
          (only (chibi ast) make-immutable!))
  (begin
    (define (cons a b)
      (let ((res (mcons a b)))
        (make-immutable! res)
        res))
    (define (list . args)
      (let lp ((ls args))
        (cond
         ((pair? ls)
          (make-immutable! ls)
          (lp (cdr ls)))))
      args)
    (define (reverse ls)
      (let lp ((ls ls) (res '()))
        (if (pair? ls)
            (lp (cdr ls) (cons (car ls) res))
            res)))
    (define (append2 ls1 ls2)
      (let lp ((ls1 (reverse ls1)) (ls2 ls2))
        (if (pair? ls1)
            (lp (cdr ls1) (cons (car ls1) ls2))
            ls2)))
    (define (append . o)
      (let lp ((lol (reverse o)) (res '()))
        (if (pair? lol)
            (lp (cdr lol) (append2 (car lol) res))
            res)))
    (define (map proc ls . lol)
      (define (map1 proc ls res)
        (if (pair? ls)
            (map1 proc (cdr ls) (cons (proc (car ls)) res))
            (reverse res)))
      (define (mapn proc lol res)
        (if (every pair? lol)
            (mapn proc
                  (map1 cdr lol '())
                  (cons (apply proc (map1 car lol '())) res))
            (reverse res)))
      (if (null? lol)
          (map1 proc ls '())
          (mapn proc (cons ls lol) '()))))
  (include "predicates.scm"
           "selectors.scm"
           "search.scm"
           "misc.scm"
           "constructors.scm"
           "fold.scm"
           "deletion.scm"
           "alists.scm"
           "lset.scm"))
;; misc.scm -- miscellaneous list utilities
;; Copyright (c) 2009-2012 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

(define (map-onto proc ls init)
  (let lp ((ls (reverse ls)) (res init))
    (if (null? ls) res (lp (cdr ls) (cons (proc (car ls)) res)))))

(define (append! . lists) (concatenate! lists))

(define (concatenate lists)
  (let lp ((ls (reverse lists)) (res '()))
    (if (null? ls) res (lp (cdr ls) (append (car ls) res)))))

(define (concatenate! lists)
  (if (null? lists)
      '()
      (let lp ((ls lists))
        (cond ((not (pair? (cdr ls)))
               (car lists))
              (else
               (set-cdr! (last-pair (car ls)) (cadr ls))
               (lp (cdr ls)))))))

(define (append-reverse rev tail)
  (if (null? rev) tail (append-reverse (cdr rev) (cons (car rev) tail))))

(define (append-reverse! rev tail)
  (if (null? rev)
      tail
      (let ((head (reverse! rev)))
        (set-cdr! rev tail)
        head)))

(define (zip . lists) (apply map list lists))

(define (unzip1 ls) (map first ls))
(define (unzip2 ls) (values (map first ls) (map second ls)))
(define (unzip3 ls) (values (map first ls) (map second ls) (map third ls)))
(define (unzip4 ls)
  (values (map first ls) (map second ls) (map third ls) (map fourth ls)))
(define (unzip5 ls)
  (values (map first ls) (map second ls) (map third ls) (map fourth ls)
          (map fifth ls)))

(define (count pred ls . lists)
  (if (null? lists)
      (let lp ((ls ls) (res 0))
        (if (pair? ls) (lp (cdr ls) (if (pred (car ls)) (+ res 1) res)) res))
      (let lp ((lists (cons ls lists)) (res 0))
        (if (every pair? lists)
            (lp (map cdr lists) (if (apply pred (map car lists)) (+ res 1) res))
            res))))
(define-library (srfi 1 test)
  (export run-tests)
  (import (chibi) (chibi test) (srfi 1))
  (begin
    (define (run-tests)
      (test-begin "srfi-1: list library")

      ;; srfi-1 examples
      ;; http://srfi.schemers.org/srfi-1/srfi-1.html
      (test '(a) (cons 'a '()))
      (test '((a) b c d) (cons '(a) '(b c d)))
      (test '("a" b c) (cons "a" '(b c)))
      (test '(a . 3) (cons 'a 3))
      (test '((a b) . c) (cons '(a b) 'c))
      (test '(a 7 c) (list 'a (+ 3 4) 'c))
      (test '() (list))
      (test '(a b c) (xcons '(b c) 'a))
      (test '(1 2 3 . 4) (cons* 1 2 3 4))
      (test 1 (cons* 1))
      (test '(c c c c) (make-list 4 'c))
      (test '(0 1 2 3) (list-tabulate 4 values))
      (test '(z q z q z q) (take (circular-list 'z 'q) 6))
      (test '(0 1 2 3 4) (iota 5))
      ;;(test '(0 -0.1 -0.2 -0.3 -0.4)
      ;;    (let ((res (iota 5 0 -0.1)))
      ;;      (cons (inexact->exact (car res)) (cdr res))))
      (test #t (pair? '(a . b)))
      (test #t (pair? '(a b c)))
      (test #f (pair? '()))
      (test #f (pair? '#(a b)))
      (test #f (pair? 7))
      (test #f (pair? 'a))
      (test #t (list= eq?))
      (test #t (list= eq? '(a)))
      (test #f (list= = '(1 2) '(1 2 3)))
      (test #f (list= = '(1 2 3) '(1 2)))
      (test 'a (car '(a b c)))
      (test '(b c)   (cdr '(a b c)))
      (test '(a) (car '((a) b c d)))
      (test '(b c d) (cdr '((a) b c d)))
      (test '1 (car '(1 . 2)))
      (test '2 (cdr '(1 . 2)))
      (test-error (car '()))
      (test-error (cdr '()))
      (test 1 (first '(1 2 3 4 5 6 7 8 9 10)))
      (test 2 (second '(1 2 3 4 5 6 7 8 9 10)))
      (test 3 (third '(1 2 3 4 5 6 7 8 9 10)))
      (test 4 (fourth '(1 2 3 4 5 6 7 8 9 10)))
      (test 5 (fifth '(1 2 3 4 5 6 7 8 9 10)))
      (test 6 (sixth '(1 2 3 4 5 6 7 8 9 10)))
      (test 7 (seventh '(1 2 3 4 5 6 7 8 9 10)))
      (test 8 (eighth '(1 2 3 4 5 6 7 8 9 10)))
      (test 9 (ninth '(1 2 3 4 5 6 7 8 9 10)))
      (test 10 (tenth '(1 2 3 4 5 6 7 8 9 10)))
      (test 'c (list-ref '(a b c d) 2))
      (test 'c (third '(a b c d e)))
      (test '(a b) (take '(a b c d e)  2))
      (test '(c d e) (drop '(a b c d e)  2))
      (test '(1 2) (take '(1 2 3 . d) 2))
      (test '(3 . d) (drop '(1 2 3 . d) 2))
      (test '(1 2 3) (take '(1 2 3 . d) 3))
      (test 'd (drop '(1 2 3 . d) 3))
      (test '(d e) (take-right '(a b c d e) 2))
      (test '(a b c) (drop-right '(a b c d e) 2))
      (test '(2 3 . d) (take-right '(1 2 3 . d) 2))
      (test '(1) (drop-right '(1 2 3 . d) 2))
      (test 'd (take-right '(1 2 3 . d) 0))
      (test '(1 2 3) (drop-right '(1 2 3 . d) 0))
      (test-assert (member (take! (circular-list 1 3 5) 8) '((1 3) (1 3 5 1 3 5 1 3)) equal?))
      (test-values (values '(a b c) '(d e f g h)) (split-at '(a b c d e f g h) 3))
      (test 'c (last '(a b c)))
      (test '(c) (last-pair '(a b c)))
      (test '(x y) (append '(x) '(y)))
      (test '(a b c d) (append '(a) '(b c d)))
      (test '(a (b) (c)) (append '(a (b)) '((c))))
      (test '(a b c . d) (append '(a b) '(c . d)))
      (test 'a (append '() 'a))
      (test '(x y) (append '(x y)))
      (test '() (append))
      (test '(c b a) (reverse '(a b c)))
      (test '((e (f)) d (b c) a) (reverse '(a (b c) d (e (f)))))
      (test '((one 1 odd) (two 2 even) (three 3 odd)) (zip '(one two three) '(1 2 3) '(odd even odd even odd even odd even)))
      (test '((1) (2) (3)) (zip '(1 2 3)))
      (test '((3 #f) (1 #t) (4 #f) (1 #t)) (zip '(3 1 4 1) (circular-list #f #t)))
      (test-values (values '(1 2 3) '(one two three)) (unzip2 '((1 one) (2 two) (3 three))))
      (test 3 (count even? '(3 1 4 1 5 9 2 5 6)))
      (test 3 (count < '(1 2 4 8) '(2 4 6 8 10 12 14 16)))
      (test 2 (count < '(3 1 4 1) (circular-list 1 10)))
      (test '(c 3 b 2 a 1) (fold cons* '() '(a b c) '(1 2 3 4 5)))
      (test '(a 1 b 2 c 3) (fold-right cons* '() '(a b c) '(1 2 3 4 5)))
      (test '((a b c) (b c) (c)) (pair-fold-right cons '() '(a b c)))
      (test '((a b c) (1 2 3) (b c) (2 3) (c) (3)) (pair-fold-right cons* '() '(a b c) '(1 2 3)))
      (test '(b e h) (map cadr '((a b) (d e) (g h))))
      (test '(1 4 27 256 3125) (map (lambda (n) (expt n n)) '(1 2 3 4 5)))
      (test '(5 7 9) (map + '(1 2 3) '(4 5 6)))
      (test-assert (member (let ((count 0)) (map (lambda (ignored) (set! count (+ count 1)) count) '(a b))) '((1 2) (2 1)) equal?))
      (test '(4 1 5 1) (map + '(3 1 4 1) (circular-list 1 0)))
      (test '#(0 1 4 9 16) (let ((v (make-vector 5))) (for-each (lambda (i) (vector-set! v i (* i i))) '(0 1 2 3 4)) v))
      (test '(1 -1 3 -3 8 -8) (append-map (lambda (x) (list x (- x))) '(1 3 8)))
      (test '(1 -1 3 -3 8 -8) (apply append (map (lambda (x) (list x (- x))) '(1 3 8))))
      (test '(1 -1 3 -3 8 -8) (append-map! (lambda (x) (list x (- x))) '(1 3 8)))
      (test '(1 -1 3 -3 8 -8) (apply append! (map (lambda (x) (list x (- x))) '(1 3 8))))
      (test "pair-for-each-1" '((a b c) (b c) (c))
        (let ((a '()))
          (pair-for-each (lambda (x) (set! a (cons x a))) '(a b c))
          (reverse a)))
      (test '(1 9 49) (filter-map (lambda (x) (and (number? x) (* x x))) '(a 1 b 3 c 7)))
      (test '(0 8 8 -4) (filter even? '(0 7 8 8 43 -4)))
      (test-values (values '(one four five) '(2 3 6)) (partition symbol? '(one 2 3 four five 6)))
      (test '(7 43) (remove even? '(0 7 8 8 43 -4)))
      (test 2 (find even? '(1 2 3)))
      (test #t (any  even? '(1 2 3)))
      (test #f (find even? '(1 7 3)))
      (test #f (any  even? '(1 7 3)))
      ;;(test-error (find even? '(1 3 . x)))
      ;;(test-error (any  even? '(1 3 . x)))
      ;;(test 'error/undefined (find even? '(1 2 . x)))
      ;;(test 'error/undefined (any  even? '(1 2 . x))) ; success, error or other
      (test 6 (find even? (circular-list 1 6 3)))
      (test #t (any  even? (circular-list 1 6 3)))
      ;;(test-error (find even? (circular-list 1 3))) ; divergent
      ;;(test-error (any even? (circular-list 1 3))) ; divergent
      (test 4 (find even? '(3 1 4 1 5 9)))
      (test #f (every odd? '(1 2 3)))
      (test #t (every < '(1 2 3) '(4 5 6)))
      (test-error (every odd? '(1 3 . x)))
      (test '(-8 -5 0 0) (find-tail even? '(3 1 37 -8 -5 0 0)))
      (test '#f (find-tail even? '(3 1 37 -5)))
      (test '(2 18) (take-while even? '(2 18 3 10 22 9)))
      (test '(3 10 22 9) (drop-while even? '(2 18 3 10 22 9)))
      (test-values (values '(2 18) '(3 10 22 9)) (span even? '(2 18 3 10 22 9)))
      (test-values (values '(3 1) '(4 1 5 9)) (break even? '(3 1 4 1 5 9)))
      (test #t (any integer? '(a 3 b 2.7)))
      (test #f (any integer? '(a 3.1 b 2.7)))
      (test #t (any < '(3 1 4 1 5) '(2 7 1 8 2)))
      (test 2 (list-index even? '(3 1 4 1 5 9)))
      (test 1 (list-index < '(3 1 4 1 5 9 2 5 6) '(2 7 1 8 2)))
      (test #f (list-index = '(3 1 4 1 5 9 2 5 6) '(2 7 1 8 2)))
      (test '(a b c) (memq 'a '(a b c)))
      (test '(b c) (memq 'b '(a b c)))
      (test #f (memq 'a '(b c d)))
      (test #f (memq (list 'a) '(b (a) c)))
      (test '((a) c) (member (list 'a) '(b (a) c)))
      ;;(test '*unspecified* (memq 101 '(100 101 102)))
      (test '(101 102) (memv 101 '(100 101 102)))
      (test '(a b c z) (delete-duplicates '(a b a c a b c z)))
      (test '((a . 3) (b . 7) (c . 1)) (delete-duplicates '((a . 3) (b . 7) (a . 9) (c . 1)) (lambda (x y) (eq? (car x) (car y)))))
      (let ((e '((a 1) (b 2) (c 3))))
        (test '(a 1) (assq 'a e))
        (test '(b 2) (assq 'b e))
        (test #f (assq 'd e))
        (test #f (assq (list 'a) '(((a)) ((b)) ((c)))))
        (test '((a)) (assoc (list 'a) '(((a)) ((b)) ((c)))))
        ;;(test '*unspecified* (assq 5 '((2 3) (5 7) (11 13))))
        (test '(5 7) (assv 5 '((2 3) (5 7) (11 13)))))
      (test #t (lset<= eq? '(a) '(a b a) '(a b c c)))
      (test #t (lset<= eq?))
      (test #t (lset<= eq? '(a)))
      (test #f (lset= eq? '(a) '()))
      (test #f (lset= eq? '() '(a)))
      (test #t (lset= eq? '(b e a) '(a e b) '(e e b a)))
      (test #t (lset= eq?))
      (test #t (lset= eq? '(a)))
      (test #f (lset= = '(2 1) '(2 1 0)))
      (test #t (lset<= = '(2 1) '(2 1 0)))
      (test #f (lset<= = '(2 1 0) '(2 1)))
      ;; order matters
      (test #t (lset= (lambda (a b) (= (inexact->exact (round a)) b)) '(1.2 0.1 2.3) '(2 1 0)))
      (test '(u o i a b c d c e) (lset-adjoin eq? '(a b c d c e) 'a 'e 'i 'o 'u))
      (test '(u o i a b c d e) (lset-union eq? '(a b c d e) '(a e i o u)))
      (test '(x a a c) (lset-union eq? '(a a c) '(x a x)))
      (test '() (lset-union eq?))
      (test '(a b c) (lset-union eq? '(a b c)))
      (test '(a e) (lset-intersection eq? '(a b c d e) '(a e i o u)))
      (test '(a x a) (lset-intersection eq? '(a x y a) '(x a x z)))
      (test '(a b c) (lset-intersection eq? '(a b c)))
      (test '(b c d) (lset-difference eq? '(a b c d e) '(a e i o u)))
      (test '(a b c) (lset-difference eq? '(a b c)))
      (test #t (lset= eq? '(d c b i o u) (lset-xor eq? '(a b c d e) '(a e i o u))))
      (test '() (lset-xor eq?))
      (test '(a b c d e) (lset-xor eq? '(a b c d e)))
      (let ((f (lambda () (list 'not-a-constant-list)))
            (g (lambda () '(constant-list))))
        ;;(test '*unspecified* (set-car! (f) 3))
        (test-error (set-car! (g) 3)))

      (test-end))))
;; search.scm -- list searching and splitting
;; Copyright (c) 2009-2011 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

(define (take-while pred ls)
  (let lp ((ls ls) (res '()))
    (if (and (pair? ls) (pred (car ls)))
        (lp (cdr ls) (cons (car ls) res))
        (reverse! res))))

(define take-while! take-while)

(define (drop-while pred ls)
  (or (find-tail (lambda (x) (not (pred x))) ls) '()))

(define (span pred ls)
  (let lp ((ls ls) (res '()))
    (if (and (pair? ls) (pred (car ls)))
        (lp (cdr ls) (cons (car ls) res))
        (values (reverse! res) ls))))

(define span! span)

(define (break pred ls) (span (lambda (x) (not (pred x))) ls))

(define break! break)

(define (list-index pred ls . lists)
  (if (null? lists)
      (let lp ((ls ls) (n 0))
        (and (pair? ls) (if (pred (car ls)) n (lp (cdr ls) (+ n 1)))))
      (let lp ((lists (cons ls lists)) (n 0))
        (and (every pair? lists)
             (if (apply pred (map car lists)) n (lp (map cdr lists) (+ n 1)))
             ))))
;; fold.scm -- list fold/reduce utilities
;; Copyright (c) 2009-2012 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

(define (fold kons knil ls . lists)
  (if (null? lists)
      (let lp ((ls ls) (acc knil))
        (if (pair? ls) (lp (cdr ls) (kons (car ls) acc)) acc))
      (let lp ((lists (cons ls lists)) (acc knil))
        (if (every pair? lists)
            (lp (map cdr lists) (apply kons (map-onto car lists (list acc))))
            acc))))

(define (fold-right kons knil ls . lists)
  (if (null? lists)
      (let lp ((ls ls))
        (if (pair? ls) (kons (car ls) (lp (cdr ls))) knil))
      (let lp ((lists (cons ls lists)))
        (if (every pair? lists)
            (apply kons (map-onto car lists (list (lp (map cdr lists)))))
            knil))))

(define (pair-fold kons knil ls . lists)
  (if (null? lists)
      (let lp ((ls ls) (acc knil))
        (if (pair? ls) (lp (cdr ls) (kons ls acc)) acc))
      (let lp ((lists (cons ls lists)) (acc knil))
        (if (every pair? lists)
            (lp (map cdr lists) (apply kons (append lists (list acc))))
            acc))))

(define (pair-fold-right kons knil ls . lists)
  (if (null? lists)
      (let lp ((ls ls))
        (if (pair? ls) (kons ls (lp (cdr ls))) knil))
      (let lp ((lists (cons ls lists)))
        (if (every pair? lists)
            (apply kons (append lists (list (lp (map cdr lists)))))
            knil))))

(define (reduce f identity ls)
  (if (null? ls) identity (fold f (car ls) (cdr ls))))

(define (reduce-right f identity ls)
  (if (null? ls) identity (fold-right f identity ls)))

(define (unfold p f g seed . o)
  (let lp ((seed seed))
    (if (p seed)
        (if (pair? o) ((car o) seed) '())
        (cons (f seed) (lp (g seed))))))

(define (unfold-right p f g seed . o)
  (let lp ((seed seed) (res (if (pair? o) (car o) '())))
    (if (p seed) res (lp (g seed) (cons (f seed) res)))))

(define (append-map-helper append f ls lists)
  (if (null? lists)
      (if (null? ls)
          '()
          (let lp ((ls (reverse ls)) (res '()))
            (if (null? ls) res (lp (cdr ls) (append (f (car ls)) res)))))
      (if (and (pair? ls) (every pair? lists))
          (let lp ((lists (cons ls lists)))
            (let ((vals (apply f (map car lists)))
                  (cdrs (map cdr lists)))
              (if (every pair? cdrs) (append vals (lp cdrs)) vals)))
          '())))

(define (append-map f ls . lists)
  (append-map-helper append f ls lists))

(define (append-map! f ls . lists)
  (append-map-helper append! f ls lists))

(define map! map)
(define map-in-order map)

(define (pair-for-each f ls . lists)
  (if (pair? lists)
      (apply pair-fold (lambda args (apply f (drop-right args 1))) #f ls lists)
      (pair-fold (lambda (x _) (f x)) #f ls)))

(define (filter-map f ls . lists)
  (if (null? lists)
      (let lp ((ls ls) (res '()))
        (if (pair? ls)
            (let ((x (f (car ls)))) (lp (cdr ls) (if x (cons x res) res)))
            (reverse res)))
      (filter (lambda (x) x) (apply map f ls lists))))

(define (take-up-to-reverse from to init)
  (if (eq? from to)
      init
      (take-up-to-reverse (cdr from) to (cons (car from) init))))

(define (remove pred ls)
  (let lp ((ls ls) (rev '()))
    (let ((tail (find-tail pred ls)))
      (if tail
          (lp (cdr tail) (take-up-to-reverse ls tail rev))
          (if (pair? rev) (append-reverse rev ls) ls)))))

(define (filter pred ls) (remove (lambda (x) (not (pred x))) ls))

(define (partition pred ls)
  (let lp ((ls ls) (good '()) (bad '()))
    (cond ((null? ls) (values (reverse! good) (reverse! bad)))
          ((pred (car ls)) (lp (cdr ls) (cons (car ls) good) bad))
          (else (lp (cdr ls) good (cons (car ls) bad))))))

(define filter! filter)
(define remove! remove)
(define partition! partition)

;; selectors.scm -- extended list selectors
;; Copyright (c) 2009 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

(define first car)
(define second cadr)
(define (third ls)   (car (cdr (cdr ls))))
(define (fourth ls)  (car (cdr (cdr (cdr ls)))))
(define (fifth ls)   (car (cdr (cdr (cdr (cdr ls))))))
(define (sixth ls)   (car (cdr (cdr (cdr (cdr (cdr ls)))))))
(define (seventh ls) (car (cdr (cdr (cdr (cdr (cdr (cdr ls))))))))
(define (eighth ls)  (car (cdr (cdr (cdr (cdr (cdr (cdr (cdr ls)))))))))
(define (ninth ls)   (car (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr ls))))))))))
(define (tenth ls)   (car (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr ls)))))))))))

(define (car+cdr x) (values (car x) (cdr x)))

(define (take ls i)
  (let lp ((i i) (ls ls) (res '()))
    (if (<= i 0)
        (reverse! res)
        (lp (- i 1) (cdr ls) (cons (car ls) res)))))

(define (take! ls i)
  (if (<= i 0)
      '()
      (let ((tail (list-tail ls (- i 1))))
        (set-cdr! tail '())
        ls)))

(define (drop ls i)
  (if (<= i 0) ls (drop (cdr ls) (- i 1))))

(define (take-right ls i)
  (drop ls (- (length+ ls) i)))

(define (drop-right ls i)
  (take ls (- (length+ ls) i)))

(define (drop-right! ls i)
  (take! ls (- (length+ ls) i)))

(define (split-at ls i)
  (let lp ((i i) (ls ls) (res '()))
    (if (<= i 0)
        (values (reverse! res) ls)
        (lp (- i 1) (cdr ls) (cons (car ls) res)))))

(define (split-at! ls i)
  (if (<= i 0)
      (values '() ls)
      (let* ((tail (list-tail ls (- i 1)))
             (right (cdr tail)))
        (set-cdr! tail '())
        (values ls right))))

(define (last ls) (if (null? (cdr ls)) (car ls) (last (cdr ls))))
(define (last-pair ls) (if (null? (cdr ls)) ls (last-pair (cdr ls))))


(define (opt-hash eq-fn o)
  (if (pair? o)
      (car o)
      (if (eq? eq? eq-fn) hash-by-identity hash)))

(define (make-hash-table x . o)
  (if (comparator? x)
      (%make-hash-table (comparator-equality-predicate x)
                        (comparator-hash-function x))
      (%make-hash-table x (opt-hash x o))))

(define (hash-table comparator . o)
  (let ((ht (make-hash-table comparator)))
    (let lp ((ls o))
      (when (pair? ls)
        (hash-table-set! ht (car ls) (cadr ls))
        (lp (cddr ls))))
    ht))

(define (hash-table-copy ht . o)
  (cond
   ((and (pair? o) (car o))
    (%hash-table-copy ht))
   ((hash-table-mutable? ht)
    (let ((res (%hash-table-copy ht)))
      (make-immutable! res)
      res))
   (else
    ht)))

(define (hash-table-set! ht . o)
  (let lp ((ls o))
    (when (pair? ls)
      (%hash-table-set! ht (car ls) (cadr ls))
      (lp (cddr ls)))))

(define (hash-table-fold a b c)
  (if (hash-table? a)
      (%hash-table-fold a b c)
      (%hash-table-fold c a b)))

(define (hash-table-unfold stop? mapper successor seed comparator . o)
  (let ((ht (make-hash-table comparator)))
    (let lp ((acc seed))
      (if (stop? acc)
          ht
          (call-with-values (lambda () (mapper acc))
            (lambda (key value)
              (hash-table-set! ht key value)
              (lp (successor acc))))))))

(define (alist->hash-table alist x . o)
  (if (comparator? x)
      (%alist->hash-table alist
                          (comparator-equality-predicate x)
                          (comparator-hash-function x))
      (%alist->hash-table alist x (opt-hash x o))))

(define hash-table-contains? hash-table-exists?)

(define (hash-table-empty? ht)
  (zero? (hash-table-size ht)))

(define (hash-table-mutable? ht)
  (not (immutable? ht)))

(define missing-key (list 'missing-key))

(define (hash-table=? value-cmp ht1 ht2)
  (and (= (hash-table-size ht1)
          (hash-table-size ht2))
       (let lp ((ls (hash-table-keys ht1)))
         (or (null? ls)
             (let ((v1 (hash-table-ref/default ht1 (car ls) missing-key))
                   (v2 (hash-table-ref/default ht2 (car ls) missing-key)))
               (and (not (eq? missing-key v1))
                    (not (eq? missing-key v2))
                    ((comparator-equality-predicate value-cmp) v1 v2)
                    (lp (cdr ls))))))))

(define (hash-table-intern! ht key failure)
  (hash-table-ref ht key (lambda ()
                           (let ((res (failure)))
                             (hash-table-set! ht key res)
                             res))))

(define (hash-table-delete! ht . keys)
  (for-each (lambda (key) (%hash-table-delete! ht key)) keys))

(define (hash-table-pop! ht)
  (let* ((key (car (hash-table-keys ht)))
         (value (hash-table-ref ht key)))
    (hash-table-delete! ht key)
    (values key value)))

(define (hash-table-clear! ht)
  (for-each
   (lambda (key) (hash-table-delete! ht key))
   (hash-table-keys ht)))

(define (hash-table-entries ht)
  (values (hash-table-keys ht) (hash-table-values ht)))

(define (hash-table-find proc ht failure)
  (call-with-current-continuation
   (lambda (return)
     (hash-table-for-each
      (lambda (key value)
        (let ((res (proc key value)))
          (if res (return res))))
      ht)
     (failure))))

(define (hash-table-count proc ht)
  (let ((count 0))
    (hash-table-for-each
     (lambda (key value)
       (if (proc key value)
           (set! count (+ count 1))))
     ht)
    count))

(define (hash-table-map proc cmp ht)
  (let ((ht2 (make-hash-table cmp)))
    (hash-table-for-each
     (lambda (key value) (hash-table-set! ht2 key (proc value)))
     ht)
    ht2))

(define (hash-table-map! proc ht)
  (for-each
   (lambda (key value) (hash-table-set! ht key (proc key value)))
   (hash-table-keys ht)
   (hash-table-values ht)))

(define (hash-table-for-each proc ht)
  (hash-table-walk ht proc))

(define (hash-table-map->list proc ht)
  (map (lambda (cell) (proc (car cell) (cdr cell))) (hash-table->alist ht)))

(define (hash-table-prune! proc ht)
  (for-each
   (lambda (key value)
     (if (proc key value)
         (hash-table-delete! ht key)))
   (hash-table-keys ht)
   (hash-table-values ht)))

(define (hash-table-empty-copy ht)
  (make-hash-table (hash-table-equivalence-function ht)
                   (hash-table-hash-function ht)))

(define hash-table-union! hash-table-merge!)

(define (hash-table-intersection! ht1 ht2)
  (for-each
   (lambda (key)
     (if (not (hash-table-contains? ht2 key))
         (hash-table-delete! ht1 key)))
   (hash-table-keys ht1))
  ht1)

(define (hash-table-difference! ht1 ht2)
  (for-each
   (lambda (key)
     (if (hash-table-contains? ht2 key)
         (hash-table-delete! ht1 key)))
   (hash-table-keys ht1))
  ht1)

(define (hash-table-xor! ht1 ht2)
  (let* ((tmp (hash-table-copy ht1 #t))
         (intersection (hash-table-intersection! tmp ht2)))
    (hash-table-difference! (hash-table-union! ht1 ht2)
                            intersection)
    ht1))
(define-library (srfi 125 test)
  (export run-tests)
  (import (scheme base) (scheme char) (scheme write)
          (srfi 125) (srfi 128) (srfi 132)
          (chibi test))
  (begin
    (define (run-tests)
      (define number-comparator
        (make-comparator real? = < (lambda (x . o) (exact (abs (round x))))))
      (define ht-default (make-hash-table default-comparator))
      (define ht-eq (make-hash-table eq-comparator 'random-argument "another"))
      (define ht-eqv (make-hash-table eqv-comparator))
      (define ht-eq2 (make-hash-table eq?))
      (define ht-eqv2 (make-hash-table eqv?))
      (define ht-equal (make-hash-table equal?))
      (define ht-string (make-hash-table string=?))
      (define ht-string-ci (make-hash-table string-ci=?))
      (define ht-symbol (make-hash-table symbol=?))    ; FIXME: glass-box
      (define ht-fixnum (make-hash-table = (lambda (x . o) (abs x))))
      (define ht-default2
        (hash-table default-comparator 'foo 'bar 101.3 "fever" '(x y z) '#()))
      (define ht-fixnum2
        (let ((ht (make-hash-table number-comparator)))
          (do ((i 0 (+ i 1)))
              ((= i 10) (hash-table-copy ht))
            (hash-table-set! ht (* i i) i))))
      (define ht-string2
        (hash-table-unfold (lambda (s) (= 0 (string-length s)))
                           (lambda (s) (values s (string-length s)))
                           (lambda (s) (substring s 0 (- (string-length s) 1)))
                           "prefixes"
                           string-comparator
                           'ignored1 'ignored2 "ignored3" '#(ignored 4 5)))
      (define ht-string-ci2
        (alist->hash-table '(("" . 0) ("Mary" . 4) ("Paul" . 4) ("Peter" . 5))
                           string-ci-comparator
                           "ignored1" 'ignored2))
      (define ht-symbol2
        (alist->hash-table '((mary . travers) (noel . stookey) (peter .yarrow))
                           eq?))
      (define ht-equal2
        (alist->hash-table '(((edward) . abbey)
                             ((dashiell) . hammett)
                             ((edward) . teach)
                             ((mark) . twain))
                           equal?
                           (comparator-hash-function default-comparator)))
      (define test-tables
        (list ht-default   ht-default2   ; initial keys: foo, 101.3, (x y z)
              ht-eq        ht-eq2        ; initially empty
              ht-eqv       ht-eqv2       ; initially empty
              ht-equal     ht-equal2     ; initial keys: (edward), (dashiell), (mark)
              ht-string    ht-string2    ; initial keys: "p, "pr", ..., "prefixes"
              ht-string-ci ht-string-ci2 ; initial keys: "", "Mary", "Paul", "Peter"
              ht-symbol    ht-symbol2    ; initial keys: mary, noel, peter
              ht-fixnum    ht-fixnum2))  ; initial keys: 0, 1, 4, 9, ..., 81

      (test-begin "srfi 125: intermediate hash tables")

      ;; Predicates

      (test (append '(#f #f) (map (lambda (x) #t) test-tables))
          (map hash-table?
               (cons '#()
                     (cons default-comparator
                           test-tables))))

      (test '(#f #t #f #f #f #f #f #t #f #t #f #t #f #t #f #t)
          (map hash-table-contains?
               test-tables
               '(foo 101.3
                     x "y"
                     (14 15) #\newline
                     (edward) (mark)
                     "p" "pref"
                     "mike" "PAUL"
                     jane noel
                     0 4)))

      (test (map (lambda (x) #f) test-tables)
          (map hash-table-contains?
               test-tables
               '(#u8() 47.9
                    '#() '()
                    foo bar
                    19 (henry)
                    "p" "perp"
                    "mike" "Noel"
                    jane paul
                    0 5)))

      (test '(#t #f #t #t #t #t #t #f #t #f #t #f #t #f #t #f)
          (map hash-table-empty? test-tables))

      ;; (test (map (lambda (x) #t) test-tables)
      ;;     (map (lambda (ht1 ht2) (hash-table=? default-comparator ht1 ht2))
      ;;          test-tables
      ;;          test-tables))

      ;; (test '(#f #f #t #t #t #t #f #f #f #f #f #f #f #f #f #f)
      ;;     (map (lambda (ht1 ht2) (hash-table=? default-comparator ht1 ht2))
      ;;          test-tables
      ;;          (do ((tables (reverse test-tables) (cddr tables))
      ;;               (rev '() (cons (car tables) (cons (cadr tables) rev))))
      ;;              ((null? tables)
      ;;               rev))))

      (test '(#t #t #t #t #t #t #t #t #t #t #t #t #t #t #t #f)
          (map hash-table-mutable? test-tables))

      ;; FIXME: glass-box
      ;; (test (map hash-table-mutable? (map hash-table-copy test-tables))
      ;;     (map (lambda (x) #f) test-tables))

      (test #t
          (hash-table-mutable? (hash-table-copy ht-fixnum2 #t)))

      ;; Accessors.

      ;; FIXME: glass-box (implementations not required to raise an exception here)
      ;; (test (map (lambda (ht)
      ;;              (guard (exn
      ;;                      (else 'err))
      ;;                (hash-table-ref ht 'not-a-key)))
      ;;            test-tables)
      ;;     (map (lambda (ht) 'err) test-tables))

      ;; FIXME: glass-box (implementations not required to raise an exception here)
      ;; (test (map (lambda (ht)
      ;;              (guard (exn
      ;;                      (else 'err))
      ;;                (hash-table-ref ht 'not-a-key (lambda () 'err))))
      ;;            test-tables)
      ;;     (map (lambda (ht) 'err) test-tables))

      ;; FIXME: glass-box (implementations not required to raise an exception here)
      ;; (test (map (lambda (ht)
      ;;              (guard (exn
      ;;                      (else 'err))
      ;;                (hash-table-ref ht 'not-a-key (lambda () 'err) values)))
      ;;            test-tables)
      ;;     (map (lambda (ht) 'err) test-tables))

      (test '(err "fever" err err err err err twain err 4 err 4 err stookey err 2)
          (map (lambda (ht key)
                 (guard (exn
                         (else 'err))
                   (hash-table-ref ht key)))
               test-tables
               '(foo 101.3
                     x "y"
                     (14 15) #\newline
                     (edward) (mark)
                     "p" "pref"
                     "mike" "PAUL"
                     jane noel
                     0 4)))

      (test '(eh "fever" eh eh eh eh eh twain eh 4 eh 4 eh stookey eh 2)
          (map (lambda (ht key)
                 (guard (exn
                         (else 'err))
                   (hash-table-ref ht key (lambda () 'eh))))
               test-tables
               '(foo 101.3
                     x "y"
                     (14 15) #\newline
                     (edward) (mark)
                     "p" "pref"
                     "mike" "PAUL"
                     jane noel
                     0 4)))

      (test '(eh ("fever") eh eh eh eh eh (twain) eh (4) eh (4) eh (stookey) eh (2))
          (map (lambda (ht key)
                 (guard (exn
                         (else 'err))
                   (hash-table-ref ht key (lambda () 'eh) list)))
               test-tables
               '(foo 101.3
                     x "y"
                     (14 15) #\newline
                     (edward) (mark)
                     "p" "pref"
                     "mike" "PAUL"
                     jane noel
                     0 4)))

      ;; FIXME: glass-box (implementations not required to raise an exception here)
      ;; (test (map (lambda (ht)
      ;;              (guard (exn
      ;;                      (else 'eh))
      ;;                (hash-table-ref/default ht 'not-a-key 'eh)))
      ;;            test-tables)
      ;;     (map (lambda (ht) 'eh) test-tables))

      (test '(eh "fever" eh eh eh eh eh twain eh 4 eh 4 eh stookey eh 2)
          (map (lambda (ht key)
                 (guard (exn
                         (else 'err))
                   (hash-table-ref/default ht key 'eh)))
               test-tables
               '(foo 101.3
                     x "y"
                     (14 15) #\newline
                     (edward) (mark)
                     "p" "pref"
                     "mike" "PAUL"
                     jane noel
                     0 4)))

      (test '()
          (begin (hash-table-set! ht-fixnum)
                 (list-sort < (hash-table-keys ht-fixnum))))

      (test '(121 144 169)
          (begin (hash-table-set! ht-fixnum 121 11 144 12 169 13)
                 (list-sort < (hash-table-keys ht-fixnum))))

      (test '(0 1 4 9 16 25 36 49 64 81 121 144 169)
          (begin (hash-table-set! ht-fixnum
                                  0 0 1 1 4 2 9 3 16 4 25 5 36 6 49 7 64 8 81 9)
                 (list-sort < (hash-table-keys ht-fixnum))))

      (test '(13 12 11 0 1 2 3 4 5 6 7 8 9)
          (map (lambda (i) (hash-table-ref/default ht-fixnum i 'error))
               '(169 144 121 0 1 4 9 16 25 36 49 64 81)))

      (test '(13 12 11 0 1 2 3 4 5 6 7 8 9)
          (begin (hash-table-delete! ht-fixnum)
                 (map (lambda (i) (hash-table-ref/default ht-fixnum i 'error))
                      '(169 144 121 0 1 4 9 16 25 36 49 64 81))))

      (test '(-1 12 -1 0 -1 2 -1 4 -1 6 -1 8 -1)
          (begin (hash-table-delete! ht-fixnum 1 9 25 49 81 200 121 169 81 1)
                 (map (lambda (i) (hash-table-ref/default ht-fixnum i -1))
                      '(169 144 121 0 1 4 9 16 25 36 49 64 81))))

      (test '(-1 12 -1 -1 -1 2 -1 4 -1 -1 -1 8 -1)
          (begin (hash-table-delete! ht-fixnum 200 100 0 81 36)
                 (map (lambda (i) (hash-table-ref/default ht-fixnum i -1))
                      '(169 144 121 0 1 4 9 16 25 36 49 64 81))))

      (test '(13 12 11 0 1 2 -1 4 -1 -1 -1 8 -1)
          (begin (hash-table-intern! ht-fixnum 169 (lambda () 13))
                 (hash-table-intern! ht-fixnum 121 (lambda () 11))
                 (hash-table-intern! ht-fixnum   0 (lambda ()  0))
                 (hash-table-intern! ht-fixnum   1 (lambda ()  1))
                 (hash-table-intern! ht-fixnum   1 (lambda () 99))
                 (hash-table-intern! ht-fixnum 121 (lambda () 66))
                 (map (lambda (i) (hash-table-ref/default ht-fixnum i -1))
                      '(169 144 121 0 1 4 9 16 25 36 49 64 81))))

      (test '(#(0 0) #(1 1) #(4 2) #(16 4) #(64 8) #(121 11) #(144 12) #(169 13))
          (list-sort (lambda (v1 v2) (< (vector-ref v1 0) (vector-ref v2 0)))
                     (hash-table-map->list vector ht-fixnum)))

      (test (begin (hash-table-intern! ht-fixnum 169 (lambda () 13))
                   (hash-table-intern! ht-fixnum 144 (lambda () 9999))
                   (hash-table-intern! ht-fixnum 121 (lambda () 11))
                   (list-sort (lambda (l1 l2)
                                (< (car l1) (car l2)))
                              (hash-table-map->list list ht-fixnum)))
          '((0 0) (1 1) (4 2) (16 4) (64 8) (121 11) (144 12) (169 13)))

      (test (begin (hash-table-update! ht-fixnum 9 length (lambda () '(a b c)))
                   (map (lambda (i) (hash-table-ref/default ht-fixnum i -1))
                        '(169 144 121 0 1 4 9 16 25 36 49 64 81)))
          '(13 12 11 0 1 2 3 4 -1 -1 -1 8 -1))

      (test (begin (hash-table-update! ht-fixnum 16 -)
                   (map (lambda (i) (hash-table-ref/default ht-fixnum i -1))
                        '(169 144 121 0 1 4 9 16 25 36 49 64 81)))
          '(13 12 11 0 1 2 3 -4 -1 -1 -1 8 -1))

      (test (begin (hash-table-update! ht-fixnum 16 - abs)
                   (map (lambda (i) (hash-table-ref/default ht-fixnum i -1))
                        '(169 144 121 0 1 4 9 16 25 36 49 64 81)))
          '(13 12 11 0 1 2 3 4 -1 -1 -1 8 -1))

      (test (begin (hash-table-update!/default ht-fixnum 25 - 5)
                   (map (lambda (i) (hash-table-ref/default ht-fixnum i -1))
                        '(169 144 121 0 1 4 9 16 25 36 49 64 81)))
          '(13 12 11 0 1 2 3 4 -5 -1 -1 8 -1))

      (test (begin (hash-table-update!/default ht-fixnum 25 - 999)
                   (map (lambda (i) (hash-table-ref/default ht-fixnum i -1))
                        '(169 144 121 0 1 4 9 16 25 36 49 64 81)))
          '(13 12 11 0 1 2 3 4 5 -1 -1 8 -1))

      (test '(#t #t)
          (let* ((n0 (hash-table-size ht-fixnum))
                 (ht (hash-table-copy ht-fixnum #t)))
            (call-with-values
                (lambda () (hash-table-pop! ht))
              (lambda (key val)
                (list (= key (* val val))
                      (= (- n0 1) (hash-table-size ht)))))))

      (test '(13 12 11 0 1 2 3 4 5 -1 -1 8 -1 -1)
          (begin (hash-table-delete! ht-fixnum 75)
                 (map (lambda (i) (hash-table-ref/default ht-fixnum i -1))
                      '(169 144 121 0 1 4 9 16 25 36 49 64 75 81))))

      (test '(13 12 11 0 1 2 3 4 5 -1 -1 8 -1)
          (map (lambda (i) (hash-table-ref/default ht-fixnum i -1))
               '(169 144 121 0 1 4 9 16 25 36 49 64 81)))

      (test '(13 12 11 0 1 2 3 4 5 6 -1 8 9)
          (begin (hash-table-set! ht-fixnum 36 6)
                 (hash-table-set! ht-fixnum 81 9)
                 (map (lambda (i) (hash-table-ref/default ht-fixnum i -1))
                      '(169 144 121 0 1 4 9 16 25 36 49 64 81))))

      (test 0
          (begin (hash-table-clear! ht-eq)
                 (hash-table-size ht-eq)))

      ;; The whole hash table.

      (test 3
          (begin (hash-table-set! ht-eq 'foo 13 'bar 14 'baz 18)
                 (hash-table-size ht-eq)))

      (test '(0 3 #t)
          (let* ((ht (hash-table-empty-copy ht-eq))
                 (n0 (hash-table-size ht))
                 (ignored (hash-table-set! ht 'foo 13 'bar 14 'baz 18))
                 (n1 (hash-table-size ht)))
            (list n0 n1 (hash-table=? default-comparator ht ht-eq))))

      (test 0
          (begin (hash-table-clear! ht-eq)
                 (hash-table-size ht-eq)))

      (test '(144 12)
          (hash-table-find (lambda (key val)
                             (if (= 144 key (* val val))
                                 (list key val)
                                 #f))
                           ht-fixnum
                           (lambda () 99)))

      (test 99
          (hash-table-find (lambda (key val)
                             (if (= 144 key val)
                                 (list key val)
                                 #f))
                           ht-fixnum
                           (lambda () 99)))

      (test 2
          (hash-table-count <= ht-fixnum))

      ;; Mapping and folding.

      (test '(0 1 2 3 4 5 6 -1 8 9 -1 11 12 13 -1)
          (map (lambda (i) (hash-table-ref/default ht-fixnum i -1))
               '(0 1 4 9 16 25 36 49 64 81 100 121 144 169 196)))

      (test '(0 1 4 9 16 25 36 -1 64 81 -1 121 144 169 -1)
          (let ((ht (hash-table-map (lambda (val) (* val val))
                                    eqv-comparator
                                    ht-fixnum)))
            (map (lambda (i) (hash-table-ref/default ht i -1))
                 '(0 1 4 9 16 25 36 49 64 81 100 121 144 169 196))))

      (test '(#(0 1 4 9 16 25 36 -1 64 81 -1 121 144 169 -1)
              #(0 1 2 3  4  5  6 -1  8  9 -1  11  12  13 -1))
          (let ((keys (make-vector 15 -1))
                (vals (make-vector 15 -1)))
            (hash-table-for-each (lambda (key val)
                                   (vector-set! keys val key)
                                   (vector-set! vals val val))
                                 ht-fixnum)
            (list keys vals)))

      (test '(0 1 2 3 -4 -5 -6 -1 -8 -9 -1 -11 -12 -13 -1)
          (begin (hash-table-map! (lambda (key val)
                                    (if (<= 10 key)
                                        (- val)
                                        val))
                                  ht-fixnum)
                 (map (lambda (i) (hash-table-ref/default ht-fixnum i -1))
                      '(0 1 4 9 16 25 36 49 64 81 100 121 144 169 196))))

      (test 13
          (hash-table-fold (lambda (key val acc)
                             (+ val acc))
                           0
                           ht-string-ci2))

      (test '(0 1 4 9 16 25 36 64 81 121 144 169)
          (list-sort < (hash-table-fold (lambda (key val acc)
                                          (cons key acc))
                                        '()
                                        ht-fixnum)))

      ;; Copying and conversion.

      (test #t
          (hash-table=? number-comparator ht-fixnum (hash-table-copy ht-fixnum)))

      (test #t
          (hash-table=? number-comparator ht-fixnum (hash-table-copy ht-fixnum #f)))

      (test #t
          (hash-table=? number-comparator ht-fixnum (hash-table-copy ht-fixnum #t)))

      (test #f
          (hash-table-mutable? (hash-table-copy ht-fixnum)))

      (test #f
          (hash-table-mutable? (hash-table-copy ht-fixnum #f)))

      (test #t
          (hash-table-mutable? (hash-table-copy ht-fixnum #t)))

      (test '()
          (hash-table->alist ht-eq))

      (test '((0 . 0)
              (1 . 1)
              (4 . 2)
              (9 . 3)
              (16 . -4)
              (25 . -5)
              (36 . -6)
              (64 . -8)
              (81 . -9)
              (121 . -11)
              (144 . -12)
              (169 . -13))
          (list-sort (lambda (x y) (< (car x) (car y)))
                     (hash-table->alist ht-fixnum)))

      ;; Hash tables as sets.

      (test '((0 . 0)
              (1 . 1)
              (4 . 2)
              (9 . 3)
              (16 . -4)
              (25 . -5)
              (36 . -6)
              (49 . 7)
              (64 . -8)
              (81 . -9)
              (121 . -11)
              (144 . -12)
              (169 . -13))
          (begin (hash-table-union! ht-fixnum ht-fixnum2)
                 (list-sort (lambda (x y) (< (car x) (car y)))
                            (hash-table->alist ht-fixnum))))

      (test '((0 . 0)
              (1 . 1)
              (4 . 2)
              (9 . 3)
              (16 . 4)
              (25 . 5)
              (36 . 6)
              (49 . 7)
              (64 . 8)
              (81 . 9)
              (121 . -11)
              (144 . -12)
              (169 . -13))
          (let ((ht (hash-table-copy ht-fixnum2 #t)))
            (hash-table-union! ht ht-fixnum)
            (list-sort (lambda (x y) (< (car x) (car y)))
                       (hash-table->alist ht))))

      (test #t
          (begin (hash-table-union! ht-eqv2 ht-fixnum)
                 (hash-table=? default-comparator ht-eqv2 ht-fixnum)))

      (test #t
          (begin (hash-table-intersection! ht-eqv2 ht-fixnum)
                 (hash-table=? default-comparator ht-eqv2 ht-fixnum)))

      (test #t
          (begin (hash-table-intersection! ht-eqv2 ht-eqv)
                 (hash-table-empty? ht-eqv2)))

      (test '((0 . 0)
              (1 . 1)
              (4 . 2)
              (9 . 3)
              (16 . -4)
              (25 . -5)
              (36 . -6)
              (49 . 7)
              (64 . -8)
              (81 . -9))
          (begin (hash-table-intersection! ht-fixnum ht-fixnum2)
                 (list-sort (lambda (x y) (< (car x) (car y)))
                            (hash-table->alist ht-fixnum))))

      (test '((4 . 2)
              (25 . -5))
          (begin (hash-table-intersection!
                  ht-fixnum
                  (alist->hash-table '((-1 . -1) (4 . 202) (25 . 205) (100 . 10))
                                     number-comparator))
                 (list-sort (lambda (x y) (< (car x) (car y)))
                            (hash-table->alist ht-fixnum))))

      (test '((0 . 0)
              (1 . 1)
              (9 . 3)
              (16 . 4)
              (36 . 6)
              (49 . 7)
              (64 . 8)
              (81 . 9))
          (let ((ht (hash-table-copy ht-fixnum2 #t)))
            (hash-table-difference!
             ht
             (alist->hash-table '((-1 . -1) (4 . 202) (25 . 205) (100 . 10))
                                number-comparator))
            (list-sort (lambda (x y) (< (car x) (car y)))
                       (hash-table->alist ht))))

      (test '((-1 . -1)
              (0 . 0)
              (1 . 1)
              (9 . 3)
              (16 . 4)
              (36 . 6)
              (49 . 7)
              (64 . 8)
              (81 . 9)
              (100 . 10))
          (let ((ht (hash-table-copy ht-fixnum2 #t)))
            (hash-table-xor!
             ht
             (alist->hash-table '((-1 . -1) (4 . 202) (25 . 205) (100 . 10))
                                number-comparator))
            (list-sort (lambda (x y) (< (car x) (car y)))
                       (hash-table->alist ht))))

      (test 'key-not-found
          (guard (exn
                  (else 'key-not-found))
            (hash-table-ref ht-default "this key won't be present")))

      ;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      ;;
      ;; Desultory tests of deprecated procedures and usages.
      ;; Deprecated usage of make-hash-table and alist->hash-table
      ;; has already been tested above.
      ;;
      ;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

      (test '(#t #t #t)
          (let* ((x (list 1 2 3))
                 (y (cons 1 (cdr x)))
                 (h1 (hash x))
                 (h2 (hash y)))
            (list (exact-integer? h1)
                  (exact-integer? h2)
                  (= h1 h2))))

      (test '(#t #t #t)
          (let* ((x "abcd")
                 (y (string-append "ab" "cd"))
                 (h1 (string-hash x))
                 (h2 (string-hash y)))
            (list (exact-integer? h1)
                  (exact-integer? h2)
                  (= h1 h2))))

      (test '(#t #t #t)
          (let* ((x "Hello There!")
                 (y "hello THERE!")
                 (h1 (string-ci-hash x))
                 (h2 (string-ci-hash y)))
            (list (exact-integer? h1)
                  (exact-integer? h2)
                  (= h1 h2))))

      (test '(#t #t #t)
          (let* ((x '#(a "bcD" #\c (d 2.718) -42 #u8() #() #u8(19 20)))
                 (y x)
                 (h1 (hash-by-identity x))
                 (h2 (hash-by-identity y)))
            (list (exact-integer? h1)
                  (exact-integer? h2)
                  (= h1 h2))))

      (test '(#t #t #t)
          (let* ((x (list 1 2 3))
                 (y (cons 1 (cdr x)))
                 (h1 (hash x 60))
                 (h2 (hash y 60)))
            (list (exact-integer? h1)
                  (exact-integer? h2)
                  (= h1 h2))))

      (test '(#t #t #t)
          (let* ((x "abcd")
                 (y (string-append "ab" "cd"))
                 (h1 (string-hash x 97))
                 (h2 (string-hash y 97)))
            (list (exact-integer? h1)
                  (exact-integer? h2)
                  (= h1 h2))))

      (test '(#t #t #t)
          (let* ((x "Hello There!")
                 (y "hello THERE!")
                 (h1 (string-ci-hash x 101))
                 (h2 (string-ci-hash y 101)))
            (list (exact-integer? h1)
                  (exact-integer? h2)
                  (= h1 h2))))

      (test '(#t #t #t)
          (let* ((x '#(a "bcD" #\c (d 2.718) -42 #u8() #() #u8(19 20)))
                 (y x)
                 (h1 (hash-by-identity x 102))
                 (h2 (hash-by-identity y 102)))
            (list (exact-integer? h1)
                  (exact-integer? h2)
                  (= h1 h2))))

      (test #t
          (let ((f (hash-table-equivalence-function ht-fixnum)))
            (if (procedure? f)
                (f 34 34)
                #t)))

      (test #t
          (let ((f (hash-table-hash-function ht-fixnum)))
            (if (procedure? f)
                (= (f 34) (f 34))
                #t)))

      (test '(#t #t #f #f #t #f #f #f #f #t #f)
          (map (lambda (key) (hash-table-exists? ht-fixnum2 key))
               '(0 1 2 3 4 5 6 7 8 9 10)))

      (test (apply +
                   (map (lambda (x) (* x x))
                        '(0 1 2 3 4 5 6 7 8 9)))
          (let ((n 0))
            (hash-table-walk ht-fixnum2
                             (lambda (key val) (set! n (+ n key))))
            n))

      (test '(0 1 4 9 16 25 36 49 64 81)
          (list-sort < (hash-table-fold ht-fixnum2
                                        (lambda (key val acc)
                                          (cons key acc))
                                        '())))

      (test '((0 . 0)
              (.25 . .5)
              (1 . 1)
              (4 . 2)
              (9 . 3)
              (16 . 4)
              (25 . 5)
              (36 . 6)
              (49 . 7)
              (64 . 8)
              (81 . 9)
              (121 . -11)
              (144 . -12))
          (let ((ht (hash-table-copy ht-fixnum2 #t))
                (ht2 (hash-table number-comparator
                                 .25 .5 64 9999 81 9998 121 -11 144 -12)))
            (hash-table-merge! ht ht2)
            (list-sort (lambda (x y) (< (car x) (car y)))
                       (hash-table->alist ht))))

      (test-end))))

(define-library (srfi 1)
  (export
   xcons cons* make-list list-tabulate list-copy circular-list iota
   proper-list? circular-list? dotted-list? not-pair? null-list? list=
   first second third fourth fifth sixth seventh eighth ninth tenth
   car+cdr take drop take-right drop-right take! drop-right! split-at split-at!
   last last-pair length+ concatenate append! concatenate! reverse!
   append-reverse append-reverse!
   zip unzip1 unzip2 unzip3 unzip4 unzip5 count
   fold unfold pair-fold reduce fold-right unfold-right
   pair-fold-right reduce-right
   append-map append-map! map! pair-for-each filter-map map-in-order
   filter partition remove filter! partition! remove! find find-tail any every
   list-index take-while drop-while take-while! span break span! break!
   delete delete-duplicates delete! delete-duplicates!
   alist-cons alist-copy alist-delete alist-delete!
   lset<= lset= lset-adjoin lset-union lset-union! lset-intersection
   lset-intersection! lset-difference lset-difference! lset-xor lset-xor!
   lset-diff+intersection lset-diff+intersection!)
  (cond-expand
   (chibi
    (import (chibi)))
   (else
    (import (scheme base))
    (begin
      (define reverse! reverse)
      (define (find-tail pred ls)
        (and (pair? ls) (if (pred (car ls)) ls (find-tail pred (cdr ls)))))
      (define (find pred ls)
        (cond ((find-tail pred ls) => car) (else #f)))
      (define (any pred ls . lol)
        (define (any1 pred ls)
          (if (pair? (cdr ls))
              ((lambda (x) (if x x (any1 pred (cdr ls)))) (pred (car ls)))
              (pred (car ls))))
        (define (anyn pred lol)
          (if (every pair? lol)
              ((lambda (x) (if x x (anyn pred (map cdr lol))))
               (apply pred (map car lol)))
              #f))
        (if (null? lol)
            (if (pair? ls) (any1 pred ls) #f)
            (anyn pred (cons ls lol))))
      (define (every pred ls . lol)
        (define (every1 pred ls)
          (if (null? (cdr ls))
              (pred (car ls))
              (if (pred (car ls)) (every1 pred (cdr ls)) #f)))
        (if (null? lol)
            (if (pair? ls) (every1 pred ls) #t)
            (not (apply any (lambda xs (not (apply pred xs))) ls lol))))
      )))
  (include "1/predicates.scm"
           "1/selectors.scm"
           "1/search.scm"
           "1/misc.scm"
           "1/constructors.scm"
           "1/fold.scm"
           "1/deletion.scm"
           "1/alists.scm"
           "1/lset.scm"))
;; interface.scm -- hash-table interface
;; Copyright (c) 2009-2017 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

;; the non-exported hash-table-cell is the heart of the implemenation

(define (make-hash-table . o)
  (let* ((eq-fn (if (pair? o) (car o) equal?))
         (hash-fn (if (and (pair? o) (pair? (cdr o)))
                      (car (cdr o))
                      (if (eq? eq? eq-fn) hash-by-identity hash))))
    (cond
     ((not (procedure? eq-fn))
      (error "make-hash-table: bad equivalence function" eq-fn))
     ((not (procedure? hash-fn))
      (error "make-hash-table: bad hash function" hash-fn))
     (else
      (%make-hash-table
       (make-vector 23 '())
       0
       (if (eq? hash-fn hash-by-identity) 1 (if (eq? hash-fn hash) 2 hash-fn))
       (if (eq? eq-fn eq?) 1 (if (eq? eq-fn equal?) 2 eq-fn)))))))

(define (hash-table-hash-function table)
  (let ((f (%hash-table-hash-function table)))
    (case f ((1) hash-by-identity) ((2) hash) (else f))))

(define (hash-table-equivalence-function table)
  (let ((f (%hash-table-equivalence-function table)))
    (case f ((1) eq?) ((2) equal?) (else f))))

(define-syntax assert-hash-table
  (syntax-rules ()
    ((assert-hash-table from obj)
     (if (not (hash-table? obj))
         (error (string-append from ": not a Hash-Table") obj)))))

(define (hash-table-ref table key . o)
  (assert-hash-table "hash-table-ref" table)
  (let ((cell (hash-table-cell table key #f)))
    (cond (cell (if (and (pair? o) (pair? (cdr o)))
                    ((cadr o) (cdr cell))
                    (cdr cell)))
          ((pair? o) ((car o)))
          (else (error "hash-table-ref: key not found" key)))))

(define (hash-table-ref/default table key default)
  (assert-hash-table "hash-table-ref/default" table)
  (let ((cell (hash-table-cell table key #f)))
    (if cell (cdr cell) default)))

(define (hash-table-set! table key value)
  (assert-hash-table "hash-table-set!" table)
  (let ((cell (hash-table-cell table key #t)))
    (set-cdr! cell value)))

(define (hash-table-exists? table key)
  (assert-hash-table "hash-table-exists?" table)
  (and (hash-table-cell table key #f) #t))

(define hash-table-update!
  (let ((not-found (cons 'not-found '())))
    (lambda (table key func . o)
      (assert-hash-table "hash-table-update!" table)
      (let ((cell (hash-table-cell table key not-found)))
        (set-cdr! cell (if (eq? not-found (cdr cell))
                           (if (pair? o)
                               (func ((car o)))
                               (error "hash-table-update!: key not found" key))
                           (func (if (and (pair? o) (pair? (cdr o)))
                                     ((cadr o) (cdr cell))
                                     (cdr cell)))))))))

(define hash-table-update!/default
  (let ((not-found (cons 'not-found '())))
    (lambda (table key func default)
      (assert-hash-table "hash-table-update!/default" table)
      (let ((cell (hash-table-cell table key not-found)))
        (set-cdr! cell (func (if (eq? not-found (cdr cell)) default (cdr cell))))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define (hash-table-fold table kons knil)
  (assert-hash-table "hash-table-fold" table)
  (let ((vec (hash-table-buckets table)))
    (let lp1 ((i (- (vector-length vec) 1)) (acc knil))
      (if (< i 0)
          acc
          (let lp2 ((ls (vector-ref vec i)) (acc acc))
            (if (null? ls)
                (lp1 (- i 1) acc)
                (lp2 (cdr ls) (kons (car (car ls)) (cdr (car ls)) acc))))))))

(define (hash-table-walk table proc)
  (hash-table-fold table (lambda (k v a) (proc k v)) #f)
  (if #f #f))

(define (hash-table->alist table)
  (hash-table-fold table (lambda (k v a) (cons (cons k v) a)) '()))

(define (hash-table-keys table)
  (hash-table-fold table (lambda (k v a) (cons k a)) '()))

(define (hash-table-values table)
  (hash-table-fold table (lambda (k v a) (cons v a)) '()))

(define (alist->hash-table ls . o)
  (let ((res (apply make-hash-table o)))
    (for-each (lambda (x) (hash-table-set! res (car x) (cdr x))) ls)
    res))

(define (hash-table-merge! a b)
  (hash-table-walk b (lambda (k v)
                       (if (not (hash-table-exists? a k))
                           (hash-table-set! a k v))))
  a)

(define (hash-table-copy table)
  (assert-hash-table "hash-table-copy" table)
  (let ((res (make-hash-table (hash-table-equivalence-function table)
                              (hash-table-hash-function table))))
    (hash-table-merge! res table)
    res))
;; types.scm -- the hash-table record type
;; Copyright (c) 2009-2011 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

(define-record-type Hash-Table
  (%make-hash-table buckets size hash-fn eq-fn)
  hash-table?
  (buckets hash-table-buckets hash-table-buckets-set!)
  (size hash-table-size hash-table-size-set!)
  (hash-fn %hash-table-hash-function)
  (eq-fn %hash-table-equivalence-function))

(define-library (srfi 69 test)
  (export run-tests)
  (import (chibi) (srfi 1) (srfi 69) (chibi test))
  (begin
    (define (run-tests)

      (define-syntax test-lset-eq?
        (syntax-rules ()
          ((test-lset= . args)
           (test-equal (lambda (a b) (lset= eq? a b)) . args))))

      (define-syntax test-lset-equal?
        (syntax-rules ()
          ((test-lset-equal? . args)
           (test-equal (lambda (a b) (lset= equal? a b)) . args))))

      (test-begin "srfi-69: hash-tables")

      (let ((ht (make-hash-table eq?)))
        ;; 3 initial elements
        (test 0 (hash-table-size ht))
        (hash-table-set! ht 'cat 'black)
        (hash-table-set! ht 'dog 'white)
        (hash-table-set! ht 'elephant 'pink)
        (test 3 (hash-table-size ht))
        (test-assert (hash-table-exists? ht 'dog))
        (test-assert (hash-table-exists? ht 'cat))
        (test-assert (hash-table-exists? ht 'elephant))
        (test-not (hash-table-exists? ht 'goose))
        (test 'white (hash-table-ref ht 'dog))
        (test 'black (hash-table-ref ht 'cat))
        (test 'pink (hash-table-ref ht 'elephant))
        (test-error (hash-table-ref ht 'goose))
        (test 'grey (hash-table-ref ht 'goose (lambda () 'grey)))
        (test 'grey (hash-table-ref/default ht 'goose 'grey))
        (test-lset-eq? '(cat dog elephant) (hash-table-keys ht))
        (test-lset-eq? '(black white pink) (hash-table-values ht))
        (test-lset-equal? '((cat . black) (dog . white) (elephant . pink))
                          (hash-table->alist ht))

        ;; remove an element
        (hash-table-delete! ht 'dog)
        (test 2 (hash-table-size ht))
        (test-not (hash-table-exists? ht 'dog))
        (test-assert (hash-table-exists? ht 'cat))
        (test-assert (hash-table-exists? ht 'elephant))
        (test-error (hash-table-ref ht 'dog))
        (test 'black (hash-table-ref ht 'cat))
        (test 'pink (hash-table-ref ht 'elephant))
        (test-lset-eq? '(cat elephant) (hash-table-keys ht))
        (test-lset-eq? '(black pink) (hash-table-values ht))
        (test-lset-equal? '((cat . black) (elephant . pink)) (hash-table->alist ht))

        ;; remove a non-existing element
        (hash-table-delete! ht 'dog)
        (test 2 (hash-table-size ht))
        (test-not (hash-table-exists? ht 'dog))

        ;; overwrite an existing element
        (hash-table-set! ht 'cat 'calico)
        (test 2 (hash-table-size ht))
        (test-not (hash-table-exists? ht 'dog))
        (test-assert (hash-table-exists? ht 'cat))
        (test-assert (hash-table-exists? ht 'elephant))
        (test-error (hash-table-ref ht 'dog))
        (test 'calico (hash-table-ref ht 'cat))
        (test 'pink (hash-table-ref ht 'elephant))
        (test-lset-eq? '(cat elephant) (hash-table-keys ht))
        (test-lset-eq? '(calico pink) (hash-table-values ht))
        (test-lset-equal? '((cat . calico) (elephant . pink)) (hash-table->alist ht))

        ;; walk and fold
        (test-lset-equal?
         '((cat . calico) (elephant . pink))
         (let ((a '()))
           (hash-table-walk ht (lambda (k v) (set! a (cons (cons k v) a))))
           a))
        (test-lset-equal? '((cat . calico) (elephant . pink))
                          (hash-table-fold ht (lambda (k v a) (cons (cons k v) a)) '()))

        ;; copy
        (let ((ht2 (hash-table-copy ht)))
          (test 2 (hash-table-size ht2))
          (test-not (hash-table-exists? ht2 'dog))
          (test-assert (hash-table-exists? ht2 'cat))
          (test-assert (hash-table-exists? ht2 'elephant))
          (test-error (hash-table-ref ht2 'dog))
          (test 'calico (hash-table-ref ht2 'cat))
          (test 'pink (hash-table-ref ht2 'elephant))
          (test-lset-eq? '(cat elephant) (hash-table-keys ht2))
          (test-lset-eq? '(calico pink) (hash-table-values ht2))
          (test-lset-equal? '((cat . calico) (elephant . pink))
                            (hash-table->alist ht2)))

        ;; merge
        (let ((ht2 (make-hash-table eq?)))
          (hash-table-set! ht2 'bear 'brown)
          (test 1 (hash-table-size ht2))
          (test-not (hash-table-exists? ht2 'dog))
          (test-assert (hash-table-exists? ht2 'bear))
          (hash-table-merge! ht2 ht)
          (test 3 (hash-table-size ht2))
          (test-assert (hash-table-exists? ht2 'bear))
          (test-assert (hash-table-exists? ht2 'cat))
          (test-assert (hash-table-exists? ht2 'elephant))
          (test-not (hash-table-exists? ht2 'goose))
          (test 'brown (hash-table-ref ht2 'bear))
          (test 'calico (hash-table-ref ht2 'cat))
          (test 'pink (hash-table-ref ht2 'elephant))
          (test-error (hash-table-ref ht2 'goose))
          (test 'grey (hash-table-ref/default ht2 'goose 'grey))
          (test-lset-eq? '(bear cat elephant) (hash-table-keys ht2))
          (test-lset-eq? '(brown calico pink) (hash-table-values ht2))
          (test-lset-equal? '((cat . calico) (bear . brown) (elephant . pink))
                            (hash-table->alist ht2)))

        ;; alist->hash-table
        (test-lset-equal? (hash-table->alist ht)
                          (hash-table->alist
                           (alist->hash-table
                            '((cat . calico) (elephant . pink))))))

      ;; update
      (let ((ht (make-hash-table eq?))
            (add1 (lambda (x) (+ x 1))))
        (hash-table-set! ht 'sheep 0)
        (hash-table-update! ht 'sheep add1)
        (hash-table-update! ht 'sheep add1)
        (test 2 (hash-table-ref ht 'sheep))
        (hash-table-update!/default ht 'crows add1 0)
        (hash-table-update!/default ht 'crows add1 0)
        (hash-table-update!/default ht 'crows add1 0)
        (test 3 (hash-table-ref ht 'crows)))

      ;; string keys
      (let ((ht (make-hash-table equal?)))
        (hash-table-set! ht "cat" 'black)
        (hash-table-set! ht "dog" 'white)
        (hash-table-set! ht "elephant" 'pink)
        (hash-table-ref/default ht "dog" #f)
        (test 'white (hash-table-ref ht "dog"))
        (test 'black (hash-table-ref ht "cat"))
        (test 'pink (hash-table-ref ht "elephant"))
        (test-error (hash-table-ref ht "goose"))
        (test 'grey (hash-table-ref/default ht "goose" 'grey))
        (test-lset-equal? '("cat" "dog" "elephant") (hash-table-keys ht))
        (test-lset-equal? '(black white pink) (hash-table-values ht))
        (test-lset-equal?
         '(("cat" . black) ("dog" . white) ("elephant" . pink))
         (hash-table->alist ht)))

      ;; string-ci keys
      (let ((ht (make-hash-table string-ci=? string-ci-hash)))
        (hash-table-set! ht "cat" 'black)
        (hash-table-set! ht "dog" 'white)
        (hash-table-set! ht "elephant" 'pink)
        (hash-table-ref/default ht "DOG" #f)
        (test 'white (hash-table-ref ht "DOG"))
        (test 'black (hash-table-ref ht "Cat"))
        (test 'pink (hash-table-ref ht "eLePhAnT"))
        (test-error (hash-table-ref ht "goose"))
        (test-lset-equal? '("cat" "dog" "elephant") (hash-table-keys ht))
        (test-lset-equal? '(black white pink) (hash-table-values ht))
        (test-lset-equal?
         '(("cat" . black) ("dog" . white) ("elephant" . pink))
         (hash-table->alist ht)))

      ;; Exception values - this works because the return value from the
      ;; primitives is a cell, and we use the cdr opcode to retrieve the
      ;; cell value.  Thus there is no FFI issue with storing exceptions.
      (let ((ht (make-hash-table)))
        (hash-table-set! ht 'boom (make-exception 'my-exn-type "boom!" '() #f #f))
        (test 'my-exn-type (exception-kind (hash-table-ref ht 'boom))))

      ;; stress test
      (test 625
          (let ((ht (make-hash-table)))
            (do ((i 0 (+ i 1))) ((= i 1000))
              (hash-table-set! ht i (* i i)))
            (hash-table-ref/default ht 25 #f)))

      (test-end))))
;; Copyright (C) Marc Nieper-Wikirchen (2019).  All Rights Reserved.

;; Permission is hereby granted, free of charge, to any person
;; obtaining a copy of this software and associated documentation
;; files (the "Software"), to deal in the Software without
;; restriction, including without limitation the rights to use, copy,
;; modify, merge, publish, distribute, sublicense, and/or sell copies
;; of the Software, and to permit persons to whom the Software is
;; furnished to do so, subject to the following conditions:

;; The above copyright notice and this permission notice (including
;; the next paragraph) shall be included in all copies or substantial
;; portions of the Software.

;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
;; EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
;; MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
;; NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
;; BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
;; ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
;; CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
;; SOFTWARE.

(define-record-type Computation-Environment-Variable
  (make-environment-variable name default immutable? id)
  environment-variable?
  (name environment-variable-name)
  (default environment-variable-default)
  (immutable? environment-variable-immutable?)
  (id environment-variable-id))

(define make-computation-environment-variable
  (let ((count 0))
    (lambda (name default immutable?)
      (set! count (+ count 1))
      (make-environment-variable name default immutable? (- count)))))

(define (predefined? var)
  (not (negative? (environment-variable-id var))))

(define variable-comparator
  (make-comparator environment-variable?
                   eq?
                   (lambda (x y)
                     (< (environment-variable-id x)
                        (environment-variable-id y)))
                   (lambda (x . y)
                     (environment-variable-id x))))

(define default-computation
  (make-computation-environment-variable 'default-computation #f #f))

(define (environment-global env)
  (vector-ref env 0))

(define (environment-local env)
  (vector-ref env 1))

(define (environment-set-global! env global)
  (vector-set! env 0 global))

(define (environment-set-local! env local)
  (vector-set! env 1 local))

(define (environment-cell-set! env var box)
  (vector-set! env (+ 2 (environment-variable-id var)) box))

(define (environment-cell env var)
  (vector-ref env (+ 2 (environment-variable-id var))))

(define-syntax define-computation-type
  (syntax-rules ()
    ((define-computation-type make-environment run var ...)
     (%define-computation-type make-environment run (var ...) 0 ()))))

(define-syntax %define-computation-type
  (syntax-rules ()
    ((_ make-environment run () n ((var default e immutable i) ...))
     (begin
       (define-values (e ...) (values default ...))
       (define var (make-environment-variable 'var e immutable i))
       ...
       (define (make-environment)
         (let ((env (make-vector (+ n 2))))
           (environment-set-global! env (hash-table variable-comparator))
           (environment-set-local! env (mapping variable-comparator))
           (vector-set! env (+ i 2) (box e))
           ...
           env))
       (define (run computation)
         (execute computation (make-environment)))))
    ((_ make-environment run ((v d) . v*) n (p ...))
     (%define-computation-type make-environment run v* (+ n 1) (p ... (v d e #f n))))
    ((_ make-environment run ((v d "immutable") . v*) n (p ...))
     (%define-computation-type make-environment run v* (+ n 1) (p ... (v d e #t n))))
    ((_ make-environment run (v . v*) n (p ...))
     (%define-computation-type make-environment run v* (+ n 1) (p ... (v #f e #f n))))))

(define-computation-type make-computation-environment computation-run)

(define (computation-environment-ref env var)
  (if (predefined? var)
      (unbox (environment-cell env var))
      (mapping-ref
       (environment-local env)
       var
       (lambda ()
         (hash-table-ref/default (environment-global env)
                                 var
                                 (environment-variable-default var)))
       unbox)))

(define (computation-environment-update env . arg*)
  (let ((new-env (vector-copy env)))
    (let loop ((arg* arg*)
               (local (environment-local env)))
      (if (null? arg*)
          (begin
            (environment-set-local! new-env local)
            new-env)
          (let ((var (car arg*))
                (val (cadr arg*)))
            (if (predefined? var)
                (begin
                  (environment-cell-set! new-env var (box val))
                  (loop (cddr arg*) local))
                (loop (cddr arg*) (mapping-set local var (box val)))))))))

(define (computation-environment-update! env var val)
  (if (predefined? var)
      (set-box! (environment-cell env var) val)
      (mapping-ref (environment-local env)
                   var
                   (lambda ()
                     (hash-table-set! (environment-global env) var val))
                   (lambda (cell)
                     (set-box! cell val)))))

(define (computation-environment-copy env)
  (let ((global (hash-table-copy (environment-global env) #t)))
    (mapping-for-each (lambda (var cell)
                        (hash-table-set! global var (unbox cell)))
                      (environment-local env))
    (let ((new-env (make-vector (vector-length env))))
      (environment-set-global! new-env global)
      (environment-set-local! new-env (mapping variable-comparator))
      (do ((i (- (vector-length env) 1) (- i 1)))
          ((< i 2)
           new-env)
        (vector-set! new-env i (box (unbox (vector-ref env i))))))))

(define (execute computation env)
  (let ((coerce (if (procedure? computation)
                    values
                    (or (computation-environment-ref env default-computation)
                        (error "not a computation" computation)))))
    ((coerce computation) env)))

(define (make-computation proc)
  (lambda (env)
    (proc (lambda (c) (execute c env)))))

(define (computation-pure . args)
  (make-computation
   (lambda (compute)
     (apply values args))))

(define (computation-each a . a*)
  (computation-each-in-list (cons a a*)))

(define (computation-each-in-list a*)
  (make-computation
   (lambda (compute)
     (let loop ((a (car a*)) (a* (cdr a*)))
       (if (null? a*)
           (compute a)
           (begin
             (compute a)
             (loop (car a*) (cdr a*))))))))

(define (computation-bind a . f*)
  (make-computation
   (lambda (compute)
     (let loop ((a a) (f* f*))
       (if (null? f*)
           (compute a)
           (loop (call-with-values
                     (lambda () (compute a))
                   (car f*))
                 (cdr f*)))))))

(define (computation-ask)
  (lambda (env)
    env))

(define (computation-local updater computation)
  (lambda (env)
    (computation (updater env))))

(define-syntax computation-fn
  (syntax-rules ()
    ((_ (clause ...) expr ... computation)
     (%fn (clause ...) () expr ... computation))))

(define-syntax %fn
  (syntax-rules ()
    ((_ () ((id var tmp) ...) expr ... computation)
     (let ((tmp var) ...)
       (computation-bind
        (computation-ask)
        (lambda (env)
          (let ((id (computation-environment-ref env tmp)) ...)
            expr ...
            computation)))))
    ((_ ((id var) . rest) (p ...) expr ... computation)
     (%fn rest (p ... (id var tmp)) expr ... computation))
    ((_ (id . rest) (p ...) expr ... computation)
     (%fn rest (p ... (id id tmp)) expr ... computation))))

(define-syntax computation-with
  (syntax-rules ()
    ((_ ((var val) ...) a* ... a)
     (%with ((var val) ...) () () a* ... a))))

(define-syntax %with
  (syntax-rules ()
    ((_ () ((x u) ...) ((a b) ...))
     (let ((u x) ... (b a) ...)
       (computation-local
        (lambda (env)
          (computation-environment-update env u ...) )
        (computation-each b ...))))
    ((_ ((var val) . rest) (p ...) () a* ...)
     (%with rest (p ... (var u) (val v)) () a* ...))
    ((_ () p* (q ...) a . a*)
     (%with () p* (q ... (a b)) . a*))))

(define-syntax computation-with!
  (syntax-rules ()
    ((_ (var val) ...)
     (%with! (var val) ... ()))))

(define-syntax %with!
  (syntax-rules ()
    ((_ ((var u val v) ...))
     (let ((u var) ... (v val) ...)
       (computation-bind
        (computation-ask)
        (lambda (env)
          (computation-environment-update! env u v) ...
          (computation-pure (if #f #f))))))
    ((_ (var val) r ... (p ...))
     (%with! r ... (p ... (var u val v))))))

(define (computation-forked a . a*)
  (make-computation
   (lambda (compute)
     (let loop ((a a) (a* a*))
       (if (null? a*)
           (compute a)
           (begin
             (compute (computation-local
                       (lambda (env)
                         (computation-environment-copy env))
                       a))
             (loop (car a*) (cdr a*))))))))

(define (computation-bind/forked computation . proc*)
  (apply computation-bind
         (computation-local computation-environment-copy computation)
         proc*))

(define (computation-sequence fmt*)
  (fold-right
   (lambda (fmt res)
     (computation-bind
      res
      (lambda (vals)
        (computation-bind
         fmt
         (lambda (val)
           (computation-pure (cons val vals)))))))
   (computation-pure '()) fmt*))
;; Copyright (C) Marc Nieper-Wikirchen (2017).  All Rights Reserved.

;; Permission is hereby granted, free of charge, to any person
;; obtaining a copy of this software and associated documentation
;; files (the "Software"), to deal in the Software without
;; restriction, including without limitation the rights to use, copy,
;; modify, merge, publish, distribute, sublicense, and/or sell copies
;; of the Software, and to permit persons to whom the Software is
;; furnished to do so, subject to the following conditions:

;; The above copyright notice and this permission notice shall be
;; included in all copies or substantial portions of the Software.

;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
;; EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
;; MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
;; NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
;; BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
;; ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
;; CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
;; SOFTWARE.

(define-library (srfi 154)
  (export dynamic-environment?
          current-dynamic-environment
          with-dynamic-environment
          closed-lambda)
  (import (scheme base))
  (include "154.scm"))
(define-library (srfi 38 test)
  (export run-tests)
  (import (chibi) (chibi test) (srfi 1) (srfi 38))
  (begin
    (define (run-tests)
      (define (read-from-string str)
        (call-with-input-string str
          (lambda (in) (read/ss in))))

      (define (write-to-string x . o)
        (call-with-output-string
          (lambda (out) (apply write/ss x out o))))

      (define-syntax test-io
        (syntax-rules ()
          ((test-io str-expr expr)
           (let ((str str-expr)
                 (value expr))
             (test str (write-to-string value))
             (test str (write-to-string (read-from-string str)))))))

      (define-syntax test-cyclic-io
        (syntax-rules ()
          ((test-cyclic-io str-expr expr)
           (let ((str str-expr)
                 (value expr))
             (test str (write-to-string value #t))
             (test str (write-to-string (read-from-string str) #t))))))

      (test-begin "srfi-38: shared read/write")

      (test-io "(1)" (list 1))
      (test-io "(1 2)" (list 1 2))
      (test-io "(1 . 2)" (cons 1 2))

      (test-io "#0=(1 . #0#)" (circular-list 1))
      (test-io "#0=(1 2 . #0#)" (circular-list 1 2))
      (test-io "(1 . #0=(2 . #0#))" (cons 1 (circular-list 2)))
      (test-io "#0=(1 #0# 3)"
               (let ((x (list 1 2 3))) (set-car! (cdr x) x) x))
      (test-io "(#0=(1 #0# 3))"
               (let ((x (list 1 2 3))) (set-car! (cdr x) x) (list x)))
      (test-io "(#0=(1 #0# 3) #0#)"
               (let ((x (list 1 2 3))) (set-car! (cdr x) x) (list x x)))
      (test-io "(#0=(1 . #0#) #1=(1 . #1#))"
               (list (circular-list 1) (circular-list 1)))

      (test-io "(#0=(1 . 2) #1=(1 . 2) #2=(3 . 4) #0# #1# #2#)"
               (let ((a (cons 1 2)) (b (cons 1 2)) (c (cons 3 4)))
                 (list a b c a b c)))
      (test-io "((1 . #0=#(2)) #0#)"
               (let ((vec (vector 2)))
                 (list (cons 1 vec) vec)))
      (test-io "((1 . #0=#(2 #0#)) #0#)"
               (let ((vec (vector 2 #f)))
                 (vector-set! vec 1 vec)
                 (list (cons 1 vec) vec)))
      (test-cyclic-io "((1 . 2) (1 . 2) (3 . 4) (1 . 2) (1 . 2) (3 . 4))"
                      (let ((a (cons 1 2)) (b (cons 1 2)) (c (cons 3 4)))
                        (list a b c a b c)))
      (test-cyclic-io "#0=((1 . 2) (1 . 2) (3 . 4) . #0#)"
                      (let* ((a (cons 1 2))
                             (b (cons 1 2))
                             (c (cons 3 4))
                             (ls (list a b c)))
                        (set-cdr! (cddr ls) ls)
                        ls))

      (test-io "#0=#(#0#)"
               (let ((x (vector 1))) (vector-set! x 0 x) x))
      (test-io "#0=#(1 #0#)"
               (let ((x (vector 1 2))) (vector-set! x 1 x) x))
      (test-io "#0=#(1 #0# 3)"
               (let ((x (vector 1 2 3))) (vector-set! x 1 x) x))
      (test-io "(#0=#(1 #0# 3))"
               (let ((x (vector 1 2 3))) (vector-set! x 1 x) (list x)))
      (test-io "#0=#(#0# 2 #0#)"
               (let ((x (vector 1 2 3)))
                 (vector-set! x 0 x)
                 (vector-set! x 2 x)
                 x))

      (test '+.! (read-from-string "+.!"))

      (test 255 (read-from-string "#xff"))
      (test 99 (read-from-string "#d99"))
      (test 63 (read-from-string "#o77"))
      (test 3 (read-from-string "#b11"))
      (test 5 (read-from-string "#e5.0"))
      (test 5.0 (read-from-string "#i5"))
      (test 15 (read-from-string "#e#xf"))
      (test 15.0 (read-from-string "#i#xf"))
      (test (expt 10 100) (read-from-string "#e1e100"))

      (test "A\n\nB\n" (read-from-string "\"A\\n\\
                                            \\n\\
                                            B\n\""))
      (test "A\n\n" (read-from-string "\"A\\n\\
                                         \\n\\
                                         \""))

      (cond-expand
       (chicken
        (test-io "(#0=\"abc\" #0# #0#)"
                 (let ((str (string #\a #\b #\c))) (list str str str)))
        (test "(\"abc\" \"abc\" \"abc\")"
            (let ((str (string #\a #\b #\c)))
              (call-with-output-string
                (lambda (out)
                  (write/ss (list str str str) out ignore-strings: #t))))))
       (else
        ))

      (test-end))))
(define-library (srfi 158 test)
  (import (scheme base)
          (scheme read)
          (srfi 1)
          (srfi 158)
          (chibi test))
  (export run-tests)
  (begin
    (define (with-input-from-string str thunk)
      (parameterize ((current-input-port (open-input-string str)))
        (thunk)))
    (define g
      (make-coroutine-generator
       (lambda (yield) (let loop ((i 0))
                     (when (< i 3) (yield i) (loop (+ i 1)))))))
    (define (for-each-digit proc n)
      (when (> n 0)
        (let-values (((div rem) (truncate/ n 10)))
          (proc rem)
          (for-each-digit proc div))))
    (define g1 (generator 1 2 3))
    (define g2 (generator 4 5 6 7))
    (define (proc . args) (values (apply + args) (apply + args)))
    (define (small? x) (< x 3))
    (define n 0)
    (define (run-tests)
      (test-group "srfi-158: generators"
        (test-group "generators/constructors"
          (test '() (generator->list (generator)))
          (test '(1 2 3) (generator->list (generator 1 2 3)))
          (test '(1 2 3 1 2) (generator->list (circular-generator 1 2 3) 5))
          (test '(8 9 10) (generator->list (make-iota-generator 3 8)))
          (test '(8 10 12) (generator->list (make-iota-generator 3 8 2)))
          (test '(3 4 5 6) (generator->list (make-range-generator 3) 4))
          (test '(3 4 5 6 7) (generator->list (make-range-generator 3 8)))
          (test '(3 5 7) (generator->list (make-range-generator 3 8 2)))

          (test '(0 1 2) (generator->list g))
          (test '(1 2 3 4 5) (generator->list (list->generator '(1 2 3 4 5))))
          (test '(1 2 3 4 5) (generator->list (vector->generator '#(1 2 3 4 5))))
          (test '#(0 0 1 2 4)
              (let ((v (make-vector 5 0)))
                (generator->vector! v 2 (generator 1 2 4))
                v))
          (test '(5 4 3 2 1) (generator->list (reverse-vector->generator '#(1 2 3 4 5))))
          (test '(#\a #\b #\c #\d #\e) (generator->list (string->generator "abcde")))
          (test '(10 20 30) (generator->list (bytevector->generator (bytevector 10 20 30))))
          (test '(5 4 3 2 1) (generator->list
                              (make-for-each-generator for-each-digit
                                                       12345)))
          (test '(0 2 4 6 8 10) (generator->list
                                 (make-unfold-generator
                                  (lambda (s) (> s 5))
                                  (lambda (s) (* s 2))
                                  (lambda (s) (+ s 1))
                                  0)))
          )                            ; end "generators/constructors"

        (test-group "generators/operators"
          (test '(a b 0 1) (generator->list (gcons* 'a 'b (make-range-generator 0 2))))
          (test '(0 1 2 0 1) (generator->list (gappend (make-range-generator 0 3)
                                                       (make-range-generator 0 2))))
          (test '() (generator->list (gappend)))
          (test '(15 22 31) (generator->list (gcombine proc 10 g1 g2)))
          (test '(1 3 5 7 9) (generator->list (gfilter
                                               odd?
                                               (make-range-generator 1 11))))
          (test '(2 4 6 8 10) (generator->list (gremove
                                                odd?
                                                (make-range-generator 1 11))))
          (set! g (make-range-generator 1 5))
          (test '(1 2 3) (generator->list (gtake g 3)))
          (test '(4) (generator->list g))
          (test '(1 2) (generator->list (gtake (make-range-generator 1 3) 3)))
          (test '(1 2 0) (generator->list (gtake (make-range-generator 1 3) 3 0)))
          (test '(3 4) (generator->list (gdrop (make-range-generator 1 5) 2)))
          (set! g (make-range-generator 1 5))
          (test '(1 2) (generator->list (gtake-while small? g)))
          (set! g (make-range-generator 1 5))
          (test '(3 4) (generator->list (gdrop-while small? g)))
          (test '() (generator->list (gdrop-while (lambda args #t) (generator 1 2 3))))
          (test '(0.0 1.0 0 2) (generator->list (gdelete 1
                                                         (generator 0.0 1.0 0 1 2))))
          (test '(0.0 0 2) (generator->list (gdelete 1
                                                     (generator 0.0 1.0 0 1 2)
                                                     =)))
          (test '(a c e) (generator->list (gindex (list->generator '(a b c d e f))
                                                  (list->generator '(0 2 4)))))
          (test '(a d e) (generator->list (gselect (list->generator '(a b c d e f))
                                                   (list->generator '(#t #f #f #t #t #f)))))
          (test '(1 2 3) (generator->list (gdelete-neighbor-dups
                                           (generator 1 1 2 3 3 3)
                                           =)))
          (test '(1) (generator->list (gdelete-neighbor-dups
                                       (generator 1 2 3)
                                       (lambda args #t))))
          (test '(1 2 3 a b c)
              (generator->list
               (gflatten (generator '(1 2 3) '(a b c)))))
          (test '((1 2 3) (4 5 6) (7 8))
              (generator->list (ggroup (generator 1 2 3 4 5 6 7 8) 3)))
          (test '((1 2 3) (4 5 6) (7 8 0))
              (generator->list (ggroup (generator 1 2 3 4 5 6 7 8) 3 0)))
          (test '(1 2 3)
              (generator->list (gmerge < (generator 1 2 3))))
          (test '(1 2 3 4 5 6)
              (generator->list (gmerge < (generator 1 2 3) (generator 4 5 6))))
          (test '(1 2 3 4 4 5 6)
              (generator->list (gmerge <
                                       (generator 1 2 4 6)
                                       (generator)
                                       (generator 3 4 5))))
          (test '(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15)
              (generator->list (gmerge <
                                       (generator 1 10 11)
                                       (generator 2 9 12)
                                       (generator 3 8 13)
                                       (generator 4 7 14)
                                       (generator 5 6 15))))
          ;; check the tie-break rule
          (test '((1 a) (1 e) (1 b) (1 c) (1 d))
              (generator->list (gmerge (lambda (x y) (< (car x) (car y)))
                                       (generator '(1 a) '(1 e))
                                       (generator '(1 b))
                                       (generator '(1 c) '(1 d)))))

          (test '(-1 -2 -3 -4 -5)
              (generator->list (gmap - (generator 1 2 3 4 5))))
          (test '(7 9 11 13)
              (generator->list (gmap +
                                     (generator 1 2 3 4 5)
                                     (generator 6 7 8 9))))
          (test '(54 140 264)
              (generator->list (gmap *
                                     (generator 1 2 3 4 5)
                                     (generator 6 7 8)
                                     (generator 9 10 11 12 13))))
          (test '(a c e g i)
              (generator->list
               (gstate-filter
                (lambda (item state) (values (even? state) (+ 1 state)))
                0
                (generator 'a 'b 'c 'd 'e 'f 'g 'h 'i 'j))))
          )                             ; end "generators/operators"


        (test-group "generators/consumers"
          ;; no test for plain generator->list (used throughout)
          (test '(1 2 3) (generator->list (generator 1 2 3 4 5) 3))
          (test '(5 4 3 2 1) (generator->reverse-list (generator 1 2 3 4 5)))
          (test '#(1 2 3 4 5) (generator->vector (generator 1 2 3 4 5)))
          (test '#(1 2 3) (generator->vector (generator 1 2 3 4 5) 3))
          (test "abc" (generator->string (generator #\a #\b #\c)))
          (test '(e d c b a . z) (with-input-from-string "a b c d e"
                                   (lambda () (generator-fold cons 'z read))))

          (generator-for-each (lambda values (set! n (apply + values)))
                              (generator 1) (generator 2) (generator 3))
          (test 6 n)
          (test '(6 15)
              (generator-map->list (lambda values (apply + values))
                                   (generator 1 4) (generator 2 5) (generator 3 6)))
          (test 3 (generator-find (lambda (x) (> x 2)) (make-range-generator 1 5)))
          (test 2 (generator-count odd? (make-range-generator 1 5)))
          (set! g (make-range-generator 2 5))
          (test #t (generator-any odd? g))
          (test '(4) (generator->list g))
          (set! g (make-range-generator 2 5))
          (test #f (generator-every odd? g))
          (test '(3 4) (generator->list g))
          (test '(#\a #\b #\c) (generator-unfold (make-for-each-generator string-for-each "abc") unfold))

          )                             ; end "generators/consumers"

        )                               ; end "generators"


      (test-group "srfi-158: accumulators"
        (test -8
            (let ((a (make-accumulator * 1 -)))
              (a 1)
              (a 2)
              (a 4)
              (a (eof-object))))

        (test 3
            (let ((a (count-accumulator)))
              (a 1)
              (a 2)
              (a 4)
              (a (eof-object))))

        (test '(1 2 4)
            (let ((a (list-accumulator)))
              (a 1)
              (a 2)
              (a 4)
              (a (eof-object))))

        (test '(4 2 1)
            (let ((a (reverse-list-accumulator)))
              (a 1)
              (a 2)
              (a 4)
              (a (eof-object))))

        (test '#(1 2 4)
            (let ((a (vector-accumulator)))
              (a 1)
              (a 2)
              (a 4)
              (a (eof-object))))

        (test '#(0 0 1 2 4)
            (let* ((v (vector 0 0 0 0 0))
                   (a (vector-accumulator! v 2)))
              (a 1)
              (a 2)
              (a 4)
              (a (eof-object))))

        (test '#u8(0 0 1 2 4)
          (let* ((v (bytevector 0 0 0 0 0))
                 (a (bytevector-accumulator! v 2)))
            (a 1)
            (a 2)
            (a 4)
            (a (eof-object))))

        (test '#(4 2 1)
            (let ((a (reverse-vector-accumulator)))
              (a 1)
              (a 2)
              (a 4)
              (a (eof-object))))

        (test "abc"
            (let ((a (string-accumulator)))
              (a #\a)
              (a #\b)
              (a #\c)
              (a (eof-object))))

        (test #u8(1 2 4)
          (let ((a (bytevector-accumulator)))
            (a 1)
            (a 2)
            (a 4)
            (a (eof-object))))

        (test 7
            (let ((a (sum-accumulator)))
              (a 1)
              (a 2)
              (a 4)
              (a (eof-object))))

        (test 8
            (let ((a (product-accumulator)))
              (a 1)
              (a 2)
              (a 4)
              (a (eof-object))))

        )                               ; end "accumulators"

      )))

(define-library (srfi 41)
  (import (scheme base) (scheme lazy) (srfi 1))
  (export
   stream-null stream-cons stream? stream-null? stream-pair?
   stream-car stream-cdr stream-lambda)
  (export
   define-stream list->stream port->stream stream stream->list
   stream-append stream-concat stream-constant stream-drop
   stream-drop-while stream-filter stream-fold stream-for-each stream-from
   stream-iterate stream-length stream-let stream-map stream-match _
   stream-of stream-range stream-ref stream-reverse stream-scan stream-take
   stream-take-while stream-unfold stream-unfolds stream-zip)
  (include "41.scm"))

(define-library (srfi 127 test)
  (import (scheme base) (srfi 127) (chibi test))
  (export run-tests)
  (begin
    ;; Make-generator for tests cloned from SRFI 121
    (define (make-generator . args)
      (lambda ()
        (if (null? args)
            (eof-object)
            (let ((next (car args)))
              (set! args (cdr args))
              next))))

    ;; Make-lseq creates an lseq, like list, but guarantees the use of
    ;; a generator.
    (define (make-lseq . args)
      (generator->lseq (apply make-generator args)))

    (define (factorial n)
      (cond
       ((< n 0) #f)
       ((= n 0) 1)
       (else (* n (factorial (- n 1))))))

    (define (run-tests)
      (test-group "srfi-127: lseqs"
        (test-group "lseqs/constructor"
          (let ((one23 (make-lseq 1 2 3)))
            (test 1 (car one23))
            (test-assert (procedure? (cdr one23)))
            (test '(1 2 3) (lseq-realize one23)))
          )

        (test-group "lseqs/predicates"
          (test-assert (lseq? '()))
          (test-assert (lseq? '(1 2 3)))
          (test-assert (lseq? (make-lseq 1 2 3)))
          (test-assert (lseq? (cons 'x (lambda () 'x))))

          (test-assert (lseq=? = '() '()))
          (test-assert (lseq=? = '(1 2 3) '(1 2 3)))
          (test-assert (lseq=? = (make-lseq 1 2 3)
                               (make-lseq 1 2 3)))
          (test-assert (lseq=? = (make-lseq 1 2 3) '(1 2 3)))
          )

        (test-group "lseqs/selectors"
          (test-error (lseq-car (make-generator)))
          (test 1 (lseq-car (make-lseq 1 2 3)))
          (test 1 (lseq-car '(1 2 3)))
          (test-error (lseq-car 2))

          (test-error (lseq-first (make-generator)))
          (test 1 (lseq-first (make-lseq 1 2 3)))
          (test 1 (lseq-first '(1 2 3)))
          (test-error (lseq-first 2))

          (test-error (lseq-cdr (make-generator)))
          (test 2 (lseq-cdr '(1 . 2)))
          (test 2 (lseq-car (lseq-cdr '(1 2 3))))
          (test 2 (lseq-car (lseq-cdr (make-lseq 1 2 3))))

          (test-error (lseq-rest (make-generator)))
          (test 2 (lseq-rest '(1 . 2)))
          (test 2 (lseq-car (lseq-rest '(1 2 3))))
          (test 2 (lseq-car (lseq-rest (make-lseq 1 2 3))))
          (test-error (lseq-rest 2))

          (test-error (lseq-ref '() 0))
          (test 1 (lseq-ref '(1) 0))
          (test 2 (lseq-ref '(1 2) 1))
          (test-error (lseq-ref (make-lseq) 0))
          (test 1 (lseq-ref (make-lseq 1) 0))
          (test 1 (lseq-ref (make-lseq 1 2) 0))
          (test 2 (lseq-ref (make-lseq 1 2) 1))

          (test-error (lseq-take '() 1))
          (test-error (lseq-take (make-lseq) 1))
          (test-assert (procedure? (cdr (lseq-take '(1 2 3 4 5) 3)))) ; test laziness
          (test '(1 2 3) (lseq-realize (lseq-take '(1 2 3 4 5) 3)))

          (test-error (lseq-drop '() 1))
          (test-error (lseq-drop (make-lseq 1) 2))
          (test '(3 4 5) (lseq-realize (lseq-drop '(1 2 3 4 5) 2)))
          (test '(3 4 5) (lseq-realize (lseq-drop (make-lseq 1 2 3 4 5) 2)))
          )

        (test-group "lseqs/whole"
          (test '() (lseq-realize '()))
          (test '(1 2 3) (lseq-realize '(1 2 3)))
          (test '() (lseq-realize (make-lseq)))
          (test '(1 2 3) (lseq-realize (make-lseq 1 2 3)))

          (let ((g (lseq->generator '(1 2 3))))
            (test 1 (g))
            (test 2 (g))
            (test 3 (g))
            (test-assert (eof-object? (g))))

          (let ((g (lseq->generator (make-lseq 1 2 3))))
            (test 1 (g))
            (test 2 (g))
            (test 3 (g))
            (test-assert (eof-object? (g))))

          (test 0 (lseq-length '()))
          (test 3 (lseq-length '(1 2 3)))
          (test 3 (lseq-length (make-lseq 1 2 3)))

          (test '(1 2 3 a b c) (lseq-realize (lseq-append '(1 2 3) '(a b c))))
          (let ((one23abc (lseq-append (make-lseq 1 2 3) (make-lseq 'a 'b 'c))))
            (test-assert (procedure? (cdr one23abc)))
            (test-assert (lseq-realize one23abc)))

          (let ((one2345 (make-lseq 1 2 3 4 5))
                (oddeven (make-lseq 'odd 'even 'odd 'even 'odd 'even 'odd 'even)))
            (test '((one 1 odd) (two 2 even) (three 3 odd))
                (lseq-realize (lseq-zip '(one two three) one2345 oddeven))))
          )

        (test-group "lseqs/mapping"
          (test '() (lseq-map - '()))
          (test '(-1 -2 -3) (lseq-realize (lseq-map - '(1 2 3))))
          (test '(-1 -2 -3) (lseq-realize (lseq-map - (make-lseq 1 2 3))))
          (test-assert (procedure? (cdr (lseq-map - '(1 2 3)))))

          (let* ((output '())
                 (out! (lambda (x) (set! output (cons x output)))))
            (lseq-for-each out! '())
            (test '() output)
            (lseq-for-each out! '(a b c))
            (test '(c b a) output)
            (lseq-for-each out! (make-lseq 1 2 3))
            (test '(3 2 1 c b a) output))

          (test '() (lseq-filter odd? '()))

          (let ((odds (lseq-filter odd? '(1 2 3 4 5))))
            (test-assert (procedure? (cdr odds)))
            (test '(1 3 5) (lseq-realize odds))
            (test '(1 3 5) (lseq-realize (lseq-filter odd? (make-lseq 1 2 3 4 5)))))

          (test '() (lseq-remove even? '()))
          (let ((odds (lseq-remove even? '(1 2 3 4 5))))
            (test-assert (procedure? (cdr odds)))
            (test '(1 3 5) (lseq-realize odds))
            (test '(1 3 5) (lseq-realize (lseq-remove even? (make-lseq 1 2 3 4 5))))))

        (test-group "lseqs/searching"
          (test 4 (lseq-find even? '(3 1 4 1 5 9 2 6)))
          (test 4 (lseq-find even? (make-lseq 3 1 4 1 5 9 2 6)))
          (test #f (lseq-find negative? (make-lseq 1 2 3 4 5)))

          (test '(-8 -5 0 0) (lseq-realize (lseq-find-tail even? '(3 1 37 -8 -5 0 0))))
          (test '(-8 -5 0 0) (lseq-realize (lseq-find-tail even?
                                                           (make-lseq 3 1 37 -8 -5 0 0))))
          (test #f (lseq-find-tail even? '()))
          (test #f (lseq-find-tail negative? (make-lseq 1 2 3 4 5)))

          (test '(2 18) (lseq-realize (lseq-take-while even? '(2 18 3 10 22 9))))
          (test '(2 18) (lseq-realize (lseq-take-while even?
                                                       (make-lseq 2 18 3 10 22 9))))
          (test '(2 18) (lseq-realize (lseq-take-while even?
                                                       (make-lseq 2 18 3 10 22 9))))

          (test '(3 10 22 9) (lseq-drop-while even? '(2 18 3 10 22 9)))
          (test '(3 10 22 9) (lseq-realize (lseq-drop-while even?
                                                            (make-lseq 2 18 3 10 22 9))))

          (test #t (lseq-any integer? '(a 3 b 2.7)))
          (test #t (lseq-any integer? (make-lseq 'a 3 'b 2.7)))
          (test #f (lseq-any integer? '(a 3.1 b 2.7)))
          (test #f (lseq-any integer? (make-lseq 'a 3.1 'b 2.7)))
          (test #t (lseq-any < '(3 1 4 1 5) '(2 7 1 8 2)))
          (test 6 (lseq-any factorial '(-1 -2 3 4)))
          (test 6 (lseq-any factorial (make-lseq -1 -2 3 4)))

          (test 24 (lseq-every factorial '(1 2 3 4)))
          (test 24 (lseq-every factorial (make-lseq 1 2 3 4)))

          (test 2 (lseq-index even? '(3 1 4 1 5 9)))
          (test 1 (lseq-index < '(3 1 4 1 5 9 2 5 6) '(2 7 1 8 2)))
          (test #f (lseq-index = '(3 1 4 1 5 9 2 5 6) '(2 7 1 8 2)))

          (test '(a b c) (lseq-realize (lseq-memq 'a '(a b c))))
          (test '(a b c) (lseq-realize (lseq-memq 'a (make-lseq 'a 'b 'c))))
          (test #f (lseq-memq 'a (make-lseq 'b 'c 'd)))
          (test #f (lseq-memq (list 'a) '(b c d)))
          (test #f (lseq-memq (list 'a) (make-lseq 'b 'c 'd)))

          (test '(101 102) (lseq-realize (lseq-memv 101 (make-lseq 100 101 102))))

          (test '((a) c) (lseq-realize (lseq-member (list 'a) (make-lseq 'b '(a) 'c))))
          (test '(2 3) (lseq-realize (lseq-member 2.0 (make-lseq 1 2 3) =)))
          )))
    ))
(define-library (srfi 139)
  (export (rename define-syntax define-syntax-parameter)
          syntax-parameterize)
  (import (chibi)
          (chibi ast))
  (include "139.scm"))
(define-library (srfi 111)
  (import (scheme base))
  (export box box? unbox set-box!)
  (begin
    (define-record-type Box
      (box value)
      box?
      (value unbox set-box!))))

;;> Returns #t if argument is a titlecase character, #f if not
(define (char-title-case? ch)
  (char-set-contains? char-set:title-case ch))

;;> Returns the single-character titlecase mapping of argument
(define (char-titlecase ch)
  (cond ((char-set-contains? char-set:title-case ch) ch)
        ((assv ch title-single-map) => cadr)
        (else (char-upcase ch))))

;; Returns #t if a character is caseless, otherwise #f
(define (char-caseless? ch)
  (not (or (char-lower-case? ch) (char-upper-case? ch) (char-title-case? ch))))

;;> Returns the string titlecase mapping of argument
(define (string-titlecase str)
  (let ((end (string-cursor-end str)))
    (let lp ((n (string-cursor-start str))
             (prev-caseless? #t)
             (result '()))
      (if (string-cursor>=? n end)
          (list->string (reverse result))
          (let ((ch (string-cursor-ref str n))
                (n2 (string-cursor-next str n)))
            (if prev-caseless?
                ;; ch must be titlecased
                (let ((multi-title (assv ch title-multiple-map)))
                  (if multi-title
                      ;; ch has multiple- or single-character titlecase mapping
                      (lp n2 #f (append-reverse (cdr multi-title) result))
                      ;; ch has single-character uppercase mapping
                      (lp n2 (char-caseless? ch) (cons (char-titlecase ch) result))))
                ;; ch must be lowercased
                (let ((multi-downcase (assv ch lower-multiple-map)))
                  (if multi-downcase
                      ;; ch has multiple-character lowercase mapping
                      (lp n2 #f (append-reverse (cdr multi-downcase) result))
                      ;; ch has single-character lowercase mapping
                      (lp n2 (char-caseless? ch) (cons (char-downcase ch) result))))))))))

(define title-single-map
  '((#\x01C4 #\x01C5) ; LATIN CAPITAL LETTER DZ WITH CARON
    (#\x01C6 #\x01C5) ; LATIN SMALL LETTER DZ WITH CARON
    (#\x01C7 #\x01C8) ; LATIN CAPITAL LETTER LJ
    (#\x01C8 #\x01C8) ; LATIN CAPITAL LETTER L WITH SMALL LETTER J
    (#\x01C9 #\x01C8) ; LATIN SMALL LETTER LJ
    (#\x01CA #\x01CB) ; LATIN CAPITAL LETTER NJ
    (#\x01CC #\x01CB) ; LATIN SMALL LETTER NJ
    (#\x01F1 #\x01F2) ; LATIN CAPITAL LETTER DZ
    (#\x01F3 #\x01F2) ; LATIN SMALL LETTER DZ
    ))

;; Alist mapping characters to their multiple-letter titlecase equivalents
(define title-multiple-map
  (append
   title-single-map
   '((#\x00DF #\x0053 #\x0073)         ; LATIN SMALL LETTER SHARP S
     (#\xFB00 #\x0046 #\x0066)         ; LATIN SMALL LIGATURE FF
     (#\xFB01 #\x0046 #\x0069)         ; LATIN SMALL LIGATURE FI
     (#\xFB02 #\x0046 #\x006C)         ; LATIN SMALL LIGATURE FL
     (#\xFB03 #\x0046 #\x0066 #\x0069) ; LATIN SMALL LIGATURE FFI
     (#\xFB04 #\x0046 #\x0066 #\x006C) ; LATIN SMALL LIGATURE FFL
     (#\xFB05 #\x0053 #\x0074)         ; LATIN SMALL LIGATURE LONG S T
     (#\xFB06 #\x0053 #\x0074)         ; LATIN SMALL LIGATURE ST
     (#\x0587 #\x0535 #\x0582)      ; ARMENIAN SMALL LIGATURE ECH YIWN
     (#\xFB13 #\x0544 #\x0576)      ; ARMENIAN SMALL LIGATURE MEN NOW
     (#\xFB14 #\x0544 #\x0565)      ; ARMENIAN SMALL LIGATURE MEN ECH
     (#\xFB15 #\x0544 #\x056B)      ; ARMENIAN SMALL LIGATURE MEN INI
     (#\xFB16 #\x054E #\x0576)      ; ARMENIAN SMALL LIGATURE VEW NOW
     (#\xFB17 #\x0544 #\x056D)      ; ARMENIAN SMALL LIGATURE MEN XEH
     (#\x0149 #\x02BC #\x004E) ; LATIN SMALL LETTER N PRECEDED BY APOSTROPHE
     (#\x0390 #\x0399 #\x0308 #\x0301) ; GREEK SMALL LETTER IOTA WITH DIALYTIKA AND TONOS
     (#\x03B0 #\x03A5 #\x0308 #\x0301) ; GREEK SMALL LETTER UPSILON WITH DIALYTIKA AND TONOS
     (#\x01F0 #\x004A #\x030C)  ; LATIN SMALL LETTER J WITH CARON
     (#\x1E96 #\x0048 #\x0331)  ; LATIN SMALL LETTER H WITH LINE BELOW
     (#\x1E97 #\x0054 #\x0308)  ; LATIN SMALL LETTER T WITH DIAERESIS
     (#\x1E98 #\x0057 #\x030A)  ; LATIN SMALL LETTER W WITH RING ABOVE
     (#\x1E99 #\x0059 #\x030A)  ; LATIN SMALL LETTER Y WITH RING ABOVE
     (#\x1E9A #\x0041 #\x02BE) ; LATIN SMALL LETTER A WITH RIGHT HALF RING
     (#\x1F50 #\x03A5 #\x0313) ; GREEK SMALL LETTER UPSILON WITH PSILI
     (#\x1F52 #\x03A5 #\x0313 #\x0300) ; GREEK SMALL LETTER UPSILON WITH PSILI AND VARIA
     (#\x1F54 #\x03A5 #\x0313 #\x0301) ; GREEK SMALL LETTER UPSILON WITH PSILI AND OXIA
     (#\x1F56 #\x03A5 #\x0313 #\x0342) ; GREEK SMALL LETTER UPSILON WITH PSILI AND PERISPOMENI
     (#\x1FB6 #\x0391 #\x0342) ; GREEK SMALL LETTER ALPHA WITH PERISPOMENI
     (#\x1FC6 #\x0397 #\x0342) ; GREEK SMALL LETTER ETA WITH PERISPOMENI
     (#\x1FD2 #\x0399 #\x0308 #\x0300) ; GREEK SMALL LETTER IOTA WITH DIALYTIKA AND VARIA
     (#\x1FD3 #\x0399 #\x0308 #\x0301) ; GREEK SMALL LETTER IOTA WITH DIALYTIKA AND OXIA
     (#\x1FD6 #\x0399 #\x0342) ; GREEK SMALL LETTER IOTA WITH PERISPOMENI
     (#\x1FD7 #\x0399 #\x0308 #\x0342) ; GREEK SMALL LETTER IOTA WITH DIALYTIKA AND PERISPOMENI
     (#\x1FE2 #\x03A5 #\x0308 #\x0300) ; GREEK SMALL LETTER UPSILON WITH DIALYTIKA AND VARIA
     (#\x1FE3 #\x03A5 #\x0308 #\x0301) ; GREEK SMALL LETTER UPSILON WITH DIALYTIKA AND OXIA
     (#\x1FE4 #\x03A1 #\x0313)     ; GREEK SMALL LETTER RHO WITH PSILI
     (#\x1FE6 #\x03A5 #\x0342) ; GREEK SMALL LETTER UPSILON WITH PERISPOMENI
     (#\x1FE7 #\x03A5 #\x0308 #\x0342) ; GREEK SMALL LETTER UPSILON WITH DIALYTIKA AND PERISPOMENI
     (#\x1FF6 #\x03A9 #\x0342) ; GREEK SMALL LETTER OMEGA WITH PERISPOMENI
     (#\x1FB2 #\x1FBA #\x0345) ; GREEK SMALL LETTER ALPHA WITH VARIA AND YPOGEGRAMMENI
     (#\x1FB4 #\x0386 #\x0345) ; GREEK SMALL LETTER ALPHA WITH OXIA AND YPOGEGRAMMENI
     (#\x1FC2 #\x1FCA #\x0345) ; GREEK SMALL LETTER ETA WITH VARIA AND YPOGEGRAMMENI
     (#\x1FC4 #\x0389 #\x0345) ; GREEK SMALL LETTER ETA WITH OXIA AND YPOGEGRAMMENI
     (#\x1FF2 #\x1FFA #\x0345) ; GREEK SMALL LETTER OMEGA WITH VARIA AND YPOGEGRAMMENI
     (#\x1FF4 #\x038F #\x0345) ; GREEK SMALL LETTER OMEGA WITH OXIA AND YPOGEGRAMMENI
     (#\x1FB7 #\x0391 #\x0342 #\x0345) ; GREEK SMALL LETTER ALPHA WITH PERISPOMENI AND YPOGEGRAMMENI
     (#\x1FC7 #\x0397 #\x0342 #\x0345) ; GREEK SMALL LETTER ETA WITH PERISPOMENI AND YPOGEGRAMMENI
     (#\x1FF7 #\x03A9 #\x0342 #\x0345) ; GREEK SMALL LETTER OMEGA WITH PERISPOMENI AND YPOGEGRAMMENI
     )))

;; Alist mapping characters to their multiple-character lowercase equivalents
(define lower-multiple-map
  '((#\x0130 #\x0069 #\x0307))) ; LATIN CAPITAL LETTER I WITH DOT ABOVE

(define-library (srfi 129 test)
  (export run-tests)
  (import (scheme base) (scheme char) (srfi 129) (chibi test))
  (begin
    (define Floo "\xFB02;oo")
    (define Floo-bar "\xFB02;oo bar")
    (define Baffle "Ba\xFB04;e")
    (define LJUBLJANA "\x01C7;ub\x01C7;ana")
    (define Ljubljana "\x01C8;ub\x01C9;ana")
    (define ljubljana "\x01C9;ub\x01C9;ana")
    (define (run-tests)
      (test-begin "srfi-129: titlecase")
      (test-group "titlecase/predicate"
        (test-assert (char-title-case? #\x01C5))
        (test-assert (char-title-case? #\x1FFC))
        (test-assert (char-upper-case? #\x01C7))
        (test-assert (char-title-case? #\x01C8))
        (test-assert (char-lower-case? #\x01C9))
        (test-assert (not (char-title-case? #\Z)))
        (test-assert (not (char-title-case? #\z))))

      (test-group "titlecase/char"
        (test #\x01C5 (char-titlecase #\x01C4))
        (test #\x01C5 (char-titlecase #\x01C5))
        (test #\x01C5 (char-titlecase #\x01C6))
        (test #\x1F88 (char-titlecase #\x1F80))
        (test #\x01C7 (char-upcase #\x01C7))
        (test #\x01C7 (char-upcase #\x01C8))
        (test #\x01C7 (char-upcase #\x01C9))
        (test #\x01C8 (char-titlecase #\x01C7))
        (test #\x01C8 (char-titlecase #\x01C8))
        (test #\x01C8 (char-titlecase #\x01C9))
        (test #\x01C9 (char-downcase #\x01C7))
        (test #\x01C9 (char-downcase #\x01C8))
        (test #\x01C9 (char-downcase #\x01C9))
        (test #\Z (char-titlecase #\Z))
        (test #\Z (char-titlecase #\z)))

      (test-group "titlecase/string"
        (test "\x01C5" (string-titlecase "\x01C5"))
        (test "\x01C5" (string-titlecase "\x01C4"))
        (test "Ss" (string-titlecase "\x00DF"))
        (test "Xi\x0307" (string-titlecase "x\x0130"))
        (test "\x1F88" (string-titlecase "\x1F80"))
        (test "\x1F88" (string-titlecase "\x1F88"))
        (test "Bar Baz" (string-titlecase "bAr baZ"))
        (test "Floo" (string-titlecase "floo"))
        (test "Floo" (string-titlecase "FLOO"))
        (test "Floo" (string-titlecase Floo))
        (test "Floo Bar" (string-titlecase "floo bar"))
        (test "Floo Bar" (string-titlecase "FLOO BAR"))
        (test "Floo Bar" (string-titlecase Floo-bar))
        (test Baffle (string-titlecase Baffle))
        (test Ljubljana (string-titlecase LJUBLJANA))
        (test Ljubljana (string-titlecase Ljubljana))
        (test Ljubljana (string-titlecase ljubljana)))
      (test-end))))
(define-library (srfi 158)
  (import (scheme base))
  (import (scheme case-lambda))
  (export generator circular-generator make-iota-generator make-range-generator
          make-coroutine-generator list->generator vector->generator
          reverse-vector->generator string->generator
          bytevector->generator
          make-for-each-generator make-unfold-generator)
  (export gcons* gappend gcombine gfilter gremove
          gtake gdrop gtake-while gdrop-while
          gflatten ggroup gmerge gmap gstate-filter
          gdelete gdelete-neighbor-dups gindex gselect)
  (export generator->list generator->reverse-list
          generator->vector generator->vector!  generator->string
          generator-fold generator-map->list generator-for-each generator-find
          generator-count generator-any generator-every generator-unfold)
  (export make-accumulator count-accumulator list-accumulator
          reverse-list-accumulator vector-accumulator
          reverse-vector-accumulator vector-accumulator!
          string-accumulator bytevector-accumulator bytevector-accumulator!
          sum-accumulator product-accumulator)
  (include "158.scm")
)

(define-library (srfi 14 test)
  (import (scheme base) (scheme char) (srfi 14) (chibi test))
  (export run-tests)
  (begin
    (define-syntax test-cs
      (syntax-rules ()
        ((test-cs . o)
         (test-equal char-set= . o))))
    (define (vowel? c) (member c '(#\a #\e #\i #\o #\u)))
    (define (run-tests)
      (test-begin "srfi-14: char-sets")
      (test-not (char-set? 5))

      (test-assert (char-set? (char-set #\a #\e #\i #\o #\u)))

      (test-assert (char-set=))
      (test-assert (char-set= (char-set)))

      (test-cs (char-set #\a #\e #\i #\o #\u)
               (string->char-set "ioeauaiii"))

      (test-not (char-set= (char-set #\e #\i #\o #\u)
                           (string->char-set "ioeauaiii")))

      (test-assert (char-set<=))
      (test-assert (char-set<= (char-set)))

      (test-assert (char-set<= (char-set #\a #\e #\i #\o #\u)
                               (string->char-set "ioeauaiii")))

      (test-assert (char-set<= (char-set #\e #\i #\o #\u)
                               (string->char-set "ioeauaiii")))

      (test-assert (<= 0 (char-set-hash char-set:graphic 100) 99))

      (test 4 (char-set-fold (lambda (c i) (+ i 1)) 0
                             (char-set #\e #\i #\o #\u #\e #\e)))

      (test-cs (string->char-set "eiaou2468013579999")
               (char-set-unfold null? car cdr
                                '(#\a #\e #\i #\o #\u #\u #\u)
                                (char-set-intersection char-set:ascii
                                                       char-set:digit)))

      (test-cs (string->char-set "eiaou246801357999")
               (char-set-unfold! null? car cdr '(#\a #\e #\i #\o #\u)
                                 (string->char-set "0123456789")))

      (test-not (char-set= (string->char-set "eiaou246801357")
                           (char-set-unfold! null? car cdr
                                             '(#\a #\e #\i #\o #\u)
                                             (string->char-set "0123456789"))))

      (let ((cs (string->char-set "0123456789")))
        (char-set-for-each (lambda (c) (set! cs (char-set-delete cs c)))
                           (string->char-set "02468000"))
        (test-cs cs (string->char-set "97531")))

      (test-not (let ((cs (string->char-set "0123456789")))
                  (char-set-for-each (lambda (c) (set! cs (char-set-delete cs c)))
                                     (string->char-set "02468"))
                  (char-set= cs (string->char-set "7531"))))

      (test-cs (string->char-set "IOUAEEEE")
               (char-set-map char-upcase (string->char-set "aeiou")))

      (test-not (char-set= (char-set-map char-upcase (string->char-set "aeiou"))
                           (string->char-set "OUAEEEE")))

      (test-cs (string->char-set "aeiou")
               (char-set-copy (string->char-set "aeiou")))

      (test-cs (string->char-set "xy") (char-set #\x #\y))
      (test-not (char-set= (char-set #\x #\y #\z) (string->char-set "xy")))

      (test-cs (string->char-set "xy") (list->char-set '(#\x #\y)))
      (test-not (char-set= (string->char-set "axy")
                           (list->char-set '(#\x #\y))))

      (test-cs (string->char-set "xy12345")
               (list->char-set '(#\x #\y) (string->char-set "12345")))
      (test-not (char-set= (string->char-set "y12345")
                           (list->char-set '(#\x #\y)
                                           (string->char-set "12345"))))

      (test-cs (string->char-set "xy12345")
               (list->char-set! '(#\x #\y) (string->char-set "12345")))
      (test-not (char-set= (string->char-set "y12345")
                           (list->char-set! '(#\x #\y)
                                            (string->char-set "12345"))))

      (test-cs (string->char-set "aeiou12345")
               (char-set-filter vowel?
                                char-set:ascii
                                (string->char-set "12345")))
      (test-not (char-set= (string->char-set "aeou12345")
                           (char-set-filter vowel?
                                            char-set:ascii
                                            (string->char-set "12345"))))

      (test-cs (string->char-set "aeiou12345")
               (char-set-filter! vowel?
                                 char-set:ascii
                                 (string->char-set "12345")))
      (test-not (char-set= (string->char-set "aeou12345")
                           (char-set-filter! vowel?
                                             char-set:ascii
                                             (string->char-set "12345"))))

      (test-cs (string->char-set "abcdef12345")
               (ucs-range->char-set 97 103 #t (string->char-set "12345")))
      (test-not (char-set=
                 (string->char-set "abcef12345")
                 (ucs-range->char-set 97 103 #t (string->char-set "12345"))))

      (test-cs (string->char-set "abcdef12345")
               (ucs-range->char-set! 97 103 #t (string->char-set "12345")))
      (test-not (char-set=
                 (string->char-set "abcef12345")
                 (ucs-range->char-set! 97 103 #t (string->char-set "12345"))))

      (test-assert (char-set= (->char-set #\x)
                              (->char-set "x")
                              (->char-set (char-set #\x))))

      (test-not (char-set= (->char-set #\x)
                           (->char-set "y")
                           (->char-set (char-set #\x))))

      (test 10 (char-set-size
                (char-set-intersection char-set:ascii char-set:digit)))
      (test 10 (char-set-size
                (char-set-intersection char-set:digit char-set:ascii)))

      (test 5 (char-set-count vowel? char-set:ascii))

      (test '(#\x) (char-set->list (char-set #\x)))
      (test-not (equal? '(#\X) (char-set->list (char-set #\x))))

      (test "x" (char-set->string (char-set #\x)))
      (test-not (equal? "X" (char-set->string (char-set #\x))))

      (test-assert (char-set-contains? (->char-set "xyz") #\x))
      (test-not (char-set-contains? (->char-set "xyz") #\a))

      (test-assert (char-set-every char-lower-case? (->char-set "abcd")))
      (test-not (char-set-every char-lower-case? (->char-set "abcD")))
      (test-assert (char-set-any char-lower-case? (->char-set "abcd")))
      (test-not (char-set-any char-lower-case? (->char-set "ABCD")))

      (test-cs (->char-set "ABCD")
               (let ((cs (->char-set "abcd")))
                 (let lp ((cur (char-set-cursor cs)) (ans '()))
                   (if (end-of-char-set? cur) (list->char-set ans)
                       (lp (char-set-cursor-next cs cur)
                           (cons (char-upcase (char-set-ref cs cur)) ans))))))


      (test-cs (->char-set "123xa")
               (char-set-adjoin (->char-set "123") #\x #\a))
      (test-not (char-set= (char-set-adjoin (->char-set "123") #\x #\a)
                           (->char-set "123x")))
      (test-cs (->char-set "123xa")
               (char-set-adjoin! (->char-set "123") #\x #\a))
      (test-not (char-set= (char-set-adjoin! (->char-set "123") #\x #\a)
                           (->char-set "123x")))

      (test-cs (->char-set "13")
               (char-set-delete (->char-set "123") #\2 #\a #\2))
      (test-not (char-set= (char-set-delete (->char-set "123") #\2 #\a #\2)
                           (->char-set "13a")))
      (test-cs (->char-set "13")
               (char-set-delete! (->char-set "123") #\2 #\a #\2))
      (test-not (char-set= (char-set-delete! (->char-set "123") #\2 #\a #\2)
                           (->char-set "13a")))

      (test-cs (->char-set "abcdefABCDEF")
               (char-set-intersection char-set:hex-digit
                                      (char-set-complement char-set:digit)))
      (test-cs (->char-set "abcdefABCDEF")
               (char-set-intersection!
                (char-set-complement! (->char-set "0123456789"))
                char-set:hex-digit))

      (test-cs (->char-set "abcdefABCDEFghijkl0123456789")
               (char-set-union char-set:hex-digit
                               (->char-set "abcdefghijkl")))
      (test-cs (->char-set "abcdefABCDEFghijkl0123456789")
               (char-set-union! (->char-set "abcdefghijkl")
                                char-set:hex-digit))

      (test-cs (->char-set "ghijklmn")
               (char-set-difference (->char-set "abcdefghijklmn")
                                    char-set:hex-digit))
      (test-cs (->char-set "ghijklmn")
               (char-set-difference! (->char-set "abcdefghijklmn")
                                     char-set:hex-digit))

      (test-cs (->char-set "abcdefABCDEF")
               (char-set-xor (->char-set "0123456789")
                             char-set:hex-digit))
      (test-cs (->char-set "abcdefABCDEF")
               (char-set-xor! (->char-set "0123456789")
                              char-set:hex-digit))

      (call-with-values
          (lambda ()
            (char-set-diff+intersection char-set:hex-digit
                                        char-set:letter))
        (lambda (d i)
          (test-cs d (->char-set "0123456789"))
          (test-cs i (->char-set "abcdefABCDEF"))))

      (call-with-values
          (lambda ()
            (char-set-diff+intersection! (char-set-copy char-set:hex-digit)
                                         (char-set-copy char-set:letter)))
        (lambda (d i)
          (test-cs d (->char-set "0123456789"))
          (test-cs i (->char-set "abcdefABCDEF"))))

      (test-end))))

(define-syntax define-record-type
  (er-macro-transformer
   (lambda (expr rename compare)
     (let* ((name+parent (cadr expr))
            (name (if (pair? name+parent) (car name+parent) name+parent))
            (parent (and (pair? name+parent) (cadr name+parent)))
            (name-str (symbol->string (identifier->symbol name)))
            (procs (cddr expr))
            (make (caar procs))
            (make-fields (cdar procs))
            (pred (cadr procs))
            (fields (cddr procs))
            (_define (rename 'define))
            (_lambda (rename 'lambda))
            (_let (rename 'let))
            (_register (rename 'register-simple-type))
            (_slot-set! (rename 'slot-set!))
            (_type_slot_offset (rename 'type-slot-offset))
            (q (rename 'syntax-quote)))
       ;; catch a common mistake
       (if (eq? name make)
           (error "same binding for record rtd and constructor" name))
       `(,(rename 'begin)
         ;; type
         (,_define ,name (,_register ,name-str ,parent (,q ,(map car fields))))
         ;; predicate
         (,_define ,pred (,(rename 'make-type-predicate)
                          ,(symbol->string (identifier->symbol pred))
                          ,name))
         ;; fields
         ,@(map (lambda (f)
                  (and (pair? f) (pair? (cdr f))
                       `(,_define ,(cadr f)
                          (,(rename 'make-getter)
                           ,(symbol->string
                             (identifier->symbol (cadr f)))
                           ,name
                           (,_type_slot_offset ,name (,q ,(car f)))))))
                fields)
         ,@(map (lambda (f)
                  (and (pair? f) (pair? (cdr f)) (pair? (cddr f))
                       `(,_define ,(car (cddr f))
                          (,(rename 'make-setter)
                           ,(symbol->string
                             (identifier->symbol (car (cddr f))))
                           ,name
                           (,_type_slot_offset ,name (,q ,(car f)))))))
                fields)
         ;; constructor
         (,_define ,make
           ,(let lp ((ls make-fields) (sets '()))
              (cond
               ((null? ls)
                `(,_let ((%make (,(rename 'make-constructor)
                                 ,(symbol->string (identifier->symbol make))
                                 ,name)))
                   (,_lambda ,make-fields
                     (,_let ((res (%make)))
                       ,@sets
                       res))))
               (else
                (let lp2 ((f fields))
                  (cond
                   ((null? f)
                    (error "unknown record field in constructor" (car ls) fields))
                   ((not (eq? (car ls) (caar f)))
                    (lp2 (cdr f)))
                   ((pair? (cddr (car f)))
                    (lp (cdr ls)
                        (cons `(,(car (cddr (car f))) res ,(car ls)) sets)))
                   (else
                    (lp (cdr ls)
                        (cons `(,_slot-set! ,name res (,_type_slot_offset ,name (,q ,(car ls))) ,(car ls))
                              sets))))))))))))))

(define-library (srfi 166)
  (import (srfi 166 base)
          (srfi 166 pretty)
          (srfi 166 columnar)
          (srfi 166 unicode)
          (srfi 166 color))
  (export
   ;; basic
   show displayed written written-shared written-simply escaped maybe-escaped
   numeric numeric/comma numeric/si numeric/fitted
   nl fl space-to tab-to nothing each each-in-list
   joined joined/prefix joined/suffix joined/last joined/dot
   joined/range padded padded/right padded/both
   trimmed trimmed/right trimmed/both trimmed/lazy
   fitted fitted/right fitted/both output-default
   ;; computations
   fn with with! forked call-with-output
   ;; state variables
   make-state-variable
   port row col width output writer pad-char ellipsis
   string-width substring/width substring/preserve
   radix precision decimal-sep decimal-align sign-rule
   comma-sep comma-rule word-separator? ambiguous-is-wide?
   pretty-environment
   ;; pretty
   pretty pretty-shared pretty-simply pretty-with-color
   ;; columnar
   columnar tabular wrapped wrapped/list wrapped/char
   justified from-file line-numbers
   ;; unicode
   terminal-aware
   string-terminal-width string-terminal-width/wide
   substring-terminal-width substring-terminal-width/wide
   substring-terminal-width substring-terminal-width/wide
   substring-terminal-preserve
   upcased downcased
   ;; color
   as-red as-blue as-green as-cyan as-yellow
   as-magenta as-white as-black
   as-bold as-italic as-underline
   as-color as-true-color
   on-red on-blue on-green on-cyan on-yellow
   on-magenta on-white on-black
   on-color on-true-color
   ))
;;; Copyright (C) William D Clinger (2016). All Rights Reserved.
;;; 
;;; Permission is hereby granted, free of charge, to any person
;;; obtaining a copy of this software and associated documentation
;;; files (the "Software"), to deal in the Software without
;;; restriction, including without limitation the rights to use,
;;; copy, modify, merge, publish, distribute, sublicense, and/or
;;; sell copies of the Software, and to permit persons to whom the
;;; Software is furnished to do so, subject to the following
;;; conditions:
;;; 
;;; The above copyright notice and this permission notice shall be
;;; included in all copies or substantial portions of the Software.
;;; 
;;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
;;; EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
;;; OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
;;; NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
;;; HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
;;; WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
;;; FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
;;; OTHER DEALINGS IN THE SOFTWARE. 

;;; FIXME: a lot of these procedures should do more error checking
;;; up front, instead of letting some other procedure deal with it.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;; The following procedures are not part of R7RS (small).
;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define (last-pair x)
  (if (and (pair? x) (pair? (cdr x)))
      (last-pair (cdr x))
      x))

;;; Returns first n elements of the list x.

(define (list-take x n)
  (let loop ((n n)
             (x x)
             (y '()))
    (if (= n 0)
        (reverse y)
        (loop (- n 1) (cdr x) (cons (car x) y)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;; Some macros to make textual arguments and optional arguments
;;; less painful.
;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define-syntax %textual->text
  (syntax-rules ()
    ((_ x)
     (if (string? x)
         (string->text x)
         x))
    ((_ x name arg ...)
     (cond ((string? x)
            (string->text x))
           ((text? x)
            x)
           (else
            (complain name arg ...))))))

;;; Several procedures take a first argument that can be either
;;; a text or a string.  They can be written as though the first
;;; argument is always a text:
;;;
;;; (define-textual (f textual args ...) ...)

(define-syntax define-textual
  (syntax-rules ()
    ((_ (f textual arg . args) expr1 expr2 ...)
     (define (f textual arg . args)
       (let ((textual (%textual->text textual 'f textual arg)))
         expr1 expr2 ...)))))

;;; Several procedures take optional start and end arguments
;;; that follow a textual argument.  They can be written as
;;; though the textual argument is always a text, the start
;;; and end arguments are always provided, and the start and
;;; end arguments are always legal:
;;;
;;; (define-textual-start-end (f args ... textual start end)
;;;   ...)

(define-syntax define-textual-start-end
  (syntax-rules ()
    ((_ (f args ... textual start end) expr1 expr2 ...)
     (define f
       ;; Don't change this to letrec or an internal definition,
       ;; because recursive calls should call the version that checks.
       (let ((f
              (lambda (args ... textual start end) expr1 expr2 ...)))
         (case-lambda
          ((args ... textual)
           (let ((text (%textual->text textual f args ... textual)))
             (f args ... text 0 (%text-length text))))
          ((args ... textual start)
           (let* ((text (%textual->text textual f args ... textual start))
                  (n (%text-length text)))
             (if (and (exact-integer? start)
                      (<= 0 start n))
                 (f args ... text start n)
                 (complain 'f args ... textual start))))
          ((args ... textual start end)
           (let* ((text (%textual->text textual f args ... textual start end))
                  (n (%text-length text)))
             (if (and (exact-integer? start)
                      (exact-integer? end)
                      (<= 0 start end n))
                 (f args ... text start end)
                 (complain 'f args ... textual start end))))))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;; Predicates
;;;
;;; text? is defined by the kernel

(define (textual? x)
  (or (text? x)
      (string? x)))

(define (textual-null? txt)
  (= 0 (textual-length txt)))

(define-textual-start-end (textual-every pred textual start end)
  (if (= start end)
      #t
      (let ((end-1 (- end 1)))
        (let loop ((i start))
          (if (= i end-1)
              (pred (%text-ref textual i))
              (and (pred (%text-ref textual i))
                   (loop (+ i 1))))))))

(define-textual-start-end (textual-any pred textual start end)
  (let loop ((i start))
    (if (= i end)
        #f
        (or (pred (%text-ref textual i))
            (loop (+ i 1))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;; Constructors
;;;
;;; text-tabulate is defined by the kernel

(define (make-text n c)
  (text-tabulate (lambda (i) c) n))

(define (text . chars)
  (string->text (list->string chars)))

;;; These next two procedures take care to accumulate texts of
;;; the kernel's preferred size, N.

(define text-unfold
  (case-lambda
   ((stop? mapper succ seed)
    (text-unfold stop? mapper succ seed (text) (lambda (x) (text))))
   ((stop? mapper succ seed base)
    (text-unfold stop? mapper succ seed base (lambda (x) (text))))
   ((stop? mapper succ seed base make-final)
    (let* ((txt (%textual->text (if (char? base) (text base) base)
                                'text-unfold
                                stop? mapper succ seed base make-final))
           (k (%text-length txt)))
      (let loop ((k k)
                 (texts (list txt))
                 (chars '())
                 (seed seed))
        (cond ((>= k N)
               (let* ((k/N   (quotient k N))
                      (k     (- k (* k/N N)))
                      (texts (cons (reverse-list->text (list-tail chars k))
                                   texts))
                      (chars (list-take chars k)))
                 (loop k texts chars seed)))
              ((stop? seed)
               (let* ((texts (if (null? chars)
                                 texts
                                 (cons (reverse-list->text chars) texts)))
                      (final (make-final seed))
                      (final (cond ((char? final) (text final))
                                   ((string? final) (string->text final))
                                   ((text? final) final)
                                   (else
                                    (%bad-final 'text-unfold final)))))
                 (textual-concatenate-reverse texts final)))
              (else
               (let ((x (mapper seed)))
                 (cond ((char? x)
                        (loop (+ k 1)
                              texts
                              (cons x chars)
                              (succ seed)))
                       ((string? x)
                        (loop (+ k (string-length x))
                              texts
                              (append (reverse (string->list x)) chars)
                              (succ seed)))
                       ((text? x)
                        (loop (+ k (%text-length x))
                              texts
                              (append (reverse (textual->list x)) chars)
                              (succ seed)))
                       (else
                        (complain 'text-unfold
                                  stop? mapper succ seed
                                  base make-final)))))))))))

(define text-unfold-right
  (case-lambda
   ((stop? mapper succ seed)
    (text-unfold-right stop? mapper succ seed (text) (lambda (x) (text))))
   ((stop? mapper succ seed base)
    (text-unfold-right stop? mapper succ seed base (lambda (x) (text))))
   ((stop? mapper succ seed base make-final)
    (let* ((txt (%textual->text (if (char? base) (text base) base)
                                'text-unfold-right
                                stop? mapper succ seed base make-final))
           (k (%text-length txt)))
      (let loop ((k k)
                 (texts (list txt))
                 (chars '())
                 (seed seed))
        (cond ((>= k N)
               (let* ((k/N   (quotient k N))
                      (k     (- k (* k/N N)))
                      (texts (cons (list->text (list-tail chars k)) texts))
                      (chars (list-take chars k)))
                 (loop k texts chars seed)))
              ((stop? seed)
               (let* ((texts (if (null? chars)
                                 texts
                                 (cons (list->text chars) texts)))
                      (final (make-final seed))
                      (final (cond ((char? final) (text final))
                                   ((string? final) (string->text final))
                                   ((text? final) final)
                                   (else
                                    (%bad-final 'text-unfold-right
                                                final)))))
                 (textual-concatenate (cons final texts))))
              (else
               (let ((x (mapper seed)))
                 (cond ((char? x)
                        (loop (+ k 1)
                              texts
                              (cons x chars)
                              (succ seed)))
                       ((string? x)
                        (loop (+ k (string-length x))
                              texts
                              (append (string->list x) chars)
                              (succ seed)))
                       ((text? x)
                        (loop (+ k (%text-length x))
                              texts
                              (append (textual->list x) chars)
                              (succ seed)))
                       (else
                        (complain 'text-unfold-right
                                  stop? mapper succ seed
                                  base make-final)))))))))))

(define (%bad-final name final)
  (error (string-append (symbol->string name)
                        " : make-final returned illegal value : ")
         final))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;; Conversion
;;;
;;; FIXME: a lot of these could be made more efficient, especially
;;; when a string is passed instead of a text.

(define (textual->text x . rest)
  (cond ((string? x)
         (string->text x))
        ((text? x)
         x)
        ((null? rest)
         (error "illegal argument passed to textual->text : " x))
        (else (apply error rest))))

(define textual->string
  (case-lambda
   ((txt)
    (if (string? txt)
        txt
        (textual->string txt 0 (textual-length txt))))
   ((txt start)
    (if (string? txt)
        (substring txt start (string-length txt))
        (textual->string txt start (textual-length txt))))
   ((txt start end)
    (let* ((txt (%textual->text txt 'textual->string txt start end))
           (n (- end start))
           (s (make-string n)))
      (do ((i start (+ i 1)))
          ((= i end)
           s)
        (string-set! s (- i start) (%text-ref txt i)))))))

(define-textual-start-end (textual->vector txt start end)
  (list->vector (string->list (textual->string (subtext txt start end)))))

(define-textual-start-end (textual->list txt start end)
  (string->list (textual->string (subtext txt start end))))

(define string->text
  (case-lambda
   ((s)
    (%string->text s))
   ((s start)
    (%string->text (substring s start (string-length s))))
   ((s start end)
    (%string->text (substring s start end)))))

(define (vector->text v . start/end)
  (%string->text (list->string (apply vector->list v start/end))))

(define (list->text chars . start/end)
  (apply string->text (list->string chars) start/end))

(define (reverse-list->text chars)
  (string->text (list->string (reverse chars))))

;;; FIXME: if txt is a string, should just call string->utf8

(define-textual-start-end (textual->utf8 txt start end)
  (string->utf8 (textual->string (subtext txt start end))))

(define-textual-start-end (textual->utf16 txt start end)
  (%textual->utf16 txt start end #f))

(define-textual-start-end (textual->utf16be txt start end)
  (%textual->utf16 txt start end 'big))

(define-textual-start-end (textual->utf16le txt start end)
  (%textual->utf16 txt start end 'little))

;;; FIXME: should this check for illegal code points?

(define (%textual->utf16 txt start end endianness)
  (let* ((n (textual-fold (lambda (c n)
                            (cond ((< (char->integer c) #x10000)
                                   (+ n 2))
                                  (else
                                   (+ n 4))))
                          0
                          txt start end))
         (n (if endianness n (+ n 2)))
         (result (make-bytevector n 0))
         (hibits (case endianness
                  ((big) 0)
                  ((little) 1)
                  (else 0)))
         (lobits (- 1 hibits)))
    (if (not endianness)
        (begin (bytevector-u8-set! result 0 #xfe)
               (bytevector-u8-set! result 1 #xff)))
    (let loop ((i start)
               (j (if endianness 0 2)))
      (if (= i end)
          result
          (let* ((c (text-ref txt i))
                 (cp (char->integer c)))
            (cond ((< cp #x10000)
                   (let* ((high (quotient cp 256))
                          (low  (- cp (* 256 high))))
                     (bytevector-u8-set! result (+ j hibits) high)
                     (bytevector-u8-set! result (+ j lobits) low))
                   (loop (+ i 1) (+ j 2)))
                  (else
                   (let* ((k (- cp #x10000))
                          (high-surrogate (+ #xd800 (quotient k 1024)))
                          (low-surrogate  (+ #xdc00 (remainder k 1024)))
                          (high0 (quotient high-surrogate 256))
                          (low0  (- high-surrogate (* 256 high0)))
                          (high1 (quotient low-surrogate 256))
                          (low1  (- low-surrogate  (* 256 high1))))
                     (bytevector-u8-set! result (+ j hibits) high0)
                     (bytevector-u8-set! result (+ j lobits) low0)
                     (bytevector-u8-set! result (+ j 2 hibits) high1)
                     (bytevector-u8-set! result (+ j 2 lobits) low1))
                   (loop (+ i 1) (+ j 4)))))))))

(define utf8->text
  (case-lambda
   ((bv)
    (if (bytevector? bv)
        (string->text (utf8->string bv))
        (complain 'utf8->text bv)))
   ((bv start)
    (if (and (bytevector? bv)
             (exact-integer? start)
             (<= 0 start (bytevector-length bv)))
        (string->text (utf8->string bv start))
        (complain 'utf8->text bv start)))
   ((bv start end)
    (if (and (bytevector? bv)
             (exact-integer? start)
             (exact-integer? end)
             (<= 0 start end (bytevector-length bv)))
        (string->text (utf8->string bv start end))
        (complain 'utf8->text bv start end)))))

(define utf16->text
  (case-lambda
   ((bv)
    (if (bytevector? bv)
        (%utf16->text bv 0 (bytevector-length bv) #f)
        (complain 'utf16->text bv)))
   ((bv start)
    (if (and (bytevector? bv)
             (exact-integer? start)
             (<= 0 start (bytevector-length bv)))
        (%utf16->text bv start (bytevector-length bv) #f)
        (complain 'utf16->text bv start)))
   ((bv start end)
    (if (and (bytevector? bv)
             (exact-integer? start)
             (exact-integer? end)
             (<= 0 start end (bytevector-length bv)))
        (%utf16->text bv start end #f)
        (complain 'utf16->text bv start end)))))

(define utf16be->text
  (case-lambda
   ((bv)
    (if (bytevector? bv)
        (%utf16->text bv 0 (bytevector-length bv) 'big)
        (complain 'utf16be->text bv)))
   ((bv start)
    (if (and (bytevector? bv)
             (exact-integer? start)
             (<= 0 start (bytevector-length bv)))
        (%utf16->text bv start (bytevector-length bv) 'big)
        (complain 'utf16be->text bv start)))
   ((bv start end)
    (if (and (bytevector? bv)
             (exact-integer? start)
             (exact-integer? end)
             (<= 0 start end (bytevector-length bv)))
        (%utf16->text bv start end 'big)
        (complain 'utf16be->text bv start end)))))

(define utf16le->text
  (case-lambda
   ((bv)
    (if (bytevector? bv)
        (%utf16->text bv 0 (bytevector-length bv) 'little)
        (complain 'utf16le->text bv)))
   ((bv start)
    (if (and (bytevector? bv)
             (exact-integer? start)
             (even? start)
             (<= 0 start (bytevector-length bv)))
        (%utf16->text bv start (bytevector-length bv) 'little)
        (complain 'utf16le->text bv start)))
   ((bv start end)
    (if (and (bytevector? bv)
             (exact-integer? start)
             (exact-integer? end)
             (even? start)
             (even? end)
             (<= 0 start end (bytevector-length bv)))
        (%utf16->text bv start end 'little)
        (complain 'utf16le->text bv start end)))))

(define (%utf16->text bv start end endianness)
  (let* ((bom (and (not endianness)
                   (< start end)
                   (let ((byte0 (bytevector-u8-ref bv start))
                         (byte1 (bytevector-u8-ref bv (+ start 1))))
                     (cond ((and (= byte0 #xfe) (= byte1 #xff))
                            'big)
                           ((and (= byte1 #xfe) (= byte0 #xff))
                            'little)
                           (else #f)))))
         (start (if bom (+ start 2) start))
         (endianness (or endianness bom 'big))
         (hibits (if (eq? endianness 'big) 0 1))
         (lobits (- 1 hibits)))
    (text-unfold
     (lambda (i) (>= i end))
     (lambda (i)
       (let* ((high (bytevector-u8-ref bv (+ i hibits)))
              (low  (bytevector-u8-ref bv (+ i lobits)))
              (cp   (if (= high 0) low (+ (* 256 high) low))))
         (cond ((< cp #xd800)
                (integer->char cp))
               ((and (< cp #xdc00)
                     (< (+ i 2) end))
                (let* ((i (+ i 2))
                       (high (bytevector-u8-ref bv (+ i hibits)))
                       (low  (bytevector-u8-ref bv (+ i lobits)))
                       (cp2  (if (= high 0) low (+ (* 256 high) low))))
                  (cond ((<= #xdc00 cp2 #xdfff)
                         (integer->char
                          (+ #x10000
                             (* 1024 (- cp #xd800))
                             (- cp2 #xdc00))))
                        (else
                         (%illegal-utf16 bv (- i 2) cp cp2)))))
               ((< cp #x10000)
                (integer->char cp))
               (else
                (%illegal-utf16 bv i cp)))))
     (lambda (i)
       (let ((cp (+ (* 256 (bytevector-u8-ref bv (+ i hibits)))
                    (bytevector-u8-ref bv (+ i lobits)))))
         (if (or (< cp #xd800)
                 (<= #xe000 cp #xffff))
             (+ i 2)
             (+ i 4))))
     start)))

(define (%illegal-utf16 bv i cp . rest)
  (if (null? rest)
      (error "illegal UTF-16: " bv i cp)
      (error "illegal UTF-16: " bv i cp (car rest))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;; Selection
;;;
;;; text-length, text-ref, and subtext are defined by the kernel

(define (textual-length txt)
  (cond ((string? txt)
         (string-length txt))
        ((text? txt)
         (%text-length txt))
        (else
         (complain 'textual-length txt))))

(define (textual-ref txt i)
  (cond ((string? txt)
         (string-ref txt i))
        ((text? txt)
         (%text-ref txt i))
        (else
         (complain 'textual-ref txt))))

(define-textual (subtextual txt start end)
  (subtext txt start end))

;;; FIXME: could be faster, but this procedure shouldn't be used much

(define-textual-start-end (textual-copy text start end)
  (string->text (textual->string text start end)))

(define-textual (textual-take txt nchars)
  (subtextual txt 0 nchars))

(define-textual (textual-drop txt nchars)
  (subtextual txt nchars (%text-length txt)))

(define-textual (textual-take-right txt nchars)
  (let ((n (%text-length txt)))
    (subtextual txt (- n nchars) n)))

(define-textual (textual-drop-right txt nchars)
  (let ((n (%text-length txt)))
    (subtextual txt 0 (- n nchars))))

(define textual-pad
  (case-lambda
   ((txt len)
    (let ((txt (%textual->text txt 'textual-pad txt len)))
      (%text-pad txt len #\space 0 (%text-length txt))))
   ((txt len c)
    (let ((txt (%textual->text txt 'textual-pad txt len c)))
      (%text-pad txt len c 0 (%text-length txt))))
   ((txt len c start)
    (let ((txt (%textual->text txt 'textual-pad txt len c start)))
      (%text-pad txt len c start (%text-length txt))))
   ((txt len c start end)
    (%text-pad (%textual->text txt 'textual-pad txt len c start end)
               len c start end))))

(define (%text-pad txt len c start end)
  (if (and (exact-integer? len)
           (char? c)
           (exact-integer? start)
           (exact-integer? end)
           (<= 0 len)
           (<= 0 start end))
      (let* ((n (%text-length txt))
             (k (- end start)))
        (cond ((not (<= end n))
               (complain 'textual-pad txt len c start end))
              ((= n k len)
               txt)
              ((= k len)
               (if (= n k)
                   txt
                   (subtext txt start end)))
              ((< k len)
               (textual-append (make-text (- len k) c)
                               (if (= n k)
                                   txt
                                   (subtext txt start end))))
              (else
               (subtext txt (- end len) end))))
      (complain 'textual-pad txt len c start end)))

(define textual-pad-right
  (case-lambda
   ((txt len)
    (let ((txt (%textual->text txt 'textual-pad-right txt len)))
      (%text-pad-right txt len #\space 0 (%text-length txt))))
   ((txt len c)
    (let ((txt (%textual->text txt 'textual-pad-right txt len c)))
      (%text-pad-right txt len c 0 (%text-length txt))))
   ((txt len c start)
    (let ((txt (%textual->text txt 'textual-pad-right txt len c start)))
      (%text-pad-right txt len c start (%text-length txt))))
   ((txt len c start end)
    (%text-pad-right (%textual->text txt
                                     'textual-pad-right txt len c start end)
                     len c start end))))

(define (%text-pad-right txt len c start end)
  (if (and (exact-integer? len)
           (char? c)
           (exact-integer? start)
           (exact-integer? end)
           (<= 0 len)
           (<= 0 start end))
      (let* ((n (%text-length txt))
             (k (- end start)))
        (cond ((not (<= end n))
               (complain 'textual-pad-right txt len c start end))
              ((= n k len)
               txt)
              ((= k len)
               (if (= n k)
                   txt
                   (subtext txt start end)))
              ((< k len)
               (textual-append (if (= n k)
                                   txt
                                   (subtext txt start end))
                               (make-text (- len k) c)))
              (else
               (subtext txt start (+ start len)))))
      (complain 'textual-pad-right txt len c start end)))

(define textual-trim
  (case-lambda
   ((txt)
    (textual-trim txt char-whitespace? 0))
   ((txt pred)
    (textual-trim txt pred 0))
   ((txt pred start)
    (let ((txt (%textual->text txt 'textual-trim txt pred start)))
      (%text-trim txt pred start (%text-length txt))))
   ((txt pred start end)
    (let ((txt (%textual->text txt 'textual-trim txt pred start end)))
      (%text-trim txt pred start end)))))

(define (%text-trim txt pred start end)
  (if (and (procedure? pred)
           (exact-integer? start)
           (exact-integer? end)
           (<= 0 start end (%text-length txt)))
      (let loop ((i start))
        (cond ((= i end)
               (text))
              ((pred (%text-ref txt i))
               (loop (+ i 1)))
              (else
               (subtext txt i end))))
      (complain 'textual-trim txt pred start end)))

(define textual-trim-right
  (case-lambda
   ((txt)
    (textual-trim-right txt char-whitespace? 0))
   ((txt pred)
    (textual-trim-right txt pred 0))
   ((txt pred start)
    (let ((txt (%textual->text txt 'textual-trim-right txt pred start)))
      (%text-trim-right txt pred start (%text-length txt))))
   ((txt pred start end)
    (let ((txt (%textual->text txt 'textual-trim-right txt pred start end)))
      (%text-trim-right txt pred start end)))))

(define (%text-trim-right txt pred start end)
  (if (and (procedure? pred)
           (exact-integer? start)
           (exact-integer? end)
           (<= 0 start end (%text-length txt)))
      (let loop ((i (- end 1)))
        (cond ((< i start)
               (text))
              ((pred (%text-ref txt i))
               (loop (- i 1)))
              (else
               (subtext txt start (+ i 1)))))
      (complain 'textual-trim-right txt pred start end)))

(define textual-trim-both
  (case-lambda
   ((txt)
    (textual-trim-both txt char-whitespace? 0))
   ((txt pred)
    (textual-trim-both txt pred 0))
   ((txt pred start)
    (let ((txt (%textual->text txt 'textual-trim-both txt pred start)))
      (%text-trim-both txt pred start (%text-length txt))))
   ((txt pred start end)
    (let ((txt (%textual->text txt 'textual-trim-both txt pred start end)))
      (%text-trim-both txt pred start end)))))

;;; This is efficient because subtext is fast.

(define (%text-trim-both txt pred start end)
  (if (and (procedure? pred)
           (exact-integer? start)
           (exact-integer? end)
           (<= 0 start end (%text-length txt)))
      (textual-trim (textual-trim-right txt pred start end)
                    pred)
      (complain 'textual-trim-both txt pred start end)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;; Replacement

(define textual-replace
  (case-lambda
   ((txt1 txt2 start1 end1 start2 end2)
    (textual-append (subtextual txt1 0 start1)
                    (subtextual txt2 start2 end2)
                    (subtextual txt1 end1 (textual-length txt1))))
   ((txt1 txt2 start1 end1 start2)
    (textual-append (subtextual txt1 0 start1)
                    (subtextual txt2 start2 (textual-length txt2))
                    (subtextual txt1 end1 (textual-length txt1))))
   ((txt1 txt2 start1 end1)
    (textual-append (subtextual txt1 0 start1)
                    txt2
                    (subtextual txt1 end1 (textual-length txt1))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;; Comparison

(define (make-nary-comparison name binop0)
  (let ((binop (lambda (a b)
                 (let ((a (%textual->text a name a b))
                       (b (%textual->text b name a b)))
                   (binop0 a b)))))
    (letrec ((loop (lambda (first rest)
                     (cond ((null? rest)
                            #t)
                           ((binop first (car rest))
                            (loop (car rest) (cdr rest)))
                           (else
                            #f)))))
      (lambda (a b . rest)
        (if (null? rest)
            (binop a b)
            (and (binop a b)
                 (loop b rest)))))))

(define textual=?
  (make-nary-comparison 'textual=?
                        (lambda (a b)
                          (%text-compare a b =))))

(define textual<?
  (make-nary-comparison 'textual<?
                        (lambda (a b)
                          (%text-compare a b <))))

(define textual<=?
  (make-nary-comparison 'textual<=?
                        (lambda (a b)
                          (%text-compare a b <=))))

(define textual>?
  (make-nary-comparison 'textual>?
                        (lambda (a b)
                          (%text-compare a b >))))

(define textual>=?
  (make-nary-comparison 'textual>=?
                        (lambda (a b)
                          (%text-compare a b >=))))

(define textual-ci=?
  (make-nary-comparison 'textual-ci=?
                        (lambda (a b)
                          (%text-compare-ci a b = string-ci=?))))

(define textual-ci<?
  (make-nary-comparison 'textual-ci<?
                        (lambda (a b)
                          (%text-compare-ci a b < string-ci<?))))

(define textual-ci<=?
  (make-nary-comparison 'textual-ci<=?
                        (lambda (a b)
                          (%text-compare-ci a b <= string-ci<=?))))

(define textual-ci>?
  (make-nary-comparison 'textual-ci>?
                        (lambda (a b)
                          (%text-compare-ci a b > string-ci>?))))

(define textual-ci>=?
  (make-nary-comparison 'textual-ci>=?
                        (lambda (a b)
                          (%text-compare-ci a b >= string-ci>=?))))

;;; Compares texts a and b.
;;; Determines whether a is less than b (-1), equal (0), or
;;; greater than b (+1), computes the boolean result by
;;; calling make-boolean on that numerical value and 0.

(define (%text-compare a b make-boolean)
  (let* ((na (%text-length a))
         (nb (%text-length b))
         (n (if (<= na nb) na nb)))
    (define (loop i)
      (if (= i n)
          (cond ((< na nb) (make-boolean -1 0))
                ((> na nb) (make-boolean +1 0))
                (else (make-boolean 0 0)))
          (let ((ca (%text-ref a i))
                (cb (%text-ref b i)))
            (cond ((char<? ca cb) (make-boolean -1 0))
                  ((char>? ca cb) (make-boolean +1 0))
                  (else (loop (+ i 1)))))))
    (loop 0)))

;;; Compares texts a and b, folding case.
;;; If either text contains non-ASCII characters, both are converted
;;; to strings and compared using string-pred.

(define (%text-compare-ci a b make-boolean string-pred)
  (let* ((na (%text-length a))
         (nb (%text-length b))
         (n (if (<= na nb) na nb)))
    (define (loop i)
      (if (= i n)
          (cond ((< na nb) (make-boolean -1 0))
                ((> na nb) (make-boolean +1 0))
                (else (make-boolean 0 0)))
          (let ((ca (%text-ref a i))
                (cb (%text-ref b i)))
            (if (or (char>? ca #\delete)
                    (char>? cb #\delete))
                (string-pred (textual->string a)
                             (textual->string b))
                (let ((ca (char-foldcase ca))
                      (cb (char-foldcase cb)))
                  (cond ((char<? ca cb) (make-boolean -1 0))
                        ((char>? ca cb) (make-boolean +1 0))
                        (else (loop (+ i 1)))))))))
    (loop 0)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;; Prefixes & suffixes

;;; FIXME: this is a prototype of how optional arguments should
;;; be handled.

(define (%make-text-prefix/suffix-proc proc name)
  (case-lambda
   (()
    (complain name))
   ((x)
    (complain name x))
   ((t1 t2)
    (let ((txt1 (%textual->text t1 name t1 t2))
          (txt2 (%textual->text t2 name t1 t2)))
      (proc txt1 txt2 0 (%text-length txt1) 0 (%text-length txt2))))
   ((t1 t2 start1)
    (let* ((txt1 (%textual->text t1 name t1 t2))
           (txt2 (%textual->text t2 name t1 t2))
           (n1 (%text-length txt1)))
      (if (and (exact-integer? start1)
               (<= 0 start1 n1))
          (proc txt1 txt2 start1 n1 0 (%text-length txt2))
          (complain name t1 t2 start1))))
   ((t1 t2 start1 end1)
    (let* ((txt1 (%textual->text t1 name t1 t2))
           (txt2 (%textual->text t2 name t1 t2))
           (n1 (%text-length txt1)))
      (if (and (exact-integer? start1)
               (exact-integer? end1)
               (<= 0 start1 end1 n1))
          (proc txt1 txt2 start1 end1 0 (%text-length txt2))
          (complain name t1 t2 start1 end1))))
   ((t1 t2 start1 end1 start2)
    (let* ((txt1 (%textual->text t1 name t1 t2))
           (txt2 (%textual->text t2 name t1 t2))
           (n1 (%text-length txt1))
           (n2 (%text-length txt2)))
      (if (and (exact-integer? start1)
               (exact-integer? end1)
               (exact-integer? start2)
               (<= 0 start1 end1 n1)
               (<= 0 start2 n2))
          (proc txt1 txt2 start1 end1 start2 n2)
          (complain name t1 t2 start1 end1 start2))))
   ((t1 t2 start1 end1 start2 end2)
    (let* ((txt1 (%textual->text t1 name t1 t2))
           (txt2 (%textual->text t2 name t1 t2))
           (n1 (%text-length txt1))
           (n2 (%text-length txt2)))
      (if (and (exact-integer? start1)
               (exact-integer? end1)
               (exact-integer? start2)
               (exact-integer? end2)
               (<= 0 start1 end1 n1)
               (<= 0 start2 end2 n2))
          (proc txt1 txt2 start1 end1 start2 end2)
          (complain name t1 t2 start1 end1 start2 end2))))
   ((t1 t2 start1 end1 start2 end2 oops . rest)
    (apply complain name t1 t2 start1 end1 start2 end2 oops rest))))

(define textual-prefix-length
  (%make-text-prefix/suffix-proc
   (lambda (txt1 txt2 start1 end1 start2 end2)
     (%text-prefix-length txt1 txt2 start1 end1 start2 end2))
   'textual-prefix-length))

(define textual-suffix-length
  (%make-text-prefix/suffix-proc
   (lambda (txt1 txt2 start1 end1 start2 end2)
     (%text-suffix-length txt1 txt2 start1 end1 start2 end2))
   'textual-suffix-length))

(define textual-prefix?
  (%make-text-prefix/suffix-proc
   (lambda (txt1 txt2 start1 end1 start2 end2)
     (%text-prefix? txt1 txt2 start1 end1 start2 end2))
   'textual-prefix?))

(define textual-suffix?
  (%make-text-prefix/suffix-proc
   (lambda (txt1 txt2 start1 end1 start2 end2)
     (%text-suffix? txt1 txt2 start1 end1 start2 end2))
   'textual-suffix?))

;;; All error checking has already been done.

(define (%text-prefix-length txt1 txt2 start1 end1 start2 end2)
  (let* ((k1   (- end1 start1))
         (k2   (- end2 start2))
         (k    (min k1 k2))
         (end1 (+ start1 k)))
    (let loop ((i start1)
               (j start2))
      (cond ((= i end1) k)
            ((char=? (%text-ref txt1 i) (%text-ref txt2 j))
             (loop (+ i 1) (+ j 1)))
            (else (- i start1))))))

(define (%text-suffix-length txt1 txt2 start1 end1 start2 end2)
  (let* ((k1     (- end1 start1))
         (k2     (- end2 start2))
         (k      (min k1 k2))
         (start1 (- end1 k)))
    (let loop ((i (- end1 1))
               (j (- end2 1)))
      (cond ((< i start1) k)
            ((char=? (%text-ref txt1 i) (%text-ref txt2 j))
             (loop (- i 1) (- j 1)))
            (else (- end1 i 1))))))

(define (%text-prefix? txt1 txt2 start1 end1 start2 end2)
  (let ((k1 (- end1 start1))
        (k2 (- end2 start2)))
    (and (<= k1 k2)
         (= k1 (%text-prefix-length txt1 txt2 start1 end1 start2 end2)))))

(define (%text-suffix? txt1 txt2 start1 end1 start2 end2)
  (let ((k1 (- end1 start1))
        (k2 (- end2 start2)))
    (and (<= k1 k2)
         (= k1 (%text-suffix-length txt1 txt2 start1 end1 start2 end2)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;; Searching

(define-textual (textual-index txt pred . rest)
  (let ((start (if (null? rest) 0 (car rest)))
        (end (if (or (null? rest) (null? (cdr rest)))
                 (%text-length txt)
                 (car (cdr rest)))))
    (if (and (procedure? pred)
             (exact-integer? start)
             (exact-integer? end)
             (<= 0 start end (%text-length txt)))
        (let loop ((i start))
          (cond ((= i end)
                 #f)
                ((pred (%text-ref txt i))
                 i)
                (else
                 (loop (+ i 1)))))
        (apply complain 'textual-index txt pred rest))))

(define-textual (textual-index-right txt pred . rest)
  (let ((start (if (null? rest) 0 (car rest)))
        (end (if (or (null? rest) (null? (cdr rest)))
                 (%text-length txt)
                 (car (cdr rest)))))
    (if (and (procedure? pred)
             (exact-integer? start)
             (exact-integer? end)
             (<= 0 start end (%text-length txt)))
        (let loop ((i (- end 1)))
          (cond ((< i start)
                 #f)
                ((pred (%text-ref txt i))
                 i)
                (else
                 (loop (- i 1)))))
        (apply complain 'textual-index-right txt pred rest))))

(define (textual-skip txt pred . rest)
  (apply textual-index txt (lambda (x) (not (pred x))) rest))

(define (textual-skip-right txt pred . rest)
  (apply textual-index-right txt (lambda (x) (not (pred x))) rest))

(define (textual-contains t1 t2 . rest0)
  (let* ((txt1 (%textual->text t1 'textual-contains t1 t2))
         (txt2 (%textual->text t2 'textual-contains t1 t2))
         (rest rest0)
         (start1 (if (null? rest) 0 (car rest)))
         (rest (if (null? rest) rest (cdr rest)))
         (end1 (if (null? rest) (%text-length txt1) (car rest)))
         (rest (if (null? rest) rest (cdr rest)))
         (start2 (if (null? rest) 0 (car rest)))
         (rest (if (null? rest) rest (cdr rest)))
         (end2 (if (null? rest) (%text-length txt2) (car rest)))
         (rest (if (null? rest) rest (cdr rest))))
    (if (and (null? rest)
             (exact-integer? start1)
             (exact-integer? end1)
             (exact-integer? start2)
             (exact-integer? end2)
             (<= 0 start1 end1 (%text-length txt1))
             (<= 0 start2 end2 (%text-length txt2)))
        (%textual-contains txt1 txt2 start1 end1 start2 end2)
        (apply complain 'textual-contains t1 t2 rest0))))

;;; No checking needed here.
;;;
;;; Naive search works well when
;;;     txt1 is very short
;;;     txt2 is very short
;;;     txt2 is almost as long as txt1
;;; Boyer-Moore-Horspool search works well when
;;;     txt2 is very short
;;;     txt1 is considerably longer than txt2, txt2 is not too short,
;;;         and the rightmost character of txt2 is distinct from
;;;         (in its low 8 bits) from several characters that precede it
;;; Rabin-Karp works reasonably well all the time, so is used when
;;;     neither naive search nor Boyer-Moore-Horspool do well

(define %threshold:short1 10)   ; is txt1 shorter than this?
(define %threshold:short2 3)    ; is txt2 shorter than this?
(define %threshold:longer 1)    ; is txt1 at least this much longer?
(define %threshold:rightmost 2) ; are rightmost characters the same?

(define (%textual-contains txt1 txt2 start1 end1 start2 end2)
  (let ((n1 (- end1 start1))
        (n2 (- end2 start2)))
    (cond ((< n1 %threshold:short1)
           (%textual-contains:naive txt1 txt2 start1 end1 start2 end2))
          ((< (- n1 n2) %threshold:longer)
           (%textual-contains:naive txt1 txt2 start1 end1 start2 end2))
          ((< n2 %threshold:short2)
           (%textual-contains:boyer-moore txt1 txt2 start1 end1 start2 end2))
          ((and (> n2 %threshold:rightmost)
                (let ((j (remainder (char->integer (text-ref txt2 (- end2 1)))
                                    128)))
                  (let loop ((i (- end2 %threshold:rightmost)))
                    (cond ((= i (- end2 1))
                           #t)
                          ((= j
                              (remainder (char->integer (text-ref txt2 i))
                                         128))
                           #f)
                          (else
                           (loop (+ i 1)))))))
           (%textual-contains:boyer-moore txt1 txt2 start1 end1 start2 end2))
          (else
           (%textual-contains:rabin-karp txt1 txt2 start1 end1 start2 end2)))))

(define (%textual-contains:naive txt1 txt2 start1 end1 start2 end2)
  (let* ((n1 (- end1 start1))
         (n2 (- end2 start2))
         (lim1 (- end1 n2)))
    (let loop ((i start1))
      (cond ((> i lim1)
             #f)
            ((textual-prefix? txt2 txt1 start2 end2 i end1)
             i)
            (else
             (loop (+ i 1)))))))

(define (%textual-contains:rabin-karp txt1 txt2 start1 end1 start2 end2)
  (define (hash txt start end)
    (do ((i start (+ i 1))
         (h 0 (+ h (char->integer (text-ref txt i)))))
        ((= i end)
         h)))
  (let* ((n1 (- end1 start1))
         (n2 (- end2 start2))
         (lim1 (- end1 n2))
         (h1 (hash txt1 start1 (min (+ start1 n2) end1)))
         (h2 (hash txt2 start2 end2)))
    (let loop ((i start1)
               (h1 h1))
      (cond ((> i lim1)
             #f)
            ((and (= h1 h2)
                  (textual-prefix? txt2 txt1 start2 end2 i end1))
             i)
            ((= i lim1)
             #f)
            (else
             (loop (+ i 1)
                   (+ (- h1 (char->integer (text-ref txt1 i)))
                      (char->integer (text-ref txt1 (+ i n2))))))))))

;;; This is actually the Boyer-Moore-Horspool algorithm,
;;; but the name is already pretty long.

(define (%textual-contains:boyer-moore txt1 txt2 start1 end1 start2 end2)
  (if (= start2 end2)
      start1
      (let* ((n1 (- end1 start1))
             (n2 (- end2 start2))
             (lim1 (- end1 n2))
             (lastchar (text-ref txt2 (- end2 1)))
             (lastj (remainder (char->integer lastchar) 128))
             (table (make-vector 128 n2)))
        (do ((i 0 (+ i 1)))
            ((>= i (- n2 1)))
          (let* ((c  (text-ref txt2 (+ i start2)))
                 (cp (char->integer c))
                 (j  (remainder cp 128)))
            (vector-set! table j (- n2 i 1))))
        (let loop ((i start1))
          (if (>= i lim1)
              (if (and (= i lim1)
                       (textual-prefix? txt2 txt1 start2 end2 i end1))
                  i
                  #f)
              (let* ((c  (text-ref txt1 (+ i n2 -1)))
                     (cp (char->integer c))
                     (j  (remainder cp 128)))
                (cond ((not (char=? c lastchar))
                       (loop (+ i (vector-ref table j))))
                      ((textual-prefix? txt2 txt1 start2 end2 i end1)
                       i)
                      (else
                       (loop (+ i (vector-ref table lastj)))))))))))

;;; FIXME: no Rabin-Karp algorithm for now

(define (textual-contains-right t1 t2 . rest0)
  (let* ((txt1 (%textual->text t1 'textual-contains-right t1 t2))
         (txt2 (%textual->text t2 'textual-contains-right t1 t2))
         (rest rest0)
         (start1 (if (null? rest) 0 (car rest)))
         (rest (if (null? rest) rest (cdr rest)))
         (end1 (if (null? rest) (%text-length txt1) (car rest)))
         (rest (if (null? rest) rest (cdr rest)))
         (start2 (if (null? rest) 0 (car rest)))
         (rest (if (null? rest) rest (cdr rest)))
         (end2 (if (null? rest) (%text-length txt2) (car rest)))
         (rest (if (null? rest) rest (cdr rest))))
    (if (and (null? rest)
             (exact-integer? start1)
             (exact-integer? end1)
             (exact-integer? start2)
             (exact-integer? end2)
             (<= 0 start1 end1 (%text-length txt1))
             (<= 0 start2 end2 (%text-length txt2)))
        (%textual-contains-right txt1 txt2 start1 end1 start2 end2)
        (apply complain 'textual-contains-right t1 t2 rest0))))

(define (%textual-contains-right txt1 txt2 start1 end1 start2 end2)
  (let ((n1 (- end1 start1))
        (n2 (- end2 start2)))
    (cond ((< n1 %threshold:short1)
           (%textual-contains-right:naive
            txt1 txt2 start1 end1 start2 end2))
          ((< (- n1 n2) %threshold:longer)
           (%textual-contains-right:naive
            txt1 txt2 start1 end1 start2 end2))
          ((< n2 %threshold:short2)
           (%textual-contains-right:boyer-moore
            txt1 txt2 start1 end1 start2 end2))
          (else
           (%textual-contains-right:boyer-moore
            txt1 txt2 start1 end1 start2 end2)))))

(define (%textual-contains-right:naive txt1 txt2 start1 end1 start2 end2)
  (let* ((n1 (- end1 start1))
         (n2 (- end2 start2))
         (lim1 (- end1 n2)))
    (let loop ((i lim1))
      (cond ((< i start1)
             #f)
            ((textual-prefix? txt2 txt1 start2 end2 i end1)
             i)
            (else
             (loop (- i 1)))))))

;;; This is actually the Boyer-Moore-Horspool algorithm,
;;; but the name is already pretty long.

(define (%textual-contains-right:boyer-moore txt1 txt2 start1 end1 start2 end2)
  (if (= start2 end2)
      end1
      (let* ((n1 (- end1 start1))
             (n2 (- end2 start2))
             (firstchar (text-ref txt2 0))
             (firstj (remainder (char->integer firstchar) 128))
             (table (make-vector 128 n2)))
        (do ((i (- n2 1) (- i 1)))
            ((<= i 0))
          (let* ((c  (text-ref txt2 (+ i start2)))
                 (cp (char->integer c))
                 (j  (remainder cp 128)))
            (vector-set! table j i)))
        (let loop ((i (- end1 n2)))
          (if (<= i start1)
              (if (and (= i start1)
                       (textual-prefix? txt2 txt1 start2 end2 i end1))
                  i
                  #f)
              (let* ((c  (text-ref txt1 i))
                     (cp (char->integer c))
                     (j  (remainder cp 128)))
                (cond ((not (char=? c firstchar))
                       (loop (- i (vector-ref table j))))
                      ((textual-prefix? txt2 txt1 start2 end2 i end1)
                       i)
                      (else
                       (loop (- i (vector-ref table firstj)))))))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;; Case conversion

;;; Two special cases:
;;;     the given text can be returned as is
;;;     the given text is entirely ASCII
;;;
;;; For all other cases, calls the corresponding procedures for strings.

(define (textual-upcase txt)
  (cond ((string? txt)
         (string->text (string-upcase txt)))
        ((text? txt)
         (%text-upcase txt))
        (else
         (complain 'textual-upcase txt))))

(define (textual-downcase txt)
  (cond ((string? txt)
         (string->text (string-downcase txt)))
        ((text? txt)
         (%text-downcase txt string-downcase))
        (else
         (complain 'textual-downcase txt))))

(define (textual-foldcase txt)
  (cond ((string? txt)
         (string->text (string-foldcase txt)))
        ((text? txt)
         (%text-downcase txt string-foldcase))
        (else
         (complain 'textual-foldcase txt))))

(define (textual-titlecase txt)
  (cond ((string? txt)
         (string->text (string-titlecase txt)))
        ((text? txt)
         (string->text
          (string-titlecase (textual->string txt))))
        (else
         (complain 'textual-titlecase txt))))

(define (%text-upcase txt)
  (let* ((n (%text-length txt)))

    ;; So far, no conversion has been necessary.

    (define (fastest i)
      (if (= i n)
          txt
          (let ((c (%text-ref txt i)))
            (cond ((char>? c #\delete)
                   (textual-upcase (textual->string txt)))
                  ((char<=? #\a c #\z)
                   (fast i (list (subtext txt 0 i)) '()))
                  (else
                   (fastest (+ i 1)))))))

    ;; Conversions are necessary but it's been all-ASCII so far.
    ;; The upcased text for characters with index < i is
    ;;     (text-concatenate (reverse (cons (list->text (reverse chars))
    ;;                                      texts)))

    (define (fast i texts chars)
      (cond ((= i n)
             (if (null? chars)
                 (textual-concatenate-reverse texts)
                 (textual-concatenate-reverse texts
                                              (reverse-list->text chars))))
            ((and (= 0 (remainder i N))
                  (not (null? chars)))
             (fast i (cons (reverse-list->text chars) texts) '()))
            (else
             (let ((c (%text-ref txt i)))
               (cond ((char>? c #\delete)
                      (textual-append (textual-concatenate-reverse texts)
                                      (reverse-list->text chars)
                                      (string->text
                                       (string-upcase (subtext txt i n)))))
                     ((char<=? #\a c #\z)
                      (fast (+ i 1) texts (cons (char-upcase c) chars)))
                     (else
                      (fast (+ i 1) texts (cons c chars))))))))

    (fastest 0)))

;;; The string-caser is either string-downcase or string-foldcase.
;;; For ASCII, down-casing and fold-casing are the same.

(define (%text-downcase txt string-caser)
  (let* ((n (%text-length txt)))

    ;; So far, no conversion has been necessary.

    (define (fastest i)
      (if (= i n)
          txt
          (let ((c (%text-ref txt i)))
            (cond ((char>? c #\delete)
                   (textual-downcase (textual->string txt)))
                  ((char<=? #\A c #\Z)
                   (fast i (list (subtext txt 0 i)) '()))
                  (else
                   (fastest (+ i 1)))))))

    ;; Conversions are necessary but it's been all-ASCII so far.
    ;; The downcased text for characters with index < i is
    ;;     (textual-concatenate (reverse (cons (list->text (reverse chars))
    ;;                                         texts)))

    (define (fast i texts chars)
      (cond ((= i n)
             (if (null? chars)
                 (textual-concatenate-reverse texts)
                 (textual-concatenate-reverse texts
                                              (reverse-list->text chars))))
            ((and (= 0 (remainder i N))
                  (not (null? chars)))
             (fast i (cons (reverse-list->text chars) texts) '()))
            (else
             (let ((c (%text-ref txt i)))
               (cond ((char>? c #\delete)
                      (textual-append (textual-concatenate-reverse texts)
                                      (reverse-list->text chars)
                                      (string->text
                                       (string-caser (subtext txt i n)))))
                     ((char<=? #\A c #\Z)
                      (fast (+ i 1) texts (cons (char-downcase c) chars)))
                     (else
                      (fast (+ i 1) texts (cons c chars))))))))

    (fastest 0)))

;;; This is a fake version of string-titlecase, to be used only
;;; if there is no Unicode-conforming version available.

(cond-expand
 ((and (not (library (rnrs unicode)))
       (not (library (srfi 129))))
  (define (%string-titlecase s)
    (let* ((s (string-copy (string-foldcase s)))
           (n (string-length s)))
      (define (first-character-of-word! i)
        (if (< i n)
          (let ((c (string-ref s i)))
            (if (char-whitespace? c)
                (first-character-of-word! (+ i 1))
                (begin (string-set! s i (char-upcase c))
                       (subsequent-character! (+ i 1)))))))
      (define (subsequent-character! i)
        (if (< i n)
          (let ((c (string-ref s i)))
            (if (char-whitespace? c)
                (first-character-of-word! (+ i 1))
                (subsequent-character! (+ i 1))))))
      (first-character-of-word! 0)
      s)))
 (else))      

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;; Concatenation
;;;
;;; textual-concatenate is defined by the kernel

(define (textual-append . texts)
  (textual-concatenate texts))

(define textual-concatenate-reverse
  (case-lambda
   ((texts)
    (textual-concatenate (reverse texts)))
   ((texts final-textual)
    (textual-concatenate-reverse (cons final-textual texts)))
   ((texts final-textual end)
    (textual-concatenate-reverse texts
                                 (subtext
                                  (%textual->text final-textual
                                                  'textual-concatenate-reverse
                                                  texts final-textual end)
                                  0 end)))))

(define textual-join
  (case-lambda
   ((textuals)
    (textual-join textuals " " 'infix))
   ((textuals delimiter)
    (textual-join textuals delimiter 'infix))
   ((textuals delimiter grammar)
    (let* ((texts (map (lambda (t) (%textual->text t 'textual-join textuals))
                       textuals))
           (delimiter (%textual->text delimiter
                                      'textual-join textuals delimiter)))
      (if (memq grammar '(infix strict-infix prefix suffix))
          (if (null? texts)
              (case grammar
                ((strict-infix)
                 (complain 'textual-join textuals delimiter grammar))
                (else (text)))
              (let loop ((rtxts (reverse texts))
                         (texts (if (eq? grammar 'suffix)
                                    (list delimiter)
                                    '())))
                (cond ((null? rtxts)
                       (let ((texts (if (eq? grammar 'prefix)
                                        texts
                                        (cdr texts))))
                         (textual-concatenate texts)))
                      (else
                       (loop (cdr rtxts)
                             (cons delimiter (cons (car rtxts) texts)))))))
          (complain 'textual-join textuals delimiter grammar))))))                

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;; Fold & map & friends

(define-textual-start-end (textual-fold kons knil txt start end)
  (if (procedure? kons)
      (let loop ((knil knil)
                 (i start))
        (if (< i end)
            (loop (kons (%text-ref txt i) knil)
                  (+ i 1))
            knil))
      (complain 'textual-fold kons knil txt start end)))

(define-textual-start-end (textual-fold-right kons knil txt start end)
  (if (procedure? kons)
      (let loop ((knil knil)
                 (i (- end 1)))
        (if (>= i start)
            (loop (kons (%text-ref txt i) knil)
                  (- i 1))
            knil))
      (complain 'textual-fold-right kons knil txt start end)))

(define textual-map
  (case-lambda
   ((proc txt)
    (%textual-map1 proc txt))
   ((proc txt1 txt2 . rest)
    (%textual-mapn proc (cons txt1 (cons txt2 rest))))))

(define (%textual-map1 proc txt)
  (let ((txt (%textual->text txt 'textual-map proc txt)))
    (if (procedure? proc)
        (let ((n (%text-length txt)))
          (let loop ((i 0)
                     (pieces '())
                     (chars '())
                     (k 0))
            (cond ((= i n)
                   (textual-concatenate
                    (reverse (%text-map-pieces pieces chars))))
                  ((>= k N)
                   (loop i
                         (%text-map-pieces pieces chars)
                         '()
                         (remainder k N)))
                  (else
                   (let ((x (proc (%text-ref txt i))))
                     (loop (+ i 1)
                           pieces
                           (cons x chars)
                           (+ k (cond ((char? x) 1)
                                      ((string? x) (string-length x))
                                      ((text? x) (%text-length x))
                                      (else
                                       (%textual-map-bad-result proc x))))))))))
        (complain 'textual-map proc txt))))

(define (%textual-mapn proc textuals)
  (if (procedure? proc)
      (let* ((texts (map (lambda (txt)
                           (%textual->text txt 'textual-map textuals))
                         textuals))
             (n (apply min (map %text-length texts))))
        (let loop ((i 0)
                   (pieces '())
                   (chars '())
                   (k 0))
          (cond ((= i n)
                 (textual-concatenate
                  (reverse (%text-map-pieces pieces chars))))
                ((>= k N)
                 (loop i
                       (%text-map-pieces pieces chars)
                       '()
                       (remainder k N)))
                (else
                 (let ((x (apply proc (%fetch-all texts i))))
                   (loop (+ i 1)
                         pieces
                         (cons x chars)
                         (+ k (cond ((char? x) 1)
                                    ((string? x) (string-length x))
                                    ((text? x) (%text-length x))
                                    (else
                                     (%textual-map-bad-result proc x))))))))))
      (complain 'textual-map proc textuals)))

(define (%textual-map-bad-result proc x)
  (error "textual-map: proc returned non-character" x))

;;; Given a list of texts and a list of mixed characters/strings/texts,
;;; in reverse order, converts the second argument into a text and
;;; returns that text consed onto the first argument.

(define (%text-map-pieces texts stuff)
  (let loop ((revstuff stuff)
             (stuff '())
             (n 0))
    (if (null? revstuff)
        (let ((s (make-string n)))    ; probably short
          (let inner-loop ((stuff stuff)
                           (i 0))
            (if (null? stuff)
                (cons (string->text s) texts)
                (let ((x (car stuff)))
                  (cond ((char? x)
                         (string-set! s i x)
                         (inner-loop (cdr stuff) (+ i 1)))
                        ((string? x)
                         (string-copy! s i x)
                         (inner-loop (cdr stuff) (+ i (string-length x))))
                        (else
                         (string-copy! s i (textual->string x))
                         (inner-loop (cdr stuff) (+ i (text-length x)))))))))
        (let* ((x (car revstuff))
               (revstuff (cdr revstuff))
               (stuff (cons x stuff)))
          (loop revstuff
                stuff
                (+ n (cond ((char? x) 1)
                           ((string? x) (string-length x))
                           (else (text-length x)))))))))

(define textual-for-each
  (case-lambda
   ((proc txt)
    (%textual-for-each1 proc txt))
   ((proc txt1 txt2 . rest)
    (%textual-for-eachn proc (cons txt1 (cons txt2 rest))))))

(define (%textual-for-each1 proc txt)
  (let ((txt (%textual->text txt 'textual-for-each proc txt)))
    (if (procedure? proc)
        (let ((n (%text-length txt)))
          (let loop ((i 0))
            (if (< i n)
                (begin (proc (%text-ref txt i))
                       (loop (+ i 1))))))
        (complain 'textual-for-each proc txt))))

(define (%textual-for-eachn proc textuals)
  (if (procedure? proc)
      (let* ((texts (map (lambda (txt)
                           (%textual->text txt 'textual-map textuals))
                         textuals))
             (n (apply min (map %text-length texts))))
        (let loop ((i 0))
          (if (< i n)
              (begin (apply proc (%fetch-all texts i))
                     (loop (+ i 1))))))
      (complain 'textual-for-each proc textuals)))

(define (%fetch-all texts i)
  (if (null? texts)
      '()
      (cons (%text-ref (car texts) i)
            (%fetch-all (cdr texts) i))))

;;; FIXME: there's no reason to convert a string to a text here

(define-textual-start-end (textual-map-index proc txt start end)
  (if (procedure? proc)
      (let ((n end))
        (let loop ((i start)
                   (pieces '())
                   (chars '())
                   (k 0))
          (cond ((= i n)
                 (textual-concatenate
                  (reverse (%text-map-pieces pieces chars))))
                ((>= k N)
                 (loop i
                       (%text-map-pieces pieces chars)
                       '()
                       (remainder k N)))
                (else
                 (let ((x (proc i)))
                   (loop (+ i 1)
                         pieces
                         (cons x chars)
                         (+ k (cond ((char? x) 1)
                                    ((string? x) (string-length x))
                                    ((text? x) (%text-length x))
                                    (else
                                     (%textual-map-bad-result proc x))))))))))
      (complain 'textual-map-index proc txt)))

;;; FIXME: there's no reason to convert a string to a text here

(define-textual-start-end (textual-for-each-index proc txt start end)
  (if (procedure? proc)
      (let ((n end))
        (let loop ((i start))
          (if (< i n)
              (begin (proc i)
                     (loop (+ i 1))))))
      (complain 'textual-for-each-index proc txt)))

(define-textual (textual-count txt pred . rest)
  (let ((start (if (null? rest) 0 (car rest)))
        (end (if (or (null? rest) (null? (cdr rest)))
                 (%text-length txt)
                 (car (cdr rest)))))
    (if (and (procedure? pred)
             (or (null? rest) (null? (cdr rest)) (null? (cdr (cdr rest))))
             (exact-integer? start)
             (exact-integer? end)
             (<= 0 start end (%text-length txt)))
        (textual-fold (lambda (c n)
                        (if (pred c)
                            (+ n 1)
                            n))
                      0 txt start end)
        (complain 'textual-count txt pred start end))))

(define-textual-start-end (textual-filter pred txt start end)
  (if (procedure? pred)
      (textual-map (lambda (c) (if (pred c) c ""))
                   (subtext txt start end))
      (complain 'textual-filter pred txt start end)))

;;; FIXME: checks arguments twice

(define-textual-start-end (textual-remove pred txt start end)
  (textual-filter (lambda (c) (not (pred c))) txt start end))

;;; FIXME: not linear-time unless string-set! is O(1)
;;; (but this is a pretty useless procedure anyway)

(define-textual-start-end (textual-reverse txt start end)
  (let* ((n (- end start))
         (s (make-string n)))
    (do ((i start (+ i 1)))
        ((= i end)
         (string->text s))
      (string-set! s (- n (- i start) 1) (%text-ref txt i)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;; Replication & splitting

(define textual-replicate
  (case-lambda
   ((s from to start end)
    (let ((s (%textual->text s 'textual-replicate s from to start end)))
      (textual-replicate (subtext s start end) from to)))
   ((s from to start)
    (let ((s (%textual->text s 'textual-replicate s from to start)))
      (textual-replicate (subtext s start (textual-length s)) from to)))
   ((s0 from to)
    (let* ((s (%textual->text s0 'textual-replicate s0 from to))
           (n (- to from))
           (len (%text-length s)))
      (cond ((= n 0)
             "")
            ((or (< n 0)
                 (= len 0))
             (complain 'textual-replicate s from to))
            (else
             (let* ((from (mod from len)) ; make from non-negative
                    (to (+ from n)))
               (do ((replicates '() (cons s replicates))
                    (replicates-length 0 (+ replicates-length len)))
                   ((>= replicates-length to)
                    (subtext (apply textual-append replicates)
                             from to))))))))))

(define textual-split
  (case-lambda
   ((s delimiter grammar limit start end)
    (textual-split (subtextual s start end) delimiter grammar limit))
   ((s delimiter grammar limit start)
    (textual-split (subtextual s start (textual-length s))
                   delimiter grammar limit))
   ((s delimiter)
    (textual-split s delimiter 'infix #f))
   ((s delimiter grammar)
    (textual-split s delimiter grammar #f))
   ((s0 delimiter grammar limit)
    (define (bad-arguments)
      (complain 'textual-split s0 delimiter grammar limit))
    (let* ((s (%textual->text s0 'textual-split s0 delimiter grammar limit))
           (delimiter
            (%textual->text delimiter
                            'textual-split s0 delimiter grammar limit))
           (limit (or limit (%text-length s)))
           (splits
            (cond ((= 0 (%text-length delimiter))
                   (%text-split-into-characters s limit))
                  (else
                   (%text-split-using-word s delimiter limit)))))
      (case grammar
        ((infix strict-infix)
         (if (= 0 (%text-length s))
             (if (eq? grammar 'infix)
                 '()
                 (bad-arguments))
             splits))
        ((prefix)
         (if (and (pair? splits)
                  (= 0 (%text-length (car splits))))
             (cdr splits)
             splits))
        ((suffix)
         (if (and (pair? splits)
                  (= 0 (%text-length (car (last-pair splits)))))
             (reverse (cdr (reverse splits)))
             splits))
        (else
         (bad-arguments)))))))

(define (%text-split-into-characters s limit)
  (let ((n (%text-length s)))
    (cond ((> n (+ limit 1))
           (append (%text-split-into-characters (subtext s 0 limit) limit)
                   (list (subtext s limit n))))
          (else
           (map text (textual->list s))))))

;;; FIXME: inefficient

(define (%text-split-using-word txt sep limit)
  (let loop ((i 0)
             (limit limit)
             (texts '()))
    (if (= 0 limit)
        (reverse (cons (subtext txt i (%text-length txt)) texts))
        (let ((i2 (textual-contains txt sep i)))
          (if i2
              (loop (+ i2 (%text-length sep))
                    (- limit 1)
                    (cons (subtext txt i i2) texts))
              (loop i 0 texts))))))

;;; eof
(define-library (srfi 141)
  (import (scheme base) (scheme division))
  (export ceiling-quotient ceiling-remainder ceiling/
          euclidean-quotient euclidean-remainder euclidean/
          floor-quotient floor-remainder floor/
          round-quotient round-remainder round/
          truncate-quotient truncate-remainder truncate/
          balanced-quotient balanced-remainder balanced/))

(define-library (srfi 55)
  (export require-extension)
  (import (chibi))
  (begin
   (define-syntax require-extension
     (syntax-rules ()
       ((require-extension (prefix mod ...))
        (begin (import (prefix mod) ...)))))))

(define-library (srfi 116 test)
  (import (scheme base) (srfi 116) (chibi test))
  (export run-tests)
  (begin
    (define (run-tests)
      (test-group "srfi-116: ilists"

        (test-group "ilists/constructors"
          (define abc (ilist 'a 'b 'c))
          (define abc-dot-d (ipair* 'a 'b 'c 'd))
          (define abc-copy (ilist-copy abc))
          (test 'a (icar abc))
          (test 'b (icadr abc))
          (test 'c (icaddr abc))
          (test (ipair 2 1) (xipair 1 2))
          (test 'd (icdddr abc-dot-d))
          (test (iq c c c c) (make-ilist 4 'c))
          (test (iq 0 1 2 3) (ilist-tabulate 4 values))
          (test (iq 0 1 2 3 4) (iiota 5))
          (test abc abc-copy)
          (test-assert (not (eq? abc abc-copy))))

        (test-group "ilists/predicates"
          (test-assert (ipair? (ipair 1 2)))
          (test-assert (proper-ilist? '()))
          (test-assert (proper-ilist? (iq 1 2 3)))
          (test-assert (ilist? '()))
          (test-assert (ilist? (iq 1 2 3)))
          (test-assert (dotted-ilist? (ipair 1 2)))
          (test-assert (dotted-ilist? 2))
          (test-assert (null-ilist? '()))
          (test-assert (not (null-ilist? (iq 1 2 3))))
          ;;(test-error (null-ilist? 'a))
          (test-assert (not-ipair? 'a))
          (test-assert (not (not-ipair? (ipair 'a 'b))))
          (test-assert (ilist= = (iq 1 2 3) (iq 1 2 3)))
          (test-assert (ilist= = (iq 1 2 3) (iq 1 2 3) (iq 1 2 3)))
          (test-assert (not (ilist= = (iq 1 2 3 4) (iq 1 2 3))))
          (test-assert (not (ilist= = (iq 1 2 3) (iq 1 2 3 4))))
          (test-assert (ilist= = (iq 1 2 3) (iq 1 2 3)))
          (test-assert (not (ilist= = (iq 1 2 3) (iq 1 2 3 4) (iq 1 2 3 4))))
          (test-assert (not (ilist= = (iq 1 2 3) (iq 1 2 3) (iq 1 2 3 4)))))

        (test-group "ilist/cxrs"
          (define ab (ipair 'a 'b))
          (define cd (ipair 'c 'd))
          (define ef (ipair 'e 'f))
          (define gh (ipair 'g 'h))
          (define abcd (ipair ab cd))
          (define efgh (ipair ef gh))
          (define abcdefgh (ipair abcd efgh))
          (define ij (ipair 'i 'j))
          (define kl (ipair 'k 'l))
          (define mn (ipair 'm 'n))
          (define op (ipair 'o 'p))
          (define ijkl (ipair ij kl))
          (define mnop (ipair mn op))
          (define ijklmnop (ipair ijkl mnop))
          (define abcdefghijklmnop (ipair abcdefgh ijklmnop))
          (test 'a (icaar abcd))
          (test 'b (icdar abcd))
          (test 'c (icadr abcd))
          (test 'd (icddr abcd))
          (test 'a (icaaar abcdefgh))
          (test 'b (icdaar abcdefgh))
          (test 'c (icadar abcdefgh))
          (test 'd (icddar abcdefgh))
          (test 'e (icaadr abcdefgh))
          (test 'f (icdadr abcdefgh))
          (test 'g (icaddr abcdefgh))
          (test 'h (icdddr abcdefgh))
          (test 'a (icaaaar abcdefghijklmnop))
          (test 'b (icdaaar abcdefghijklmnop))
          (test 'c (icadaar abcdefghijklmnop))
          (test 'd (icddaar abcdefghijklmnop))
          (test 'e (icaadar abcdefghijklmnop))
          (test 'f (icdadar abcdefghijklmnop))
          (test 'g (icaddar abcdefghijklmnop))
          (test 'h (icdddar abcdefghijklmnop))
          (test 'i (icaaadr abcdefghijklmnop))
          (test 'j (icdaadr abcdefghijklmnop))
          (test 'k (icadadr abcdefghijklmnop))
          (test 'l (icddadr abcdefghijklmnop))
          (test 'm (icaaddr abcdefghijklmnop))
          (test 'n (icdaddr abcdefghijklmnop))
          (test 'o (icadddr abcdefghijklmnop))
          (test 'p (icddddr abcdefghijklmnop)))

        (test-group "ilists/selectors"
          (define ten (ilist 1 2 3 4 5 6 7 8 9 10))
          (define abcde (iq a b c d e))
          (define dotted (ipair 1 (ipair 2 (ipair 3 'd))))
          (test 'c (ilist-ref (iq a b c d) 2))
          (test 1 (ifirst ten))
          (test 2 (isecond ten))
          (test 3 (ithird ten))
          (test 4 (ifourth ten))
          (test 5 (ififth ten))
          (test 6 (isixth ten))
          (test 7 (iseventh ten))
          (test 8 (ieighth ten))
          (test 9 (ininth ten))
          (test 10 (itenth ten))
          (test-error (ilist-ref '() 2))
          (test '(1 2) (call-with-values (lambda () (icar+icdr (ipair 1 2))) list))
          (test (iq a b) (itake abcde 2))
          (test (iq c d e) (idrop abcde 2))
          (test (iq c d e) (ilist-tail abcde 2))
          (test (iq 1 2) (itake dotted 2))
          (test (ipair 3 'd) (idrop dotted 2))
          (test (ipair 3 'd) (ilist-tail dotted 2))
          (test 'd (idrop dotted 3))
          (test 'd (ilist-tail dotted 3))
          (test abcde (iappend (itake abcde 4) (idrop abcde 4)))
          (test (iq d e) (itake-right abcde 2))
          (test (iq a b c) (idrop-right abcde 2))
          (test (ipair 2 (ipair 3 'd)) (itake-right dotted 2))
          (test (iq 1) (idrop-right dotted 2))
          (test 'd (itake-right dotted 0))
          (test (iq 1 2 3) (idrop-right dotted 0))
          (test abcde (call-with-values (lambda () (isplit-at abcde 3)) iappend))
          (test 'c (ilast (iq a b c)))
          (test (iq c) (last-ipair (iq a b c))))

        (test-group "ilists/misc"
          (test 0 (ilength '()))
          (test 3 (ilength (iq 1 2 3)))
          (test (iq x y) (iappend (iq x) (iq y)))
          (test (iq a b c d) (iappend (iq a b) (iq c d)))
          (test (iq a) (iappend '() (iq a)))
          (test (iq x y) (iappend (iq x y)))
          (test '() (iappend))
          (test (iq a b c d) (iconcatenate (iq (a b) (c d))))
          (test (iq c b a) (ireverse (iq a b c)))
          (test (iq (e (f)) d (b c) a) (ireverse (iq a (b c) d (e (f)))))
          (test (ipair 2 (ipair 1 'd)) (iappend-reverse (iq 1 2) 'd))
          (test (iq (one 1 odd) (two 2 even) (three 3 odd))
              (izip (iq one two three) (iq 1 2 3) (iq odd even odd)))
          (test (iq (1) (2) (3)) (izip (iq 1 2 3)))
          (test (iq 1 2 3) (iunzip1 (iq (1) (2) (3))))
          (test (iq (1 2 3) (one two three))
              (call-with-values
                  (lambda () (iunzip2 (iq (1 one) (2 two) (3 three))))
                ilist))
          (test (iq (1 2 3) (one two three) (a b c))
              (call-with-values
                  (lambda () (iunzip3 (iq (1 one a) (2 two b) (3 three c))))
                ilist))
          (test (iq (1 2 3) (one two three) (a b c) (4 5 6))
              (call-with-values
                  (lambda () (iunzip4 (iq (1 one a 4) (2 two b 5) (3 three c 6))))
                ilist))
          (test (iq (1 2 3) (one two three) (a b c) (4 5 6) (#t #f #t))
              (call-with-values
                  (lambda () (iunzip5 (iq (1 one a 4 #t) (2 two b 5 #f) (3 three c 6 #t))))
                ilist))
          (test 3 (icount even? (iq 3 1 4 1 5 9 2 5 6)))
          (test 3 (icount < (iq 1 2 4 8) (iq 2 4 6 8 10 12 14 16))))

        (test-group "ilists/folds"
          ;; We have to be careful to test both single-list and multiple-list
          ;; code paths, as they are different in this implementation.
          (define squares (iq 1 4 9 16 25 36 49 64 81 100))
          (define lis (iq 1 2 3))
          (define (z x y ans) (ipair (ilist x y) ans))
          (define z2 (let ((count 0)) (lambda (ignored) (set! count (+ count 1)) count)))
          (test 6 (ifold + 0 lis))
          (test (iq 3 2 1) (ifold ipair '() lis))
          (test 2 (ifold
                   (lambda (x count) (if (symbol? x) (+ count 1) count))
                   0
                   (iq a 0 b)))
          (test 4 (ifold
                   (lambda (s max-len) (max max-len (string-length s)))
                   0
                   (iq "ab" "abcd" "abc")))
          (test 32 (ifold
                    (lambda (a b ans) (+ (* a b) ans))
                    0
                    (iq 1 2 3)
                    (iq 4 5 6)))
          (test (iq (b d) (a c))
              (ifold z '() (iq a b) (iq c d)))
          (test lis (ifold-right ipair '() lis))
          (test (iq 0 2 4) (ifold-right
                            (lambda (x l) (if (even? x) (ipair x l) l))
                            '()
                            (iq 0 1 2 3 4)))
          (test (iq (a c) (b d))
              (ifold-right z '() (iq a b) (iq c d)))
          (test (iq (c) (b c) (a b c))
              (ipair-fold ipair '() (iq a b c)))
          (test (iq ((b) (d)) ((a b) (c d)))
              (ipair-fold z '() (iq a b) (iq c d)))
          (test (iq (a b c) (b c) (c))
              (ipair-fold-right ipair '() (iq a b c)))
          (test (iq ((a b) (c d)) ((b) (d)))
              (ipair-fold-right z '() (iq a b) (iq c d)))
          (test 5 (ireduce max 0 (iq 1 3 5 4 2 0)))
          (test 1 (ireduce - 0 (iq 1 2)))
          (test -1 (ireduce-right - 0 (iq 1 2)))
          (test squares
              (iunfold (lambda (x) (> x 10))
                       (lambda (x) (* x x))
                       (lambda (x) (+ x 1))
                       1))
          (test squares
              (iunfold-right zero?
                             (lambda (x) (* x x))
                             (lambda (x) (- x 1))
                             10))
          (test (iq 1 2 3) (iunfold null-ilist? icar icdr (iq 1 2 3)))
          (test (iq 3 2 1) (iunfold-right null-ilist? icar icdr (iq 1 2 3)))
          (test (iq 1 2 3 4)
              (iunfold null-ilist? icar icdr (iq 1 2) (lambda (x) (iq 3 4))))
          (test (iq b e h) (imap icadr (iq (a b) (d e) (g h))))
          (test (iq b e h) (imap-in-order icadr (iq (a b) (d e) (g h))))
          (test (iq 5 7 9) (imap + (iq 1 2 3) (iq 4 5 6)))
          (test (iq 5 7 9) (imap-in-order + (iq 1 2 3) (iq 4 5 6)))
          (test (iq 1 2) (imap-in-order z2 (iq a b)))
          (test '#(0 1 4 9 16)
              (let ((v (make-vector 5)))
                (ifor-each (lambda (i)
                             (vector-set! v i (* i i)))
                           (iq 0 1 2 3 4))
                v))
          (test '#(5 7 9 11 13)
              (let ((v (make-vector 5)))
                (ifor-each (lambda (i j)
                             (vector-set! v i (+ i j)))
                           (iq 0 1 2 3 4)
                           (iq 5 6 7 8 9))
                v))
          (test (iq 1 -1 3 -3 8 -8)
              (iappend-map (lambda (x) (ilist x (- x))) (iq 1 3 8)))
          (test (iq 1 4 2 5 3 6)
              (iappend-map ilist (iq 1 2 3) (iq 4 5 6)))
          (test (vector (iq 0 1 2 3 4) (iq 1 2 3 4) (iq 2 3 4) (iq 3 4) (iq 4))
              (let ((v (make-vector 5)))
                (ipair-for-each (lambda (lis) (vector-set! v (icar lis) lis)) (iq 0 1 2 3 4))
                v))
          (test (vector (iq 5 6 7 8 9) (iq 6 7 8 9) (iq 7 8 9) (iq 8 9) (iq 9))
              (let ((v (make-vector 5)))
                (ipair-for-each (lambda (i j) (vector-set! v (icar i) j))
                                (iq 0 1 2 3 4)
                                (iq 5 6 7 8 9))
                v))
          (test (iq 1 9 49)
              (ifilter-map (lambda (x) (and (number? x) (* x x))) (iq a 1 b 3 c 7)))
          (test (iq 5 7 9)
              (ifilter-map
               (lambda (x y) (and (number? x) (number? y) (+ x y)))
               (iq 1 a 2 b 3 4)
               (iq 4 0 5 y 6 z2))))

        (test-group "ilists/filtering"
          (test (iq 0 8 8 -4) (ifilter even? (iq 0 7 8 8 43 -4)))
          (test (list (iq one four five) (iq 2 3 6))
              (call-with-values
                  (lambda () (ipartition symbol? (iq one 2 3 four five 6)))
                list))
          (test (iq 7 43) (iremove even? (iq 0 7 8 8 43 -4))))

        (test-group "ilists/searching"
          (test 2 (ifind even? (iq 1 2 3)))
          (test #t (iany  even? (iq 1 2 3)))
          (test #f (ifind even? (iq 1 7 3)))
          (test #f (iany  even? (iq 1 7 3)))
          ;;(test-error (ifind even? (ipair 1 (ipair 3 'x))))
          ;;(test-error (iany  even? (ipair 1 (ipair 3 'x))))
          (test 4 (ifind even? (iq 3 1 4 1 5 9)))
          (test (iq -8 -5 0 0) (ifind-tail even? (iq 3 1 37 -8 -5 0 0)))
          (test (iq 2 18) (itake-while even? (iq 2 18 3 10 22 9)))
          (test (iq 3 10 22 9) (idrop-while even? (iq 2 18 3 10 22 9)))
          (test (list (iq 2 18) (iq 3 10 22 9))
              (call-with-values
                  (lambda () (ispan even? (iq 2 18 3 10 22 9)))
                list))
          (test (list (iq 3 1) (iq 4 1 5 9))
              (call-with-values
                  (lambda () (ibreak even? (iq 3 1 4 1 5 9)))
                list))
          (test #t (iany integer? (iq a 3 b 2.7)))
          (test #f (iany integer? (iq a 3.1 b 2.7)))
          (test #t (iany < (iq 3 1 4 1 5) (iq 2 7 1 8 2)))
          (test #t (ievery integer? (iq 1 2 3 4 5)))
          (test #f (ievery integer? (iq 1 2 3 4.5 5)))
          (test #t (ievery (lambda (a b) (< a b)) (iq 1 2 3) (iq 4 5 6)))
          (test 2 (ilist-index even? (iq 3 1 4 1 5 9)))
          (test 1 (ilist-index < (iq 3 1 4 1 5 9 2 5 6) (iq 2 7 1 8 2)))
          (test #f (ilist-index = (iq 3 1 4 1 5 9 2 5 6) (iq 2 7 1 8 2)))
          (test (iq a b c) (imemq 'a (iq a b c)))
          (test (iq b c) (imemq 'b (iq a b c)))
          (test #f (imemq 'a (iq b c d)))
          (test #f (imemq (ilist 'a) (iq b (a) c)))
          (test (iq (a) c) (imember (ilist 'a) (iq b (a) c)))
          (test (iq 101 102) (imemv 101 (iq 100 101 102))))

        (test-group "ilists/deletion"
          (test (iq 1 2 4 5) (idelete 3 (iq 1 2 3 4 5)))
          (test (iq 3 4 5) (idelete 5 (iq 3 4 5 6 7) <))
          (test (iq a b c z) (idelete-duplicates (iq a b a c a b c z))))

        (test-group "ilists/alists"
          (define e (iq (a 1) (b 2) (c 3)))
          (define e2 (iq (2 3) (5 7) (11 13)))
          (test (iq a 1) (iassq 'a e))
          (test (iq b 2) (iassq 'b e))
          (test #f (iassq 'd e))
          (test #f (iassq (ilist 'a) (iq ((a)) ((b)) ((c)))))
          (test (iq (a)) (iassoc (ilist 'a) (iq ((a)) ((b)) ((c)))))
          (test (iq 5 7) (iassv 5 e2))
          (test (iq 11 13) (iassoc 5 e2 <))
          (test (ipair (iq 1 1) e2) (ialist-cons 1 (ilist 1) e2))
          (test (iq (2 3) (11 13)) (ialist-delete 5 e2))
          (test (iq (2 3) (5 7)) (ialist-delete 5 e2 <))
          )

        (test-group "ilists/replacers"
          (test (ipair 1 3) (replace-icar (ipair 2 3) 1))
          (test (ipair 1 3) (replace-icdr (ipair 1 2) 3)))

        (test-group "ilists/conversion"
          (test (ipair 1 2) (pair->ipair '(1 . 2)))
          (test '(1 . 2) (ipair->pair (ipair 1 2)))
          (test (iq 1 2 3) (list->ilist '(1 2 3)))
          (test '(1 2 3) (ilist->list (iq 1 2 3)))
          (test (ipair 1 (ipair 2 3)) (list->ilist '(1 2 . 3)))
          (test '(1 2 . 3) (ilist->list (ipair 1 (ipair 2 3))))
          (test (ipair (ipair 1 2) (ipair 3 4)) (tree->itree '((1 . 2) . (3 . 4))))
          (test '((1 . 2) . (3 . 4)) (itree->tree (ipair (ipair 1 2) (ipair 3 4))))
          (test (ipair (ipair 1 2) (ipair 3 4)) (gtree->itree (cons (ipair 1 2) (ipair 3 4))))
          (test '((1 . 2) . (3 . 4)) (gtree->tree (cons (ipair 1 2) (ipair 3 4))))
          (test 6 (iapply + (iq 1 2 3)))
          (test 15 (iapply + 1 2 (iq 3 4 5))))

        ))))

(define-library (srfi 26)
  (export cut cute)
  (import (chibi))
  (begin
   (define-syntax %cut
     (syntax-rules (<> <...>)
       ((%cut e? params args)
        (lambda params args))
       ((%cut e? (params ...) (args ...) <> . rest)
        (%cut e? (params ... tmp) (args ... tmp) . rest))
       ((%cut e? (params ...) (args ...) <...>)
        (%cut e? (params ... . tmp) (apply args ... tmp)))
       ((%cut e? (params ...) (args ...) <...> . rest)
        (error "cut: non-terminal <...>"))
       ((%cut #t (params ...) (args ...) x . rest)
        (let ((tmp x)) (%cut #t (params ...) (args ... tmp) . rest)))
       ((%cut #f (params ...) (args ...) x . rest)
        (%cut #f (params ...) (args ... x) . rest))))
   (define-syntax cut
     (syntax-rules () ((cut args ...) (%cut #f () () args ...))))
   (define-syntax cute
     (syntax-rules () ((cute args ...) (%cut #t () () args ...))))))

(define fx=? =)
(define fx<? <)
(define fx>? >)
(define fx<=? <=)
(define fx>=? >=)
(define fxzero? zero?)
(define fxpositive? positive?)
(define fxnegative? negative?)
(define fxodd? odd?)
(define fxeven? even?)
(define fxmax max)
(define fxmin min)
(define fx+ +)
(define fx- -)
(define fx* *)
(define fxquotient quotient)
(define fxremainder remainder)
(define fxabs abs)
(define fxsquare square)
(define fxsqrt exact-integer-sqrt)

(define fx-width
  (if (fixnum? (expt 2 32)) 62 30))

(define fx-greatest
  (- (expt 2 fx-width) 1))

(define fx-least
  (- -1 fx-greatest))

(define (fxneg x) (- x))

(define (fx+/carry i j k)
  (let ((s (+ i j k)))
    (call-with-values (lambda () (balanced/ s (expt 2 fx-width)))
      (lambda (q r) (values r q)))))

(define (fx-/carry i j k)
  (let ((d (- i j k)))
    (call-with-values (lambda () (balanced/ d (expt 2 fx-width)))
      (lambda (q r) (values r q)))))

(define (fx*/carry i j k)
  (let ((s (+ (* i j) k)))
    (call-with-values (lambda () (balanced/ s (expt 2 fx-width)))
      (lambda (q r) (values r q)))))

(define fxarithmetic-shift-left fxarithmetic-shift)

(define (fxarithmetic-shift-right i count)
  (fxarithmetic-shift i (- count)))

(define (fxbit-set? index i)
  (or (bit-set? index i)
      (and (negative? i)
           (>= index (fxlength i)))))
(define-library (srfi 143 test)
  (import (scheme base) (srfi 143) (chibi test))
  (export run-tests)
  (begin
    (define (run-tests)
      (test-group "fixnum"
        (test-group "arithmetic"
          (test #t (fixnum? 32767))
          (test #f (fixnum? 1.1))

          (test #t (fx=? 1 1 1))
          (test #f (fx=? 1 2 2))
          (test #f (fx=? 1 1 2))
          (test #f (fx=? 1 2 3))

          (test #t (fx<? 1 2 3))
          (test #f (fx<? 1 1 2))
          (test #t (fx>? 3 2 1))
          (test #f (fx>? 2 1 1))
          (test #t (fx<=? 1 1 2))
          (test #f (fx<=? 1 2 1))
          (test #t (fx>=? 2 1 1))
          (test #f (fx>=? 1 2 1))
          (test '(#t #f) (list (fx<=? 1 1 2) (fx<=? 2 1 3)))

          (test #t (fxzero? 0))
          (test #f (fxzero? 1))

          (test #f (fxpositive? 0))
          (test #t (fxpositive? 1))
          (test #f (fxpositive? -1))

          (test #f (fxnegative? 0))
          (test #f (fxnegative? 1))
          (test #t (fxnegative? -1))

          (test #f (fxodd? 0))
          (test #t (fxodd? 1))
          (test #t (fxodd? -1))
          (test #f (fxodd? 102))

          (test #t (fxeven? 0))
          (test #f (fxeven? 1))
          (test #t (fxeven? -2))
          (test #t (fxeven? 102))

          (test 4 (fxmax 3 4))
          (test 5 (fxmax 3 5 4))
          (test 3 (fxmin 3 4))
          (test 3 (fxmin 3 5 4))

          (test 7 (fx+ 3 4))
          (test 12 (fx* 4 3))

          (test -1 (fx- 3 4))
          (test -3 (fxneg 3))

          (test 7 (fxabs -7))
          (test 7 (fxabs 7))

          (test 1764 (fxsquare 42))
          (test 4 (fxsquare 2))

          (test 2 (fxquotient 5 2))
          (test -2 (fxquotient -5 2))
          (test -2 (fxquotient 5 -2))
          (test 2 (fxquotient -5 -2))

          (test 1 (fxremainder 13 4))
          (test -1 (fxremainder -13 4))
          (test 1 (fxremainder 13 -4))
          (test -1 (fxremainder -13 -4))

          (call-with-values (lambda () (fxsqrt 32))
            (lambda (root rem)
              (test 35 (* root rem)))))

        (test-group "bitwise"
          (test -1 (fxnot 0))
          (test 0 (fxand #b0 #b1))
          (test 6 (fxand 14 6))
          (test 14 (fxior 10 12))
          (test 6 (fxxor 10 12))
          (test 0 (fxnot -1))
          (test 9 (fxif 3 1 8))
          (test 0 (fxif 3 8 1))
          (test 2 (fxbit-count 12))
          (test 0 (fxlength 0))
          (test 8 (fxlength 128))
          (test 8 (fxlength 255))
          (test 9 (fxlength 256))
          (test -1 (fxfirst-set-bit 0))
          (test 0 (fxfirst-set-bit 1))
          (test 0 (fxfirst-set-bit 3))
          (test 2 (fxfirst-set-bit 4))
          (test 1 (fxfirst-set-bit 6))
          (test 0 (fxfirst-set-bit -1))
          (test 1 (fxfirst-set-bit -2))
          (test 0 (fxfirst-set-bit -3))
          (test 2 (fxfirst-set-bit -4))
          (test #t (fxbit-set? 0 1))
          (test #f (fxbit-set? 1 1))
          (test #f (fxbit-set? 1 8))
          (test #t (fxbit-set? 10000 -1))
          (test #t (fxbit-set? 1000 -1))
          (test 0 (fxcopy-bit 0 0 #f))
          (test -1 (fxcopy-bit 0 -1 #t))
          (test 1 (fxcopy-bit 0 0 #t))
          (test #x106 (fxcopy-bit 8 6 #t))
          (test 6 (fxcopy-bit 8 6 #f))
          (test -2 (fxcopy-bit 0 -1 #f))
          (test 0 (fxbit-field 6 0 1))
          (test 3 (fxbit-field 6 1 3))
          (test 2 (fxarithmetic-shift 1 1))
          (test 0 (fxarithmetic-shift 1 -1))
          (test #b110  (fxbit-field-rotate #b110 1 1 2))
          (test #b1010 (fxbit-field-rotate #b110 1 2 4))
          (test #b1011 (fxbit-field-rotate #b0111 -1 1 4))
          (test #b110 (fxbit-field-rotate #b110 0 0 10))
          (test 6 (fxbit-field-reverse 6 1 3))
          (test 12 (fxbit-field-reverse 6 1 4))
          (test -11 (fxnot 10))
          (test 36 (fxnot -37))
          (test 11 (fxior 3  10))
          (test 10 (fxand 11 26))
          (test 9 (fxxor 3 10))
          (test 4 (fxand 37 12))
          (test 32 (fxarithmetic-shift 8 2))
          (test 4 (fxarithmetic-shift 4 0))
          (test 4 (fxarithmetic-shift 8 -1))
          (test 0 (fxlength  0))
          (test 1 (fxlength  1))
          (test 0 (fxlength -1))
          (test 3 (fxlength  7))
          (test 3 (fxlength -7))
          (test 4 (fxlength  8))
          (test 3 (fxlength -8))
          (test #t (fxbit-set? 3 10))
          (test #t (fxbit-set? 2 6))
          (test #f (fxbit-set? 0 6))
          (test #b100 (fxcopy-bit 2 0 #t))
          (test #b1011 (fxcopy-bit 2 #b1111 #f))
          (test 1 (fxfirst-set-bit 2))
          (test 3 (fxfirst-set-bit 40))
          (test 2 (fxfirst-set-bit -28))
          (test 1 (fxand #b1 #b1))
          (test 0 (fxand #b1 #b10))
          (test #b10 (fxand #b11 #b10))
          (test #b101 (fxand #b101 #b111))
          (test #b111 (fxand -1 #b111))
          (test #b110 (fxand -2 #b111))
          (test 1 (fxarithmetic-shift 1 0))
          (test 4 (fxarithmetic-shift 1 2))
          (test 8 (fxarithmetic-shift 1 3))
          (test 16 (fxarithmetic-shift 1 4))
          (test -1 (fxarithmetic-shift -1 0))
          (test -2 (fxarithmetic-shift -1 1))
          (test -4 (fxarithmetic-shift -1 2))
          (test -8 (fxarithmetic-shift -1 3))
          (test -16 (fxarithmetic-shift -1 4))
          (test #b1010 (fxbit-field #b1101101010 0 4))
          (test #b101101 (fxbit-field #b1101101010 3 9))
          (test #b10110 (fxbit-field #b1101101010 4 9))
          (test #b110110 (fxbit-field #b1101101010 4 10))
          (test 3 (fxif 1 1 2))
          (test #b00110011 (fxif #b00111100 #b11110000 #b00001111))
          (test #b1 (fxcopy-bit 0 0 #t)))))))

(define-library (srfi 27)
  (export random-integer random-real default-random-source
          make-random-source random-source?
          random-source-state-ref random-source-state-set!
          random-source-randomize! random-source-pseudo-randomize!
          random-source-make-integers random-source-make-reals)
  (import (chibi))
  (include-shared "27/rand")
  (include "27/constructors.scm"))

(define-library (srfi 101)
  (import (scheme base)
          (scheme case-lambda)
          (srfi 1)
          (srfi 125)
          (rename (srfi 151)
                  (arithmetic-shift bitwise-arithmetic-shift)))
  (export (rename ra:quote quote)
          (rename ra:pair? pair?)
          (rename ra:cons cons)
          (rename ra:car car)
          (rename ra:cdr cdr)
          (rename ra:caar caar)
          (rename ra:cadr cadr)
          (rename ra:cddr cddr)
          (rename ra:cdar cdar)
          (rename ra:caaar caaar)
          (rename ra:caadr caadr)
          (rename ra:caddr caddr)
          (rename ra:cadar cadar)
          (rename ra:cdaar cdaar)
          (rename ra:cdadr cdadr)
          (rename ra:cdddr cdddr)
          (rename ra:cddar cddar)
          (rename ra:caaaar caaaar)
          (rename ra:caaadr caaadr)
          (rename ra:caaddr caaddr)
          (rename ra:caadar caadar)
          (rename ra:cadaar cadaar)
          (rename ra:cadadr cadadr)
          (rename ra:cadddr cadddr)
          (rename ra:caddar caddar)
          (rename ra:cdaaar cdaaar)
          (rename ra:cdaadr cdaadr)
          (rename ra:cdaddr cdaddr)
          (rename ra:cdadar cdadar)
          (rename ra:cddaar cddaar)
          (rename ra:cddadr cddadr)
          (rename ra:cddddr cddddr)
          (rename ra:cdddar cdddar)
          (rename ra:null? null?)
          (rename ra:list? list?)
          (rename ra:list list)
          (rename ra:make-list make-list)
          (rename ra:length length)
          (rename ra:length<=? length<=?)
          (rename ra:append append)
          (rename ra:reverse reverse)
          (rename ra:list-tail list-tail)
          (rename ra:list-ref list-ref)
          (rename ra:list-set list-set)
          (rename ra:list-ref/update list-ref/update)
          (rename ra:map map)
          (rename ra:for-each for-each)
          (rename ra:random-access-list->linear-access-list
                  random-access-list->linear-access-list)
          (rename ra:linear-access-list->random-access-list
                  linear-access-list->random-access-list))
  (include "101.scm"))
;; Chibi Scheme version of any

(define (any pred ls)
  (if (null? (cdr ls))
    (pred (car ls))
    ((lambda (x) (if x x (any pred (cdr ls)))) (pred (car ls)))))

;; list->bytevector
(define (list->bytevector list)
  (let ((vec (make-bytevector (length list) 0)))
    (let loop ((i 0) (list list))
      (if (null? list)
        vec
        (begin
          (bytevector-u8-set! vec i (car list))
          (loop (+ i 1) (cdr list)))))))


;; generator
(define (generator . args)
  (lambda () (if (null? args)
               (eof-object)
               (let ((next (car args)))
                (set! args (cdr args))
                next))))

;; circular-generator
(define (circular-generator . args)
  (let ((base-args args))
    (lambda ()
      (when (null? args)
        (set! args base-args))
          (let ((next (car args)))
                (set! args (cdr args))
                next))))


;; make-iota-generator
(define make-iota-generator
  (case-lambda ((count) (make-iota-generator count 0 1))
               ((count start) (make-iota-generator count start 1))
               ((count start step) (make-iota count start step))))

;; make-iota
(define (make-iota count start step)
  (lambda ()
    (cond
      ((<= count 0)
       (eof-object))
      (else
        (let ((result start))
         (set! count (- count 1))
         (set! start (+ start step))
         result)))))


;; make-range-generator
(define make-range-generator
  (case-lambda ((start end) (make-range-generator start end 1))
               ((start) (make-infinite-range-generator start))
               ((start end step)
                (set! start (- (+ start step) step))
                (lambda () (if (< start end)
                             (let ((v start))
                              (set! start (+ start step))
                              v)
                             (eof-object))))))

(define (make-infinite-range-generator start)
  (lambda ()
    (let ((result start))
     (set! start (+ start 1))
     result)))



;; make-coroutine-generator
(define (make-coroutine-generator proc)
  (define return #f)
  (define resume #f)
  (define yield (lambda (v) (call/cc (lambda (r) (set! resume r) (return v)))))
  (lambda () (call/cc (lambda (cc) (set! return cc)
                        (if resume
                          (resume (if #f #f))  ; void? or yield again?
                          (begin (proc yield)
                                 (set! resume (lambda (v) (return (eof-object))))
                                 (return (eof-object))))))))


;; list->generator
(define (list->generator lst)
  (lambda () (if (null? lst)
               (eof-object)
               (let ((next (car lst)))
                (set! lst (cdr lst))
                next))))


;; vector->generator
(define vector->generator
  (case-lambda ((vec) (vector->generator vec 0 (vector-length vec)))
               ((vec start) (vector->generator vec start (vector-length vec)))
               ((vec start end)
                (lambda () (if (>= start end)
                             (eof-object)
                             (let ((next (vector-ref vec start)))
                              (set! start (+ start 1))
                              next))))))


;; reverse-vector->generator
(define reverse-vector->generator
  (case-lambda ((vec) (reverse-vector->generator vec 0 (vector-length vec)))
               ((vec start) (reverse-vector->generator vec start (vector-length vec)))
               ((vec start end)
                (lambda () (if (>= start end)
                             (eof-object)
                             (let ((next (vector-ref vec (- end 1))))
                              (set! end (- end 1))
                              next))))))


;; string->generator
(define string->generator
  (case-lambda ((str) (string->generator str 0 (string-length str)))
               ((str start) (string->generator str start (string-length str)))
               ((str start end)
                (lambda () (if (>= start end)
                             (eof-object)
                             (let ((next (string-ref str start)))
                              (set! start (+ start 1))
                              next))))))


;; bytevector->generator
(define bytevector->generator
  (case-lambda ((str) (bytevector->generator str 0 (bytevector-length str)))
               ((str start) (bytevector->generator str start (bytevector-length str)))
               ((str start end)
                (lambda () (if (>= start end)
                             (eof-object)
                             (let ((next (bytevector-u8-ref str start)))
                              (set! start (+ start 1))
                              next))))))


;; make-for-each-generator
;FIXME: seems to fail test
(define (make-for-each-generator for-each obj)
  (make-coroutine-generator (lambda (yield) (for-each yield obj))))


;; make-unfold-generator
(define (make-unfold-generator stop? mapper successor seed)
  (make-coroutine-generator (lambda (yield)
                              (let loop ((s seed))
                               (if (stop? s)
                                 (if #f #f)
                                 (begin (yield (mapper s))
                                        (loop (successor s))))))))


;; gcons*
(define (gcons* . args)
  (lambda () (if (null? args)
               (eof-object)
               (if (= (length args) 1)
                 ((car args))
                 (let ((v (car args)))
                  (set! args (cdr args))
                  v)))))


;; gappend
(define (gappend . args)
  (lambda () (if (null? args)
               (eof-object)
               (let loop ((v ((car args))))
                (if (eof-object? v)
                  (begin (set! args (cdr args))
                         (if (null? args)
                           (eof-object)
                           (loop ((car args)))))
                  v)))))

;; gflatten
(define (gflatten gen)
  (let ((state '()))
    (lambda ()
      (if (null? state) (set! state (gen)))
      (if (eof-object? state)
        state
        (let ((obj (car state)))
          (set! state (cdr state))
          obj)))))

;; ggroup
(define ggroup
  (case-lambda
    ((gen k)
     (simple-ggroup gen k))
    ((gen k padding)
     (padded-ggroup (simple-ggroup gen k) k padding))))

(define (simple-ggroup gen k)
  (lambda ()
    (let loop ((item (gen)) (result '()) (count (- k 1)))
      (if (eof-object? item)
        (if (null? result) item (reverse result))
        (if (= count 0)
          (reverse (cons item result))
          (loop (gen) (cons item result) (- count 1)))))))

(define (padded-ggroup gen k padding)
  (lambda ()
    (let ((item (gen)))
      (if (eof-object? item)
        item
        (let ((len (length item)))
          (if (= len k)
              item
              (append item (make-list (- k len) padding))))))))

;; gmerge
(define gmerge
  (case-lambda
    ((<) (error "wrong number of arguments for gmerge"))
    ((< gen) gen)
    ((< genleft genright)
     (let ((left (genleft))
           (right (genright)))
       (lambda ()
         (cond
          ((and (eof-object? left) (eof-object? right))
           left)
          ((eof-object? left)
           (let ((obj right)) (set! right (genright)) obj))
          ((eof-object? right)
           (let ((obj left))  (set! left (genleft)) obj))
          ((< right left)
           (let ((obj right)) (set! right (genright)) obj))
          (else
           (let ((obj left)) (set! left (genleft)) obj))))))
    ((< . gens)
     (apply gmerge <
            (let loop ((gens gens) (gs '()))
              (cond ((null? gens) (reverse gs))
                    ((null? (cdr gens)) (reverse (cons (car gens) gs)))
                    (else (loop (cddr gens)
                                (cons (gmerge < (car gens) (cadr gens)) gs)))))))))

;; gmap
(define gmap
  (case-lambda
    ((proc) (error "wrong number of arguments for gmap"))
    ((proc gen)
     (lambda ()
       (let ((item (gen)))
         (if (eof-object? item) item (proc item)))))
    ((proc . gens)
     (lambda ()
       (let ((items (map (lambda (x) (x)) gens)))
         (if (any eof-object? items) (eof-object) (apply proc items)))))))

;; gcombine
(define (gcombine proc seed . gens)
  (lambda ()
    (define items (map (lambda (x) (x)) gens))
    (if (any eof-object? items)
      (eof-object)
      (let ()
       (define-values (value newseed) (apply proc (append items (list seed))))
       (set! seed newseed)
       value))))

;; gfilter
(define (gfilter pred gen)
  (lambda () (let loop ()
              (let ((next (gen)))
               (if (or (eof-object? next)
                       (pred next))
                 next
                 (loop))))))

;; gstate-filter
(define (gstate-filter proc seed gen)
  (let ((state seed))
    (lambda ()
      (let loop ((item (gen)))
        (if (eof-object? item)
          item
          (let-values (((yes newstate) (proc item state)))
            (set! state newstate)
            (if yes
               item
               (loop (gen)))))))))



;; gremove
(define (gremove pred gen)
  (gfilter (lambda (v) (not (pred v))) gen))



;; gtake
(define gtake
  (case-lambda ((gen k) (gtake gen k (eof-object)))
               ((gen k padding)
                (make-coroutine-generator (lambda (yield)
                                            (if (> k 0)
                                              (let loop ((i 0) (v (gen)))
                                               (begin (if (eof-object? v) (yield padding) (yield v))
                                                      (if (< (+ 1 i) k)
                                                        (loop (+ 1 i) (gen))
                                                        (eof-object))))
                                              (eof-object)))))))



;; gdrop
(define (gdrop gen k)
  (lambda () (do () ((<= k 0)) (set! k (- k 1)) (gen))
    (gen)))



;; gdrop-while
(define (gdrop-while pred gen)
  (define found #f)
  (lambda ()
    (let loop ()
     (let ((val (gen)))
      (cond (found val)
            ((and (not (eof-object? val)) (pred val)) (loop))
            (else (set! found #t) val))))))


;; gtake-while
(define (gtake-while pred gen)
  (lambda () (let ((next (gen)))
              (if (eof-object? next)
                next
                (if (pred next)
                  next
                  (begin (set! gen (generator))
                         (gen)))))))



;; gdelete
(define gdelete
  (case-lambda ((item gen) (gdelete item gen equal?))
               ((item gen ==)
                (lambda () (let loop ((v (gen)))
                            (cond
                              ((eof-object? v) (eof-object))
                              ((== item v) (loop (gen)))
                              (else v)))))))



;; gdelete-neighbor-dups
(define gdelete-neighbor-dups
  (case-lambda ((gen)
                (gdelete-neighbor-dups gen equal?))
               ((gen ==)
                (define firsttime #t)
                (define prev #f)
                (lambda () (if firsttime
                             (begin (set! firsttime #f)
                                    (set! prev (gen))
                                    prev)
                             (let loop ((v (gen)))
                              (cond
                                ((eof-object? v)
                                 v)
                                ((== prev v)
                                 (loop (gen)))
                                (else
                                  (set! prev v)
                                  v))))))))


;; gindex
(define (gindex value-gen index-gen)
  (let ((done? #f) (count 0))
   (lambda ()
     (if done?
       (eof-object)
       (let loop ((value (value-gen)) (index (index-gen)))
        (cond
          ((or (eof-object? value) (eof-object? index))
           (set! done? #t)
           (eof-object))
          ((= index count)
           (set! count (+ count 1))
           value)
          (else
            (set! count (+ count 1))
            (loop (value-gen) index))))))))


;; gselect
(define (gselect value-gen truth-gen)
  (let ((done? #f))
   (lambda ()
     (if done?
       (eof-object)
       (let loop ((value (value-gen)) (truth (truth-gen)))
        (cond
          ((or (eof-object? value) (eof-object? truth))
           (set! done? #t)
           (eof-object))
          (truth value)
          (else (loop (value-gen) (truth-gen)))))))))

;; generator->list
(define generator->list
  (case-lambda ((gen n)
                (generator->list (gtake gen n)))
               ((gen)
                (reverse (generator->reverse-list gen)))))

;; generator->reverse-list
(define generator->reverse-list
  (case-lambda ((gen n)
                (generator->reverse-list (gtake gen n)))
               ((gen)
                (generator-fold cons '() gen))))

;; generator->vector
(define generator->vector
  (case-lambda ((gen) (list->vector (generator->list gen)))
               ((gen n) (list->vector (generator->list gen n)))))


;; generator->vector!
(define (generator->vector! vector at gen)
  (let loop ((value (gen)) (count 0) (at at))
   (cond
     ((eof-object? value) count)
     ((>= at (vector-length vector)) count)
     (else (begin
             (vector-set! vector at value)
             (loop (gen) (+ count 1) (+ at 1)))))))


;; generator->string
(define generator->string
  (case-lambda ((gen) (list->string (generator->list gen)))
               ((gen n) (list->string (generator->list gen n)))))




;; generator-fold
(define (generator-fold f seed . gs)
  (define (inner-fold seed)
    (let ((vs (map (lambda (g) (g)) gs)))
     (if (any eof-object? vs)
       seed
       (inner-fold (apply f (append vs (list seed)))))))
  (inner-fold seed))



;; generator-for-each
(define (generator-for-each f . gs)
  (let loop ()
   (let ((vs (map (lambda (g) (g)) gs)))
    (if (any eof-object? vs)
      (if #f #f)
      (begin (apply f vs)
             (loop))))))


(define (generator-map->list f . gs)
  (let loop ((result '()))
   (let ((vs (map (lambda (g) (g)) gs)))
    (if (any eof-object? vs)
      (reverse result)
      (loop (cons (apply f vs) result))))))


;; generator-find
(define (generator-find pred g)
  (let loop ((v (g)))
    (and (not (eof-object? v))
         (if (pred v) v (loop (g))))))


;; generator-count
(define (generator-count pred g)
  (generator-fold (lambda (v n) (if (pred v) (+ 1 n) n)) 0 g))


;; generator-any
(define (generator-any pred g)
  (let loop ((v (g)))
   (if (eof-object? v)
     #f
     (if (pred v)
       #t
       (loop (g))))))


;; generator-every
(define (generator-every pred g)
  (let loop ((v (g)))
   (if (eof-object? v)
     #t
     (if (pred v)
       (loop (g))
       #f ; the spec would have me return #f, but I think it must simply be wrong...
       ))))


;; generator-unfold
(define (generator-unfold g unfold . args)
  (apply unfold eof-object? (lambda (x) x) (lambda (x) (g)) (g) args))


;; make-accumulator
(define (make-accumulator kons knil finalize)
  (let ((state knil))
    (lambda (obj)
      (if (eof-object? obj)
        (finalize state)
        (set! state (kons obj state))))))


;; count-accumulator
(define (count-accumulator) (make-accumulator
                            (lambda (obj state) (+ 1 state)) 0 (lambda (x) x)))

;; list-accumulator
(define (list-accumulator) (make-accumulator cons '() reverse))

;; reverse-list-accumulator
(define (reverse-list-accumulator) (make-accumulator cons '() (lambda (x) x)))

;; vector-accumulator
(define (vector-accumulator)
  (make-accumulator cons '() (lambda (x) (list->vector (reverse x)))))

;; reverse-vector-accumulator
(define (reverse-vector-accumulator)
  (make-accumulator cons '() list->vector))

;; vector-accumulator!
(define (vector-accumulator! vec at)
  (lambda (obj)
    (if (eof-object? obj)
      vec
      (begin
        (vector-set! vec at obj)
        (set! at (+ at 1))))))

;; bytevector-accumulator
(define (bytevector-accumulator)
  (make-accumulator cons '() (lambda (x) (list->bytevector (reverse x)))))

(define (bytevector-accumulator! bytevec at)
  (lambda (obj)
    (if (eof-object? obj)
      bytevec
      (begin
        (bytevector-u8-set! bytevec at obj)
        (set! at (+ at 1))))))

;; string-accumulator
(define (string-accumulator)
  (make-accumulator cons '()
        (lambda (lst) (list->string (reverse lst)))))

;; sum-accumulator
(define (sum-accumulator) (make-accumulator + 0 (lambda (x) x)))

;; product-accumulator
(define (product-accumulator) (make-accumulator * 1 (lambda (x) x)))

(define eof (read-char (open-input-string "")))

(define (list->generator ls)
  (lambda ()
    (if (null? ls)
        eof
        (let ((res (car ls)))
          (set! ls (cdr ls))
          res))))

(define (generator . elts)
  (list->generator elts))

(define (make-iota-generator count . o)
  (let ((val (if (pair? o) (car o) 0))
        (step (if (and (pair? o) (pair? (cdr o))) (cadr o) 1))
        (i 0))
    (lambda ()
      (if (>= i count)
          eof
          (let ((res val))
            (set! val (+ val step))
            (set! i (+ i 1))
            res)))))

(define (make-range-generator start . o)
  (let ((end (if (pair? o) (car o) +inf.0))
        (step (if (and (pair? o) (pair? (cdr o))) (cadr o) 1))
        (val start))
    (lambda ()
      (if (>= val end)
          eof
          (let ((res val))
            (set! val (+ val step))
            res)))))

(define (make-coroutine-generator proc)
  (let ((return #f)
        (resume #f))
    (lambda ()
      (call-with-current-continuation
       (lambda (outer)
         (set! return outer)
         (cond
          (resume
           (resume #f))
          (else
           ;; first time
           (proc (lambda (result)
                   (call-with-current-continuation
                    (lambda (inner)
                      (set! resume inner)
                      (return result)))))
           ;; done
           (set! resume (lambda (v) (return eof)))
           (return eof))))))))

(define (vector->generator vec . o)
  (let ((i (if (pair? o) (car o) 0))
        (end (if (and (pair? o) (pair? (cdr o))) (cadr o) (vector-length vec))))
    (lambda ()
      (if (>= i end)
          eof
          (let ((res (vector-ref vec i)))
            (set! i (+ i 1))
            res)))))

(define (reverse-vector->generator vec . o)
  (let* ((start (if (pair? o) (car o) 0))
         (end (if (and (pair? o) (pair? (cdr o))) (cadr o) (vector-length vec)))
         (i (- end 1)))
    (lambda ()
      (if (< i start)
          eof
          (let ((res (vector-ref vec i)))
            (set! i (- i 1))
            res)))))

(define (string->generator str . o)
  (let ((start (if (pair? o) (car o) 0))
        (end (if (and (pair? o) (pair? (cdr o))) (cadr o) (string-length str))))
    (let ((sc (string-index->cursor str start))
          (end-sc (string-index->cursor str end)))
      (lambda ()
        (if (string-cursor>=? sc end-sc)
            eof
            (let ((res (string-ref/cursor str sc)))
              (set! sc (string-cursor-next str sc))
              res))))))

(define (bytevector->generator bv . o)
  (let ((i (if (pair? o) (car o) 0))
        (end (if (and (pair? o) (pair? (cdr o)))
                 (cadr o)
                 (bytevector-length bv))))
    (lambda ()
      (if (>= i end)
          eof
          (let ((res (bytevector-u8-ref bv i)))
            (set! i (+ i 1))
            res)))))

(define (make-for-each-generator for-each obj)
  (make-coroutine-generator
   (lambda (yield) (for-each yield obj))))

(define (make-unfold-generator stop? mapper successor seed)
  (lambda ()
    (if (stop? seed)
        eof
        (let ((res (mapper seed)))
          (set! seed (successor seed))
          res))))

(define (gcons* . elts)
  (if (null? elts) (error "gcons* requires at least one arg"))
  (lambda ()
    (if (null? (cdr elts))
        ((car elts))
        (let ((res (car elts)))
          (set! elts (cdr elts))
          res))))

(define (gappend . gens)
  (define (g)
    (if (null? gens)
        eof
        (let ((res ((car gens))))
          (cond
           ((eof-object? res)
            (set! gens (cdr gens))
            (g))
           (else
            res)))))
  g)

(define (gcombine proc seed gen . o)
  (if (null? o)
      (lambda ()
        (call-with-values
            (lambda ()
              (let ((elt (gen)))
                (if (eof-object? elt) (values eof seed) (proc elt seed))))
          (lambda (res new-seed)
            (set! seed new-seed)
            res)))
      (lambda ()
        (call-with-values
            (lambda ()
              (let ((elts (cons (gen) (map (lambda (g) (g)) o))))
                (if (memq eof elts)
                    (values eof seed)
                    (apply proc (append elts (list seed))))))
          (lambda (res new-seed)
            (set! seed new-seed)
            res)))))

(define (gfilter pred gen)
  (define (g)
    (let ((res (gen)))
      (cond
       ((eof-object? res) res)
       ((pred res) res)
       (else (g)))))
  g)

(define (gremove pred gen)
  (gfilter (lambda (x) (not (pred x))) gen))

(define (gtake gen k . o)
  (let ((pad? (pair? o))
        (pad (and (pair? o) (car o)))
        (i 0))
    (lambda ()
      (if (>= i k)
          eof
          (let ((res (gen)))
            (set! i (+ i 1))
            (if (and pad? (eof-object? res))
                pad
                res))))))

(define (gdrop gen k)
  (define (g)
    (cond
     ((<= k 0) (gen))
     (else (gen) (set! k (- k 1)) (g))))
  g)

(define (gtake-while pred gen)
  (let ((done? #f))
    (lambda ()
      (if done?
          eof
          (let ((res (gen)))
            (cond
             ((and (not (eof-object? res)) (pred res)) res)
             (else (set! done? #t) eof)))))))

(define (gdrop-while pred gen)
  (define (g)
    (let ((res (gen)))
      (cond
       ((eof-object? res) res)
       ((pred res) (g))
       (else (set! pred (lambda (x) #f)) res))))
  g)

(define (gdelete item gen . o)
  (let ((eq (if (pair? o) (car o) equal?)))
    (define (g)
      (let ((res (gen)))
        (cond
         ((eof-object? res) res)
         ((eq res item) (g))
         (else res))))
    g))

(define (gdelete-neighbor-dups gen . o)
  (let ((eq (if (pair? o) (car o) equal?))
        (prev eof))
    (define (g)
      (let ((res (gen)))
        (cond
         ((eof-object? res)
          res)
         ((and (not (eof-object? prev)) (eq res prev))
          (g))
         (else
          (set! prev res)
          res))))
    g))

(define (gindex value-gen index-gen)
  (let ((index 0)
        (next-index -1))
    (define (g)
      (cond
       ((> index next-index)
        (let ((n (index-gen)))
          (cond
           ((eof-object? n) n)
           (else
            (if (<= n next-index)
                (error "indexes must be monotonically increasing"))
            (set! next-index n)
            (g)))))
       (else
        (let ((value (value-gen))
              (keep? (= index next-index)))
          (set! index (+ index 1))
          (cond
           ((eof-object? value) value)
           (keep? value)
           (else (g)))))))
    g))

(define (gselect value-gen truth-gen)
  (define (g)
    (let ((value (value-gen))
          (keep? (truth-gen)))
      (cond
       ((eof-object? value) value)
       ((eof-object? keep?) keep?)
       (keep? value)
       (else (g)))))
  g)

(define (generator->reverse-list gen . o)
  (let ((gen (if (pair? o) (gtake gen (car o)) gen)))
    (let lp ((res '()))
      (let ((elt (gen)))
        (if (eof-object? elt)
            res
            (lp (cons elt res)))))))

(define (generator->list gen . o)
  (reverse (apply generator->reverse-list gen o)))

(define (generator->vector gen . o)
  (list->vector (generator->list (if (pair? o) (gtake gen (car o)) gen))))

(define (generator->vector! vec at gen)
  (let ((len (vector-length vec)))
    (let lp ((i at))
      (let ((elt (if (>= i len) eof (gen))))
        (cond
         ((eof-object? elt)
          (- len at))
         (else
          (vector-set! vec i elt)
          (lp (+ i 1))))))))

(define (generator->string gen . o)
  (list->string (generator->list (if (pair? o) (gtake gen (car o)) gen))))

(define (generator-fold proc seed gen . o)
  (if (null? o)
      (let lp ((acc seed))
        (let ((elt (gen)))
          (if (eof-object? elt)
              acc
              (lp (proc elt acc)))))
      (let lp ((acc seed))
        (let ((elt (gen))
              (elts (map (lambda (g) (g)) o)))
          (if (or (eof-object? elt) (memq eof elts))
              acc
              (lp (apply proc elt (append elts (list acc)))))))))

(define (generator-for-each proc gen . o)
  (if (null? o)
      (generator-fold (lambda (elt acc) (proc elt)) #f gen)
      (let lp ()
        (let ((elt (gen))
              (elts (map (lambda (g) (g)) o)))
          (unless (or (eof-object? elt) (memq eof elts))
            (apply proc elt elts)
            (lp)))))
  (if #f #f))

(define (generator-find pred gen)
  (let lp ()
    (let ((elt (gen)))
      (cond ((eof-object? elt) #f)
            ((pred elt) elt)
            (else (lp))))))

(define (generator-count pred gen)
  (let lp ((count 0))
    (let ((elt (gen)))
      (cond ((eof-object? elt) count)
            ((pred elt) (lp (+ count 1)))
            (else (lp count))))))

(define (generator-any pred gen)
  (let lp ()
    (let ((elt (gen)))
      (cond ((eof-object? elt) #f)
            ((pred elt))
            (else (lp))))))

(define (generator-every pred gen)
  (let lp ()
    (let ((elt (gen)))
      (cond ((eof-object? elt) #t)
            ((pred elt) (lp))
            (else #f)))))

(define (generator-unfold gen unfold . args)
  (apply unfold eof-object? values (lambda (x) (gen)) (gen) args))
(define-library (srfi 121 test)
  (export run-tests)
  (import (scheme base) (scheme read) (srfi 1) (srfi 121) (chibi test))
  (begin
    (define (run-tests)
      (test-begin "srfi-121: generators")

      (test-group "generators/constructors"
        (define (for-each-digit proc n)
          (when (> n 0)
            (let-values (((div rem) (truncate/ n 10)))
              (proc rem)
              (for-each-digit proc div))))
        (test '() (generator->list (generator)))
        (test '(1 2 3) (generator->list (generator 1 2 3)))
        (test '(8 9 10) (generator->list (make-iota-generator 3 8)))
        (test '(8 10 12) (generator->list (make-iota-generator 3 8 2)))
        (test '(3 4 5 6 7) (generator->list (make-range-generator 3 8)))
        (test '(3 4 5 6) (generator->list (make-range-generator 3) 4))
        (test '(3 5 7) (generator->list (make-range-generator 3 8 2)))
        (test '(0 1 2)
            (generator->list
             (make-coroutine-generator
              (lambda (yield)
                (let lp ((i 0))
                  (when (< i 3) (yield i) (lp (+ i 1))))))))
        (test '(1 2 3 4 5) (generator->list (list->generator '(1 2 3 4 5))))
        (test '(1 2 3 4 5) (generator->list (vector->generator '#(1 2 3 4 5))))
        (test '(5 4 3 2 1)
            (generator->list (reverse-vector->generator '#(1 2 3 4 5))))
        (test '(#\a #\b #\c #\d #\e)
            (generator->list (string->generator "abcde")))
        (test '(10 20 30)
            (generator->list (bytevector->generator (bytevector 10 20 30))))
        (test '(5 4 3 2 1)
             (generator->list
              (make-for-each-generator for-each-digit 12345)))
        (test '(0 2 4 6 8 10) (generator->list
                               (make-unfold-generator
                                (lambda (s) (> s 5))
                                (lambda (s) (* s 2))
                                (lambda (s) (+ s 1))
                                0)))
        )

      (test-group "generators/operators"
        (define (small? x) (< x 3))
        (test '(a b 0 1)
            (generator->list (gcons* 'a 'b (make-range-generator 0 2))))
        (test '(0 1 2 0 1)
            (generator->list (gappend (make-range-generator 0 3)
                                      (make-range-generator 0 2))))
        (test '() (generator->list (gappend)))
        (test '(15 22 31)
            (generator->list
             (gcombine (lambda args (values (apply + args) (apply + args)))
                       10
                       (generator 1 2 3)
                       (generator 4 5 6 7))))
        (test '(1 3 5 7 9) (generator->list (gfilter
                                             odd?
                                             (make-range-generator 1 11))))
        (test '(2 4 6 8 10) (generator->list (gremove
                                              odd?
                                              (make-range-generator 1 11))))
        (let ((g (make-range-generator 1 5)))
          (test '(1 2 3) (generator->list (gtake g 3)))
          (test '(4) (generator->list g)))
        (test '(1 2) (generator->list (gtake (make-range-generator 1 3) 3)))
        (test '(1 2 0) (generator->list (gtake (make-range-generator 1 3) 3 0)))
        (test '(3 4) (generator->list (gdrop (make-range-generator 1 5) 2)))
        (test '(1 2)
            (generator->list (gtake-while small? (make-range-generator 1 5))))
        (test '(3 4)
            (generator->list (gdrop-while small? (make-range-generator 1 5))))
        (test '() (generator->list (gdrop-while (lambda args #t) (generator 1 2 3))))
        (test '(0.0 1.0 0 2)
            (generator->list (gdelete 1 (generator 0.0 1.0 0 1 2))))
        (test '(0.0 0 2)
            (generator->list (gdelete 1 (generator 0.0 1.0 0 1 2) =)))
        (test '(a c e)
            (generator->list (gindex (list->generator '(a b c d e f))
                                     (list->generator '(0 2 4)))))
        (test '(a d e)
            (generator->list (gselect (list->generator '(a b c d e f))
                                      (list->generator '(#t #f #f #t #t #f)))))
        (test '(1 2 3)
            (generator->list (gdelete-neighbor-dups
                              (generator 1 1 2 3 3 3)
                              =)))
        (test '(1)
            (generator->list (gdelete-neighbor-dups
                              (generator 1 2 3)
                              (lambda args #t))))
        )

      (test-group "generators/consumers"
        (test '(1 2 3) (generator->list (generator 1 2 3 4 5) 3))
        (test '(5 4 3 2 1) (generator->reverse-list (generator 1 2 3 4 5)))
        (test '#(1 2 3 4 5) (generator->vector (generator 1 2 3 4 5)))
        (test '#(1 2 3) (generator->vector (generator 1 2 3 4 5) 3))
        (test "abc" (generator->string (generator #\a #\b #\c)))
        (test '(e d c b a . z)
            (let ((in (open-input-string "a b c d e")))
              (generator-fold cons 'z (lambda () (read in)))))
        (let ((n 0))
          (generator-for-each (lambda values (set! n (apply + values)))
                              (generator 1) (generator 2) (generator 3))
          (test 6 n))
        (test 3 (generator-find (lambda (x) (> x 2)) (make-range-generator 1 5)))
        (test 2 (generator-count odd? (make-range-generator 1 5)))
        (let ((g (make-range-generator 2 5)))
          (test #t (generator-any odd? g))
          (test '(4) (generator->list g)))
        (let ((g (make-range-generator 2 5)))
          (test #f (generator-every odd? g))
          (test '(3 4) (generator->list g)))
        (test '(#\a #\b #\c)
             (generator-unfold (make-for-each-generator string-for-each "abc")
                               unfold))
        )

      (test-end))))
(define-library (srfi 115)
  (export regexp regexp? valid-sre? rx regexp->sre char-set->sre
          regexp-matches regexp-matches? regexp-search
          regexp-replace regexp-replace-all regexp-match->list
          regexp-fold regexp-extract regexp-split regexp-partition
          regexp-match? regexp-match-count
          regexp-match-submatch
          regexp-match-submatch-start regexp-match-submatch-end)
  (cond-expand (chicken (import (scheme base))) (else))
  (import (chibi regexp)))
(define-library (srfi 147)
  (export define-syntax let-syntax letrec-syntax syntax-rules)
  (import (scheme base)))
(define-library (srfi 219 test)
  (export run-tests)
  (import (chibi) (chibi test) (rename (srfi 219) (define define-219)))
  (begin
    (define (run-tests)
      (test-group
       "srfi-219: define higher-order lambda"

       (let ()
         (define-219 ((greet/prefix prefix) suffix)
           (string-append prefix " " suffix))
         (let ((greet (greet/prefix "Hello")))
           (test "Hello there!" (greet "there!"))))

       (let ()
         (define-219 ((append-to . a) . b)
           (apply append (append a b)))
         (test '()
               ((append-to '()) '()))
         (test '(1 2 3 4 5 6 7 8)
               ((append-to '(1 2) '(3 4)) '(5 6) '(7 8))))

       (let ()
         (define-219 (((jenga a b) c d))
           (list a b c d))
         (test '(1 2 3 4)
               (((jenga 1 2) 3 4))))))))

(define-library (srfi 98)
  (export get-environment-variable get-environment-variables)
  (include-shared "98/env"))

(define-library (srfi 16)
  (export case-lambda)
  (import (chibi))
  (begin
   (define-syntax %case
     (syntax-rules ()
       ((%case args len n p ((params ...) . body) . rest)
        (if (= len (length '(params ...)))
            (apply (lambda (params ...) . body) args)
            (%case args len 0 () . rest)))
       ((%case args len n (p ...) ((x . y) . body) . rest)
        (%case args len (+ n 1) (p ... x) (y . body) . rest))
       ((%case args len n (p ...) (y . body) . rest)
        (if (>= len n)
            (apply (lambda (p ... . y) . body) args)
            (%case args len 0 () . rest)))
       ((%case args len n p)
        (error "case-lambda: no cases matched"))))
   (define-syntax case-lambda
     (syntax-rules ()
       ((case-lambda . clauses)
        (lambda args (let ((len (length* args))) (%case args len 0 () . clauses))))))))
(define-library (srfi 33 test)
  (export run-tests)
  (import (scheme base) (srfi 33) (chibi test))
  (begin
    (define (run-tests)
      (test-begin "srfi-33: bitwise operations")

      (test 0 (bitwise-and #b0 #b1))
      (test 1 (bitwise-and #b1 #b1))
      (test 0 (bitwise-and #b1 #b10))
      (test #b10 (bitwise-and #b11 #b10))
      (test #b101 (bitwise-and #b101 #b111))
      (test #b111 (bitwise-and -1 #b111))
      (test #b110 (bitwise-and -2 #b111))
      (test 3769478 (bitwise-and -4290775858 1694076839))
      (test 1680869008 (bitwise-and -193073517 1689392892))
      (test -4294967295 (bitwise-ior 1 (- -1 #xffffffff)))
      (test -18446744073709551615 (bitwise-ior 1 (- -1 #xffffffffffffffff)))
      (test -4294967126 (bitwise-xor #b10101010 (- -1 #xffffffff)))
      (test -18446744073709551446 (bitwise-xor #b10101010 (- -1 #xffffffffffffffff)))
      (test -2600468497 (bitwise-ior 1694076839 -4290775858))
      (test -184549633 (bitwise-ior -193073517 1689392892))
      (test -2604237975 (bitwise-xor 1694076839 -4290775858))
      (test -1865418641 (bitwise-xor -193073517 1689392892))
      (test 3769478 (bitwise-and 1694076839 -4290775858))
      (test 1680869008 (bitwise-and -193073517 1689392892))

      (test 1 (arithmetic-shift 1 0))
      (test 2 (arithmetic-shift 1 1))
      (test 4 (arithmetic-shift 1 2))
      (test 8 (arithmetic-shift 1 3))
      (test 16 (arithmetic-shift 1 4))
      (test (expt 2 31) (arithmetic-shift 1 31))
      (test (expt 2 32) (arithmetic-shift 1 32))
      (test (expt 2 33) (arithmetic-shift 1 33))
      (test (expt 2 63) (arithmetic-shift 1 63))
      (test (expt 2 64) (arithmetic-shift 1 64))
      (test (expt 2 65) (arithmetic-shift 1 65))
      (test (expt 2 127) (arithmetic-shift 1 127))
      (test (expt 2 128) (arithmetic-shift 1 128))
      (test (expt 2 129) (arithmetic-shift 1 129))
      (test 3028397001194014464 (arithmetic-shift 11829675785914119 8))

      (test -1 (arithmetic-shift -1 0))
      (test -2 (arithmetic-shift -1 1))
      (test -4 (arithmetic-shift -1 2))
      (test -8 (arithmetic-shift -1 3))
      (test -16 (arithmetic-shift -1 4))
      (test (- (expt 2 31)) (arithmetic-shift -1 31))
      (test (- (expt 2 32)) (arithmetic-shift -1 32))
      (test (- (expt 2 33)) (arithmetic-shift -1 33))
      (test (- (expt 2 63)) (arithmetic-shift -1 63))
      (test (- (expt 2 64)) (arithmetic-shift -1 64))
      (test (- (expt 2 65)) (arithmetic-shift -1 65))
      (test (- (expt 2 127)) (arithmetic-shift -1 127))
      (test (- (expt 2 128)) (arithmetic-shift -1 128))
      (test (- (expt 2 129)) (arithmetic-shift -1 129))

      (test 0 (arithmetic-shift 1 -63))
      (test 0 (arithmetic-shift 1 -64))
      (test 0 (arithmetic-shift 1 -65))

      (test #x1000000000000000100000000000000000000000000000000
          (arithmetic-shift #x100000000000000010000000000000000 64))
      (test #x8e73b0f7da0e6452c810f32b809079e5
          (arithmetic-shift #x8e73b0f7da0e6452c810f32b809079e562f8ead2522c6b7b -64))

      (test-not (bit-set? 64 1))
      (test-assert (bit-set? 64 #x10000000000000000))

      (test 3 (bitwise-merge 1 1 2))
      (test #b00110011 (bitwise-merge #b00111100 #b11110000 #b00001111))

      (test-end))))

(define-library (srfi 69)
  (export hash-table-cell
   make-hash-table hash-table? alist->hash-table
   hash-table-equivalence-function hash-table-hash-function
   hash-table-ref hash-table-ref/default hash-table-set!
   hash-table-delete! hash-table-exists?
   hash-table-update! hash-table-update!/default
   hash-table-size hash-table-keys hash-table-values
   hash-table-walk hash-table-fold hash-table->alist
   hash-table-copy hash-table-merge!
   hash string-hash string-ci-hash hash-by-identity)
  (import (chibi) (srfi 9))
  (include-shared "69/hash")
  (include "69/type.scm" "69/interface.scm"))
(define-library (srfi 134)
  (import (scheme base) (scheme case-lambda)
          (srfi 1) (srfi 9) (srfi 121))
  (export ideque ideque-tabulate ideque-unfold ideque-unfold-right 
          ideque? ideque-empty? ideque= ideque-any ideque-every

          ideque-front ideque-add-front ideque-remove-front
          ideque-back  ideque-add-back  ideque-remove-back

          ideque-ref
          ideque-take ideque-take-right ideque-drop ideque-drop-right
          ideque-split-at

          ideque-length ideque-append ideque-reverse
          ideque-count ideque-zip

          ideque-map ideque-filter-map
          ideque-for-each ideque-for-each-right
          ideque-fold ideque-fold-right
          ideque-append-map
          
          ideque-filter ideque-remove ideque-partition

          ideque-find ideque-find-right
          ideque-take-while ideque-take-while-right
          ideque-drop-while ideque-drop-while-right
          ideque-span ideque-break
          
          list->ideque ideque->list
          generator->ideque ideque->generator
          )
  (include "134.scm"))

;; Adaptation of John Cowan's reference impl for chibi, using the
;; our own char-set:title-case.

(define-library (srfi 129)
  (import (scheme base) (scheme char)
          (srfi 1)
          (chibi char-set) (chibi char-set full) (chibi string))
  (export char-title-case? char-titlecase string-titlecase)
  (include "129/titlemaps.scm" "129/titlecase.scm"))

;; Adapted from the reference implementation test suite for R7RS.

(define-library (srfi 101 test)
  (import (except (scheme base)
                  quote pair? cons car cdr 
                  caar cadr cddr cdar
                  null? list? list make-list length 
                  append reverse list-tail
                  list-ref map for-each)
          (prefix (scheme base) r7:)
          (srfi 101)
          (chibi test))
  (export run-tests)
  (begin
    (define (run-tests)

      (test-begin "srfi-101: random access lists")

      (test-assert (let ((f (lambda () '(x))))
                     (eq? (f) (f))))

      (test '(1 2 3) (list 1 2 3))

      ;; pair?
      (test-assert (pair? (cons 'a 'b)))
      (test-assert (pair? (list 'a 'b 'c)))
      (test-not (pair? '()))
      (test-not (pair? '#(a b)))

      ;; cons
      (test (cons 'a '()) (list 'a))
      (test (cons (list 'a) (list 'b 'c 'd))
          (list (list 'a) 'b 'c 'd))
      (test (cons "a" (list 'b 'c))
          (list "a" 'b 'c))
      (test (cons 'a 3)
          (cons 'a 3))
      (test (cons (list 'a 'b) 'c)
          (cons (list 'a 'b) 'c))

      ;; car
      (test 'a
          (car (list 'a 'b 'c)))
      (test (list 'a)
          (car (list (list 'a) 'b 'c 'd)))
      (test 1 (car (cons 1 1)))
      (test-error (car '()))

      ;; cdr
      (test (list 'b 'c 'd)
          (cdr (list (list 'a) 'b 'c 'd)))
      (test 2
          (cdr (cons 1 2)))
      (test-error (cdr '()))

      ;; null?
      (test-assert (eq? null? r7:null?))
      (test-assert (null? '()))
      (test-not (null? (cons 1 2)))
      (test-not (null? 4))

      ;; list?
      (test-assert (list? (list 'a 'b 'c)))
      (test-assert (list? '()))
      (test-not (list? (cons 'a 'b)))

      ;; list
      (test (list 'a 7 'c)
          (list 'a (+ 3 4) 'c))
      (test '() (list))

      ;; make-list
      (test 5 (length (make-list 5)))
      (test (list 0 0 0 0 0)
          (make-list 5 0))

      ;; length
      (test 3 (length (list 'a 'b 'c)))
      (test 3 (length (list 'a (list 'b) (list 'c))))
      (test 0 (length '()))
      (test #t (length<=? 'not-a-list 0))
      (test #t (length<=? '(a . b) 0))
      (test #t (length<=? '(a . b) 1))
      (test #f (length<=? '(a . b) 2))

      ;; append
      (test (list 'x 'y) (append (list 'x) (list 'y)))
      (test (list 'a 'b 'c 'd) (append (list 'a) (list 'b 'c 'd)))
      (test (list 'a (list 'b) (list 'c)) 
          (append (list 'a (list 'b)) (list (list 'c))))
      (test (cons 'a (cons 'b (cons 'c 'd))) 
          (append (list 'a 'b) (cons 'c 'd)))
      (test 'a (append '() 'a))

      ;; reverse
      (test (list 'c 'b 'a)
          (reverse (list 'a 'b 'c)))
      (test (list (list 'e (list 'f)) 'd (list 'b 'c) 'a)
          (reverse (list 'a (list 'b 'c) 'd (list 'e (list 'f)))))

      ;; list-tail
      (test (list 'c 'd)
          (list-tail (list 'a 'b 'c 'd) 2))

      ;; list-ref
      (test 'c (list-ref (list 'a 'b 'c 'd) 2))

      ;; list-set
      (test (list 'a 'b 'x 'd)
          (list-set (list 'a 'b 'c 'd) 2 'x))

      ;; list-ref/update
      (let-values (((a b) 
                    (list-ref/update (list 7 8 9 10) 2 -)))
        (test 9 a)
        (test (list 7 8 -9 10) (values b)))

      ;; map
      (test (list 'b 'e 'h)
          (map cadr (list (list 'a 'b) (list 'd 'e) (list 'g 'h))))
      (test (list 1 4 27 256 3125)
          (map (lambda (n) (expt n n))
                 (list 1 2 3 4 5)))
      (test (list 5 7 9)
          (map + (list 1 2 3) (list 4 5 6)))

      ;; for-each
      (test '#(0 1 4 9 16)
          (let ((v (make-vector 5)))
              (for-each (lambda (i)
                          (vector-set! v i (* i i)))
                        (list 0 1 2 3 4))
              v))

      ;; random-access-list->linear-access-list
      ;; linear-access-list->random-access-list
      (test '() (random-access-list->linear-access-list '()))
      (test '() (linear-access-list->random-access-list '()))

      (test (r7:list 1 2 3)
          (random-access-list->linear-access-list (list 1 2 3)))

      (test (list 1 2 3)
          (linear-access-list->random-access-list (r7:list 1 2 3)))

      (test-end))))
(define-library (srfi 16 test)
  (export run-tests)
  (import (chibi) (chibi test) (srfi 16))
  (begin
    (define (run-tests)
      (define plus
        (case-lambda 
         (() 0)
         ((x) x)
         ((x y) (+ x y))
         ((x y z) (+ (+ x y) z))
         (args (apply + args))))
      (define print
        (case-lambda
         (()
          (display ""))
         ((arg)
          (display arg))
         ((arg . args)
          (display arg)
          (display " ")
          (apply print args))))
      (define (print-to-string . args)
        (let ((out (open-output-string))
              (old-out (current-output-port)))
          (dynamic-wind
            (lambda () (current-output-port out))
            (lambda () (apply print args))
            (lambda () (current-output-port old-out)))
          (get-output-string out)))

      (test-begin "srfi-16: case-lambda")

      (test 0 (plus))
      (test 1 (plus 1))
      (test 6 (plus 1 2 3))
      (test-error ((case-lambda ((a) a) ((a b) (* a b))) 1 2 3))

      (test "" (print-to-string))
      (test "hi" (print-to-string 'hi))
      (test "hi there world" (print-to-string 'hi 'there 'world))

      (test-end))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; primitive layer adapted from SRFI 41 reference impl

(define-record-type Stream
  (make-stream promise)
  stream?
  (promise stream-promise))

(define-record-type Stream-null
  (make-stream-null)
  %stream-null?)

(define-record-type Stream-pair
  (make-stream-pair head tail)
  %stream-pair?
  (head %stream-car)
  (tail %stream-cdr))

(define stream-null (make-stream (make-promise (make-stream-null))))

(define-syntax stream-cons
  (syntax-rules ()
    ((stream-cons object stream) 
     (make-stream
       (make-promise
         (make-stream-pair
           (delay object)
           (delay-force (stream-promise stream))))))))

(define (stream-null? stream)
  (and (stream? stream)
       (%stream-null? (force (stream-promise stream)))))

(define (stream-pair? stream)
  (and (stream? stream)
       (%stream-pair? (force (stream-promise stream)))))

(define (stream-car stream)
  (force (%stream-car (force (stream-promise stream)))))

(define (stream-cdr stream) 
  (let ((t (force (%stream-cdr (force (stream-promise stream))))))
    (make-stream (make-promise t))))

(define-syntax stream-lambda
  (syntax-rules ()
    ((stream-lambda formals body0 body1 ...)
     (lambda formals
       (make-stream
         (delay-force (stream-promise (let () body0 body1 ...))))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; derived

(define-syntax assert
  (syntax-rules ()
    ((assert expr ...)
     (begin (unless expr (error "assertion failed" 'expr)) ...))))

(define-syntax define-stream
  (syntax-rules ()
    ((define-stream (name . args) e0 e1 ...)
     (define name
       (stream-lambda args e0 e1 ...)))))

(define-syntax stream-let
  (syntax-rules ()
    ((stream-let lp ((name val) ...) e0 e1 ...)
     ((letrec ((lp (stream-lambda (name ...) e0 e1 ...))) lp)
      val ...))))

(define-syntax stream
  (syntax-rules ()
    ((stream) stream-null)
    ((stream x y ...) (stream-cons x (stream y ...)))))

(define (list->stream ls)
  (assert (list? ls))
  (let lp ((ls (reverse ls)) (res stream-null))
    (if (null? ls)
        res
        (lp (cdr ls) (stream-cons (car ls) res)))))

(define (port->stream in)
  (assert (input-port? in))
  (let lp ()
    (let ((ch (read-char in)))
      (if (eof-object? ch)
          stream-null
          (stream-cons ch (lp))))))

(define (stream->list x . o)
  (let ((n (if (pair? o) x +inf.0)))
    (assert (not (negative? n)))
    (let lp ((i 0)
             (strm (if (pair? o) (car o) x))
             (res '()))
      (if (or (>= i n) (stream-null? strm))
          (reverse res)
          (lp (+ i 1)
              (stream-cdr strm)
              (cons (stream-car strm) res))))))

(define (stream-concat strms)
  (assert (stream? strms))
  (if (stream-null? strms)
      stream-null
      (let lp ((strm (stream-car strms))
               (strms (stream-cdr strms)))
        (assert (stream? strm))
        (cond
         ((stream-null? strm)
          (if (stream-null? strms)
              stream-null
              (lp (stream-car strms) (stream-cdr strms))))
         (else
          (stream-cons (stream-car strm)
                       (lp (stream-cdr strm) strms)))))))

(define (stream-append . strms)
  (stream-concat (list->stream strms)))

(define (stream-from n . o)
  (let ((step (if (pair? o) (car o) 1)))
    (assert (number? n) (number? step))
    (let lp ((n n))
      (stream-cons n (lp (+ n step))))))

(define (stream-range first past . o)
  (let ((step (if (pair? o) (car o) (if (< first past) 1 -1))))
    (assert (number? first) (number? past) (number? step))
    (if (positive? step)
        (stream-let lp ((n first))
          (if (< n past)
              (stream-cons n (lp (+ n step)))
              stream-null))
        (stream-let lp ((n first))
          (if (> n past)
              (stream-cons n (lp (+ n step)))
              stream-null)))))

(define (stream-constant . o)
  (let lp ((ls o))
    (if (null? ls)
        (lp o)
        (stream-cons (car ls) (lp (cdr ls))))))

(define (stream-ref strm k)
  (assert (stream? strm) (integer? k) (not (negative? k)))
  (if (positive? k)
      (stream-ref (stream-cdr strm) (- k 1))
      (stream-car strm)))

(define (stream-length strm)
  (assert (stream? strm))
  (let lp ((strm strm) (len 0))
    (if (stream-null? strm)
        len
        (lp (stream-cdr strm) (+ len 1)))))

(define (stream-drop k strm)
  (assert (integer? k) (not (negative? k)) (stream? strm))
  (stream-let drop ((k k) (strm strm))
    (if (or (zero? k) (stream-null? strm))
        strm
        (drop (- k 1) (stream-cdr strm)))))

(define (stream-drop-while pred? strm)
  (assert (procedure? pred?) (stream? strm))
  (stream-let drop-while ((strm strm))
    (if (or (stream-null? strm) (not (pred? (stream-car strm))))
        strm
        (drop-while (stream-cdr strm)))))

(define (stream-filter pred? strm)
  (assert (procedure? pred?) (stream? strm))
  (stream-let filter ((strm strm))
    (cond ((stream-null? strm) stream-null)
          ((pred? (stream-car strm))
           (stream-cons (stream-car strm) (filter (stream-cdr strm))))
          (else not (filter (stream-cdr strm))))))

(define (stream-for-each proc strm)
  (assert (procedure? proc) (stream? strm))
  (when (stream-pair? strm)
    (proc (stream-car strm))
    (stream-for-each proc (stream-cdr strm))))

(define (stream-fold kons knil strm)
  (assert (procedure? kons) (stream? strm))
  (let fold ((acc knil) (strm strm))
    (if (stream-null? strm)
        acc
        (fold (kons (stream-car strm) acc) (stream-cdr strm)))))

(define (stream-scan proc base strm)
  (assert (procedure? proc) (stream? strm))
  (stream-let scan ((acc base) (strm strm))
    (if (stream-null? strm)
        (stream acc)
        (stream-cons acc
                     (scan (proc acc (stream-car strm))
                           (stream-cdr strm))))))

(define (stream-map proc strm . o)
  (assert (procedure? proc) (stream? strm))
  (if (pair? o)
      (stream-let lp ((strms (cons strm o)))
        (if (any stream-null? strms)
            stream-null
            (stream-cons (apply proc (map stream-car strms))
                         (lp (map stream-cdr strms)))))
      (stream-let lp ((strm strm))
        (if (stream-null? strm)
            stream-null
            (stream-cons (proc (stream-car strm))
                         (lp (stream-cdr strm)))))))

(define (stream-iterate proc base)
  (assert (procedure? proc))
  (stream-let iterate ((base base))
    (stream-cons base (iterate (proc base)))))

(define (stream-take k strm)
  (assert (integer? k) (not (negative? k)) (stream? strm))
  (stream-let take ((k k) (strm strm))
    (if (and (positive? k) (stream-pair? strm))
        (stream-cons (stream-car strm) (take (- k 1) (stream-cdr strm)))
        stream-null)))

(define (stream-take-while pred strm)
  (assert (procedure? pred) (stream? strm))
  (stream-let take-while ((strm strm))
    (if (and (stream-pair? strm) (pred (stream-car strm)))
        (stream-cons (stream-car strm) (take-while (stream-cdr strm)))
        stream-null)))

(define-syntax stream-of
  (syntax-rules ()
    ((stream-of expr . clauses)
     (stream-of/aux expr stream-null . clauses))))

(define-syntax stream-of/aux
  (syntax-rules (in is)
    ((stream-of/aux expr tail)
     (stream-cons expr tail))
    ((stream-of/aux expr tail (var in s) . rest)
     (stream-let lp ((strm s))
       (if (stream-null? strm)
           tail
           (let ((var (stream-car strm)))
             (stream-of/aux expr (lp (stream-cdr strm)) . rest)))))
    ((stream-of/aux expr tail (var is e) . rest)
     (let ((var e))
       (stream-of/aux expr tail . rest)))
    ((stream-of/aux expr tail pred . rest)
     (if pred (stream-of/aux expr tail . rest) tail))))

(define (stream-reverse strm)
  (list->stream (reverse (stream->list strm))))

(define (stream-unfold mapper pred gen base)
  (assert (procedure? mapper) (procedure? pred) (procedure? gen))
  (stream-let unfold ((base base))
    (if (pred base)
        (stream-cons (mapper base) (unfold (gen base)))
        stream-null)))

(define (stream-unfolds proc seed)
  (assert (procedure? proc))
  (let ((strm (stream-let lp ((seed seed))
                (call-with-values
                    (lambda () (proc seed))
                  (lambda ls
                    (stream-cons (cdr ls)
                                 (lp (car ls))))))))
    (apply values
           (map (lambda (i)
                  (stream-let lp ((strm strm))
                    (let ((x (list-ref (stream-car strm) i)))
                      (cond
                       ((null? x) stream-null)
                       ((pair? x) (stream-cons (car x) (lp (stream-cdr strm))))
                       (else (lp (stream-cdr strm)))))))
                (iota (length (stream-car strm)))))))

(define (stream-zip strm . o)
  (assert (stream? strm) (every stream? o))
  (stream-let lp ((strms (cons strm o)))
    (if (every stream-pair? strms)
        (stream-cons (map stream-car strms)
                     (lp (map stream-cdr strms)))
        stream-null)))

(define-syntax stream-match
  (syntax-rules ()
    ((stream-match expr clause ...)
     (let ((strm expr))
       (assert (stream? strm))
       (stream-match-next strm clause ...)))))

(define-syntax stream-match-next
  (syntax-rules ()
    ((stream-match-next strm)
     (error "no pattern matched"))
    ((stream-match-next strm clause . clauses)
     (let ((fail (lambda () (stream-match-next strm . clauses))))
       (stream-match-one strm clause (fail))))))

(define-syntax stream-match-one
  (syntax-rules (_)
    ((stream-match-one strm (() . body) fail)
     (if (stream-null? strm)
         (stream-match-body fail . body)
         fail))
    ((stream-match-one strm (_ . body) fail)
     (stream-match-body fail . body))
    ((stream-match-one strm ((a . b) . body) fail)
     (if (stream-pair? strm)
         (stream-match-one
          (stream-car strm)
          (a
           (stream-match-one (stream-cdr strm) (b . body) fail))
          fail)
         fail))
    ((stream-match-one strm (a . body) fail)
     (let ((a strm))
       (stream-match-body fail . body)))))

(define-syntax stream-match-body
  (syntax-rules ()
    ((stream-match-body fail fender expr)
     (if fender expr fail))
    ((stream-match-body fail expr)
     expr)))

;; Local variables:
;; eval: (put 'stream-let 'scheme-indent-function 2)
;; End:
;; Adapted for R7RS from original SRFI 41 r5rs.ss.

;; Copyright (C) 2007 by Philip L. Bewig of Saint Louis, Missouri,
;; USA.  All rights reserved.  Permission is hereby granted, free of
;; charge, to any person obtaining a copy of this software and
;; associated documentation files (the "Software"), to deal in the
;; Software without restriction, including without limitation the
;; rights to use, copy, modify, merge, publish, distribute,
;; sublicense, and/or sell copies of the Software, and to permit
;; persons to whom the Software is furnished to do so, subject to the
;; following conditions: The above copyright notice and this
;; permission notice shall be included in all copies or substantial
;; portions of the Software.  THE SOFTWARE IS PROVIDED "AS IS",
;; WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
;; LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
;; PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
;; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
;; OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
;; OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
;; OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; unit tests

(define-library (srfi 41 test)
  (import (scheme base) (srfi 41) (chibi test))
  (export run-tests)
  (begin

    (define (add1 n) (+ n 1))
    (define strm123 (stream 1 2 3))
    (define (lsec proc . args)
      (lambda x (apply proc (append args x))))
    (define (rsec proc . args)
      (lambda x (apply proc (reverse (append (reverse args) (reverse x))))))
    (define nats
      (stream-cons 0 (stream-map add1 nats)))

    ;; executing (run-tests) should produce no output
    (define (run-tests)

      (test-begin "srfi-41: streams")

      ;; stream-null
      (test #t (stream? stream-null))
      (test #t (stream-null? stream-null))
      (test #f (stream-pair? stream-null))
      
      ;; stream-cons
      (test #t (stream? (stream-cons 1 stream-null)))
      (test #f (stream-null? (stream-cons 1 stream-null)))
      (test #t (stream-pair? (stream-cons 1 stream-null)))
      
      ;; stream?
      (test #t (stream? stream-null))
      (test #t (stream? (stream-cons 1 stream-null)))
      (test #f (stream? "four"))
      
      ;; stream-null?
      (test #t (stream-null? stream-null))
      (test #f (stream-null? (stream-cons 1 stream-null)))
      (test #f (stream-null? "four"))
      
      ;; stream-pair?
      (test #f (stream-pair? stream-null))
      (test #t (stream-pair? (stream-cons 1 stream-null)))
      (test #f (stream-pair? "four"))
      
      ;; stream-car
      (test-error (stream-car "four")) ; "stream-car: non-stream"
      (test-error (stream-car stream-null)) ; "stream-car: null stream"
      (test 1 (stream-car strm123))
      
      ;; stream-cdr
      (test-error (stream-cdr "four")) ; "stream-cdr: non-stream"
      (test-error (stream-cdr stream-null)) ; "stream-cdr: null stream"
      (test 2 (stream-car (stream-cdr strm123)))

      ;; stream-lambda
      (test
          '(2 4 6)
          (stream->list
           (letrec ((double
                     (stream-lambda (strm)
                                    (if (stream-null? strm)
                                        stream-null
                                        (stream-cons
                                         (* 2 (stream-car strm))
                                         (double (stream-cdr strm)))))))
             (double strm123))))

      ;; define-stream
      (test
          '(2 4 6)
          (stream->list
           (let ()
             (define-stream (double strm)
               (if (stream-null? strm)
                   stream-null
                   (stream-cons
                    (* 2 (stream-car strm))
                    (double (stream-cdr strm)))))
             (double strm123))))

      ;; list->stream
      (test-error (list->stream "four")) ; "list->stream: non-list argument"
      (test '() (stream->list (list->stream '())))
      (test '(1 2 3) (stream->list (list->stream '(1 2 3))))

      ;; port->stream
      (let* ((p (open-input-string "; Copyright 2007"))
             (s (port->stream p)))
        (test-error (port->stream "four"))
        (test "; Copyright" (list->string (stream->list 11 s)) )
        (close-input-port p))

      ;; stream
      (test '() (stream->list (stream)))
      (test '(1) (stream->list (stream 1)))
      (test '(1 2 3) (stream->list (stream 1 2 3)))

      ;; stream->list
      (test-error (stream->list '())) ; "stream->list: non-stream argument"
      (test-error (stream->list "four" strm123)) ; "stream->list: non-integer count"
      (test-error (stream->list -1 strm123)) ; "stream->list: negative count"
      (test '() (stream->list (stream)))
      (test '(1 2 3) (stream->list strm123))
      (test '(1 2 3) (stream->list 5 strm123))
      (test '(1 2 3) (stream->list 3 (stream-from 1)))
      
      ;; stream-append
      (test-error (stream-append "four")) ; "stream-append: non-stream argument"
      (test '(1 2 3) (stream->list (stream-append strm123)))
      (test '(1 2 3 1 2 3) (stream->list (stream-append strm123 strm123)))
      (test '(1 2 3 1 2 3 1 2 3)
          (stream->list (stream-append strm123 strm123 strm123)))
      (test '(1 2 3) (stream->list (stream-append strm123 stream-null)))
      (test '(1 2 3) (stream->list (stream-append stream-null strm123)))
      
      ;; stream-concat
      (test-error (stream-concat "four")) ; "stream-concat: non-stream argument"
      (test '(1 2 3) (stream->list (stream-concat (stream strm123))))
      (test '(1 2 3 1 2 3)
          (stream->list (stream-concat (stream strm123 strm123))))

      ;; stream-constant
      (test 1 (stream-ref (stream-constant 1) 100))
      (test 1 (stream-ref (stream-constant 1 2) 100))
      (test 1 (stream-ref (stream-constant 1 2 3) 3))

      ;; stream-drop
      (test-error (stream-drop "four" strm123)) ; "stream-drop: non-integer argument"
      (test-error (stream-drop -1 strm123)) ; "stream-drop: negative argument"
      (test-error (stream-drop 2 "four")) ; "stream-drop: non-stream argument"
      (test '() (stream->list (stream-drop 0 stream-null)))
      (test '(1 2 3) (stream->list (stream-drop 0 strm123)))
      (test '(2 3) (stream->list (stream-drop 1 strm123)))
      (test '() (stream->list (stream-drop 5 strm123)))

      ;; stream-drop-while
      (test-error ; "stream-drop-while: non-procedural argument"
       (stream-drop-while "four" strm123))
      (test-error ; "stream-drop-while: non-stream argument"
       (stream-drop-while odd? "four"))
      (test '() (stream->list (stream-drop-while odd? stream-null)))
      (test '(2 3) (stream->list (stream-drop-while odd? strm123)))
      (test '(1 2 3) (stream->list (stream-drop-while even? strm123)))
      (test '() (stream->list (stream-drop-while positive? strm123)))
      (test '(1 2 3) (stream->list (stream-drop-while negative? strm123)))

      ;; stream-filter
      (test-error ; "stream-filter: non-procedural argument"
       (stream-filter "four" strm123))
      (test-error (stream-filter odd? '())) ; "stream-filter: non-stream argument"
      (test #t (stream-null? (stream-filter odd? (stream))))
      (test '(1 3) (stream->list (stream-filter odd? strm123)))
      (test '(2) (stream->list (stream-filter even? strm123)))
      (test '(1 2 3) (stream->list (stream-filter positive? strm123)))
      (test '() (stream->list (stream-filter negative? strm123)))
      (let loop ((n 10))
        (test #t (odd? (stream-ref (stream-filter odd? (stream-from 0)) n)))
        (if (positive? n) (loop (- n 1))))
      (let loop ((n 10))
        (test #f (even? (stream-ref (stream-filter odd? (stream-from 0)) n)))
        (if (positive? n) (loop (- n 1))))

      ;; stream-fold
      (test-error ; "stream-fold: non-procedural argument"
       (stream-fold "four" 0 strm123))
      (test-error (stream-fold + 0 '())) ; "stream-fold: non-stream argument"
      (test 6 (stream-fold + 0 strm123))

      ;; stream-for-each
      (test-error ; "stream-for-each: non-procedural argument"
       (stream-for-each "four" strm123))
      (test-error ; "stream-for-each: no stream arguments"
       (stream-for-each +))
      (test-error ; "stream-for-each: non-stream argument"
       (stream-for-each + "four"))
      (test 6
          (let ((sum 0))
            (stream-for-each (lambda (x) (set! sum (+ sum x))) strm123)
            sum))

      ;; stream-from
      (test-error (stream-from "four")) ; "stream-from: non-numeric starting number"
      (test-error (stream-from 1 "four")) ; "stream-from: non-numeric step size"
      (test 100 (stream-ref (stream-from 0) 100))
      (test 201 (stream-ref (stream-from 1 2) 100))
      (test -100 (stream-ref (stream-from 0 -1) 100))

      ;; stream-iterate
      (test-error (stream-iterate "four" 0)) ; "stream-iterate: non-procedural argument"
      (test '(1 2 3) (stream->list 3 (stream-iterate (lsec + 1) 1)))

      ;; stream-length
      (test-error (stream-length "four")) ; "stream-length: non-stream argument"
      (test 0 (stream-length (stream)))
      (test 3 (stream-length strm123))

      ;; stream-let
      (test '(2 4 6)
          (stream->list
           (stream-let loop ((strm strm123))
                       (if (stream-null? strm)
                           stream-null
                           (stream-cons
                            (* 2 (stream-car strm))
                            (loop (stream-cdr strm)))))))

      ;; stream-map
      (test-error (stream-map "four" strm123)) ; "stream-map: non-procedural argument"
      (test-error (stream-map odd?)) ; "stream-map: no stream arguments"
      (test-error (stream-map odd? "four")) ; "stream-map: non-stream argument"
      (test '(-1 -2 -3) (stream->list (stream-map - strm123)))
      (test '(2 4 6) (stream->list (stream-map + strm123 strm123)))
      (test '(2 4 6) (stream->list (stream-map + strm123 (stream-from 1))))
      (test '(2 4 6) (stream->list (stream-map + (stream-from 1) strm123)))
      (test '(3 6 9) (stream->list (stream-map + strm123 strm123 strm123)))

      ;; stream-match
      (test-error (stream-match '(1 2 3) (_ 'ok))) ; "stream-match: non-stream argument"
      (test-error (stream-match strm123 (() 42))) ; "stream-match: pattern failure"
      (test 'ok (stream-match stream-null (() 'ok)))
      (test 'ok (stream-match strm123 (() 'no) (else 'ok)))
      (test 1 (stream-match (stream 1) (() 'no) ((a) a)))
      (test 'ok (stream-match (stream 1) (() 'no) ((_) 'ok)))
      (test '(1 2 3) (stream-match strm123 ((a b c) (list a b c))))
      (test 1 (stream-match strm123 ((a . _) a)))
      (test '(1 2) (stream-match strm123 ((a b . _) (list a b))))
      (test '(1 2 3)
          (stream-match strm123 ((a b . c) (list a b (stream-car c)))))
      (test '(1 2 3) (stream-match strm123 (s (stream->list s))))
      (test 'ok (stream-match strm123 ((a . _) (= a 1) 'ok)))
      (test 'no (stream-match strm123 ((a . _) (= a 2) 'yes) (_ 'no)))
      (test 'no (stream-match strm123 ((a b c) (= a b) 'yes) (_ 'no)))
      (test 'yes (stream-match (stream 1 1 2) ((a b c) (= a b) 'yes) (_ 'no)))

      ;; stream-of
      (test '(7 15 31)
          (stream->list
           (stream-of (+ y 6)
                      (x in (stream-range 1 6))
                      (odd? x)
                      (y is (* x x)))))
      (test '(1 2 3 4 2 4 6 8 3 6 9 12)
          (stream->list
           (stream-of (* x y)
                      (x in (stream-range 1 4))
                      (y in (stream-range 1 5)))))
      (test 1 (stream-car (stream-of 1)))

      ;; stream-range
      (test-error (stream-range "four" 0)) ; "stream-range: non-numeric starting number"
      (test-error (stream-range 0 "four")) ; "stream-range: non-numeric ending number"
      (test-error (stream-range 1 2 "three")) ; "stream-range: non-numeric step size"
      (test '(0 1 2 3 4) (stream->list (stream-range 0 5)))
      (test '(5 4 3 2 1) (stream->list (stream-range 5 0)))
      (test '(0 2 4) (stream->list (stream-range 0 5 2)))
      (test '(5 3 1) (stream->list (stream-range 5 0 -2)))
      (test '() (stream->list (stream-range 0 1 -1)))

      ;; stream-ref
      (test-error (stream-ref '() 4)) ; "stream-ref: non-stream argument"
      (test-error (stream-ref nats 3.5)) ; "stream-ref: non-integer argument"
      (test-error (stream-ref nats -3)) ; "stream-ref: negative argument"
      (test-error (stream-ref strm123 5)) ; "stream-ref: beyond end of stream"
      (test 1 (stream-ref strm123 0))
      (test 2 (stream-ref strm123 1))
      (test 3 (stream-ref strm123 2))

      ;; stream-reverse
      (test-error (stream-reverse '())) ; "stream-reverse: non-stream argument"
      (test '() (stream->list (stream-reverse (stream))))
      (test '(3 2 1) (stream->list (stream-reverse strm123)))

      ;; stream-scan
      (test-error ; "stream-scan: non-procedural argument"
       (stream-scan "four" 0 strm123))
      (test-error (stream-scan + 0 '())) ; "stream-scan: non-stream argument"
      (test '(0 1 3 6) (stream->list (stream-scan + 0 strm123)))

      ;; stream-take
      (test-error (stream-take 5 "four")) ; "stream-take: non-stream argument"
      (test-error (stream-take "four" strm123)) ; "stream-take: non-integer argument"
      (test-error (stream-take -4 strm123)) ; "stream-take: negative argument"
      (test '() (stream->list (stream-take 5 stream-null)))
      (test '() (stream->list (stream-take 0 stream-null)))
      (test '() (stream->list (stream-take 0 strm123)))
      (test '(1 2) (stream->list (stream-take 2 strm123)))
      (test '(1 2 3) (stream->list (stream-take 3 strm123)))
      (test '(1 2 3) (stream->list (stream-take 5 strm123)))

      ;; stream-take-while
      (test-error ; "stream-take-while: non-stream argument"
       (stream-take-while odd? "four"))
      (test-error ; "stream-take-while: non-procedural argument"
       (stream-take-while "four" strm123))
      (test '(1) (stream->list (stream-take-while odd? strm123)))
      (test '() (stream->list (stream-take-while even? strm123)))
      (test '(1 2 3) (stream->list (stream-take-while positive? strm123)))
      (test '() (stream->list (stream-take-while negative? strm123)))

      ;; stream-unfold
      (test-error ; "stream-unfold: non-procedural mapper"
       (stream-unfold "four" odd? + 0))
      (test-error ; "stream-unfold: non-procedural pred?"
       (stream-unfold + "four" + 0))
      (test-error ; "stream-unfold: non-procedural generator"
       (stream-unfold + odd? "four" 0))
      (test '(0 1 4 9 16 25 36 49 64 81)
          (stream->list (stream-unfold (rsec expt 2) (rsec < 10) (rsec + 1) 0)))

      ;; stream-unfolds
      (test
          '(0 1 2 3 4)
          (stream->list
           (stream-unfolds
            (lambda (x)
              (let ((n (car x)) (s (cdr x)))
                (if (zero? n)
                    (values 'dummy '())
                    (values
                     (cons (- n 1) (stream-cdr s))
                     (list (stream-car s))))))
            (cons 5 (stream-from 0)))))

      ;; stream-zip
      (test-error (stream-zip)) ; "stream-zip: no stream arguments"
      (test-error (stream-zip "four")) ; "stream-zip: non-stream argument"
      (test-error (stream-zip strm123 "four")) ; "stream-zip: non-stream argument"
      (test '() (stream->list (stream-zip strm123 stream-null)))
      (test '((1) (2) (3)) (stream->list (stream-zip strm123)))
      (test '((1 1) (2 2) (3 3)) (stream->list (stream-zip strm123 strm123)))
      (test '((1 1) (2 2) (3 3))
          (stream->list (stream-zip strm123 (stream-from 1))))
      (test '((1 1 1) (2 2 2) (3 3 3))
          (stream->list (stream-zip strm123 strm123 strm123)))

      (test-end))))
;; Miscellaneous Functions

(define (translation? x)
  (and (vector? x) (not (vector-empty? x)) (vector-every exact-integer? x)))

(define (permutation? x)
  (and (translation? x)
       (let* ((len (vector-length x))
              (seen (make-vector len 0)))
         (let lp ((i 0))
           (or (>= i len)
               (and (< -1 (vector-ref x i) len)
                    (zero? (vector-ref seen (vector-ref x i)))
                    (begin
                      (vector-set! seen (vector-ref x i) 1)
                      (lp (+ i 1)))))))))

;; Intervals

(define-record-type Interval
  (%%make-interval lb ub)
  interval?
  (lb interval-lb)
  (ub interval-ub))

(define (%make-interval lo hi)
  (assert (and (translation? lo)
               (translation? hi)
               (= (vector-length lo) (vector-length hi))
               (vector-every < lo hi)))
  (%%make-interval lo hi))

(define (make-interval x . o)
  (if (pair? o)
      (%make-interval x (car o))
      (%make-interval (make-vector (vector-length x) 0) x)))

(define (interval-dimension iv)
  (vector-length (interval-lb iv)))

(define (interval-lower-bound iv i) (vector-ref (interval-lb iv) i))
(define (interval-upper-bound iv i) (vector-ref (interval-ub iv) i))
(define (interval-lower-bounds->list iv) (vector->list (interval-lb iv)))
(define (interval-upper-bounds->list iv) (vector->list (interval-ub iv)))
(define (interval-lower-bounds->vector iv) (vector-copy (interval-lb iv)))
(define (interval-upper-bounds->vector iv) (vector-copy (interval-ub iv)))

(define (interval= iv1 iv2)
  (assert (and (interval? iv1) (interval? iv2)))
  (and (equal? (interval-lb iv1) (interval-lb iv2))
       (equal? (interval-ub iv1) (interval-ub iv2))))

(define (interval-volume iv)
  (vector-fold (lambda (acc lower upper) (* acc (- upper lower)))
               1
               (interval-lb iv) (interval-ub iv)))

(define (interval-subset? iv1 iv2)
  (assert (and (interval? iv1) (interval? iv2)
               (= (interval-dimension iv1) (interval-dimension iv2))))
  (and (vector-every >= (interval-lb iv1) (interval-lb iv2))
       (vector-every <= (interval-ub iv1) (interval-ub iv2))))

(define (interval-contains-multi-index? iv i0 . o)
  (assert (interval? iv))
  (let ((i (list->vector (cons i0 o))))
    (assert (and (= (interval-dimension iv) (vector-length i))
                 (vector-every integer? i)))
    (and (vector-every >= i (interval-lb iv))
         (vector-every < i (interval-ub iv)))))

(define (interval-projections iv rd)
  (values (make-interval (vector-copy (interval-lb iv) 0 rd)
                         (vector-copy (interval-ub iv) 0 rd))
          (make-interval (vector-copy (interval-lb iv) rd)
                         (vector-copy (interval-ub iv) rd))))

(define (rev-index-next! rev-index rev-lowers rev-uppers)
  (cond
   ((null? rev-index) #f)
   ((< (caar rev-index) (- (car rev-uppers) 1))
    (set-car! (car rev-index) (+ 1 (caar rev-index)))
    #t)
   (else
    (set-car! (car rev-index) (car rev-lowers))
    (rev-index-next! (cdr rev-index) (cdr rev-lowers) (cdr rev-uppers)))))

(define (interval-cursor iv)
  (let* ((rev-lowers (reverse (interval-lower-bounds->list iv)))
         (rev-uppers (reverse (interval-upper-bounds->list iv)))
         (multi-index (interval-lower-bounds->list iv))
         (rev-index (pair-fold cons '() multi-index)))
    (vector multi-index rev-index rev-lowers rev-uppers)))

(define (interval-cursor-get ivc)
  (vector-ref ivc 0))

(define (interval-cursor-next! ivc)
  (and (rev-index-next! (vector-ref ivc 1)
                        (vector-ref ivc 2)
                        (vector-ref ivc 3))
       (vector-ref ivc 0)))

(define (interval-cursor-next ivc)
  (let* ((multi-index (list-copy (vector-ref ivc 0)))
         (ivc (vector multi-index
                      (pair-fold cons '() multi-index)
                      (vector-ref ivc 2)
                      (vector-ref ivc 3))))
    (and (rev-index-next! (vector-ref ivc 1)
                          (vector-ref ivc 2)
                          (vector-ref ivc 3))
         (values ivc (vector-ref ivc 0)))))

(define (interval-fold kons knil iv)
  (case (interval-dimension iv)
    ((1)
     (let ((end (interval-upper-bound iv 0)))
       (do ((i (interval-lower-bound iv 0) (+ i 1))
            (acc knil (kons acc i)))
           ((>= i end) acc))))
    ((2)
     (let ((end0 (interval-upper-bound iv 0))
           (start1 (interval-lower-bound iv 1))
           (end1 (interval-upper-bound iv 1)))
       (do ((i (interval-lower-bound iv 0) (+ i 1))
            (acc knil
                 (do ((j start1 (+ j 1))
                      (acc acc (kons acc i j)))
                     ((>= j end1) acc))))
           ((>= i end0) acc))))
    (else
     (let ((ivc (interval-cursor iv)))
       (let lp ((acc knil))
         (let ((acc (apply kons acc (interval-cursor-get ivc))))
           (if (interval-cursor-next! ivc)
               (lp acc)
               acc)))))))

(define (interval-for-each f iv)
  (interval-fold (lambda (acc . multi-index) (apply f multi-index)) #f iv)
  (if #f #f))

(define (interval-dilate iv lower-diffs upper-diffs)
  (assert (= (interval-dimension iv)
             (vector-length lower-diffs)
             (vector-length upper-diffs)))
  (make-interval (vector-map + (interval-lb iv) lower-diffs)
                 (vector-map + (interval-ub iv) upper-diffs)))

(define (interval-intersect iv0 . o)
  (let ((ls (cons iv0 o)))
    (assert (and (every interval? ls)
                 (or (null? o) (apply = (map interval-dimension ls)))))
    (let ((lower (apply vector-map max (map interval-lb ls)))
          (upper (apply vector-map min (map interval-ub ls))))
      (and (vector-every < lower upper)
           (make-interval lower upper)))))

(define (interval-translate iv translation)
  (assert (translation? translation))
  (interval-dilate iv translation translation))

(define (interval-permute iv perm)
  (assert (and (interval? iv) (permutation? perm)))
  (let* ((len (interval-dimension iv))
         (lower (make-vector len))
         (upper (make-vector len)))
    (assert (= len (vector-length perm)))
    (do ((i 0 (+ i 1)))
        ((>= i len) (make-interval lower upper))
      (vector-set! lower i (interval-lower-bound iv (vector-ref perm i)))
      (vector-set! upper i (interval-upper-bound iv (vector-ref perm i))))))

(define (interval-rotate iv dim)
  (let ((lower (interval-lb iv))
        (upper (interval-ub iv)))
    (make-interval (vector-append (vector-copy lower dim)
                                  (vector-copy lower 0 dim))
                   (vector-append (vector-copy upper dim)
                                  (vector-copy upper 0 dim)))))

(define (interval-scale iv scales)
  (assert (and (interval? iv)
               (vector? scales)
               (= (interval-dimension iv) (vector-length scales))
               (vector-every exact-integer? scales)
               (vector-every positive? scales)))
  (make-interval
   (vector-map (lambda (u s) (exact (ceiling (/ u s))))
               (interval-ub iv)
               scales)))

(define (interval-cartesian-product iv0 . o)
  (make-interval (apply vector-append (map interval-lb (cons iv0 o)))
                 (apply vector-append (map interval-ub (cons iv0 o)))))

;; Storage Classes

(define-record-type Storage-Class
  (make-storage-class getter setter checker maker copier length default)
  storage-class?
  (getter storage-class-getter)
  (setter storage-class-setter)
  (checker storage-class-checker)
  (maker storage-class-maker)
  (copier storage-class-copier)
  (length storage-class-length)
  (default storage-class-default))

(define generic-storage-class
  (make-storage-class
   vector-ref vector-set! (lambda (x) #t) make-vector
   vector-copy! vector-length #f))

;; Parameters

;; Note safety is ignored in this implementation.
(define specialized-array-default-safe?
  (make-parameter #f (lambda (x) (assert (boolean? x)) x)))

(define specialized-array-default-mutable?
  (make-parameter #t (lambda (x) (assert (boolean? x)) x)))

;; Arrays

(define-record-type Array
  (%%make-array domain getter setter storage body coeffs indexer safe? adjacent?)
  array?
  (domain array-domain)
  (getter array-getter)
  (setter array-setter %array-setter-set!)
  (storage array-storage-class)
  (body array-body)
  (coeffs array-coeffs)
  (indexer array-indexer)
  (safe? array-safe?)
  (adjacent? array-adjacent? array-adjacent?-set!))

(define (%make-array domain getter setter storage body coeffs
                     indexer safe? adjacent?)
  (assert (and (interval? domain)
               (procedure? getter)
               (or (not setter) (procedure? setter))
               (or (not storage) (storage-class? storage))))
  (%%make-array
   domain getter setter storage body coeffs indexer safe? adjacent?))

(define (make-array domain getter . o)
  (assert (and (interval? domain) (procedure? getter)))
  (%make-array domain getter (and (pair? o) (car o)) #f #f #f #f #f #f))

(define (array-dimension a)
  (interval-dimension (array-domain a)))

(define (mutable-array? x)
  (and (array? x) (array-setter x) #t))

(define (array-ref array . multi-index)
  (apply (array-getter array) multi-index))

(define (array-set! array val . multi-index)
  (apply (array-setter array) val multi-index))

(define (specialized-getter body indexer getter)
  (lambda multi-index
    (getter body (apply indexer multi-index))))

(define (specialized-setter body indexer setter)
  (lambda (val . multi-index)
    (setter body (apply indexer multi-index) val)))


;; Indexing

(define (indexer->coeffs indexer domain . o)
  (let* ((verify? (and (pair? o) (car o)))
         (res (make-vector (+ 1 (interval-dimension domain)) 0))
         (multi-index (interval-lower-bounds->list domain))
         (base (apply indexer multi-index)))
    (vector-set! res 0 base)
    (let lp ((i 1)
             (ls multi-index)
             (offset base)
             (count 0))
      (cond
       ((null? ls)
        (if (and verify? (zero? count))
            (lp 1 multi-index offset (+ count 1))
            res))
       ((= (+ 1 (interval-lower-bound domain (- i 1)))
           (interval-upper-bound domain (- i 1)))
        (lp (+ i 1) (cdr ls) offset count))
       (else
        (let ((dir (if (and (> count 0)
                            (= (+ (car ls) 1)
                               (interval-upper-bound domain (- i 1))))
                       -1
                       1)))
          (set-car! ls (+ (car ls) dir))
          (let* ((offset2 (apply indexer multi-index))
                 (coeff (* dir (- offset2 offset))))
            (cond
             ((> count 0)
              (and (= coeff (vector-ref res i))
                   (lp (+ i 1) (cdr ls) offset2 count)))
             (else
              (vector-set! res i coeff)
              (vector-set! res 0 (- (vector-ref res 0)
                                    (* coeff
                                       (interval-lower-bound domain (- i 1)))))
              (lp (+ i 1) (cdr ls) offset2 count))))))))))

(define (coeffs->indexer coeffs domain)
  (case (vector-length coeffs)
    ((2)
     (let ((a (vector-ref coeffs 0))
           (b (vector-ref coeffs 1)))
       (lambda (x) (+ a (* b x)))))
    ((3)
     (let ((a (vector-ref coeffs 0))
           (b (vector-ref coeffs 1))
           (c (vector-ref coeffs 2)))
       (lambda (x y) (+ a (* b x) (* c y)))))
    ((4)
     (let ((a (vector-ref coeffs 0))
           (b (vector-ref coeffs 1))
           (c (vector-ref coeffs 2))
           (d (vector-ref coeffs 3)))
       (lambda (x y z) (+ a (* b x) (* c y) (* d z)))))
    (else
     (lambda multi-index
       (let ((lim (vector-length coeffs)))
         (let lp ((ls multi-index)
                  (i 1)
                  (res (vector-ref coeffs 0)))
           (cond
            ((null? ls)
             (if (< i lim)
                 (error "multi-index too short for domain" multi-index domain)
                 res))
            ((>= i lim)
             (error "multi-index too long for domain" multi-index domain))
            (else
             (lp (cdr ls)
                 (+ i 1)
                 (+ res (* (car ls) (vector-ref coeffs i))))))))))))

(define (default-coeffs domain)
  (let* ((dim (interval-dimension domain))
         (res (make-vector (+ 1 dim))))
    (vector-set! res 0 0)
    (vector-set! res dim 1)
    (let lp ((i (- dim 1))
             (scale 1))
      (cond
       ((< i 0)
        res)
       ((= (+ 1 (interval-lower-bound domain i))
           (interval-upper-bound domain i))
        (vector-set! res (+ i 1) 0)
        (lp (- i 1) scale))
       (else
        (let ((coeff (* scale  (- (interval-upper-bound domain i)
                                  (interval-lower-bound domain i)))))
          (vector-set! res (+ i 1) scale)
          (vector-set! res 0 (- (vector-ref res 0)
                                (* scale (interval-lower-bound domain i))))
          (lp (- i 1) coeff)))))))

(define (default-indexer domain)
  (coeffs->indexer (default-coeffs domain) domain))

;; Converts the raw integer index to the multi-index in domain that
;; would map to it using the default indexer (i.e. iterating over the
;; possible multi-indices in domain in lexicographic order would
;; produce 0 through volume-1).
(define (invert-default-index domain raw-index)
  (let lp ((index raw-index)
           (i 0)
           (scale (/ (interval-volume domain)
                     (max 1
                          (- (interval-upper-bound domain 0)
                             (interval-lower-bound domain 0)))))
           (res '()))
    (cond
     ((>= (+ i 1) (interval-dimension domain))
      (reverse (cons (+ index (interval-lower-bound domain i)) res)))
     (else
      (let ((digit (quotient index scale)))
        (lp (- index (* digit scale))
            (+ i 1)
            (/ scale
               (max 1
                    (- (interval-upper-bound domain (+ i 1))
                       (interval-lower-bound domain (+ i 1)))))
            (cons (+ digit
                     (interval-lower-bound domain i))
                  res)))))))

;; Specialized arrays

(define (%make-specialized domain storage body coeffs indexer
                           safe? mutable? adjacent?)
  (%make-array
   domain
   (specialized-getter body indexer (storage-class-getter storage))
   (and mutable?
        (specialized-setter body indexer (storage-class-setter storage)))
   storage
   body
   coeffs
   indexer
   safe?
   adjacent?))

(define (make-specialized-array domain . o)
  (let* ((storage (if (pair? o) (car o) generic-storage-class))
         (safe? (if (and (pair? o) (pair? (cdr o)))
                    (cadr o)
                    (specialized-array-default-safe?)))
         (body ((storage-class-maker storage)
                (interval-volume domain)
                (storage-class-default storage)))
         (coeffs (default-coeffs domain))
         (indexer (coeffs->indexer coeffs domain)))
    (assert (boolean? safe?))
    (%make-specialized domain storage body coeffs indexer safe? #t #t)))

(define (specialized-array? x)
  (and (array? x) (array-storage-class x) #t))

(define (compute-array-elements-in-order? array)
  (let ((indexer (array-indexer array)))
    (call-with-current-continuation
     (lambda (return)
       (interval-fold
        (lambda (prev . multi-index)
          (let ((i (apply indexer multi-index)))
            (if (and prev (not (= i (+ prev 1))))
                (return #f)
                i)))
        #f
        (array-domain array))
       #t))))

(define (array-elements-in-order? array)
  (assert (specialized-array? array))
  (let ((res (array-adjacent? array)))
    (when (eq? res 'unknown)
      (set! res (compute-array-elements-in-order? array))
      (array-adjacent?-set! array res))
    res))

(define (specialized-array-share array new-domain project)
  (assert (and (specialized-array? array) (interval? new-domain)))
  (let* ((body (array-body array))
         (coeffs
          (indexer->coeffs
           (lambda multi-index
             (call-with-values
                 (lambda () (apply project multi-index))
               (array-indexer array)))
           new-domain))
         (indexer
          (coeffs->indexer coeffs new-domain))
         (storage (array-storage-class array)))
    (%make-specialized new-domain storage body coeffs indexer
                       (array-safe? array) (array-setter array) 'unknown)))
#|
Adapted from original SRFI reference test suite:

SRFI 179: Nonempty Intervals and Generalized Arrays (Updated)

Copyright 2016, 2018, 2020 Bradley J Lucier.
All Rights Reserved.

Permission is hereby granted, free of charge,
to any person obtaining a copy of this software
and associated documentation files (the "Software"),
to deal in the Software without restriction,
including without limitation the rights to use, copy,
modify, merge, publish, distribute, sublicense,
and/or sell copies of the Software, and to permit
persons to whom the Software is furnished to do so,
subject to the following conditions:

The above copyright notice and this permission notice
(including the next paragraph) shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF
ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
|#

;;; A test program for SRFI 179:
;;; Nonempty Intervals and Generalized Arrays (Updated)

(define-library (srfi 179 test)
  (import (scheme base) (scheme cxr) (scheme complex)
          (scheme file) (scheme list) (scheme read)
          (scheme sort) (scheme vector) (scheme write)
          (chibi test)
          (srfi 27) (srfi 143) (srfi 144) (srfi 160 base) (srfi 179))
  (export run-tests)
  (begin
    ;; Just run 1 pass of the randomized tests.
    ;; TODO: remove all randomized tests.
    (define tests 1)

    (define (random a . b)
      (if (pair? b)
          (+ a (random-integer (- (car b) a)))
          (random-integer a)))

    (define (random-sample n . o)
      (let ((l (if (pair? o) (car o) 4)))
        (list->vector (map (lambda (i)
                             (random 1 l))
                           (iota n)))))

    (define (random-f64vector n)
      (let ((res (make-f64vector n)))
        (do ((i 0 (+ i 1)))
            ((= i n) res)
          (f64vector-set! res i (random-real)))))

    (define (f64vector->list vec)
      (do ((i (- (f64vector-length vec) 1) (- i 1))
           (res '() (cons (f64vector-ref vec i) res)))
          ((< i 0) res)))

    (define (random-permutation n)
      (let ((result (make-vector n)))
        ;; fill it
        (do ((i 0 (fx+ i 1)))
            ((fx=? i n))
          (vector-set! result i i))
        ;; permute it
        (do ((i 0 (fx+ i 1)))
            ((fx=? i n)
             ;;(write `(random-permutation ,n -> ,result)) (newline)
             result)
          (vector-swap! result i (random i n)))))

    (define (inverse-permutation permutation)
      (list->vector
       (map
        car
        (list-sort
         (lambda (a b) (< (cdr a) (cdr b)))
         (map cons
              (iota (vector-length permutation))
              (vector->list permutation))))))

    (define (vector-permute v permutation)
      (let* ((n (vector-length v))
             (result (make-vector n)))
        (do ((i 0 (+ i 1)))
            ((= i n) result)
          (vector-set! result i (vector-ref v (vector-ref permutation i))))))

    (define (in-order < l)
      (or (null? l)
          (null? (cdr l))
          (and (< (car l) (cadr l))
               (in-order < (cdr l)))))

    (define (local-iota a b)
      (if (= a b)
          '()
          (cons a (local-iota (+ a 1) b))))

    (define (all-elements lower upper)
      (if (null? (cdr lower))
          (map list (local-iota (car lower) (car upper)))
          (apply append (map (lambda (x)
                               (map (lambda (y)
                                      (cons x y))
                                    (all-elements (cdr lower) (cdr upper))))
                             (local-iota (car lower) (car upper))))))

    ;; define random-interval, random-multi-index

    (define (random-multi-index interval)
      (apply values
             (apply map
                    random
                    (map (lambda (bounds)
                           (bounds interval))
                         (list interval-lower-bounds->list
                               interval-upper-bounds->list)))))

    (define use-bignum-intervals #f)

    (define (random-interval . o)
      ;; a random interval with min <= dimension < max
      ;; positive and negative lower bounds
      (let* ((min (if (pair? o) (car o) 1))
             (max (if (and (pair? o) (pair? (cdr o))) (cadr o) 4))
             (lower
              (map (lambda (x)
                     (if use-bignum-intervals
                         (random (- (expt 2 90)) (expt 2 90))
                         (random -10 10)))
                   (vector->list (make-vector (random min max)))))
             (upper
              (map (lambda (x)
                     (+ (random 1 8) x))
                   lower)))
        (make-interval (list->vector lower)
                       (list->vector upper))))

    (define (random-subinterval interval)
      (let* ((lowers (interval-lower-bounds->vector interval))
             (uppers (interval-upper-bounds->vector interval))
             (new-lowers (vector-map random lowers uppers))
             (new-uppers (vector-map (lambda (x) (+ x 1))
                                     (vector-map random new-lowers uppers)))
             (subinterval (make-interval new-lowers new-uppers)))
        subinterval))

    (define (random-nonnegative-interval . o)
      ;; a random interval with min <= dimension < max
      (let* ((min (if (pair? o) (car o) 1))
             (max (if (and (pair? o) (pair? (cdr o))) (cadr o) 6))
             (lower
              (make-vector (random min max) 0))
             (upper
              (vector-map (lambda (x) (random 1 7)) lower)))
        (make-interval lower upper)))

    (define (random-positive-vector n . o)
      (let ((max (if (pair? o) (car o) 5)))
        (vector-map (lambda (x)
                      (random 1 max))
                    (make-vector n))))

    (define (random-boolean)
      (zero? (random 2)))

    (define (array-display A)
  
      (define (display-item x)
        (display x) (display "\t"))
  
      (newline)
      (case (array-dimension A)
        ((1) (array-for-each display-item A) (newline))
        ((2) (array-for-each (lambda (row)
                               (array-for-each display-item row)
                               (newline))
                             (array-curry A 1)))
        (else
         (error "array-display can't handle > 2 dimensions: " A))))

    (define (myindexer= indexer1 indexer2 interval)
      (array-fold (lambda (x y) (and x y))
                  #t
                  (make-array interval
                              (lambda args
                                (= (apply indexer1 args)
                                   (apply indexer2 args))))))

    (define (my-indexer base lower-bounds increments)
      (lambda indices
        (apply + base (map * increments (map - indices lower-bounds)))))

    (define (random-sign)
      (- 1 (* 2 (random 2))))

    (define (myarray= array1 array2)
      (and (interval= (array-domain array1)
                      (array-domain array2))
           (array-fold (lambda (vs result)
                         (and (equal? (car vs)
                                      (cadr vs))
                              result))
                       #t
                       (array-map list array1 array2))))

    (define random-storage-class-and-initializer
      (let* ((storage-classes
              (vector
               ;; generic
               (list generic-storage-class
                     (lambda args (random-permutation (length args))))
               ;; signed integer
               (list s8-storage-class
                     (lambda args (random (- (expt 2 7)) (- (expt 2 7) 1))))
               (list s16-storage-class
                     (lambda args (random (- (expt 2 15)) (- (expt 2 15) 1))))
               (list s32-storage-class
                     (lambda args (random (- (expt 2 31)) (- (expt 2 31) 1))))
               (list s64-storage-class
                     (lambda args (random (- (expt 2 63)) (- (expt 2 63) 1))))
               ;; unsigned integer
               (list u1-storage-class
                     (lambda args (random (expt 2 1))))
               (list u8-storage-class
                     (lambda args (random (expt 2 8))))
               (list u16-storage-class
                     (lambda args (random (expt 2 16))))
               (list u32-storage-class
                     (lambda args (random (expt 2 32))))
               (list u64-storage-class
                     (lambda args (random (expt 2 64))))
               ;; float
               (list f32-storage-class
                     (lambda args (random-real)))
               (list f64-storage-class
                     (lambda args (random-real)))
               ;; complex-float
               (list c64-storage-class
                     (lambda args (make-rectangular (random-real) (random-real))))
               (list c128-storage-class
                     (lambda args (make-rectangular (random-real) (random-real))))))
             (n
              (vector-length storage-classes)))
        (lambda ()
          (vector-ref storage-classes (random n)))))

    ;; Elements of extracted arrays of newly created specialized
    ;; arrays are not in order unless
    ;; (1) the differences in the upper and lower bounds of the
    ;;     first dimensions all equal 1 *and*
    ;; (2) the next dimension doesn't matter *and*
    ;; (3) the upper and lower bounds of the latter dimensions
    ;;     of the original and extracted arrays are the same
    ;; Whew!

    (define (extracted-array-elements-in-order? base extracted)
      (let ((base-domain (array-domain base))
            (extracted-domain (array-domain extracted))
            (dim (array-dimension base)))
        (let loop-1 ((i 0))
          (or (= i (- dim 1))
              (or (and (= 1 (- (interval-upper-bound extracted-domain i)
                               (interval-lower-bound extracted-domain i)))
                       (loop-1 (+ i 1)))
                  (let loop-2 ((i (+ i 1)))
                    (or (= i dim)
                        (and (= (interval-upper-bound extracted-domain i)
                                (interval-upper-bound base-domain i))
                             (= (interval-lower-bound extracted-domain i)
                                (interval-lower-bound base-domain i))
                             (loop-2 (+ i 1))))))))))


    ;; A permuted array has elements in order iff all the dimensions with
    ;; sidelength > 1 are in the same order.
    (define (permuted-array-elements-in-order? array permutation)
      (let* ((domain
              (array-domain array))
             (axes-and-limits
              (vector-map list
                          (list->vector (iota (vector-length permutation)))
                          (interval-lower-bounds->vector domain)
                          (interval-upper-bounds->vector domain)))
             (permuted-axes-and-limits
              (vector->list (vector-permute axes-and-limits permutation))))
        (in-order (lambda (x y)
                    (< (car x) (car y)))
                  (filter (lambda (l)
                            (let ((i (car l))
                                  (l (cadr l))
                                  (u (caddr l)))
                              (< 1 (- u l))))
                          permuted-axes-and-limits))))

    ;; a sampled array has elements in order iff after a string of
    ;; dimensions with side-length 1 at the beginning, all the rest
    ;; of the dimensions have sidelengths the same as the original
    (define (sampled-array-elements-in-order? base scales)
      (let* ((domain
              (array-domain base))
             (sampled-base
              (array-sample base scales))
             (scaled-domain
              (array-domain sampled-base))
             (base-sidelengths
              (vector->list
               (vector-map -
                           (interval-upper-bounds->vector domain)
                           (interval-lower-bounds->vector domain))))
             (scaled-sidelengths
              (vector->list
               (vector-map -
                           (interval-upper-bounds->vector scaled-domain)
                           (interval-lower-bounds->vector scaled-domain)))))
        (let loop-1 ((base-lengths   base-sidelengths)
                     (scaled-lengths scaled-sidelengths))
          (or (null? base-lengths)
              (if (= (car scaled-lengths) 1)
                  (loop-1 (cdr base-lengths)
                          (cdr scaled-lengths))
                  (let loop-2 ((base-lengths   base-lengths)
                               (scaled-lengths scaled-lengths))
                    (or (null? base-lengths)
                        (and (= (car base-lengths) (car scaled-lengths))
                             (loop-2 (cdr base-lengths)
                                     (cdr scaled-lengths))))))))))

    (define (multi-index< ind1 ind2)
      (and (not (null? ind1))
           (not (null? ind2))
           (or (< (car ind1)
                  (car ind2))
               (and (= (car ind1)
                       (car ind2))
                    (multi-index< (cdr ind1)
                                  (cdr ind2))))))

    (define (indices-in-proper-order l)
      (or (null? l)
          (null? (cdr l))
          (and (multi-index< (car l)
                             (cadr l))
               (indices-in-proper-order (cdr l)))))

    ;; OK, how to test array-reduce?

    ;; Well, we take an associative, non-commutative operation,
    ;; multiplying 2x2 matrices, with data such that doing operations
    ;; in the opposite order gives the wrong answer, doing it for the
    ;; wrong interval (e.g., swapping axes) gives the wrong answer.

    ;; This is not in the same style as the other tests, which use random
    ;; data to a great extent, but I couldn't see how to choose random
    ;; data that would satisfy the constraints.

    (define matrix vector)

    (define (x2x2-multiply A B)
      (let ((a_11 (vector-ref A 0)) (a_12 (vector-ref A 1))
            (a_21 (vector-ref A 2)) (a_22 (vector-ref A 3))
            (b_11 (vector-ref B 0)) (b_12 (vector-ref B 1))
            (b_21 (vector-ref B 2)) (b_22 (vector-ref B 3)))
        (vector (+ (* a_11 b_11) (* a_12 b_21))
                (+ (* a_11 b_12) (* a_12 b_22))
                (+ (* a_21 b_11) (* a_22 b_21))
                (+ (* a_21 b_12) (* a_22 b_22)))))

    (define (my-array-translate Array translation)
      (let* ((array-copy (array-copy Array))
             (getter (array-getter array-copy))
             (setter (array-setter array-copy)))
        (make-array (interval-translate (array-domain Array)
                                        translation)
                    (lambda args
                      (apply getter
                             (map - args (vector->list translation))))
                    (lambda (v . args)
                      (apply setter
                             v
                             (map - args (vector->list translation)))))))

    (define (my-array-permute Array permutation)
      (let* ((array-copy (array-copy Array))
             (getter (array-getter array-copy))
             (setter (array-setter array-copy))
             (permutation-inverse (inverse-permutation permutation)))
        (make-array (interval-permute (array-domain Array)
                                      permutation)
                    (lambda args
                      (apply getter
                             (vector->list
                              (vector-permute (list->vector args)
                                              permutation-inverse))))
                    (lambda (v . args)
                      (apply setter
                             v
                             (vector->list
                              (vector-permute (list->vector args)
                                              permutation-inverse)))))))

    (define (my-interval-intersect . args)
      (define (fold-left operator ;; called with (op result-so-far (car list))
                         initial-value
                         list)
        (if (null? list)
            initial-value
            (fold-left operator
                       (operator initial-value (car list))
                       (cdr list))))
      (let ((new-uppers
             (let ((uppers (map interval-upper-bounds->vector args)))
               (fold-left (lambda (arg result)
                            (vector-map min arg result))
                          (car uppers)
                          uppers)))
            (new-lowers (let ((lowers (map interval-lower-bounds->vector args)))
                          (fold-left (lambda (arg result)
                                       (vector-map max arg result))
                                     (car lowers)
                                     lowers))))
        (and (vector-every < new-lowers new-uppers)
             (make-interval new-lowers new-uppers))))

    (define (my-interval-scale interval scales)
      (make-interval (interval-lower-bounds->vector interval)
                     (vector-map (lambda (u s)
                                   (quotient (+ u s -1) s))
                                 (interval-upper-bounds->vector interval)
                                 scales)))

    (define sparse-array
      (let ((domain (make-interval '#(1000000 1000000)))
            (sparse-rows (make-vector 1000000 '())))
        (make-array
         domain
         (lambda (i j)
           (cond ((assv j (vector-ref sparse-rows i))
                  => cdr)
                 (else
                  0.0)))
         (lambda (v i j)
           (cond
            ((assv j (vector-ref sparse-rows i))
             => (lambda (pair)
                  (set-cdr! pair v)))
            (else
             (vector-set! sparse-rows i (cons (cons j v)
                                              (vector-ref sparse-rows i)))))))))

    (define (myarray-sample array scales)
      (let ((scales-list (vector->list scales)))
        (cond ((specialized-array? array)
               (specialized-array-share
                array
                (interval-scale (array-domain array) scales)
                (lambda multi-index
                  (apply values (map * multi-index scales-list)))))
              ((mutable-array? array)
               (let ((getter (array-getter array))
                     (setter (array-setter array)))
                 (make-array
                  (interval-scale (array-domain array) scales)
                  (lambda multi-index
                    (apply getter (map * multi-index scales-list)))
                  (lambda (v . multi-index)
                    (apply setter v (map * multi-index scales-list))))))
              (else
               (let ((getter (array-getter array)))
                 (make-array
                  (interval-scale (array-domain array) scales)
                  (lambda multi-index
                    (apply getter (map * multi-index scales-list)))))))))

    (define (ceiling-quotient x d)
      ;; assumes x and d are positive
      (quotient (+ x d -1) d))

    (define (my-array-tile array sidelengths)
      ;; an alternate definition more-or-less from the srfi document
      (let* ((domain
              (array-domain array))
             (lowers
              (interval-lower-bounds->vector domain))
             (uppers
              (interval-upper-bounds->vector domain))
             (result-lowers
              (vector-map (lambda (x)
                            0)
                          lowers))
             (result-uppers
              (vector-map (lambda (l u s)
                            (ceiling-quotient (- u l) s))
                          lowers uppers sidelengths)))
        (make-array
         (make-interval result-lowers result-uppers)
         (lambda i
           (let* ((vec-i
                   (list->vector i))
                  (result-lowers
                   (vector-map (lambda (l i s)
                                 (+ l (* i s)))
                               lowers vec-i sidelengths))
                  (result-uppers
                   (vector-map (lambda (l u i s)
                                 (min u (+ l (* (+ i 1) s))))
                               lowers uppers vec-i sidelengths)))
             (array-extract array
                            (make-interval result-lowers result-uppers)))))))

    (define (myarray-reverse array flip?)
      (let* ((flips (vector->list flip?))
             (domain (array-domain array))
             (lowers (interval-lower-bounds->list domain))
             (uppers (interval-upper-bounds->list domain))
             (transform
              (lambda (multi-index)
                (map (lambda (i_k l_k u_k f_k?)
                       (if f_k?
                           (- (+ u_k l_k -1) i_k)
                           i_k))
                     multi-index lowers uppers flips))))
        (cond ((specialized-array? array)
               (specialized-array-share
                array
                domain
                (lambda multi-index
                  (apply values (transform multi-index)))))
              ((mutable-array? array)
               (let ((getter (array-getter array))
                     (setter (array-setter array)))
                 (make-array domain
                             (lambda multi-index
                               (apply getter (transform multi-index)))
                             (lambda (v . multi-index)
                               (apply setter v (transform multi-index))))))
              (else
               (let ((getter (array-getter array)))
                 (make-array domain
                             (lambda multi-index
                               (apply getter (transform multi-index)))))))))

    (define (my-interval-cartesian-product . args)
      (make-interval
       (list->vector (apply append (map interval-lower-bounds->list args)))
       (list->vector (apply append (map interval-upper-bounds->list args)))))

    (define make-pgm   cons)
    (define pgm-greys  car)
    (define pgm-pixels cdr)

    (define (read-pgm file)
      (define (read-pgm-object port)
        (skip-white-space port)
        (let ((o (read port)))
          (read-char port)    ; to skip the newline or next whitespace
          (if (eof-object? o)
              (error "reached end of pgm file")
              o)))
      (define (skip-to-end-of-line port)
        (let loop ((ch (read-char port)))
          (if (not (eq? ch #\newline))
              (loop (read-char port)))))
      (define (white-space? ch)
        (case ch
          ((#\newline #\space #\tab) #t)
          (else #f)))
      (define (skip-white-space port)
        (let ((ch (peek-char port)))
          (cond ((white-space? ch) (read-char port) (skip-white-space port))
                ((eq? ch #\#) (skip-to-end-of-line port)(skip-white-space port))
                (else #f))))
      (call-with-input-file file
        (lambda (port)
          ;; We're going to read text for a while,
          ;; then switch to binary.
          ;; So we need to turn off buffering until
          ;; we switch to binary.
          ;;(port-settings-set! port '(buffering: #f))
          (let* ((header (read-pgm-object port))
                 (columns (read-pgm-object port))
                 (rows (read-pgm-object port))
                 (greys (read-pgm-object port)))

            ;; now we switch back to buffering
            ;; to speed things up
            ;; (port-settings-set! port '(buffering: #t))
            (make-pgm greys
                      (array-copy
                       (make-array
                        (make-interval (vector rows columns))
                        (cond ((or (eq? header 'p5) ;; pgm binary
                                   (eq? header 'P5))
                               (if (< greys 256)
                                   (lambda (i j) ;; one byte/pixel
                                     (char->integer (read-char port)))
                                   (lambda (i j) ;; two bytes/pixel, little-endian
                                     (let* ((first-byte
                                             (char->integer (read-char port)))
                                            (second-byte
                                             (char->integer (read-char port))))
                                       (+ (* second-byte 256) first-byte)))))
                              ((or (eq? header 'p2) ;; pgm ascii
                                   (eq? header 'P2))
                               (lambda (i j)
                                 (read port)))
                              (else
                               (error "read-pgm: not a pgm file"))))))))))

    (define (write-pgm pgm-data file . force-ascii)
      (call-with-output-file file
        (lambda (port)
          (let* ((greys
                  (pgm-greys pgm-data))
                 (pgm-array
                  (pgm-pixels pgm-data))
                 (domain
                  (array-domain pgm-array))
                 (rows
                  (fx- (interval-upper-bound domain 0)
                       (interval-lower-bound domain 0)))
                 (columns
                  (fx- (interval-upper-bound domain 1)
                       (interval-lower-bound domain 1))))
            (if (and (pair? force-ascii) (car force-ascii))
                (display "P2" port)
                (display "P5" port))
            (newline port)
            (display columns port) (display " " port)
            (display rows port) (newline port)
            (display greys port) (newline port)
            (array-for-each
             (if (and (pair? force-ascii) (car force-ascii))
                 (let ((next-pixel-in-line 1))
                   (lambda (p)
                     (write p port)
                     (if (fxzero? (fxand next-pixel-in-line 15))
                         (begin
                           (newline port)
                           (set! next-pixel-in-line 1))
                         (begin
                           (display " " port)
                           (set! next-pixel-in-line
                                 (fx+ 1 next-pixel-in-line))))))
                 (if (fx<? greys 256)
                     (lambda (p)
                       (write-u8 p port))
                     (lambda (p)
                       (write-u8 (fxand p 255) port)
                       (write-u8 (fxarithmetic-shift-right p 8) port))))
             pgm-array)))))

    ;;(define test-pgm (read-pgm "girl.pgm"))

    (define (array-dot-product a b)
      (array-fold (lambda (x y)
                    (+ x y))
                  0
                  (array-map
                   (lambda (x y)
                     (* x y))
                   a b)))

    (define (array-convolve source filter)
      (let* ((source-domain
              (array-domain source))
             (S_
              (array-getter source))
             (filter-domain
              (array-domain filter))
             (F_
              (array-getter filter))
             (result-domain
              (interval-dilate
               source-domain
               ;; left bound of an interval is an equality,
               ;; right bound is an inequality, hence the
               ;; the difference in the following two expressions
               (vector-map -
                           (interval-lower-bounds->vector filter-domain))
               (vector-map (lambda (x)
                             (- 1 x))
                           (interval-upper-bounds->vector filter-domain)))))
        (make-array
         result-domain
         (lambda (i j)
           (array-fold
            (lambda (p q)
              (+ p q))
            0
            (make-array
             filter-domain
             (lambda (k l)
               (* (S_ (+ i k)
                      (+ j l))
                  (F_ k l)))))))))

    ;; (define sharpen-filter
    ;;   (list->array
    ;;    '(0 -1  0
    ;;        -1  5 -1
    ;;        0 -1  0)
    ;;    (make-interval '#(-1 -1) '#(2 2))))

    ;; (define edge-filter
    ;;   (list->array
    ;;    '(0 -1  0
    ;;        -1  4 -1
    ;;        0 -1  0)
    ;;    (make-interval '#(-1 -1) '#(2 2))))

    (define (round-and-clip pixel max-grey)
      (max 0 (min (exact (round pixel)) max-grey)))

    (define (array-sum a)
      (array-fold + 0 a))
    (define (array-max a)
      (array-fold max -inf.0 a))

    (define (max-norm a)
      (array-max (array-map abs a)))
    (define (one-norm a)
      (array-sum (array-map abs a)))

    (define (operator-max-norm a)
      (max-norm (array-map one-norm (array-curry (array-permute a '#(1 0)) 1))))
    (define (operator-one-norm a)
      ;; The "permutation" to apply here is the identity, so we omit it.
      (max-norm (array-map one-norm (array-curry a 1))))

    (define (make-separable-transform ~1D-transform)
      (lambda (a)
        (let ((n (array-dimension a)))
          (do ((d 0 (fx+ d 1)))
              ((fx=? d n))
            (array-for-each
             ~1D-transform
             (array-curry (array-rotate a d) 1))))))

    (define (recursively-apply-transform-and-downsample transform)
      (lambda (a)
        (let ((sample-vector (make-vector (array-dimension a) 2)))
          (define (helper a)
            (if (fx<? 1 (interval-upper-bound (array-domain a) 0))
                (begin
                  (transform a)
                  (helper (array-sample a sample-vector)))))
          (helper a))))

    (define (recursively-downsample-and-apply-transform transform)
      (lambda (a)
        (let ((sample-vector (make-vector (array-dimension a) 2)))
          (define (helper a)
            (if (fx<? 1 (interval-upper-bound (array-domain a) 0))
                (begin
                  (helper (array-sample a sample-vector))
                  (transform a))))
          (helper a))))

    (define (~1D-Haar-loop a)
      (let ((a_ (array-getter a))
            (a! (array-setter a))
            (n (interval-upper-bound (array-domain a) 0)))
        (do ((i 0 (fx+ i 2)))
            ((fx=? i n))
          (let* ((a_i               (a_ i))
                 (a_i+1             (a_ (fx+ i 1)))
                 (scaled-sum        (fl/ (fl+ a_i a_i+1) (flsqrt 2.0)))
                 (scaled-difference (fl/ (fl- a_i a_i+1) (flsqrt 2.0))))
            (a! scaled-sum i)
            (a! scaled-difference (fx+ i 1))))))

    (define ~1D-Haar-transform
      (recursively-apply-transform-and-downsample ~1D-Haar-loop))

    (define ~1D-Haar-inverse-transform
      (recursively-downsample-and-apply-transform ~1D-Haar-loop))

    (define hyperbolic-Haar-transform
      (make-separable-transform ~1D-Haar-transform))

    (define hyperbolic-Haar-inverse-transform
      (make-separable-transform ~1D-Haar-inverse-transform))

    (define Haar-transform
      (recursively-apply-transform-and-downsample
       (make-separable-transform ~1D-Haar-loop)))

    (define Haar-inverse-transform
      (recursively-downsample-and-apply-transform
       (make-separable-transform ~1D-Haar-loop)))

    (define (LU-decomposition A)
      ;; Assumes the domain of A is [0,n)\\times [0,n)
      ;; and that Gaussian elimination can be applied
      ;; without pivoting.
      (let ((n
             (interval-upper-bound (array-domain A) 0))
            (A_
             (array-getter A)))
        (do ((i 0 (fx+ i 1)))
            ((= i (fx- n 1)) A)
          (let* ((pivot
                  (A_ i i))
                 (column/row-domain
                  ;; both will be one-dimensional
                  (make-interval (vector (+ i 1))
                                 (vector n)))
                 (column
                  ;; the column below the (i,i) entry
                  (specialized-array-share A
                                           column/row-domain
                                           (lambda (k)
                                             (values k i))))
                 (row
                  ;; the row to the right of the (i,i) entry
                  (specialized-array-share A
                                           column/row-domain
                                           (lambda (k)
                                             (values i k))))
                 ;; the subarray to the right and
                 ;;below the (i,i) entry
                 (subarray
                  (array-extract
                   A (make-interval
                      (vector (fx+ i 1) (fx+ i 1))
                      (vector n         n)))))
            ;; compute multipliers
            (array-assign!
             column
             (array-map (lambda (x)
                          (/ x pivot))
                        column))
            ;; subtract the outer product of i'th
            ;; row and column from the subarray
            (array-assign!
             subarray
             (array-map -
                        subarray
                        (array-outer-product * column row)))))))

    ;; We'll define a brief, not-very-efficient matrix multiply routine.
    (define (matrix-multiply a b)
      (let ((a-rows
             ;; We copy this array because its elements are accessed
             ;; multiple times.
             (array-copy (array-curry a 1)))
            (b-columns
             ;; We copy this array because its elements are accessed
             ;; multiple times.
             (array-copy (array-curry (array-rotate b 1) 1))))
        (array-outer-product array-dot-product a-rows b-columns)))

    (define (inner-product A f g B)
      (array-outer-product
       (lambda (a b)
         (array-reduce f (array-map g a b)))
       (array-copy (array-curry A 1))
       (array-copy (array-curry (array-rotate B 1) 1))))

    (define (x2x2-matrix-multiply-into! A B C)
      (let ((C! (array-setter C))
            (A_ (array-getter A))
            (B_ (array-getter B)))
        (C! (+ (* (A_ 0 0) (B_ 0 0))
               (* (A_ 0 1) (B_ 1 0)))
            0 0)
        (C! (+ (* (A_ 0 0) (B_ 0 1))
               (* (A_ 0 1) (B_ 1 1)))
            0 1)
        (C! (+ (* (A_ 1 0) (B_ 0 0))
               (* (A_ 1 1) (B_ 1 0)))
            1 0)
        (C! (+ (* (A_ 1 0) (B_ 0 1))
               (* (A_ 1 1) (B_ 1 1)))
            1 1)))

    (define (run-tests)

      (random-source-pseudo-randomize! default-random-source 7 23)

      (test-begin "srfi-179: nonempty intervals and generalized arrays")

      (test-group "interval tests"
        (test-error (make-interval 1 '#(3 4)))
        (test-error (make-interval '#(1 1)  3))
        (test-error (make-interval '#(1 1)  '#(3)))
        (test-error (make-interval '#()  '#()))
        (test-error (make-interval '#(1.)  '#(1)))
        (test-error (make-interval '#(1 #f)  '#(1 2)))
        (test-error (make-interval '#(1)  '#(1.)))
        (test-error (make-interval '#(1 1)  '#(1 #f)))
        (test-error (make-interval '#(1)  '#(1)))
        (test-error (make-interval '#(1 2 3)  '#(4 2 6)))
        (test-error (make-interval 1))
        (test-error (make-interval '#()))
        (test-error (make-interval '#(1.)))
        (test-error (make-interval '#(-1)))

        (test (make-interval '#(11111)  '#(11112))
            (make-interval '#(11111) '#(11112)))

        (test (make-interval '#(1 2 3)  '#(4 5 6))
            (make-interval '#(1 2 3) '#(4 5 6)))

        (test-not (interval? #t))

        (test-assert (interval? (make-interval '#(1 2 3) '#(4 5 6))))

        (test-error (interval-dimension 1))

        (test 3
            (interval-dimension (make-interval '#(1 2 3) '#(4 5 6))))

        (test-error
         (interval-lower-bound 1 0))
        (test-error
         (interval-lower-bound (make-interval '#(1 2 3) '#(4 5 6)) #f))
        (test-error
         (interval-lower-bound (make-interval '#(1 2 3) '#(4 5 6)) 1.))
        (test-error
         (interval-lower-bound (make-interval '#(1 2 3) '#(4 5 6)) -1))
        (test-error
         (interval-lower-bound (make-interval '#(1 2 3) '#(4 5 6)) 3))
        (test-error
         (interval-lower-bound (make-interval '#(1 2 3) '#(4 5 6)) 4))
        (test-error
         (interval-upper-bound 1 0))
        (test-error
         (interval-upper-bound (make-interval '#(1 2 3) '#(4 5 6)) #f))
        (test-error
         (interval-upper-bound (make-interval '#(1 2 3) '#(4 5 6)) 1.))
        (test-error
         (interval-upper-bound (make-interval '#(1 2 3) '#(4 5 6)) -1))
        (test-error
         (interval-upper-bound (make-interval '#(1 2 3) '#(4 5 6)) 3))
        (test-error
         (interval-upper-bound (make-interval '#(1 2 3) '#(4 5 6)) 4))
        (test-error
         (interval-lower-bounds->list 1))
        (test-error
         (interval-upper-bounds->list #f))

        (do ((i 0 (+ i 1)))
            ((= i tests))
          (let* ((lower (map (lambda (x) (random 10))
                             (vector->list (make-vector (random 1 11)))))
                 (upper (map (lambda (x) (+ (random 1 11) x))
                             lower)))
            (let ((interval (make-interval (list->vector lower)
                                           (list->vector upper)))
                  (offset (random (length lower))))
              (test (list-ref lower offset)
                  (interval-lower-bound interval offset))
              (test (list-ref upper offset)
                  (interval-upper-bound interval offset))
              (test lower
                  (interval-lower-bounds->list interval))
              (test upper
                  (interval-upper-bounds->list interval)))))

        (test-error (interval-lower-bounds->vector 1))
        (test-error (interval-upper-bounds->vector #f))

        (do ((i 0 (+ i 1)))
            ((= i tests))
          (let* ((lower (map (lambda (x) (random 10))
                             (vector->list (make-vector (random 1 11)))))
                 (upper (map (lambda (x) (+ (random 1 11) x))
                             lower)))
            (let ((interval (make-interval (list->vector lower)
                                           (list->vector upper)))
                  (offset (random (length lower))))
              (test (list-ref lower offset)
                  (interval-lower-bound interval offset))
              (test (list-ref upper offset)
                  (interval-upper-bound interval offset))
              (test (list->vector lower)
                  (interval-lower-bounds->vector interval))
              (test (list->vector upper)
                  (interval-upper-bounds->vector interval)))))

        (test-error (interval-projections 1 1))
        (test-error (interval-projections (make-interval '#(0) '#(1)) #t))
        (test-error (interval-projections (make-interval '#(0 0) '#(1 1)) 1/2))
        (test-error (interval-projections (make-interval '#(0 0) '#(1 1)) 1.))
        (test-error (interval-projections (make-interval '#(0 0) '#(1 1)) 0))
        (test-error (interval-projections (make-interval '#(0 0) '#(1 1)) 2))

        (do ((i 0 (+ i 1)))
            ((= i tests))
          (let* ((lower (map (lambda (x) (random 10))
                             (vector->list (make-vector (random 3 11)))))
                 (upper (map (lambda (x) (+ (random 1 11) x))
                             lower))
                 (left-dimension (random 1 (- (length lower) 1)))
                 (right-dimension (- (length lower) left-dimension)))
            (test-values
             (interval-projections (make-interval (list->vector lower)
                                                  (list->vector upper))
                                   right-dimension)
             (values
              (make-interval (list->vector (take lower right-dimension))
                             (list->vector (take upper right-dimension)))
              (make-interval (list->vector (drop lower right-dimension))
                             (list->vector (drop upper right-dimension))))
             )))

        (test-error (interval-volume #f))

        (do ((i 0 (+ i 1)))
            ((= i tests))
          (let* ((lower (map (lambda (x) (random 10))
                             (vector->list (make-vector (random 1 11)))))
                 (upper (map (lambda (x) (+ (random 1 11) x))
                             lower)))
            (test (apply * (map - upper lower))
                (interval-volume (make-interval (list->vector lower)
                                                (list->vector upper))))))

        (test-error (interval= #f (make-interval '#(1 2 3) '#(4 5 6))))
        (test-error (interval= (make-interval '#(1 2 3) '#(4 5 6)) #f))

        (do ((i 0 (+ i 1)))
            ((= i tests))
          (let* ((lower1 (map (lambda (x) (random 2))
                              (vector->list (make-vector (random 1 6)))))
                 (upper1 (map (lambda (x) (+ (random 1 3) x)) lower1))
                 (lower2 (map (lambda (x) (random 2)) lower1))
                 (upper2 (map (lambda (x) (+ 1 (random 1 3) x)) lower2)))
            (test (and (equal? lower1 lower2) ; prob ~1/16
                       (equal? upper1 upper2))
                (interval= (make-interval (list->vector lower1)
                                          (list->vector upper1))
                           (make-interval (list->vector lower2)
                                          (list->vector upper2))))))

        (test-error (interval-subset? #f (make-interval '#(1 2 3) '#(4 5 6))))
        (test-error (interval-subset? (make-interval '#(1 2 3) '#(4 5 6)) #f))
        (test-error (interval-subset? (make-interval '#(1) '#(2))
                                      (make-interval '#(0 0) '#(1 2))))

        (do ((i 0 (+ i 1)))
            ((= i tests))
          (let* ((lower1 (map (lambda (x) (random 2))
                              (vector->list (make-vector (random 1 6)))))
                 (upper1 (map (lambda (x) (+ (random 1 3) x)) lower1))
                 (lower2 (map (lambda (x) (random 2)) lower1))
                 (upper2 (map (lambda (x) (+ (random 1 3) x)) lower2)))
            (test (and (every (lambda (x) (>= (car x) (cdr x)))
                              (map cons lower1 lower2))
                       (every (lambda (x) (<= (car x) (cdr x)))
                              (map cons upper1 upper2)))
                (interval-subset? (make-interval (list->vector lower1)
                                                 (list->vector upper1))
                                  (make-interval (list->vector lower2)
                                                 (list->vector upper2))))))

        (test-error (interval-contains-multi-index? 1 1))
        (test-error (interval-contains-multi-index?
                     (make-interval '#(1 2 3) '#(4 5 6)) 1))
        (test-error (interval-contains-multi-index?
                     (make-interval '#(1 2 3) '#(4 5 6)) 1 1/2 0.1))

        (let ((interval   (make-interval '#(1 2 3) '#(4 5 6)))
              (interval-2 (make-interval '#(10 11 12) '#(13 14 15))))
          (test-assert
              (array-every
               (lambda (x)
                 (apply interval-contains-multi-index? interval x))
               (make-array interval list)))
          (test-assert
              (array-every
               (lambda (x)
                 (not (apply interval-contains-multi-index? interval x)))
               (make-array interval-2 list))))

        (test-error (interval-for-each (lambda (x) x) 1))
        (test-error (interval-for-each 1 (make-interval '#(3) '#(4))))

        (do ((i 0 (+ i 1)))
            ((= i tests))
          (let* ((lower (map (lambda (x) (random 10))
                             (vector->list (make-vector (random 1 7)))))
                 (upper (map (lambda (x) (+ (random 1 4) x))
                             lower)))
            (let ((result '()))
              (define (f . args)
                (set! result (cons args result)))
              (test (reverse (all-elements lower upper))
                  (begin
                    (interval-for-each f
                                       (make-interval (list->vector lower)
                                                      (list->vector upper)))
                    result)))))

        (let ((interval (make-interval '#(0 0) '#(100 100))))
          (test-error (interval-dilate interval 'a '#(-10 10)))
          (test-error (interval-dilate 'a '#(10 10) '#(-10 -10)))
          (test-error (interval-dilate interval '#(10 10) 'a))
          (test-error (interval-dilate interval '#(10) '#(-10 -10)))
          (test-error (interval-dilate interval '#(10 10) '#( -10)))
          (test-error (interval-dilate interval '#(100 100) '#(-100 -100))))
        )

      (test-group "basic"
        (test-error (make-array 1 values))
        (test-error (make-array (make-interval '#(3) '#(4)) 1))

        ;; (let ((getter (lambda args 1.)))
        ;;   (test (make-array (make-interval '#(3) '#(4)) getter)
        ;;       (make-%%array (make-interval '#(3) '#(4))
        ;;                     getter
        ;;                     #f
        ;;                     #f
        ;;                     #f
        ;;                     #f
        ;;                     #f
        ;;                     %%order-unknown)))

        (test-error (array-domain #f))
        (test-error (array-getter #f))

        (let* ((getter (lambda args 1.))
               (array    (make-array (make-interval '#(3) '#(4)) getter)))
          (test-not (array? #f))
          (test-assert (array? array))
          (test (make-interval '#(3) '#(4))
              (array-domain array))
          (test getter
              (array-getter array)))

        ;; (let ((result #f))
        ;;   (let ((getter (lambda (i) result))
        ;;         (setter   (lambda (v i) (set! result v)))
        ;;         (domain   (make-interval '#(3) '#(4))))
        ;;     (test (make-array domain
        ;;                       getter
        ;;                       setter)
        ;;         (make-%%array domain
        ;;                       getter
        ;;                       setter
        ;;                       #f
        ;;                       #f
        ;;                       #f
        ;;                       #f
        ;;                       %%order-unknown))))

        (test-error (array-setter #f))

        (let ((result (cons #f #f)))
          (let ((getter (lambda (i) (car result)))
                (setter   (lambda (v i) (set-car! result v)))
                (domain   (make-interval '#(3) '#(4))))
            (let ((array (make-array domain
                                     getter
                                     setter)))
              (test-assert (array? array))
              (test-assert (mutable-array? array))
              (test-not (mutable-array? 1))
              (test setter
                  (array-setter array))
              (test getter
                  (array-getter array))
              (test domain
                  (array-domain array)))))

        ;; (do ((i 0 (+ i 1)))
        ;;     ((= i tests))
        ;;   (let* ((lower-bounds
        ;;           (map (lambda (x) (random 2))
        ;;                (vector->list (make-vector (random 1 7)))))
        ;;          (upper-bounds
        ;;           (map (lambda (x) (+ x (random 1 3)))
        ;;                lower-bounds))
        ;;          (new-domain
        ;;           (make-interval (list->vector lower-bounds)
        ;;                          (list->vector upper-bounds)))
        ;;          (new-domain-dimension
        ;;           (interval-dimension new-domain))
        ;;          (old-domain-dimension
        ;;           (random 1 7))
        ;;          (base
        ;;           (random 100))
        ;;          (coefficients
        ;;           (map (lambda (x) (* (random-sign)
        ;;                           (random 20)))
        ;;                (local-iota 0 old-domain-dimension)))
        ;;          (old-indexer
        ;;           (lambda args
        ;;             (apply + base (map * args coefficients))))
        ;;          (new-domain->old-domain-coefficients
        ;;           (map (lambda (x)
        ;;                  (map (lambda (x) (* (random-sign) (random 10)))
        ;;                       (local-iota 0 new-domain-dimension)))
        ;;                (local-iota 0 old-domain-dimension)))
        ;;          (new-domain->old-domain
        ;;           (lambda args
        ;;             (apply values (map (lambda (row)
        ;;                                  (apply + (map * row args)))
        ;;                                new-domain->old-domain-coefficients)))))
        ;;     (if (not (and (myindexer=
        ;;                    (lambda args
        ;;                      (call-with-values
        ;;                          (lambda () (apply new-domain->old-domain args))
        ;;                        old-indexer))
        ;;                    (%%compose-indexers old-indexer new-domain
        ;;                                        new-domain->old-domain)
        ;;                    new-domain)))
        ;;         (error (list new-domain
        ;;                      old-domain-dimension
        ;;                      base
        ;;                      coefficients
        ;;                      new-domain->old-domain-coefficients))
        ;;         )))

        ;; errors are not required to signal
        ;; (let ((a (make-array (make-interval '#(0 0) '#(1 1)) ;; not valid
        ;;                      values
        ;;                      values)))
        ;;   (test-error (array-body a))
        ;;   (test-error (array-indexer a))
        ;;   (test-error (array-storage-class a))
        ;;   (test-error (array-safe? a)))

        (test-error (make-specialized-array  'a))
        (test-error (make-specialized-array (make-interval '#(0) '#(10)) 'a))
        (test-error (make-specialized-array
                     (make-interval '#(0) '#(10))
                     generic-storage-class
                     'a))

        ;; We'll use specialized arrays with u1-storage-class---we never
        ;; use the array contents, just the indexers, and it saves storage.

        (test-error (array-elements-in-order? 1))
        (test-error (array-elements-in-order?
                     (make-array (make-interval '#(1 2)) list)))
        (test-error (array-elements-in-order?
                     (make-array (make-interval '#(1 2)) list list)))

        ;; all these are true, we'll have to see how to screw it up later.
        ;; (do ((i 0 (+ i 1)))
        ;;     ((= i tests))
        ;;   (let ((array
        ;;          (make-specialized-array (random-interval)
        ;;                                  u1-storage-class)))
        ;;     (test-assert (array-elements-in-order? array))))

        (let ((array
               (make-specialized-array (make-interval '#(0 0) '#(2 3)))))
          (test 2 (array-dimension array))
          (test 6 (interval-volume (array-domain array)))
          (do ((i 0 (+ i 1)))
              ((= i 2))
            (do ((j 0 (+ j 1)))
                ((= j 3))
              (array-set! array (+ j (* i 3)) i j)
              (test (+ j (* i 3))
                  (array-ref array i j)))))

        (let ((array
               (make-specialized-array (make-interval '#(-2 -1 3) '#(0 2 5)))))
          (test 3 (array-dimension array))
          (test 12 (interval-volume (array-domain array)))
          (do ((i -2 (+ i 1)))
              ((= i 0))
            (do ((j -1 (+ j 1)))
                ((= j 2))
              (do ((k 3 (+ k 1)))
                  ((= k 5))
                (let ((cell (+ k (* 2 (+ j (* i 3))))))
                  (array-set! array cell i j k)
                  (test cell (array-ref array i j k)))))))

        ;; the elements of curried arrays are in order
        (do ((i 0 (+ i 1)))
            ((= i tests))
          (let* ((base
                  (make-specialized-array (random-interval 2 5)
                                          u1-storage-class))
                 (curried
                  (array-curry base (random 1 (array-dimension base)))))
            (test-assert (array-every array-elements-in-order? curried))))

        (do ((i 0 (+ i 1)))
            ((= i tests))
          (let* ((base
                  (make-specialized-array (random-interval 2 6)
                                          u1-storage-class))
                 (extracted
                  (array-extract base (random-subinterval (array-domain base)))))
            (test (array-elements-in-order? extracted)
                (extracted-array-elements-in-order? base extracted))))

        ;; Should we do reversed now?
        (do ((i 0 (+ i 1)))
            ((= i tests))
          (let* ((base
                  (make-specialized-array (random-interval)
                                          u1-storage-class))
                 (domain
                  (array-domain base))
                 (reversed-dimensions
                  (vector-map (lambda args (random-boolean))
                              (make-vector (array-dimension base))))
                 (reversed
                  (array-reverse base reversed-dimensions)))
            (test (vector-every
                   (lambda (lower upper reversed?)
                     (or (= (+ 1 lower) upper) ;; side-length 1
                         (not reversed?))) ;; dimension not reversed
                   (interval-lower-bounds->vector domain)
                   (interval-upper-bounds->vector domain)
                   reversed-dimensions)
                (array-elements-in-order? reversed))))

        ;; permutations

        (do ((i 0 (+ i 1)))
            ((= i tests))
          (let* ((base
                  (make-specialized-array (random-interval)
                                          u1-storage-class))
                 (domain
                  (array-domain base))
                 (permutation
                  (random-permutation (array-dimension base)))
                 (permuted
                  (array-permute base permutation)))
            (test (permuted-array-elements-in-order? base permutation)
                (array-elements-in-order? permuted))))

        (do ((i 0 (+ i 1)))
            ((= i tests))
          (let* ((base
                  (make-specialized-array (random-nonnegative-interval 1 6)
                                          u1-storage-class))
                 (scales
                  (random-positive-vector (array-dimension base) 4))
                 (sampled
                  (array-sample base scales)))
            (test (sampled-array-elements-in-order? base scales)
                (array-elements-in-order? sampled))))

        ;; Now we need to test the precomputation and caching of
        ;; array-elements-in-order?
        ;; The only places we precompute are
        ;; 1.  after creating a new specialized array
        ;; 2.  in %%specialized-array-translate
        ;; 3.  in %%specialized-array-curry
        ;; 4.  reshaping a specialized array in place.
        ;; So we need to check these situations.

        ;; (let ((array (array-copy (make-array (make-interval '#(3 5)) list))))
        ;;   (test-assert (and (array-elements-in-order? array)
        ;;                     (%%compute-array-elements-in-order?
        ;;                      (%%array-domain array) (%%array-indexer array)))))

        ;; (do ((i 0 (+ i 1)))
        ;;     ((= i tests))
        ;;   (let* ((array
        ;;           (make-specialized-array (random-nonnegative-interval)
        ;;                                   u8-storage-class))
        ;;          (ignore ;; compute and cache the results
        ;;           (array-elements-in-order? array))
        ;;          (sampled-array
        ;;           (array-sample array (random-sample (array-dimension array))))
        ;;          (ignore ;; compute and cache the results
        ;;           ;; possibly not in order
        ;;           (array-elements-in-order? sampled-array))
        ;;          (translated-array
        ;;           (array-translate array
        ;;                            (vector-map (lambda (x) (random 10))
        ;;                                        (make-vector
        ;;                                         (array-dimension array)))))
        ;;          (translated-sampled-array
        ;;           (array-translate sampled-array
        ;;                            (vector-map (lambda (x) (random 10))
        ;;                                        (make-vector
        ;;                                         (array-dimension array))))))
        ;;     (test (%%compute-array-elements-in-order?
        ;;            (%%array-domain translated-array)
        ;;            (%%array-indexer translated-array))
        ;;         (array-elements-in-order? translated-array))
        ;;     (test (%%compute-array-elements-in-order?
        ;;            (%%array-domain translated-sampled-array)
        ;;            (%%array-indexer translated-sampled-array))
        ;;         (array-elements-in-order? translated-sampled-array))))

        ;; (do ((i 0 (+ i 1)))
        ;;     ((= i tests))
        ;;   (let* ((array
        ;;           (make-specialized-array (random-nonnegative-interval 2 4)
        ;;                                   u8-storage-class))
        ;;          (d-1
        ;;           (- (array-dimension array) 1))
        ;;          (ignore
        ;;           ;; compute and cache the result, in order
        ;;           (array-elements-in-order? array))
        ;;          (rotated-array
        ;;           (array-rotate array 1))
        ;;          (ignore ;; compute and cache the results
        ;;           ;; possibly not in order
        ;;           (array-elements-in-order? rotated-array))
        ;;          (sampled-array
        ;;           (array-sample array (list->vector (cons 2 (make-list d-1 1)))))
        ;;          (ignore
        ;;           ;; almost definitely not in order, but if we curry it
        ;;           ;; with dimension 1 the subarrays are in order.
        ;;           (array-elements-in-order? sampled-array))
        ;;          (curried-array
        ;;           (array-ref (array-curry array d-1)
        ;;                      (interval-lower-bound (array-domain array) 0)))
        ;;          (curried-rotated-array
        ;;           (array-ref
        ;;            (array-curry rotated-array d-1)
        ;;            (interval-lower-bound (array-domain rotated-array) 0)))
        ;;          (curried-sampled-array
        ;;           (array-ref
        ;;            (array-curry sampled-array d-1)
        ;;            (interval-lower-bound (array-domain sampled-array) 0))))
        ;;     (test (%%compute-array-elements-in-order?
        ;;            (%%array-domain curried-array)
        ;;            (%%array-indexer curried-array))
        ;;         (array-elements-in-order? curried-array))
        ;;     (test (%%compute-array-elements-in-order?
        ;;            (%%array-domain curried-rotated-array)
        ;;            (%%array-indexer curried-rotated-array))
        ;;         (array-elements-in-order? curried-rotated-array))
        ;;     (test (%%compute-array-elements-in-order?
        ;;            (%%array-domain curried-sampled-array)
        ;;            (%%array-indexer curried-sampled-array))
        ;;         (array-elements-in-order? curried-sampled-array))))
         
        ;; FIXME: array-reshape tests.

        ;; error tests

        ;; (test-error
        ;;  (%%move-array-elements
        ;;   (array-reverse (make-specialized-array (make-interval '#(2 2))))
        ;;   (make-array (make-interval '#(1 4)) list)
        ;;   ""))

        ;; (test-error
        ;;  (%%move-array-elements
        ;;   (make-specialized-array (make-interval '#(2 2)))
        ;;   (make-array (make-interval '#(1 5)) list)
        ;;   ""))

        ;; (test-error
        ;;  (%%move-array-elements
        ;;   (make-array (make-interval '#(2 2)) list list) ;; not a valid setter
        ;;   (make-array (make-interval '#(1 4)) list)
        ;;   ""))

        ;; (do ((d 1 (fx+ d 1)))
        ;;     ((= d 6))
        ;;   (let* ((uppers-list
        ;;           (iota d 2))
        ;;          (domain
        ;;           (make-interval (list->vector uppers-list)))
        ;;          (reversed-domain
        ;;           (make-interval (list->vector (reverse uppers-list)))))
        ;;     (do ((i 0 (fx+ i 1)))
        ;;         ;; distribute "tests" results over five dimensions
        ;;         ((= i (quotient tests 5)))
        ;;       (let* ((storage-class-and-initializer
        ;;               (random-storage-class-and-initializer))
        ;;              (storage-class
        ;;               (car storage-class-and-initializer))
        ;;              (initializer
        ;;               (cadr storage-class-and-initializer))
        ;;              (specialized-source
        ;;               (array-copy
        ;;                (make-array domain
        ;;                            (lambda args
        ;;                              (initializer)))
        ;;                storage-class))
        ;;              (rotated-specialized-source
        ;;               (array-rotate specialized-source (- d 1)))
        ;;              (specialized-reversed-source
        ;;               (array-copy
        ;;                (make-array reversed-domain
        ;;                            (lambda args
        ;;                              (initializer)))
        ;;                storage-class))
        ;;              (specialized-destination
        ;;               (make-specialized-array domain
        ;;                                       storage-class))
        ;;              (specialized-reversed-destination
        ;;               (make-specialized-array reversed-domain
        ;;                                       storage-class))
        ;;              (source
        ;;               (make-array domain
        ;;                           (array-getter
        ;;                            (array-reverse specialized-source))))
        ;;              (destination
        ;;               (make-array (array-domain specialized-destination)
        ;;                           (array-getter specialized-destination)
        ;;                           (array-setter specialized-destination)))
        ;;              (rotated-specialized-source
        ;;               (array-rotate specialized-source (- d 1)))
        ;;              (rotated-source
        ;;               (array-rotate source (- d 1)))
        ;;              (reversed-source
        ;;               (make-array reversed-domain
        ;;                           (array-getter specialized-reversed-source)))
        ;;              (reversed-destination
        ;;               (make-array reversed-domain
        ;;                           (array-getter specialized-reversed-source)
        ;;                           (array-setter specialized-reversed-source))))
        ;;         ;; specialized-to-specialized, use fast copy
        ;;         (test-error (%%move-array-elements specialized-destination
        ;;                                            specialized-source "test: "))
        ;;         (test-assert
        ;;             (myarray= specialized-source specialized-destination))
        ;;         ;; fast copying between specialized of the same volume
        ;;         (test-error (%%move-array-elements specialized-destination
        ;;                                            specialized-reversed-source
        ;;                                            "test: "))
        ;;         ;; copy to adjacent elements of destination, checking needed
        ;;         (test-error
        ;;          (%%move-array-elements specialized-destination source "test: "))
        ;;         (test-assert (myarray= source specialized-destination))
        ;;         ;; copy to adjacent elements of destination, no checking needed
        ;;         ;; arrays of different shapes
        ;;         (test-error (%%move-array-elements specialized-destination
        ;;                                            rotated-specialized-source
        ;;                                            "test: "))
        ;;         (test (array->list rotated-specialized-source)
        ;;             (array->list specialized-destination))
        ;;         ;; copy to adjacent elements of destination, checking needed
        ;;         ;; arrays of different shapes
        ;;         (test-error (%%move-array-elements specialized-destination
        ;;                                            rotated-source "test: "))
        ;;         (test (array->list rotated-source)
        ;;             (array->list specialized-destination))
        ;;         ;; copy to non-adjacent elements of destination, no
        ;;         ;; checking needed
        ;;         (test-error (%%move-array-elements
        ;;                      (array-reverse specialized-destination)
        ;;                      specialized-source "test: "))
        ;;         (test-assert (myarray= specialized-source
        ;;                                (array-reverse specialized-destination)))
        ;;         ;; copy to non-specialized array
        ;;         (test-error (%%move-array-elements destination source "test: "))
        ;;         (test-assert (myarray= destination source))
        ;;         ))))

        (test-error (array-copy #f generic-storage-class))
        (test-error (array-copy (make-array (make-interval '#(1) '#(2))
                                            list)
                                #f))
        (test-error (array-copy (make-array (make-interval '#(1) '#(2))
                                            list)
                                generic-storage-class
                                'a))
        (test-error (array-copy (make-array (make-interval '#(1) '#(2))
                                            list)
                                generic-storage-class
                                (make-interval '#(10))))
        (test-error (array-copy (make-array (make-interval '#(1) '#(2))
                                            list)
                                generic-storage-class
                                #f
                                'a))

        (test-error (array-copy (make-array (make-interval '#(1) '#(2))
                                            list)
                                generic-storage-class
                                #f
                                #f
                                'a))

        ;; We gotta make sure than the error checks work in all dimensions ...
        (test-error (array-copy (make-array (make-interval '#(1) '#(2))
                                            list)
                                u16-storage-class))
        (test-error (array-copy (make-array (make-interval '#(1 1) '#(2 2))
                                            list)
                                u16-storage-class))
        (test-error (array-copy (make-array (make-interval '#(1 1 1) '#(2 2 2))
                                            list)
                                u16-storage-class))
        (test-error (array-copy (make-array (make-interval '#(1 1 1 1)
                                                           '#(2 2 2 2))
                                            list)
                                u16-storage-class))
        (test-error (array-copy (make-array (make-interval '#(1 1 1 1 1)
                                                           '#(2 2 2 2 2))
                                            list)
                                u16-storage-class))
        (test-error (specialized-array-default-safe? 'a))
        (test-error (specialized-array-default-mutable? 'a))

        ;; (let ((mutable-default (specialized-array-default-mutable?)))
        ;;   (specialized-array-default-mutable? #f)
        ;;   (do ((i 1 (+ i 1)))
        ;;       ((= i 6))
        ;;     (let ((A (array-copy (make-array (make-interval (make-vector i 2))
        ;;                                      (lambda args 10)))))
        ;;       (test-error (apply array-set! A 0 (make-list i 0)))
        ;;       (test-error (array-assign! A A))))
        ;;   (specialized-array-default-mutable? mutable-default))

        (specialized-array-default-safe? #t)

        ;; (do ((i 0 (+ i 1)))
        ;;     ((= i tests))
        ;;   (let* ((domain
        ;;           (random-interval))
        ;;          (lower-bounds
        ;;           (interval-lower-bounds->list domain))
        ;;          (upper-bounds
        ;;           (interval-upper-bounds->list domain))
        ;;          (array1
        ;;           (let ((alist '()))
        ;;             (make-array
        ;;              domain
        ;;              (lambda indices
        ;;                (cond ((assoc indices alist)
        ;;                       => cdr)
        ;;                      (else
        ;;                       indices)))
        ;;              (lambda (value . indices)
        ;;                (cond ((assoc indices alist)
        ;;                       =>(lambda (entry)
        ;;                           (set-cdr! entry value)))
        ;;                      (else
        ;;                       (set! alist (cons (cons indices value)
        ;;                                         alist))))))))
        ;;          (array2
        ;;           (array-copy array1 generic-storage-class))
        ;;          (setter1
        ;;           (array-setter array1))
        ;;          (setter2
        ;;           (array-setter array2)))
        ;;     (do ((j 0 (+ j 1)))
        ;;         ((= j 25))
        ;;       (let ((v (random 1000))
        ;;             (indices (map random lower-bounds upper-bounds)))
        ;;         (apply setter1 v indices)
        ;;         (apply setter2 v indices)))
        ;;     (test-assert (myarray= array1 array2))
        ;;     (test-assert (myarray= (array-copy array1 generic-storage-class)
        ;;                            array2))
        ;;     ))

        (specialized-array-default-safe? #f)

        ;; (do ((i 0 (+ i 1)))
        ;;     ((= i tests))
        ;;   (let* ((domain
        ;;           (random-interval))
        ;;          (lower-bounds
        ;;           (interval-lower-bounds->list domain))
        ;;          (upper-bounds
        ;;           (interval-upper-bounds->list domain))
        ;;          (array1
        ;;           (let ((alist '()))
        ;;             (make-array
        ;;              domain
        ;;              (lambda indices
        ;;                (cond ((assoc indices alist)
        ;;                       => cdr)
        ;;                      (else
        ;;                       indices)))
        ;;              (lambda (value . indices)
        ;;                (cond ((assoc indices alist)
        ;;                       =>(lambda (entry)
        ;;                           (set-cdr! entry value)))
        ;;                      (else
        ;;                       (set! alist (cons (cons indices value)
        ;;                                         alist))))))))
        ;;          (array2
        ;;           (array-copy array1 generic-storage-class ))
        ;;          (setter1
        ;;           (array-setter array1))
        ;;          (setter2
        ;;           (array-setter array2)))
        ;;     (do ((j 0 (+ j 1)))
        ;;         ((= j 25))
        ;;       (let ((v (random 1000))
        ;;             (indices (map random lower-bounds upper-bounds)))
        ;;         (apply setter1 v indices)
        ;;         (apply setter2 v indices)))
        ;;     (test-assert (myarray= array1 array2))
        ;;     (test-assert (myarray= (array-copy array1 generic-storage-class)
        ;;                            array2))
        ;;     ))

        (test-error (array-map 1 #f))
        (test-error (array-map list 1 (make-array (make-interval '#(3) '#(4))
                                                  list)))
        (test-error (array-map list (make-array (make-interval '#(3) '#(4))
                                                list) 1))
        (test-error (array-map list
                               (make-array (make-interval '#(3) '#(4))
                                           list)
                               (make-array (make-interval '#(3 4) '#(4 5))
                                           list)))
        (test-error (array-every 1 2))
        (test-error (array-every list 1))
        (test-error (array-every list
                                 (make-array (make-interval '#(3) '#(4))
                                             list)
                                 1))
        (test-error (array-every list
                                 (make-array (make-interval '#(3) '#(4))
                                             list)
                                 (make-array (make-interval '#(3 4) '#(4 5))
                                             list)))
        (test-error (array-any 1 2))
        (test-error (array-any list 1))
        (test-error (array-any list
                               (make-array (make-interval '#(3) '#(4))
                                           list)
                               1))
        (test-error (array-any list
                               (make-array (make-interval '#(3) '#(4))
                                           list)
                               (make-array (make-interval '#(3 4) '#(4 5))
                                           list)))

        ;; (do ((i 0 (+ i 1)))
        ;;     ((= i tests))
        ;;   (let* ((interval
        ;;           (random-nonnegative-interval 1 6))
        ;;          (n
        ;;           (interval-volume interval))
        ;;          (separator
        ;;           ;; I want to make sure that the last item is chosen at least
        ;;           ;; once for each random
        ;;           (random (max 0 (- n 10)) n))
        ;;          (indexer
        ;;           (%%interval->basic-indexer interval))
        ;;          (arguments-1
        ;;           '())
        ;;          (array-1
        ;;           (make-array
        ;;            interval
        ;;            (lambda args
        ;;              (set! arguments-1 (cons args
        ;;                                      arguments-1))
        ;;              (let ((index (apply indexer args)))
        ;;                (cond
        ;;                 ((< index separator)
        ;;                  #f)
        ;;                 ((= index separator)
        ;;                  1)
        ;;                 (else
        ;;                  (error "The array should never be called with these args"
        ;;                         interval
        ;;                         separator
        ;;                         args
        ;;                         index)))))))
        ;;          (arguments-2
        ;;           '())
        ;;          (array-2
        ;;           (make-array
        ;;            interval
        ;;            (lambda args
        ;;              (set! arguments-2 (cons args
        ;;                                      arguments-2))
        ;;              (let ((index (apply indexer args)))
        ;;                (cond
        ;;                 ((< index separator)
        ;;                  #t)
        ;;                 ((= index separator)
        ;;                  #f)
        ;;                 (else
        ;;                  (error "The array should never be called with these args"
        ;;                         interval
        ;;                         separator
        ;;                         args
        ;;                         index))))))))
        ;;     (test 1
        ;;         (array-any values array-1))
        ;;     (test-not (array-every values array-2))
        ;;     (test-assert (indices-in-proper-order (reverse arguments-1)))
        ;;     (test-assert (indices-in-proper-order (reverse arguments-2)))
        ;;     ))

        (test-error (array-fold 1 1 1))
        (test-error (array-fold list 1 1))
        (test-error (array-fold-right 1 1 1))
        (test-error (array-fold-right list 1 1))
        (test-error (array-for-each 1 #f))
        (test-error (array-for-each list 1 (make-array (make-interval '#(3) '#(4))
                                                       list)))
        (test-error (array-for-each list (make-array (make-interval '#(3) '#(4))
                                                     list) 1))
        (test-error (array-for-each list
                                    (make-array (make-interval '#(3) '#(4))
                                                list)
                                    (make-array (make-interval '#(3 4) '#(4 5))
                                                list)))

        (specialized-array-default-safe? #t)

        ;; (let ((array-builders
        ;;        (vector
        ;;         (list u1-storage-class      (lambda indices (random 0 (expt 2 1))))
        ;;         (list u8-storage-class      (lambda indices (random 0 (expt 2 8))))
        ;;         (list u16-storage-class     (lambda indices (random 0 (expt 2 16))))
        ;;         (list u32-storage-class     (lambda indices (random 0 (expt 2 32))))
        ;;         (list u64-storage-class     (lambda indices (random 0 (expt 2 64))))
        ;;         (list s8-storage-class
        ;;               (lambda indices (random (- (expt 2 7))  (expt 2 7))))
        ;;         (list s16-storage-class
        ;;               (lambda indices (random (- (expt 2 15)) (expt 2 15))))
        ;;         (list s32-storage-class
        ;;               (lambda indices (random (- (expt 2 31)) (expt 2 31))))
        ;;         (list s64-storage-class
        ;;               (lambda indices (random (- (expt 2 63)) (expt 2 63))))
        ;;         (list f32-storage-class
        ;;               (lambda indices (random-real)))
        ;;         (list f64-storage-class
        ;;               (lambda indices (random-real)))
        ;;         (list c64-storage-class
        ;;               (lambda indices (make-rectangular (random-real) (random-real))))
        ;;         (list c128-storage-class
        ;;               (lambda indices (make-rectangular (random-real) (random-real))))
        ;;         (list generic-storage-class
        ;;               (lambda indices indices)))))
        ;;   (do ((i 0 (+ i 1)))
        ;;       ((= i tests))
        ;;     (let* ((domain
        ;;             (random-interval))
        ;;            (lower-bounds
        ;;             (interval-lower-bounds->list domain))
        ;;            (upper-bounds
        ;;             (interval-upper-bounds->list domain))
        ;;            (array-length
        ;;             (lambda (a)
        ;;               (let ((upper-bounds
        ;;                      (interval-upper-bounds->list (array-domain a)))
        ;;                     (lower-bounds
        ;;                      (interval-lower-bounds->list (array-domain a))))
        ;;                 (apply * (map - upper-bounds lower-bounds)))))
        ;;            (arrays
        ;;             (map (lambda (ignore)
        ;;                    (let ((array-builder
        ;;                           (vector-ref array-builders
        ;;                                       (random
        ;;                                        (vector-length array-builders)))))
        ;;                      (array-copy (make-array domain
        ;;                                              (cadr array-builder))
        ;;                                  (car array-builder))))
        ;;                  (local-iota 0 (random 1 7))))
        ;;            (result-array-1
        ;;             (apply array-map
        ;;                    list
        ;;                    arrays))
        ;;            (result-array-2
        ;;             (array-copy
        ;;              (apply array-map
        ;;                     list
        ;;                     arrays)))
        ;;            (getters
        ;;             (map array-getter arrays))
        ;;            (result-array-3
        ;;             (make-array domain
        ;;                         (lambda indices
        ;;                           (map (lambda (g) (apply g indices)) getters)))))
        ;;       (test-assert
        ;;           (and (myarray= result-array-1 result-array-2)
        ;;                (myarray= result-array-2 result-array-3)
        ;;                (equal? (vector->list (array-body result-array-2))
        ;;                        (reverse (array-fold (lambda (x y) (cons x y))
        ;;                                             '()
        ;;                                             result-array-2)))
        ;;                (equal? (vector->list (array-body result-array-2))
        ;;                        (reverse (let ((result '()))
        ;;                                   (array-for-each
        ;;                                    (lambda (f)
        ;;                                      (set! result (cons f result)))
        ;;                                    result-array-2)
        ;;                                   result)))
        ;;                (equal?  (map array-length arrays)
        ;;                         (map (lambda (array)
        ;;                                ((storage-class-length
        ;;                                  (array-storage-class array))
        ;;                                 (array-body array)))
        ;;                              arrays))))
        ;;       )))

        (specialized-array-default-safe? #f)

        ;; (let ((array-builders
        ;;        (vector
        ;;         (list u1-storage-class      (lambda indices (random (expt 2 1))))
        ;;         (list u8-storage-class      (lambda indices (random (expt 2 8))))
        ;;         (list u16-storage-class     (lambda indices (random (expt 2 16))))
        ;;         (list u32-storage-class     (lambda indices (random (expt 2 32))))
        ;;         (list u64-storage-class     (lambda indices (random (expt 2 64))))
        ;;         (list s8-storage-class
        ;;               (lambda indices (random (- (expt 2 7))  (expt 2 7))))
        ;;         (list s16-storage-class
        ;;               (lambda indices (random (- (expt 2 15)) (expt 2 15))))
        ;;         (list s32-storage-class
        ;;               (lambda indices (random (- (expt 2 31)) (expt 2 31))))
        ;;         (list s64-storage-class
        ;;               (lambda indices (random (- (expt 2 63)) (expt 2 63))))
        ;;         (list f32-storage-class
        ;;               (lambda indices (random-real)))
        ;;         (list f64-storage-class
        ;;               (lambda indices (random-real)))
        ;;         (list c64-storage-class
        ;;               (lambda indices (make-rectangular (random-real) (random-real))))
        ;;         (list c128-storage-class
        ;;               (lambda indices (make-rectangular (random-real) (random-real))))
        ;;         (list generic-storage-class (lambda indices indices)))))
        ;;   (do ((i 0 (+ i 1)))
        ;;       ((= i tests))
        ;;     (let* ((domain
        ;;             (random-interval))
        ;;            ;;(_ (begin (write `(domain: ,domain)) (newline)))
        ;;            (lower-bounds
        ;;             (interval-lower-bounds->list domain))
        ;;            (upper-bounds
        ;;             (interval-upper-bounds->list domain))
        ;;            (arrays
        ;;             (map (lambda (ignore)
        ;;                    (let ((array-builder
        ;;                           (vector-ref array-builders
        ;;                                       (random
        ;;                                        (vector-length array-builders)))))
        ;;                      (array-copy (make-array domain
        ;;                                              (cadr array-builder))
        ;;                                  (car array-builder))))
        ;;                  (local-iota 0 (random 1 7))))
        ;;            (result-array-1
        ;;             (apply array-map
        ;;                    list
        ;;                    arrays))
        ;;            (result-array-2
        ;;             (array-copy
        ;;              (apply array-map
        ;;                     list
        ;;                     arrays)))
        ;;            (getters
        ;;             (map array-getter arrays))
        ;;            (result-array-3
        ;;             (make-array domain
        ;;                         (lambda indices
        ;;                           (map (lambda (g) (apply g indices)) getters)))))
        ;;       (test-assert
        ;;           (and (myarray= result-array-1 result-array-2)
        ;;                (myarray= result-array-2 result-array-3)
        ;;                (equal? (vector->list (array-body result-array-2))
        ;;                        (reverse (array-fold cons
        ;;                                             '()
        ;;                                             result-array-2)))
        ;;                (equal? (vector->list (array-body result-array-2))
        ;;                        (reverse (let ((result '()))
        ;;                                   (array-for-each
        ;;                                    (lambda (f)
        ;;                                      (set! result (cons f result)))
        ;;                                    result-array-2)
        ;;                                   result))))))))

        (test-error (array-reduce 'a 'a))
        (test-error (array-reduce 'a (make-array (make-interval '#(1) '#(3))
                                                 list)))

        (let ((A (make-array (make-interval '#(1) '#(11))
                             (lambda (i)
                               (if (even? i)
                                   (matrix 1 i
                                           0 1)
                                   (matrix 1 0
                                           i 1))))))
          (test (array-fold-right x2x2-multiply (matrix 1 0 0 1) A)
              (array-reduce x2x2-multiply A))
          (test-not (equal? (array-reduce x2x2-multiply A)
                            (array-fold x2x2-multiply (matrix 1 0 0 1) A))))

        (let ((A_2 (make-array (make-interval '#(1 1) '#(3 7))
                               (lambda (i j)
                                 (if (and (even? i) (even? j))
                                     (matrix 1 i
                                             j 1)
                                     (matrix 1 j
                                             i -1))))))
          (test (array-fold-right x2x2-multiply (matrix 1 0 0 1) A_2)
              (array-reduce x2x2-multiply A_2))
          (test-not (equal? (array-reduce x2x2-multiply A_2)
                            (array-fold x2x2-multiply (matrix 1 0 0 1) A_2)))
          (test-not (equal? (array-reduce x2x2-multiply A_2)
                            (array-reduce x2x2-multiply (array-rotate A_2 1)))))

        (let ((A_3 (make-array (make-interval '#(1 1 1) '#(3 5 4))
                               (lambda (i j k)
                                 (if (and (even? i) (even? j))
                                     (matrix 1 i
                                             j k)
                                     (matrix k j
                                             i -1))))))
          (test (array-fold-right x2x2-multiply (matrix 1 0 0 1) A_3)
              (array-reduce x2x2-multiply A_3))
          (test-not (equal? (array-reduce x2x2-multiply A_3)
                            (array-fold x2x2-multiply (matrix 1 0 0 1) A_3)))
          (test-not (equal? (array-reduce x2x2-multiply A_3)
                            (array-reduce x2x2-multiply (array-rotate A_3 1)))))

        (let ((A_4 (make-array (make-interval '#(1 1 1 1) '#(3 2 4 3))
                               (lambda (i j k l)
                                 (if (and (even? i) (even? j))
                                     (matrix l i
                                             j k)
                                     (matrix l k
                                             i j))))))
          (test (array-fold-right x2x2-multiply (matrix 1 0 0 1) A_4)
              (array-reduce x2x2-multiply A_4))
          (test-not (equal? (array-reduce x2x2-multiply A_4)
                            (array-fold x2x2-multiply (matrix 1 0 0 1) A_4)))
          (test-not (equal? (array-reduce x2x2-multiply A_4)
                            (array-reduce x2x2-multiply (array-rotate A_4 1)))))

        (let ((A_5 (make-array (make-interval '#(1 1 1 1 1) '#(3 2 4 3 3))
                               (lambda (i j k l m)
                                 (if (even? m)
                                     (matrix (+ m l) i
                                             j k)
                                     (matrix (- l m) k
                                             i j))))))
          (test (array-fold-right x2x2-multiply (matrix 1 0 0 1) A_5)
              (array-reduce x2x2-multiply A_5))
          (test-not (equal? (array-reduce x2x2-multiply A_5)
                            (array-fold x2x2-multiply (matrix 1 0 0 1) A_5)))
          (test-not (equal? (array-reduce x2x2-multiply A_5)
                            (array-reduce x2x2-multiply (array-rotate A_5 1)))))

        (test-error (array-curry 'a 1))
        (test-error
         (array-curry (make-array (make-interval '#(0) '#(1)) list)  'a))
        (test-error
         (array-curry (make-array (make-interval '#(0 0) '#(1 1)) list)  0))
        (test-error
         (array-curry (make-array (make-interval '#(0 0) '#(1 1)) list)  2))

        ;; (let ((array-builders
        ;;        (vector
        ;;         (list u1-storage-class      (lambda indices (random (expt 2 1))))
        ;;         (list u8-storage-class      (lambda indices (random (expt 2 8))))
        ;;         (list u16-storage-class     (lambda indices (random (expt 2 16))))
        ;;         (list u32-storage-class     (lambda indices (random (expt 2 32))))
        ;;         (list u64-storage-class     (lambda indices (random (expt 2 64))))
        ;;         (list s8-storage-class
        ;;               (lambda indices (random (- (expt 2 7))  (expt 2 7))))
        ;;         (list s16-storage-class
        ;;               (lambda indices (random (- (expt 2 15)) (expt 2 15))))
        ;;         (list s32-storage-class
        ;;               (lambda indices (random (- (expt 2 31)) (expt 2 31))))
        ;;         (list s64-storage-class
        ;;               (lambda indices (random (- (expt 2 63)) (expt 2 63))))
        ;;         (list f32-storage-class
        ;;               (lambda indices (random-real)))
        ;;         (list f64-storage-class
        ;;               (lambda indices (random-real)))
        ;;         (list c64-storage-class
        ;;               (lambda indices (make-rectangular (random-real) (random-real))))
        ;;         (list c128-storage-class
        ;;               (lambda indices (make-rectangular (random-real) (random-real))))
        ;;         (list generic-storage-class
        ;;               (lambda indices indices)))))
        ;;   (do ((i 0 (+ i 1)))
        ;;       ((= i tests))
        ;;     (let* ((domain
        ;;             (random-interval 2 7))
        ;;            (lower-bounds
        ;;             (interval-lower-bounds->list domain))
        ;;            (upper-bounds
        ;;             (interval-upper-bounds->list domain))
        ;;            (array-builder
        ;;             (vector-ref array-builders
        ;;                         (random (vector-length array-builders))))
        ;;            (random-array-element
        ;;             (cadr array-builder))
        ;;            (storage-class
        ;;             (car array-builder))
        ;;            (Array
        ;;             (array-copy (make-array domain
        ;;                                     random-array-element)
        ;;                         storage-class))
        ;;            (copied-array
        ;;             (array-copy Array
        ;;                         storage-class))
        ;;            (inner-dimension
        ;;             (random 1 (interval-dimension domain)))
        ;;            (domains
        ;;             (call-with-values
        ;;                 (lambda () (interval-projections domain inner-dimension))
        ;;               list))
        ;;            (outer-domain
        ;;             (car domains))
        ;;            (inner-domain
        ;;             (cadr domains))
        ;;            (immutable-curry
        ;;             (array-curry (make-array (array-domain Array)
        ;;                                      (array-getter Array))
        ;;                          inner-dimension))
        ;;            (mutable-curry
        ;;             (array-curry (make-array (array-domain Array)
        ;;                                      (array-getter Array)
        ;;                                      (array-setter Array))
        ;;                          inner-dimension))
        ;;            (specialized-curry
        ;;             (array-curry Array inner-dimension))
        ;;            (immutable-curry-from-definition
        ;;             (call-with-values
        ;;                 (lambda () (interval-projections (array-domain Array)
        ;;                                              inner-dimension))
        ;;               (lambda (outer-interval inner-interval)
        ;;                 (make-array
        ;;                  outer-interval
        ;;                  (lambda outer-multi-index
        ;;                    (make-array
        ;;                     inner-interval
        ;;                     (lambda inner-multi-index
        ;;                       (apply (array-getter Array)
        ;;                              (append outer-multi-index
        ;;                                      inner-multi-index)))))))))
        ;;            (mutable-curry-from-definition
        ;;             (call-with-values
        ;;                 (lambda () (interval-projections (array-domain Array)
        ;;                                              inner-dimension))
        ;;               (lambda (outer-interval inner-interval)
        ;;                 (make-array
        ;;                  outer-interval
        ;;                  (lambda outer-multi-index
        ;;                    (make-array
        ;;                     inner-interval
        ;;                     (lambda inner-multi-index
        ;;                       (apply (array-getter Array)
        ;;                              (append outer-multi-index
        ;;                                      inner-multi-index)))
        ;;                     (lambda (v . inner-multi-index)
        ;;                       (apply (array-setter Array) v
        ;;                              (append outer-multi-index
        ;;                                      inner-multi-index)))))))))
        ;;            (specialized-curry-from-definition
        ;;             (call-with-values
        ;;                 (lambda () (interval-projections (array-domain Array)
        ;;                                              inner-dimension))
        ;;               (lambda (outer-interval inner-interval)
        ;;                 (make-array
        ;;                  outer-interval
        ;;                  (lambda outer-multi-index
        ;;                    (specialized-array-share
        ;;                     Array
        ;;                     inner-interval
        ;;                     (lambda inner-multi-index
        ;;                       (apply values
        ;;                              (append outer-multi-index
        ;;                                      inner-multi-index))))))))))
        ;;       ;; mutate the curried array
        ;;       (for-each
        ;;        (lambda (curried-array)
        ;;          (let ((outer-getter
        ;;                 (array-getter curried-array)))
        ;;            (do ((i 0 (+ i 1)))
        ;;                ((= i 50)) ;; used to be tests, not 50, but 50 will do fine
        ;;              (call-with-values
        ;;                  (lambda ()
        ;;                    (random-multi-index outer-domain))
        ;;                (lambda outer-multi-index
        ;;                  (let ((inner-setter
        ;;                         (array-setter (apply outer-getter
        ;;                                              outer-multi-index))))
        ;;                    (call-with-values
        ;;                        (lambda ()
        ;;                          (random-multi-index inner-domain))
        ;;                      (lambda inner-multi-index
        ;;                        (let ((new-element
        ;;                               (random-array-element)))
        ;;                          (apply inner-setter
        ;;                                 new-element
        ;;                                 inner-multi-index)
        ;;                          ;; mutate the copied array without currying
        ;;                          (apply (array-setter copied-array)
        ;;                                 new-element
        ;;                                 (append outer-multi-index
        ;;                                         inner-multi-index)))))))))))
        ;;        (list mutable-curry
        ;;              specialized-curry
        ;;              mutable-curry-from-definition
        ;;              specialized-curry-from-definition
        ;;              ))

        ;;       (and (or (myarray= Array copied-array) (error "Arggh"))
        ;;            (or (array-every array? immutable-curry) (error "Arggh"))
        ;;            (or (array-every (lambda (a) (not (mutable-array? a)))
        ;;                             immutable-curry)
        ;;                (error "Arggh"))
        ;;            (or (array-every mutable-array? mutable-curry) (error "Arggh"))
        ;;            (or (array-every (lambda (a) (not (specialized-array? a)))
        ;;                             mutable-curry)
        ;;                (error "Arggh"))
        ;;            (or (array-every specialized-array? specialized-curry)
        ;;                (error "Arggh"))
        ;;            (or (array-every
        ;;                 (lambda (xy) (apply myarray= xy))
        ;;                 (array-map list immutable-curry
        ;;                            immutable-curry-from-definition))
        ;;                (error "Arggh"))
        ;;            (or (array-every
        ;;                 (lambda (xy) (apply myarray= xy))
        ;;                 (array-map list mutable-curry
        ;;                            mutable-curry-from-definition))
        ;;                (error "Arggh"))
        ;;            (or (array-every
        ;;                 (lambda (xy) (apply myarray= xy))
        ;;                 (array-map list specialized-curry
        ;;                            specialized-curry-from-definition))
        ;;                (error "Arggh"))))))

        (test-error (specialized-array-share 1 1 1))
        (test-error (specialized-array-share
                     (make-specialized-array (make-interval '#(1) '#(2)))
                     1 1))
        ;; (test-error (specialized-array-share
        ;;              (make-specialized-array (make-interval '#(1) '#(2)))
        ;;              (make-interval '#(0) '#(1))
        ;;              1))

        (test-assert
            (myarray= (list->array (reverse (local-iota 0 10))
                                   (make-interval '#(0) '#(10)))
                      (specialized-array-share
                       (list->array (local-iota 0 10)
                                    (make-interval '#(0) '#(10)))
                       (make-interval '#(0) '#(10))
                       (lambda (i)
                         (- 9 i)))))

        ;; (do ((i 0 (+ i 1)))
        ;;     ((= i tests))
        ;;   (let* ((n (random 1 11))
        ;;          (permutation (random-permutation n))
        ;;          (input-vec
        ;;           (list->vector (f64vector->list (random-f64vector n)))))
        ;;     (test (%%vector-permute input-vec permutation)
        ;;         (vector-permute input-vec permutation))
        ;;     (test (vector-permute input-vec permutation)
        ;;         (list->vector (%%vector-permute->list input-vec permutation)))))

        (specialized-array-default-safe? #t)

        ;; (do ((i 0 (+ i 1)))
        ;;     ((= i tests))
        ;;   (let* ((interval (random-interval))
        ;;          (axes (local-iota 0 (interval-dimension interval)))
        ;;          (lower-bounds (interval-lower-bounds->vector interval))
        ;;          (upper-bounds (interval-upper-bounds->vector interval))
        ;;          (a (array-copy (make-array interval list)))
        ;;          (new-axis-order
        ;;           (vector-permute (list->vector axes)
        ;;                           (random-permutation (length axes))))
        ;;          (reverse-order?
        ;;           (list->vector (map (lambda (x) (zero? (random 2))) axes))))
        ;;     (let ((b (make-array
        ;;               (make-interval (vector-permute lower-bounds new-axis-order)
        ;;                              (vector-permute upper-bounds new-axis-order))
        ;;               (lambda multi-index
        ;;                 (apply
        ;;                  (array-getter a)
        ;;                  (let* ((n (vector-length new-axis-order))
        ;;                         (multi-index-vector
        ;;                          (list->vector multi-index))
        ;;                         (result (make-vector n)))
        ;;                    (do ((i 0 (+ i 1)))
        ;;                        ((= i n) (vector->list result))
        ;;                      (vector-set!
        ;;                       result
        ;;                       (vector-ref new-axis-order i)
        ;;                       (if (vector-ref reverse-order?
        ;;                                       (vector-ref new-axis-order i))
        ;;                           (+ (vector-ref lower-bounds
        ;;                                          (vector-ref new-axis-order i))
        ;;                              (- (vector-ref upper-bounds
        ;;                                             (vector-ref new-axis-order i))
        ;;                                 (vector-ref multi-index-vector i)
        ;;                                 1))
        ;;                           (vector-ref multi-index-vector i)))))))))
        ;;           (c (specialized-array-share
        ;;               a
        ;;               (make-interval (vector-permute lower-bounds new-axis-order)
        ;;                              (vector-permute upper-bounds new-axis-order))
        ;;               (lambda multi-index
        ;;                 (apply
        ;;                  values
        ;;                  (let* ((n (vector-length new-axis-order))
        ;;                         (multi-index-vector (list->vector multi-index))
        ;;                         (result (make-vector n)))
        ;;                    (do ((i 0 (+ i 1)))
        ;;                        ((= i n) (vector->list result))
        ;;                      (vector-set!
        ;;                       result
        ;;                       (vector-ref new-axis-order i)
        ;;                       (if (vector-ref reverse-order?
        ;;                                       (vector-ref new-axis-order i))
        ;;                           (+ (vector-ref lower-bounds
        ;;                                          (vector-ref new-axis-order i))
        ;;                              (- (vector-ref upper-bounds
        ;;                                             (vector-ref new-axis-order i))
        ;;                                 (vector-ref multi-index-vector i)
        ;;                                 1))
        ;;                           (vector-ref multi-index-vector i))))))))))
        ;;       (test-assert (myarray= b c)))))

        (specialized-array-default-safe? #f)

        ;; (do ((i 0 (+ i 1)))
        ;;     ((= i tests))
        ;;   (let* ((interval (random-interval))
        ;;          (axes (local-iota 0 (interval-dimension interval)))
        ;;          (lower-bounds (interval-lower-bounds->vector interval))
        ;;          (upper-bounds (interval-upper-bounds->vector interval))
        ;;          (a (array-copy (make-array interval list)))
        ;;          (new-axis-order
        ;;           (vector-permute (list->vector axes)
        ;;                           (random-permutation (length axes))))
        ;;          (reverse-order?
        ;;           (list->vector (map (lambda (x) (zero? (random 2))) axes))))
        ;;     (let ((b (make-array
        ;;               (make-interval (vector-permute lower-bounds new-axis-order)
        ;;                              (vector-permute upper-bounds new-axis-order))
        ;;               (lambda multi-index
        ;;                 (apply
        ;;                  (array-getter a)
        ;;                  (let* ((n (vector-length new-axis-order))
        ;;                         (multi-index-vector (list->vector multi-index))
        ;;                         (result (make-vector n)))
        ;;                    (do ((i 0 (+ i 1)))
        ;;                        ((= i n) (vector->list result))
        ;;                      (vector-set!
        ;;                       result
        ;;                       (vector-ref new-axis-order i)
        ;;                       (if (vector-ref reverse-order?
        ;;                                       (vector-ref new-axis-order i))
        ;;                           (+ (vector-ref lower-bounds
        ;;                                          (vector-ref new-axis-order i))
        ;;                              (- (vector-ref upper-bounds
        ;;                                             (vector-ref new-axis-order i))
        ;;                                 (vector-ref multi-index-vector i)
        ;;                                 1))
        ;;                           (vector-ref multi-index-vector i)))))))))
        ;;           (c (specialized-array-share
        ;;               a
        ;;               (make-interval
        ;;                (vector-permute lower-bounds new-axis-order)
        ;;                (vector-permute upper-bounds new-axis-order))
        ;;               (lambda multi-index
        ;;                 (apply
        ;;                  values
        ;;                  (let* ((n (vector-length new-axis-order))
        ;;                         (multi-index-vector (list->vector multi-index))
        ;;                         (result (make-vector n)))
        ;;                    (do ((i 0 (+ i 1)))
        ;;                        ((= i n) (vector->list result))
        ;;                      (vector-set!
        ;;                       result
        ;;                       (vector-ref new-axis-order i)
        ;;                       (if (vector-ref reverse-order?
        ;;                                       (vector-ref new-axis-order i))
        ;;                           (+ (vector-ref lower-bounds
        ;;                                          (vector-ref new-axis-order i))
        ;;                              (- (vector-ref upper-bounds
        ;;                                             (vector-ref new-axis-order i))
        ;;                                 (vector-ref multi-index-vector i)
        ;;                                 1))
        ;;                           (vector-ref multi-index-vector i))))))))))
        ;;       (test-assert (myarray= b c)))))

        (let ((int (make-interval '#(0 0) '#(10 10)))
              (translation '#(10 -2)))
          (test-error (interval-translate 'a 10))
          (test-error (interval-translate int 10))
          (test-error (interval-translate int '#(a b)))
          (test-error (interval-translate int '#(1. 2.)))
          (test-error (interval-translate int '#(1)))
          (do ((i 0 (+ i 1)))
              ((= i tests))
            (let* ((int (random-interval))
                   (lower-bounds (interval-lower-bounds->vector int))
                   (upper-bounds (interval-upper-bounds->vector int))
                   (translation
                    (list->vector
                     (map (lambda (x)
                            (random -10 10))
                          (local-iota 0 (vector-length lower-bounds))))))
              (interval= (interval-translate int translation)
                         (make-interval
                          (vector-map + lower-bounds translation)
                          (vector-map + upper-bounds translation)))))
          )

        (let* ((specialized-array
                (array-copy (make-array (make-interval '#(0 0) '#(10 12))
                                        list)))
               (mutable-array (let ((temp (array-copy specialized-array)))
                                (make-array (array-domain temp)
                                            (array-getter temp)
                                            (array-setter temp))))
               (immutable-array (make-array (array-domain mutable-array)
                                            (array-getter mutable-array)))
               (translation '#(10 -2)))

          (test-error (array-translate 'a 1))
          (test-error (array-translate immutable-array '#(1.)))
          (test-error (array-translate immutable-array '#(0 2 3)))
          (let ((specialized-result
                 (array-translate specialized-array translation)))
            (test-assert (specialized-array? specialized-result)))
          (let ((mutable-result (array-translate mutable-array translation)))
            (test-assert (and (mutable-array? mutable-array)
                              (not (specialized-array? mutable-array))
                              (mutable-array? mutable-result)
                              (not (specialized-array? mutable-result)))))
          (let ((immutable-result (array-translate immutable-array translation)))
            (test-assert (and (array? immutable-array)
                              (not (mutable-array? immutable-array))
                              (array? immutable-result)
                              (not (mutable-array? immutable-result)))))

          ;; (do ((i 0 (+ i 1)))
          ;;     ((= i tests))
          ;;   (let* ((domain (random-interval))
          ;;          (Array (let ((temp (make-array domain list)))
          ;;                   (case (random-integer 3)
          ;;                     ((0) temp)
          ;;                     ((1) (array-copy temp))
          ;;                     ((2) (let ((temp (array-copy temp)))
          ;;                            (make-array (array-domain temp)
          ;;                                        (array-getter temp)
          ;;                                        (array-setter temp)))))))
          ;;          (translation
          ;;           (list->vector
          ;;            (map (lambda (x) (random -10 10))
          ;;                 (vector->list (%%interval-lower-bounds domain))))))
          ;;     (let ((translated-array       (array-translate Array translation))
          ;;           (my-translated-array (my-array-translate Array translation)))
          ;;       (if (mutable-array? Array)
          ;;           (let ((translated-domain
          ;;                  (interval-translate domain translation)))
          ;;             (do ((j 0 (+ j 1)))
          ;;                 ((= j 50))
          ;;               (call-with-values
          ;;                   (lambda ()
          ;;                     (random-multi-index translated-domain))
          ;;                 (lambda multi-index
          ;;                   (let ((value (random-integer 10000)))
          ;;                     (apply (array-setter translated-array)
          ;;                            value multi-index)
          ;;                     (apply (array-setter my-translated-array)
          ;;                            value multi-index)))))))
          ;;       (test-assert
          ;;           (myarray= (array-translate Array translation)
          ;;                     (my-array-translate Array translation))))))
          )
        )

      (test-group "permutation tests"
        (let* ((specialized
                (make-specialized-array (make-interval '#(0 0 0 0 0)
                                                       '#(1 1 1 1 1))))
               (mutable (make-array (array-domain specialized)
                                    (array-getter specialized)
                                    (array-setter specialized)))
               (A (array-translate  mutable '#(0 0 0 0 0))))
          (test-error ((array-getter A) 0 0))
          (test-error ((array-setter A) 'a 0 0)))

        (let ((int (make-interval '#(0 0) '#(10 10)))
              (permutation '#(1 0)))
          (test-error (interval-permute 'a 10))
          (test-error (interval-permute int 10))
          (test-error (interval-permute int '#(a b)))
          (test-error (interval-permute int '#(1. 2.)))
          (test-error (interval-permute int '#(10 -2)))
          (test-error (interval-permute int '#(0)))
          (do ((i 0 (+ i 1)))
              ((= i tests))
            (let* ((int (random-interval))
                   (lower-bounds (interval-lower-bounds->vector int))
                   (upper-bounds (interval-upper-bounds->vector int))
                   (permutation
                    (random-permutation (vector-length lower-bounds))))
              (interval=
               (interval-permute int permutation)
               (make-interval (vector-permute lower-bounds permutation)
                              (vector-permute upper-bounds permutation))))))

        (let* ((specialized-array
                (array-copy (make-array (make-interval '#(0 0) '#(10 12))
                                        list)))
               (mutable-array (let ((temp (array-copy specialized-array)))
                                (make-array (array-domain temp)
                                            (array-getter temp)
                                            (array-setter temp))))
               (immutable-array (make-array (array-domain mutable-array)
                                            (array-getter mutable-array)))
               (permutation '#(1 0)))

          (test-error (array-permute 'a 1))
          (test-error (array-permute immutable-array '#(1.)))
          (test-error (array-permute immutable-array '#(2)))
          (test-error (array-permute immutable-array '#(0 1 2)))
          (let ((specialized-result
                 (array-permute specialized-array permutation)))
            (test-assert (specialized-array? specialized-result)))
          (let ((mutable-result (array-permute mutable-array permutation)))
            (test-assert (and (mutable-array? mutable-array)
                              (not (specialized-array? mutable-array))
                              (mutable-array? mutable-result)
                              (not (specialized-array? mutable-result)))))
          (let ((immutable-result (array-permute immutable-array permutation)))
            (test-assert (and (array? immutable-array)
                              (not (mutable-array? immutable-array))
                              (array? immutable-result)
                              (not (mutable-array? immutable-result)))))

          (specialized-array-default-safe? #t)

          (do ((i 0 (+ i 1)))
              ((= i tests))
            (let* ((domain (random-interval))
                   (Array (let ((temp (make-array domain list)))
                            (case (random-integer 3)
                              ((0) temp)
                              ((1) (array-copy temp))
                              ((2) (let ((temp (array-copy temp)))
                                     (make-array (array-domain temp)
                                                 (array-getter temp)
                                                 (array-setter temp)))))))
                   (permutation
                    (random-permutation (interval-dimension domain))))
              (let* ((permuted-array       (array-permute Array permutation))
                     (my-permuted-array (my-array-permute Array permutation)))
                (let ((permuted-domain (interval-permute domain permutation)))
                  (do ((j 0 (+ j 1)))
                      ((= j 50))
                    (call-with-values
                        (lambda ()
                          (random-multi-index permuted-domain))
                      (lambda multi-index
                        (test (apply (array-getter my-permuted-array)
                                     multi-index)
                            (apply (array-getter permuted-array)
                                   multi-index))))))
                (if (mutable-array? Array)
                    (let ((permuted-domain
                           (interval-permute domain permutation)))
                      (do ((j 0 (+ j 1)))
                          ((= j 50))
                        (call-with-values
                            (lambda ()
                              (random-multi-index permuted-domain))
                          (lambda multi-index
                            (let ((value (random-integer 10000)))
                              (apply (array-setter permuted-array) value
                                     multi-index)
                              (apply (array-setter my-permuted-array) value
                                     multi-index)))))))
                (test-assert (myarray= permuted-array
                                       my-permuted-array)))))

          (specialized-array-default-safe? #f)

          (do ((i 0 (+ i 1)))
              ((= i tests))
            (let* ((domain (random-interval))
                   (Array (let ((temp (make-array domain list)))
                            (case (random-integer 3)
                              ((0) temp)
                              ((1) (array-copy temp))
                              ((2) (let ((temp (array-copy temp)))
                                     (make-array (array-domain temp)
                                                 (array-getter temp)
                                                 (array-setter temp)))))))
                   (permutation
                    (random-permutation (interval-dimension domain)))
                   (permuted-array       (array-permute Array permutation))
                   (my-permuted-array (my-array-permute Array permutation))
                   (permuted-domain (interval-permute domain permutation)))
              ;;(write `(permuted: ,permuted-array my-permuted: ,my-permuted-array)) (newline)
              (do ((j 0 (+ j 1)))
                  ((= j 50))
                (call-with-values
                    (lambda () (random-multi-index permuted-domain))
                  (lambda multi-index
                    ;;(write `(multi-index: ,multi-index domain: ,permuted-domain)) (newline)
                    (test (apply (array-getter my-permuted-array) multi-index)
                        (apply (array-getter permuted-array) multi-index)))))
              (if (mutable-array? Array)
                  (let ((permuted-domain
                         (interval-permute domain permutation)))
                    (do ((j 0 (+ j 1)))
                        ((= j 50))
                      (call-with-values
                          (lambda ()
                            (random-multi-index permuted-domain))
                        (lambda multi-index
                          (let ((value (random-integer 10000)))
                            (apply (array-setter permuted-array) value
                                   multi-index)
                            (apply (array-setter my-permuted-array) value
                                   multi-index)))))))
              (test-assert (myarray= permuted-array
                                     my-permuted-array))))
          )

        ;; because array-rotate is built using the array-permute
        ;; infrastructure, we won't test as much

        (test-error (array-rotate 1 1))
        (test-error
         (array-rotate (make-array (make-interval '#(0 0) '#(2 3)) list) 'a))
        (test-error
         (array-rotate (make-array (make-interval '#(0 0) '#(2 3)) list) 1.))
        (test-error
         (array-rotate (make-array (make-interval '#(0 0) '#(2 3)) list) 1/2))
        (test-error
         (array-rotate (make-array (make-interval '#(0 0) '#(2 3)) list) -1))
        (test-error
         (array-rotate (make-array (make-interval '#(0 0) '#(2 3)) list) 4))
        (test-error (interval-rotate 1 1))
        (test-error (interval-rotate (make-interval '#(0 0) '#(2 3)) 'a))
        (test-error (interval-rotate (make-interval '#(0 0) '#(2 3)) 1.))
        (test-error (interval-rotate (make-interval '#(0 0) '#(2 3)) 37))

        (for-each
         (lambda (n)
           (let* ((upper-bounds (make-vector n 2))
                  (lower-bounds (make-vector n 0))
                  (domain (make-interval lower-bounds upper-bounds))
                  (A (array-copy (make-array domain list)))
                  (immutable-A
                   (let ((A (array-copy A))) ;; copy A
                     (make-array domain
                                 (array-getter A))))
                  (mutable-A
                   (let ((A (array-copy A))) ;; copy A
                     (make-array domain
                                 (array-getter A)
                                 (array-setter A)))))
             (for-each (lambda (dim)
                         (let ((permutation
                                (list->vector
                                 (append
                                  (local-iota dim n)
                                  (local-iota 0 dim)))))
                           (let ((rA
                                  (array-rotate A dim))
                                 (pA
                                  (array-permute A permutation)))
                             (if (not (and (specialized-array? rA)
                                           (specialized-array? pA)
                                           (myarray= rA pA)))
                                 (error "blah rotate specialized")))
                           (let ((rA
                                  (array-rotate immutable-A dim))
                                 (pA
                                  (array-permute immutable-A permutation)))
                             (if (not (and (array? rA)
                                           (array? pA)
                                           (myarray= rA pA)))
                                 (error "blah rotate immutable")))
                           (let ((rA
                                  (array-rotate mutable-A dim))
                                 (pA
                                  (array-permute mutable-A permutation)))
                             (if (not (and (mutable-array? rA)
                                           (mutable-array? pA)
                                           (myarray= rA pA)))
                                 (error "blah rotate mutable")))
                           (test (array-domain (array-rotate mutable-A dim))
                               (interval-rotate (array-domain A) dim))))
                       (iota n))))
         (iota 5 1))
        )

      (test-group "intersect/scale/sample"
        (let ((a (make-interval '#(0 0) '#(10 10)))
              (b (make-interval '#(0) '#(10)))
              (c (make-interval '#(10 10) '#(20 20))))
          (test-error (interval-intersect 'a))
          (test-error (interval-intersect  a 'a))
          (test-error (interval-intersect a b)))

        (do ((i 0 (+ i 1)))
            ((= i tests))
          (let* ((dimension (random 1 6))
                 (number-of-intervals (random 1 4))
                 (intervals (map (lambda (x)
                                   (random-interval dimension (+ dimension 1)))
                                 (local-iota 0 number-of-intervals))))
            (test (apply interval-intersect intervals)
                (apply my-interval-intersect intervals))))

        (test-error (interval-scale 1 'a))
        (test-error (interval-scale (make-interval '#(1) '#(2)) 'a))
        (test-error (interval-scale (make-interval '#(0) '#(1)) 'a))
        (test-error (interval-scale (make-interval '#(0) '#(1)) '#(a)))
        (test-error (interval-scale (make-interval '#(0) '#(1)) '#(0)))
        (test-error (interval-scale (make-interval '#(0) '#(1)) '#(1.)))
        (test-error (interval-scale (make-interval '#(0) '#(1)) '#(1 2)))

        (do ((i 0 (fx+ i 1)))
            ((fx=? i tests))
          (let* ((interval (random-nonnegative-interval))
                 (scales (random-positive-vector (interval-dimension interval))))
            (test (my-interval-scale interval scales)
                (interval-scale interval scales))))

        (test-error (array-sample 'a 'a))
        (test-error
         (array-sample (make-array (make-interval '#(1) '#(2)) list) 'a))
        (test-error
         (array-sample (make-array (make-interval '#(0) '#(2)) list) 'a))
        (test-error
         (array-sample (make-array (make-interval '#(0) '#(2)) list) '#(1.)))
        (test-error
         (array-sample (make-array (make-interval '#(0) '#(2)) list) '#(0)))
        (test-error
         (array-sample (make-array (make-interval '#(0) '#(2)) list) '#(2 1)))

        (do ((i 0 (+ i 1)))
            ((= i tests))
          (let* ((domain (random-nonnegative-interval 1 6))
                 (Array (let ((temp (make-array domain list)))
                          (case (random-integer 3)
                            ((0) temp)
                            ((1) (array-copy temp))
                            ((2) (let ((temp (array-copy temp)))
                                   (make-array (array-domain temp)
                                               (array-getter temp)
                                               (array-setter temp)))))))
                 (scales (random-positive-vector (interval-dimension domain)))
                 (sampled-array (array-sample Array scales))
                 (my-sampled-array (myarray-sample Array scales)))

            (if (mutable-array? Array)
                (let ((scaled-domain (interval-scale domain scales)))
                  (do ((j 0 (+ j 1)))
                      ((= j 50))
                    (call-with-values
                        (lambda ()
                          (random-multi-index scaled-domain))
                      (lambda multi-index
                        (let ((value (random-integer 10000)))
                          (apply (array-setter sampled-array) value multi-index)
                          (apply (array-setter my-sampled-array) value
                                 multi-index)))))))
            (test-assert (myarray= sampled-array
                                   my-sampled-array))))

        (test-error
         (array-extract (make-array (make-interval '#(0 0) '#(1 1)) list)
                        'a))
        (test-error (array-extract 'a (make-interval '#(0 0) '#(1 1))))
        (test-error
         (array-extract (make-array (make-interval '#(0 0) '#(1 1)) list)
                        (make-interval '#(0) '#(1))))
        (test-error
         (array-extract (make-array (make-interval '#(0 0) '#(1 1)) list)
                        (make-interval '#(0 0) '#(1 3))))
        (do ((i 0 (fx+ i 1)))
            ((fx=? i tests))
          (let* ((domain (random-interval))
                 (subdomain (random-subinterval domain))
                 (spec-A (array-copy (make-array domain list)))
                 (spec-A-extract (array-extract spec-A subdomain))
                 (mut-A (let ((A-prime (array-copy spec-A)))
                          (make-array domain
                                      (array-getter A-prime)
                                      (array-setter A-prime))))
                 (mut-A-extract (array-extract mut-A subdomain))
                 (immutable-A (let ((A-prime (array-copy spec-A)))
                                (make-array domain
                                            (array-getter A-prime))))
                 (immutable-A-extract (array-extract immutable-A subdomain))
                 (spec-B (array-copy (make-array domain list)))
                 (spec-B-extract (array-extract spec-B subdomain))
                 (mut-B (let ((B-prime (array-copy spec-B)))
                          (make-array domain
                                      (array-getter B-prime)
                                      (array-setter B-prime))))
                 (mut-B-extract (array-extract mut-B subdomain)))
            ;; test that the extracts are the same kind of arrays as the original
            (if (not (and (specialized-array? spec-A)
                          (specialized-array? spec-A-extract)
                          (mutable-array? mut-A)
                          (mutable-array? mut-A-extract)
                          (not (specialized-array? mut-A))
                          (not (specialized-array? mut-A-extract))
                          (array? immutable-A)
                          (array? immutable-A-extract)
                          (not (mutable-array? immutable-A))
                          (not (mutable-array? immutable-A-extract))
                          (equal? (array-domain spec-A-extract) subdomain)
                          (equal? (array-domain mut-A-extract) subdomain)
                          (equal? (array-domain immutable-A-extract) subdomain)))
                (error "extract: Aargh!"))
            ;; test that applying the original setter to arguments in
            ;; the subdomain gives the same answer as applying the
            ;; setter of the extracted array to the same arguments.
            (for-each (lambda (A B A-extract B-extract)
                        (let ((A-setter (array-setter A))
                              (B-extract-setter (array-setter B-extract)))
                          (do ((i 0 (fx+ i 1)))
                              ((fx=? i 100)
                               (test-assert (myarray= spec-A spec-B))
                               (test-assert
                                   (myarray= spec-A-extract spec-B-extract)))
                            (call-with-values
                                (lambda ()
                                  (random-multi-index subdomain))
                              (lambda multi-index
                                (let ((val (random-real)))
                                  (apply A-setter val multi-index)
                                  (apply B-extract-setter val multi-index)))))))
                      (list spec-A mut-A)
                      (list spec-B mut-B)
                      (list spec-A-extract mut-A-extract)
                      (list spec-B-extract mut-B-extract))))
        )

      (test-group "tile/reverse/flip"
        (test-error (array-tile 'a '#(10)))
        (test-error
         (array-tile (make-array (make-interval '#(0 0) '#(10 10)) list)
                     'a))
        (test-error
         (array-tile (make-array (make-interval '#(0 0) '#(10 10)) list)
                     '#(a a)))
        (test-error
         (array-tile (make-array (make-interval '#(0 0) '#(10 10)) list)
                     '#(-1 1)))
        (test-error
         (array-tile (make-array (make-interval '#(0 0) '#(10 10)) list)
                     '#(10)))

        (do ((d 1 (fx+ d 1)))
            ((fx=? d 6))
          (let* ((A (make-array (make-interval (make-vector d 100)) list))
                 (B (array-tile A (make-vector d 10)))
                 (index (make-list d 12)))
            (test-error (apply (array-getter B) index))))

        (do ((i 0 (fx+ i 1)))
            ((fx=? i tests))
          (let* ((domain
                  (random-interval))
                 (array
                  (let ((res (make-array domain list)))
                    (case (random-integer 3)
                      ;; immutable
                      ((0) res)
                      ;; specialized
                      ((1) (array-copy res))
                      (else
                       ;; mutable, but not specialized
                       (let ((res (array-copy res)))
                         (make-array domain
                                     (array-getter res)
                                     (array-setter res)))))))
                 (lowers
                  (interval-lower-bounds->vector domain))
                 (uppers
                  (interval-upper-bounds->vector domain))
                 (sidelengths
                  (vector-map (lambda (l u)
                                (let ((dim (- u l)))
                                  (random 1 (ceiling-quotient (* dim 7) 5))))
                              lowers uppers))
                 (result
                  (array-tile array sidelengths))
                 (test-result
                  (my-array-tile array sidelengths)))

            ;; extract-array is tested independently, so we just make
            ;; a few tests.

            ;; test all the subdomain tiles are the same
            (test-assert
                (array-every (lambda (r t)
                               (equal? (array-domain r) (array-domain t)))
                             result test-result))
            ;; test that the subarrays are the same type
            (test-assert
                (array-every
                 (lambda (r t)
                   (and
                    (eq? (mutable-array? r) (mutable-array? t))
                    (eq? (mutable-array? r) (mutable-array? array))
                    (eq? (specialized-array? r) (specialized-array? t))
                    (eq? (specialized-array? r) (specialized-array? array))))
                 result test-result))
            ;; test that the first tile has the right values
            (test-assert
                (myarray= (apply (array-getter result)
                                 (make-list (vector-length lowers) 0))
                          (apply (array-getter test-result)
                                 (make-list (vector-length lowers) 0))))
            ))

        (test-error (array-reverse 'a 'a))
        (test-error
         (array-reverse (make-array (make-interval '#(0 0) '#(2 2)) list)
                        'a))
        (test-error
         (array-reverse (make-array (make-interval '#(0 0) '#(2 2)) list)
                        '#(1 0)))
        (test-error
         (array-reverse (make-array (make-interval '#(0 0) '#(2 2)) list)
                        '#(#t)))

        (do ((i 0 (+ i 1)))
            ((= i tests))
          (let* ((domain (random-interval))
                 (Array (let ((temp (make-array domain list)))
                          (case (random-integer 3)
                            ((0) temp)
                            ((1) (array-copy temp))
                            ((2) (let ((temp (array-copy temp)))
                                   (make-array (array-domain temp)
                                               (array-getter temp)
                                               (array-setter temp)))))))
                 (flips (vector-map (lambda (x) (random-boolean))
                                    (make-vector (interval-dimension domain))))
                 (reversed-array (array-reverse Array flips))
                 (my-reversed-array (myarray-reverse Array flips)))

            (if (mutable-array? Array)
                (do ((j 0 (+ j 1)))
                    ((= j 50))
                  (call-with-values
                      (lambda ()
                        (random-multi-index domain))
                    (lambda multi-index
                      (let ((value (random-integer 10000)))
                        (apply (array-setter reversed-array) value multi-index)
                        (apply (array-setter my-reversed-array) value
                               multi-index))))))
            (test-assert (myarray= reversed-array
                                   my-reversed-array))))

        ;; next test that the optional flip? argument is computed correctly.

        (for-each
         (lambda (n)
           (let* ((upper-bounds (make-vector n 2))
                  (lower-bounds (make-vector n 0))
                  (domain (make-interval lower-bounds upper-bounds))
                  (A (array-copy (make-array domain list)))
                  (immutable-A
                   (let ((A (array-copy A))) ;; copy A
                     (make-array domain
                                 (array-getter A))))
                  (mutable-A
                   (let ((A (array-copy A))) ;; copy A
                     (make-array domain
                                 (array-getter A)
                                 (array-setter A))))
                  (flip? (make-vector n #t)))
             (let ((r1 (array-reverse A))
                   (r2 (array-reverse A flip?)))
               (test-assert (and (specialized-array? r1)
                                 (specialized-array? r2)
                                 (myarray= r1 r2))))
             (let ((r1 (array-reverse mutable-A))
                   (r2 (array-reverse mutable-A flip?)))
               (test-assert (and (mutable-array? r1)
                                 (mutable-array? r2)
                                 (myarray= r1 r2))))
             (let ((r1 (array-reverse immutable-A))
                   (r2 (array-reverse immutable-A flip?)))
               (test-assert (and (array? r1)
                                 (array? r2)
                                 (myarray= r1 r2))))))
         (iota 5 1))

        (test-error (array-assign! 'a 'a))
        (test-error
         (array-assign! (make-array (make-interval '#(0 0) '#(1 1)) values) 'a))
        (test-error
         (array-assign! (array-copy (make-array (make-interval '#(0 0) '#(1 1))
                                                values))
                        'a))
        (test-error
         (array-assign! (array-copy (make-array (make-interval '#(0 0) '#(1 1))
                                                values))
                        (make-array (make-interval '#(0 0) '#(2 1)) values)))
        (test-error
         (array-assign! (make-array (make-interval '#(1 2)) list list) ; invalid
                        (make-array (make-interval '#(0 0) '#(2 1)) values)))
        (test-error
         (array-assign! (array-rotate
                         (array-copy (make-array (make-interval '#(2 3))
                                                 list ))
                         1)
                        (make-array (make-interval '#(2 3)) list)))

        (let ( ;; elements in order
              (destination (make-specialized-array (make-interval '#(3 2))))
              ;; not the same interval, but same volume
              (source (array-rotate (make-array (make-interval '#(3 2)) list)
                                    1)))
          (array-assign! destination source)
          (test (array->list destination)
              (array->list source)))
        )

      (test-group "assign/product"
        (do ((d 1 (fx+ d 1)))
            ((= d 6))
          (let* ((unsafe-specialized-destination
                  (make-specialized-array (make-interval (make-vector d 10))
                                          u1-storage-class))
                 (safe-specialized-destination
                  (make-specialized-array (make-interval (make-vector d 10))
                                          u1-storage-class
                                          #t))
                 (mutable-destination
                  (make-array (array-domain safe-specialized-destination)
                              (array-getter safe-specialized-destination)
                              (array-setter safe-specialized-destination)))
                 (source
                  (make-array (array-domain safe-specialized-destination)
                              (lambda args 100)))) ;; not 0 or 1
            (test-error (array-assign! unsafe-specialized-destination source))
            (test-error (array-assign! safe-specialized-destination source))
            (test-error (array-assign! mutable-destination source))))

        (do ((i 0 (fx+ i 1)))
            ((fx=? i tests))
          (let* ((interval
                  (random-interval))
                 (subinterval
                  (random-subinterval interval))
                 (storage-class-and-initializer
                  (random-storage-class-and-initializer))
                 (storage-class
                  (car storage-class-and-initializer))
                 (initializer
                  (cadr storage-class-and-initializer))
                 (specialized-array
                  (array-copy
                   (make-array interval initializer)
                   storage-class))
                 (mutable-array
                  (let ((specialized-array
                         (array-copy
                          (make-array interval initializer)
                          storage-class)))
                    (make-array interval
                                (array-getter specialized-array)
                                (array-setter specialized-array))))
                 (specialized-subarray
                  (array-extract specialized-array subinterval))
                 (mutable-subarray
                  (array-extract mutable-array subinterval))
                 (new-subarray
                  (array-copy
                   (make-array subinterval initializer)
                   storage-class)))
            (array-assign! specialized-subarray new-subarray)
            (array-assign! mutable-subarray new-subarray)
            (test-assert
                (myarray=
                 specialized-array
                 (make-array
                  interval
                  (lambda multi-index
                    (if (apply interval-contains-multi-index? subinterval
                               multi-index)
                        (apply (array-getter new-subarray) multi-index)
                        (apply (array-getter specialized-array) multi-index))))))
            (test-assert
                (myarray=
                 mutable-array
                 (make-array
                  interval
                  (lambda multi-index
                    (if (apply interval-contains-multi-index? subinterval
                               multi-index)
                        (apply (array-getter new-subarray) multi-index)
                        (apply (array-getter mutable-array) multi-index)))))
              )))

        (test-error (make-array (make-interval '#(0 0) '#(10 10)) list 'a))
        (test-error (array-dimension 'a))
        (test-assert
            (array-safe?
             (array-copy (make-array (make-interval '#(0 0) '#(10 10)) list)
                         generic-storage-class
                         #f
                         #t
                         #t)))
        (test-not
         (array-safe?
          (array-copy (make-array (make-interval '#(0 0) '#(10 10)) list)
                      generic-storage-class
                      #f
                      #t
                      #f)))

        (let ((array-builders
               (vector
                (list u1-storage-class
                      (lambda indices (let ((res (random (expt 2 1)))) res))
                      '(a -1))
                (list u8-storage-class
                      (lambda indices (random (expt 2 8)))
                      '(a -1))
                (list u16-storage-class
                      (lambda indices (random (expt 2 16)))
                      '(a -1))
                (list u32-storage-class
                      (lambda indices (random (expt 2 32)))
                      '(a -1))
                (list u64-storage-class
                      (lambda indices (random (expt 2 64)))
                      '(a -1))
                (list s8-storage-class
                      (lambda indices (random (- (expt 2 7))  (expt 2 7)))
                      `(a ,(expt 2 8)))
                (list s16-storage-class
                      (lambda indices (random (- (expt 2 15)) (expt 2 15)))
                      `(a ,(expt 2 16)))
                (list s32-storage-class
                      (lambda indices (random (- (expt 2 31)) (expt 2 31)))
                      `(a ,(expt 2 32)))
                (list s64-storage-class
                      (lambda indices (random (- (expt 2 63)) (expt 2 63)))
                      `(a ,(expt 2 64)))
                (list f32-storage-class
                      (lambda indices (random-real))
                      `(a 1))
                (list f64-storage-class
                      (lambda indices (random-real))
                      `(a 1))
                (list c64-storage-class
                      (lambda indices (make-rectangular (random-real) (random-real)))
                      `(a 1))
                (list c128-storage-class
                      (lambda indices (make-rectangular (random-real) (random-real)))
                      `(a 1))
                )))
          (do ((i 0 (+ i 1)))
              ((= i tests))
            (let* ((domain (random-interval))
                   (builders (vector-ref array-builders
                                         0
                                         #; (random-integer
                                         (vector-length array-builders))
                                         ))
                   (storage-class (car builders))
                   (random-entry (cadr builders))
                   (invalid-entry (list-ref (caddr builders) (random 2)))
                   (Array (array-copy (make-array domain random-entry)
                                      storage-class
                                      #f
                                      #t   ; mutable
                                      #t)) ; safe
                   (getter (array-getter Array))
                   (setter (array-setter Array))
                   (dimension (interval-dimension domain))
                   (valid-args (call-with-values
                                   (lambda ()
                                     (random-multi-index domain))
                                 list)))
              (test-error (apply setter invalid-entry valid-args))
              (set-car! valid-args 'a)
              (test-error (apply getter valid-args))
              (test-error (apply setter 10 valid-args))
              ;; outside the range of any random-interval
              (set-car! valid-args 10000)
              (test-error (apply getter valid-args))
              (test-error (apply setter 10 valid-args))
              (if (< 4 dimension)
                  (begin
                    (set! valid-args (cons 1 valid-args))
                    (test-error (apply getter valid-args))
                    (test-error (apply setter 10 valid-args)))))))

        (test-error (array->list 'a))
        (test-error (list->array 'a 'b))
        (test-error (list->array '(0) 'b))
        (test-error (list->array '(0) (make-interval '#(0) '#(1)) 'a))
        (test-error (list->array '(0) (make-interval '#(0) '#(1))
                                 generic-storage-class 'a))
        (test-error (list->array '(0) (make-interval '#(0) '#(1))
                                 generic-storage-class #t 'a))

        ;; (list->array '(0) (make-interval '#(0) '#(10)))

        (test-error (list->array '(0) (make-interval '#(0) '#(10))))
        (test-error
         (list->array '(a) (make-interval '#(0) '#(1)) u1-storage-class))
        (test-error (list->array '(a) (make-interval '#(10))))

        (let ((array-builders
               (vector
                (list u1-storage-class      (lambda indices (random 0 (expt 2 1))))
                (list u8-storage-class      (lambda indices (random 0 (expt 2 8))))
                (list u16-storage-class     (lambda indices (random 0 (expt 2 16))))
                (list u32-storage-class     (lambda indices (random 0 (expt 2 32))))
                (list u64-storage-class     (lambda indices (random 0 (expt 2 64))))
                (list s8-storage-class
                      (lambda indices (random (- (expt 2 7))  (expt 2 7))))
                (list s16-storage-class
                      (lambda indices (random (- (expt 2 15)) (expt 2 15))))
                (list s32-storage-class
                      (lambda indices (random (- (expt 2 31)) (expt 2 31))))
                (list s64-storage-class
                      (lambda indices (random (- (expt 2 63)) (expt 2 63))))
                (list f32-storage-class
                      (lambda indices (random-real)))
                (list f64-storage-class
                      (lambda indices (random-real)))
                (list c64-storage-class
                      (lambda indices (make-rectangular (random-real) (random-real))))
                (list c128-storage-class
                      (lambda indices (make-rectangular (random-real) (random-real))))
                (list generic-storage-class (lambda indices indices)))))
          (do ((i 0 (+ i 1)))
              ((= i tests))
            (let* ((domain (random-interval))
                   (builders
                    (vector-ref array-builders
                                (random-integer (vector-length array-builders))))
                   (storage-class (car builders))
                   (random-entry (cadr builders))
                   (Array (array-copy (make-array domain random-entry)
                                      storage-class
                                      #f
                                      #t)) ; safe
                   (l (array->list Array))
                   (new-array
                    (list->array l domain storage-class
                                 (zero? (random-integer 2)))))
              (test-assert (myarray= Array new-array)))))

        (test-error (interval-cartesian-product 'a))
        (test-error (interval-cartesian-product (make-interval '#(0) '#(1)) 'a))

        (do ((i 0 (+ i 1)))
            ((= i tests))
          (let* ((intervals
                  (map (lambda (ignore)
                         (random-interval 1 4))
                       (make-list (random 1 3)))))
            (test (apply my-interval-cartesian-product intervals)
                (apply interval-cartesian-product intervals))))

        (let ((test-array (make-array  (make-interval '#(0) '#(1)) list)))
          (test-error (array-outer-product 'a test-array test-array))
          (test-error (array-outer-product append 'a test-array))
          (test-error (array-outer-product append test-array 'a)))

        (do ((i 0 (+ i 1)))
            ((= i tests))
          (let* ((arrays
                  (map (lambda (ignore)
                         (make-array (random-interval 1 5) list))
                       (make-list 2))))
            (test-assert
                (myarray= (apply array-outer-product append arrays)
                          (make-array (apply my-interval-cartesian-product
                                             (map array-domain arrays))
                                      list))))))

      (test-group "reshape tests"
        (specialized-array-default-safe? #t)
        (let ((A-ref
               (array-copy
                (make-array (make-interval '#(10 10))
                            (lambda (i j) (if (= i j) 1 0)))))
              (B-set!
               (array-copy
                (make-array (make-interval '#(10 10))
                            (lambda (i j) (if (= i j) 1 0)))
                u1-storage-class)))
          (do ((i 1 (+ i 1)))
              ((= i 6))
            (test-error (apply array-ref 1 (make-list i 0))))
          (test-error (array-ref A-ref 1))
          (test-error (array-ref A-ref 1 1001))
          (test 1 (array-ref A-ref 4 4))
          (test 0 (array-ref A-ref 4 5))

          (test-error (array-set! 1 1 1))
          (test-error (array-set! B-set!))
          (test-error (array-set! B-set! 2))
          (test-error (array-set! B-set! 2 1))
          (test-error (array-set! B-set! 2 1 1))
          (array-set! B-set! 1 1 2)
          (array-set! B-set! 0 2 2)
          ;;(array-display B-set!)

          (test-error (specialized-array-reshape 'a 1))
          (test-error (specialized-array-reshape A-ref 'a))
          (test-error (specialized-array-reshape A-ref (make-interval '#(5))))
          )

        (let ((array (array-copy (make-array (make-interval '#(2 1 3 1)) list))))
          (test (array->list array)
              (array->list
               (specialized-array-reshape array (make-interval '#(6))))))

        (let ((array (array-copy (make-array (make-interval '#(2 1 3 1)) list))))
          (test (array->list array)
              (array->list
               (specialized-array-reshape array (make-interval '#(3 2))))))

        (let ((array
               (array-reverse
                (array-copy (make-array (make-interval '#(2 1 3 1)) list)))))
          (test (array->list array)
              (array->list
               (specialized-array-reshape array (make-interval '#(6))))))

        (let ((array
               (array-reverse
                (array-copy (make-array (make-interval '#(2 1 3 1)) list)))))
          (test (array->list
                 (specialized-array-reshape array (make-interval '#(3 2))))
              (array->list array)))

        (let ((array
               (array-reverse
                (array-copy (make-array (make-interval '#(2 1 3 1)) list))
                '#(#f #f #f #t))))
          (test (array->list
                 (specialized-array-reshape array (make-interval '#(3 2))))
              (array->list array)))

        (let ((array (array-reverse
                      (array-copy (make-array (make-interval '#(2 1 3 1)) list))
                      '#(#f #f #f #t))))
          (test (array->list
                 (specialized-array-reshape array (make-interval '#(3 1 2))))
              (array->list array)))

        (let ((array (array-reverse
                      (array-copy (make-array (make-interval '#(2 1 3 1)) list))
                      '#(#f #f #f #t))))
          (test (array->list
                 (specialized-array-reshape array (make-interval '#(1 1 1 3 2))))
              (array->list array)))

        (let ((array (array-reverse
                      (array-copy (make-array (make-interval '#(2 1 3 1)) list))
                      '#(#f #f #f #t))))
          (test (array->list
                 (specialized-array-reshape array (make-interval '#(3 2 1 1 1))))
              (array->list array)))

        (let ((array (array-reverse
                      (array-copy (make-array (make-interval '#(2 1 3 1)) list))
                      '#(#f #f #f #t))))
          (test (array->list
                 (specialized-array-reshape array (make-interval '#(3 1 1 2))))
              (array->list array)))

        (let ((array (array-reverse
                      (array-copy (make-array (make-interval '#(2 1 3 1)) list))
                      '#(#f #f #f #t))))
          (test (array->list
                 (specialized-array-reshape array (make-interval '#(3 1 2 1))))
              (array->list array)))

        (let ((array
               (array-sample
                (array-reverse
                 (array-copy (make-array (make-interval '#(2 1 4 1)) list))
                 '#(#f #f #f #t))
                '#(1 1 2 1))))
          (test (array->list
                 (specialized-array-reshape array (make-interval '#(4))))
              (array->list array)))

        (let ((array
               (array-sample
                (array-reverse
                 (array-copy (make-array (make-interval '#(2 1 4 1)) list))
                 '#(#t #f #t #t))
                '#(1 1 2 1))))
          (test (array->list
                 (specialized-array-reshape array (make-interval '#(4))))
              (array->list array)))

        (test-error
         (specialized-array-reshape
          (array-reverse
           (array-copy (make-array (make-interval '#(2 1 3 1)) list))
           '#(#t #f #f #f))
          (make-interval '#(6))))

        (test-error
         (specialized-array-reshape
          (array-reverse
           (array-copy (make-array (make-interval '#(2 1 3 1)) list))
           '#(#t #f #f #f))
          (make-interval '#(3 2))))

        (test-error
         (specialized-array-reshape
          (array-reverse
           (array-copy (make-array (make-interval '#(2 1 3 1)) list))
           '#(#f #f #t #f))
          (make-interval '#(6))))

        (test-error
         (specialized-array-reshape
          (array-reverse
           (array-copy (make-array (make-interval '#(2 1 3 1)) list))
           '#(#f #f #t #t))
          (make-interval '#(3 2))))

        (test-error
         (specialized-array-reshape
          (array-sample
           (array-reverse
            (array-copy (make-array (make-interval '#(2 1 3 1)) list))
            '#(#f #f #f #t))
           '#(1 1 2 1))
          (make-interval '#(4))))

        (test-error
         (specialized-array-reshape
          (array-sample
           (array-reverse
            (array-copy (make-array (make-interval '#(2 1 4 1)) list))
            '#(#f #f #t #t))
           '#(1 1 2 1))
          (make-interval '#(4))))
        )

      (test-group "curry tests"
        (test-assert
            (interval=
             (interval-dilate (make-interval '#(100 100)) '#(1 1) '#(1 1))
             (make-interval '#(1 1) '#(101 101))))

        (test-assert
            (interval=
             (interval-dilate (make-interval '#(100 100)) '#(-1 -1) '#(1 1))
             (make-interval '#(-1 -1) '#(101 101))))

        (test-assert
            (interval=
             (interval-dilate (make-interval '#(100 100))  '#(0 0) '#(-50 -50))
             (make-interval '#(50 50))))

        (test-error
         (interval-dilate (make-interval '#(100 100)) '#(0 0) '#(-500 -50)))

        (let ((a (make-array (make-interval '#(1 1) '#(11 11))
                             (lambda (i j)
                               (if (= i j)
                                   1
                                   0)))))
          (test 1
              ((array-getter a) 3 3))
          (test 0
              ((array-getter a) 2 3)))

        (let ((a (make-array (make-interval '#(0 0) '#(10 10))
                             list)))
          (test '(3 4)
              ((array-getter a) 3 4))
          (let ((curried-a (array-curry a 1)))
            (test '(3 4)
                ((array-getter ((array-getter curried-a) 3)) 4))))

        (test 0.
            ((array-getter sparse-array) 12345 6789))

        (test 0.
            ((array-getter sparse-array) 0 0))

        ((array-setter sparse-array) 1.0 0 0)

        (test 0.
            ((array-getter sparse-array) 12345 6789))

        (test 1.
            ((array-getter sparse-array) 0 0))
        )

      (test-group "misc"
        (let ()
          (define a
            (array-copy
             (make-array (make-interval '#(5 10))
                         list)))
          (define b
            (specialized-array-share
             a
             (make-interval '#(5 5))
             (lambda (i j)
               (values i (+ i j)))))
          ;; Print the \"rows\" of b
          ;; (array-for-each (lambda (row)
          ;;                   (pretty-print (array->list row)))
          ;;                 (array-curry b 1))
  
          ;; which prints
          ;; ((0 0) (0 1) (0 2) (0 3) (0 4))
          ;; ((1 1) (1 2) (1 3) (1 4) (1 5))
          ;; ((2 2) (2 3) (2 4) (2 5) (2 6))
          ;; ((3 3) (3 4) (3 5) (3 6) (3 7))
          ;; ((4 4) (4 5) (4 6) (4 7) (4 8))
          )

        '(let ()
           (define (palindrome? s)
             (let ((n (string-length s)))
               (or (< n 2)
                   (let* ((a
                           ;; an array accessing the characters of s
                           (make-array (make-interval (vector n))
                                       (lambda (i)
                                         (string-ref s i))))
                          (ra
                           ;; the array in reverse order
                           (array-reverse a))
                          (half-domain
                           (make-interval (vector (quotient n 2)))))
                     (array-every
                      char=?
                      ;; the first half of s
                      (array-extract a half-domain)
                      ;; the second half of s
                      (array-extract ra half-domain))))))
           (for-each
            (lambda (s)
              (for-each display
                        (list "(palindrome? \""
                              s
                              "\") => "
                              (palindrome? s)
                              #\newline)))
            '("" "a" "aa" "ab" "aba" "abc" "abba" "abca" "abbc")))

        ;; (let ((greys (pgm-greys test-pgm)))
        ;;   (write-pgm
        ;;    (make-pgm
        ;;     greys
        ;;     (array-map (lambda (p)
        ;;                  (round-and-clip p greys))
        ;;                (array-convolve
        ;;                 (pgm-pixels test-pgm)
        ;;                 sharpen-filter)))
        ;;    "sharper-test.pgm"))

        ;; (let* ((greys (pgm-greys test-pgm))
        ;;        (edge-array
        ;;         (array-copy
        ;;          (array-map
        ;;           abs
        ;;           (array-convolve
        ;;            (pgm-pixels test-pgm)
        ;;            edge-filter))))
        ;;        (max-pixel
        ;;         (array-fold max 0 edge-array))
        ;;        (normalizer
        ;;         (inexact (/ greys max-pixel))))
        ;;   (write-pgm
        ;;    (make-pgm
        ;;     greys
        ;;     (array-map (lambda (p)
        ;;                  (- greys
        ;;                     (round-and-clip (* p normalizer) greys)))
        ;;                edge-array))
        ;;    "edge-test.pgm"))

      
        (let ((m
               (array-copy (make-array (make-interval '#(0 0) '#(40 30))
                                       (lambda (i j) (inexact (+ i j)))))))
          (test 1940. (operator-max-norm m))
          (test 1605. (operator-one-norm m)))

        (let ((image
               (array-copy
                (make-array (make-interval '#(4 4))
                            (lambda (i j)
                              (case i
                                ((0) 1.)
                                ((1) -1.)
                                (else 0.)))))))
          ;; (display "\nInitial image: \n")
          ;; (pretty-print (list (array-domain image)
          ;;                     (array->list image)))
          ;; (hyperbolic-Haar-transform image)
          ;; (display "\nArray of hyperbolic Haar wavelet coefficients: \n")
          ;; (pretty-print (list (array-domain image)
          ;;                     (array->list image)))
          ;; (hyperbolic-Haar-inverse-transform image)
          ;; (display "\nReconstructed image: \n")
          ;; (pretty-print (list (array-domain image)
          ;;                     (array->list image)))
          #f)


        ;; (let ((image
        ;;        (array-copy
        ;;         (make-array (make-interval '#(4 4))
        ;;                     (lambda (i j)
        ;;                       (case i
        ;;                         ((0) 1.)
        ;;                         ((1) -1.)
        ;;                         (else 0.)))))))
        ;;   (display "\nInitial image: \n")
        ;;   (pretty-print (list (array-domain image)
        ;;                       (array->list image)))
        ;;   (Haar-transform image)
        ;;   (display "\nArray of Haar wavelet coefficients: \n")
        ;;   (pretty-print (list (array-domain image)
        ;;                       (array->list image)))
        ;;   (Haar-inverse-transform image)
        ;;   (display "\nReconstructed image: \n")
        ;;   (pretty-print (list (array-domain image)
        ;;                       (array->list image))))

        ;; (define A
        ;;   ;; A Hilbert matrix
        ;;   (array-copy
        ;;    (make-array (make-interval '#(4 4))
        ;;                (lambda (i j)
        ;;                  (/ (+ 1 i j))))))

        ;; (display "\nHilbert matrix:\n\n")
        ;; (array-display A)

        ;; (LU-decomposition A)

        ;; (display "\nLU decomposition of Hilbert matrix:\n\n")

        ;; (array-display A)

        ;; Functions to extract the lower- and upper-triangular
        ;; matrices of the LU decomposition of A.

        ;; (define (L a)
        ;;   (let ((a_ (array-getter a))
        ;;         (d  (array-domain a)))
        ;;     (make-array
        ;;      d
        ;;      (lambda (i j)
        ;;        (cond ((= i j) 1)        ;; diagonal
        ;;              ((> i j) (a_ i j)) ;; below diagonal
        ;;              (else 0))))))      ;; above diagonal

        ;; (define (U a)
        ;;   (let ((a_ (array-getter a))
        ;;         (d  (array-domain a)))
        ;;     (make-array
        ;;      d
        ;;      (lambda (i j)
        ;;        (cond ((<= i j) (a_ i j)) ;; diagonal and above
        ;;              (else 0))))))       ;; below diagonal

        ;; ;; Lower triangular matrix of decomposition of Hilbert matrix
        ;; (array-display (L A))

        ;; ;; Upper triangular matrix of decomposition of Hilbert matrix
        ;; (array-display (U A))

        ;; We'll check that the product of the result of LU
        ;; decomposition of A is again A.

        ;; (define product (matrix-multiply (L A) (U A)))

        ;; (display "\nProduct of lower and upper triangular matrices ")
        ;; (display "of LU decomposition of Hilbert matrix:\n\n")
        ;; (array-display product)

        ;; Examples from
        ;; http://microapl.com/apl_help/ch_020_020_880.htm

        (let ((TABLE1
               (list->array
                '(1 2
                    5 4
                    3 0)
                (make-interval '#(3 2))))
              (TABLE2
               (list->array
                '(6 2 3 4
                    7 0 1 8)
                (make-interval '#(2 4)))))
          (test '(20 2 5 20
                     58 10 19 52
                     18 6 9 12)
              (array->list (inner-product TABLE1 + * TABLE2))))

        (let ((X ;; a "row vector"
               (list->array '(1 3 5 7) (make-interval '#(1 4))))
              (Y ;; a "column vector"
               (list->array '(2 3 6 7) (make-interval '#(4 1)))))
          (test '(2)
              (array->list (inner-product X + (lambda (x y) (if (= x y) 1 0)) Y))))

        ;; (let* ((A (array-copy (make-array (make-interval '#(3 4)) list)))
        ;;        (B (array-sample A '#(2 1))))
        ;;   (test-error
        ;;    (specialized-array-reshape B (make-interval '#(8)))))

        '(let* ((interval-flat (make-interval '#(100 100 4)))
                (interval-2x2  (make-interval '#(100 100 2 2)))
                (A (array-copy (make-array interval-flat
                                           (lambda args (random-integer 5)))))
                (B (array-copy (make-array interval-flat
                                           (lambda args (random-integer 5)))))
                (C (array-copy (make-array interval-flat
                                           (lambda args 0)))))
           (array-for-each
            x2x2-matrix-multiply-into!
            (array-curry (specialized-array-reshape A interval-2x2) 2)
            (array-curry (specialized-array-reshape B interval-2x2) 2)
            (array-curry (specialized-array-reshape C interval-2x2) 2))
           (array-for-each
            (lambda (A B C)
              (array-assign! C (matrix-multiply A B)))
            (array-curry (specialized-array-reshape A interval-2x2) 2)
            (array-curry (specialized-array-reshape B interval-2x2) 2)
            (array-curry (specialized-array-reshape C interval-2x2) 2))
           '(array-display ((array-getter
                             (array-curry
                              (specialized-array-reshape A interval-2x2)
                              2))
                            0 0))
           '(array-display ((array-getter
                             (array-curry
                              (specialized-array-reshape B interval-2x2)
                              2))
                            0 0))
           '(array-display ((array-getter
                             (array-curry
                              (specialized-array-reshape C interval-2x2)
                              2))
                            0 0))

           (let ((a2x2 (make-interval '#(2 2))))
             (array-for-each (lambda (A B C)
                               (x2x2-matrix-multiply-into!
                                (specialized-array-reshape A a2x2)
                                (specialized-array-reshape B a2x2)
                                (specialized-array-reshape C a2x2)))
                             (array-curry A 1)
                             (array-curry B 1)
                             (array-curry C 1))
             (array-for-each (lambda (A B C)
                               (array-assign!
                                (specialized-array-reshape C a2x2)
                                (matrix-multiply
                                 (specialized-array-reshape A a2x2)
                                 (specialized-array-reshape B a2x2))))
                             (array-curry A 1)
                             (array-curry B 1)
                             (array-curry C 1)))

           '(array-display ((array-getter
                             (array-curry
                              (specialized-array-reshape A interval-2x2)
                              2))
                            0 0))
           '(array-display ((array-getter
                             (array-curry
                              (specialized-array-reshape B interval-2x2)
                              2))
                            0 0))
           '(array-display ((array-getter
                             (array-curry
                              (specialized-array-reshape C interval-2x2)
                              2))
                            0 0))
           )
        )

      (test-end)
      )))

;; Homogeneous storage classes

;; Define a storage class with an optimized -copy!
(define-syntax define-storage-class
  (syntax-rules ()
    ((define-storage-class name ref set elt? make len default)
     (define name
       (make-storage-class
        ref set elt? make
        (lambda (to at from start end)
          (let ((limit (min end (+ start (- (len to) at)))))
            (if (<= at start)
                (do ((i at (+ i 1)) (j start (+ j 1)))
                    ((>= j limit))
                  (set to i (ref from j)))
                (do ((i (+ at (- end start 1)) (- i 1)) (j (- limit 1) (- j 1)))
                    ((< j start))
                  (set to i (ref from j))))))
        len default)))))

(define-storage-class s8-storage-class
  s8vector-ref s8vector-set! s8? make-s8vector s8vector-length 0)

(define-storage-class s16-storage-class
  s16vector-ref s16vector-set! s16? make-s16vector s16vector-length 0)

(define-storage-class s32-storage-class
  s32vector-ref s32vector-set! s32? make-s32vector s32vector-length 0)

(define-storage-class s64-storage-class
  s64vector-ref s64vector-set! s64? make-s64vector s64vector-length 0)

(define-storage-class u1-storage-class
  u1vector-ref u1vector-set! u1? make-u1vector u1vector-length 0)

(define-storage-class u8-storage-class
  u8vector-ref u8vector-set! u8? make-u8vector u8vector-length 0)

(define-storage-class u16-storage-class
  u16vector-ref u16vector-set! u16? make-u16vector u16vector-length 0)

(define-storage-class u32-storage-class
  u32vector-ref u32vector-set! u32? make-u32vector u32vector-length 0)

(define-storage-class u64-storage-class
  u64vector-ref u64vector-set! u64? make-u64vector u64vector-length 0)

(define-storage-class f32-storage-class
  f32vector-ref f32vector-set! f32? make-f32vector f32vector-length 0)

(define-storage-class f64-storage-class
  f64vector-ref f64vector-set! f64? make-f64vector f64vector-length 0)

(define-storage-class c64-storage-class
  c64vector-ref c64vector-set! c64? make-c64vector c64vector-length 0)

(define-storage-class c128-storage-class
  c128vector-ref c128vector-set! c128? make-c128vector c128vector-length 0)

;; TODO: implement
(define f8-storage-class #f)
(define f16-storage-class #f)

;; Array transformations

(define (array-copy array . o)
  (assert (array? array))
  (let* ((storage (if (pair? o) (car o) generic-storage-class))
         (o (if (pair? o) (cdr o) '()))
         (new-domain (or (and (pair? o) (car o)) (array-domain array)))
         (o (if (pair? o) (cdr o) '()))
         (mutable? (if (pair? o) (car o) (specialized-array-default-mutable?)))
         (o (if (pair? o) (cdr o) '()))
         (safe? (if (pair? o) (car o) (specialized-array-default-safe?))))
    (assert (and (storage-class? storage) (interval? new-domain)
                 (boolean? mutable?) (boolean? safe?)))
    (let* ((body ((storage-class-maker storage)
                    (interval-volume new-domain)
                    (storage-class-default storage)))
           (coeffs (default-coeffs new-domain))
           (indexer (coeffs->indexer coeffs new-domain))
           (getter (specialized-getter body indexer
                                       (storage-class-getter storage)))
           (setter (specialized-setter body indexer
                                       (storage-class-setter storage)))
           (res (%make-specialized new-domain storage body coeffs indexer
                                   safe? #t #t)))
      (array-assign! res array)
      (unless mutable?
        (%array-setter-set! res #f))
      res)))

(define (array-curry array inner-dimension)
  (call-with-values
      (lambda () (interval-projections (array-domain array) inner-dimension))
    (lambda (outer-domain inner-domain)
      (cond
       ((specialized-array? array)
        (make-array
         outer-domain
         (lambda outer-index
           (specialized-array-share
            array
            inner-domain
            (lambda inner-index
              (apply values (append outer-index inner-index)))))))
       (else
        (make-array
         outer-domain
         (lambda outer-index
           (make-array
            inner-domain
            (lambda inner-index
              (apply array-ref array (append outer-index inner-index)))
            (and
             (mutable-array? array)
             (lambda (val . inner-index)
               (apply array-set! array val (append outer-index inner-index))
               ))))))))))

(define (array-extract array new-domain)
  (assert (and (array? array)
               (interval? new-domain)
               (interval-subset? new-domain (array-domain array))))
  (if (specialized-array? array)
      (specialized-array-share array new-domain values)
      (make-array new-domain (array-getter array) (array-setter array))))

(define (array-tile array sizes)
  (assert (and (array? array)
               (vector? sizes)
               (= (array-dimension array) (vector-length sizes))
               (vector-every exact-integer? sizes)
               (vector-every <= sizes (interval-ub (array-domain array)))))
  (let ((domain (make-interval
                 (vector-map
                  (lambda (lo hi s) (exact (ceiling (/ (- hi lo) s))))
                  (interval-lb (array-domain array))
                  (interval-ub (array-domain array))
                  sizes))))
    (make-array
     domain
     (lambda multi-index
       (array-extract
        array
        (make-interval
         (vector-map
          (lambda (i lo s) (+ lo (* i s)))
          (list->vector multi-index)
          (interval-lb (array-domain array))
          sizes)
         (vector-map
          (lambda (i lo hi s)
            (min hi (+ lo (* (+ i 1) s))))
          (list->vector multi-index)
          (interval-lb (array-domain array))
          (interval-ub (array-domain array))
          sizes)))))))

(define (array-translate array translation)
  (let ((new-domain (interval-translate (array-domain array) translation))
        (translation-ls (vector->list translation)))
    (if (specialized-array? array)
        (specialized-array-share
         array
         new-domain
         (lambda multi-index
           (apply values (map - multi-index translation-ls))))
        (make-array
         new-domain
         (lambda multi-index
           (apply array-ref array (map - multi-index translation-ls)))
         (and (mutable-array? array)
              (lambda (val . multi-index)
                (apply array-set! array val
                       (map - multi-index translation-ls))))))))

(define (permute ls permutation)
  (let ((vec (list->vector ls))
        (len (vector-length permutation)))
    (do ((i (- len 1) (- i 1))
         (res '() (cons (vector-ref vec (vector-ref permutation i)) res)))
        ((< i 0) res))))

(define (inverse-permutation permutation)
  (list->vector
   (map car
        (list-sort (lambda (a b) (< (cdr a) (cdr b)))
                   (map cons
                        (iota (vector-length permutation))
                        (vector->list permutation))))))

(define (array-permute array permutation)
  (assert (permutation? permutation))
  (let ((new-domain (interval-permute (array-domain array) permutation))
        (perm^-1 (inverse-permutation permutation)))
    (if (specialized-array? array)
        (specialized-array-share
         array
         new-domain
         (lambda multi-index
           (let ((perm-index (permute multi-index perm^-1)))
             (apply values perm-index))))
        (make-array
         new-domain
         (lambda multi-index
           (let ((perm-index (permute multi-index perm^-1)))
             (apply array-ref array perm-index)))
         (and (mutable-array? array)
              (lambda (val . multi-index)
                (apply array-set! array val (permute multi-index perm^-1))))))))

(define (array-rotate array dim)
  (let ((left (iota (- (array-dimension array) dim) dim))
        (right (iota dim)))
    (array-permute array (list->vector (append left right)))))

(define (array-reverse array . o)
  (assert (array? array))
  (let ((flip? (if (pair? o) (car o) (make-vector (array-dimension array) #t))))
    (assert (and (vector? flip?)
                 (= (array-dimension array) (vector-length flip?))
                 (vector-every boolean? flip?)))
    (let* ((flips (vector->list flip?))
           (domain (array-domain array))
           (lowers (interval-lower-bounds->list domain))
           (uppers (interval-upper-bounds->list domain))
           (flip-multi-index
            (lambda (multi-index)
              (map (lambda (i flip-i? lo hi)
                     (if flip-i? (- (+ lo hi -1) i) i))
                   multi-index
                   flips
                   lowers
                   uppers))))
      (if (specialized-array? array)
          (specialized-array-share array
                                   domain
                                   (lambda multi-index
                                     (apply values
                                            (flip-multi-index multi-index))))
          (make-array
           domain
           (lambda multi-index
             (apply array-ref array (flip-multi-index multi-index)))
           (and
            (mutable-array? array)
            (lambda (val . multi-index)
              (apply array-set! array val (flip-multi-index multi-index))
              )))))))

(define (array-sample array scales)
  (unless (vector-every zero?
                        (interval-lower-bounds->vector (array-domain array)))
    (error "can only sample an array with zero lower bounds" array))
  (let ((scales-ls (vector->list scales))
        (new-domain (interval-scale (array-domain array) scales)))
    (if (specialized-array? array)
        (specialized-array-share
         array
         new-domain
         (lambda multi-index
           (apply values (map * multi-index scales-ls))))
        (make-array
         new-domain
         (lambda multi-index
           (apply array-ref array (map * multi-index scales-ls)))
         (and
          (mutable-array? array)
          (lambda (val . multi-index)
            (apply array-set! array val (map * multi-index scales-ls))))))))

(define (array-outer-product op array1 array2)
  (assert (and (procedure? op) (array? array1) (array? array2)))
  (make-array (interval-cartesian-product (array-domain array1)
                                          (array-domain array2))
              (let ((getter1 (array-getter array1))
                    (getter2 (array-getter array2))
                    (dim1 (array-dimension array1)))
                (lambda multi-index
                  (op (apply getter1 (take multi-index dim1))
                      (apply getter2 (drop multi-index dim1)))))))

(define (same-dimensions? ls)
  (or (null? ls)
      (null? (cdr ls))
      (and (equal? (array-dimension (car ls)) (array-dimension (cadr ls)))
           (same-dimensions? (cdr ls)))))

(define (same-domains? ls)
  (or (null? ls)
      (null? (cdr ls))
      (and (interval= (array-domain (car ls)) (array-domain (cadr ls)))
           (same-domains? (cdr ls)))))

(define (array-map f array . arrays)
  (make-array (array-domain array)
              (let* ((ls (cons array arrays))
                     (getters (map array-getter ls)))
                (assert (same-dimensions? ls))
                (lambda multi-index
                  (apply f (map (lambda (g) (apply g multi-index)) getters))))))

(define (array-for-each f array . arrays)
  (if (null? arrays)
      (interval-for-each
       (let ((g (array-getter array)))
         (case (array-dimension array)
           ((1)
            (lambda (i) (f (g i))))
           ((2)
            (lambda (i j) (f (g i j))))
           (else
            (lambda multi-index
              (f (apply g multi-index))))))
       (array-domain array))
      (interval-for-each
       (let* ((lower (interval-lower-bounds->list (array-domain array)))
              (ls (cons array arrays))
              (getters
               (cons (array-getter (car ls))
                     (map (lambda (ar)
                            (let ((getter (array-getter ar)))
                              (lambda multi-index
                                (apply getter multi-index))))
                          (cdr ls)))))
         (assert (same-domains? ls))
         (lambda multi-index
           (apply f (map (lambda (g) (apply g multi-index)) getters))))
       (array-domain array))))

(define (array-fold kons knil array)
  (interval-fold (lambda (acc . multi-index)
                   (kons (apply array-ref array multi-index) acc))
                 knil
                 (array-domain array)))

(define (array-fold-right kons knil array)
  (fold-right kons knil (array->list array)))

(define (array-reduce op array)
  (let* ((domain (array-domain array))
         (init-index (interval-lower-bounds->list domain))
         (knil (list 'first-element)))
    (interval-fold
     (lambda (acc . multi-index)
       (if (eq? acc knil)
           (apply array-ref array multi-index)
           (op acc (apply array-ref array multi-index))))
     knil
     domain)))

(define (array-any pred array . arrays)
  (assert (same-dimensions? (cons array arrays)))
  (call-with-current-continuation
   (lambda (return)
     (apply array-for-each
            (lambda args (cond ((apply pred args) => return)))
            #f
            array
            arrays)
     #f)))

(define (array-every pred array . arrays)
  (assert (same-dimensions? (cons array arrays)))
  (call-with-current-continuation
   (lambda (return)
     (interval-fold
      (let ((getters (map array-getter (cons array arrays))))
        (lambda (acc . multi-index)
          (or (apply pred (map (lambda (g) (apply g multi-index)) getters))
              (return #f))))
      #t
      (array-domain array)))))

(define (array->list array)
  (reverse (array-fold cons '() array)))

(define (list->array ls domain . o)
  (let* ((storage (if (pair? o) (car o) generic-storage-class))
         (mutable? (if (and (pair? o) (pair? (cdr o)))
                       (cadr o)
                       (specialized-array-default-mutable?)))
         (safe? (if (and (pair? o) (pair? (cdr o)) (pair? (cddr o)))
                    (car (cddr o))
                    (specialized-array-default-safe?)))
         (res (make-specialized-array domain storage safe?)))
    (assert (and (interval? domain) (storage-class? storage)
                 (boolean? mutable?) (boolean? safe?)))
    (interval-fold
     (lambda (ls . multi-index)
       (apply array-set! res (car ls) multi-index)
       (cdr ls))
     ls
     domain)
    res))

(define (array-assign! destination source)
  (assert (and (mutable-array? destination) (array? source)))
  (let ((getter (array-getter source))
        (setter (array-setter destination)))
    (cond
     ((interval= (array-domain destination) (array-domain source))
      (interval-for-each
       (case (array-dimension destination)
         ((1) (lambda (i) (setter (getter i) i)))
         ((2) (lambda (i j) (setter (getter i j) i j)))
         ((3) (lambda (i j k) (setter (getter i j k) i j k)))
         (else
          (lambda multi-index
            (apply setter (apply getter multi-index) multi-index))))
       (array-domain source)))
     (else
      (assert (and (array-elements-in-order? destination)
                   (equal? (interval-volume (array-domain destination))
                           (interval-volume (array-domain source)))))
      (let* ((ivc (interval-cursor (array-domain destination)))
             (dst-index (interval-cursor-get ivc)))
        (interval-for-each
         (lambda multi-index
           (apply setter (apply getter multi-index) dst-index)
           (interval-cursor-next! ivc))
         (array-domain source)))))
    destination))

(define (reshape-without-copy array new-domain)
  (let* ((domain (array-domain array))
         (orig-indexer (array-indexer array))
         (tmp-indexer (default-indexer new-domain))
         (new-indexer
          (lambda multi-index
            (apply orig-indexer
                   (invert-default-index domain
                                         (apply tmp-indexer multi-index)))))
         (new-coeffs (indexer->coeffs new-indexer new-domain #t))
         (flat-indexer (coeffs->indexer new-coeffs new-domain))
         (new-indexer (coeffs->indexer new-coeffs new-domain))
         (body (array-body array))
         (storage (array-storage-class array))
         (res
          (%make-specialized new-domain storage body new-coeffs flat-indexer
                             (array-safe? array) (array-setter array)
                             (array-adjacent? array))))
    (let ((multi-index (interval-lower-bounds->list domain))
          (orig-default-indexer (default-indexer domain)))
      (let lp ((i 0)
               (ls multi-index))
        (let ((reshaped-index
               (invert-default-index
                new-domain
                (apply orig-default-indexer multi-index))))
          (cond
           ((not (equal? (apply flat-indexer reshaped-index)
                         (apply orig-indexer multi-index)))
            #f)
           ((null? ls)
            res)
           ((= (+ 1 (interval-lower-bound domain i))
               (interval-upper-bound domain i))
            (lp (+ i 1) (cdr ls)))
           (else
            (set-car! ls (+ 1 (car ls)))
            (lp (+ i 1) (cdr ls)))))))))

(define (specialized-array-reshape array new-domain . o)
  (assert (and (specialized-array? array)
               (= (interval-volume (array-domain array))
                  (interval-volume new-domain))))
  (let ((copy-on-failure? (and (pair? o) (car o))))
    (cond
     ((reshape-without-copy array new-domain))
     (copy-on-failure?
      (let ((res (make-specialized-array
                  new-domain
                  (array-storage-class array)
                  (array-safe? array))))
        (array-assign! res array)
        res))
     (else
      (error "can't reshape" array new-domain)))))

;;> The base array definitions of SRFI 179, plus some extra internal
;;> bindings.

(define-library (srfi 179 base)
  (import (scheme base)
          (scheme list)
          (scheme vector)
          (chibi assert))
  (export
   ;; Miscellaneous Functions
   translation? permutation?
   ;; Intervals
   make-interval interval? interval-dimension interval-lb interval-ub
   interval-lower-bound interval-upper-bound interval-lower-bounds->list
   interval-upper-bounds->list interval-lower-bounds->vector
   interval-upper-bounds->vector interval= interval-volume
   interval-subset? interval-contains-multi-index? interval-projections
   interval-for-each interval-dilate interval-intersect
   interval-translate interval-permute interval-rotate
   interval-scale interval-cartesian-product
   ;; Indexing
   indexer->coeffs coeffs->indexer default-indexer default-coeffs
   invert-default-index interval-cursor interval-cursor-next!
   interval-cursor-next interval-cursor-get interval-fold
   ;; Storage Classes
   make-storage-class storage-class? storage-class-getter
   storage-class-setter storage-class-checker storage-class-maker
   storage-class-copier storage-class-length storage-class-default
   generic-storage-class
   ;; Arrays
   make-array array? array-domain array-getter array-dimension
   mutable-array? array-setter specialized-array-default-safe?
   specialized-array-default-mutable? make-specialized-array
   specialized-array? array-storage-class array-indexer array-body
   array-safe? array-coeffs array-adjacent? array-elements-in-order?
   specialized-array-share array-ref array-set!
   %make-specialized %array-setter-set!
   specialized-getter specialized-setter
   )
  (include "base.scm"))
;; char-set:zero-width
(define char-set:zero-width? (lambda (n) (if (< n 68900) (if (< n 12330) (if (< n 6679) (if (< n 1425) (if (< n 1155) (<= 768 n 879) (<= n 1159)) (if (> n 4253) (if (< n 5906) (<= 4957 n 4959) (if (> n 6459) #f (bit-set? (- n 5906) 51654814515775487143066232783390167417190249239197745817200662630546961064292554504203649883705840324554781044118350731330848841429221578063291283522087222079752503303))) (bit-set? (- n 1425) 205510703248794064385799288111379553899177236721844427958663885943912447037636015703722458582080212074964115397630065758419083258557178791291572045390928965000517761101693657384097462852805005223789556257652925846392379688350478539272364567836963922093122354965736916957801582655554045063883899910493538605405067002499688533586876666092658246104323699888852680426382228126850348432897066859954019357227298272892506279761774951117859456904408554199637716442671276335693418641886045354548080235810360809122448516863904652167066224711146510448624096937959409199684953654914585698643427248887519665328616615751486909865868764846766218624841700373624128912795005115413173034267739971653354314214069620902510761561645618122027617911016679702936039677009392664194441428497838216197914975998358752016720492749295864086894236325597101175925631693488402676580351))) (if (> n 7223) (if (< n 8400) (if (< n 7616) (if (< n 7376) #f (if (> n 7417) #f (bit-set? (- n 7376) 3367824654327))) (if (> n 7679) #f (bit-set? (- n 7616) 18158513697557839871))) (if (> n 8432) (if (< n 11647) (<= 11503 n 11505) (if (> n 11775) #f (bit-set? (- n 11647) 680564733683420601898220539676448522241))) (bit-set? (- n 8400) 8587976703))) (bit-set? (- n 6679) 93549288715282589785155353610353886491418033273055579755950049941276640743523826260726496451218508777751751117752658787002603454722245250226862282085717170773295123))) (if (> n 12442) (if (< n 65024) (if (< n 43204) (if (< n 43010) (if (< n 42607) #f (if (> n 42737) #f (bit-set? (- n 42607) 2041694201525630780780248066803074367457))) (if (> n 43052) #f (bit-set? (- n 43010) 4501125726737))) (if (> n 43766) (if (< n 64286) (if (< n 44005) #f (if (> n 44013) #f (bit-set? (- n 44005) 265))) (<= n 64286)) (bit-set? (- n 43204) 15140075821452045156435686692227855958090094076212194752904600649738386873024625209829508281199675047875687625406266463651325109390207641183187724769853784365253770870787))) (if (> n 65071) (if (< n 66422) (if (< n 66272) (<= 66045 n 66045) (<= n 66272)) (if (> n 66426) (if (< n 68325) (if (< n 68097) #f (if (> n 68159) #f (bit-set? (- n 68097) 4863887597560166455))) (<= n 68326)) #t)) (bit-set? (- n 65024) 281470681808895))) (bit-set? (- n 12330) 7788445287802241442795744493830159))) (if (> n 68903) (if (< n 92912) (if (< n 71090) (if (< n 69633) (if (< n 69446) (<= 69291 n 69292) (<= n 69456)) (if (> n 70206) (if (< n 70712) (if (< n 70367) #f (if (> n 70516) #f (bit-set? (- n 70367) 1388177832465565583748880650475847749063413745))) (if (> n 70851) #f (bit-set? (- n 70712) 1178046920456322681183219660472574183234815))) (bit-set? (- n 69633) 31315396710562944755562359524395422889373597990417327292477766884025457959630346593353500376569566606431910948292248640666923116843972687831060900891883862689184984344821761))) (if (> n 71467) (if (< n 72148) (if (< n 71995) (if (< n 71727) #f (if (> n 71738) #f (bit-set? (- n 71727) 3583))) (if (> n 72003) #f (bit-set? (- n 71995) 267))) (if (> n 72345) (if (< n 73459) (if (< n 72752) #f (if (> n 73111) #f (bit-set? (- n 72752) 1495361097625526625570256678500368769738841504996522270098150646281731627800177929801827597371100995086499711))) (<= n 73460)) (bit-set? (- n 72148) 351511567199490659298273789834301951705775336083122752065743))) (bit-set? (- n 71090) 605567007883067350144846792920936979368360383438593457381381338194386513335133428523310644367613386859332205833231))) (if (> n 92982) (if (< n 122880) (if (< n 119143) (if (< n 113821) (if (< n 94031) #f (if (> n 94180) #f (bit-set? (- n 94031) 713623846352979940529143261425908673834647553))) (<= n 113822)) (if (> n 119213) (if (< n 121344) (<= 119362 n 119364) (if (> n 121519) #f (bit-set? (- n 121344) 95779464130560000838435563242757336329136322539159551))) (bit-set? (- n 119143) 2213609288981778792455))) (if (> n 122922) (if (< n 125136) (if (< n 123628) (<= 123184 n 123190) (<= n 123631)) (if (> n 125258) (<= 917760 n 917999) (bit-set? (- n 125136) 10550747216542769741173968540975235199))) (bit-set? (- n 122880) 8641373536127))) (bit-set? (- n 92912) 2342736497361113055263))) #t))))

;; char-set:full-width
(define char-set:full-width? (lambda (n) (if (< n 65504) (if (< n 12880) (if (< n 11035) (if (< n 9193) (if (< n 8986) (<= 4352 n 4447) (if (> n 9002) #f (bit-set? (- n 8986) 98307))) (if (> n 9203) (if (< n 9725) #f (if (> n 10175) #f (bit-set? (- n 9725) 2907443622617266820054333480998780529725701130302280275370007947623808338047781548019528101403890814668593761726693391537327403448664067))) (bit-set? (- n 9193) 1167))) (if (> n 11093) (if (< n 12288) (if (< n 11904) #f (if (> n 12284) #f (bit-set? (- n 11904) 2462024160382423828429811516068427561660749306784056468848805869416245321611661291646414375862022918616033934704639))) (if (> n 12288) (if (< n 12289) #f (if (> n 12879) #f (bit-set? (- n 12289) 31658291388542983835601784359821364092920312042945607229551814400819120094685286422379319320933806533062611154529989222389109195010548367461806701052374837219444518916037017599))) #t)) (bit-set? (- n 11035) 297237575406452739))) (if (> n 19903) (if (< n 44032) (if (< n 42128) (if (< n 19968) (if (< n 19904) #f (if (> n 19967) #f (bit-set? (- n 19904) 0))) (<= n 42124)) (if (> n 42182) (<= 43360 n 43388) #t)) (if (> n 55203) (if (< n 65040) (<= 63744 n 64255) (if (> n 65131) (<= 65281 n 65376) (bit-set? (- n 65040) 4797017504656895971262727167))) #t)) #t)) (if (> n 65510) (if (< n 127183) (if (< n 101632) (if (< n 100344) (if (< n 94208) (if (< n 94176) #f (if (> n 94207) #f (bit-set? (- n 94176) 196639))) (<= n 100343)) (if (> n 100351) (<= 100352 n 101589) (bit-set? (- n 100344) 0))) (if (> n 101640) (if (< n 110960) (if (< n 110592) #f (if (> n 110959) #f (bit-set? (- n 110592) 2201759651238793353935978839989206105180151758945528329367307032632076306562609289056077994868130232108318719))) (if (> n 111355) (<= 126980 n 126980) #t)) #t)) (if (> n 127183) (if (< n 129292) (if (< n 127744) (if (< n 127374) #f (if (> n 127589) #f (bit-set? (- n 127374) 103666862632257055884375554338292758824945695871569254787261145081))) (if (> n 128764) (<= 128992 n 129003) (bit-set? (- n 127744) 22427532355441897097494388929338899236988773969297598703485634661859864729808161736681853448048691489805457651039471569590476931512946609416855878944269320917585568431313760949188816496022192318927601521301355797906472807547744415626581438889327443126299259883097149821600460467129283287639251279166002167807))) (if (> n 129750) (if (< n 196606) (<= 131072 n 196605) (if (> n 196607) (<= 196608 n 262141) (bit-set? (- n 196606) 0))) (bit-set? (- n 129292) 1476937530268593348028592145760648876257390306909878067362834750498663701692341803996798291958154966950849039520561259075909404413382361087))) #t)) #t))))

;; char-set:ambiguous-width
(define char-set:ambiguous-width? (lambda (n) (if (< n 65024) (if (< n 11094) (if (< n 8208) (if (< n 161) #f (if (> n 1105) #f (bit-set? (- n 161) 223052536271667459415678930318905079873549773617932793730641638019059504712673796525524909775020557665956016104500455950219001349342694128220978917003401578883591589344111031259581620889226429090957790179652065257339299797525743429872558723447631104797406273409853160160039741152015049))) (if (> n 8978) (if (< n 9312) #f (if (> n 10111) #f (bit-set? (- n 9312) 6661502700035245041435504908796213048795246635156488431799991666791867984381040418533146610100595617817495711540720281547788461940893726414925833870538641183879792268453003453351317627145210838405747057167482906429027337302253989020846522367))) (bit-set? (- n 8208) 6210072369202835740595918595956453086120179989637780933534686381158779319390650106752194038767228255040840848246999248665204356172037404661019798426289847167202141507582321755409018753079304131847016847989633301370435793517521875833))) (if (> n 11097) (if (< n 57344) (<= 12872 n 12879) (<= n 63743)) #t)) (if (> n 65039) (if (< n 983040) (if (< n 127232) (<= 65533 n 65533) (if (> n 127404) (<= 917760 n 917999) (bit-set? (- n 127232) 11972575780114894207525815562028054143265854222960639))) (if (> n 1048573) (if (< n 1048576) (if (< n 1048574) #f (if (> n 1048575) #f (bit-set? (- n 1048574) 0))) (<= n 1114109)) #t)) #t))))

;; color.scm -- colored output
;; Copyright (c) 2006-2020 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

(define (color->ansi x)
  (case x
    ((bold) "1")
    ((dark) "2")
    ((italic) "3")
    ((underline) "4")

    ((bold-off) "22")
    ((italic-off) "23")
    ((underline-off) "24")

    ((black) "30")
    ((red) "31")
    ((green) "32")
    ((yellow) "33")
    ((blue) "34")
    ((magenta) "35")
    ((cyan) "36")
    ((white) "37")
    ((default-fg) "39")

    ((on-black) "40")
    ((on-red) "41")
    ((on-green) "42")
    ((on-yellow) "43")
    ((on-blue) "44")
    ((on-magenta) "45")
    ((on-cyan) "46")
    ((on-white) "47")
    ((default-bg) "49")))

(define (ansi-escape color)
  (if (string? color)
      color
      (string-append "\x1B;[" (color->ansi color) "m")))

(define color (make-state-variable 'color 'default-fg #f))
(define background (make-state-variable 'background 'default-bg #f))
(define bold (make-state-variable 'bold 'bold-off #f))
(define italic (make-state-variable 'bold 'italic-off #f))
(define underline (make-state-variable 'bold 'underline-off #f))

(define (with-attr var new-attr . args)
  (fn ((orig-attr var))
      (with ((var new-attr))
            (each (ansi-escape new-attr)
                  (each-in-list args)
                  (ansi-escape orig-attr)))))

(define (as-bold . args) (with-attr bold 'bold (each-in-list args)))
(define (as-italic . args) (with-attr italic 'italic (each-in-list args)))
(define (as-underline . args) (with-attr underline 'underline (each-in-list args)))

(define (as-red . args) (with-attr color 'red (each-in-list args)))
(define (as-blue . args) (with-attr color 'blue (each-in-list args)))
(define (as-green . args) (with-attr color 'green (each-in-list args)))
(define (as-cyan . args) (with-attr color 'cyan (each-in-list args)))
(define (as-yellow . args) (with-attr color 'yellow (each-in-list args)))
(define (as-magenta . args) (with-attr color 'magenta (each-in-list args)))
(define (as-white . args) (with-attr color 'white (each-in-list args)))
(define (as-black . args) (with-attr color 'black (each-in-list args)))

(define (on-red . args) (with-attr background 'on-red (each-in-list args)))
(define (on-blue . args) (with-attr background 'on-blue (each-in-list args)))
(define (on-green . args) (with-attr background 'on-green (each-in-list args)))
(define (on-cyan . args) (with-attr background 'on-cyan (each-in-list args)))
(define (on-yellow . args) (with-attr background 'on-yellow (each-in-list args)))
(define (on-magenta . args) (with-attr background 'on-magenta (each-in-list args)))
(define (on-white . args) (with-attr background 'on-white (each-in-list args)))
(define (on-black . args) (with-attr background 'on-black (each-in-list args)))

(define (rgb-escape red-level green-level blue-level bg?)
  (when (not (and (exact-integer? red-level) (<= 0 red-level 5)))
    (error "invalid red-level value" red-level))
  (when (not (and (exact-integer? green-level) (<= 0 green-level 5)))
    (error "invalid green-level value" green-level))
  (when (not (and (exact-integer? blue-level) (<= 0 blue-level 5)))
    (error "invalid blue-level value" blue-level))
  (string-append
   (if bg? "\x1B;[48;5;" "\x1B;[38;5;")
   (number->string (+ (* 36 red-level) (* 6 green-level) blue-level 16))
   "m"))

(define (rgb24-escape red-level green-level blue-level bg?)
  (when (not (and (exact-integer? red-level) (<= 0 red-level 255)))
    (error "invalid red-level value" red-level))
  (when (not (and (exact-integer? green-level) (<= 0 green-level 255)))
    (error "invalid green-level value" green-level))
  (when (not (and (exact-integer? blue-level) (<= 0 blue-level 255)))
    (error "invalid blue-level value" blue-level))
  (string-append
   (if bg? "\x1B;[48;2;" "\x1B;[38;2;")
   (number->string red-level) ";"
   (number->string green-level) ";"
   (number->string blue-level)
   "m"))

(define (as-color red green blue . fmt)
  (with-attr color (rgb-escape red green blue #f) (each-in-list fmt)))

(define (as-true-color red green blue . fmt)
  (with-attr color (rgb24-escape red green blue #f) (each-in-list fmt)))

(define (on-color red green blue . fmt)
  (with-attr background (rgb-escape red green blue #t) (each-in-list fmt)))

(define (on-true-color red green blue . fmt)
  (with-attr background (rgb24-escape red green blue #t) (each-in-list fmt)))

(define-library (srfi 166 unicode)
  (import (scheme base)
          (scheme char)
          (srfi 130)
          (srfi 151)
          (srfi 166 base))
  (export terminal-aware
          string-terminal-width string-terminal-width/wide
          substring-terminal-width substring-terminal-width/wide
          substring-terminal-preserve
          upcased downcased)
  (include "width.scm"
           "unicode.scm"))

(define-library (srfi 166 pretty)
  (import (scheme base)
          (scheme char)
          (scheme write)
          (chibi show shared)
          (srfi 1)
          (srfi 69)
          (srfi 130)
          (srfi 166 base)
          (srfi 166 color))
  (export pretty pretty-shared pretty-simply pretty-with-color)
  (include "pretty.scm"))
;; unicode.scm -- Unicode character width and ANSI escape support
;; Copyright (c) 2006-2020 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

(define (unicode-char-width ch ambiguous-is-wide?)
  (let ((ci (char->integer ch)))
    (cond
     ((char-set:zero-width? ci)
      0)
     ((char-set:full-width? ci)
      2)
     ((and ambiguous-is-wide? (char-set:ambiguous-width? ci))
      2)
     (else
      1))))

(define (string-terminal-width/aux str start end ambiguous-is-wide?)
  (let lp1 ((sc start) (width 0))
    (if (string-cursor>=? sc end)
        width
        (let ((c (string-ref/cursor str sc))
              (sc2 (string-cursor-next str sc)))
          (cond
           ;; ANSI escapes
           ;; TODO: consider maintaining a state machine so the escape
           ;; can be spread across multiple strings (not needed if
           ;; assuming all escapes come from (srfi 166 color)).
           ((and (= 27 (char->integer c)) ; esc
                 (string-cursor<? sc2 end)
                 (eqv? #\[ (string-ref/cursor str sc2)))
            (let lp2 ((sc (string-cursor-forward str sc 2)))
              (cond ((string-cursor>=? sc end) width)
                    ((memv (string-ref/cursor str sc) '(#\m #\newline))
                     (lp1 (string-cursor-next str sc) width))
                    (else (lp2 (string-cursor-next str sc))))))
           ;; fast-path ASCII
           ((char<=? c #\~)
            (lp1 sc2 (+ width 1)))
           ;; unicode
           (else
            (lp1 sc2 (+ width (unicode-char-width c ambiguous-is-wide?)))
            ))))))

(define (cursor-arg str x)
  (if (string-cursor? x) x (string-index->cursor str x)))

;; convert args to cursors internally for efficiency

(define (string-terminal-width str . o)
  (let ((start (cursor-arg str (if (pair? o)
                                   (car o)
                                   (string-cursor-start str))))
        (end (cursor-arg str (if (and (pair? o) (pair? (cdr o)))
                                 (cadr o)
                                 (string-cursor-end str)))))
    (string-terminal-width/aux str start end #f)))

(define (string-terminal-width/wide str . o)
  (let ((start (cursor-arg str (if (pair? o)
                                   (car o)
                                   (string-cursor-start str))))
        (end (cursor-arg str (if (and (pair? o) (pair? (cdr o)))
                                 (cadr o)
                                 (string-cursor-end str)))))
    (string-terminal-width/aux str start end #t)))

(define (substring-terminal-width/aux str lo hi ambiguous-is-wide?)
  (let ((start (string-cursor-start str))
        (end (string-cursor-end str)))
    (let lp1 ((sc start)
              (from (and (negative? lo) start))
              (width 0))
      (if (string-cursor>=? sc end)
          (if from (substring/cursors str from end) str)
          (let ((c (string-ref/cursor str sc)))
            (cond
             ((and (= 27 (char->integer c)) ; esc
                   (string-cursor<? (string-cursor-next str sc) end)
                   (eqv? #\[ (string-ref/cursor
                              str
                              (string-cursor-next str sc))))
              (let lp2 ((sc2 (string-cursor-forward str sc 2)))
                (cond ((string-cursor>=? sc2 end)
                       (lp1 sc2 from width))
                      ((memv (string-ref/cursor str sc2) '(#\m #\newline))
                       (lp1 (string-cursor-next str sc2) from width))
                      (else (lp2 (string-cursor-next str sc2))))))
             (else
              (let ((width2 (+ width
                               (unicode-char-width c ambiguous-is-wide?))))
                (cond
                 ((> width2 hi)
                  (if from
                      (substring/cursors str from sc)
                      ""))
                 ((and (not from) (> width2 lo))
                  (lp1 (string-cursor-next str sc) sc width2))
                 (else
                  (lp1 (string-cursor-next str sc) from width2)
                  ))))))))))

(define (substring-terminal-width str lo hi)
  (substring-terminal-width/aux str lo hi #f))

(define (substring-terminal-width/wide str lo hi)
  (substring-terminal-width/aux str lo hi #t))

;; The BiDi control characters - trimming these would result in the
;; remaining text rendered in the wrong direction.
;; Other characters for consideration would be language tags or
;; interlinear annotation, but use of these is discouraged.
;; Similarly, we might want to preserve the BOM only at the start of
;; text, but this is a file-level encoding mechanism and not likely
;; appropriate to formatting in-memory strings.
(define non-local-controls
  '(#\x061C #\x200E #\x200F #\x202A #\x202B #\x202C
    #\x202D #\x202E #\x2066 #\x2067 #\x2068 #\x2069))

(define (substring-terminal-preserve str)
  (let ((start (string-cursor-start str))
        (end (string-cursor-end str)))
    (let lp1 ((sc start) (escapes '()))
      (if (string-cursor>=? sc end)
          (string-concatenate-reverse escapes)
          (let ((c (string-ref/cursor str sc))
                (sc2 (string-cursor-next str sc)))
            (cond
             ((and (= 27 (char->integer c))
                   (string-cursor<? sc2 end)
                   (eqv? #\[ (string-ref/cursor str sc2)))
              (let lp2 ((sc2 (string-cursor-next str sc2)))
                (if (string-cursor>=? sc2 end)
                    (string-concatenate-reverse escapes)
                    (let ((c2 (string-ref/cursor str sc2))
                          (sc3 (string-cursor-next str sc2)))
                      (if (eqv? #\m c2)
                          (lp1 sc3
                               (cons (substring/cursors str sc sc3)
                                     escapes))
                          (lp2 sc3))))))
             ((and (memv c non-local-controls))
              (lp1 sc2 (cons (string c) escapes)))
             (else
              (lp1 sc2 escapes))))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define (terminal-aware . args)
  (fn (ambiguous-is-wide?)
    (with ((string-width (if ambiguous-is-wide?
                             string-terminal-width/wide
                             string-terminal-width))
           (substring/width (if ambiguous-is-wide?
                                substring-terminal-width/wide
                                substring-terminal-width))
           (substring/preserve substring-terminal-preserve))
      (each-in-list args))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; String transformations

(define (with-string-transformer proc . ls)
  (fn ((orig-output output))
    (let ((output* (lambda (str) (orig-output (proc str)))))
      (with ((output output*))
        (each-in-list ls)))))

;;> Show each of \var{ls}, uppercasing all generated text.
(define (upcased . ls) (apply with-string-transformer string-upcase ls))

;;> Show each of \var{ls}, lowercasing all generated text.
(define (downcased . ls) (apply with-string-transformer string-downcase ls))
;; pretty.scm -- pretty printing format combinator
;; Copyright (c) 2006-2020 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; utilities

(define (take* ls n)   ; handles dotted lists and n > length
  (cond ((zero? n) '())
        ((pair? ls) (cons (car ls) (take* (cdr ls) (- n 1))))
        (else '())))

(define (drop* ls n)   ; may return the dot
  (cond ((zero? n) ls)
        ((pair? ls) (drop* (cdr ls) (- n 1)))
        (else ls)))

(define (make-space n) (make-string n #\space))
(define (make-nl-space n) (string-append "\n" (make-string n #\space)))

(define (call-with-output-string proc)
  (let ((out (open-output-string)))
    (proc out)
    (let ((res (get-output-string out)))
      (close-output-port out)
      res)))

(define (joined/shares fmt ls shares . o)
  (let ((sep (displayed (if (pair? o) (car o) " "))))
    (fn ()
      (cond
       ((null? ls)
        nothing)
       ((pair? ls)
        (fn ()
          (let lp ((ls ls))
            (each
             (fmt (car ls))
             (let ((rest (cdr ls)))
               (cond
                ((null? rest) nothing)
                ((pair? rest)
                 (call-with-shared-ref/cdr rest
                                           shares
                                           each
                                           (fn () (lp rest))
                                           sep))
                (else (each sep ". " (fmt rest)))))))))
       (else (fmt ls))))))

(define (string-find/index str pred i)
  (string-cursor->index
   str
   (string-index str pred (string-index->cursor str i))))

(define (write-to-string x)
  (call-with-output-string (lambda (out) (write x out))))

(define (try-fitted2 proc fail)
  (fn (width string-width (orig-output output))
    (let ((out (open-output-string)))
      (call-with-current-continuation
       (lambda (abort)
         ;; Modify output to accumulate to an output string port,
         ;; and escape immediately with failure if we exceed the
         ;; column width.
         (define (output* str)
           (fn (col)
             (let lp ((i 0) (col col))
               (let ((nli (string-find/index str #\newline i))
                     (len (string-width str)))
                 (if (< nli len)
                     (if (> (+ (- nli i) col) width)
                         (abort fail)
                         (lp (+ nli 1) 0))
                     (let ((col (+ (- len i) col)))
                       (cond
                        ((> col width)
                         (abort fail))
                        (else
                         (output-default str)))))))))
         (forked
          (with ((output output*)
                 (port out))
            proc)
          ;; fitted successfully
          (fn () (orig-output (get-output-string out)))))))))

(define (try-fitted proc . fail)
  (let lp ((proc proc) (ls fail))
    (if (null? ls)
        proc
        (try-fitted2 proc (lp (car ls) (cdr ls))))))

(define (fits-in-width width proc set-failed!)
  (call-with-current-continuation
   (lambda (abort)
     (fn ((orig-output output))
       (define (output* str)
         (each (orig-output str)
               (fn (col)
                 (if (>= col width)
                     (begin (set-failed! #t) (abort #f))
                     nothing))))
       (with ((output output*))
         proc)))))

(define (fits-in-columns width ls writer set-result!)
  (let ((max-w (quotient width 2)))
    (fn (string-width)
      (let lp ((ls ls) (res '()) (widest 0))
        (cond
         ((pair? ls)
          (let ((failed? #f))
            (call-with-output
             (fits-in-width max-w
                            (writer (car ls))
                            (lambda (x) (set! failed? x)))
             (lambda (str)
               (if failed?
                   (begin
                     (set-result! #f)
                     nothing)
                   (lp (cdr ls)
                       (cons str res)
                       (max (string-width str) widest)))))))
         ((null? ls) (set-result! (cons widest (reverse res))) nothing)
         (else (set-result! #f) nothing))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; style

(define syntax-abbrevs
  '((quote . "'") (quasiquote . "`")
    (unquote . ",") (unquote-splicing . ",@")
    ))

(define (pp-let ls pp shares color?)
  (if (and (pair? (cdr ls)) (symbol? (cadr ls)))
      (pp-with-indent 2 ls pp shares color?)
      (pp-with-indent 1 ls pp shares color?)))

(define indent-rules
  `((lambda . 1) (define . 1) (define-syntax . 1)
    (let . ,pp-let) (loop . ,pp-let)
    (let* . 1) (letrec . 1) (letrec* . 1) (and-let* . 1) (let1 . 2)
    (let-values . 1) (let*-values . 1) (receive . 2) (parameterize . 1)
    (let-syntax . 1) (letrec-syntax . 1) (syntax-rules . 1) (syntax-case . 2)
    (match . 1) (match-let . 1) (match-let* . 1)
    (if . 3) (when . 1) (unless . 1) (case . 1) (while . 1) (until . 1)
    (do . 2) (dotimes . 1) (dolist . 1) (test . 1)
    (condition-case . 1) (guard . 1) (rec . 1)
    (call-with-current-continuation . 0)
    ))

(define indent-prefix-rules
  `(("with-" . -1) ("call-with-" . -1) ("define-" . 1))
  )

(define indent-suffix-rules
  `(("-case" . 1))
  )

(define pp-macros
  (append
   (map car indent-rules)
   '(quote quasiquote unquote unquote-splicing set! cond-expand cond )))

(define (pp-indentation form)
  (let ((indent
         (cond
          ((assq (car form) indent-rules) => cdr)
          ((and (symbol? (car form))
                (let ((str (symbol->string (car form))))
                  (or (find (lambda (rx) (string-prefix? (car rx) str))
                            indent-prefix-rules)
                      (find (lambda (rx) (string-suffix? (car rx) str))
                            indent-suffix-rules))))
           => cdr)
          (else #f))))
    (if (and (number? indent) (negative? indent))
        (max 0 (- (+ (or (length+ form) +inf.0) indent) 1))
        indent)))

(define (with-reset-shares shares proc)
  (let ((orig-count (cdr shares)))
    (fn ()
      (let ((new-count (cdr shares)))
        (when (> new-count orig-count)
          (hash-table-walk
           (car shares)
           (lambda (k v)
             (if (and (cdr v) (>= (car v) orig-count))
                 (set-cdr! v #f))))
          (set-cdr! shares orig-count))
        proc))))

(define (pp-with-indent indent-rule ls pp shares color?)
  (fn ((col1 col))
    (each
     "("
     ((if (and color? (memq (car ls) pp-macros)) as-blue displayed)
      (pp (car ls)))
     (fn ((col2 col) width string-width)
       (let ((fixed (take* (cdr ls) (or indent-rule 1)))
             (tail (drop* (cdr ls) (or indent-rule 1)))
             (default
               (let ((sep (make-nl-space (+ col1 1))))
                 (fn () (each sep (joined/shares pp (cdr ls) shares sep)))))
             ;; reset in case we don't fit on the first line
             (reset-shares (with-reset-shares shares nothing)))
         (call-with-output
          (trimmed/lazy (- width col2)
                        (each (if (or (null? fixed) (pair? fixed)) " " " . ")
                              (joined/shares
                               (lambda (x) (pp-flat x pp shares color?))
                               fixed shares " ")))
          (lambda (first-line)
            (cond
             ((< (+ col2 (string-width first-line)) width)
              ;; fixed values on first line
              (let ((sep (make-nl-space
                          (if indent-rule (+ col1 2) (+ col2 1)))))
                (each first-line
                      (cond
                       ((not (or (null? tail) (pair? tail)))
                        (each ". " (pp tail)))
                       ((> (or (length+ (cdr ls)) +inf.0) (or indent-rule 1))
                        (each sep (joined/shares pp tail shares sep)))
                       (else
                        nothing)))))
             (indent-rule
              ;; fixed values lined up, body indented two spaces
              (try-fitted
               (each
                reset-shares
                " "
                (joined/shares pp fixed shares (make-nl-space (+ col2 1)))
                (if (pair? tail)
                    (let ((sep (make-nl-space (+ col1 2))))
                      (each sep (joined/shares pp tail shares sep)))
                    nothing))
               (each reset-shares default)))
             (else
              ;; all on separate lines
              (each reset-shares default)))))))
     ")")))

(define (pp-app ls pp shares color?)
  (let ((indent-rule (pp-indentation ls)))
    (if (procedure? indent-rule)
        (indent-rule ls pp shares color?)
        (pp-with-indent indent-rule ls pp shares color?))))

;; the elements may be shared, just checking the top level list
;; structure
(define (proper-non-shared-list? ls shares)
  (let ((tab (car shares)))
    (let lp ((ls ls))
      (or (null? ls)
          (and (pair? ls)
               (not (hash-table-ref/default tab ls #f))
               (lp (cdr ls)))))))

(define (non-app? x)
  (if (pair? x)
      (or (not (or (null? (cdr x)) (pair? (cdr x))))
          (non-app? (car x)))
      (not (symbol? x))))

(define (pp-data-list ls pp shares)
  (each
   "("
   (fn (col width string-width)
     (let ((avail (- width col)))
       (cond
        ((and (pair? (cdr ls)) (pair? (cddr ls)) (pair? (cdr (cddr ls))))
         (let ((out (open-output-string))
               (result #f))
           (call-with-output
            (fits-in-columns width ls (lambda (x) (pp-flat x pp shares #f))
                             (lambda (res) (set! result res)))
            (lambda (str)
              (fn ()
                (if (not result)
                    ;; no room, print one per line
                    (joined/shares pp ls shares (make-nl-space col))
                    ;; at least four elements which can be broken into columns
                    (let* ((prefix (make-nl-space col))
                           (widest (+ 1 (car result)))
                           (columns (quotient width widest))) ; always >= 2
                      (let lp ((ls (cdr result)) (i 1))
                        (cond
                         ((null? ls)
                          nothing)
                         ((null? (cdr ls))
                          (displayed (car ls)))
                         ((>= i columns)
                          (each (car ls)
                                prefix
                                (fn () (lp (cdr ls) 1))))
                         (else
                          (let ((pad (- widest (string-width (car ls)))))
                            (each (car ls)
                                  (make-space pad)
                                  (lp (cdr ls) (+ i 1))))))))))))))
        (else
         ;; no room, print one per line
         (joined/shares pp ls shares (make-nl-space col))))))
   ")"))

(define (pp-flat x pp shares color?)
  (define (ppf x)
    (pp-flat x pp shares color?))
  (cond
   ((pair? x)
    (cond
     ((and (pair? (cdr x)) (null? (cddr x))
           (assq (car x) syntax-abbrevs))
      => (lambda (abbrev)
           (each (cdr abbrev)
                 (call-with-shared-ref
                  (cadr x)
                  shares
                  each
                  (pp-flat (cadr x) pp shares color?)))))
     (else
      (fn ()
        (each "("
              ((if (and color? (memq (car x) pp-macros)) as-blue displayed)
               (pp (car x)))
              (if (null? (cdr x))
                  nothing
                  (call-with-shared-ref/cdr
                   (cdr x)
                   shares
                   each
                   (cond
                    ((pair? (cdr x))
                     (each "" (joined/shares ppf (cdr x) shares " ")))
                    (else
                     (each ". " (joined/shares ppf (cdr x) shares " "))))
                   " "))
              ")")))))
   ((vector? x)
    (each "#("
          (joined/shares ppf (vector->list x) shares " ")
          ")"))
   (else
    (pp x))))

(define (pp-pair ls pp shares color?)
  (cond
   ;; one element list, no lines to break
   ((null? (cdr ls))
    (each "(" (pp (car ls)) ")"))
   ;; quote or other abbrev
   ((and (pair? (cdr ls)) (null? (cddr ls))
         (assq (car ls) syntax-abbrevs))
    => (lambda (abbrev)
         (each (cdr abbrev) (pp (cadr ls)))))
   (else
    (let ((reset-shares (with-reset-shares shares nothing)))
      (try-fitted
       (pp-flat ls pp shares color?)
       (each
        reset-shares
        (fn ()
          (if (and (non-app? ls)
                   (proper-non-shared-list? ls shares))
              (pp-data-list ls pp shares)
              (pp-app ls pp shares color?)))))))))

(define (pp-vector vec pp shares)
  (each "#" (pp-data-list (vector->list vec) pp shares)))

;; adapted from `write-with-shares'
(define (pp obj shares color?)
  (fn (radix precision)
    (let ((write-number
           (cond
            ((and (not precision)
                  (assv radix '((16 . "#x") (10 . "") (8 . "#o") (2 . "#b"))))
             => (lambda (cell)
                  (lambda (n)
                    (if (or (exact? n) (eqv? radix 10))
                        (each (cdr cell) (number->string n (car cell)))
                        (with ((radix 10)) (numeric n))))))
            (else (lambda (n) (with ((radix 10)) (numeric n)))))))
      (let pp ((obj obj))
        (call-with-shared-ref
         obj shares each
         (fn ()
           (cond
            ((pair? obj)
             (pp-pair obj pp shares color?))
            ((vector? obj)
             (pp-vector obj pp shares))
            ((number? obj)
             (write-number obj))
            ((and color? (string? obj))
             (as-green (write-to-string obj)))
            (else
             (displayed (write-to-string obj))))))))))

(define (pretty obj)
  (fn ()
    (call-with-output
     (each (pp obj (extract-shared-objects obj #t) #f)
           fl)
     displayed)))

(define (pretty-shared obj)
  (fn ()
    (call-with-output
     (each (pp obj (extract-shared-objects obj #f) #f)
           fl)
     displayed)))

(define (pretty-simply obj)
  (fn ()
    (each (pp obj (extract-shared-objects #f #f) #f)
          fl)))

(define (pretty-with-color obj)
  (fn ()
    (call-with-output
     (each (pp obj (extract-shared-objects obj #t) #t)
           fl)
     displayed)))
;; write.scm - written formatting, the default displayed for non-string/chars
;; Copyright (c) 2006-2019 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;> \section{String utilities}

(define (write-to-string x)
  (call-with-output-string (lambda (out) (write x out))))

(define (string-replace-all str ch1 ch2)
  (let ((out (open-output-string)))
    (string-for-each
     (lambda (ch) (display (if (eqv? ch ch1) ch2 ch) out))
     str)
    (get-output-string out)))

(define (string-intersperse-right str sep rule)
  (let ((start (string-cursor-start str)))
    (let lp ((i (string-cursor-end str))
             (rule rule)
             (res '()))
      (let* ((offset (if (pair? rule) (car rule) rule))
             (i2 (if offset (string-cursor-back str i offset) start)))
        (if (string-cursor<=? i2 start)
            (apply string-append (cons (substring/cursors str start i) res))
            (lp i2
                (if (and (pair? rule) (not (null? (cdr rule)))) (cdr rule) rule)
                (cons sep (cons (substring/cursors str i2 i) res))))))))

;;> Outputs the string str, escaping any quote or escape characters.
;;> If esc-ch, which defaults to #\\, is #f, escapes only the
;;> quote-ch, which defaults to #\", by doubling it, as in SQL strings
;;> and CSV values.  If renamer is provided, it should be a procedure
;;> of one character which maps that character to its escape value,
;;> e.g. #\newline => #\n, or #f if there is no escape value.

(define (escaped fmt . o)
  (let-optionals* o ((quot #\")
                     (esc #\\)
                     (rename (lambda (x) #f)))
    (let ((esc-str (cond ((char? esc) (string esc))
                         ((not esc) (string quot))
                         (else esc))))
      (fn ((orig-output output))
        (define (output* str)
          (let ((start (string-cursor-start str))
                (end (string-cursor-end str)))
            (let lp ((i start) (j start))
              (define (collect)
                (if (eq? i j) "" (substring/cursors str i j)))
              (if (string-cursor>=? j end)
                  (orig-output (collect))
                  (let ((c (string-ref/cursor str j))
                        (j2 (string-cursor-next str j)))
                    (cond
                     ((or (eqv? c quot) (eqv? c esc))
                      (each (orig-output (collect))
                            (orig-output esc-str)
                            (fn () (lp j j2))))
                     ((rename c)
                      => (lambda (c2)
                           (each (orig-output (collect))
                                 (orig-output esc-str)
                                 (orig-output (if (char? c2) (string c2) c2))
                                 (fn () (lp j2 j2)))))
                     (else
                      (lp i j2))))))))
        (with ((output output*))
          fmt)))))

;;> Only escape if there are special characters, in which case also
;;> wrap in quotes.  For writing symbols in |...| escapes, or CSV
;;> fields, etc.  The predicate indicates which characters cause
;;> slashification - this is in addition to automatic slashifying when
;;> either the quote or escape char is present.

(define (maybe-escaped fmt pred . o)
  (let-optionals* o ((quot #\")
                     (esc #\\)
                     (rename (lambda (x) #f)))
    (define (esc? c) (or (eqv? c quot) (eqv? c esc) (rename c) (pred c)))
    (call-with-output
     fmt
     (lambda (str)
       (if (string-cursor<? (string-index str esc?) (string-cursor-end str))
           (each quot (escaped str quot esc rename) quot)
           (displayed str))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; numeric formatting

(define (char-mirror c)
  (case c ((#\() #\)) ((#\[) #\]) ((#\{) #\}) ((#\<) #\>) (else c)))

(define (integer-log a base)
  (if (zero? a)
      0
      ;; (exact (ceiling (/ (log (+ a 1)) (log base))))
      (do ((ndigits 1 (+ ndigits 1))
           (p base (* p base)))
          ((> p a) ndigits))))

;; The original fmt algorithm was based on "Printing Floating-Point
;; Numbers Quickly and Accurately" by Burger and Dybvig
;; (FP-Printing-PLDI96.pdf).  It had grown unwieldy with formatting
;; special cases, so the below is a simplification which tries to rely
;; on number->string for common cases.

(define unspec (list 'unspecified))

(define-syntax default
  (syntax-rules ()
    ((default var dflt) (if (eq? var unspec) dflt var))))

(define (numeric n . o)
  (let-optionals* o ((rad unspec) (prec unspec) (sgn unspec)
                     (comma unspec) (commasep unspec) (decsep unspec))
    (fn (radix precision sign-rule
               comma-rule comma-sep decimal-sep decimal-align)
      (let* ((radix (default rad radix))
             (precision (default prec precision))
             (sign-rule (default sgn sign-rule))
             (comma-rule (default comma comma-rule))
             (comma-sep (default commasep comma-sep))
             (dec-sep (default decsep
                        (or decimal-sep (if (eqv? comma-sep #\.) #\, #\.))))
             (dec-ls (if (char? dec-sep)
                         (list dec-sep)
                         (reverse (string->list dec-sep)))))
        ;; General formatting utilities.
        (define (get-scale q)
          (expt radix (- (integer-log q radix) 1)))
        (define (char-digit d)
          (cond ((char? d) d)
                ((< d 10) (integer->char (+ d (char->integer #\0))))
                (else (integer->char (+ (- d 10) (char->integer #\a))))))
        (define (digit-value ch)
          (let ((res (- (char->integer ch) (char->integer #\0))))
            (if (<= 0 res 9)
                res
                ch)))
        (define (round-up ls)
          (let lp ((ls ls) (res '()))
            (cond
             ((null? ls)
              (append (reverse res) '(1)))
             ((not (number? (car ls)))
              (lp (cdr ls) (cons (car ls) res)))
             ((= (car ls) (- radix 1))
              (lp (cdr ls) (cons 0 res)))
             (else
              (append (reverse res) (cons (+ 1 (car ls)) (cdr ls)))))))
        (define (maybe-round n d ls)
          (let* ((q (quotient n d))
                 (digit (* 2 (if (>= q radix) (quotient q (get-scale q)) q))))
            (if (or (> digit radix)
                    (and (= digit radix)
                         (let ((prev (find integer? ls)))
                           (and prev (odd? prev)))))
                (round-up ls)
                ls)))
        (define (maybe-trim-zeros i res inexact?)
          (if (and (not precision) (positive? i))
              (let lp ((res res))
                (cond
                 ((and (pair? res) (eqv? 0 (car res))) (lp (cdr res)))
                 ((and (pair? res)
                       (eqv? (car dec-ls) (car res))
                       (null? (cdr dec-ls)))
                  (if inexact?
                      (cons 0 res)      ; "1.0"
                      (cdr res)))       ; "1"
                 (else res)))
              res))
        ;; General slow loop to generate digits one at a time, for
        ;; non-standard radixes or writing rationals with a fixed
        ;; precision.
        (define (gen-general n-orig)
          (let* ((p (exact n-orig))
                 (n (numerator p))
                 (d (denominator p)))
            (let lp ((n n)
                     (i (if (zero? p) -1 (- (integer-log p radix))))
                     (res '()))
              (cond
               ;; Use a fixed precision if specified, otherwise generate
               ;; 15 decimals.
               ((if precision (< i precision) (< i 16))
                (let ((res (if (zero? i)
                               (append dec-ls (if (null? res) (cons 0 res) res))
                               res))
                      (q (quotient n d)))
                  (cond
                   ((< i -1)
                    (let* ((scale (expt radix (- -1 i)))
                           (digit (quotient q scale))
                           (n2 (- n (* d digit scale))))
                      (lp n2 (+ i 1) (cons digit res))))
                   (else
                    (lp (* (remainder n d) radix)
                        (+ i 1)
                        (cons q res))))))
               (else
                (reverse-list->string
                 (map char-digit
                      (maybe-trim-zeros i (maybe-round n d res) (inexact? n-orig)))))))))
        ;; Generate a fixed precision decimal result by post-editing the
        ;; result of string->number.
        (define (gen-fixed n)
          (cond
           ((and (eqv? radix 10) (zero? precision) (inexact? n))
            (number->string (exact (round n))))
           ((and (eqv? radix 10) (or (integer? n) (inexact? n)))
            (let* ((s (number->string n))
                   (end (string-cursor-end s))
                   (dec (string-index s #\.))
                   (digits (- (string-cursor->index s end)
                              (string-cursor->index s dec))))
              (cond
               ((string-cursor<? (string-index s #\e) end)
                (gen-general n))
               ((string-cursor=? dec end)
                (string-append s (if (char? dec-sep) (string dec-sep) dec-sep)
                               (make-string precision #\0)))
               ((<= digits precision)
                (string-append s (make-string (- precision digits -1) #\0)))
               (else
                (let* ((last
                        (string-cursor-back s end (- digits precision 1)))
                       (res (substring/cursors s (string-cursor-start s) last)))
                  (if (and
                       (string-cursor<? last end)
                       (let ((next (digit-value (string-ref/cursor s last))))
                         (or (> next 5)
                             (and (= next 5)
                                  (string-cursor>? last (string-cursor-start s))
                                  (memv (digit-value
                                         (string-ref/cursor
                                          s (string-cursor-prev s last)))
                                        '(1 3 5 7 9))))))
                      (reverse-list->string
                       (map char-digit
                            (round-up
                             (reverse
                              (map digit-value (string->list res))))))
                      res))))))
           (else
            (gen-general n))))
        ;; Generate any unsigned real number.
        (define (gen-positive-real n)
          (cond
           (precision
            (gen-fixed n))
           ((memv radix (if (exact? n) '(2 8 10 16) '(10)))
            (number->string n radix))
           (else
            (gen-general n))))
        ;; Insert commas according to the current comma-rule.
        (define (insert-commas str)
          (let* ((dec-pos (if (string? dec-sep)
                              (or (string-contains str dec-sep)
                                  (string-cursor-end str))
                              (string-index str dec-sep)))
                 (left (substring/cursors str (string-cursor-start str) dec-pos))
                 (right (string-copy/cursors str dec-pos))
                 (sep (cond ((char? comma-sep) (string comma-sep))
                            ((string? comma-sep) comma-sep)
                            ((eqv? #\, dec-sep) ".")
                            (else ","))))
            (string-append
             (string-intersperse-right left sep comma-rule)
             right)))
        ;; Post-process a positive real number with decimal char fixup
        ;; and commas as needed.
        (define (wrap-comma n)
          (if (and (not precision) (exact? n) (not (integer? n)))
              (string-append (wrap-comma (numerator n))
                             "/"
                             (wrap-comma (denominator n)))
              (let* ((s0 (gen-positive-real n))
                     (s1 (if (or (eqv? #\. dec-sep)
                                 (equal? "." dec-sep))
                             s0
                             (string-replace-all s0 #\. dec-sep))))
                (if comma-rule (insert-commas s1) s1))))
        ;; Wrap the sign of a real number, forcing a + prefix or using
        ;; parentheses (n) for negatives according to sign-rule.

        (define-syntax is-neg-zero?
          (syntax-rules ()
            ((_ n)
             (is-neg-zero? (-0.0) n))
            ((_ (0.0) n)                ; -0.0 is not distinguished?
             #f)
            ((_ (-0.0) n)
             (eqv? -0.0 n))))
        (define (negative?* n)
          (or (negative? n)
              (is-neg-zero? n)))
        (define (wrap-sign n sign-rule)
          (cond
           ((negative?* n)
            (cond
             ((char? sign-rule)
              (string-append (string sign-rule)
                             (wrap-comma (- n))
                             (string (char-mirror sign-rule))))
             ((pair? sign-rule)
              (string-append (car sign-rule)
                             (wrap-comma (- n))
                             (cdr sign-rule)))
             (else
              (string-append "-" (wrap-comma (- n))))))
           ((eq? #t sign-rule)
            (string-append "+" (wrap-comma n)))
           (else
            (wrap-comma n))))
        ;; Format a single real number with padding as necessary.
        (define (format n sign-rule)
          (cond
           ((finite? n)
            (let* ((s (wrap-sign n sign-rule))
                   (dec-pos (if decimal-align
                                (string-cursor->index
                                 s
                                 (if (char? dec-sep)
                                     (string-index s dec-sep)
                                     (or (string-contains s dec-sep)
                                         (string-cursor-end s))))
                                0))
                   (diff (- (or decimal-align 0) dec-pos 1)))
              (if (positive? diff)
                  (string-append (make-string diff #\space) s)
                  s)))
           (else
            (number->string n))))
        ;; Write any number.
        (define (write-complex n)
          (cond
           ((and radix (not (and (integer? radix) (<= 2 radix 36))))
            (error "invalid radix for numeric formatting" radix))
           ((zero? (imag-part n))
            (displayed (format (real-part n) sign-rule)))
           (else
            (each (format (real-part n) sign-rule)
                  (format (imag-part n) #t)
                  "i"))))
        (write-complex n)))))

(define numeric/si
  (let* ((names10 '#("" "k" "M" "G" "T" "E" "P" "Z" "Y"))
         (names-10 '#("" "m" "" "n" "p" "f" "a" "z" "y"))
         (names2 (list->vector
                  (cons ""
                        (cons "Ki" (map (lambda (s) (string-append s "i"))
                                        (cddr (vector->list names10)))))))
         (names-2 (list->vector
                   (cons ""
                         (map (lambda (s) (string-append s "i"))
                              (cdr (vector->list names-10)))))))
    (define (round-to n k)
      (/ (round (* n k)) k))
    (lambda (n . o)
      (let-optionals* o ((base 1000)
                         (separator ""))
        (if (zero? n)
            "0"
            (let* ((log-n (log (abs n)))
                   (names  (if (negative? log-n)
                               (if (= base 1024) names-2 names-10)
                               (if (= base 1024) names2 names10)))
                   (k (min (exact ((if (negative? log-n) ceiling floor)
                                   (/ (abs log-n) (log base))))
                           (- (vector-length names) 1)))
                   (n2 (round-to (/ (abs n)
                                    (expt base (if (negative? log-n) (- k) k)))
                                 10)))
              (each (if (negative? n) "-" "")
                    (if (integer? n2)
                        (number->string (exact n2))
                        (inexact n2))
                    ;; (if (zero? k) "" separator)
                    separator
                    (vector-ref names k))))))))

;; Force a number into a fixed width, print as #'s if doesn't fit.
;; Needs to be wrapped in PADDED if you want to expand to the width.

(define (numeric/fitted width n . args)
  (call-with-output
   (apply numeric n args)
   (lambda (str)
     (if (> (string-length str) width)
         (fn (precision decimal-sep comma-sep)
           (let ((prec (if (and (pair? args) (pair? (cdr args)))
                           (cadr args)
                           precision)))
             (if (and prec (not (zero? prec)))
                 (let* ((dec-sep
                         (or decimal-sep
                             (if (eqv? #\. comma-sep) #\, #\.)))
                        (diff (- width (+ prec
                                          (if (char? dec-sep)
                                              1
                                              (string-length dec-sep))))))
                   (each (if (positive? diff) (make-string diff #\#) "")
                         dec-sep (make-string prec #\#)))
                 (displayed (make-string width #\#)))))
         (displayed str)))))

(define (numeric/comma n . o)
  (fn ((orig-comma-rule comma-rule))
    (with ((comma-rule (if (pair? o) (car o) (or orig-comma-rule 3))))
      (apply numeric n (if (pair? o) (cdr o) '())))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; written

(define (write-with-shares obj shares)
  (fn ((orig-radix radix) precision)
    (let ((write-number
           ;; Shortcut for numeric values.  Try to rely on
           ;; number->string for standard radixes and no precision,
           ;; otherwise fall back on numeric but resetting to a usable
           ;; radix.
           (cond
            ((and (not precision)
                  (assv orig-radix
                        '((16 . "#x") (10 . "") (8 . "#o") (2 . "#b"))))
             => (lambda (cell)
                  (lambda (n)
                    (cond
                     ((eqv? orig-radix 10)
                      (displayed (number->string n (car cell))))
                     ((exact? n)
                      (each (cdr cell) (number->string n (car cell))))
                     (else
                      (with ((radix 10)) (numeric n)))))))
            (else (lambda (n) (with ((radix 10)) (numeric n)))))))
      ;; `wr' is the recursive writer closing over the shares.
      (let wr ((obj obj))
        (call-with-shared-ref
         obj shares each
         (fn ()
           (cond
            ((pair? obj)
             (each "("
                   (fn ()
                     (let lp ((ls obj))
                       (let ((rest (cdr ls)))
                         (each (wr (car ls))
                               (cond
                                ((null? rest)
                                 nothing)
                                ((pair? rest)
                                 (each
                                  " "
                                  (call-with-shared-ref/cdr
                                   rest shares each
                                   (fn () (lp rest)))))
                                (else
                                 (each " . " (wr rest))))))))
                   ")"))
            ((vector? obj)
             (let ((len (vector-length obj)))
               (if (zero? len)
                   (displayed "#()")
                   (each "#("
                         (wr (vector-ref obj 0))
                         (fn ()
                           (let lp ((i 1))
                             (if (>= i len)
                                 nothing
                                 (each " " (wr (vector-ref obj i))
                                       (fn () (lp (+ i 1)))))))
                         ")"))))
            ((number? obj)
             (write-number obj))
            (else
             (displayed (write-to-string obj))))))))))

;; The default formatter for `written', overriden with the `writer'
;; variable.  Intended to be equivalent to `write', using datum labels
;; for shared notation iff there are cycles in the object.

(define (written-default obj)
  (fn ()
    (write-with-shares obj (extract-shared-objects obj #t))))

;; Writes the object showing the full shared structure.

(define (written-shared obj)
  (fn ()
    (write-with-shares obj (extract-shared-objects obj #f))))

;; The only expensive part, in both time and memory, of handling
;; shared structures when writing is building the initial table, so
;; for the efficient version we just skip that and re-use the writing
;; code.

(define (written-simply obj)
  (fn ()
    (write-with-shares obj (extract-shared-objects #f #f))))

;; Local variables:
;; eval: (put 'fn 'scheme-indent-function 1)
;; End:
;; column.scm -- formatting columns and tables
;; Copyright (c) 2006-2017 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

(define (string-split-words str separator?)
  (let ((start (string-cursor-start str))
        (end (string-cursor-end str)))
    (let lp ((sc start) (res '()))
      (cond
       ((string-cursor>=? sc end)
        (reverse res))
       (else
        (let ((sc2 (string-index str separator? sc)))
          (lp (string-cursor-next str sc2)
              (if (string-cursor=? sc sc2)
                  res
                  (cons (substring/cursors str sc sc2) res)))))))))

(define (call-with-output-generator producer consumer)
  (fn ()
    (let ((out (open-output-string))
          (queue (list-queue))
          (return #f)
          (resume #f))
      (define eof (read-char (open-input-string "")))
      (define (output* str)
        (fn (row col string-width)
          (list-queue-add-back! queue str)
          (each
           (let ((nl-index
                  (string-index-right str (lambda (ch) (eqv? ch #\newline)))))
             (if (string-cursor>? nl-index (string-cursor-start str))
                 (with!
                  (row (+ row (string-count str (lambda (ch) (eqv? ch #\newline)))))
                  (col (string-width str (string-cursor->index str nl-index))))
                 (with! (col (+ col (string-width str))))))
           (call-with-current-continuation
            (lambda (cc)
              (set! resume cc)
              (return nothing))))
          nothing))
      (define (generate)
        (when (and resume (list-queue-empty? queue))
          (call-with-current-continuation
           (lambda (cc)
             (set! return cc)
             (resume nothing))))
        (if (list-queue-empty? queue)
            eof
            (list-queue-remove-front! queue)))
      (forked (fn () (with ((port out) (output output*))
                       (call-with-current-continuation
                        (lambda (cc)
                          (set! return cc)
                          (each producer
                                (fn (output)
                                  (set! resume #f)
                                  (fn () (return nothing) nothing)))))))
              (fn () (consumer generate))))))

(define (call-with-output-generators producers consumer)
  (let lp ((ls producers) (generators '()))
    (if (null? ls)
        (consumer (reverse generators))
        (call-with-output-generator
         (car ls)
         (lambda (generator)
           (lp (cdr ls) (cons generator generators)))))))

(define (string->line-generator source)
  (let ((str '())
        (scanned? #f))
    (define (gen)
      (if (pair? str)
          (if scanned?
              (let ((res (source)))
                (cond
                 ((eof-object? res)
                  (let ((res (string-concatenate (reverse str))))
                    (set! str '())
                    res))
                 ((equal? res "")
                  (gen))
                 (else
                  (set! str (cons res str))
                  (set! scanned? #f)
                  (gen))))
              (let ((nl (string-index (car str) #\newline))
                    (end (string-cursor-end (car str))))
                (cond
                 ((string-cursor<? nl end)
                  (let* ((left (substring/cursors
                                (car str)
                                (string-cursor-start (car str))
                                nl))
                         (right (substring/cursors
                                 (car str)
                                 (string-cursor-next (car str) nl)
                                 end))
                         (res (string-concatenate
                               (reverse (cons left (cdr str))))))
                    (set! str (if (equal? right "") '() (list right)))
                    res))
                 (else
                  (set! scanned? #t)
                  (gen)))))
          (let ((res (source)))
            (cond
             ((eof-object? res)
              res)
             ((equal? res "")
              (gen))
             (else
              (set! str (cons res str))
              (set! scanned? #f)
              (gen))))))
    gen))

(define-record-type Column
  (make-column format generate infinite?)
  column?
  (format column-format)
  (generate column-generate)
  (infinite? column-infinite?))

;; (show-columns (fmt gen [infinite?]) ...)
(define (show-columns . ls)
  (fn ()
    (let* ((cols (map (lambda (x)
                        (make-column (or (car x) displayed)
                                     (displayed (cadr x))
                                     (and (pair? (cddr x)) (car (cddr x)))))
                      ls))
           (num-infinite (count column-infinite? cols)))
      (call-with-output-generators
       (map column-generate cols)
       (lambda (gens)
         (let ((gens (map string->line-generator gens)))
           (let lp ()
             (let* ((lines (map (lambda (gen) (gen)) gens))
                    (num-present (count string? lines)))
               (if (<= num-present num-infinite)
                   nothing
                   (each
                    (each-in-list
                     (map (lambda (col line)
                            ((column-format col)
                             (if (eof-object? line) "" line)))
                          cols
                          lines))
                    "\n"
                    (fn () (lp))))))))))))

;; (columnar ['infinite|'right|'left|'center|width] string-or-formatter ...)
(define (columnar . ls)
  (define (proportional-width? w)
    (and (number? w)
         (or (< 0 w 1)
             (and (inexact? w) (= w 1.0)))))
  (define (build-column ls)
    (let-optionals* ls ((fixed-width #f)
                        (col-width #f)
                        (last? #t)
                        (tail '())
                        (gen #f)
                        (prefix '())
                        (align 'left)
                        (infinite? #f))
      (define (scale-width width)
        (max 1 (exact (truncate (* col-width (- width fixed-width))))))
      (define (padder)
        (if (proportional-width? col-width)
            (case align
              ((right)
               (lambda (str) (fn (width) (padded (scale-width width) str))))
              ((center)
               (lambda (str) (fn (width) (padded/both (scale-width width) str))))
              (else
               (lambda (str) (fn (width) (padded/right (scale-width width) str)))))
            (case align
              ((right) (lambda (str) (padded col-width str)))
              ((center) (lambda (str) (padded/both col-width str)))
              (else (lambda (str) (padded/right col-width str))))))
      (define (affix x)
        (cond
         ((pair? tail)
          (lambda (str)
            (each (each-in-list prefix)
                  (x str)
                  (each-in-list tail))))
         ((pair? prefix)
          (lambda (str) (each (each-in-list prefix) (x str))))
         (else (displayed x))))
      (list
       ;; line formatter
       (affix
        (let ((pad (padder)))
          (if (and last? (not (pair? tail)) (eq? align 'left))
              (lambda (str)
                (fn (pad-char)
                  ((if (or (not pad-char) (char-whitespace? pad-char))
                       displayed
                       pad)
                   str)))
              pad)))
       ;; generator
       (if (proportional-width? col-width)
           (fn ((orig-width width))
             (with ((width (scale-width orig-width)))
               gen))
           (with ((width col-width)) gen))
       infinite?)))
  (define (adjust-widths ls border-width)
    (let* ((fixed-ls
            (filter (lambda (x) (and (number? (car x)) (>= (car x) 1))) ls))
           (fixed-total (fold + border-width (map car fixed-ls)))
           (scaled-ls (filter (lambda (x) (proportional-width? (car x))) ls))
           (denom (- (length ls) (+ (length fixed-ls) (length scaled-ls))))
           (rest (if (zero? denom)
                     0
                     (inexact
                      (/ (- 1 (fold + 0 (map car scaled-ls))) denom)))))
      (if (negative? rest)
          (error "fractional widths must sum to less than 1"
                 (map car scaled-ls)))
      (map
       (lambda (col)
         (cons fixed-total
               (if (not (number? (car col)))
                   (cons rest (cdr col))
                   col)))
       ls)))
  (define (finish ls border-width)
    (apply show-columns
           (map build-column (adjust-widths (reverse ls) border-width))))
  (let lp ((ls ls) (strs '()) (align 'left) (infinite? #f)
           (width #t) (border-width 0) (res '()))
    (cond
     ((null? ls)
      (cond
       ((null? res) nl)
       ((pair? strs)
        (finish (cons (cons (caar res)
                            (cons #t (cons (append (reverse strs)
                                                   (cadr (cdar res)))
                                           (cddr (cdar res)))))
                      (cdr res))
                border-width))
       (else
        (finish (cons (cons (caar res) (cons #t (cddr (car res)))) (cdr res))
                border-width))))
     ((char? (car ls))
      (lp (cons (string (car ls)) (cdr ls)) strs align infinite?
          width border-width res))
     ((string? (car ls))
      (if (string-contains "\n" (car ls))
          (error "column string literals can't contain newlines")
          (lp (cdr ls) (cons (car ls) strs) align infinite?
              width (+ border-width (string-length (car ls))) res)))
     ((number? (car ls))
      (lp (cdr ls) strs align infinite? (car ls) border-width res))
     ((eq? (car ls) 'infinite)
      (lp (cdr ls) strs align #t width border-width res))
     ((symbol? (car ls))
      (lp (cdr ls) strs (car ls) infinite? width border-width res))
     ((procedure? (car ls))
      (lp (cdr ls) '() 'left #f #t border-width
          (cons (list width #f '() (car ls) (reverse strs) align infinite?)
                res)))
     (else
      (error "invalid column" (car ls))))))

(define (max-line-width string-width str)
  (let ((end (string-cursor-end str)))
    (let lp ((i (string-cursor-start str)) (hi 0))
      (let ((j (string-index str #\newline i)))
        (if (string-cursor<? j end)
            (lp (string-cursor-next str j)
                (max hi (string-width (substring/cursors str i j))))
            (max hi (string-width (substring/cursors str i end))))))))

(define (pad-finite proc width string-width k)
  (call-with-output
   proc
   (lambda (str)
     (let ((w (max-line-width (or string-width string-length) str)))
       (k (displayed str)
          (if (and (integer? width) (exact? width))
              (max width w)
              w))))))

(define (tabular . ls)
  (fn (string-width)
    (let lp ((ls ls) (infinite? #f) (width #t) (res '()))
      (cond
       ((null? ls)
        (apply columnar (reverse res)))
       ((number? (car ls))
        (lp (cdr ls) infinite? (car ls) res))
       ((eq? 'infinite (car ls))
        (lp (cdr ls) #t width (cons (car ls) res)))
       ((procedure? (car ls))
        (if infinite?
            (if width
                (lp (cdr ls) #f #t (cons (car ls) (cons width res)))
                (lp (cdr ls) #f #t (cons (car ls) res)))
            (pad-finite (car ls) width string-width
                        (lambda (gen width)
                          (lp (cdr ls) #f #t (cons gen (cons width res)))))))
       (else
        (lp (cdr ls) infinite? width (cons (car ls) res)))))))

;; break lines only, don't join short lines or justify
(define (wrapped/char . ls)
  (fn ((orig-output output) width string-width substring/width)
    (define (kons-in-line str)
      (fn (col)
        (let ((len ((or string-width string-length) str))
              (space (- width col)))
          (cond
           ((equal? "" str)
            nothing)
           ((or (<= len space) (not (positive? space)))
            (each (orig-output str) (orig-output "\n")))
           (else
            (each
             ;; TODO: when splitting by string-width, substring needs
             ;; to be provided
             (orig-output (substring/width str 0 space))
             (orig-output "\n")
             (fn () (kons-in-line (substring/width str space len)))))))))
    (with ((output
            (lambda (str)
              (let ((end (string-cursor-end str)))
                (let lp ((i (string-cursor-start str)))
                  (let ((nli (string-index str #\newline i)))
                    (cond
                     ((string-cursor>=? i end)
                      nothing)
                     ((string-cursor>=? nli end)
                      (kons-in-line (substring/cursors str i end)))
                     (else
                      (each
                       (fn () (kons-in-line (substring/cursors str i nli)))
                       (fn () (lp (string-cursor-next str nli))))))))))))
      (each-in-list ls))))

;; `seq' is a list or vector of pre-tokenized words.  `line' is called
;; on each wrapped line and the accumulator, starting with `knil'.
;; The optional `last-line' is used instead on the last line of the
;; paragraph.
(define (wrap-fold-words seq knil max-width get-width line . o)
  (let* ((last-line (if (pair? o) (car o) line))
         (vec (if (list? seq) (list->vector seq) seq))
         (len (vector-length vec))
         (len-1 (- len 1))
         (breaks (make-vector len #f))
         (penalties (make-vector len #f))
         (widths
          (list->vector
           (map get-width (if (list? seq) seq (vector->list vec))))))
    (define (largest-fit i)
      (let lp ((j (+ i 1)) (width (vector-ref widths i)))
        (let ((width (+ width 1 (vector-ref widths j))))
          (cond
            ((>= width max-width) (- j 1))
            ((>= j len-1) len-1)
            (else (lp (+ j 1) width))))))
    (define (min-penalty! i)
      (cond
        ((>= i len-1) 0)
        ((vector-ref penalties i))
        (else
         (vector-set! penalties i (expt (+ max-width 1) 3))
         (vector-set! breaks i i)
         (let ((k (largest-fit i)))
           (let lp ((j i) (width 0))
             (if (<= j k)
                 (let* ((width (+ width (vector-ref widths j)))
                        (break-penalty
                         (+ (max 0 (expt (- max-width (+ width (- j i))) 3))
                            (min-penalty! (+ j 1)))))
                   (cond
                     ((< break-penalty (vector-ref penalties i))
                      (vector-set! breaks i j)
                      (vector-set! penalties i break-penalty)))
                   (lp (+ j 1) width)))))
         (if (>= (vector-ref breaks i) len-1)
             (vector-set! penalties i 0))
         (vector-ref penalties i))))
    (define (sub-list i j)
      (let lp ((i i) (res '()))
        (if (> i j)
            (reverse res)
            (lp (+ i 1) (cons (vector-ref vec i) res)))))
    (cond
     ((zero? len)
      ;; degenerate case
      (last-line '() knil))
     (else
      ;; compute optimum breaks
      (vector-set! breaks len-1 len-1)
      (vector-set! penalties len-1 0)
      (min-penalty! 0)
      ;; fold
      (let lp ((i 0) (acc knil))
        (let ((break (vector-ref breaks i)))
          (if (>= break len-1)
              (last-line (sub-list i len-1) acc)
              (lp (+ break 1) (line (sub-list i break) acc)))))))))

(define (wrapped/list ls)
  (fn (width string-width pad-char)
    (joined
     (lambda (ls) (joined displayed ls pad-char))
     (reverse
      (wrap-fold-words ls '() width (or string-width string-length) cons))
     "\n")))

(define (wrapped . ls)
  (call-with-output
   (each-in-list ls)
   (lambda (str)
     (fn (word-separator?)
       (wrapped/list
        (string-split-words str (or word-separator? char-whitespace?)))))))

(define (justified . ls)
  (fn (output width string-width)
    (define (justify-line ls)
      (if (null? ls)
          nl
          (let* ((sum (fold (lambda (s n)
                              (+ n ((or string-width string-length) s)))
                            0 ls))
                 (len (length ls))
                 (diff (max 0 (- width sum)))
                 (sep (make-string (if (= len 1)
                                       0
                                       (quotient diff (- len 1)))
                                   #\space))
                 (rem (if (= len 1)
                          diff
                          (remainder diff (- len 1))))
                 (p (open-output-string)))
            (write-string (car ls) p)
            (let lp ((ls (cdr ls)) (i 1))
              (when (pair? ls)
                (write-string sep p)
                (if (<= i rem) (write-char #\space p))
                (write-string (car ls) p)
                (lp (cdr ls) (+ i 1))))
            (displayed (get-output-string p)))))
    (define (justify-last ls)
      (each (joined displayed ls " ") "\n"))
    (call-with-output
     (each-in-list ls)
     (lambda (str)
       (fn (word-separator?)
         (joined/last
          justify-line
          justify-last
          (reverse
           (wrap-fold-words
            (string-split-words str (or word-separator? char-whitespace?))
            '() width (or string-width string-length)
            cons))
          "\n"))))))

(define (from-file path . ls)
  (let-optionals* ls ((sep nl))
    (fn ()
      (let ((in (open-input-file path)))
        (let lp ()
          (let ((line (read-line in)))
            (if (eof-object? line)
                (begin (close-input-port in) nothing)
                (each line sep
                      (fn () (lp))))))))))

(define (line-numbers . o)
  (let ((start (if (pair? o) (car o) 1)))
    (joined/range displayed start #f "\n")))

(define-library (srfi 166 color)
  (import (scheme base) (srfi 130) (srfi 166 base))
  (export
   ;; foreground
   as-red as-blue as-green as-cyan as-yellow
   as-magenta as-white as-black
   as-bold as-italic as-underline
   as-color as-true-color
   ;; background
   on-red on-blue on-green on-cyan on-yellow
   on-magenta on-white on-black
   on-color on-true-color
   )
  (include "color.scm"))

;;> The minimal base formatting combinators and show interface.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define-syntax fn
  (syntax-rules ()
    ((fn . x)
     (computation-fn . x))))

;; The base formatting handles outputting raw strings and a simple,
;; configurable handler for formatting objects.

;; Utility - default value of string-width.
(define (substring-length str . o)
  (let ((start (if (pair? o) (car o) 0))
        (end (if (and (pair? o) (pair? (cdr o))) (cadr o) (string-length str))))
    (- end start)))

(define (call-with-output-string proc)
  (let ((out (open-output-string)))
    (proc out)
    (let ((res (get-output-string out)))
      (close-output-port out)
      res)))

;;> Raw output - displays str to the formatter output port and updates
;;> row and col.
(define (output-default str)
  (fn (port (r row) (c col) string-width)
    (let ((nl-index (string-index-right str #\newline)))
      (write-string str port)
      (if (string-cursor>? nl-index (string-cursor-start str))
          (with! (row (+ r (string-count str (lambda (ch) (eqv? ch #\newline)))))
                 (col (string-width str (string-cursor->index str nl-index))))
          (with! (col (+ c (string-width str))))))))

(define-computation-type make-show-env show-run
  (port (current-output-port))
  (col 0)
  (row 0)
  (width 78)
  (radix 10)
  (pad-char #\space)
  (output output-default)
  (string-width substring-length)
  (substring/width substring)
  (substring/preserve #f)
  (word-separator? char-whitespace?)
  (ambiguous-is-wide? #f)
  (ellipsis "")
  (decimal-align #f)
  (decimal-sep #f)
  (comma-sep #f)
  (comma-rule #f)
  (sign-rule #f)
  (precision #f)
  (writer #f)
  (pretty-environment (interaction-environment))
  )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;> \procedure{(show out [args ...])}
;;>
;;> Run the combinators \var{args}, accumulating the output to
;;> \var{out}, which is either an output port or a boolean, with
;;> \scheme{#t} indicating \scheme{current-output-port} and
;;> \scheme{#f} to collect the output as a string.
(define (show out . args)
  (let ((proc (each-in-list args)))
    (cond
     ((output-port? out)
      (show-run (sequence (with! (port out)) proc)))
     ((eq? #t out)
      (show-run (sequence (with! (port (current-output-port))) proc)))
     ((eq? #f out)
      (call-with-output-string
        (lambda (out)
          (show-run (sequence (with! (port out)) proc)))))
     (else
      (error "unknown output to show" out)))))


;;> Temporarily bind the parameters in the body \var{x}.

(define-syntax with
  (syntax-rules ()
    ((with params x ... y)
     (computation-with params (each x ... y)))))

;;> The noop formatter.  Generates no output and leaves the state
;;> unmodified.
(define nothing (fn () (with!)))

;;> Formats a displayed version of x - if a string or char, outputs the
;;> raw characters (as with `display'), if x is already a formatter
;;> defers to that, otherwise outputs a written version of x.
(define (displayed x)
  (cond
   ((procedure? x) x)
   ((string? x) (fn ((output1 output)) (output1 x)))
   ((char? x) (displayed (string x)))
   (else (written x))))

;;> Formats a written version of x, as with `write'.  The formatting
;;> can be updated with the \scheme{'writer} field.
(define (written x)
  (fn (writer) ((or writer written-default) x)))

;;> Takes a single list of formatters, combined in sequence with
;;> \scheme{each}.
(define (each-in-list args)
  (if (pair? args)
      (if (pair? (cdr args))
          (sequence (displayed (car args)) (each-in-list (cdr args)))
          (fn () (displayed (car args))))
      nothing))

;;> Combines each of the formatters in a sequence using
;;> \scheme{displayed}, so that strings and chars will be output
;;> directly and other objects will be \scheme{written}.
(define (each . args)
  (each-in-list args))

;;> Captures the output of \var{producer} and formats the result with
;;> \var{consumer}.
(define (call-with-output producer consumer)
  (let ((out (open-output-string)))
    (forked (with ((port out) (output output-default)) producer)
            (fn () (consumer (get-output-string out))))))
;; show.scm -- additional combinator formatters
;; Copyright (c) 2013-2020 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

;;> A library of procedures for formatting Scheme objects to text in
;;> various ways, and for easily concatenating, composing and
;;> extending these formatters.

;;> \section{Background}
;;>
;;> There are several approaches to text formatting.  Building strings
;;> to \scheme{display} is not acceptable, since it doesn't scale to
;;> very large output.  The simplest realistic idea, and what people
;;> resort to in typical portable Scheme, is to interleave
;;> \scheme{display} and \scheme{write} and manual loops, but this is
;;> both extremely verbose and doesn't compose well.  A simple concept
;;> such as padding space can't be achieved directly without somehow
;;> capturing intermediate output.
;;>
;;> The traditional approach is to use templates - typically strings,
;;> though in theory any object could be used and indeed Emacs'
;;> mode-line format templates allow arbitrary sexps.  Templates can
;;> use either escape sequences (as in C's \cfun{printf} and
;;> \hyperlink["http://en.wikipedia.org/wiki/Format_(Common_Lisp)"]{CL's}
;;> \scheme{format}) or pattern matching (as in Visual Basic's
;;> \cfun{Format},
;;> \hyperlink["http://search.cpan.org/~dconway/Perl6-Form-0.04/Form.pm"}{Perl6's}
;;> \cfun{form}, and SQL date formats).  The primary disadvantage of
;;> templates is the relative difficulty (usually impossibility) of
;;> extending them, their opaqueness, and the unreadability that
;;> arises with complex formats.  Templates are not without their
;;> advantages, but they are already addressed by other libraries such
;;> as
;;> \hyperlink["http://srfi.schemers.org/srfi-28/srfi-28.html"]{SRFI-28}
;;> and
;;> \hyperlink["http://srfi.schemers.org/srfi-48/srfi-48.html"]{SRFI-48}.
;;>
;;> This library takes a combinator approach.  Formats are nested chains
;;> of closures, which are called to produce their output as needed.
;;> The primary goal of this library is to have, first and foremost, a
;;> maximally expressive and extensible formatting library.  The next
;;> most important goal is scalability - to be able to handle
;;> arbitrarily large output and not build intermediate results except
;;> where necessary.  The third goal is brevity and ease of use.

;;> \section{Interface}

;;> \procedure{(show out [args ...])}
;;>
;;> The primary interface.  Analogous to CL's \scheme{format}, the first
;;> argument is either an output port or a boolean, with \scheme{#t}
;;> indicating \scheme{current-output-port} and \scheme{#f} indicating a
;;> string port.  The remaining arguments are formatters, combined as with
;;> \scheme{each}, run with output to the given destination.  If \var{out}
;;> is \scheme{#f} then the accumulated output is returned, otherwise
;;> the result is unspecified.

;;> \section{Formatters}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Spacing

;;> Output a single newline.
(define nl (displayed "\n"))

;;> "Fresh line" - output a newline iff we're not at the start of a
;;> fresh line.
(define fl
  (fn (col) (if (zero? col) nothing nl)))

;;> Move to a given tab-stop (using spaces, not tabs).
(define (tab-to . o)
  (fn (col pad-char)
    (let* ((tab-width (if (pair? o) (car o) 8))
           (rem (modulo col tab-width)))
      (if (positive? rem)
          (displayed (make-string (- tab-width rem) pad-char))
          nothing))))

;;> Move to an explicit column.
(define (space-to where)
  (fn (col pad-char)
    (displayed (make-string (max 0 (- where col)) pad-char))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Padding and trimming

;;> Pad the result of \scheme{(each-in-list ls)} to at least
;;> \var{width} characters, equally applied to the left and right,
;;> with any extra odd padding applied to the right.  Uses the value
;;> of \scheme{pad-char} for padding, defaulting to \scheme{#\\space}.
(define (padded/both width . ls)
  (call-with-output
   (each-in-list ls)
   (lambda (str)
     (fn (string-width pad-char)
       (let ((diff (- width (string-width str))))
         (if (positive? diff)
             (let* ((diff/2 (quotient diff 2))
                    (left (make-string diff/2 pad-char))
                    (right (if (even? diff)
                               left
                               (make-string (+ 1 diff/2) pad-char))))
               (each left str right))
             (displayed str)))))))

;;> As \scheme{padded/both} but only applies padding on the right.
(define (padded/right width . ls)
  (fn ((col1 col))
    (each (each-in-list ls)
          (fn ((col2 col) pad-char)
            (displayed (make-string (max 0 (- width (- col2 col1)))
                                    pad-char))))))

;;> As \scheme{padded/both} but only applies padding on the left.
(define (padded/left width . ls)
  (call-with-output
   (each-in-list ls)
   (lambda (str)
     (fn (string-width pad-char)
       (let ((diff (- width (string-width str))))
         (each (make-string (max 0 diff) pad-char) str))))))

;;> An alias for \scheme{padded/left}.
(define padded padded/left)

;; General buffered trim - capture the output apply a trimmer.
(define (trimmed/buffered width producer proc)
  (call-with-output
   producer
   (lambda (str)
     (fn (string-width)
       (let* ((str-width (string-width str))
              (diff (- str-width width)))
         (displayed (if (positive? diff)
                        (proc str str-width diff)
                        str)))))))

;;> Trims the result of \scheme{(each-in-list ls)} to at most
;;> \var{width} characters, removed from the right.  If any characters
;;> are removed, then the value of \scheme{ellipsis} (default empty)
;;> is used in its place (trimming additional characters as needed to
;;> be sure the final output doesn't exceed \var{width}).
(define (trimmed/right width . ls)
  (trimmed/buffered
   width
   (each-in-list ls)
   (lambda (str str-width diff)
     (fn (ellipsis string-width substring/width substring/preserve)
       (let* ((ell (if (char? ellipsis) (string ellipsis) (or ellipsis "")))
              (ell-len (string-width ell))
              (diff (- (+ str-width ell-len) width))
              (end (- width ell-len)))
         (each (if substring/preserve
                   (substring/preserve (substring/width str -1 0))
                   nothing)
               (if (negative? diff)
                   nothing
                   (substring/width str 0 end))
               ell
               (if (and substring/preserve (< end str-width))
                   (substring/preserve (substring/width str end str-width))
                   nothing)))))))

;;> As \scheme{trimmed/right} but removes from the left.
(define (trimmed/left width . ls)
  (trimmed/buffered
   width
   (each-in-list ls)
   (lambda (str str-width diff)
     (fn (ellipsis string-width substring/width substring/preserve)
       (let* ((ell (if (char? ellipsis) (string ellipsis) (or ellipsis "")))
              (ell-len (string-width ell))
              (diff (- (+ str-width ell-len) width)))
         (each (if (and substring/preserve (positive? diff))
                   (substring/preserve (substring/width str 0 diff))
                   nothing)
               ell
               (if (negative? diff)
                   nothing
                   (substring/width str diff str-width))))))))

;;> An alias for \scheme{trimmed/left}.
(define trimmed trimmed/left)

;;> As \scheme{trimmed} but removes equally from both the left and the
;;> right, removing extra odd characters from the right, and inserting
;;> \scheme{ellipsis} on both sides.
(define (trimmed/both width . ls)
  (trimmed/buffered
   width
   (each-in-list ls)
   (lambda (str str-width diff)
     (fn (ellipsis string-width substring/width substring/preserve)
       (let* ((ell (if (char? ellipsis) (string ellipsis) (or ellipsis "")))
              (ell-len (string-width ell))
              (diff (- (+ str-width ell-len ell-len) width))
              (left (quotient diff 2))
              (right (- str-width (quotient (+ diff 1) 2))))
         (each
          (if substring/preserve
              (substring/preserve (substring/width str 0 left))
              nothing)
          (if (negative? diff)
              ell
              (each ell (substring/width str left right) ell))
          (if substring/preserve
              (substring/preserve (substring/width str right str-width))
              nothing)))))))

;;> A \scheme{trimmed}, but truncates and terminates immediately if
;;> more than \var{width} characters are generated by \var{ls}.  Thus
;;> \var{ls} may lazily generate an infinite amount of output safely
;;> (e.g. \scheme{write-simple} on an infinite list).  The nature of
;;> this procedure means only truncating on the right is meaningful.
(define (trimmed/lazy width . ls)
  (fn ((orig-output output) string-width substring/width)
    (call-with-current-continuation
     (lambda (return)
       (let ((chars-written 0)
             (orig-output (or orig-output output-default)))
         (define (output* str)
           (let ((len (string-width str)))
             (set! chars-written (+ chars-written len))
             (if (> chars-written width)
                 (let* ((end (max 0 (- len (- chars-written width))))
                        (s (substring/width str 0 end)))
                   (each (orig-output s)
                         (with! (output orig-output))
                         (fn () (return nothing))))
                 (orig-output str))))
         (with ((output output*))
           (each-in-list ls)))))))

;;> Fits the result of \scheme{(each-in-list ls)} to exactly
;;> \var{width} characters, padding or trimming on the right as
;;> needed.
(define (fitted/right width . ls)
  (padded/right width (trimmed/right width (each-in-list ls))))

;;> As \scheme{fitted} but pads/trims from the left.
(define (fitted/left width . ls)
  (padded/left width (trimmed/left width (each-in-list ls))))

;;> An alias for \scheme{fitted/left}.
(define fitted fitted/left)

;;> As \scheme{fitted} but pads/trims equally from both the left and
;;> the right.
(define (fitted/both width . ls)
  (padded/both width (trimmed/both width (each-in-list ls))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Joining and interspersing

(define (joined/general elt-f last-f dot-f init-ls sep)
  (fn ()
    (let lp ((ls init-ls))
      (cond
       ((pair? ls)
        (each (if (eq? ls init-ls) nothing sep)
              ((if (and last-f (null? (cdr ls))) last-f elt-f) (car ls))
              (lp (cdr ls))))
       ((and dot-f (not (null? ls)))
        (each (if (eq? ls init-ls) nothing sep) (dot-f ls)))
       (else
        nothing)))))

;;> \procedure{(joined elt-f ls [sep])}
;;>
;;> Joins the result of applying \var{elt-f} to each element of the
;;> list \var{ls} together with \var{sep}, which defaults to the empty
;;> string.
(define (joined elt-f ls . o)
  (joined/general elt-f #f #f ls (if (pair? o) (car o) "")))

;;> As \scheme{joined} but treats the separator as a prefix, inserting
;;> before every element instead of between.
(define (joined/prefix elt-f ls . o)
  (if (null? ls)
      nothing
      (let ((sep (if (pair? o) (car o) "")))
        (each sep (joined elt-f ls sep)))))

;;> As \scheme{joined} but treats the separator as a suffix, inserting
;;> after every element instead of between.
(define (joined/suffix elt-f ls . o)
  (if (null? ls)
      nothing
      (let ((sep (if (pair? o) (car o) "")))
        (each (joined elt-f ls sep) sep))))

;;> As \scheme{joined} but applies \var{last-f}, instead of
;;> \var{elt-f}, to the last element of \var{ls}, useful for
;;> e.g. commas separating a list with "and" before the final element.
(define (joined/last elt-f last-f ls . o)
  (joined/general elt-f last-f #f ls (if (pair? o) (car o) "")))

;;> As \scheme{joined} but if \var{ls} is a dotted list applies
;;> \var{dot-f} to the dotted tail as a final element.
(define (joined/dot elt-f dot-f ls . o)
  (joined/general elt-f #f dot-f ls (if (pair? o) (car o) "")))

;;> As \scheme{joined} but counts from \var{start} to \var{end}
;;> (exclusive), formatting each integer in the range.  If \var{end}
;;> is \scheme{#f} or unspecified, produces an infinite stream of
;;> output.
(define (joined/range elt-f start . o)
  (let ((end (and (pair? o) (car o)))
        (sep (if (and (pair? o) (pair? (cdr o))) (cadr o) "")))
    (let lp ((i start))
      (if (and end (>= i end))
          nothing
          (each (if (> i start) sep nothing)
                (elt-f i)
                (fn () (lp (+ i 1))))))))
(define-library (srfi 166 test)
  (export run-tests)
  (import (scheme base) (scheme char) (scheme read) (scheme file)
          (only (srfi 1) circular-list)
          (chibi test)
          (srfi 166))
  (begin
    (define-syntax test-pretty
      (syntax-rules ()
        ((test-pretty str)
         (let ((sexp (read (open-input-string str))))
           (test str (show #f (pretty sexp)))))))
    (define (run-tests)
      (test-begin "show")

      ;; basic data types

      (test "hi" (show #f "hi"))
      (test "\"hi\"" (show #f (written "hi")))
      (test "\"hi \\\"bob\\\"\"" (show #f (written "hi \"bob\"")))
      (test "\"hello\\nworld\"" (show #f (written "hello\nworld")))
      (test "#(1 2 3)" (show #f (written '#(1 2 3))))
      (test "(1 2 3)" (show #f (written '(1 2 3))))
      (test "(1 2 . 3)" (show #f (written '(1 2 . 3))))
      (test "ABC" (show #f (upcased "abc")))
      (test "abc" (show #f (downcased "ABC")))

      (test "a    b" (show #f "a" (space-to 5) "b"))
      (test "ab" (show #f "a" (space-to 0) "b"))

      (test "abc     def" (show #f "abc" (tab-to) "def"))
      (test "abc  def" (show #f "abc" (tab-to 5) "def"))
      (test "abcdef" (show #f "abc" (tab-to 3) "def"))
      (test "abc\ndef\n" (show #f "abc" nl "def" nl))
      (test "abc\ndef\n" (show #f "abc" fl "def" nl fl))
      (test "abc\ndef\n" (show #f "abc" fl "def" fl fl))

      (test "ab" (show #f "a" nothing "b"))

      ;; numbers

      (test "-1" (show #f -1))
      (test "0" (show #f 0))
      (test "1" (show #f 1))
      (test "10" (show #f 10))
      (test "100" (show #f 100))
      (test "-1" (show #f (numeric -1)))
      (test "0" (show #f (numeric 0)))
      (test "1" (show #f (numeric 1)))
      (test "10" (show #f (numeric 10)))
      (test "100" (show #f (numeric 100)))
      (test "57005" (show #f #xDEAD))
      (test "#xdead" (show #f (with ((radix 16)) #xDEAD)))
      (test "#xdead1234" (show #f (with ((radix 16)) #xDEAD) 1234))
      (test "de.ad"
          (show #f (with ((radix 16) (precision 2)) (numeric (/ #xDEAD #x100)))))
      (test "d.ead"
          (show #f (with ((radix 16) (precision 3)) (numeric (/ #xDEAD #x1000)))))
      (test "0.dead"
          (show #f (with ((radix 16) (precision 4)) (numeric (/ #xDEAD #x10000)))))
      (test "1g"
          (show #f (with ((radix 17)) (numeric 33))))

      (test "3.14159" (show #f 3.14159))
      (test "3.14" (show #f (with ((precision 2)) 3.14159)))
      (test "3.14" (show #f (with ((precision 2)) 3.14)))
      (test "3.00" (show #f (with ((precision 2)) 3.)))
      (test "1.10" (show #f (with ((precision 2)) 1.099)))
      (test "0.00" (show #f (with ((precision 2)) 1e-17)))
      (test "0.0000000010" (show #f (with ((precision 10)) 1e-9)))
      (test "0.0000000000" (show #f (with ((precision 10)) 1e-17)))
      (test "0.000004" (show #f (with ((precision 6)) 0.000004)))
      (test "0.0000040" (show #f (with ((precision 7)) 0.000004)))
      (test "0.00000400" (show #f (with ((precision 8)) 0.000004)))
      (test "1.00" (show #f (with ((precision 2)) .997554209949891)))
      (test "1.00" (show #f (with ((precision 2)) .99755420)))
      (test "1.00" (show #f (with ((precision 2)) .99755)))
      (test "1.00" (show #f (with ((precision 2)) .997)))
      (test "0.99" (show #f (with ((precision 2)) .99)))
      (test "-15" (show #f (with ((precision 0)) -14.99995999999362)))

      (test "   3.14159" (show #f (with ((decimal-align 5)) (numeric 3.14159))))
      (test "  31.4159" (show #f (with ((decimal-align 5)) (numeric 31.4159))))
      (test " 314.159" (show #f (with ((decimal-align 5)) (numeric 314.159))))
      (test "3141.59" (show #f (with ((decimal-align 5)) (numeric 3141.59))))
      (test "31415.9" (show #f (with ((decimal-align 5)) (numeric 31415.9))))
      (test "  -3.14159" (show #f (with ((decimal-align 5)) (numeric -3.14159))))
      (test " -31.4159" (show #f (with ((decimal-align 5)) (numeric -31.4159))))
      (test "-314.159" (show #f (with ((decimal-align 5)) (numeric -314.159))))
      (test "-3141.59" (show #f (with ((decimal-align 5)) (numeric -3141.59))))
      (test "-31415.9" (show #f (with ((decimal-align 5)) (numeric -31415.9))))

      (test "+inf.0" (show #f +inf.0))
      (test "-inf.0" (show #f -inf.0))
      (test "+nan.0" (show #f +nan.0))
      (test "+inf.0" (show #f (numeric +inf.0)))
      (test "-inf.0" (show #f (numeric -inf.0)))
      (test "+nan.0" (show #f (numeric +nan.0)))

      (cond
       ((exact? (/ 1 3)) ;; exact rationals
        (test "333.333333333333333333333333333333"
            (show #f (with ((precision 30)) (numeric 1000/3))))
        (test  "33.333333333333333333333333333333"
            (show #f (with ((precision 30)) (numeric 100/3))))
        (test   "3.333333333333333333333333333333"
            (show #f (with ((precision 30)) (numeric 10/3))))
        (test   "0.333333333333333333333333333333"
            (show #f (with ((precision 30)) (numeric 1/3))))
        (test   "0.033333333333333333333333333333"
            (show #f (with ((precision 30)) (numeric 1/30))))
        (test   "0.003333333333333333333333333333"
            (show #f (with ((precision 30)) (numeric 1/300))))
        (test   "0.000333333333333333333333333333"
            (show #f (with ((precision 30)) (numeric 1/3000))))
        (test   "0.666666666666666666666666666667"
            (show #f (with ((precision 30)) (numeric 2/3))))
        (test   "0.090909090909090909090909090909"
            (show #f (with ((precision 30)) (numeric 1/11))))
        (test   "1.428571428571428571428571428571"
            (show #f (with ((precision 30)) (numeric 10/7))))
        (test "0.123456789012345678901234567890"
            (show #f (with ((precision 30))
                       (numeric (/  123456789012345678901234567890
                                    1000000000000000000000000000000)))))
        (test  " 333.333333333333333333333333333333"
            (show #f (with ((precision 30) (decimal-align 5)) (numeric 1000/3))))
        (test  "  33.333333333333333333333333333333"
            (show #f (with ((precision 30) (decimal-align 5)) (numeric 100/3))))
        (test  "   3.333333333333333333333333333333"
            (show #f (with ((precision 30) (decimal-align 5)) (numeric 10/3))))
        (test  "   0.333333333333333333333333333333"
            (show #f (with ((precision 30) (decimal-align 5)) (numeric 1/3))))
        ))

      (test "11.75" (show #f (with ((precision 2)) (/ 47 4))))
      (test "-11.75" (show #f (with ((precision 2)) (/ -47 4))))

      (test "(#x11 #x22 #x33)" (show #f (with ((radix 16)) '(#x11 #x22 #x33))))

      (test "299792458" (show #f (with ((comma-rule 3)) 299792458)))
      (test "299,792,458" (show #f (with ((comma-rule 3)) (numeric 299792458))))
      (test "-29,97,92,458"
          (show #f (with ((comma-rule '(3 2))) (numeric -299792458))))
      (test "299.792.458"
          (show #f (with ((comma-rule 3) (comma-sep #\.)) (numeric 299792458))))
      (test "299.792.458,0"
          (show #f (with ((comma-rule 3) (decimal-sep #\,)) (numeric 299792458.0))))

      (test "100,000" (show #f (with ((comma-rule 3)) (numeric 100000))))
      (test "100,000.0"
          (show #f (with ((comma-rule 3) (precision 1)) (numeric 100000))))
      (test "100,000.00"
          (show #f (with ((comma-rule 3) (precision 2)) (numeric 100000))))

      ;; radix argument:
      (test "0" (show #f (numeric 0 2)))
      (test "0" (show #f (numeric 0 10)))
      (test "0" (show #f (numeric 0 36)))

      (test "0.0" (show #f (numeric 0.0 2)))
      (test "0.0" (show #f (numeric 0.0 10)))
      (test "0.0" (show #f (numeric 0.0 36)))

      (test "1" (show #f (numeric 1 2)))
      (test "1" (show #f (numeric 1 10)))
      (test "1" (show #f (numeric 1 36)))

      (test "1.0" (show #f (numeric 1.0 2)))
      (test "1.0" (show #f (numeric 1.0 10)))
      (test "1.0" (show #f (numeric 1.0 36)))

      (test "0" (show #f (numeric 0.0 10 0)))
      (test "0" (show #f (numeric 0.0 9 0)))
      (test "3/4" (show #f (numeric #e.75)))

      (test "0.0000000000000001" (show #f (numeric 1e-25 36)))
      (test "100000000000000000000000000000000000000000000000000000000000000000000000000000000.0"
            (show #f (numeric (expt 2.0 80) 2)))

      ;; numeric, radix=2
      (test "10" (show #f (numeric 2 2)))
      (test "10.0" (show #f (numeric 2.0 2)))
      (test "11/10" (show #f (numeric 3/2 2)))
      (test "1001" (show #f (numeric 9 2)))
      (test "1001.0" (show #f (numeric 9.0 2)))
      (test "1001.01" (show #f (numeric 9.25 2)))

      ;; numeric, radix=3
      (test "11" (show #f (numeric 4 3)))
      (test "10.0" (show #f (numeric 3.0 3)))
      (test "11/10" (show #f (numeric 4/3 3)))
      (test "1001" (show #f (numeric 28 3)))
      (test "1001.0" (show #f (numeric 28.0 3)))
      (test "1001.01" (show #f (numeric #i253/9 3 2)))

      ;; radix 36
      (test "zzz" (show #f (numeric (- (* 36 36 36) 1) 36)))

      ;; Precision:
      (test "1.1250" (show #f (numeric 9/8 10 4)))
      (test "1.125" (show #f (numeric 9/8 10 3)))
      (test "1.12" (show #f (numeric 9/8 10 2)))
      (test "1.1" (show #f (numeric 9/8 10 1)))
      (test "1" (show #f (numeric 9/8 10 0)))

      (test "1.1250" (show #f (numeric #i9/8 10 4)))
      (test "1.125" (show #f (numeric #i9/8 10 3)))
      (test "1.12" (show #f (numeric #i9/8 10 2)))
      (test "1.1" (show #f (numeric #i9/8 10 1)))
      (test "1" (show #f (numeric #i9/8 10 0)))

      (test "1.0"
          (show #f (with ((precision 1)) 0.999999999999876)))
      (test "10.0"
          (show #f (with ((precision 1)) 9.999999999999876)))
      (test "10.0"
          (show #f (numeric 9.999999999999876 10 1)))
      (test "10.00"
          (show #f (numeric 9.999999999999876 10 2)))

      ;; precision-show, base-4
      (test "1.1230" (show #f (numeric 91/64 4 4)))
      (test "1.123" (show #f (numeric 91/64 4 3)))
      (test "1.13" (show #f (numeric 91/64 4 2)))
      (test "1.2" (show #f (numeric 91/64 4 1)))
      (test "1" (show #f (numeric 91/64 4 0)))

      (test "1.1230" (show #f (numeric #i91/64 4 4)))
      (test "1.123" (show #f (numeric #i91/64 4 3)))
      (test "1.13" (show #f (numeric #i91/64 4 2)))
      (test "1.2" (show #f (numeric #i91/64 4 1)))
      (test "1" (show #f (numeric #i91/64 4 0)))

      ;; sign
      (test "+1" (show #f (numeric 1 10 #f #t)))
      (test "+1" (show #f (with ((sign-rule #t)) (numeric 1))))
      (test "(1)" (show #f (with ((sign-rule '("(" . ")"))) (numeric -1))))
      (test "-1" (show #f (with ((sign-rule '("-" . ""))) (numeric -1))))
      (test "1" (show #f (with ((sign-rule '("" . ""))) (numeric -1))))
      (test "-0.0" (show #f (with ((sign-rule #t)) (numeric -0.0))))
      (test "+0.0" (show #f (with ((sign-rule #t)) (numeric +0.0))))

      ;; comma
      (test "1,234,567" (show #f (numeric 1234567 10 #f #f 3)))
      (test "567" (show #f (numeric 567 10 #f #f 3)))
      (test "1,23,45,67" (show #f (numeric 1234567 10 #f #f 2)))
      (test "12,34,567" (show #f (numeric 1234567 10 #f #f '(3 2))))

      ;; comma-sep
      (test "1|234|567" (show #f (numeric 1234567 10 #f #f 3 #\|)))
      (test "1&234&567" (show #f (with ((comma-sep #\&)) (numeric 1234567 10 #f #f 3))))
      (test "1*234*567" (show #f (with ((comma-sep #\&)) (numeric 1234567 10 #f #f 3 #\*))))
      (test "567" (show #f (numeric 567 10 #f #f 3 #\|)))
      (test "1,23,45,67" (show #f (numeric 1234567 10 #f #f 2)))

      ;; decimal
      (test "1_5" (show #f (with ((decimal-sep #\_)) (numeric 1.5))))
      (test "1,5" (show #f (with ((comma-sep #\.)) (numeric 1.5))))
      (test "1,5" (show #f (numeric 1.5 10 #f #f #f #\.)))
      (test "1%5" (show #f (numeric 1.5 10 #f #f #f #\. #\%)))

      (cond-expand
       (complex
        (test "1+2i" (show #f (string->number "1+2i")))
        (test "1.00+2.00i"
            (show #f (with ((precision 2)) (string->number "1+2i"))))
        (test "3.14+2.00i"
            (show #f (with ((precision 2)) (string->number "3.14159+2i"))))))

      (test "608" (show #f (numeric/si 608)))
      (test "608 B" (show #f (numeric/si 608 1000 " ") "B"))
      (test "4k" (show #f (numeric/si 3986)))
      (test "3.9Ki" (show #f (numeric/si 3986 1024)))
      (test "4kB" (show #f (numeric/si 3986 1000) "B"))
      (test "1.2Mm" (show #f (numeric/si 1.23e6 1000) "m"))
      (test "123km" (show #f (numeric/si 1.23e5 1000) "m"))
      (test "12.3km" (show #f (numeric/si 1.23e4 1000) "m"))
      (test "1.2km" (show #f (numeric/si 1.23e3 1000) "m"))
      (test "123m" (show #f (numeric/si 1.23e2 1000) "m"))
      (test "12.3m" (show #f (numeric/si 1.23e1 1000) "m"))
      (test "1.2m" (show #f (numeric/si 1.23 1000) "m"))
      (test "1.2 m" (show #f (numeric/si 1.23 1000 " ") "m"))
      (test "123mm" (show #f (numeric/si 0.123 1000) "m"))
      (test "12.3mm" (show #f (numeric/si 1.23e-2 1000) "m")) ;?
      (test "1.2mm" (show #f (numeric/si 1.23e-3 1000) "m"))
      (test "123m" (show #f (numeric/si 1.23e-4 1000) "m"))  ;?
      (test "12.3m" (show #f (numeric/si 1.23e-5 1000) "m")) ;?
      (test "1.2m" (show #f (numeric/si 1.23e-6 1000) "m"))
      (test "1.2 m" (show #f (numeric/si 1.23e-6 1000 " ") "m"))
      (test "0" (show #f (numeric/si 0)))
      (test "-608" (show #f (numeric/si -608)))
      (test "-4k" (show #f (numeric/si -3986)))

      (test "1,234,567" (show #f (numeric/comma 1234567)))
      (test "1,234,567" (show #f (numeric/comma 1234567 3)))
      (test "123,4567" (show #f (numeric/comma 1234567 4)))

      (test "1.23" (show #f (numeric/fitted 4 1.2345 10 2)))
      (test "1.00" (show #f (numeric/fitted 4 1 10 2)))
      (test "#.##" (show #f (numeric/fitted 4 12.345 10 2)))
      (test "#" (show #f (numeric/fitted 1 12.345 10 0)))

      ;; padding/trimming

      (test "abc  " (show #f (padded/right 5 "abc")))
      (test "  abc" (show #f (padded 5 "abc")))
      (test "abcdefghi" (show #f (padded 5 "abcdefghi")))
      (test " abc " (show #f (padded/both 5 "abc")))
      (test " abc  " (show #f (padded/both 6 "abc")))
      (test "abcde" (show #f (padded/right 5 "abcde")))
      (test "abcdef" (show #f (padded/right 5 "abcdef")))

      (test "abc" (show #f (trimmed/right 3 "abcde")))
      (test "abc" (show #f (trimmed/right 3 "abcd")))
      (test "abc" (show #f (trimmed/right 3 "abc")))
      (test "ab" (show #f (trimmed/right 3 "ab")))
      (test "a" (show #f (trimmed/right 3 "a")))
      (test "abcde" (show #f (trimmed/right 5 "abcdef")))
      (test "abcde" (show #f (trimmed 5 "abcde")))
      (test "cde" (show #f (trimmed 3 "abcde")))
      (test "bcdef" (show #f (trimmed 5 "abcdef")))
      (test "bcd" (show #f (trimmed/both 3 "abcde")))
      (test "abcd" (show #f (trimmed/both 4 "abcde")))
      (test "abcde" (show #f (trimmed/both 5 "abcdef")))
      (test "bcde" (show #f (trimmed/both 4 "abcdef")))
      (test "bcdef" (show #f (trimmed/both 5 "abcdefgh")))
      (test "abc" (show #f (trimmed/lazy 3 "abcde")))
      (test "abc" (show #f (trimmed/lazy 3 "abc\nde")))

      (test "prefix: abc" (show #f "prefix: " (trimmed/right 3 "abcde")))
      (test "prefix: cde" (show #f "prefix: " (trimmed 3 "abcde")))
      (test "prefix: bcd" (show #f "prefix: " (trimmed/both 3 "abcde")))
      (test "prefix: abc" (show #f "prefix: " (trimmed/lazy 3 "abcde")))
      (test "prefix: abc" (show #f "prefix: " (trimmed/lazy 3 "abc\nde")))

      (test "abc :suffix" (show #f (trimmed/right 3 "abcde") " :suffix"))
      (test "cde :suffix" (show #f (trimmed 3 "abcde") " :suffix"))
      (test "bcd :suffix" (show #f (trimmed/both 3 "abcde") " :suffix"))
      (test "abc :suffix" (show #f (trimmed/lazy 3 "abcde") " :suffix"))
      (test "abc :suffix" (show #f (trimmed/lazy 3 "abc\nde") " :suffix"))

      (test "abc" (show #f (trimmed/lazy 10 (trimmed/lazy 3 "abcdefghijklmnopqrstuvwxyz"))))
      (test "abc" (show #f (trimmed/lazy 3 (trimmed/lazy 10 "abcdefghijklmnopqrstuvwxyz"))))

      (test "abcde"
          (show #f (with ((ellipsis "...")) (trimmed/right 5 "abcde"))))
      (test "ab..."
          (show #f (with ((ellipsis "...")) (trimmed/right 5 "abcdef"))))
      (test "abc..."
          (show #f (with ((ellipsis "...")) (trimmed/right 6 "abcdefg"))))
      (test "abcde"
          (show #f (with ((ellipsis "...")) (trimmed 5 "abcde"))))
      (test "...ef"
          (show #f (with ((ellipsis "...")) (trimmed 5 "abcdef"))))
      (test "...efg"
          (show #f (with ((ellipsis "...")) (trimmed 6 "abcdefg"))))
      (test "abcdefg"
          (show #f (with ((ellipsis "...")) (trimmed/both 7 "abcdefg"))))
      (test "...d..."
          (show #f (with ((ellipsis "...")) (trimmed/both 7 "abcdefgh"))))
      (test "...e..."
          (show #f (with ((ellipsis "...")) (trimmed/both 7 "abcdefghi"))))

      (test "abc  " (show #f (fitted/right 5 "abc")))
      (test "  abc" (show #f (fitted 5 "abc")))
      (test " abc " (show #f (fitted/both 5 "abc")))
      (test "abcde" (show #f (fitted/right 5 "abcde")))
      (test "abcde" (show #f (fitted 5 "abcde")))
      (test "abcde" (show #f (fitted/both 5 "abcde")))
      (test "abcde" (show #f (fitted/right 5 "abcdefgh")))
      (test "defgh" (show #f (fitted 5 "abcdefgh")))
      (test "bcdef" (show #f (fitted/both 5 "abcdefgh")))

      (test "prefix: abc   :suffix"
          (show #f "prefix: " (fitted/right 5 "abc") " :suffix"))
      (test "prefix:   abc :suffix"
          (show #f "prefix: " (fitted 5 "abc") " :suffix"))
      (test "prefix:  abc  :suffix"
          (show #f "prefix: " (fitted/both 5 "abc") " :suffix"))
      (test "prefix: abcde :suffix"
          (show #f "prefix: " (fitted/right 5 "abcde") " :suffix"))
      (test "prefix: abcde :suffix"
          (show #f "prefix: " (fitted 5 "abcde") " :suffix"))
      (test "prefix: abcde :suffix"
          (show #f "prefix: " (fitted/both 5 "abcde") " :suffix"))
      (test "prefix: abcde :suffix"
          (show #f "prefix: " (fitted/right 5 "abcdefgh") " :suffix"))
      (test "prefix: defgh :suffix"
          (show #f "prefix: " (fitted 5 "abcdefgh") " :suffix"))
      (test "prefix: bcdef :suffix"
          (show #f "prefix: " (fitted/both 5 "abcdefgh") " :suffix"))

      ;; joining

      (test "1 2 3" (show #f (joined each '(1 2 3) " ")))

      (test ":abc:123"
          (show #f (joined/prefix
                    (lambda (x) (trimmed/right 3 x))
                    '("abcdef" "123456")
                    ":")))

      (test "abc\n123\n"
          (show #f (joined/suffix
                    (lambda (x) (trimmed/right 3 x))
                    '("abcdef" "123456")
                    nl)))

      (test "lions, tigers, and bears"
          (show #f (joined/last
                    each
                    (lambda (x) (each "and " x))
                    '(lions tigers bears)
                    ", ")))

      (test "lions, tigers, or bears"
          (show #f (joined/dot
                    each
                    (lambda (x) (each "or " x))
                    '(lions tigers . bears)
                    ", ")))

      ;; escaping

      (test "hi, bob!" (show #f (escaped "hi, bob!")))
      (test "hi, \\\"bob!\\\"" (show #f (escaped "hi, \"bob!\"")))
      (test "hi, \\'bob\\'" (show #f (escaped "hi, 'bob'" #\')))
      (test "hi, ''bob''" (show #f (escaped "hi, 'bob'" #\' #\')))
      (test "hi, ''bob''" (show #f (escaped "hi, 'bob'" #\' #f)))
      (test "line1\\nline2\\nkapow\\a\\n"
            (show #f (escaped "line1\nline2\nkapow\a\n"
                              #\" #\\
                              (lambda (c) (case c ((#\newline) #\n) ((#\alarm) #\a) (else #f))))))

      (test "bob" (show #f (maybe-escaped "bob" char-whitespace?)))
      (test "\"hi, bob!\""
            (show #f (maybe-escaped "hi, bob!" char-whitespace?)))
      (test "\"foo\\\"bar\\\"baz\"" (show #f (maybe-escaped "foo\"bar\"baz" char-whitespace?)))
      (test "'hi, ''bob'''" (show #f (maybe-escaped "hi, 'bob'" (lambda (c) #f) #\' #f)))
      (test "\\" (show #f (maybe-escaped "\\" (lambda (c) #f) #\' #f)))
      (test "''''" (show #f (maybe-escaped "'" (lambda (c) #f) #\' #f)))

      ;; shared structures

      (test "#0=(1 . #0#)"
          (show #f (written (let ((ones (list 1))) (set-cdr! ones ones) ones))))
      (test "(0 . #0=(1 . #0#))"
          (show #f (written (let ((ones (list 1)))
                              (set-cdr! ones ones)
                              (cons 0 ones)))))
      (test "(sym . #0=(sym . #0#))"
          (show #f (written (let ((syms (list 'sym)))
                              (set-cdr! syms syms)
                              (cons 'sym syms)))))
      (test "(#0=(1 . #0#) #1=(2 . #1#))"
          (show #f (written (let ((ones (list 1))
                                  (twos (list 2)))
                              (set-cdr! ones ones)
                              (set-cdr! twos twos)
                              (list ones twos)))))
      (test "(#0=(1 . #0#) #0#)"
          (show #f (written (let ((ones (list 1)))
                              (set-cdr! ones ones)
                              (list ones ones)))))
      (test "((1) (1))"
          (show #f (written (let ((ones (list 1)))
                              (list ones ones)))))

      (test "(#0=(1) #0#)"
          (show #f (written-shared (let ((ones (list 1)))
                                     (list ones ones)))))

      ;; cycles without shared detection

      (test "(1 1 1 1 1"
          (show #f (trimmed/lazy
                    10
                    (written-simply
                     (let ((ones (list 1))) (set-cdr! ones ones) ones)))))

      (test "(1 1 1 1 1 "
          (show #f (trimmed/lazy
                    11
                    (written-simply
                     (let ((ones (list 1))) (set-cdr! ones ones) ones)))))

      ;; pretty printing

      (test-pretty "(foo bar)\n")

      (test-pretty
       "((self . aquanet-paper-1991)
 (type . paper)
 (title . \"Aquanet: a hypertext tool to hold your\"))
")

      (test-pretty
       "(abracadabra xylophone
             bananarama
             yellowstonepark
             cryptoanalysis
             zebramania
             delightful
             wubbleflubbery)\n")

      (test-pretty
       "#(0  1  2  3  4  5  6  7  8  9  10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
  26 27 28 29 30 31 32 33 34 35 36 37)\n")

      (test-pretty
       "(0  1  2  3  4  5  6  7  8  9  10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
 26 27 28 29 30 31 32 33 34 35 36 37)\n")

      (test-pretty
       "(#(0 1)   #(2 3)   #(4 5)   #(6 7)   #(8 9)   #(10 11) #(12 13) #(14 15)
 #(16 17) #(18 19))\n")

      (test-pretty
       "#(#(0 1)   #(2 3)   #(4 5)   #(6 7)   #(8 9)   #(10 11) #(12 13) #(14 15)
  #(16 17) #(18 19))\n")

      (test-pretty
       "(define (fold kons knil ls)
  (define (loop ls acc)
    (if (null? ls) acc (loop (cdr ls) (kons (car ls) acc))))
  (loop ls knil))\n")

      (test-pretty
       "(do ((vec (make-vector 5)) (i 0 (+ i 1))) ((= i 5) vec) (vector-set! vec i i))\n")

      (test-pretty
       "(do ((vec (make-vector 5)) (i 0 (+ i 1))) ((= i 5) vec)
  (vector-set! vec i 'supercalifrajalisticexpialidocious))\n")

      (test-pretty
       "(do ((my-vector (make-vector 5)) (index 0 (+ index 1)))
    ((= index 5) my-vector)
  (vector-set! my-vector index index))\n")

      (test-pretty
       "(define (fold kons knil ls)
  (let loop ((ls ls) (acc knil))
    (if (null? ls) acc (loop (cdr ls) (kons (car ls) acc)))))\n")

      (test-pretty
       "(define (file->sexp-list pathname)
  (call-with-input-file pathname
    (lambda (port)
      (let loop ((res '()))
        (let ((line (read port)))
          (if (eof-object? line) (reverse res) (loop (cons line res))))))))\n")

      (test-pretty
       "(design
 (module (name \"\\\\testshiftregister\") (attributes (attribute (name \"\\\\src\"))))
 (wire (name \"\\\\shreg\") (attributes (attribute (name \"\\\\src\")))))\n")

      (test-pretty
       "(design
 (module (name \"\\\\testshiftregister\")
         (attributes
          (attribute (name \"\\\\src\") (value \"testshiftregister.v:10\"))))
 (wire (name \"\\\\shreg\")
       (attributes
        (attribute (name \"\\\\src\") (value \"testshiftregister.v:15\")))))\n")

      (test "(let ((ones '#0=(1 . #0#))) ones)\n"
          (show #f (pretty (let ((ones (list 1)))
                             (set-cdr! ones ones)
                             `(let ((ones ',ones)) ones)))))

      '(test
           "(let ((zeros '(0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0))
      (ones '#0=(1 . #0#)))
  (append zeros ones))\n"
           (show #f (pretty
                     (let ((ones (list 1)))
                       (set-cdr! ones ones)
                       `(let ((zeros '(0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0))
                              (ones ',ones))
                          (append zeros ones))))))

      ;; pretty-simply
      (let* ((d (let ((d (list 'a 'b #f)))
                  (list-set! d 2 d)
                  (list d)))
             (ca (circular-list 'a)))
        (test "((a b (a b (a b" (show #f (trimmed/lazy 15 (pretty-simply '((a b (a b (a b (a b)))))))))
        (test "((a b\n    (a b\n" (show #f (trimmed/lazy 15 (pretty-simply d))))
        (test "'(a a\n    a\n   " (show #f (trimmed/lazy 15 (pretty-simply `(quote ,ca)))))
        (test "(foo\n (a a\n    " (show #f (trimmed/lazy 15 (pretty-simply `(foo ,ca)))))
        (test "(with-x \n  (a a" (show #f (trimmed/lazy 15 (pretty-simply `(with-x ,ca)))))
        )

      ;; columns

      '(test "abc\ndef\n"
          (show #f (show-columns (list displayed "abc\ndef\n"))))
      '(test "abc123\ndef456\n"
          (show #f (show-columns (list displayed "abc\ndef\n")
                                 (list displayed "123\n456\n"))))
      '(test "abc123\ndef456\n"
          (show #f (show-columns (list displayed "abc\ndef\n")
                                 (list displayed "123\n456"))))
      '(test "abc123\ndef456\n"
          (show #f (show-columns (list displayed "abc\ndef")
                                 (list displayed "123\n456\n"))))
      '(test "abc123\ndef456\nghi789\n"
          (show #f (show-columns (list displayed "abc\ndef\nghi\n")
                                 (list displayed "123\n456\n789\n"))))
      '(test "abc123wuv\ndef456xyz\n"
          (show #f (show-columns (list displayed "abc\ndef\n")
                                 (list displayed "123\n456\n")
                                 (list displayed "wuv\nxyz\n"))))
      '(test "abc  123\ndef  456\n"
          (show #f (show-columns (list (lambda (x) (padded/right 5 x))
                                       "abc\ndef\n")
                                 (list displayed "123\n456\n"))))
      '(test "ABC  123\nDEF  456\n"
          (show #f (show-columns (list (lambda (x) (upcased (padded/right 5 x)))
                                       "abc\ndef\n")
                                 (list displayed "123\n456\n"))))
      '(test "ABC  123\nDEF  456\n"
          (show #f (show-columns (list (lambda (x) (padded/right 5 (upcased x)))
                                       "abc\ndef\n")
                                 (list displayed "123\n456\n"))))

      (test "" (show #f (wrapped "    ")))
      (test "hello\nworld"
          (show #f (with ((width 8)) (wrapped "hello world"))))
      (test "\n"
          (show #f (with ((width 16))
                     (terminal-aware (wrapped "")))))

      (test
          "The  quick
brown  fox
jumped
over   the
lazy dog
"
          (show #f
                (with ((width 10))
                  (justified "The quick brown fox jumped over the lazy dog"))))

      (test
          "The fundamental list iterator.
Applies KONS to each element of
LS and the result of the previous
application, beginning with KNIL.
With KONS as CONS and KNIL as '(),
equivalent to REVERSE."
          (show #f
                (with ((width 36))
                  (wrapped "The fundamental list iterator.  Applies KONS to each element of LS and the result of the previous application, beginning with KNIL.  With KONS as CONS and KNIL as '(), equivalent to REVERSE."))))

      (test
          "(define (fold kons knil ls)
  (let lp ((ls ls) (acc knil))
    (if (null? ls)
        acc
        (lp (cdr ls)
            (kons (car ls) acc)))))
"
          (show #f
                (with ((width 36))
                  (pretty '(define (fold kons knil ls)
                             (let lp ((ls ls) (acc knil))
                               (if (null? ls)
                                   acc
                                   (lp (cdr ls)
                                       (kons (car ls) acc)))))))))

      '(test
           "(define (fold kons knil ls)          ; The fundamental list iterator.
  (let lp ((ls ls) (acc knil))       ; Applies KONS to each element of
    (if (null? ls)                   ; LS and the result of the previous
        acc                          ; application, beginning with KNIL.
        (lp (cdr ls)                 ; With KONS as CONS and KNIL as '(),
            (kons (car ls) acc)))))  ; equivalent to REVERSE.
"
           (show #f
                 (show-columns
                  (list
                   (lambda (x) (padded/right 36 x))
                   (with ((width 36))
                     (pretty '(define (fold kons knil ls)
                                (let lp ((ls ls) (acc knil))
                                  (if (null? ls)
                                      acc
                                      (lp (cdr ls)
                                          (kons (car ls) acc))))))))
                  (list
                   (lambda (x) (each " ; " x))
                   (with ((width 36))
                     (wrapped "The fundamental list iterator.  Applies KONS to each element of LS and the result of the previous application, beginning with KNIL.  With KONS as CONS and KNIL as '(), equivalent to REVERSE."))))))

      (test "\n" (show #f (columnar)))      ; degenerate case
      (test "\n" (show #f (columnar "*")))  ; only infinite columns
      (test "*\n" (show #f (columnar (each "*"))))

      (test "foo" (show #f (wrapped "foo")))

      (test
           "(define (fold kons knil ls)          ; The fundamental list iterator.
  (let lp ((ls ls) (acc knil))       ; Applies KONS to each element of
    (if (null? ls)                   ; LS and the result of the previous
        acc                          ; application, beginning with KNIL.
        (lp (cdr ls)                 ; With KONS as CONS and KNIL as '(),
            (kons (car ls) acc)))))  ; equivalent to REVERSE.
"
           (show #f (with ((width 76))
                      (columnar
                       (pretty '(define (fold kons knil ls)
                                  (let lp ((ls ls) (acc knil))
                                    (if (null? ls)
                                        acc
                                        (lp (cdr ls)
                                            (kons (car ls) acc))))))
                       " ; "
                       (wrapped "The fundamental list iterator.  Applies KONS to each element of LS and the result of the previous application, beginning with KNIL.  With KONS as CONS and KNIL as '(), equivalent to REVERSE.")))))

      (test
          "- Item 1: The text here is
          indented according
          to the space \"Item
          1\" takes, and one
          does not known what
          goes here.
"
          (show #f (columnar 9 (each "- Item 1:") " " (with ((width 20)) (wrapped "The text here is indented according to the space \"Item 1\" takes, and one does not known what goes here.")))))

      (test
          "- Item 1: The text here is
          indented according
          to the space \"Item
          1\" takes, and one
          does not known what
          goes here.
"
          (show #f (columnar 9 (each "- Item 1:\n") " " (with ((width 20)) (wrapped "The text here is indented according to the space \"Item 1\" takes, and one does not known what goes here.")))))

      (test
          "- Item 1: The-text-here-is----------------------------------------------------
--------- indented-according--------------------------------------------------
--------- to-the-space-\"Item--------------------------------------------------
--------- 1\"-takes,-and-one---------------------------------------------------
--------- does-not-known-what-------------------------------------------------
--------- goes-here.----------------------------------------------------------
"
          (show #f (with ((pad-char #\-)) (columnar 9 (each "- Item 1:\n") " " (with ((width 20)) (wrapped "The text here is indented according to the space \"Item 1\" takes, and one does not known what goes here."))))))

      (test
          "a   | 123
bc  | 45
def | 6
"
          (show #f (with ((width 20))
                    (tabular (each "a\nbc\ndef\n") " | "
                             (each "123\n45\n6\n")))))

      ;; color
      (test "\x1B;[31mred\x1B;[39m" (show #f (as-red "red")))
      (test "\x1B;[31mred\x1B;[34mblue\x1B;[31mred\x1B;[39m"
          (show #f (as-red "red" (as-blue "blue") "red")))
      (test "\x1b;[31m1234567\x1b;[39m col: 7"
            (show #f (terminal-aware (as-red "1234567") (fn (col) (each " col: " col)))))
      (test "\x1b;[31m\x1b;[4m\x1b;[1mabc\x1b;[22mdef\x1b;[24mghi\x1b;[39m"
            (show #f (as-red (each (as-underline (as-bold "abc") "def") "ghi"))))
      (test "\x1b;[44m\x1b;[33mabc\x1b;[39mdef\x1b;[49m"
            (show #f (on-blue (each (as-yellow "abc") "def"))))

      ;; unicode
      (test ""
          (show #f (with ((pad-char #\)) (padded/both 5 ""))))
      (test ""
          (show #f (terminal-aware (with ((pad-char #\)) (padded/both 5 "")))))
      (test ""
          (show #f (trimmed 2 "")))
      (test ""
          (show #f (terminal-aware (trimmed 2 ""))))
      (test ""
          (show #f (trimmed/right 2 "")))
      (test ""
          (show #f (terminal-aware (trimmed/right 2 ""))))
      (test "\x1B;[31m\x1B;[46m\x1B;[49m\x1B;[39m"
          (show #f (terminal-aware
                    (trimmed/right 2 (as-red "" (on-cyan "!!!!"))))))
      (test ""
          (show #f (trimmed/right 3 "")))
      (test ""
          (show #f (terminal-aware (trimmed/right 3 ""))))
      (test " col: 6"
          (show #f (terminal-aware "" (fn (col) (each " col: " col)))))
      (test " col: 9"
          (show #f (terminal-aware "" (fn (col) (each " col: " col)))))
      (test " col: 12"
          (show #f (with ((ambiguous-is-wide? #t))
                     (terminal-aware ""
                                     (fn (col) (each " col: " col))))))
      (test "" (substring-terminal-width "" 0 6))
      (test "" (substring-terminal-width "" 0 4))
      (test "" (substring-terminal-width "" 2 6))
      (test "" (substring-terminal-width "" 1 4))
      (test "" (substring-terminal-width "" 1 5))
      (test "" (substring-terminal-width "" 2 4))
      (test "" (substring-terminal-width "" 2 3))
      (test "" (substring-terminal-width "" -1 2))

      ;; from-file
      ;; for reference, filesystem-test relies on creating files under /tmp
      (let* ((tmp-file "chibi-show-test-0123456789")
             (content-string "first line\nsecond line\nthird line"))
        (with-output-to-file tmp-file (lambda () (write-string content-string)))
        (test (string-append content-string "\n")
              (show #f (from-file tmp-file)))
        (test
         "   1 first line\n   2 second line\n   3 third line\n"
         (show #f (columnar 4 'right 'infinite (line-numbers) " " (from-file tmp-file))))
        (delete-file tmp-file))

      (test-end))))

(define-library (srfi 166 base)
  (import (scheme base)
          (scheme char)
          (scheme complex)
          (scheme inexact)
          (scheme repl)
          (scheme write)
          (srfi 1)
          (srfi 69)
          (srfi 130)
          (rename (srfi 165)
                  (computation-each sequence)
                  (computation-with! with!)
                  (computation-forked forked)
                  (make-computation-environment-variable make-state-variable))
          (chibi show shared))
  (cond-expand
   (chibi
    (import (only (chibi) let-optionals*)))
   (else
    (begin
      (define-syntax let-optionals*
        (syntax-rules ()
          ((let-optionals* opt-ls () . body)
           (begin . body))
          ((let-optionals* (op . args) vars . body)
           (let ((tmp (op . args)))
             (let-optionals* tmp vars . body)))
          ((let-optionals* tmp ((var default) . rest) . body)
           (let ((var (if (pair? tmp) (car tmp) default))
                 (tmp2 (if (pair? tmp) (cdr tmp) '())))
             (let-optionals* tmp2 rest . body)))
          ((let-optionals* tmp tail . body)
           (let ((tail tmp)) . body)))))))
  (export
   ;; basic
   show displayed written written-shared written-simply
   escaped maybe-escaped
   numeric numeric/comma numeric/si numeric/fitted
   nl fl space-to tab-to nothing each each-in-list
   joined joined/prefix joined/suffix joined/last joined/dot
   joined/range padded padded/right padded/both
   trimmed trimmed/right trimmed/both trimmed/lazy
   fitted fitted/right fitted/both output-default
   ;; computations
   fn with with! forked call-with-output
   ;; state variables
   make-state-variable
   port row col width output writer pad-char ellipsis
   string-width substring/width substring/preserve
   radix precision decimal-sep decimal-align sign-rule
   comma-sep comma-rule word-separator? ambiguous-is-wide?
   pretty-environment
   )
  (include "base.scm")
  (include "write.scm")
  (include "show.scm"))

(define-library (srfi 166 columnar)
  (import (scheme base)
          (scheme char)
          (scheme file)
          (srfi 1)
          (srfi 117)
          (srfi 130)
          (srfi 166 base)
          (chibi optional))
  (export
   columnar tabular wrapped wrapped/list wrapped/char
   justified from-file line-numbers)
  (include "column.scm"))

(define-library (srfi 113)
  (import (scheme base) (srfi 1) (srfi 125) (srfi 128))
  (export
   ;;;;;;;;;;;;;; Sets
   ;; Constructors:
   set set-contains? set-unfold
   ;; Predicates:
   set? set-empty? set-disjoint?
   ;; Accessors:
   set-member set-element-comparator
   ;; Updaters:
   set-adjoin set-adjoin! set-replace set-replace!
   set-delete set-delete! set-delete-all set-delete-all!
   set-search!
   ;; The whole set:
   set-size set-find set-count set-any? set-every?
   ;; Mapping and folding:
   set-map set-for-each set-fold set-filter set-filter!
   set-remove set-remove! set-partition set-partition!
   ;; Copying and conversion:
   set-copy set->list list->set list->set!
   ;; Subsets:
   set=? set<? set>? set<=? set>=?
   ;; Set theory operations:
   set-union set-intersection set-difference set-xor
   set-union! set-intersection! set-difference! set-xor!
   ;; Comparators:
   (rename the-set-comparator set-comparator)

   ;;;;;;;;;;;;;; Bags
   ;; Constructors:
   bag bag-contains? bag-unfold
   ;; Predicates:
   bag? bag-empty? bag-disjoint?
   ;; Accessors:
   bag-member bag-element-comparator
   ;; Updaters:
   bag-adjoin bag-adjoin! bag-replace bag-replace!
   bag-delete bag-delete! bag-delete-all bag-delete-all!
   bag-search!
   ;; The whole bag:
   bag-size bag-find bag-count bag-any? bag-every?
   ;; Mapping and folding:
   bag-map bag-for-each bag-fold bag-filter bag-filter!
   bag-remove bag-remove! bag-partition bag-partition!
   ;; Copying and conversion:
   bag-copy bag->list list->bag list->bag!
   ;; Subbags:
   bag=? bag<? bag>? bag<=? bag>=?
   ;; Bag theory operations:
   bag-union bag-intersection bag-difference bag-xor
   bag-union! bag-intersection! bag-difference! bag-xor!
   ;; Comparators:
   (rename the-bag-comparator bag-comparator)

   ;; Additional bag procedures:
   bag-unique-size
   bag-sum bag-sum! bag-product bag-product! bag-element-count
   bag-for-each-unique bag-fold-unique bag-increment! bag-decrement!
   bag->set set->bag set->bag!
   bag->alist alist->bag
   )
  ;;(include-shared "69/hash")
  (include "113/sets.scm"
           "113/bags.scm"))
(define-library (srfi 144)
  (import (chibi)
          (rename (srfi 141)
                  (floor/ flfloor/)
                  (floor-quotient flfloor-quotient)
                  (floor-remainder flfloor-remainder)
                  (ceiling/ flceiling/)
                  (ceiling-quotient flceiling-quotient)
                  (ceiling-remainder flceiling-remainder)
                  (truncate/ fltruncate/)
                  (truncate-quotient fltruncate-quotient)
                  (truncate-remainder fltruncate-remainder)
                  (round/ flround/)
                  (round-quotient flround-quotient)
                  (round-remainder flround-remainder)
                  (euclidean/ fleuclidean/)
                  (euclidean-quotient fleuclidean-quotient)
                  (euclidean-remainder fleuclidean-remainder)
                  (balanced/ flbalanced/)
                  (balanced-quotient flbalanced-quotient)
                  (balanced-remainder flbalanced-remainder)))
  (export
   fl-e fl-1/e fl-e-2 fl-e-pi/4 fl-log2-e fl-log10-e fl-log-2
   fl-1/log-2 fl-log-3 fl-log-pi fl-log-10 fl-1/log-10 fl-pi
   fl-1/pi fl-2pi fl-2/pi fl-pi/2 fl-pi/4 fl-pi-squared fl-degree
   fl-sqrt-pi fl-2/sqrt-pi fl-sqrt-2 fl-sqrt-3 fl-sqrt-5 fl-sqrt-10
   fl-1/sqrt-2 fl-cbrt-2 fl-cbrt-3 fl-4thrt-2 fl-phi fl-log-phi
   fl-1/log-phi fl-euler fl-e-euler fl-sin-1 fl-cos-1 fl-gamma-1/2
   fl-gamma-1/3 fl-gamma-2/3 fl-greatest fl-least fl-epsilon
   fl-integer-exponent-zero fl-integer-exponent-nan fl-fast-+*

   flonum flonum? fl=? fl<? fl>? fl<=? fl>=? flodd? fleven?
   flunordered? flinteger? flzero? flpositive? flnegative?

   fl+ fl- fl* fl/ fl+* flmax flmin flabsdiff
   flnumerator fldenominator

   fladjacent flcopysign flsgn make-flonum flinteger-fraction
   flexponent flinteger-exponent flnormalized-fraction-exponent
   sign-bit flfinite? flinfinite? flnan? flnormalized? fldenormalized?
   flabs flposdiff flfloor flceiling flround fltruncate

   flexp flexp2 flexp-1 flsquare flsqrt flcbrt flhypot flexpt fllog fllog1+
   fllog2 fllog10 flsin flcos fltan flasin flacos flatan
   flsinh flcosh fltanh flasinh flacosh flatanh flremquo
   flgamma flloggamma flfirst-bessel flsecond-bessel flerf flerfc

   flfloor/ flfloor-quotient flfloor-remainder
   flceiling/ flceiling-quotient flceiling-remainder
   fltruncate/ fltruncate-quotient fltruncate-remainder
   flround/ flround-quotient flround-remainder
   fleuclidean/ fleuclidean-quotient fleuclidean-remainder
   flbalanced/ flbalanced-quotient flbalanced-remainder)
  (include-shared "144/math")
  (include "144/flonum.scm"))

(define-library (srfi 142)
  (export bitwise-not
          bitwise-and   bitwise-ior 
          bitwise-xor   bitwise-eqv
          bitwise-nand  bitwise-nor 
          bitwise-andc1 bitwise-andc2
          bitwise-orc1  bitwise-orc2 
          arithmetic-shift bit-count integer-length
          bitwise-if
          bit-set? any-bit-set? every-bit-set?
          first-set-bit
          bit-field bit-field-any? bit-field-every?
          bit-field-clear bit-field-set
          bit-field-replace bit-field-replace-same
          bit-field-rotate bit-field-reverse
          copy-bit integer->list list->integer
          integer->vector vector->integer
          bits bit-swap
          bitwise-fold bitwise-for-each bitwise-unfold
          make-bitwise-generator)
  (import (chibi)
          (rename (srfi 151)
                  (bitwise-if srfi-151:bitwise-if)
                  (bits->list integer->list)
                  (list->bits list->integer)
                  (bits->vector integer->vector)
                  (vector->bits vector->integer)))
  (begin
    (define (bitwise-if mask n m)
      (srfi-151:bitwise-if mask m n))))
;;;; Persistent Hash Map

;;; Copyright MMXV-MMXVII Arthur A. Gleckler.  All rights reserved.

;; Permission is hereby granted, free of charge, to any person
;; obtaining a copy of this software and associated documentation
;; files (the "Software"), to deal in the Software without
;; restriction, including without limitation the rights to use, copy,
;; modify, merge, publish, distribute, sublicense, and/or sell copies
;; of the Software, and to permit persons to whom the Software is
;; furnished to do so, subject to the following conditions:

;; The above copyright notice and this permission notice shall be
;; included in all copies or substantial portions of the Software.

;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
;; EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
;; MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
;; NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
;; HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
;; WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
;; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
;; DEALINGS IN THE SOFTWARE.

;;; Public protocol (API)

;; (phm? datum)

;;   Return true iff `datum' is a persistent hash map.

;; (make-phm hash = [alist])

;;   Return a new immutable persistent hash map that uses the `hash'
;;   procedure to hash its keys and `=' to compare them.  If `alist'
;;   is supplied, include all its keys and data in the result.  Later
;;   occurrences of the same key override earlier ones.

;; (phm/count phm)

;;   Return the number of elements in `phm'.

;; (phm/empty? phm)

;;   Return true iff `phm' is empty.

;; (phm/immutable phm)
;; (phm/immutable phm replace)

;;   Return a PHM equivalent to `phm', but that is immutable.  Even if
;;   `phm' is mutable, no change to it will affect the returned one.
;;   If `replace' is supplied, replace the datum associated with each
;;   key whose value has been modified since the PHM was made mutable
;;   with the result of calling `replace' on that key and datum.  This
;;   is useful for converting PHSs (sets) stored as values in a PHM
;;   back into immutable ones when the containing PHM is made
;;   immutable.

;; (phm/mutable phm)

;;   Return a PHM equivalent to `phm', but that is mutable.  If `phm'
;;   was immutable, no change to the returned PHM will affect `phm'.

;; (phm/mutable? phm)

;;   Return true iff `phm' is mutable.

;; (phm/put phm key datum)

;;   Return a PHM equivalent to `phm' except that `datum' is at `key'.

;; (phm/put! phm key datum)

;;   Return a PHM equivalent to `phm' except that `datum' is at `key'.
;;   Modify `phm', which must be mutable, in the process.

;; (phm/replace phm key replace)

;;   Return a PHM equivalent to `phm' except that whatever value is at
;;   `key' has been replaced by `(replace datum)', or `(replace
;;   hamt-null)' if there was no value there already.  If `replace'
;;   returns `hamt-null', the value is removed.

;; (phm/replace! phm key replace)

;;   Return a PHM equivalent to `phm' except that whatever value is at
;;   `key' has been replaced by `(replace datum)', or `(replace
;;   hamt-null)' if there was no value there already.  If `replace'
;;   returns `hamt-null', the value is removed.  Modify `phm', which
;;   must be mutable, in the process.

;; (phm/get phm key [default])

;;   Return the datum stored at `key' in `phm'.  If none is present,
;;   return `default' if it was supplied, or #f if it was not.

;; (phm/contains? phm key)

;;   Return true iff `phm' has a datum at `key'.

;; (phm/remove phm key)

;;   Return a PHM equivalent to `phm' except that there is no datum at
;;   `key'.

;; (phm/remove! phm key)

;;   Return a PHM equivalent to `phm' except that there is no datum at
;;   `key'.  Modify `phm', which must be mutable, in the process.

;; (phm/add-alist phm alist)

;;   Return a PHM equivalent to `phm' except that, for every pair in
;;   `alist', the datum in its cdr is stored in the new PHM at the key
;;   in its car.  Later occurrences of the same key override earlier
;;   ones.

;; (phm/add-alist! phm alist)

;;   Return a PHM equivalent to `phm' except that, for every pair in
;;   `alist', the datum in its cdr is stored in the new PHM at the key
;;   in its car.  Later occurrences of the same key override earlier
;;   ones.  Modify `phm', which must be mutable, in the process.

;; (phm->alist phm)

;;   Return an alist mapping the keys in `phm' to their values.

;; (phm/keys phm)

;;   Return a list of the keys in `phm'.

;; (phm/for-each procedure phm)

;;   Run `procedure' on each key and datum in `phm'.

;;; Implementation of public protocol (API)

(define (phm? datum)
  (and (hash-array-mapped-trie? datum)
       (hamt/payload? datum)))

(define (make-phm-inner hash = alist)
  (let ((phm (make-hamt = hash #t)))
    (if (null? alist)
    phm
    (let ((phm-1 (phm/mutable phm)))
      (phm/add-alist! phm-1 alist)
      (phm/immutable phm-1)))))

(define make-phm
  (case-lambda
   ((hash =) (make-phm-inner hash = '()))
   ((hash = alist) (make-phm-inner hash = alist))))

(define (phm/count phm)
  (assert (phm? phm))
  (hamt/count phm))

(define (phm/empty? phm)
  (assert (phm? phm))
  (hamt/empty? phm))

(define phm/immutable
  (case-lambda
   ((phm)
    (assert (phm? phm))
    (hamt/immutable phm))
   ((phm replace)
    (assert (phm? phm))
    (hamt/immutable phm replace))))

(define (phm/mutable phm)
  (assert (phm? phm))
  (hamt/mutable phm))

(define (phm/mutable? phm)
  (assert (phm? phm))
  (hamt/mutable? phm))

(define (phm/put phm key datum)
  (assert (phm? phm))
  (hamt/put phm key datum))

(define (phm/put! phm key datum)
  (assert (phm? phm))
  (hamt/put! phm key datum))

(define (phm/replace phm key replace)
  (assert (phm? phm))
  (hamt/replace phm key replace))

(define (phm/replace! phm key replace)
  (assert (phm? phm))
  (hamt/replace! phm key replace))

(define (phm/get-inner phm key default)
  (assert (phm? phm))
  (let ((result (hamt-fetch phm key)))
    (if (hamt-null? result)
    default
    result)))

(define phm/get
  (case-lambda
   ((phm key) (phm/get-inner phm key #f))
   ((phm key default) (phm/get-inner phm key default))))

(define (phm/contains? phm key)
  (assert (phm? phm))
  (not (hamt-null? (hamt-fetch phm key))))

(define (phm/remove phm key)
  (assert (phm? phm))
  (phm/put phm key hamt-null))

(define (phm/remove! phm key)
  (assert (phm? phm))
  (assert (hamt/mutable? phm))
  (phm/put! phm key hamt-null))

(define (phm/add-alist phm alist)
  (assert (phm? phm))
  (fold (lambda (a phm) (phm/put phm (car a) (cdr a))) phm alist))

(define (phm/add-alist! phm alist)
  (assert (phm? phm))
  (do-list (a alist)
    (phm/put! phm (car a) (cdr a)))
  phm)

(define (phm->alist phm)
  (assert (phm? phm))
  (hamt->list phm cons))

(define (phm/data phm)
  (assert (phm? phm))
  (hamt->list phm (lambda (k d) d)))

(define (phm/keys phm)
  (assert (phm? phm))
  (hamt->list phm (lambda (k d) k)))

(define (phm/for-each procedure phm)
  (assert (phm? phm))
  (hamt/for-each procedure phm))(define-library (srfi 146 hamt-map-test)
  (import
   (scheme base)
   (chibi test)
   (srfi 146 hamt)
   (srfu 146 hamt-map)
   (srfi 146 hamt-misc)
   (only (srfi 1) alist-delete fold)
   (only (srfi 27) random-integer)
   (only (srfi 113)
         set
         set-adjoin!
         set-delete!
         set-for-each)
   (only (srfi 125)
         hash-table->alist
         hash-table-keys
         hash-table-delete!
         hash-table-for-each
         hash-table-set!
         hash-table-size
         string-hash)
   (only (srfi 128) make-comparator)
   (only (srfi 132) list-sort)
   (only (srfi 151) bit-count))
  (export run-hamt-map-tests)
  (include "hamt-map-test.scm"))
;;;; `vector-edit'

;;; Copyright MMIV-MMXV Arthur A. Gleckler.  All rights reserved.

;; Permission is hereby granted, free of charge, to any person
;; obtaining a copy of this software and associated documentation
;; files (the "Software"), to deal in the Software without
;; restriction, including without limitation the rights to use, copy,
;; modify, merge, publish, distribute, sublicense, and/or sell copies
;; of the Software, and to permit persons to whom the Software is
;; furnished to do so, subject to the following conditions:

;; The above copyright notice and this permission notice shall be
;; included in all copies or substantial portions of the Software.

;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
;; EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
;; MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
;; NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
;; HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
;; WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
;; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
;; DEALINGS IN THE SOFTWARE.

;;; `vector-edit' adds and/or removes elements from a vector
;;; non-destructively, i.e. by returning a new vector.  It maps
;;; offsets in the original vector to offsets in the new vector so
;;; that the caller doesn't have to perform these error-prone
;;; calculations itself.

(define (vector-without v start end)
  "Return a copy of vector `v' without the elements with indices [start, end)."
  (let* ((size (vector-length v))
     (gap-size (- end start))
     (new-size (- size gap-size))
     (result (make-vector new-size)))
    (vector-copy! result 0 v 0 start)
    (vector-copy! result start v end size)
    result))

(define (vector-replace-one v i e)
  "Return a copy of vector `v' with the `i'th element replaced by `e'."
  (let ((result (vector-copy v)))
    (vector-set! result i e)
    result))

(define-syntax vector-edit-total-skew
  (syntax-rules (add drop)
    ((_ s) s)
    ((_ s (add i e) . rest)
     (vector-edit-total-skew (+ s 1) . rest))
    ((_ s (drop i c) . rest)
     (vector-edit-total-skew (- s c) . rest))))

(define-syntax vector-edit-code
  (syntax-rules (add drop)
    ((_ v r o s)
     (let ((index (vector-length v)))
       (vector-copy! r (+ o s) v o index)
       r))
    ((_ v r o s (add i e) . rest)
     (let ((index i))
       (vector-copy! r (+ o s) v o index)
       (vector-set! r (+ s index) e)
       (let ((skew (+ s 1)))
     (vector-edit-code v r index skew . rest))))
    ((_ v r o s (drop i c) . rest)
     (let ((index i))
       (vector-copy! r (+ o s) v o index)
       (let* ((dropped c)
          (offset (+ index dropped))
          (skew (- s dropped)))
     (vector-edit-code v r offset skew . rest))))))

;; <> Optimize this by allowing one to supply more than one value in
;; `add' sub-expressions so that adjacent values can be inserted
;; without extra computation.

;; Given a vector `v' and a set of `(add i e)' and `(drop i c)' forms,
;; return a new vector that is the result of applying insertions to
;; and deletions from `v'.  Interpret each `i' as an index into `v',
;; each `e' as an element to be inserted into the resulting vector at
;; the index corresponding to `i', and each `c' as a count of elements
;; of `v' to be dropped starting at index `i'.  The `i' values in the
;; `add' and `drop' forms must never decrease from left to right.
;; This is useful for doing insertions and deletions without
;; constructing an intermediate vector.
(define-syntax vector-edit
  (syntax-rules ()
    ((_ v . rest)
     (let ((result (make-vector (+ (vector-length v)
                   (vector-edit-total-skew 0 . rest)))))
       (vector-edit-code v result 0 0 . rest)))));; Copyright (C) Marc Nieper-Wikirchen (2016, 2017).  All Rights
;; Reserved.

;; Permission is hereby granted, free of charge, to any person
;; obtaining a copy of this software and associated documentation
;; files (the "Software"), to deal in the Software without
;; restriction, including without limitation the rights to use, copy,
;; modify, merge, publish, distribute, sublicense, and/or sell copies
;; of the Software, and to permit persons to whom the Software is
;; furnished to do so, subject to the following conditions:

;; The above copyright notice and this permission notice shall be
;; included in all copies or substantial portions of the Software.

;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
;; EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
;; MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
;; NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
;; BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
;; ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
;; CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
;; SOFTWARE.

;;; New types

(define-record-type <mapping>
  (%make-mapping comparator tree)
  mapping?
  (comparator mapping-key-comparator)
  (tree mapping-tree))

(define (make-empty-mapping comparator)
  (assume (comparator? comparator))
  (%make-mapping comparator (make-tree)))

;;; Exported procedures

;; Constructors

(define (mapping comparator . args)
  (assume (comparator? comparator))
  (mapping-unfold null?
          (lambda (args)
        (values (car args)
            (cadr args)))
          cddr
          args
          comparator))

(define (mapping-unfold stop? mapper successor seed comparator)
  (assume (procedure? stop?))
  (assume (procedure? mapper))
  (assume (procedure? successor))
  (assume (comparator? comparator))
  (let loop ((mapping (make-empty-mapping comparator))
         (seed seed))
    (if (stop? seed)
    mapping
    (receive (key value)
        (mapper seed)
      (loop (mapping-adjoin mapping key value)
        (successor seed))))))

(define mapping/ordered mapping)
(define mapping-unfold/ordered mapping-unfold)

;; Predicates

(define (mapping-empty? mapping)
  (assume (mapping? mapping))
  (not (mapping-any? (lambda (key value) #t) mapping)))

(define (mapping-contains? mapping key)
  (assume (mapping? mapping))
  (call/cc
   (lambda (return)
     (mapping-search mapping
         key
         (lambda (insert ignore)
           (return #f))
         (lambda (key value update remove)
           (return #t))))))

(define (mapping-disjoint? mapping1 mapping2)
  (assume (mapping? mapping1))
  (assume (mapping? mapping2))
  (call/cc
   (lambda (return)
     (mapping-for-each (lambda (key value)
             (when (mapping-contains? mapping2 key)
               (return #f)))
           mapping1)
     #t)))

;; Accessors

(define mapping-ref
  (case-lambda
    ((mapping key)
     (assume (mapping? mapping))
     (mapping-ref mapping key (lambda ()
            (error "mapping-ref: key not in mapping" key))))
    ((mapping key failure)
     (assume (mapping? mapping))
     (assume (procedure? failure))
     (mapping-ref mapping key failure (lambda (value)
                value)))
    ((mapping key failure success)
     (assume (mapping? mapping))
     (assume (procedure? failure))
     (assume (procedure? success))
     ((call/cc
       (lambda (return-thunk)
     (mapping-search mapping
             key
             (lambda (insert ignore)
               (return-thunk failure))
             (lambda (key value update remove)
               (return-thunk (lambda () (success value)))))))))))

(define (mapping-ref/default mapping key default)
  (assume (mapping? mapping))
  (mapping-ref mapping key (lambda () default)))

;; Updaters

(define (mapping-adjoin mapping . args)
  (assume (mapping? mapping))
  (let loop ((args args)
         (mapping mapping))
    (if (null? args)
    mapping
    (receive (mapping value)
        (mapping-intern mapping (car args) (lambda () (cadr args)))
      (loop (cddr args) mapping)))))

(define mapping-adjoin! mapping-adjoin)

(define (mapping-set mapping . args)
  (assume (mapping? mapping))
  (let loop ((args args)
         (mapping mapping))
    (if (null? args)
    mapping
    (receive (mapping)
        (mapping-update mapping (car args) (lambda (value) (cadr args)) (lambda () #f))    
      (loop (cddr args)
        mapping)))))

(define mapping-set! mapping-set)

(define (mapping-replace mapping key value)
  (assume (mapping? mapping))
  (receive (mapping obj)
      (mapping-search mapping
          key
          (lambda (insert ignore)
            (ignore #f))
          (lambda (old-key old-value update remove)
            (update key value #f)))
    mapping))

(define mapping-replace! mapping-replace)

(define (mapping-delete mapping . keys)
  (assume (mapping? mapping))
  (mapping-delete-all mapping keys))

(define mapping-delete! mapping-delete)

(define (mapping-delete-all mapping keys)
  (assume (mapping? mapping))
  (assume (list? keys))
  (fold (lambda (key mapping)
      (receive (mapping obj)
          (mapping-search mapping
              key
              (lambda (insert ignore)
                (ignore #f))
              (lambda (old-key old-value update remove)
                (remove #f)))
        mapping))
    mapping keys))

(define mapping-delete-all! mapping-delete-all)

(define (mapping-intern mapping key failure)
  (assume (mapping? mapping))
  (assume (procedure? failure))
  (call/cc
   (lambda (return)
     (mapping-search mapping
         key
         (lambda (insert ignore)
           (receive (value)
               (failure)
             (insert value value)))
         (lambda (old-key old-value update remove)
           (return mapping old-value))))))

(define mapping-intern! mapping-intern)

(define mapping-update 
  (case-lambda
   ((mapping key updater)
    (mapping-update mapping key updater (lambda ()
                  (error "mapping-update: key not found in mapping" key))))
   ((mapping key updater failure)
    (mapping-update mapping key updater failure (lambda (value)
                      value)))
   ((mapping key updater failure success)
    (assume (mapping? mapping))
    (assume (procedure? updater))
    (assume (procedure? failure))
    (assume (procedure? success))
    (receive (mapping obj)
    (mapping-search mapping
            key
            (lambda (insert ignore)
              (insert (updater (failure)) #f))
            (lambda (old-key old-value update remove)
              (update key (updater (success old-value)) #f)))
      mapping))))

(define mapping-update! mapping-update)

(define (mapping-update/default mapping key updater default)
  (mapping-update mapping key updater (lambda () default)))

(define mapping-update!/default mapping-update/default)

(define mapping-pop
  (case-lambda
    ((mapping)
     (mapping-pop mapping (lambda ()
                (error "mapping-pop: mapping has no association"))))
    ((mapping failure)
     (assume (mapping? mapping))
     (assume (procedure? failure))
     ((call/cc
       (lambda (return-thunk)
     (receive (key value)
         (mapping-find (lambda (key value) #t) mapping (lambda () (return-thunk failure)))
       (lambda ()
         (values (mapping-delete mapping key) key value)))))))))

(define mapping-pop! mapping-pop)

(define (mapping-search mapping key failure success)
  (assume (mapping? mapping))
  (assume (procedure? failure))
  (assume (procedure? success))
  (call/cc
   (lambda (return)
     (let*-values
     (((comparator)
       (mapping-key-comparator mapping))
      ((tree obj)
       (tree-search comparator
            (mapping-tree mapping)
            key
            (lambda (insert ignore)
              (failure (lambda (value obj)
                     (insert key value obj))
                   (lambda (obj)
                     (return mapping obj))))
            success)))
       (values (%make-mapping comparator tree)
           obj)))))

(define mapping-search! mapping-search)

;; The whole mapping

(define (mapping-size mapping)
  (assume (mapping? mapping))
  (mapping-count (lambda (key value)
           #t)
         mapping))

(define (mapping-find predicate mapping failure)
  (assume (procedure? predicate))
  (assume (mapping? mapping))
  (assume (procedure? failure))
  (call/cc
   (lambda (return)
     (mapping-for-each (lambda (key value)
             (when (predicate key value)
               (return key value)))
           mapping)
     (failure))))

(define (mapping-count predicate mapping)
  (assume (procedure? predicate))
  (assume (mapping? mapping))
  (mapping-fold (lambda (key value count)
          (if (predicate key value)
          (+ 1 count)
          count))
        0 mapping))

(define (mapping-any? predicate mapping)
  (assume (procedure? predicate))
  (assume (mapping? mapping))
  (call/cc
   (lambda (return)
     (mapping-for-each (lambda (key value)
             (when (predicate key value)
               (return #t)))
           mapping)
     #f)))

(define (mapping-every? predicate mapping)
  (assume (procedure? predicate))
  (assume (mapping? mapping))
  (not (mapping-any? (lambda (key value)
           (not (predicate key value)))
         mapping)))

(define (mapping-keys mapping)
  (assume (mapping? mapping))
  (mapping-fold/reverse (lambda (key value keys)
              (cons key keys))
            '() mapping))

(define (mapping-values mapping)
  (assume (mapping? mapping))
  (mapping-fold/reverse (lambda (key value values)
              (cons value values))
            '() mapping))

(define (mapping-entries mapping)
  (assume (mapping? mapping))
  (values (mapping-keys mapping)
      (mapping-values mapping)))

;; Mapping and folding

(define (mapping-map proc comparator mapping)
  (assume (procedure? proc))
  (assume (comparator? comparator))
  (assume (mapping? mapping))
  (mapping-fold (lambda (key value mapping)
          (receive (key value)
          (proc key value)
        (mapping-set mapping key value)))
        (make-empty-mapping comparator)
        mapping))

(define (mapping-for-each proc mapping)
  (assume (procedure? proc))
  (assume (mapping? mapping))
  (tree-for-each proc (mapping-tree mapping)))

(define (mapping-fold proc acc mapping)
  (assume (procedure? proc))
  (assume (mapping? mapping))
  (tree-fold proc acc (mapping-tree mapping)))

(define (mapping-map->list proc mapping)
  (assume (procedure? proc))
  (assume (mapping? mapping))
  (mapping-fold/reverse (lambda (key value lst)
              (cons (proc key value) lst))
            '()
            mapping))

(define (mapping-filter predicate mapping)
  (assume (procedure? predicate))
  (assume (mapping? mapping))
  (mapping-fold (lambda (key value mapping)
          (if (predicate key value)
          (mapping-set mapping key value)
          mapping))
        (make-empty-mapping (mapping-key-comparator mapping))
        mapping))

(define mapping-filter! mapping-filter)

(define (mapping-remove predicate mapping)
  (assume (procedure? predicate))
  (assume (mapping? mapping))
  (mapping-filter (lambda (key value)
        (not (predicate key value)))
          mapping))

(define mapping-remove! mapping-remove)

(define (mapping-partition predicate mapping)
  (assume (procedure? predicate))
  (assume (mapping? mapping))
  (values (mapping-filter predicate mapping)
      (mapping-remove predicate mapping)))

(define mapping-partition! mapping-partition)

;; Copying and conversion

(define (mapping-copy mapping)
  (assume (mapping? mapping))
  mapping)

(define (mapping->alist mapping)
  (assume (mapping? mapping))
  (reverse
   (mapping-fold (lambda (key value alist)
           (cons (cons key value) alist))
         '() mapping)))

(define (alist->mapping comparator alist)
  (assume (comparator? comparator))
  (assume (list? alist))
  (mapping-unfold null?
          (lambda (alist)
        (let ((key (caar alist))
              (value (cdar alist)))
          (values key value)))
          cdr
          alist
          comparator))

(define (alist->mapping! mapping alist)
  (assume (mapping? mapping))
  (assume (list? alist))
  (fold (lambda (association mapping)
      (let ((key (car association))
        (value (cdr association)))
        (mapping-set mapping key value)))
    mapping
    alist))

(define alist->mapping/ordered alist->mapping)
(define alist->mapping/ordered! alist->mapping!)

;; Submappings

(define mapping=?
  (case-lambda
    ((comparator mapping)
     (assume (mapping? mapping))
     #t)
    ((comparator mapping1 mapping2) (%mapping=? comparator mapping1 mapping2))
    ((comparator mapping1 mapping2 . mappings)
     (and (%mapping=? comparator mapping1 mapping2)
          (apply mapping=? comparator mapping2 mappings)))))
(define (%mapping=? comparator mapping1 mapping2)
  (and (eq? (mapping-key-comparator mapping1) (mapping-key-comparator mapping2))
       (%mapping<=? comparator mapping1 mapping2)
       (%mapping<=? comparator mapping2 mapping1)))

(define mapping<=?
  (case-lambda
    ((comparator mapping)
     (assume (mapping? mapping))
     #t)
    ((comparator mapping1 mapping2)
     (assume (comparator? comparator))
     (assume (mapping? mapping1))
     (assume (mapping? mapping2))
     (%mapping<=? comparator mapping1 mapping2))
    ((comparator mapping1 mapping2 . mappings)
     (assume (comparator? comparator))
     (assume (mapping? mapping1))
     (assume (mapping? mapping2))
     (and (%mapping<=? comparator mapping1 mapping2)
          (apply mapping<=? comparator mapping2 mappings)))))

(define (%mapping<=? comparator mapping1 mapping2)
  (assume (comparator? comparator))
  (assume (mapping? mapping1))
  (assume (mapping? mapping2))
  (let ((less? (comparator-ordering-predicate (mapping-key-comparator mapping1)))
    (equality-predicate (comparator-equality-predicate comparator))
    (gen1 (tree-generator (mapping-tree mapping1)))
    (gen2 (tree-generator (mapping-tree mapping2))))    
    (let loop ((item1 (gen1))
           (item2 (gen2)))
      (cond
       ((eof-object? item1)
    #t)
       ((eof-object? item2)
    #f)
       (else
    (let ((key1 (car item1)) (value1 (cadr item1))
          (key2 (car item2)) (value2 (cadr item2)))
      (cond
       ((less? key1 key2)
        #f)
       ((less? key2 key1)
        (loop item1 (gen2)))
       ((equality-predicate value1 value2)
        (loop (gen1) (gen2)))
       (else
        #f))))))))

(define mapping>?
  (case-lambda
    ((comparator mapping)
     (assume (mapping? mapping))
     #t)
    ((comparator mapping1 mapping2)
     (assume (comparator? comparator))
     (assume (mapping? mapping1))
     (assume (mapping? mapping2))
     (%mapping>? comparator mapping1 mapping2))
    ((comparator mapping1 mapping2 . mappings)
     (assume (comparator? comparator))
     (assume (mapping? mapping1))
     (assume (mapping? mapping2))
     (and (%mapping>? comparator  mapping1 mapping2)
          (apply mapping>? comparator mapping2 mappings)))))

(define (%mapping>? comparator mapping1 mapping2)
  (assume (comparator? comparator))
  (assume (mapping? mapping1))
  (assume (mapping? mapping2))
  (not (%mapping<=? comparator mapping1 mapping2)))

(define mapping<?
  (case-lambda
    ((comparator mapping)
     (assume (mapping? mapping))
     #t)
    ((comparator mapping1 mapping2)
     (assume (comparator? comparator))
     (assume (mapping? mapping1))
     (assume (mapping? mapping2))
     (%mapping<? comparator mapping1 mapping2))
    ((comparator mapping1 mapping2 . mappings)
     (assume (comparator? comparator))
     (assume (mapping? mapping1))
     (assume (mapping? mapping2))
     (and (%mapping<? comparator  mapping1 mapping2)
          (apply mapping<? comparator mapping2 mappings)))))

(define (%mapping<? comparator mapping1 mapping2)
     (assume (comparator? comparator))
     (assume (mapping? mapping1))
     (assume (mapping? mapping2))
     (%mapping>? comparator mapping2 mapping1))

(define mapping>=?
  (case-lambda
    ((comparator mapping)
     (assume (mapping? mapping))
     #t)
    ((comparator mapping1 mapping2)
     (assume (comparator? comparator))
     (assume (mapping? mapping1))
     (assume (mapping? mapping2))
     (%mapping>=? comparator mapping1 mapping2))
    ((comparator mapping1 mapping2 . mappings)
     (assume (comparator? comparator))
     (assume (mapping? mapping1))
     (assume (mapping? mapping2))
     (and (%mapping>=? comparator mapping1 mapping2)
          (apply mapping>=? comparator mapping2 mappings)))))

(define (%mapping>=? comparator mapping1 mapping2)
  (assume (comparator? comparator))
  (assume (mapping? mapping1))
  (assume (mapping? mapping2))
  (not (%mapping<? comparator mapping1 mapping2)))

;; Set theory operations

(define (%mapping-union mapping1 mapping2)
  (mapping-fold (lambda (key2 value2 mapping)
          (receive (mapping obj)
              (mapping-search mapping
                      key2
                      (lambda (insert ignore)
                    (insert value2 #f))
                      (lambda (key1 value1 update remove)
                    (update key1 value1 #f)))
            mapping))
        mapping1 mapping2))

(define (%mapping-intersection mapping1 mapping2)
  (mapping-filter (lambda (key1 value1)
        (mapping-contains? mapping2 key1))
          mapping1))

(define (%mapping-difference mapping1 mapping2)
  (mapping-fold (lambda (key2 value2 mapping)
          (receive (mapping obj)
          (mapping-search mapping
                  key2
                  (lambda (insert ignore)
                (ignore #f))
                  (lambda (key1 value1 update remove)
                (remove #f)))
        mapping))
        mapping1 mapping2))

(define (%mapping-xor mapping1 mapping2)
  (mapping-fold (lambda (key2 value2 mapping)
          (receive (mapping obj)
          (mapping-search mapping
                  key2
                  (lambda (insert ignore)
                (insert value2 #f))
                  (lambda (key1 value1 update remove)
                (remove #f)))
        mapping))
        mapping1 mapping2))

(define mapping-union
  (case-lambda
    ((mapping)
     (assume (mapping? mapping))
     mapping)
    ((mapping1 mapping2)
     (assume (mapping? mapping1))
     (assume (mapping? mapping2))
     (%mapping-union mapping1 mapping2))
    ((mapping1 mapping2 . mappings)
     (assume (mapping? mapping1))
     (assume (mapping? mapping2))
     (apply mapping-union (%mapping-union mapping1 mapping2) mappings))))
(define mapping-union! mapping-union)

(define mapping-intersection
  (case-lambda
    ((mapping)
     (assume (mapping? mapping))
     mapping)
    ((mapping1 mapping2)
     (assume (mapping? mapping1))
     (assume (mapping? mapping2))
     (%mapping-intersection mapping1 mapping2))
    ((mapping1 mapping2 . mappings)
     (assume (mapping? mapping1))
     (assume (mapping? mapping2))
     (apply mapping-intersection (%mapping-intersection mapping1 mapping2) mappings))))
(define mapping-intersection! mapping-intersection)

(define mapping-difference
  (case-lambda
    ((mapping)
     (assume (mapping? mapping))
     mapping)
    ((mapping1 mapping2)
     (assume (mapping? mapping1))
     (assume (mapping? mapping2))
     (%mapping-difference mapping1 mapping2))
    ((mapping1 mapping2 . mappings)
     (assume (mapping? mapping1))
     (assume (mapping? mapping2))
     (apply mapping-difference (%mapping-difference mapping1 mapping2) mappings))))
(define mapping-difference! mapping-difference)

(define mapping-xor
  (case-lambda
    ((mapping)
     (assume (mapping? mapping))
     mapping)
    ((mapping1 mapping2)
     (assume (mapping? mapping1))
     (assume (mapping? mapping2))
     (%mapping-xor mapping1 mapping2))
    ((mapping1 mapping2 . mappings)
     (assume (mapping? mapping1))
     (assume (mapping? mapping2))
     (apply mapping-xor (%mapping-xor mapping1 mapping2) mappings))))
(define mapping-xor! mapping-xor)

;; Additional procedures for mappings with ordererd keys

(define (mapping-min-key mapping)
  (assume (mapping? mapping))
  (call/cc
   (lambda (return)
     (mapping-fold (lambda (key value acc)
             (return key))
           #f mapping)
     (error "mapping-min-key: empty map"))))

(define (mapping-max-key mapping)
  (assume (mapping? mapping))
  (call/cc
   (lambda (return)
     (mapping-fold/reverse (lambda (key value acc)
                 (return key))
               #f mapping)
     (error "mapping-max-key: empty map"))))

(define (mapping-min-value mapping)
  (assume (mapping? mapping))
  (call/cc
   (lambda (return)
     (mapping-fold (lambda (key value acc)
             (return value))
           #f mapping)
     (error "mapping-min-value: empty map"))))

(define (mapping-max-value mapping)
  (assume (mapping? mapping))
  (call/cc
   (lambda (return)
     (mapping-fold/reverse (lambda (key value acc)
                 (return value))
               #f mapping)
     (error "mapping-max-value: empty map"))))

(define (mapping-key-predecessor mapping obj failure)
  (assume (mapping? mapping))
  (assume (procedure? failure))
  (tree-key-predecessor (mapping-key-comparator mapping) (mapping-tree mapping) obj failure))

(define (mapping-key-successor mapping obj failure)
  (assume (mapping? mapping))
  (assume (procedure? failure))
  (tree-key-successor (mapping-key-comparator mapping) (mapping-tree mapping) obj failure))

(define (mapping-range= mapping obj)
  (assume (mapping? mapping))
  (let ((comparator (mapping-key-comparator mapping)))
    (receive (tree< tree<= tree= tree>= tree>)
    (tree-split comparator (mapping-tree mapping) obj)
      (%make-mapping comparator tree=))))

(define (mapping-range< mapping obj)
  (assume (mapping? mapping))
  (let ((comparator (mapping-key-comparator mapping)))
    (receive (tree< tree<= tree= tree>= tree>)
    (tree-split comparator (mapping-tree mapping) obj)
      (%make-mapping comparator tree<))))

(define (mapping-range<= mapping obj)
  (assume (mapping? mapping))
  (let ((comparator (mapping-key-comparator mapping)))
    (receive (tree< tree<= tree= tree>= tree>)
    (tree-split comparator (mapping-tree mapping) obj)
      (%make-mapping comparator tree<=))))

(define (mapping-range> mapping obj)
  (assume (mapping? mapping))
  (let ((comparator (mapping-key-comparator mapping)))
    (receive (tree< tree<= tree= tree>= tree>)
    (tree-split comparator (mapping-tree mapping) obj)
      (%make-mapping comparator tree>))))

(define (mapping-range>= mapping obj)
  (assume (mapping? mapping))
  (assume (mapping? mapping))
  (let ((comparator (mapping-key-comparator mapping)))
    (receive (tree< tree<= tree= tree>= tree>)
    (tree-split comparator (mapping-tree mapping) obj)
      (%make-mapping comparator tree>=))))

(define mapping-range=! mapping-range=)
(define mapping-range<! mapping-range<)
(define mapping-range>! mapping-range>)
(define mapping-range<=! mapping-range<=)
(define mapping-range>=! mapping-range>=)

(define (mapping-split mapping obj)
  (assume (mapping? mapping))
  (let ((comparator (mapping-key-comparator mapping)))
    (receive (tree< tree<= tree= tree>= tree>)
    (tree-split comparator (mapping-tree mapping) obj)
      (values (%make-mapping comparator tree<)
          (%make-mapping comparator tree<=)
          (%make-mapping comparator tree=)
          (%make-mapping comparator tree>=)
          (%make-mapping comparator tree>)))))

(define (mapping-catenate comparator mapping1 pivot-key pivot-value mapping2)
  (assume (comparator? comparator))
  (assume (mapping? mapping1))
  (assume (mapping? mapping2))
  (%make-mapping comparator (tree-catenate (mapping-tree mapping1)
                       pivot-key
                       pivot-value
                       (mapping-tree mapping2))))

(define mapping-catenate! mapping-catenate)

(define (mapping-map/monotone proc comparator mapping)
  (assume (procedure? proc))
  (assume (comparator? comparator))
  (assume (mapping? mapping))
  (%make-mapping comparator (tree-map proc (mapping-tree mapping))))

(define mapping-map/monotone! mapping-map/monotone)

(define (mapping-fold/reverse proc acc mapping)
  (assume (procedure? proc))
  (assume (mapping? mapping))
  (tree-fold/reverse proc acc (mapping-tree mapping)))

;; Comparators

(define (mapping-equality comparator)
  (assume (comparator? comparator))
  (lambda (mapping1 mapping2)
    (mapping=? comparator mapping1 mapping2)))

(define (mapping-ordering comparator)
  (assume (comparator? comparator))
  (let ((value-equality (comparator-equality-predicate comparator))
    (value-ordering (comparator-ordering-predicate comparator)))
    (lambda (mapping1 mapping2)
      (let* ((key-comparator (mapping-key-comparator mapping1))
         (equality (comparator-equality-predicate key-comparator))
         (ordering (comparator-ordering-predicate key-comparator))
         (gen1 (tree-generator (mapping-tree mapping1)))
         (gen2 (tree-generator (mapping-tree mapping2))))
    (let loop ()
      (let ((item1 (gen1)) (item2 (gen2)))
        (cond
         ((eof-object? item1)
          (not (eof-object? item2)))
         ((eof-object? item2)
          #f)
         (else
          (let ((key1 (car item1)) (value1 (cadr item1))
            (key2 (car item2)) (value2 (cadr item2)))
        (cond
         ((equality key1 key2)
          (if (value-equality value1 value2)
              (loop)
              (value-ordering value1 value2)))
         (else
          (ordering key1 key2))))))))))))

(define (make-mapping-comparator comparator)
  (make-comparator mapping? (mapping-equality comparator) (mapping-ordering comparator) #f))

(define mapping-comparator (make-mapping-comparator (make-default-comparator)))

(comparator-register-default! mapping-comparator)
(define-library (srfi 146 hamt-test)
  (import (scheme base)
          (chibi test)
          (only (srfi 146 hamt) fragment->mask))
  (export run-hamt-core-tests)
  (include "hamt-test.scm"))
(define-library (srfi 146 hamt-map)
  (import
   (scheme base)
   (scheme case-lambda)
   (only (srfi 1) fold)
   (srfi 16)
   (srfi 146 hamt)
   (srfi 146 hamt-misc))
  (export
   make-phm phm?
   phm->alist
   phm/add-alist phm/add-alist!
   phm/contains?
   phm/count
   phm/empty?
   phm/for-each
   phm/get
   phm/immutable
   phm/keys
   phm/mutable phm/mutable?
   phm/put
   phm/put!
   phm/remove phm/remove!
   phm/replace phm/replace!

   ;; This is only needed by tests:
   phm/data)
  (include "hamt-map.scm"))
(define-library (srfi 146 hamt-misc-test)
  (import (scheme base) (chibi test) (srfi 146 hamt-misc))
  (export run-hamt-misc-tests)
  (include "hamt-misc-test.scm"))
(define-library (srfi 146 vector-edit-test)
  (import (scheme base) (chibi test) (srfi 146 vector-edit))
  (export run-vector-edit-tests)
  (include "vector-edit-test.scm"))
;; Copyright (C) Marc Nieper-Wikirchen (2016).  All Rights Reserved. 

;; Permission is hereby granted, free of charge, to any person
;; obtaining a copy of this software and associated documentation
;; files (the "Software"), to deal in the Software without
;; restriction, including without limitation the rights to use, copy,
;; modify, merge, publish, distribute, sublicense, and/or sell copies
;; of the Software, and to permit persons to whom the Software is
;; furnished to do so, subject to the following conditions:

;; The above copyright notice and this permission notice shall be
;; included in all copies or substantial portions of the Software.

;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
;; EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
;; MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
;; NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
;; BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
;; ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
;; CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
;; SOFTWARE.

;; Concrete data types

(define (make-item key value) (vector key value))
(define (item-key item) (vector-ref item 0))
(define (item-value item) (vector-ref item 1))

(define (node color left item right) (vector color left item right))
(define (color node) (vector-ref node 0))
(define (left node) (vector-ref node 1))
(define (item node) (vector-ref node 2))
(define (right node) (vector-ref node 3))
(define (key node) (item-key (item node)))
(define (value node) (item-value (item node)))
(define (red left item right) (node 'red left item right))
(define (black left item right)
  (node 'black left item right))
(define (black-leaf) (black #f #f #f))
(define (white left item right)
  (node 'white left item right))
(define (white-leaf) (white #f #f #f))
(define (red? node) (eq? (color node) 'red))
(define (black? node) (eq? (color node) 'black))
(define (white? node) (eq? (color node) 'white))

;;; Tree matcher macros

(define-syntax tree-match
  (syntax-rules ()
    ((tree-match tree (pattern . expression*) ...)
     (compile-patterns (expression* ...) tree () (pattern ...)))))

(define-syntax compile-patterns
  (syntax-rules ()

    ((compile-patterns (expression* ...) tree (clauses ...) ())
     (call-with-current-continuation
      (lambda (return)
    (or (and-let* clauses
          (call-with-values
          (lambda () . expression*)
        return))
        ...
        (error "tree does not match any pattern" tree)))))
    
    ((compile-patterns e tree clauses* (pattern . pattern*))
     (compile-pattern tree pattern
              (add-pattern e tree clauses* pattern*)))))

(define-syntax add-pattern
  (syntax-rules ()
    ((add-pattern e tree (clauses ...) pattern* new-clauses)
     (compile-patterns e tree (clauses ... new-clauses) pattern*))))

(define-syntax compile-pattern
  (syntax-rules (_ and red? black? white? ? node red black white)

    ((compile-pattern tree (red? x) (k ...))
     (k ... (((red? tree)) (x tree))))

    ((compile-pattern tree (black? x) (k ...))
     (k ... (((black? tree)) (x tree))))

    ((compile-pattern tree (white? x) (k ...))
     (k ... (((white? tree)) (x tree))))

    ((compile-pattern tree (black) (k ...))
     (k ... (((black? tree)) ((not (item tree))))))

    ((compile-pattern tree (white) (k ...))
     (k ... (((white? tree)) ((not (item tree))))))

    ((compile-pattern tree (and pt ...) k*)
     (compile-subpatterns () ((t pt) ...)
              (compile-and-pattern tree t k*)))

    ((compile-pattern tree (node pc pa px pb) k*)
     (compile-subpatterns () ((c pc) (a pa) (x px) (b pb))
              (compile-node-pattern tree c a x b k*)))

    ((compile-pattern tree (red pa px pb) k*)
     (compile-subpatterns () ((a pa) (x px) (b pb))
              (compile-color-pattern red? tree a x b k*)))

    ((compile-pattern tree (black pa px pb) k*)
     (compile-subpatterns () ((a pa) (x px) (b pb))
              (compile-color-pattern black? tree a x b k*)))

    ((compile-pattern tree (white pa px pb) k*)
     (compile-subpatterns () ((a pa) (x px) (b pb))
              (compile-color-pattern white? tree a x b k*)))

    ((compile-pattern tree _ (k ...))
     (k ... ()))

    ((compile-pattern tree x (k ...))
     (k ... ((x tree))))))

(define-syntax compile-and-pattern
  (syntax-rules ()    
    ((compile-and-pattern tree t (k ...) clauses)
     (k ... ((t tree) . clauses)))))

(define-syntax compile-node-pattern
  (syntax-rules ()
    ((compile-node-pattern tree c a x b (k ...) clauses)
     (k ... (((item tree))
         (c (color tree))
         (a (left tree))
         (x (item tree))
         (b (right tree)) . clauses)))))

(define-syntax compile-color-pattern
  (syntax-rules ()
    ((compile-color-pattern pred? tree a x b (k ...) clauses)
     (k ... (((item tree))
         ((pred? tree))
         (a (left tree))
         (x (item tree))
         (b (right tree)) . clauses)))))

(define-syntax compile-subpatterns
  (syntax-rules ()
    
    ((compile-subpatterns clauses () (k ...))
     (k ... clauses))

    ((compile-subpatterns clauses ((tree pattern) . rest) k*)
     (compile-pattern tree pattern (add-subpattern clauses rest k*)))))

(define-syntax add-subpattern
  (syntax-rules ()
    ((add-subpattern (clause ...) rest k* clauses)
     (compile-subpatterns (clause ... . clauses) rest k*))))
    
;;; Tree recolouring procedures

(define (blacken tree)
  (tree-match tree
    ((red a x b)
     (black a x b))
    (t t)))

(define (redden tree)
  (tree-match tree
    ((black (black? a) x (black? b))
     (red a x b))
    (t t)))

(define (white->black tree)
  (tree-match tree
    ((white)
     (black-leaf))
    ((white a x b)
     (black a x b))))

;;; Exported identifiers

(define (make-tree) (black-leaf))

(define (tree-fold proc seed tree)
  (let loop ((acc seed) (tree tree))
    (tree-match tree
      ((black)
       acc)
      ((node _ a x b)
       (let*
       ((acc (loop acc a))
        (acc (proc (item-key x) (item-value x) acc))
        (acc (loop acc b)))
     acc)))))

(define (tree-fold/reverse proc seed tree)
  (let loop ((acc seed) (tree tree))
    (tree-match tree
      ((black)
       acc)
      ((node _ a x b)
       (let*
       ((acc (loop acc b))
        (acc (proc (item-key x) (item-value x) acc))
        (acc (loop acc a)))
     acc)))))

(define (tree-for-each proc tree)
  (tree-fold (lambda (key value acc)
           (proc key value))
         #f tree))

(define (tree-generator tree)
  (make-coroutine-generator
   (lambda (yield)
     (tree-for-each (lambda item (yield item)) tree))))

(define (identity obj) obj)

(define (tree-search comparator tree obj failure success)
  (receive (tree ret op)
      (let search ((tree (redden tree)))
    (tree-match tree      
      ((black)
       (failure
        ;; insert
        (lambda (new-key new-value ret)
          (values (red (black-leaf) (make-item new-key new-value) (black-leaf))
              ret
              balance))
        ;; ignore
        (lambda (ret)
          (values (black-leaf) ret identity))))
      
      ((and t (node c a x b))
       (let ((key (item-key x)))
         (comparator-if<=> comparator obj key
           
           (receive (a ret op) (search a)
         (values (op (node c a x b)) ret op))
           
           (success
        key
        (item-value x)
        ;; update
        (lambda (new-key new-value ret)
          (values (node c a (make-item new-key new-value) b)
              ret
              identity))
        ;; remove
        (lambda (ret)
          (values
           (tree-match t
             ((red (black) x (black))
              (black-leaf))
             ((black (red a x b) _ (black))
              (black a x b))
             ((black (black) _ (black))
              (white-leaf))
             (_
              (receive (x b) (min+delete b)
            (rotate (node c a x b)))))
           ret
           rotate)))
           
           (receive (b ret op) (search b)
         (values (op (node c a x b)) ret op)))))))
      
    (values (blacken tree) ret)))

(define (tree-key-successor comparator tree obj failure)
  (let loop ((return failure) (tree tree))
    (tree-match tree
      ((black)
       (return))
      ((node _ a x b)
       (let ((key (item-key x)))
     (comparator-if<=> comparator key obj
               (loop return b)
               (loop return b)
               (loop (lambda () key) a)))))))

(define (tree-key-predecessor comparator tree obj failure)
  (let loop ((return failure) (tree tree))
    (tree-match tree
      ((black)
       (return))
      ((node _ a x b)
       (let ((key (item-key x)))
     (comparator-if<=> comparator key obj
               (loop (lambda () key) b)
               (loop return a)
               (loop return a)))))))

(define (tree-map proc tree)
  (let loop ((tree tree))
    (tree-match tree
      ((black)
       (black-leaf))
      ((node c a x b)
       (receive (key value)
       (proc (item-key x) (item-value x))
     (node c (loop a) (make-item key value) (loop b)))))))


(define (tree-catenate tree1 pivot-key pivot-value tree2)
  (let ((pivot (make-item pivot-key pivot-value))
    (height1 (black-height tree1))
    (height2 (black-height tree2)))
    (cond
     ((= height1 height2)
      (black tree1 pivot tree2))
     ((< height1 height2)
      (blacken
       (let loop ((tree tree2) (depth (- height2 height1)))
     (if (zero? depth)
         (balance (red tree1 pivot tree))
         (balance
          (node (color tree) (loop (left tree) (- depth 1)) (item tree) (right tree)))))))
     (else
      (blacken
       (let loop ((tree tree1) (depth (- height1 height2)))
     (if (zero? depth)
         (balance (red tree pivot tree2))
         (balance
          (node (color tree) (left tree) (item tree) (loop (right tree) (- depth 1)))))))))))

(define (tree-split comparator tree obj)
  (let loop ((tree1 (black-leaf))
         (tree2 (black-leaf))
         (pivot1 #f)
         (pivot2 #f)
         (tree tree))
    (tree-match tree
      ((black)
       (let ((tree1 (catenate-left tree1 pivot1 (black-leaf)))
         (tree2 (catenate-right (black-leaf) pivot2 tree2)))
     (values tree1 tree1 (black-leaf) tree2 tree2)))
      ((node _ a x b)
       (comparator-if<=> comparator obj (item-key x)
             (loop tree1
                   (catenate-right (blacken b) pivot2 tree2)
                   pivot1
                   x
                   (blacken a))
             (let* ((tree1 (catenate-left tree1 pivot1 (blacken a)))
                (tree1+ (catenate-left tree1 x (black-leaf)))
                (tree2 (catenate-right (blacken b) pivot2 tree2))
                (tree2+ (catenate-right (black-leaf) x tree2)))
               (values tree1
                   tree1+
                   (black (black-leaf) x (black-leaf))
                   tree2+
                   tree2))
             (loop (catenate-left tree1 pivot1 (blacken a))
                   tree2
                   x
                   pivot2
                   (blacken b)))))))

(define (catenate-left tree1 item tree2)
  (if item
      (tree-catenate tree1 (item-key item) (item-value item) tree2)
      tree2))

(define (catenate-right tree1 item tree2)
  (if item
      (tree-catenate tree1 (item-key item) (item-value item) tree2)
      tree1))

(define (black-height tree)
  (let loop ((tree tree))
    (tree-match tree
      ((black)
       0)
      ((node red a x b)
       (loop b))
      ((node black a x b)
       (+ 1 (loop b))))))

(define (left-tree tree depth)
  (let loop ((parent #f) (tree tree) (depth depth))
    (if (zero? depth)
    (values parent tree)
    (loop tree (left tree) (- depth 1)))))

(define (right-tree tree depth)
  (let loop ((parent #f) (tree tree) (depth depth))
    (if (zero? depth)
    (values parent tree)
    (loop tree (right tree) (- depth 1)))))

;;; Helper procedures for deleting and balancing

(define (min+delete tree)
  (tree-match tree
    ((red (black) x (black))
     (values x (black-leaf)))
    ((black (black) x (black))
     (values x (white-leaf)))
    ((black (black) x (red a y b))
     (values x (black a y b)))
    ((node c a x b)
     (receive (v a) (min+delete a)
       (values v (rotate (node c a x b)))))))

(define (balance tree)
  (tree-match tree
    ((black (red (red a x b) y c) z d)
     (red (black a x b) y (black c z d)))
    ((black (red a x (red b y c)) z d)
     (red (black a x b) y (black c z d)))
    ((black a x (red (red b y c) z d))
     (red (black a x b) y (black c z d)))
    ((black a x (red b y (red c z d)))
     (red (black a x b) y (black c z d)))
    ((white (red a x (red b y c)) z d)
     (black (black a x b) y (black c z d)))
    ((white a x (red (red b y c) z d))
     (black (black a x b) y (black c z d)))   
    (t t)))

(define (rotate tree)
  (tree-match tree
    ((red (white? a+x+b) y (black c z d))
     (balance (black (red (white->black a+x+b) y c) z d)))
    ((red (black a x b) y (white? c+z+d))
     (balance (black a x (red b y (white->black c+z+d)))))
    ((black (white? a+x+b) y (black c z d))
     (balance (white (red (white->black a+x+b) y c) z d)))
    ((black (black a x b) y (white? c+z+d))
     (balance (white a x (red b y (white->black c+z+d)))))
    ((black (white? a+w+b) x (red (black c y d) z e))
     (black (balance (black (red (white->black a+w+b) x c) y d)) z e))
    ((black (red a w (black b x c)) y (white? d+z+e))
     (black a w (balance (black b x (red c y (white->black d+z+e))))))
    (t t)))

;; Local Variables:
;; eval: (put 'tree-match 'scheme-indent-function 1)
;; End:
(define-library (srfi 146 hamt-misc)
  (import
   (scheme base)
   (scheme case-lambda)
   (only (srfi 125) make-hash-table string-hash)
   (only (srfi 128) make-comparator))
  (export assert do-list
          make-string-hash-table
          with-output-to-string)
  (include "hamt-misc.scm"))
(define-library (srfi 146 hamt)
  (import (scheme base)
          (scheme case-lambda)
          (only (srfi 1) find-tail)
          (srfi 16)
          (only (srfi 143) fx-width)
          (srfi 151)
          (srfi 146 hamt-misc)
          (srfi 146 vector-edit))
  (export fragment->mask
          hamt->list
          hamt-fetch
          hamt-null
          hamt-null?
          hamt/count
          hamt/empty?
          hamt/for-each
          hamt/immutable
          hamt/mutable
          hamt/mutable?
          hamt/payload?
          hamt/put
          hamt/put!
          hamt/replace
          hamt/replace!
          hash-array-mapped-trie?
          make-hamt

          ;; These are only needed by tests:
          collision?
          hamt-bucket-size
          hamt-hash-size
          hamt/root
          leaf-stride
          narrow/array
          narrow/leaves
          narrow?
          next-set-bit
          wide/array
          wide/children
          wide?)
  (include "hamt.scm"))
;;;; Persistent Hash Map

;;; Copyright MMXV-MMXVII Arthur A. Gleckler.  All rights reserved.

;; Permission is hereby granted, free of charge, to any person
;; obtaining a copy of this software and associated documentation
;; files (the "Software"), to deal in the Software without
;; restriction, including without limitation the rights to use, copy,
;; modify, merge, publish, distribute, sublicense, and/or sell copies
;; of the Software, and to permit persons to whom the Software is
;; furnished to do so, subject to the following conditions:

;; The above copyright notice and this permission notice shall be
;; included in all copies or substantial portions of the Software.

;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
;; EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
;; MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
;; NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
;; HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
;; WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
;; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
;; DEALINGS IN THE SOFTWARE.

;;; Naming conventions:

;;    =: procedure that compares keys
;;    c: bit string representing the non-leaf children present
;;       immediately below a sparse node
;;    d: datum, or `hamt-null' to represent absence or deletion
;;   dp: procedure that takes an existing datum and returns the datum
;;       that should replace it.  Either may be `hamt-null'.  When
;;       there is no payload, `hamt-null' is passed.
;;    h: hash
;;   hp: procedure that computes hash
;;    k: key that maps to a particular datum
;;    l: bit string representing the leaves present below a sparse node
;;    n: node (of type `collision', `narrow', or `wide')

;;; Background

;; See these papers:

;; - Ideal Hash Trees, Phil Bagwell, 2000,
;;   <https://infoscience.epfl.ch/record/64398/files/idealhashtrees.pdf>

;; - Optimizing Hash-Array Mapped Tries for Fast and Lean Immutable
;;   JVM Collections, Steinforder & Vinju, 2015,
;;   <http://michael.steindorfer.name/publications/oopsla15.pdf>

;; Also, see Clojure's persistent hash maps, which support both
;; mutable ("transient") and persistent modes.

;;; Design

;; According to Phil Bagwell's paper, "Occasionally an entire 32 bit
;; hash may be consumed and a new one must be computed to
;; differentiate the two keys."  Later, he says "The hash function was
;; tailored to give a 32 bit hash.  The algorithm requires that the
;; hash can be extended to an arbitrary number of bits.  This was
;; accomplished by rehashing the key combined with an integer
;; representing the trie level, zero being the root.  Hence if two
;; keys do give the same initial hash then the rehash has a
;; probability of 1 in 2^32 of a further collision."  However, I
;; implement collision lists instead because they will be rarely used
;; when hash functions are good, but work well when they're not, as in
;; the case of MIT Scheme's `string-hash'.

(define hamt-hash-slice-size 5)
(define hamt-hash-size
  (let ((word-size fx-width))
    (- word-size
       (remainder word-size hamt-hash-slice-size))))
(define hamt-hash-modulus (expt 2 hamt-hash-size))
(define hamt-bucket-size (expt 2 hamt-hash-slice-size))
(define hamt-null (cons 'hamt 'null))

(define-record-type hash-array-mapped-trie
    (%make-hamt = count hash mutable? payload? root)
    hash-array-mapped-trie?
  (=        hamt/=)
  (count    hamt/count set-hamt/count!)
  (hash     hamt/hash)
  (mutable? hamt/mutable?)
  (payload? hamt/payload?)
  (root     hamt/root  set-hamt/root!))

(define (make-hamt = hash payload?)
  (%make-hamt = 0 hash #f payload? (make-empty-narrow)))

(define-record-type collision
    (make-collision entries hash)
    collision?
  (entries collision/entries)
  (hash  collision/hash))

(define-record-type narrow
    (make-narrow array children leaves)
    narrow?
  (array    narrow/array)
  (children narrow/children)
  (leaves   narrow/leaves))

(define-record-type wide
    (make-wide array children leaves)
    wide?
  (array    wide/array)
  (children wide/children set-wide/children!)
  (leaves   wide/leaves   set-wide/leaves!))

(define (hamt/empty? hamt)
  (zero? (hamt/count hamt)))

(define (hamt/immutable-inner hamt replace)
  "Return a HAMT equivalent to `hamt', but that is immutable.  Even if
`hamt' is mutable, no change to it will affect the returned HAMT.  If
`hamt' has payloads, replace each datum in a wide node with what
`replace' returns when passed the key and corresponding datum.  This
is useful for converting HAMT sets stored as values in a HAMT map back
to immutable ones when the containing map is made immutable.  (Only
data in wide nodes will have been modified since the change to mutable
happened.)"
  (if (hamt/mutable? hamt)
      (let ((payload? (hamt/payload? hamt)))
    (%make-hamt (hamt/= hamt)
            (hamt/count hamt)
            (hamt/hash hamt)
            #f
            payload?
            (->immutable (hamt/root hamt) payload? replace)))
      hamt))

(define hamt/immutable
  (case-lambda
   ((hamt) (hamt/immutable-inner hamt (lambda (k d) d)))
   ((hamt replace) (hamt/immutable-inner hamt replace))))

(define (hamt/mutable hamt)
  (if (hamt/mutable? hamt)
      hamt
      (%make-hamt (hamt/= hamt)
          (hamt/count hamt)
          (hamt/hash hamt)
          #t
          (hamt/payload? hamt)
          (hamt/root hamt))))

(define (hamt/replace hamt key dp)
  (assert (not (hamt/mutable? hamt)))
  (let*-values (((payload?) (hamt/payload? hamt))
        ((root) (hamt/root hamt))
        ((==) (hamt/= hamt))
        ((hp) (hamt/hash hamt))
        ((hash) (hash-bits hp key))
        ((change node) (modify-pure hamt root 0 dp hash key)))
    (if (eq? node root)
    hamt
    (let ((count (+ (hamt/count hamt) change)))
      (%make-hamt == count hp #f payload? node)))))

(define (hamt/put hamt key datum)
  (hamt/replace hamt key (lambda (x) datum)))

(define (hamt/replace! hamt key dp)
  (assert (hamt/mutable? hamt))
  (let*-values (((root) (hamt/root hamt))
        ((hp) (hamt/hash hamt))
        ((hash) (hash-bits hp key))
        ((change node) (mutate hamt root 0 dp hash key)))
    (unless (zero? change)
      (set-hamt/count! hamt (+ (hamt/count hamt) change)))
    (unless (eq? node root)
      (set-hamt/root! hamt node))
    hamt))

(define (hamt/put! hamt key datum)
  (hamt/replace! hamt key (lambda (x) datum)))

(define (make-empty-narrow)
  (make-narrow (vector) 0 0))

(define (hamt-null? n)
  (eq? n hamt-null))

(define (collision-single-leaf? n)
  (let ((elements (collision/entries n)))
    (and (not (null? elements))
     (null? (cdr elements)))))

(define (narrow-single-leaf? n)
  (and (zero? (narrow/children n))
       (= 1 (bit-count (narrow/leaves n)))))

(define (wide-single-leaf? n)
  (and (zero? (wide/children n))
       (= 1 (bit-count (wide/leaves n)))))

(define (hash-bits hp key)
  (remainder (hp key) hamt-hash-modulus))

(define (next-set-bit i start end)
  (let ((index (first-set-bit (bit-field i start end))))
    (and (not (= index -1))
     (+ index start))))

(define (narrow->wide n payload?)
  (let* ((c (narrow/children n))
     (l (narrow/leaves n))
     (stride (leaf-stride payload?))
     (a-in (narrow/array n))
     (a-out (make-vector (* stride hamt-bucket-size))))
    (let next-leaf ((start 0) (count 0))
      (let ((i (next-set-bit l start hamt-bucket-size)))
    (when i
      (let ((j (* stride i)))
        (vector-set! a-out j (vector-ref a-in count))
        (when payload?
          (vector-set! a-out (+ j 1) (vector-ref a-in (+ count 1)))))
      (next-leaf (+ i 1) (+ stride count)))))
    (let next-child ((start 0) (offset (* stride (bit-count l))))
      (let ((i (next-set-bit c start hamt-bucket-size)))
    (when i
      (vector-set! a-out (* stride i) (vector-ref a-in offset))
      (next-child (+ i 1) (+ offset 1)))))
    (make-wide a-out c l)))

(define (->immutable n payload? replace)
  "Convert `n' and its descendants into `collision' or `narrow' nodes.
Stop at the first `collision' node or `narrow' node on each path.  If
`payload?' is true, then expect data, not just keys, and replace each
datum in a wide node with what `replace' returns when passed the key
and corresponding datum."
  (cond ((collision? n) n)
    ((narrow? n) n)
    ((wide? n)
     (let* ((c (wide/children n))
        (l (wide/leaves n))
        (stride (leaf-stride payload?))
        (l-count (bit-count l))
        (a-in (wide/array n))
        (a-out (make-vector
            (+ (* stride l-count) (bit-count c)))))
       (let next-leaf ((start 0) (count 0))
         (let ((i (next-set-bit l
                    start
                    hamt-bucket-size)))
           (when i
         (let* ((j (* stride i))
            (key (vector-ref a-in j)))
           (vector-set! a-out count key)
           (when payload?
             (vector-set! a-out
                  (+ count 1)
                  (replace
                   key
                   (vector-ref a-in (+ j 1))))))
         (next-leaf (+ i 1) (+ stride count)))))
       (let next-child ((start 0) (offset (* stride l-count)))
         (let ((i (next-set-bit c
                    start
                    hamt-bucket-size)))
           (when i
         (vector-set! a-out
                  offset
                  (->immutable (vector-ref a-in (* stride i))
                      payload?
                      replace))
         (next-child (+ i 1) (+ offset 1)))))
       (make-narrow a-out c l)))
    (else (error "Unexpected type of node."))))

(define (hash-fragment shift hash)
  (bit-field hash shift (+ shift hamt-hash-slice-size)))

(define (fragment->mask fragment)
  (- (expt 2 fragment) 1))

(define (mutate hamt n shift dp h k)
  (cond ((collision? n) (modify-collision hamt n shift dp h k))
    ((narrow? n)
     (modify-wide hamt
              (narrow->wide n (hamt/payload? hamt))
              shift
              dp
              h
              k))
    ((wide? n) (modify-wide hamt n shift dp h k))
    (else (error "Unknown HAMT node type." n))))

(define (modify-wide hamt n shift dp h k)
  (let ((fragment (hash-fragment shift h)))
    (cond ((bit-set? fragment (wide/children n))
       (modify-wide-child hamt n shift dp h k))
      ((bit-set? fragment (wide/leaves n))
       (modify-wide-leaf hamt n shift dp h k))
      (else
       (let ((d (dp hamt-null)))
         (if (hamt-null? d)
         (values 0 n)
         (modify-wide-new hamt n shift d h k)))))))

(define (modify-wide-child hamt n shift dp h k)
  (let*-values (((fragment) (hash-fragment shift h))
        ((array) (wide/array n))
        ((payload?) (hamt/payload? hamt))
        ((stride) (leaf-stride payload?))
        ((i) (* stride fragment))
        ((child) (vector-ref array i))
        ((change new-child)
         (mutate hamt
             child
             (+ shift hamt-hash-slice-size)
             dp
             h
             k)))
    (define (coalesce key datum)
      (vector-set! array i key)
      (when payload?
    (vector-set! array (+ i 1) datum))
      (set-wide/children! n (copy-bit fragment (wide/children n) #f))
      (set-wide/leaves! n (copy-bit fragment (wide/leaves n) #t))
      (values change n))
    (define (replace)
      (vector-set! array i new-child)
      (values change n))
    (cond ((eq? new-child child) (values change n))
      ((hamt-null? new-child)
       (error "Child cannot become null." n))
      ((collision? new-child)
       (if (collision-single-leaf? new-child)
           (let ((a (car (collision/entries new-child))))
         (if payload?
             (coalesce (car a) (cdr a))
             (coalesce a #f)))
           (replace)))
      ((wide? new-child)
       (if (wide-single-leaf? new-child)
           (let ((a (wide/array new-child))
             (j (* stride (next-set-bit (wide/leaves new-child)
                        0
                        hamt-bucket-size))))
         (coalesce (vector-ref a j)
               (and payload? (vector-ref a (+ j 1)))))
           (replace)))
      ((narrow? new-child)
       (replace))
      (else (error "Unexpected type of child node.")))))

(define (modify-wide-leaf hamt n shift dp h k)
  (let* ((fragment (hash-fragment shift h))
     (array (wide/array n))
     (payload? (hamt/payload? hamt))
     (stride (leaf-stride payload?))
     (i (* stride fragment))
     (key (vector-ref array i)))
    (if ((hamt/= hamt) k key)
    (let* ((existing (if payload? (vector-ref array (+ i 1)) hamt-null))
           (d (dp existing)))
      (cond ((hamt-null? d)
         (vector-set! array i #f)
         (when payload? (vector-set! array (+ i 1) #f))
         (set-wide/leaves! n (copy-bit fragment (wide/leaves n) #f))
         (values -1 n))
        (else
         (when payload? (vector-set! array (+ i 1) d))
         (values 0 n))))
    (let ((d (dp hamt-null)))
      (if (hamt-null? d)
          (values 0 n)
          (add-wide-leaf-key hamt n shift d h k))))))

(define (add-wide-leaf-key hamt n shift d h k)
  (define payload? (hamt/payload? hamt))
  (define make-entry
    (if payload? cons (lambda (k d) k)))
  (let* ((fragment (hash-fragment shift h))
     (array (wide/array n))
     (stride (leaf-stride payload?))
     (i (* stride fragment))
     (key (vector-ref array i))
     (hash (hash-bits (hamt/hash hamt) key))
     (datum (and payload? (vector-ref array (+ i 1)))))
    (vector-set! array
         i
         (if (= h hash)
             (make-collision (list (make-entry k d)
                       (make-entry key datum))
                     h)
             (make-narrow-with-two-keys
              payload?
              (+ shift hamt-hash-slice-size)
              h
              k
              d
              hash
              key
              datum)))
    (when payload?
      (vector-set! array (+ i 1) #f))
    (set-wide/children! n (copy-bit fragment (wide/children n) #t))
    (set-wide/leaves! n (copy-bit fragment (wide/leaves n) #f))
    (values 1 n)))

(define (modify-wide-new hamt n shift d h k)
  (let* ((fragment (hash-fragment shift h))
     (array (wide/array n))
     (payload? (hamt/payload? hamt))
     (stride (leaf-stride payload?))
     (i (* stride fragment)))
    (vector-set! array i k)
    (when payload?
      (vector-set! array (+ i 1) d))
    (set-wide/leaves! n (copy-bit fragment (wide/leaves n) #t))
    (values 1 n)))

(define (make-narrow-with-two-keys payload? shift h1 k1 d1 h2 k2 d2)
  (define (two-leaves f1 k1 d1 f2 k2 d2)
    (make-narrow
     (if payload?
     (vector k1 d1 k2 d2)
     (vector k1 k2))
     0
     (copy-bit f2 (copy-bit f1 0 #t) #t)))
  (assert (not (= h1 h2)))
  (let ((f1 (hash-fragment shift h1))
    (f2 (hash-fragment shift h2)))
    (cond ((= f1 f2)
       (make-narrow
        (vector (make-narrow-with-two-keys payload?
                           (+ shift hamt-hash-slice-size)
                           h1
                           k1
                           d1
                           h2
                           k2
                           d2))
        (copy-bit f1 0 #t)
        0))
      ((< f1 f2)
       (two-leaves f1 k1 d1 f2 k2 d2))
      (else
       (two-leaves f2 k2 d2 f1 k1 d1)))))

(define (modify-pure hamt n shift dp h k)
  (cond ((collision? n) (modify-collision hamt n shift dp h k))
    ((narrow? n) (modify-narrow hamt n shift dp h k))
    ((wide? n) (error "Should have been converted to narrow before here."))
    (else (error "Unknown HAMT node type." n))))

(define (lower-collision hamt n shift dp h k)
  "If we try to add a key to a collision but it has a different hash
than the collision's elements, add it to a narrow above the collision
instead.  Add as many levels of child-only narrows as needed to reach
the point where the hash fragments differ.  This is guaranteed to
happen at some level because we're only called when the full hashes
differ."
  (let ((collision-hash (collision/hash n))
    (d (dp hamt-null)))
    (if (hamt-null? d)
    (values 0 n)
    (values
     1
     (let descend ((shift shift))
       (let ((collision-fragment (hash-fragment shift collision-hash))
         (leaf-fragment (hash-fragment shift h)))
         (if (= collision-fragment leaf-fragment)
         (let ((child (descend (+ shift hamt-hash-slice-size))))
           (make-narrow
            (vector child)
            (copy-bit collision-fragment 0 #t)
            0))
         (make-narrow
          (if (hamt/payload? hamt)
              (vector k d n)
              (vector k n))
          (copy-bit collision-fragment 0 #t)
          (copy-bit leaf-fragment 0 #t)))))))))

(define (modify-collision hamt n shift dp h k)
  (if (= h (collision/hash n))
      (let ((payload? (hamt/payload? hamt)))
    (let next ((entries (collision/entries n))
           (checked '()))
      (if (null? entries)
          (let ((d (dp hamt-null)))
        (if (hamt-null? d)
            (values 0 n)
            (values 1
                (make-collision (if payload?
                        (cons (cons k d) checked)
                        (cons k checked))
                        h))))
          (let* ((entry (car entries))
             (key (if payload? (car entry) entry)))
        (if ((hamt/= hamt) k key)
            (let* ((existing (if payload? (cdr entry) hamt-null))
               (d (dp existing))
               (delete? (hamt-null? d))
               (others (append checked (cdr entries))))
              (values
               (if delete? -1 0)
               (make-collision (cond (delete? others)
                         (payload? (cons (cons k d) others))
                         (else (cons k others)))
                       h)))
            (next (cdr entries)
              (cons (car entries) checked)))))))
      (lower-collision hamt n shift dp h k)))

;; If we're storing "payloads," i.e. a datum to go with each key, we
;; must reserve two spots for each key in each vector.  Otherwise, we
;; need only one.
(define (leaf-stride payload?)
  (if payload? 2 1))

(define (narrow-child-index l c mask payload?)
  (+ (* (leaf-stride payload?) (bit-count l))
     (bit-count (bitwise-and c mask))))

(define (narrow-leaf-index l mask payload?)
  (* (leaf-stride payload?) (bit-count (bitwise-and l mask))))

(define (modify-narrow hamt n shift dp h k)
  (let ((fragment (hash-fragment shift h)))
    (cond ((bit-set? fragment (narrow/children n))
       (modify-narrow-child hamt n shift dp h k))
      ((bit-set? fragment (narrow/leaves n))
       (modify-narrow-leaf hamt n shift dp h k))
      (else
       (let ((d (dp hamt-null)))
         (if (hamt-null? d)
         (values 0 n)
         (modify-narrow-new hamt n shift d h k)))))))

(define (modify-narrow-child hamt n shift dp h k)
  (let*-values (((fragment) (hash-fragment shift h))
        ((mask) (fragment->mask fragment))
        ((c) (narrow/children n))
        ((l) (narrow/leaves n))
        ((array) (narrow/array n))
        ((payload?) (hamt/payload? hamt))
        ((child-index)
         (narrow-child-index l c mask payload?))
        ((child) (vector-ref array child-index))
        ((change new-child)
         (modify-pure hamt
                  child
                  (+ shift hamt-hash-slice-size)
                  dp
                  h
                  k)))
    (define (coalesce key datum)
      (let ((leaf-index (narrow-leaf-index l mask payload?)))
    (values change
        (make-narrow (if payload?
                 (vector-edit array
                          (add leaf-index key)
                          (add leaf-index datum)
                          (drop child-index 1))
                 (vector-edit array
                          (add leaf-index key)
                          (drop child-index 1)))
                 (copy-bit fragment c #f)
                 (copy-bit fragment l #t)))))
    (define (replace)
      (values change
          (make-narrow (vector-replace-one array child-index new-child)
               c
               l)))
    (cond ((eq? new-child child) (values 0 n))
      ((hamt-null? new-child)
       (error "Child cannot become null." n))
      ((collision? new-child)
       (if (collision-single-leaf? new-child)
           (let ((a (car (collision/entries new-child))))
         (if payload?
             (coalesce (car a) (cdr a))
             (coalesce a #f)))
           (replace)))
      ((narrow? new-child)
       (if (narrow-single-leaf? new-child)
           (let ((a (narrow/array new-child)))
         (coalesce (vector-ref a 0)
               (and payload? (vector-ref a 1))))
           (replace)))
      ((wide? new-child)
       (error "New child should be collision or narrow."))
      (else (error "Unexpected type of child node.")))))

(define (modify-narrow-leaf hamt n shift dp h k)
  (let* ((fragment (hash-fragment shift h))
     (mask (fragment->mask fragment))
     (c (narrow/children n))
     (l (narrow/leaves n))
     (array (narrow/array n))
     (payload? (hamt/payload? hamt))
     (stride (leaf-stride payload?))
     (leaf-index (narrow-leaf-index l mask payload?))
     (key (vector-ref array leaf-index)))
    (if ((hamt/= hamt) k key)
    (let* ((existing (if payload?
                 (vector-ref array (+ leaf-index 1))
                 hamt-null))
           (d (dp existing)))
      (cond ((hamt-null? d)
         (values -1
             (make-narrow (vector-without array
                              leaf-index
                              (+ leaf-index stride))
                      c
                      (copy-bit fragment l #f))))
        (payload?
         (values
          0
          (make-narrow (vector-replace-one array (+ leaf-index 1) d)
                   c
                   l)))
        (else (values 0 n))))
    (let ((d (dp hamt-null)))
      (if (hamt-null? d)
          (values 0 n)
          (add-narrow-leaf-key hamt n shift d h k))))))

(define (add-narrow-leaf-key hamt n shift d h k)
  (define payload? (hamt/payload? hamt))
  (define make-entry
    (if payload? cons (lambda (k d) k)))
  (let* ((fragment (hash-fragment shift h))
     (mask (fragment->mask fragment))
     (c (narrow/children n))
     (l (narrow/leaves n))
     (array (narrow/array n))
     (payload? (hamt/payload? hamt))
     (stride (leaf-stride payload?))
     (leaf-index (narrow-leaf-index l mask payload?))
     (key (vector-ref array leaf-index))
     (child-index (narrow-child-index l c mask payload?))
     (hash (hash-bits (hamt/hash hamt) key))
     (datum (and payload? (vector-ref array (+ leaf-index 1)))))
    (values 1
        (make-narrow (if (= h hash)
                 (vector-edit
                  array
                  (drop leaf-index stride)
                  (add child-index
                   (make-collision (list (make-entry k d)
                             (make-entry key datum))
                           h)))
                 (vector-edit
                  array
                  (drop leaf-index stride)
                  (add child-index
                   (make-narrow-with-two-keys
                    payload?
                    (+ shift hamt-hash-slice-size)
                    h
                    k
                    d
                    hash
                    key
                    datum))))
             (copy-bit fragment c #t)
             (copy-bit fragment l #f)))))

(define (modify-narrow-new hamt n shift d h k)
  (let* ((fragment (hash-fragment shift h))
     (mask (fragment->mask fragment))
     (c (narrow/children n))
     (l (narrow/leaves n))
     (array (narrow/array n))
     (payload? (hamt/payload? hamt))
     (leaf-index (narrow-leaf-index l mask payload?))
     (delete? (hamt-null? d)))
    (values 1
        (make-narrow (if payload?
                 (vector-edit array
                      (add leaf-index k)
                      (add leaf-index d))
                 (vector-edit array
                      (add leaf-index k)))
             c
             (copy-bit fragment l #t)))))

(define (hamt-fetch hamt key)
  "Fetch datum from `hamt' at `key'.  Return `hamt-null' if the key is
not present.  If `hamt' stores no payloads, return the symbol
`present' if the key is present."
  (let ((h (hash-bits (hamt/hash hamt) key))
    (payload? (hamt/payload? hamt)))
    (let descend ((n (hamt/root hamt))
          (shift 0))
      (cond ((collision? n)
         (let ((entries (collision/entries n))
           (key= (hamt/= hamt)))
           (if payload?
           (cond ((assoc key entries key=) => cdr)
             (else hamt-null))
           (if (find-tail (lambda (e) (key= key e)) entries)
               'present
               hamt-null))))
        ((narrow? n)
         (let ((array (narrow/array n))
           (c (narrow/children n))
           (l (narrow/leaves n))
           (fragment (hash-fragment shift h)))
           (cond ((bit-set? fragment c)
              (let* ((mask (fragment->mask fragment))
                 (child-index (narrow-child-index
                       l
                       c
                       mask
                       (hamt/payload? hamt))))
            (descend (vector-ref array child-index)
                 (+ shift hamt-hash-slice-size))))
             ((bit-set? fragment l)
              (let* ((mask (fragment->mask fragment))
                 (leaf-index
                  (narrow-leaf-index l mask (hamt/payload? hamt)))
                 (k (vector-ref array leaf-index)))
            (if ((hamt/= hamt) k key)
                (if payload?
                (vector-ref array (+ leaf-index 1))
                'present)
                hamt-null)))
             (else hamt-null))))
        ((wide? n)
         (let ((array (wide/array n))
           (stride (leaf-stride (hamt/payload? hamt)))
           (c (wide/children n))
           (l (wide/leaves n))
           (i (hash-fragment shift h)))
           (cond ((bit-set? i c)
              (descend (vector-ref array (* stride i))
                   (+ shift hamt-hash-slice-size)))
             ((bit-set? i l)
              (let* ((j (* stride i))
                 (k (vector-ref array j)))
            (if ((hamt/= hamt) k key)
                (if payload?
                (vector-ref array (+ j 1))
                'present)
                hamt-null)))
             (else hamt-null))))
        (else (error "Unexpected type of child node."))))))

(define (collision/for-each procedure node payload?)
  (if payload?
      (do-list (e (collision/entries node))
    (procedure (car e) (cdr e)))
      (do-list (e (collision/entries node))
    (procedure e #f))))

(define (narrow/for-each procedure node payload?)
  (let ((array (narrow/array node))
    (stride (leaf-stride payload?))
    (c (narrow/children node))
    (l (narrow/leaves node)))
    (let next-leaf ((count 0)
            (start 0))
      (let ((i (next-set-bit l start hamt-bucket-size)))
    (if i
        (let* ((j (* stride count))
           (k (vector-ref array j))
           (d (and payload? (vector-ref array (+ j 1)))))
          (procedure k d)
          (next-leaf (+ count 1) (+ i 1)))
        (let next-child ((start 0)
                 (offset (* stride count)))
          (let ((i (next-set-bit c start hamt-bucket-size)))
        (when i
          (let ((child (vector-ref array offset)))
            (hamt-node/for-each child payload? procedure)
            (next-child (+ i 1) (+ offset 1)))))))))))

(define (wide/for-each procedure node payload?)
  (let ((array (wide/array node))
    (stride (leaf-stride payload?))
    (c (wide/children node))
    (l (wide/leaves node)))
    (do ((i 0 (+ i 1)))
    ((= i hamt-bucket-size))
      (let ((j (* stride i)))
    (cond ((bit-set? i l)
           (let ((k (vector-ref array j))
             (d (and payload? (vector-ref array (+ j 1)))))
         (procedure k d)))
          ((bit-set? i c)
           (let ((child (vector-ref array j)))
         (hamt-node/for-each child payload? procedure))))))))

(define (hamt-node/for-each node payload? procedure)
  (cond ((collision? node) (collision/for-each procedure node payload?))
    ((narrow? node) (narrow/for-each procedure node payload?))
    ((wide? node) (wide/for-each procedure node payload?))
    (else (error "Invalid type of node." node))))

(define (hamt/for-each procedure hamt)
  (hamt-node/for-each (hamt/root hamt)
              (hamt/payload? hamt)
              procedure))

(define (hamt->list hamt procedure)
  (let ((accumulator '()))
    (hamt/for-each (lambda (k v)
             (set! accumulator
               (cons (procedure k v)
                 accumulator)))
           hamt)
    accumulator))

;;; Debugging

(define (assert-collision-valid node hp payload?)
  "Do sanity checks on a collision.  Return the list of all keys
present."
  (let ((entries (collision/entries node))
    (hash (collision/hash node))
    (extract (if payload? car (lambda (x) x))))
    (do-list (a entries)
      (assert (= hash (hash-bits hp (extract a)))))
    (if payload?
    (map car entries)
    entries)))

(define (assert-narrow-valid node hp payload? shift)
  "Do sanity checks on a narrow and all its children.  Return the list
of all keys present."
  (let ((array (narrow/array node))
    (stride (leaf-stride payload?))
    (c (narrow/children node))
    (l (narrow/leaves node)))
    (assert (zero? (bitwise-and c l)))
    (let next-leaf ((count 0)
            (i 0)
            (keys '()))
      (if (< i hamt-bucket-size)
      (cond ((bit-set? i l)
         (let ((k (vector-ref array (* stride count))))
           (assert (= i (hash-fragment shift (hash-bits hp k))))
           (next-leaf (+ count 1) (+ i 1) (cons k keys))))
        (else (next-leaf count (+ i 1) keys)))
      (let next-child ((i 0)
               (key-groups (list keys))
               (offset (* stride count)))
        (if (= i hamt-bucket-size)
        (apply append key-groups)
        (cond ((bit-set? i c)
               (let* ((child (vector-ref array offset))
                  (child-keys (assert-hamt-node-valid
                       child
                       hp
                       payload?
                       (+ shift hamt-hash-slice-size))))
             (do-list (k child-keys)
               (assert (= i
                      (hash-fragment shift (hash-bits hp k)))))
             (next-child (+ i 1)
                     (cons child-keys key-groups)
                     (+ offset 1))))
              (else (next-child (+ i 1) key-groups offset)))))))))

(define (assert-wide-valid node hp payload? shift)
  "Do sanity checks on a wide and all its children.  Return the list
of all keys present."
  (let ((array (wide/array node))
    (stride (leaf-stride payload?))
    (c (wide/children node))
    (l (wide/leaves node)))
    (assert (zero? (bitwise-and c l)))
    (let next-fragment ((i 0)
            (key-groups '()))
      (if (= i hamt-bucket-size)
      (apply append key-groups)
      (let ((j (* stride i)))
        (cond ((bit-set? i l)
           (let ((k (vector-ref array j)))
             (assert (= i (hash-fragment shift (hash-bits hp k))))
             (next-fragment (+ i 1) (cons (list k) key-groups))))
          ((bit-set? i c)
           (let* ((child (vector-ref array j))
              (child-keys (assert-hamt-node-valid
                       child
                       hp
                       payload?
                       (+ shift hamt-hash-slice-size))))
             (do-list (k child-keys)
               (assert (= i
                  (hash-fragment shift (hash-bits hp k)))))
             (next-fragment (+ i 1)
                    (cons child-keys key-groups))))
          (else
           (assert (not (vector-ref array j)))
           (when payload?
             (assert (not (vector-ref array (+ j 1)))))
           (next-fragment (+ i 1) key-groups))))))))

(define (assert-hamt-node-valid node hp payload? shift)
  "Do sanity checks on a HAMT node and all its children.  Return the
list of all keys present."
  (cond ((collision? node) (assert-collision-valid node hp payload?))
    ((narrow? node) (assert-narrow-valid node hp payload? shift))
    ((wide? node) (assert-wide-valid node hp payload? shift))
    (else (error "Invalid type of node." node))))

(define (assert-hamt-valid hamt)
  "Do sanity checks on `hamt'."
  (let ((hp (hamt/hash hamt)))
    (assert (procedure? (hamt/= hamt)))
    (assert (procedure? hp))
    (assert (memq (hamt/mutable? hamt) '(#t #f)))
    (let* ((payload? (hamt/payload? hamt))
       (keys (assert-hamt-node-valid (hamt/root hamt) hp payload? 0)))
      (assert (= (hamt/count hamt) (length keys))))))
;; Copyright (C) Marc Nieper-Wikirchen (2016, 2017).  All Rights
;; Reserved.

;; Permission is hereby granted, free of charge, to any person
;; obtaining a copy of this software and associated documentation
;; files (the "Software"), to deal in the Software without
;; restriction, including without limitation the rights to use, copy,
;; modify, merge, publish, distribute, sublicense, and/or sell copies
;; of the Software, and to permit persons to whom the Software is
;; furnished to do so, subject to the following conditions:

;; The above copyright notice and this permission notice shall be
;; included in all copies or substantial portions of the Software.

;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
;; EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
;; MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
;; NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
;; BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
;; ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
;; CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
;; SOFTWARE.

(define-library (srfi 146 hash-test)
  (export run-tests)
  (import (scheme base)
          (srfi 1)
          (srfi 8)
          (srfi 146 hash)
          (srfi 128)
          (chibi test))
  (begin
    (define comparator (make-default-comparator))

    (define (run-tests)
      (test-begin "srfi-146: hashmaps")

      (test-group "Predicates"
        (define hashmap0 (hashmap comparator))
        (define hashmap1 (hashmap comparator 'a 1 'b 2 'c 3))
        (define hashmap2 (hashmap comparator 'c 1 'd 2 'e 3))
        (define hashmap3 (hashmap comparator 'd 1 'e 2 'f 3))

        (test-assert "hashmap?: a hashmap"
          (hashmap? (hashmap comparator)))

        (test-assert "hashmap?: not a hashmap"
          (not (hashmap? (list 1 2 3))))

        (test-assert "hashmap-empty?: empty hashmap"
          (hashmap-empty? hashmap0))

        (test-assert "hashmap-empty?: non-empty hashmap"
          (not (hashmap-empty? hashmap1)))

        (test-assert "hashmap-contains?: containing"
          (hashmap-contains? hashmap1 'b))

        (test-assert "hashmap-contains?: not containing"
          (not (hashmap-contains? hashmap1 '2)))

        (test-assert "hashmap-disjoint?: disjoint"
          (hashmap-disjoint? hashmap1 hashmap3))

        (test-assert "hashmap-disjoint?: not disjoint"
          (not (hashmap-disjoint? hashmap1 hashmap2))))

      (test-group "Accessors"
        (define hashmap1 (hashmap comparator 'a 1 'b 2 'c 3))

        (test "hashmap-ref: key found"
                    2
                    (hashmap-ref hashmap1 'b))

        (test "hashmap-ref: key not found/with failure"
                    42
                    (hashmap-ref hashmap1 'd (lambda () 42)))

        (test-error "hashmap-ref: key not found/without failure"
                    (hashmap-ref hashmap1 'd))

        (test "hashmap-ref: with success procedure"
                    (* 2 2)
                    (hashmap-ref hashmap1 'b (lambda () #f) (lambda (x) (* x x))))

        (test "hashmap-ref/default: key found"
                    3
                    (hashmap-ref/default hashmap1 'c 42))

        (test "hashmap-ref/default: key not found"
                    42
                    (hashmap-ref/default hashmap1 'd 42))

        (test "hashmap-key-comparator"
                    comparator
                    (hashmap-key-comparator hashmap1)))

      (test-group "Updaters"
        (define hashmap1 (hashmap comparator 'a 1 'b 2 'c 3))
        (define hashmap2 (hashmap-set hashmap1 'c 4 'd 4 'd 5))
        (define hashmap3 (hashmap-update hashmap1 'b (lambda (x) (* x x))))
        (define hashmap4 (hashmap-update/default hashmap1 'd (lambda (x) (* x x)) 4))
        (define hashmap5 (hashmap-adjoin hashmap1 'c 4 'd 4 'd 5))
        (define hashmap0 (hashmap comparator))

        (test "hashmap-adjoin: key already in hashmap"
                    3
                    (hashmap-ref hashmap5 'c))

        (test "hashmap-adjoin: key set earlier"
                    4
                    (hashmap-ref hashmap5 'd))

        (test "hashmap-set: key already in hashmap"
                    4
                    (hashmap-ref hashmap2 'c))

        (test "hashmap-set: key set earlier"
                    5
                    (hashmap-ref hashmap2 'd))

        (test "hashmap-replace: key not in hashmap"
                    #f
                    (hashmap-ref/default (hashmap-replace hashmap1 'd 4) 'd #f))

        (test "hashmap-replace: key in hashmap"
                    6
                    (hashmap-ref (hashmap-replace hashmap1 'c 6) 'c))

        (test "hashmap-delete"
                    42
                    (hashmap-ref/default (hashmap-delete hashmap1 'b) 'b 42))

        (test "hashmap-delete-all"
                    42
                    (hashmap-ref/default (hashmap-delete-all hashmap1 '(a b)) 'b 42))

        (test "hashmap-intern: key in hashmap"
                    (list hashmap1 2)
                    (receive result
                        (hashmap-intern hashmap1 'b (lambda () (error "should not have been invoked")))
                      result))

        (test "hashmap-intern: key not in hashmap"
                    (list 42 42)
                    (receive (hashmap value)
                        (hashmap-intern hashmap1 'd (lambda () 42))
                      (list value (hashmap-ref hashmap 'd))))

        (test "hashmap-update"
                    4
                    (hashmap-ref hashmap3 'b))

        (test "hashmap-update/default"
                    16
                    (hashmap-ref hashmap4 'd))

        (test "hashmap-pop: empty hashmap"
                    'empty
                    (hashmap-pop hashmap0 (lambda () 'empty)))

        (test-assert "hashmap-pop: non-empty hashmap"
          (member
           (receive (hashmap key value)
               (hashmap-pop hashmap1)
             (list (hashmap-size hashmap) key value))
           '((2 a 1) (2 b 2) (2 c 3)))))

      (test-group "The whole hashmap"
        (define hashmap0 (hashmap comparator))
        (define hashmap1 (hashmap comparator 'a 1 'b 2 'c 3))

        (test "hashmap-size: empty hashmap"
                    0
                    (hashmap-size hashmap0))

        (test "hashmap-size: non-empty hashmap"
                    3
                    (hashmap-size hashmap1))

        (test "hashmap-find: found in hashmap"
                    (list 'b 2)
                    (receive result
                        (hashmap-find (lambda (key value)
                                        (and (eq? key 'b)
                                             (= value 2)))
                                      hashmap1
                                      (lambda () (error "should not have been called")))
                      result))

        (test "hashmap-find: not found in hashmap"
                    (list 42)
                    (receive result
                        (hashmap-find (lambda (key value)
                                        (eq? key 'd))
                                      hashmap1
                                      (lambda ()
                                        42))
                      result))

        (test "hashmap-count"
                    2
                    (hashmap-count (lambda (key value)
                                     (>= value 2))
                                   hashmap1))

        (test-assert "hashmap-any?: found"
          (hashmap-any? (lambda (key value)
                          (= value 3))
                        hashmap1))

        (test-assert "hashmap-any?: not found"
          (not (hashmap-any? (lambda (key value)
                               (= value 4))
                             hashmap1)))

        (test-assert "hashmap-every?: true"
          (hashmap-every? (lambda (key value)
                            (<= value 3))
                          hashmap1))

        (test-assert "hashmap-every?: false"
          (not (hashmap-every? (lambda (key value)
                                 (<= value 2))
                               hashmap1)))

        (test "hashmap-keys"
                    3
                    (length (hashmap-keys hashmap1)))

        (test "hashmap-values"
                    6
                    (fold + 0 (hashmap-values hashmap1)))

        (test "hashmap-entries"
                    (list 3 6)
                    (receive (keys values)
                        (hashmap-entries hashmap1)
                      (list (length keys) (fold + 0 values)))))

      (test-group "Hashmap and folding"
        (define hashmap1 (hashmap comparator 'a 1 'b 2 'c 3))
        (define hashmap2 (hashmap-map (lambda (key value)
                                        (values (symbol->string key)
                                                (* 10 value)))
                                      comparator
                                      hashmap1))

        (test "hashmap-map"
                    20
                    (hashmap-ref hashmap2 "b"))

        (test "hashmap-for-each"
                    6
                    (let ((counter 0))
                      (hashmap-for-each (lambda (key value)
                                          (set! counter (+ counter value)))
                                        hashmap1)
                      counter))

        (test "hashmap-fold"
                    6
                    (hashmap-fold (lambda (key value acc)
                                    (+ value acc))
                                  0
                                  hashmap1))

        (test "hashmap-map->list"
                    (+ (* 1 1) (* 2 2) (* 3 3))
                    (fold + 0 (hashmap-map->list (lambda (key value)
                                                   (* value value))
                                                 hashmap1)))

        (test "hashmap-filter"
                    2
                    (hashmap-size (hashmap-filter (lambda (key value)
                                                    (<= value 2))
                                                  hashmap1)))

        (test "hashmap-remove"
                    1
                    (hashmap-size (hashmap-remove (lambda (key value)
                                                    (<= value 2))
                                                  hashmap1)))

        (test "hashmap-partition"
                    (list 1 2)
                    (receive result
                        (hashmap-partition (lambda (key value)
                                             (eq? 'b key))
                                           hashmap1)
                      (map hashmap-size result)))

        (test-group "Copying and conversion"
          (define hashmap1 (hashmap comparator 'a 1 'b 2 'c 3))
          (define hashmap2 (alist->hashmap comparator '((a . 1) (b . 2) (c . 3))))
          (define hashmap3 (alist->hashmap! (hashmap-copy hashmap1) '((d . 4) '(c . 5))))

          (test "hashmap-copy: same size"
                      3
                      (hashmap-size (hashmap-copy hashmap1)))

          (test "hashmap-copy: same comparator"
                      comparator
                      (hashmap-key-comparator (hashmap-copy hashmap1)))

          (test "hashmap->alist"
                      (cons 'b 2)
                      (assq 'b (hashmap->alist hashmap1)))

          (test "alist->hashmap"
                      2
                      (hashmap-ref hashmap2 'b)
                      )

          (test "alist->hashmap!: new key"
                      4
                      (hashmap-ref hashmap3 'd))

          (test "alist->hashmap!: existing key"
                      3
                      (hashmap-ref hashmap3 'c)))

        (test-group "Subhashmaps"
          (define hashmap1 (hashmap comparator 'a 1 'b 2 'c 3))
          (define hashmap2 (hashmap comparator 'a 1 'b 2 'c 3))
          (define hashmap3 (hashmap comparator 'a 1 'c 3))
          (define hashmap4 (hashmap comparator 'a 1 'c 3 'd 4))
          (define hashmap5 (hashmap comparator 'a 1 'b 2 'c 6))
          (define hashmap6 (hashmap (make-comparator (comparator-type-test-predicate comparator)
                                                     (comparator-equality-predicate comparator)
                                                     (comparator-ordering-predicate comparator)
                                                     (comparator-hash-function comparator))
                                    'a 1 'b 2 'c 3))


          (test-assert "hashmap=?: equal hashmaps"
            (hashmap=? comparator hashmap1 hashmap2))

          (test-assert "hashmap=?: unequal hashmaps"
            (not (hashmap=? comparator hashmap1 hashmap4)))

          (test-assert "hashmap=?: different comparators"
            (not (hashmap=? comparator hashmap1 hashmap6)))

          (test-assert "hashmap<?: proper subset"
            (hashmap<? comparator hashmap3 hashmap1))

          (test-assert "hashmap<?: improper subset"
            (not (hashmap<? comparator hashmap3 hashmap1 hashmap2)))

          (test-assert "hashmap>?: proper superset"
            (hashmap>? comparator hashmap2 hashmap3))

          (test-assert "hashmap>?: improper superset"
            (not (hashmap>? comparator hashmap1 hashmap2 hashmap3)))

          (test-assert "hashmap<=?: subset"
            (hashmap<=? comparator hashmap3 hashmap2 hashmap1))

          (test-assert "hashmap<=?: non-matching values"
            (not (hashmap<=? comparator hashmap3 hashmap5)))

          (test-assert "hashmap<=?: not a subset"
            (not (hashmap<=? comparator hashmap2 hashmap4)))

          (test-assert "hashmap>=?: superset"
            (hashmap>=? comparator hashmap4 hashmap3))

          (test-assert "hashmap>=?: not a superset"
            (not (hashmap>=? comparator hashmap5 hashmap3))))

        (test-group "Set theory operations"
          (define hashmap1 (hashmap comparator 'a 1 'b 2 'c 3))
          (define hashmap2 (hashmap comparator 'a 1 'b 2 'd 4))
          (define hashmap3 (hashmap comparator 'a 1 'b 2))
          (define hashmap4 (hashmap comparator 'a 1 'b 2 'c 4))
          (define hashmap5 (hashmap comparator 'a 1 'c 3))
          (define hashmap6 (hashmap comparator 'd 4 'e 5 'f 6))

          (test "hashmap-union: new association"
                      4
                      (hashmap-ref (hashmap-union hashmap1 hashmap2) 'd))

          (test "hashmap-union: existing association"
                      3
                      (hashmap-ref (hashmap-union hashmap1 hashmap4) 'c))

          (test "hashmap-union: three hashmaps"
                      6
                      (hashmap-size (hashmap-union hashmap1 hashmap2 hashmap6)))

          (test "hashmap-intersection: existing association"
                      3
                      (hashmap-ref (hashmap-intersection hashmap1 hashmap4) 'c))

          (test "hashmap-intersection: removed association"
                      42
                      (hashmap-ref/default (hashmap-intersection hashmap1 hashmap5) 'b 42))

          (test "hashmap-difference"
                      2
                      (hashmap-size (hashmap-difference hashmap2 hashmap6)))

          (test "hashmap-xor"
                      4
                      (hashmap-size (hashmap-xor hashmap2 hashmap6))))

        (test-group "Comparators"
          (define hashmap1 (hashmap comparator 'a 1 'b 2 'c 3))
          (define hashmap2 (hashmap comparator 'a 1 'b 2 'c 3))
          (define hashmap3 (hashmap comparator 'a 1 'b 2))
          (define hashmap4 (hashmap comparator 'a 1 'b 2 'c 4))
          (define hashmap5 (hashmap comparator 'a 1 'c 3))
          (define hashmap0 (hashmap comparator
                                    hashmap1 "a"
                                    hashmap2 "b"
                                    hashmap3 "c"
                                    hashmap4 "d"
                                    hashmap5 "e"))

          (test-assert "hashmap-comparator"
            (comparator? hashmap-comparator))

          (test "hashmap-keyed hashmap"
                      (list "a" "a" "c" "d" "e")
                      (list (hashmap-ref hashmap0 hashmap1)
                            (hashmap-ref hashmap0 hashmap2)
                            (hashmap-ref hashmap0 hashmap3)
                            (hashmap-ref hashmap0 hashmap4)
                            (hashmap-ref hashmap0 hashmap5)
                            ))

          (test-group "Ordering comparators"
            (test-assert "=?: equal hashmaps"
              (=? comparator hashmap1 hashmap2))

            (test-assert "=?: unequal hashmaps"
              (not (=? comparator hashmap1 hashmap4))))))

      (test-end "srfi-146: hashmaps"))))
;;;; `vector-edit' tests

;;; Copyright MMIV-MMXV Arthur A. Gleckler.  All rights reserved.

;; Permission is hereby granted, free of charge, to any person
;; obtaining a copy of this software and associated documentation
;; files (the "Software"), to deal in the Software without
;; restriction, including without limitation the rights to use, copy,
;; modify, merge, publish, distribute, sublicense, and/or sell copies
;; of the Software, and to permit persons to whom the Software is
;; furnished to do so, subject to the following conditions:

;; The above copyright notice and this permission notice shall be
;; included in all copies or substantial portions of the Software.

;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
;; EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
;; MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
;; NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
;; HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
;; WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
;; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
;; DEALINGS IN THE SOFTWARE.

(define (run-vector-edit-tests)
  (test-begin "vector-edit")

  (test-group "(vector-without)"
    (define (check expected start end)
      (let ((v #(0 1 2 3 4)))
    (test expected (vector-without v start end))))
    (check #(0 1 2 3 4) 0 0)
    (check #() 0 5)
    (check #(1 2 3 4) 0 1)
    (check #(2 3 4) 0 2)
    (check #(0 2 3 4) 1 2)
    (check #(0 3 4) 1 3)
    (check #(0 1 4) 2 4)
    (check #(0 1 2 3) 4 5)
    (check #(0 1 2) 3 5))

  (test-group "(vector-edit empty)"
    (let ((array (vector 0 1 2)))
      (test #(0 1 2) (vector-edit array))))

  (test-group "(vector-edit adjacent-adds)"
    (let ((array (vector 0 1 2)))
      (test #(0 1 2 3 4)
        (vector-edit array
             (add 3 3)
             (add 3 4)))))

  (test-group "(vector-edit adjacent-drops)"
    (let ((array (vector 0 1 2 3 4 5)))
      (test #(0 1 2)
        (vector-edit array
             (drop 3 1)
             (drop 4 2)))))

  (test-group "(vector-edit alternating-add-drop)"
    (let ((array (vector 0 1 2 2 2 3 4 6 6 6 6 7 9)))
      (test #(0 1 2 3 4 5 6 7 8 9)
        (vector-edit array
             (drop 3 2)
             (add 7 5)
             (drop 8 3)
             (add 12 8)))))

  (test-end));; Copyright (C) Marc Nieper-Wikirchen (2018).  All Rights
;; Reserved.

;; Permission is hereby granted, free of charge, to any person
;; obtaining a copy of this software and associated documentation
;; files (the "Software"), to deal in the Software without
;; restriction, including without limitation the rights to use, copy,
;; modify, merge, publish, distribute, sublicense, and/or sell copies
;; of the Software, and to permit persons to whom the Software is
;; furnished to do so, subject to the following conditions:

;; The above copyright notice and this permission notice shall be
;; included in all copies or substantial portions of the Software.

;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
;; EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
;; MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
;; NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
;; BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
;; ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
;; CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
;; SOFTWARE.

;;; Implementation layer

(define (tree-search comparator tree obj failure success)
  (let ((entry (phm/get tree obj)))
    (if entry
    (success (car entry) (cdr entry)
         (lambda (new-key new-datum ret)
           (let ((tree (phm/remove tree obj)))
             (values (phm/put tree new-key (cons new-key new-datum))
                 ret)))
         (lambda (ret)
           (values (phm/remove tree obj) ret)))
    (failure (lambda (new-key new-datum ret)
           (values (phm/put tree new-key (cons new-key new-datum))
               ret))
         (lambda (ret)
           (values tree ret))))))

(define (tree-fold proc seed tree)
  (phm/for-each (lambda (key entry)
          (set! seed (proc (car entry) (cdr entry) seed)))
        tree)
  seed)

(define (tree-for-each proc tree)
  (phm/for-each (lambda (key entry)
          (proc (car entry) (cdr entry)))
        tree))

(define (tree-generator tree)
  (make-coroutine-generator
   (lambda (yield)
     (tree-for-each (lambda item (yield item))
            tree))))

;;; New types

(define-record-type <hashmap>
  (%make-hashmap comparator tree)
  hashmap?
  (comparator hashmap-key-comparator)
  (tree hashmap-tree))

(define (make-empty-hashmap comparator)
  (assume (comparator? comparator))
  (%make-hashmap comparator
         (make-phm (comparator-hash-function comparator)
               (comparator-equality-predicate comparator))))

;;; Exported procedures

;; Constructors

(define (hashmap comparator . args)
  (assume (comparator? comparator))
  (hashmap-unfold null?
          (lambda (args)
        (values (car args)
            (cadr args)))
          cddr
          args
          comparator))

(define (hashmap-unfold stop? mapper successor seed comparator)
  (assume (procedure? stop?))
  (assume (procedure? mapper))
  (assume (procedure? successor))
  (assume (comparator? comparator))
  (let loop ((hashmap (make-empty-hashmap comparator))
         (seed seed))
    (if (stop? seed)
    hashmap
    (receive (key value)
        (mapper seed)
      (loop (hashmap-adjoin hashmap key value)
        (successor seed))))))

;; Predicates

(define (hashmap-empty? hashmap)
  (assume (hashmap? hashmap))
  (not (hashmap-any? (lambda (key value) #t) hashmap)))

(define (hashmap-contains? hashmap key)
  (assume (hashmap? hashmap))
  (call/cc
   (lambda (return)
     (hashmap-search hashmap
         key
         (lambda (insert ignore)
           (return #f))
         (lambda (key value update remove)
           (return #t))))))

(define (hashmap-disjoint? hashmap1 hashmap2)
  (assume (hashmap? hashmap1))
  (assume (hashmap? hashmap2))
  (call/cc
   (lambda (return)
     (hashmap-for-each (lambda (key value)
             (when (hashmap-contains? hashmap2 key)
               (return #f)))
           hashmap1)
     #t)))

;; Accessors

(define hashmap-ref
  (case-lambda
    ((hashmap key)
     (assume (hashmap? hashmap))
     (hashmap-ref hashmap key (lambda ()
            (error "hashmap-ref: key not in hashmap" key))))
    ((hashmap key failure)
     (assume (hashmap? hashmap))
     (assume (procedure? failure))
     (hashmap-ref hashmap key failure (lambda (value)
                value)))
    ((hashmap key failure success)
     (assume (hashmap? hashmap))
     (assume (procedure? failure))
     (assume (procedure? success))
     ((call/cc
       (lambda (return-thunk)
     (hashmap-search hashmap
             key
             (lambda (insert ignore)
               (return-thunk failure))
             (lambda (key value update remove)
               (return-thunk (lambda () (success value)))))))))))

(define (hashmap-ref/default hashmap key default)
  (assume (hashmap? hashmap))
  (hashmap-ref hashmap key (lambda () default)))

;; Updaters

(define (hashmap-adjoin hashmap . args)
  (assume (hashmap? hashmap))
  (let loop ((args args)
         (hashmap hashmap))
    (if (null? args)
    hashmap
    (receive (hashmap value)
        (hashmap-intern hashmap (car args) (lambda () (cadr args)))
      (loop (cddr args) hashmap)))))

(define hashmap-adjoin! hashmap-adjoin)

(define (hashmap-set hashmap . args)
  (assume (hashmap? hashmap))
  (let loop ((args args)
         (hashmap hashmap))
    (if (null? args)
    hashmap
    (receive (hashmap)
        (hashmap-update hashmap (car args) (lambda (value) (cadr args)) (lambda () #f))
      (loop (cddr args)
        hashmap)))))

(define hashmap-set! hashmap-set)

(define (hashmap-replace hashmap key value)
  (assume (hashmap? hashmap))
  (receive (hashmap obj)
      (hashmap-search hashmap
          key
          (lambda (insert ignore)
            (ignore #f))
          (lambda (old-key old-value update remove)
            (update key value #f)))
    hashmap))

(define hashmap-replace! hashmap-replace)

(define (hashmap-delete hashmap . keys)
  (assume (hashmap? hashmap))
  (hashmap-delete-all hashmap keys))

(define hashmap-delete! hashmap-delete)

(define (hashmap-delete-all hashmap keys)
  (assume (hashmap? hashmap))
  (assume (list? keys))
  (fold (lambda (key hashmap)
      (receive (hashmap obj)
          (hashmap-search hashmap
              key
              (lambda (insert ignore)
                (ignore #f))
              (lambda (old-key old-value update remove)
                (remove #f)))
        hashmap))
    hashmap keys))

(define hashmap-delete-all! hashmap-delete-all)

(define (hashmap-intern hashmap key failure)
  (assume (hashmap? hashmap))
  (assume (procedure? failure))
  (call/cc
   (lambda (return)
     (hashmap-search hashmap
         key
         (lambda (insert ignore)
           (receive (value)
               (failure)
             (insert value value)))
         (lambda (old-key old-value update remove)
           (return hashmap old-value))))))

(define hashmap-intern! hashmap-intern)

(define hashmap-update
  (case-lambda
   ((hashmap key updater)
    (hashmap-update hashmap key updater (lambda ()
                  (error "hashmap-update: key not found in hashmap" key))))
   ((hashmap key updater failure)
    (hashmap-update hashmap key updater failure (lambda (value)
                      value)))
   ((hashmap key updater failure success)
    (assume (hashmap? hashmap))
    (assume (procedure? updater))
    (assume (procedure? failure))
    (assume (procedure? success))
    (receive (hashmap obj)
    (hashmap-search hashmap
            key
            (lambda (insert ignore)
              (insert (updater (failure)) #f))
            (lambda (old-key old-value update remove)
              (update key (updater (success old-value)) #f)))
      hashmap))))

(define hashmap-update! hashmap-update)

(define (hashmap-update/default hashmap key updater default)
  (hashmap-update hashmap key updater (lambda () default)))

(define hashmap-update!/default hashmap-update/default)

(define hashmap-pop
  (case-lambda
    ((hashmap)
     (hashmap-pop hashmap (lambda ()
                (error "hashmap-pop: hashmap has no association"))))
    ((hashmap failure)
     (assume (hashmap? hashmap))
     (assume (procedure? failure))
     ((call/cc
       (lambda (return-thunk)
     (receive (key value)
         (hashmap-find (lambda (key value) #t) hashmap (lambda () (return-thunk failure)))
       (lambda ()
         (values (hashmap-delete hashmap key) key value)))))))))

(define hashmap-pop! hashmap-pop)

(define (hashmap-search hashmap key failure success)
  (assume (hashmap? hashmap))
  (assume (procedure? failure))
  (assume (procedure? success))
  (call/cc
   (lambda (return)
     (let*-values
     (((comparator)
       (hashmap-key-comparator hashmap))
      ((tree obj)
       (tree-search comparator
            (hashmap-tree hashmap)
            key
            (lambda (insert ignore)
              (failure (lambda (value obj)
                     (insert key value obj))
                   (lambda (obj)
                     (return hashmap obj))))
            success)))
       (values (%make-hashmap comparator tree)
           obj)))))

(define hashmap-search! hashmap-search)

;; The whole hashmap

(define (hashmap-size hashmap)
  (assume (hashmap? hashmap))
  (hashmap-count (lambda (key value)
           #t)
         hashmap))

(define (hashmap-find predicate hashmap failure)
  (assume (procedure? predicate))
  (assume (hashmap? hashmap))
  (assume (procedure? failure))
  (call/cc
   (lambda (return)
     (hashmap-for-each (lambda (key value)
             (when (predicate key value)
               (return key value)))
           hashmap)
     (failure))))

(define (hashmap-count predicate hashmap)
  (assume (procedure? predicate))
  (assume (hashmap? hashmap))
  (hashmap-fold (lambda (key value count)
          (if (predicate key value)
          (+ 1 count)
          count))
        0 hashmap))

(define (hashmap-any? predicate hashmap)
  (assume (procedure? predicate))
  (assume (hashmap? hashmap))
  (call/cc
   (lambda (return)
     (hashmap-for-each (lambda (key value)
             (when (predicate key value)
               (return #t)))
           hashmap)
     #f)))

(define (hashmap-every? predicate hashmap)
  (assume (procedure? predicate))
  (assume (hashmap? hashmap))
  (not (hashmap-any? (lambda (key value)
           (not (predicate key value)))
         hashmap)))

(define (hashmap-keys hashmap)
  (assume (hashmap? hashmap))
  (hashmap-fold (lambda (key value keys)
          (cons key keys))
        '() hashmap))

(define (hashmap-values hashmap)
  (assume (hashmap? hashmap))
  (hashmap-fold (lambda (key value values)
          (cons value values))
        '() hashmap))

(define (hashmap-entries hashmap)
  (assume (hashmap? hashmap))
  (values (hashmap-keys hashmap)
      (hashmap-values hashmap)))

;; Hashmap and folding

(define (hashmap-map proc comparator hashmap)
  (assume (procedure? proc))
  (assume (comparator? comparator))
  (assume (hashmap? hashmap))
  (hashmap-fold (lambda (key value hashmap)
          (receive (key value)
          (proc key value)
        (hashmap-set hashmap key value)))
        (make-empty-hashmap comparator)
        hashmap))

(define (hashmap-for-each proc hashmap)
  (assume (procedure? proc))
  (assume (hashmap? hashmap))
  (tree-for-each proc (hashmap-tree hashmap)))

(define (hashmap-fold proc acc hashmap)
  (assume (procedure? proc))
  (assume (hashmap? hashmap))
  (tree-fold proc acc (hashmap-tree hashmap)))

(define (hashmap-map->list proc hashmap)
  (assume (procedure? proc))
  (assume (hashmap? hashmap))
  (hashmap-fold (lambda (key value lst)
          (cons (proc key value) lst))
        '()
        hashmap))

(define (hashmap-filter predicate hashmap)
  (assume (procedure? predicate))
  (assume (hashmap? hashmap))
  (hashmap-fold (lambda (key value hashmap)
          (if (predicate key value)
          (hashmap-set hashmap key value)
          hashmap))
        (make-empty-hashmap (hashmap-key-comparator hashmap))
        hashmap))

(define hashmap-filter! hashmap-filter)

(define (hashmap-remove predicate hashmap)
  (assume (procedure? predicate))
  (assume (hashmap? hashmap))
  (hashmap-filter (lambda (key value)
        (not (predicate key value)))
          hashmap))

(define hashmap-remove! hashmap-remove)

(define (hashmap-partition predicate hashmap)
  (assume (procedure? predicate))
  (assume (hashmap? hashmap))
  (values (hashmap-filter predicate hashmap)
      (hashmap-remove predicate hashmap)))

(define hashmap-partition! hashmap-partition)

;; Copying and conversion

(define (hashmap-copy hashmap)
  (assume (hashmap? hashmap))
  hashmap)

(define (hashmap->alist hashmap)
  (assume (hashmap? hashmap))
  (hashmap-fold (lambda (key value alist)
          (cons (cons key value) alist))
        '() hashmap))

(define (alist->hashmap comparator alist)
  (assume (comparator? comparator))
  (assume (list? alist))
  (hashmap-unfold null?
          (lambda (alist)
        (let ((key (caar alist))
              (value (cdar alist)))
          (values key value)))
          cdr
          alist
          comparator))

(define (alist->hashmap! hashmap alist)
  (assume (hashmap? hashmap))
  (assume (list? alist))
  (fold (lambda (association hashmap)
      (let ((key (car association))
        (value (cdr association)))
        (hashmap-set hashmap key value)))
    hashmap
    alist))

;; Subhashmaps

(define hashmap=?
  (case-lambda
    ((comparator hashmap)
     (assume (hashmap? hashmap))
     #t)
    ((comparator hashmap1 hashmap2) (%hashmap=? comparator hashmap1 hashmap2))
    ((comparator hashmap1 hashmap2 . hashmaps)
     (and (%hashmap=? comparator hashmap1 hashmap2)
          (apply hashmap=? comparator hashmap2 hashmaps)))))
(define (%hashmap=? comparator hashmap1 hashmap2)
  (and (eq? (hashmap-key-comparator hashmap1) (hashmap-key-comparator hashmap2))
       (%hashmap<=? comparator hashmap1 hashmap2)
       (%hashmap<=? comparator hashmap2 hashmap1)))

(define hashmap<=?
  (case-lambda
    ((comparator hashmap)
     (assume (hashmap? hashmap))
     #t)
    ((comparator hashmap1 hashmap2)
     (assume (comparator? comparator))
     (assume (hashmap? hashmap1))
     (assume (hashmap? hashmap2))
     (%hashmap<=? comparator hashmap1 hashmap2))
    ((comparator hashmap1 hashmap2 . hashmaps)
     (assume (comparator? comparator))
     (assume (hashmap? hashmap1))
     (assume (hashmap? hashmap2))
     (and (%hashmap<=? comparator hashmap1 hashmap2)
          (apply hashmap<=? comparator hashmap2 hashmaps)))))

(define (%hashmap<=? comparator hashmap1 hashmap2)
  (assume (comparator? comparator))
  (assume (hashmap? hashmap1))
  (assume (hashmap? hashmap2))
  (hashmap-every? (lambda (key value)
            (hashmap-ref hashmap2 key
                 (lambda ()
                   #f)
                 (lambda (stored-value)
                   (=? comparator value stored-value))))
          hashmap1))

(define hashmap>?
  (case-lambda
    ((comparator hashmap)
     (assume (hashmap? hashmap))
     #t)
    ((comparator hashmap1 hashmap2)
     (assume (comparator? comparator))
     (assume (hashmap? hashmap1))
     (assume (hashmap? hashmap2))
     (%hashmap>? comparator hashmap1 hashmap2))
    ((comparator hashmap1 hashmap2 . hashmaps)
     (assume (comparator? comparator))
     (assume (hashmap? hashmap1))
     (assume (hashmap? hashmap2))
     (and (%hashmap>? comparator  hashmap1 hashmap2)
          (apply hashmap>? comparator hashmap2 hashmaps)))))

(define (%hashmap>? comparator hashmap1 hashmap2)
  (assume (comparator? comparator))
  (assume (hashmap? hashmap1))
  (assume (hashmap? hashmap2))
  (not (%hashmap<=? comparator hashmap1 hashmap2)))

(define hashmap<?
  (case-lambda
    ((comparator hashmap)
     (assume (hashmap? hashmap))
     #t)
    ((comparator hashmap1 hashmap2)
     (assume (comparator? comparator))
     (assume (hashmap? hashmap1))
     (assume (hashmap? hashmap2))
     (%hashmap<? comparator hashmap1 hashmap2))
    ((comparator hashmap1 hashmap2 . hashmaps)
     (assume (comparator? comparator))
     (assume (hashmap? hashmap1))
     (assume (hashmap? hashmap2))
     (and (%hashmap<? comparator  hashmap1 hashmap2)
          (apply hashmap<? comparator hashmap2 hashmaps)))))

(define (%hashmap<? comparator hashmap1 hashmap2)
     (assume (comparator? comparator))
     (assume (hashmap? hashmap1))
     (assume (hashmap? hashmap2))
     (%hashmap>? comparator hashmap2 hashmap1))

(define hashmap>=?
  (case-lambda
    ((comparator hashmap)
     (assume (hashmap? hashmap))
     #t)
    ((comparator hashmap1 hashmap2)
     (assume (comparator? comparator))
     (assume (hashmap? hashmap1))
     (assume (hashmap? hashmap2))
     (%hashmap>=? comparator hashmap1 hashmap2))
    ((comparator hashmap1 hashmap2 . hashmaps)
     (assume (comparator? comparator))
     (assume (hashmap? hashmap1))
     (assume (hashmap? hashmap2))
     (and (%hashmap>=? comparator hashmap1 hashmap2)
          (apply hashmap>=? comparator hashmap2 hashmaps)))))

(define (%hashmap>=? comparator hashmap1 hashmap2)
  (assume (comparator? comparator))
  (assume (hashmap? hashmap1))
  (assume (hashmap? hashmap2))
  (not (%hashmap<? comparator hashmap1 hashmap2)))

;; Set theory operations

(define (%hashmap-union hashmap1 hashmap2)
  (hashmap-fold (lambda (key2 value2 hashmap)
          (receive (hashmap obj)
              (hashmap-search hashmap
                      key2
                      (lambda (insert ignore)
                    (insert value2 #f))
                      (lambda (key1 value1 update remove)
                    (update key1 value1 #f)))
            hashmap))
        hashmap1 hashmap2))

(define (%hashmap-intersection hashmap1 hashmap2)
  (hashmap-filter (lambda (key1 value1)
        (hashmap-contains? hashmap2 key1))
          hashmap1))

(define (%hashmap-difference hashmap1 hashmap2)
  (hashmap-fold (lambda (key2 value2 hashmap)
          (receive (hashmap obj)
          (hashmap-search hashmap
                  key2
                  (lambda (insert ignore)
                (ignore #f))
                  (lambda (key1 value1 update remove)
                (remove #f)))
        hashmap))
        hashmap1 hashmap2))

(define (%hashmap-xor hashmap1 hashmap2)
  (hashmap-fold (lambda (key2 value2 hashmap)
          (receive (hashmap obj)
          (hashmap-search hashmap
                  key2
                  (lambda (insert ignore)
                (insert value2 #f))
                  (lambda (key1 value1 update remove)
                (remove #f)))
        hashmap))
        hashmap1 hashmap2))

(define hashmap-union
  (case-lambda
    ((hashmap)
     (assume (hashmap? hashmap))
     hashmap)
    ((hashmap1 hashmap2)
     (assume (hashmap? hashmap1))
     (assume (hashmap? hashmap2))
     (%hashmap-union hashmap1 hashmap2))
    ((hashmap1 hashmap2 . hashmaps)
     (assume (hashmap? hashmap1))
     (assume (hashmap? hashmap2))
     (apply hashmap-union (%hashmap-union hashmap1 hashmap2) hashmaps))))
(define hashmap-union! hashmap-union)

(define hashmap-intersection
  (case-lambda
    ((hashmap)
     (assume (hashmap? hashmap))
     hashmap)
    ((hashmap1 hashmap2)
     (assume (hashmap? hashmap1))
     (assume (hashmap? hashmap2))
     (%hashmap-intersection hashmap1 hashmap2))
    ((hashmap1 hashmap2 . hashmaps)
     (assume (hashmap? hashmap1))
     (assume (hashmap? hashmap2))
     (apply hashmap-intersection (%hashmap-intersection hashmap1 hashmap2) hashmaps))))
(define hashmap-intersection! hashmap-intersection)

(define hashmap-difference
  (case-lambda
    ((hashmap)
     (assume (hashmap? hashmap))
     hashmap)
    ((hashmap1 hashmap2)
     (assume (hashmap? hashmap1))
     (assume (hashmap? hashmap2))
     (%hashmap-difference hashmap1 hashmap2))
    ((hashmap1 hashmap2 . hashmaps)
     (assume (hashmap? hashmap1))
     (assume (hashmap? hashmap2))
     (apply hashmap-difference (%hashmap-difference hashmap1 hashmap2) hashmaps))))
(define hashmap-difference! hashmap-difference)

(define hashmap-xor
  (case-lambda
    ((hashmap)
     (assume (hashmap? hashmap))
     hashmap)
    ((hashmap1 hashmap2)
     (assume (hashmap? hashmap1))
     (assume (hashmap? hashmap2))
     (%hashmap-xor hashmap1 hashmap2))
    ((hashmap1 hashmap2 . hashmaps)
     (assume (hashmap? hashmap1))
     (assume (hashmap? hashmap2))
     (apply hashmap-xor (%hashmap-xor hashmap1 hashmap2) hashmaps))))
(define hashmap-xor! hashmap-xor)

;; Comparators

(define (hashmap-equality comparator)
  (assume (comparator? comparator))
  (lambda (hashmap1 hashmap2)
    (hashmap=? comparator hashmap1 hashmap2)))

(define (hashmap-hash-function comparator)
  (assume (comparator? comparator))
  (lambda (hashmap)
    0 ;; TODO
    #;
    (default-hash (hashmap->alist hashmap))))

(define (make-hashmap-comparator comparator)
  (make-comparator hashmap?
           (hashmap-equality comparator)
           #f
           (hashmap-hash-function comparator)))

(define hashmap-comparator (make-hashmap-comparator (make-default-comparator)))

(comparator-register-default! hashmap-comparator)
;;;; HAMT Map Tests

;;; Copyright MMXV-MMXVII Arthur A. Gleckler.  All rights reserved.

;; Permission is hereby granted, free of charge, to any person
;; obtaining a copy of this software and associated documentation
;; files (the "Software"), to deal in the Software without
;; restriction, including without limitation the rights to use, copy,
;; modify, merge, publish, distribute, sublicense, and/or sell copies
;; of the Software, and to permit persons to whom the Software is
;; furnished to do so, subject to the following conditions:

;; The above copyright notice and this permission notice shall be
;; included in all copies or substantial portions of the Software.

;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
;; EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
;; MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
;; NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
;; HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
;; WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
;; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
;; DEALINGS IN THE SOFTWARE.

(define (make-string-set)
  (set (make-comparator string? string=? string<? string-hash)))


(define (run-hamt-map-tests)

  (define (assert-phm= phm alist)
    (test-equal = (length alist) (phm/count phm))
    (do-list (a alist)
      (test-assert (phm/contains? phm (car a)))
      (test-assert (= (cdr a) (phm/get phm (car a) #f)))))

  (define (phm-random-test put remove transform)
    (define (sort-alist alist)
      (list-sort (lambda (a1 a2) (string<? (car a1) (car a2))) alist))
    (let ((contents (make-string-hash-table))
      (deleted-keys (make-string-set))
      (deletion-odds 5)
      (max-key-length 5)
      (operations 100))
      (define (random-key)
    (let ((size (+ (random-integer max-key-length) 1)))
      (with-output-to-string
        (lambda ()
          (do ((i 0 (+ i 1)))
          ((= i size))
        (write-char (integer->char (+ 97 (random-integer 26)))))))))
      (define (fill-phm i phm)
    (let ((size (hash-table-size contents)))
      (cond ((zero? i) phm)
        ((and (not (zero? size))
              (zero? (random-integer deletion-odds)))
         (let ((key (list-ref (hash-table-keys contents)
                      (random-integer size))))
           (set-adjoin! deleted-keys key)
           (hash-table-delete! contents key)
           (fill-phm (- i 1)
                 (remove phm key))))
        (else (let* ((key (random-key))
                 (datum (random-integer 1000)))
            (set-delete! deleted-keys key)
            (hash-table-set! contents key datum)
            (fill-phm (- i 1)
                  (put phm key datum)))))))
      (let ((phm (fill-phm operations
               (transform (make-phm string-hash string=?)))))
    (test-assert (= (phm/count phm) (hash-table-size contents)))
    (hash-table-for-each (lambda (key datum)
                   (test-assert (= datum (phm/get phm key -1)))
                   (test-assert (phm/contains? phm key)))
                 contents)
    (set-for-each (lambda (key)
            (test-assert (= -1 (phm/get phm key -1)))
            (test-assert (not (phm/contains? phm key))))
              deleted-keys)
    (let ((ht-alist (hash-table->alist contents))
          (phm-alist (phm->alist phm)))
      (test-assert (equal? (sort-alist ht-alist)
                   (sort-alist phm-alist)))))))

  (define (phm-remove-non-existent-test remove transform)
    (define (terrible-hash string) 0)
    (let ((phm (remove (transform (make-phm string-hash string=?))
               "not-present")))
      (test-assert (zero? (phm/count phm)))
      (test-assert (not (phm/contains? phm "not-present")))
      (test-assert (not (phm/get phm "not-present" #f))))
    (let ((phm (remove (transform (phm/put (make-phm terrible-hash string=?)
                       "foo"
                       1))
               "not-present")))
      (test-assert (= 1 (phm/count phm)))
      (test-assert (phm/contains? phm "foo"))
      (test-assert (not (phm/contains? phm "not-present")))))

  (define (phm-collision-test put remove transform)
    (define (sort-alist alist)
      (list-sort (lambda (a1 a2) (string<? (car a1) (car a2))) alist))
    (define (terrible-hash string)
      (cond ((string=? string "foo") 0)
        ((string=? string "bar") 1)
        (else 2)))
    (let* ((alist '(("foo" . 1) ("bar" . 2) ("baz" . 3) ("bat" . 4)
            ("quux" . 5)))
       (phm-1 (fold (lambda (a phm) (put phm (car a) (cdr a)))
            (transform (make-phm terrible-hash string=?))
            alist))
       (phm (put phm-1 "baz" 3)))
      (assert-phm= phm alist)
      (let ((phm-alist (phm->alist phm)))
    (test-assert (equal? (sort-alist alist)
                 (sort-alist phm-alist))))
      (let ((alist-minus-baz (alist-delete "baz" alist string=?))
        (phm-minus-baz (remove (transform phm) "baz")))
    (assert-phm= phm-minus-baz alist-minus-baz)
    (let ((phm-minus-nonexistent (remove phm-minus-baz "not-present")))
      (test-equal = (phm/count phm-minus-nonexistent) (- (length alist) 1))
      (let ((alist-minus-bat (alist-delete "bat" alist-minus-baz string=?))
        (phm-minus-bat (remove phm-minus-nonexistent "bat")))
        (assert-phm= phm-minus-bat alist-minus-bat))))))

  (define (persistent-hash-map replace transform)
    (define (sort-alist alist)
      (list-sort (lambda (a1 a2) (string<? (car a1) (car a2))) alist))
    (let* ((alist-1 '(("a" . 1) ("b" . 2) ("c" . 3)))
       (alist-2 '(("a" . 1) ("b" . 4) ("c" . 3)))
       (alist-3 '(("a" . 1) ("b" . 4)))
       (phm (replace (transform (make-phm string-hash string=? alist-1))
             "b"
             (lambda (x) 4))))
      (test-assert (equal? alist-2 (sort-alist (phm->alist phm))))
      (test-assert (equal? alist-3
               (sort-alist
                (phm->alist
                 (replace phm "c" (lambda (x) hamt-null))))))))

  (define (hamt-max-depth hamt)
    "Return maximum depth of `hamt'.  For testing."
    (let descend ((n (hamt/root hamt)))
      (cond ((collision? n) 1)
        ((narrow? n)
         (let* ((array (narrow/array n))
            (stride (leaf-stride (hamt/payload? hamt)))
            (start (* stride (bit-count (narrow/leaves n))))
            (end (vector-length array)))
           (do ((i start (+ i 1))
            (high 0 (max high (descend (vector-ref array i)))))
           ((= i end) (+ high 1)))))
        ((wide? n)
         (let ((array (wide/array n))
           (c (wide/children n)))
           (let next-child ((high 0)
                (i 0))
         (cond ((next-set-bit c i hamt-bucket-size)
            => (lambda (j)
                 (next-child (max high
                          (descend (vector-ref array j)))
                     (+ j 1))))
               (else (+ high 1))))))
        (else (error "Invalid type of node." n)))))

  (test-begin "hamt-map")

  (test-group "(persistent-hash-map make-phm alist)"
    (let* ((alist '(("a" . 1) ("b" . 2)))
       (phm (make-phm string-hash string=? alist)))
      (test-assert (not (hamt/mutable? phm)))
      (assert-phm= phm alist)))

  (test-group "(persistent-hash-map make-phm phm/count)"
    (let ((phm (make-phm string-hash string=? '(("a". 1) ("b" . 2)))))
      (test-assert (= 2 (phm/count phm)))))

  (test-group "(persistent-hash-map phm/empty?)"
    (test-assert (phm/empty? (make-phm string-hash string=?)))
    (test-assert (not (phm/empty? (make-phm string-hash string=? '(("a")))))))

  (test-group "(persistent-hash-map random pure)"
    (phm-random-test phm/put phm/remove (lambda (m) m)))

  (test-group "(persistent-hash-map random mutate)"
    (phm-random-test phm/put! phm/remove! phm/mutable))

  (test-group "(persistent-hash-map random mixed)"
    (define (flip mutate? phm)
      ((if mutate? phm/mutable phm/immutable) phm))
    (phm-random-test (let ((mutate? #t))
               (lambda (phm key datum)
             (set! mutate? (not mutate?))
             ((if mutate? phm/put! phm/put)
              (flip mutate? phm)
              key
              datum)))
             (let ((count 0))
               (lambda (phm key)
             (set! count (remainder (+ count 1) 3))
             (let ((mutate? (zero? count)))
               ((if mutate? phm/remove! phm/remove)
                (flip mutate? phm)
                key))))
             (lambda (m) m)))

  (test-group "(persistent-hash-map remove-non-existent pure)"
    (phm-remove-non-existent-test phm/remove (lambda (m) m)))

  (test-group "(persistent-hash-map remove-non-existent mutate)"
    (phm-remove-non-existent-test phm/remove! phm/mutable))

  (test-group "(persistent-hash-map phm/add-alist)"
    (let* ((alist '(("foo" . 1) ("bar" . 2) ("baz" . 3)))
       (phm (phm/add-alist (make-phm string-hash string=?) alist)))
      (assert-phm= phm alist)))

  (test-group "(persistent-hash-map phm/add-alist!)"
    (let* ((alist '(("foo" . 1) ("bar" . 2) ("baz" . 3)))
       (phm (phm/mutable (make-phm string-hash string=?))))
      (phm/add-alist! phm alist)
      (assert-phm= phm alist)))

  (test-group "(persistent-hash-map collisions pure)"
    (phm-collision-test phm/put phm/remove (lambda (m) m)))

  (test-group "(persistent-hash-map collisions mutate)"
    (phm-collision-test phm/put! phm/remove! phm/mutable))

  (test-group "(persistent-hash-map big-hash)"
    "Test that hashes that differ only above `hamt-hash-size' still work."
    (define big-hash
      (let* ((big-1 (expt 2 hamt-hash-size))
         (big-2 (* 2 big-1)))
    (lambda (string)
      (cond ((string=? string "foo") big-1)
        (else big-2)))))
    (let* ((alist '(("foo" . 1) ("bar" . 2) ("baz" . 3) ("bat" . 4)
            ("quux" . 5)))
       (phm (phm/add-alist (make-phm big-hash string=?) alist)))
      (assert-phm= phm alist)))

  (test-group "(persistent-hash-map same-first-fragment)"
    (define (same-first-fragment string)
      (* hamt-bucket-size (string-hash string)))
    (let* ((alist '(("foo" . 1) ("bar" . 2) ("baz" . 3) ("bat" . 4)
            ("quux" . 5)))
       (phm (phm/add-alist (make-phm same-first-fragment string=?) alist)))
      (assert-phm= phm alist)
      (let ((phm-minus-baz (phm/remove phm "baz")))
    (assert-phm= phm-minus-baz (alist-delete "baz" alist string=?)))
      (let ((phm-minus-nonexistent (phm/remove phm "not-present")))
    (test-assert (= (phm/count phm-minus-nonexistent) (length alist))))))

  (test-group "(persistent-hash-map pure-mutate-interference)"
    "Test that mutating and pure operations interact with each other
correctly."
    (define (alist-replace alist key datum)
      (cons (cons key datum) (alist-delete key alist string=?)))
    (let* ((m0 (make-phm string-hash string=?))
       (a1 '(("foo" . 1) ("bar" . 2) ("baz" . 3)))
       (m1 (phm/add-alist m0 a1))
       (a4 (alist-replace a1 "foo" 4))
       (m2 (phm/put m1 "foo" 4))
       (a5 (alist-replace a1 "foo" 5))
       (m3 (phm/mutable m2))
       (m4 (phm/put! m3 "foo" 5))
       (a6 (alist-replace a1 "foo" 6))
       (m5 (phm/immutable m4))
       (m6 (phm/mutable m5))
       (m7 (phm/put! m6 "foo" 6))
       (a7 (alist-replace a1 "foo" 7))
       (a8 (alist-replace a1 "foo" 8))
       (m8 (phm/put! m6 "foo" 7)))
      (phm/put! m4 "foo" 8)
      (assert-phm= m0 '())
      (assert-phm= m1 a1)
      (assert-phm= m2 a4)
      (assert-phm= m3 a8)
      (assert-phm= m4 a8)
      (assert-phm= m5 a5)
      (assert-phm= m6 a7)
      (assert-phm= m7 a7)
      (assert-phm= m8 a7)
      (let ((a (alist-delete "foo" a1 string=?))
        (m9 (phm/remove! m4 "foo")))
    (assert-phm= m4 a)
    (assert-phm= m9 a))))

  (test-group "(persistent-hash-map phm/data)"
    (let* ((alist '(("a" . 1) ("b" . 2) ("c" . 3)))
       (data (phm/data (make-phm string-hash string=? alist))))
      (test-assert (equal? (map cdr alist)
               (list-sort < data)))))

  (test-group "(persistent-hash-map phm/keys)"
    (let* ((alist '(("a" . 1) ("b" . 2) ("c" . 3)))
       (keys (phm/keys (make-phm string-hash string=? alist))))
      (test-assert (equal? (map car alist)
               (list-sort string<? keys)))))

  (test-group "(persistent-hash-map phm/for-each)"
    (define (sort-alist alist)
      (list-sort (lambda (a1 a2) (string<? (car a1) (car a2))) alist))
    (let* ((alist '(("a" . 1) ("b" . 2) ("c" . 3)))
       (phm (make-phm string-hash string=? alist))
       (accumulator '()))
      (phm/for-each (lambda (k d) (set! accumulator
                   (cons (cons k d) accumulator)))
            phm)
      (test-assert (equal? alist (sort-alist accumulator)))))

  (test-group "(persistent-hash-map phm/replace)"
    (persistent-hash-map phm/replace (lambda (m) m)))

  (test-group "(persistent-hash-map phm/replace!)"
    (persistent-hash-map phm/replace! phm/mutable))

  (test-group "(persistent-hash-map immutable-replace)"
    (define (sort-alist alist)
      (list-sort (lambda (a1 a2) (string<? (car a1) (car a2))) alist))
    (let* ((alist-1 '(("a" . 1) ("b" . 2) ("c" . 3)))
       (alist-2 '(("a" . 1) ("b" . 5) ("c" . 3)))
       (phm-1 (phm/mutable (make-phm string-hash string=? alist-1))))
      (phm/put! phm-1 "b" 4)
      (let ((phm-2 (phm/immutable phm-1
                  (lambda (k d) (if (string=? k "b") (+ d 1) d)))))
    (test-assert (equal? alist-2 (sort-alist (phm->alist phm-2)))))))

  (test-group "(persistent-hash-map phm/mutable?)"
    (let ((phm (make-phm string-hash string=?)))
      (test-assert (not (phm/mutable? phm)))
      (test-assert (phm/mutable? (phm/mutable phm)))
      (test-assert (not (phm/mutable? (phm/immutable (phm/mutable phm)))))))

  (test-group "(persistent-hash-map modify-collision add-different-hash)"
    (define (terrible-hash string)
      (cond ((string=? string "foo") 0)
        ((string=? string "bar") 0)
        (else hamt-bucket-size)))    ; same as 0 in bottom 5 bits
    (let* ((alist '(("foo" . 1) ("bar" . 2)))
       (phm-1 (make-phm terrible-hash string=? alist))
       (phm-2 (phm/put phm-1 "baz" 3)))
      (assert-phm= phm-2 '(("foo" . 1) ("bar" . 2) ("baz" . 3)))))

  (test-group "(persistent-hash-map lower-collision)"
    (define same-bottom-three-fragments (expt hamt-bucket-size 3))
    (define (terrible-hash string)
      (if (or (string=? string "foo")
          (string=? string "bar"))
      same-bottom-three-fragments
      (* 2 same-bottom-three-fragments)))
    (let* ((alist '(("foo" . 1) ("bar" . 2)))
       (phm-1 (make-phm terrible-hash string=? alist))
       (phm-2 (phm/put phm-1 "baz" 3))
       (phm-3 (phm/remove phm-2 "foo"))
       (phm-4 (phm/remove phm-3 "bar"))
       (phm-5 (phm/remove phm-4 "baz")))
      (assert-phm= phm-2 '(("foo" . 1) ("bar" . 2) ("baz" . 3)))
      (assert-phm= phm-3 '(("bar" . 2) ("baz" . 3)))
      (assert-phm= phm-4 '(("baz" . 3)))
      (assert-phm= phm-5 '())
      (test-assert (= 5 (hamt-max-depth phm-2)))
      (test-assert (= 4 (hamt-max-depth phm-3)))
      (test-assert (= 1 (hamt-max-depth phm-4)))
      (test-assert (= 1 (hamt-max-depth phm-5)))))
  (test-end))(define-library (srfi 146 vector-edit)
  (import (scheme base))
  (export vector-edit vector-replace-one vector-without)
  (include "vector-edit.scm"))
;; Copyright (C) Marc Nieper-Wikirchen (2016, 2017).  All Rights
;; Reserved.

;; Permission is hereby granted, free of charge, to any person
;; obtaining a copy of this software and associated documentation
;; files (the "Software"), to deal in the Software without
;; restriction, including without limitation the rights to use, copy,
;; modify, merge, publish, distribute, sublicense, and/or sell copies
;; of the Software, and to permit persons to whom the Software is
;; furnished to do so, subject to the following conditions:

;; The above copyright notice and this permission notice shall be
;; included in all copies or substantial portions of the Software.

;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
;; EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
;; MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
;; NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
;; BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
;; ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
;; CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
;; SOFTWARE.

(define-library (srfi 146 test)
  (export run-tests)
  (import (scheme base)
          (srfi 1)
          (srfi 8)
          (srfi 128)
          (srfi 146)
          (chibi test))
  (begin
    (define (run-tests)
      (test-begin "srfi-146: mappings")

      (test-group "Predicates"
        (define mapping0 (mapping comparator))
        (define mapping1 (mapping comparator 'a 1 'b 2 'c 3))
        (define mapping2 (mapping comparator 'c 1 'd 2 'e 3))
        (define mapping3 (mapping comparator 'd 1 'e 2 'f 3))
        
        (test-assert "mapping?: a mapping"
          (mapping? (mapping comparator)))

        (test-assert "mapping?: not a mapping"
          (not (mapping? (list 1 2 3))))
        
        (test-assert "mapping-empty?: empty mapping"
          (mapping-empty? mapping0))
        
        (test-assert "mapping-empty?: non-empty mapping"
          (not (mapping-empty? mapping1)))

        (test-assert "mapping-contains?: containing"
          (mapping-contains? mapping1 'b))   

        (test-assert "mapping-contains?: not containing"
          (not (mapping-contains? mapping1 '2)))

        (test-assert "mapping-disjoint?: disjoint"
          (mapping-disjoint? mapping1 mapping3))

        (test-assert "mapping-disjoint?: not disjoint"
          (not (mapping-disjoint? mapping1 mapping2))))

      (test-group "Accessors"
        (define mapping1 (mapping comparator 'a 1 'b 2 'c 3))

        (test "mapping-ref: key found"
                    2
                    (mapping-ref mapping1 'b))

        (test "mapping-ref: key not found/with failure"
                    42
                    (mapping-ref mapping1 'd (lambda () 42)))

        (test-error "mapping-ref: key not found/without failure"
                    (mapping-ref mapping1 'd))

        (test "mapping-ref: with success procedure"
                    (* 2 2)
                    (mapping-ref mapping1 'b (lambda () #f) (lambda (x) (* x x))))

        (test "mapping-ref/default: key found"
                    3
                    (mapping-ref/default mapping1 'c 42))

        (test "mapping-ref/default: key not found"
                    42
                    (mapping-ref/default mapping1 'd 42))

        (test "mapping-key-comparator"
                    comparator
                    (mapping-key-comparator mapping1)))

      (test-group "Updaters"
        (define mapping1 (mapping comparator 'a 1 'b 2 'c 3))
        (define mapping2 (mapping-set mapping1 'c 4 'd 4 'd 5))
        (define mapping3 (mapping-update mapping1 'b (lambda (x) (* x x))))
        (define mapping4 (mapping-update/default mapping1 'd (lambda (x) (* x x)) 4))
        (define mapping5 (mapping-adjoin mapping1 'c 4 'd 4 'd 5))
        (define mapping0 (mapping comparator))

        (test "mapping-adjoin: key already in mapping"
                    3
                    (mapping-ref mapping5 'c))

        (test "mapping-adjoin: key set earlier"
                    4
                    (mapping-ref mapping5 'd))
        
        (test "mapping-set: key already in mapping"
                    4
                    (mapping-ref mapping2 'c))

        (test "mapping-set: key set earlier"
                    5
                    (mapping-ref mapping2 'd))

        (test "mapping-replace: key not in mapping"
                    #f
                    (mapping-ref/default (mapping-replace mapping1 'd 4) 'd #f))

        (test "mapping-replace: key in mapping"
                    6
                    (mapping-ref (mapping-replace mapping1 'c 6) 'c))

        (test "mapping-delete"
                    42
                    (mapping-ref/default (mapping-delete mapping1 'b) 'b 42))

        (test "mapping-delete-all"
                    42
                    (mapping-ref/default (mapping-delete-all mapping1 '(a b)) 'b 42))
        
        (test "mapping-intern: key in mapping"
                    (list mapping1 2)
                    (receive result
                        (mapping-intern mapping1 'b (lambda () (error "should not have been invoked")))
                      result))

        (test "mapping-intern: key not in mapping"
                    (list 42 42)
                    (receive (mapping value)
                        (mapping-intern mapping1 'd (lambda () 42))
                      (list value (mapping-ref mapping 'd))))
        
        (test "mapping-update"
                    4
                    (mapping-ref mapping3 'b))

        (test "mapping-update/default"
                    16
                    (mapping-ref mapping4 'd))

        (test "mapping-pop: empty mapping"
                    'empty
                    (mapping-pop mapping0 (lambda () 'empty)))

        (test "mapping-pop: non-empty mapping"
                    (list 2 'a 1)
                    (receive (mapping key value)
                        (mapping-pop mapping1)
                      (list (mapping-size mapping) key value))))

      (test-group "The whole mapping"
        (define mapping0 (mapping comparator))
        (define mapping1 (mapping comparator 'a 1 'b 2 'c 3))

        (test "mapping-size: empty mapping"
                    0
                    (mapping-size mapping0))

        (test "mapping-size: non-empty mapping"
                    3
                    (mapping-size mapping1))

        (test "mapping-find: found in mapping"
                    (list 'b 2)
                    (receive result
                        (mapping-find (lambda (key value)
                                        (and (eq? key 'b)
                                             (= value 2)))
                                      mapping1
                                      (lambda () (error "should not have been called")))
                      result))

        (test "mapping-find: not found in mapping"
                    (list 42)
                    (receive result
                        (mapping-find (lambda (key value)
                                        (eq? key 'd))
                                      mapping1
                                      (lambda ()
                                        42))
                      result))

        (test "mapping-count"
                    2
                    (mapping-count (lambda (key value)
                                     (>= value 2))
                                   mapping1))
        
        (test-assert "mapping-any?: found"
          (mapping-any? (lambda (key value)
                          (= value 3))
                        mapping1))

        (test-assert "mapping-any?: not found"
          (not (mapping-any? (lambda (key value)
                               (= value 4))
                             mapping1)))

        (test-assert "mapping-every?: true"
          (mapping-every? (lambda (key value)
                            (<= value 3))
                          mapping1))

        (test-assert "mapping-every?: false"
          (not (mapping-every? (lambda (key value)
                                 (<= value 2))
                               mapping1)))

        (test "mapping-keys"
                    3
                    (length (mapping-keys mapping1)))

        (test "mapping-values"
                    6
                    (fold + 0 (mapping-values mapping1)))

        (test "mapping-entries"
                    (list 3 6)
                    (receive (keys values)
                        (mapping-entries mapping1)
                      (list (length keys) (fold + 0 values)))))

      (test-group "Mapping and folding"
        (define mapping1 (mapping comparator 'a 1 'b 2 'c 3))
        (define mapping2 (mapping-map (lambda (key value)
                                        (values (symbol->string key)
                                                (* 10 value)))
                                      comparator
                                      mapping1))

        (test "mapping-map"
                    20
                    (mapping-ref mapping2 "b"))

        (test "mapping-for-each"
                    6
                    (let ((counter 0))
                      (mapping-for-each (lambda (key value)
                                          (set! counter (+ counter value)))
                                        mapping1)
                      counter))

        (test "mapping-fold"
                    6
                    (mapping-fold (lambda (key value acc)
                                    (+ value acc))
                                  0
                                  mapping1))

        (test "mapping-map->list"
                    (+ (* 1 1) (* 2 2) (* 3 3))
                    (fold + 0 (mapping-map->list (lambda (key value)
                                                   (* value value))
                                                 mapping1)))

        (test "mapping-filter"
                    2
                    (mapping-size (mapping-filter (lambda (key value)
                                                    (<= value 2))
                                                  mapping1)))

        (test "mapping-remove"
                    1
                    (mapping-size (mapping-remove (lambda (key value)
                                                    (<= value 2))
                                                  mapping1)))

        (test "mapping-partition"
                    (list 1 2)
                    (receive result
                        (mapping-partition (lambda (key value)
                                             (eq? 'b key))
                                           mapping1)
                      (map mapping-size result)))

        (test-group "Copying and conversion"
          (define mapping1 (mapping comparator 'a 1 'b 2 'c 3))
          (define mapping2 (alist->mapping comparator '((a . 1) (b . 2) (c . 3))))
          (define mapping3 (alist->mapping! (mapping-copy mapping1) '((d . 4) '(c . 5))))
          
          (test "mapping-copy: same size"
                      3
                      (mapping-size (mapping-copy mapping1)))

          (test "mapping-copy: same comparator"
                      comparator
                      (mapping-key-comparator (mapping-copy mapping1)))

          (test "mapping->alist"
                      (cons 'b 2)
                      (assq 'b (mapping->alist mapping1)))
          
          (test "alist->mapping"
                      2
                      (mapping-ref mapping2 'b)
                      )

          (test "alist->mapping!: new key"
                      4
                      (mapping-ref mapping3 'd))

          (test "alist->mapping!: existing key"
                      3
                      (mapping-ref mapping3 'c)))

        (test-group "Submappings"
          (define mapping1 (mapping comparator 'a 1 'b 2 'c 3))
          (define mapping2 (mapping comparator 'a 1 'b 2 'c 3))
          (define mapping3 (mapping comparator 'a 1 'c 3))
          (define mapping4 (mapping comparator 'a 1 'c 3 'd 4))
          (define mapping5 (mapping comparator 'a 1 'b 2 'c 6))
          (define mapping6 (mapping (make-comparator (comparator-type-test-predicate comparator)
                                                     (comparator-equality-predicate comparator)
                                                     (comparator-ordering-predicate comparator)
                                                     (comparator-hash-function comparator))
                                    'a 1 'b 2 'c 3))
          

          (test-assert "mapping=?: equal mappings"
            (mapping=? comparator mapping1 mapping2))
          
          (test-assert "mapping=?: unequal mappings"
            (not (mapping=? comparator mapping1 mapping4)))

          (test-assert "mapping=?: different comparators"
            (not (mapping=? comparator mapping1 mapping6)))
          
          (test-assert "mapping<?: proper subset"
            (mapping<? comparator mapping3 mapping1))

          (test-assert "mapping<?: improper subset"
            (not (mapping<? comparator mapping3 mapping1 mapping2)))
          
          (test-assert "mapping>?: proper superset"
            (mapping>? comparator mapping2 mapping3))

          (test-assert "mapping>?: improper superset"
            (not (mapping>? comparator mapping1 mapping2 mapping3)))

          (test-assert "mapping<=?: subset"
            (mapping<=? comparator mapping3 mapping2 mapping1))

          (test-assert "mapping<=?: non-matching values"
            (not (mapping<=? comparator mapping3 mapping5)))

          (test-assert "mapping<=?: not a subset"
            (not (mapping<=? comparator mapping2 mapping4)))

          (test-assert "mapping>=?: superset"
            (mapping>=? comparator mapping4 mapping3))

          (test-assert "mapping>=?: not a superset"
            (not (mapping>=? comparator mapping5 mapping3))))

        (test-group "Set theory operations"
          (define mapping1 (mapping comparator 'a 1 'b 2 'c 3))
          (define mapping2 (mapping comparator 'a 1 'b 2 'd 4))
          (define mapping3 (mapping comparator 'a 1 'b 2))
          (define mapping4 (mapping comparator 'a 1 'b 2 'c 4))
          (define mapping5 (mapping comparator 'a 1 'c 3))
          (define mapping6 (mapping comparator 'd 4 'e 5 'f 6))
          
          (test "mapping-union: new association"
                      4
                      (mapping-ref (mapping-union mapping1 mapping2) 'd))

          (test "mapping-union: existing association"
                      3
                      (mapping-ref (mapping-union mapping1 mapping4) 'c))
          
          (test "mapping-union: three mappings"
                      6
                      (mapping-size (mapping-union mapping1 mapping2 mapping6)))
          
          (test "mapping-intersection: existing association"
                      3
                      (mapping-ref (mapping-intersection mapping1 mapping4) 'c))

          (test "mapping-intersection: removed association"
                      42
                      (mapping-ref/default (mapping-intersection mapping1 mapping5) 'b 42))

          (test "mapping-difference"
                      2
                      (mapping-size (mapping-difference mapping2 mapping6)))

          (test "mapping-xor"
                      4
                      (mapping-size (mapping-xor mapping2 mapping6))))

        (test-group "Additional procedures for mappings with ordered keys"
          (define mapping1 (mapping comparator 'a 1 'b 2 'c 3))
          (define mapping2 (mapping comparator 'a 1 'b 2 'c 3 'd 4))
          (define mapping3 (mapping comparator 'a 1 'b 2 'c 3 'd 4 'e 5))
          (define mapping4 (mapping comparator 'a 1 'b 2 'c 3 'd 4 'e 5 'f 6))
          (define mapping5 (mapping comparator 'f 6 'g 7 'h 8))

          (test "mapping-min-key"
                      '(a a a a)
                      (map mapping-min-key (list mapping1 mapping2 mapping3 mapping4)))

          (test "mapping-max-key"
                      '(c d e f)
                      (map mapping-max-key (list mapping1 mapping2 mapping3 mapping4)))
          
          (test "mapping-min-value"
                      '(1 1 1 1)
                      (map mapping-min-value (list mapping1 mapping2 mapping3 mapping4)))

          (test "mapping-max-value"
                      '(3 4 5 6)
                      (map mapping-max-value (list mapping1 mapping2 mapping3 mapping4)))

          (test "mapping-key-predecessor"
                      '(c d d d)
                      (map (lambda (mapping)
                             (mapping-key-predecessor mapping 'e (lambda () #f)))
                           (list mapping1 mapping2 mapping3 mapping4)))

          (test "mapping-key-successor"
                      '(#f #f e e)
                      (map (lambda (mapping)
                             (mapping-key-successor mapping 'd (lambda () #f)))
                           (list mapping1 mapping2 mapping3 mapping4)))

          (test "mapping-range=: contained"
                      '(4)
                      (mapping-values (mapping-range= mapping4 'd)))

          (test "mapping-range=: not contained"
                      '()
                      (mapping-values (mapping-range= mapping4 'z)))

          (test "mapping-range<"
                      '(1 2 3)
                      (mapping-values (mapping-range< mapping4 'd)))

          (test "mapping-range<="
                      '(1 2 3 4)
                      (mapping-values (mapping-range<= mapping4 'd)))

          (test "mapping-range>"
                      '(5 6)
                      (mapping-values (mapping-range> mapping4 'd)))

          (test "mapping-range>="
                      '(4 5 6)
                      (mapping-values (mapping-range>= mapping4 'd)))

          (test "mapping-split"
                      '((1 2 3) (1 2 3 4) (4) (4 5 6) (5 6))
                      (receive mappings
                          (mapping-split mapping4 'd)
                        (map mapping-values mappings)))
          
          (test "mapping-catenate"
                      '((a . 1) (b . 2) (c . 3) (d . 4) (e . 5) (f . 6) (g . 7) (h . 8))
                      (mapping->alist (mapping-catenate comparator mapping2 'e 5 mapping5)))
          
          (test "mapping-map/monotone"
                      '((1 . 1) (2 . 4) (3 . 9))
                      (mapping->alist
                       (mapping-map/monotone (lambda (key value)
                                               (values value (* value value)))
                                             comparator
                                             mapping1)))

          (test "mapping-fold/reverse"
                      '(1 2 3)
                      (mapping-fold/reverse (lambda (key value acc)
                                              (cons value acc))
                                            '() mapping1)))
        
        (test-group "Comparators"
          (define mapping1 (mapping comparator 'a 1 'b 2 'c 3))
          (define mapping2 (mapping comparator 'a 1 'b 2 'c 3))
          (define mapping3 (mapping comparator 'a 1 'b 2))
          (define mapping4 (mapping comparator 'a 1 'b 2 'c 4))
          (define mapping5 (mapping comparator 'a 1 'c 3))
          (define mapping0 (mapping comparator mapping1 "a" mapping2 "b" mapping3 "c" mapping4 "d" mapping5 "e"))

          (test-assert "mapping-comparator"
            (comparator? mapping-comparator))
          
          (test "mapping-keyed mapping"
                      (list "a" "a" "c" "d" "e")
                      (list (mapping-ref mapping0 mapping1)
                            (mapping-ref mapping0 mapping2)
                            (mapping-ref mapping0 mapping3)
                            (mapping-ref mapping0 mapping4)
                            (mapping-ref mapping0 mapping5)))
          
          (test-group "Ordering comparators"
            (test-assert "=?: equal mappings"
              (=? comparator mapping1 mapping2))

            (test-assert "=?: unequal mappings"
              (not (=? comparator mapping1 mapping4)))

            (test-assert "<?: case 1"
              (<? comparator mapping3 mapping4))

            (test-assert "<?: case 2"
              (<? comparator mapping1 mapping4))

            (test-assert "<?: case 3"
              (<? comparator mapping1 mapping5)))))
      
      (test-end "srfi-146: mappings"))

    (define comparator (make-default-comparator))))
;;;; Tests of utilities used by HAMT

;;; Copyright MMIV-MMXVII Arthur A. Gleckler.  All rights reserved.

;; Permission is hereby granted, free of charge, to any person
;; obtaining a copy of this software and associated documentation
;; files (the "Software"), to deal in the Software without
;; restriction, including without limitation the rights to use, copy,
;; modify, merge, publish, distribute, sublicense, and/or sell copies
;; of the Software, and to permit persons to whom the Software is
;; furnished to do so, subject to the following conditions:

;; The above copyright notice and this permission notice shall be
;; included in all copies or substantial portions of the Software.

;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
;; EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
;; MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
;; NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
;; HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
;; WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
;; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
;; DEALINGS IN THE SOFTWARE.

(define (run-hamt-misc-tests)
  (test-begin "hamt-misc")

  (test-group "(do-list)"
    (let ((index-accumulator '())
      (value-accumulator '())
      (all-values '(1 2 3 4 5)))
      (do-list (value all-values)
    (set! value-accumulator (cons value value-accumulator)))
      (test all-values (reverse value-accumulator))
      (do-list (value index all-values)
    (set! index-accumulator (cons index index-accumulator)))
      (test '(4 3 2 1 0) index-accumulator)))

  (test-end));;;; Utilities used by HAMT

;;; Copyright MMIV-MMXVII Arthur A. Gleckler.  All rights reserved.

;; Permission is hereby granted, free of charge, to any person
;; obtaining a copy of this software and associated documentation
;; files (the "Software"), to deal in the Software without
;; restriction, including without limitation the rights to use, copy,
;; modify, merge, publish, distribute, sublicense, and/or sell copies
;; of the Software, and to permit persons to whom the Software is
;; furnished to do so, subject to the following conditions:

;; The above copyright notice and this permission notice shall be
;; included in all copies or substantial portions of the Software.

;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
;; EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
;; MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
;; NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
;; HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
;; WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
;; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
;; DEALINGS IN THE SOFTWARE.

(define-syntax assert
  (syntax-rules ()
    ((_ (operator argument ...))
     (unless (operator argument ...)
       (error "Assertion failed:"
          '(operator argument ...)
          (list 'operator argument ...))))
    ((_ expression)
     (unless expression
       (error "Assertion failed:" 'expression)))))

(define-syntax do-list
  (syntax-rules ()
    ((_ (variable list) body ...)
     (do ((remaining list (cdr remaining)))
     ((null? remaining))
       (let ((variable (car remaining)))
     body ...)))
    ((_ (element-variable index-variable list) body ...)
     (do ((remaining list (cdr remaining))
      (index-variable 0 (+ index-variable 1)))
     ((null? remaining))
       (let ((element-variable (car remaining)))
     body ...)))))

(define string-comparator
  (make-comparator string? string=? #f string-hash))

(define (make-string-hash-table)
  (make-hash-table string-comparator))

(define (with-output-to-string thunk)
  (parameterize ((current-output-port (open-output-string)))
    (thunk)
    (get-output-string (current-output-port))))
(define-library (srfi 146 hash)
  (export
   hashmap hashmap-unfold
   hashmap? hashmap-contains? hashmap-empty? hashmap-disjoint?
   hashmap-ref hashmap-ref/default hashmap-key-comparator
   hashmap-adjoin hashmap-adjoin!
   hashmap-set hashmap-set!
   hashmap-replace hashmap-replace!
   hashmap-delete hashmap-delete! hashmap-delete-all hashmap-delete-all!
   hashmap-intern hashmap-intern!
   hashmap-update hashmap-update! hashmap-update/default hashmap-update!/default
   hashmap-pop hashmap-pop!
   hashmap-search hashmap-search!
   hashmap-size hashmap-find hashmap-count hashmap-any? hashmap-every?
   hashmap-keys hashmap-values hashmap-entries
   hashmap-map hashmap-map->list hashmap-for-each hashmap-fold
   hashmap-filter hashmap-filter!
   hashmap-remove hashmap-remove!
   hashmap-partition hashmap-partition!
   hashmap-copy hashmap->alist alist->hashmap alist->hashmap!
   hashmap=? hashmap<? hashmap>? hashmap<=? hashmap>=?
   hashmap-union hashmap-intersection hashmap-difference hashmap-xor
   hashmap-union! hashmap-intersection! hashmap-difference! hashmap-xor!
   make-hashmap-comparator
   hashmap-comparator
   comparator?)
  (import (scheme base)
          (scheme case-lambda)
          (srfi 1)
          (srfi 8)
          (srfi 121)
          (srfi 128)
          (srfi 145)
          (srfi 146 hamt-map))
  (include "hash.scm"))
;;;; HAMT Core Tests

;;; Copyright MMXV-MMXVII Arthur A. Gleckler.  All rights reserved.

;; Permission is hereby granted, free of charge, to any person
;; obtaining a copy of this software and associated documentation
;; files (the "Software"), to deal in the Software without
;; restriction, including without limitation the rights to use, copy,
;; modify, merge, publish, distribute, sublicense, and/or sell copies
;; of the Software, and to permit persons to whom the Software is
;; furnished to do so, subject to the following conditions:

;; The above copyright notice and this permission notice shall be
;; included in all copies or substantial portions of the Software.

;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
;; EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
;; MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
;; NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
;; HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
;; WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
;; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
;; DEALINGS IN THE SOFTWARE.

;;; HAMT Core Tests

(define (run-hamt-core-tests)
  (test-begin "hamt-core")

  (test-group "(hash-array-mapped-trie fragment->mask)"
    (test-equal = 0 (fragment->mask 0))
    (test-equal = 1 (fragment->mask 1))
    (test-equal = 3 (fragment->mask 2))
    (test-equal = 7 (fragment->mask 3)))

  (test-end));; constructors.scm -- random function constructors
;; Copyright (c) 2009 Alex Shinn.  All rights reserved.
;; BSD-style license: http://synthcode.com/license.txt

(define (random-source-make-integers rs)
  (if (not (random-source? rs))
      (error "not a random source" rs))
  (lambda (n) (%random-integer rs n)))

(define (random-source-make-reals rs . o)
  (if (not (random-source? rs))
      (error "not a random source" rs))
  (lambda () (%random-real rs)))


(define-library (srfi 27 test)
  (export run-tests)
  (import (scheme base)
          (scheme flonum)
          (scheme inexact)
          (scheme vector)
          (srfi 27)
          (chibi test))
  (begin
    (define (random-histogram bound n . o)
      (let* ((hist (make-vector (if (pair? o) (car o) (min 10 bound)) 0))
             (rs (make-random-source))
             (rand (random-source-make-integers rs)))
        (random-source-pseudo-randomize! rs 23 42)
        (do ((i 0 (+ i 1)))
            ((= i n) hist)
          (let* ((a (rand bound))
                 (b (quotient (* a (vector-length hist)) bound)))
            (vector-set! hist b (+ 1 (vector-ref hist b)))))))
    (define (loggamma x)
      (call-with-values (lambda () (flloggamma x))
        (lambda (res sign) res)))
    ;; continued fraction expansion, borrowed from (chibi math stats)
    (define (lower-incomplete-gamma s z)
      (let lp ((k 1) (x 1.0) (sum 1.0))
        (if (or (= k 1000) (< (/ x sum) 1e-14))
            (exp (+ (* s (log z))
                    (log sum)
                    (- z)
                    (- (loggamma (+ s 1.)))))
            (let* ((x2 (* x (/ z (+ s k))))
                   (sum2 (+ sum x2)))
              (lp (+ k 1) x2 sum2)))))
    (define (chi^2-cdf X^2 df)
      (min 1 (lower-incomplete-gamma (/ df 2) (/ X^2 2))))
    (define (histogram-uniform? hist . o)
      ;; ultra-conservative alpha to avoid test failures on false positives
      (let* ((alpha (if (pair? o) (car o) 1e-5))
             (n (vector-fold + 0 hist))
             (len (vector-length hist))
             (expected (/ n (inexact len)))
             (X^2 (vector-fold
                   (lambda (X^2 observed)
                     (+ X^2 (/ (square (- observed expected)) expected)))
                   0
                   hist))
             (p (- 1.0 (chi^2-cdf X^2 (- len 1)))))
        ;;(write `(hist: ,hist X^2: ,X^2 p: ,p)) (newline)
        (> p alpha)))
    (define (run-tests)
      (define (test-random rand n)
        (test-assert (<= 0 (rand n) (- n 1))))
      (test-begin "srfi-27: random")

      ;; sanity checks
      (test 0 (random-integer 1))
      (test-assert (<= 0 (random-integer 2) 1))
      (test-error (random-integer 0))
      (test-error (random-integer -1))

      (let ((rs (make-random-source)))
        ;; chosen by fair dice roll.  guaranteed to be random
        (random-source-pseudo-randomize! rs 4 4)
        (let ((rand (random-source-make-integers rs)))
          (do ((k 0 (+ k 5))
               (n 1 (* n 2)))
              ((> k 1024))
            (test-random rand n))
          (let* ((state (random-source-state-ref rs))
                 (x (rand 1000000)))
            ;; the next int won't be the same, but it will be after
            ;; resetting the state
            (test-not (= x (rand 1000000)))
            (random-source-state-set! rs state)
            ;; (test x (rand 1000000))  ;; actually impl defined
            )))

      ;; Distribution Checks.
      ;; Since we fall back on the libc rand, we can't test the exact
      ;; result even for a given seed, so we run some conservative
      ;; statistical tests.
      (test-assert
          (histogram-uniform? (random-histogram 2 1000)))      ; coin
      (test-assert
          (histogram-uniform? (random-histogram 6 10000)))     ; die
      (test-assert
          (histogram-uniform? (random-histogram 27 10000 27))) ; small prime
      ;; boundaries
      (test-assert
          (histogram-uniform? (random-histogram (expt 2 31) 10000)))
      (test-assert
          (histogram-uniform? (random-histogram (expt 2 32) 10000)))
      (test-assert
          (histogram-uniform? (random-histogram (- (expt 2 62) 1) 10000)))
      ;; bignums
      (test-assert
          (histogram-uniform? (random-histogram (expt 2 62) 10000)))
      (test-assert
          (histogram-uniform? (random-histogram (expt 2 63) 10000)))
      (test-assert
          (histogram-uniform? (random-histogram (expt 2 63) 10000 100)))
      (test-assert
          (histogram-uniform? (random-histogram (- (expt 2 64) 1) 10000)))
      (test-assert
          (histogram-uniform? (random-histogram (expt 2 64) 10000)))
      (test-assert
          (histogram-uniform? (random-histogram (+ (expt 2 64) 1) 10000)))
      (test-assert
          (histogram-uniform? (random-histogram (expt 2 65) 10000)))
      (test-assert
          (histogram-uniform? (random-histogram (expt 2 164) 10000)))

      (test-end))))
(define-library (srfi 2 test)
  (export run-tests)
  (import (chibi) (srfi 2) (chibi test))
  (begin
    (define (run-tests)
      (test-begin "srfi-2: and-let*")
      (test 1 (and-let* () 1))
      (test 2 (and-let* () 1 2))
      (test #t (and-let* () ))
      (test #f (let ((x #f)) (and-let* (x))))
      (test 1 (let ((x 1)) (and-let* (x))))
      (test #f (and-let* ((x #f)) ))
      (test 1 (and-let* ((x 1)) ))
      ;; (test-syntax-error (and-let* ( #f (x 1))))
      (test #f (and-let* ( (#f) (x 1)) ))
      ;; (test-syntax-error (and-let* (2 (x 1))))
      (test 1 (and-let* ( (2) (x 1)) ))
      (test 2 (and-let* ( (x 1) (2)) ))
      (test #f (let ((x #f)) (and-let* (x) x)))
      (test "" (let ((x "")) (and-let* (x) x)))
      (test "" (let ((x "")) (and-let* (x)  )))
      (test 2 (let ((x 1)) (and-let* (x) (+ x 1))))
      (test #f (let ((x #f)) (and-let* (x) (+ x 1))))
      (test 2 (let ((x 1)) (and-let* (((positive? x))) (+ x 1))))
      (test #t (let ((x 1)) (and-let* (((positive? x))) )))
      (test #f (let ((x 0)) (and-let* (((positive? x))) (+ x 1))))
      (test 3  (let ((x 1)) (and-let* (((positive? x)) (x (+ x 1))) (+ x 1))))
      (test 4
          (let ((x 1))
            (and-let* (((positive? x)) (x (+ x 1)) (x (+ x 1))) (+ x 1))))
      (test 2 (let ((x 1)) (and-let* (x ((positive? x))) (+ x 1))))
      (test 2 (let ((x 1)) (and-let* ( ((begin x)) ((positive? x))) (+ x 1))))
      (test #f (let ((x 0)) (and-let* (x ((positive? x))) (+ x 1))))
      (test #f (let ((x #f)) (and-let* (x ((positive? x))) (+ x 1))))
      (test #f (let ((x #f)) (and-let* ( ((begin x)) ((positive? x))) (+ x 1))))

      (test #f
          (let ((x 1)) (and-let* (x (y (- x 1)) ((positive? y))) (/ x y))))
      (test #f
          (let ((x 0)) (and-let* (x (y (- x 1)) ((positive? y))) (/ x y))))
      (test #f
          (let ((x #f)) (and-let* (x (y (- x 1)) ((positive? y))) (/ x y))))
      (test 3/2
          (let ((x 3)) (and-let* (x (y (- x 1)) ((positive? y))) (/ x y))))
      (test 5 (and-let* () (define x 5) x))
      (test 6 (and-let* ((x 6)) (define y x) y))
      (test-end))))

(define (vector-unfold! f vec start end . o)
  (let lp ((i start) (seeds o))
    (if (< i end)
        (call-with-values (lambda () (apply f i seeds))
          (lambda (x . seeds)
            (vector-set! vec i x)
            (lp (+ i 1) seeds))))))

(define (vector-unfold-right! f vec start end . o)
  (let lp ((i (- end 1)) (seeds o))
    (if (>= i start)
        (call-with-values (lambda () (apply f i seeds))
          (lambda (x . seeds)
            (vector-set! vec i x)
            (lp (- i 1) seeds))))))

(define (vector-unfold f len . o)
  (let ((res (make-vector len)))
    (apply vector-unfold! f res 0 len o)
    res))

(define (vector-unfold-right f len . o)
  (let ((res (make-vector len)))
    (apply vector-unfold-right! f res 0 len o)
    res))

(define (vector-reverse-copy vec . o)
  (let* ((start (if (pair? o) (car o) 0))
         (end (if (and (pair? o) (pair? (cdr o))) (cadr o) (vector-length vec)))
         (len (- end start)))
    (vector-unfold-right (lambda (i) (vector-ref vec (- end i 1))) len)))

(define (vector-concatenate ls)
  (apply vector-append ls))

(define (vector-append-subvectors . o)
  (let lp ((ls o) (vecs '()))
    (if (null? ls)
        (vector-concatenate (reverse vecs))
        (lp (cdr (cddr ls))
            (cons (vector-copy (car ls) (cadr ls) (car (cddr ls))) vecs)))))

(define (vector-empty? vec)
  (zero? (vector-length vec)))

(define (vector= eq . o)
  (cond
   ((null? o) #t)
   ((null? (cdr o)) #t)
   (else
    (and (let* ((v1 (car o))
                (v2 (cadr o))
                (len (vector-length v1)))
           (and (= len (vector-length v2))
                (let lp ((i 0))
                  (or (>= i len)
                      (and (eq (vector-ref v1 i) (vector-ref v2 i))
                           (lp (+ i 1)))))))
         (apply vector= eq (cdr o))))))

(define (vector-fold kons knil vec1 . o)
  (let ((len (vector-length vec1)))
    (if (null? o)
        (let lp ((i 0) (acc knil))
          (if (>= i len) acc (lp (+ i 1) (kons acc (vector-ref vec1 i)))))
        (let lp ((i 0) (acc knil))
          (if (>= i len)
              acc
              (lp (+ i 1)
                  (apply kons acc (vector-ref vec1 i)
                         (map (lambda (v) (vector-ref v i)) o))))))))

(define (vector-fold-right kons knil vec1 . o)
  (let ((len (vector-length vec1)))
    (if (null? o)
        (let lp ((i (- len 1)) (acc knil))
          (if (negative? i) acc (lp (- i 1) (kons acc (vector-ref vec1 i)))))
        (let lp ((i (- len 1)) (acc knil))
          (if (negative? i)
              acc
              (lp (- i 1)
                  (apply kons acc (vector-ref vec1 i)
                         (map (lambda (v) (vector-ref v i)) o))))))))

(define (vector-map! proc vec1 . o)
  (let ((len (vector-length vec1)))
    (if (null? o)
        (let lp ((i 0))
          (cond
           ((>= i len) vec1)
           (else (vector-set! vec1 i (proc (vector-ref vec1 i))) (lp (+ i 1)))))
        (let lp ((i 0))
          (cond
           ((>= i len) vec1)
           (else
            (let ((x (apply proc (vector-ref vec1 i)
                            (map (lambda (v) (vector-ref v i)) o))))
              (vector-set! vec1 i x)
              (lp (+ i 1)))))))))

(define (vector-count pred? vec1 . o)
  (apply vector-fold
         (lambda (count . x) (+ count (if (apply pred? x) 1 0)))
         0
         vec1 o))

(define (vector-cumulate f knil vec)
  (let* ((len (vector-length vec))
         (res (make-vector len)))
    (let lp ((i 0) (acc knil))
      (if (>= i len)
          res
          (let ((acc (f acc (vector-ref vec i))))
            (vector-set! res i acc)
            (lp (+ i 1) acc))))))

(define (vector-index pred? vec1 . o)
  (let ((len (apply min (vector-length vec1) (map vector-length o))))
    (let lp ((i 0))
      (and (< i len)
           (if (apply pred? (vector-ref vec1 i)
                      (map (lambda (v) (vector-ref v i)) o))
               i
               (lp (+ i 1)))))))

(define (vector-index-right pred? vec1 . o)
  (let ((len (vector-length vec1)))
    (let lp ((i (- len 1)))
      (and (>= i 0)
           (if (apply pred? (vector-ref vec1 i)
                      (map (lambda (v) (vector-ref v i)) o))
               i
               (lp (- i 1)))))))

(define (complement f)
  (lambda args (not (apply f args))))

(define (vector-skip pred? vec1 . o)
  (apply vector-index (complement pred?) vec1 o))

(define (vector-skip-right pred? vec1 . o)
  (apply vector-index-right (complement pred?) vec1 o))

(define (vector-binary-search vec value cmp)
  (let lp ((lo 0) (hi (- (vector-length vec) 1)))
    (and (<= lo hi)
         (let* ((mid (quotient (+ lo hi) 2))
                (x (vector-ref vec mid))
                (y (cmp value x)))
           (cond
            ((< y 0) (lp lo (- mid 1)))
            ((> y 0) (lp (+ mid 1) hi))
            (else mid))))))

(define (vector-any pred? vec1 . o)
  (let ((len (apply min (vector-length vec1) (map vector-length o))))
    (let lp ((i 0))
      (and (< i len)
           (or (apply pred? (vector-ref vec1 i)
                      (map (lambda (v) (vector-ref v i)) o))
               (lp (+ i 1)))))))

(define (vector-every pred? vec1 . o)
  (let ((len (apply min (vector-length vec1) (map vector-length o))))
    (or (zero? len)
        (let lp ((i 0))
          (let ((x (apply pred? (vector-ref vec1 i)
                          (map (lambda (v) (vector-ref v i)) o))))
            (if (= i (- len 1))
                x
                (and x (lp (+ i 1)))))))))

(define (vector-swap! vec i j)
  (let ((tmp (vector-ref vec i)))
    (vector-set! vec i (vector-ref vec j))
    (vector-set! vec j tmp)))

(define (vector-reverse! vec . o)
  (let lp ((left (if (pair? o) (car o) 0))
           (right (- (if (and (pair? o) (pair? (cdr o)))
                         (cadr o)
                         (vector-length vec))
                     1)))
    (cond
     ((>= left right) (if #f #f))
     (else
      (vector-swap! vec left right)
      (lp (+ left 1) (- right 1))))))

(define (vector-reverse-copy! to at from . o)
  (let ((start (if (pair? o) (car o) 0))
        (end (if (and (pair? o) (pair? (cdr o)))
                 (cadr o)
                 (vector-length from))))
    (vector-copy! to at from start end)
    (vector-reverse! to at (+ at (- end start)))))

(define (reverse-vector->list vec . o)
  (reverse (apply vector->list vec o)))

(define (reverse-list->vector ls)
  (list->vector (reverse ls)))

(define (vector-partition pred? vec)
  (let* ((len (vector-length vec))
         (res (make-vector len)))
    (let lp ((i 0) (left 0) (right (- len 1)))
      (cond
       ((= i len)
        (if (< left len)
            (vector-reverse! res left))
        (values res left))
       (else
        (let ((x (vector-ref vec i)))
          (cond
           ((pred? x)
            (vector-set! res left x)
            (lp (+ i 1) (+ left 1) right))
           (else
            (vector-set! res right x)
            (lp (+ i 1) left (- right 1))))))))))
(define-library (srfi 133 test)
  (import (scheme base) (srfi 133) (chibi test))
  (export run-tests)
  (begin
    (define (run-tests)
      (test-begin "srfi-133: vectors")
      (test-group "vectors/constructors"
        (define a2i '#(a b c d e f g h i))
        (test '#(0 1 2 3 4) (vector 0 1 2 3 4))
        (test '#(0 -1 -2 -3 -4 -5 -6 -7 -8 -9)
            (vector-unfold (lambda (i x) (values x (- x 1))) 10 0))
        (test '#(0 1 2 3 4 5 6) (vector-unfold values 7))
        (test '#((0 . 4) (1 . 3) (2 . 2) (3 . 1) (4 . 0))
            (vector-unfold-right (lambda (i x) (values (cons i x) (+ x 1))) 5 0))
        (test a2i (vector-copy a2i))
        (test-assert (not (eqv? a2i (vector-copy a2i))))
        (test '#(g h i) (vector-copy a2i 6))
        (test '#(d e f) (vector-copy a2i 3 6))
        (test '#(1 2 3 4) (vector-reverse-copy '#(5 4 3 2 1 0) 1 5))
        (test '#(x y) (vector-append '#(x) '#(y)))
        (test '#(a b c d) (vector-append '#(a) '#(b c d)))
        (test '#(a #(b) #(c)) (vector-append '#(a #(b)) '#(#(c))))
        (test '#(a b c d) (vector-concatenate '(#(a b) #(c d))))
        (test '#(a b h i) (vector-append-subvectors '#(a b c d e) 0 2 '#(f g h i j) 2 4))
        )

      (test-group "vectors/predicates"
        (test #f (vector-empty? '#(a)))
        (test #f (vector-empty? '#(())))
        (test #f (vector-empty? '#(#())))
        (test-assert (vector-empty? '#()))
        (test-assert (vector= eq? '#(a b c d) '#(a b c d)))
        (test #f (vector= eq? '#(a b c d) '#(a b d c)))
        (test #f (vector= = '#(1 2 3 4 5) '#(1 2 3 4)))
        (test-assert (vector= eq?))
        (test-assert (vector= eq? '#(a)))
        (test #f (vector= eq? (vector (vector 'a)) (vector (vector 'a))))
        (test-assert (vector= equal? (vector (vector 'a)) (vector (vector 'a))))
        )

      (test-group "vectors/iteration"
        (define vos '#("abc" "abcde" "abcd"))
        (define vec '#(0 1 2 3 4 5))
        (define vec2 (vector 0 1 2 3 4))
        (define vec3 (vector 1 2 3 4 5))
        (define result '())
        (define (sqr x) (* x x))
        (test 5 (vector-fold (lambda (len str) (max (string-length str) len))
                             0 vos))
        (test '(5 4 3 2 1 0)
            (vector-fold (lambda (tail elt) (cons elt tail)) '() vec))
        (test 3 (vector-fold (lambda (ctr n) (if (even? n) (+ ctr 1) ctr)) 0 vec))
        (test '(a b c d) (vector-fold-right (lambda (tail elt) (cons elt tail))
                                            '() '#(a b c d)))
        (test '#(1 4 9 16) (vector-map sqr '#(1 2 3 4)))
        (test '#(5 8 9 8 5) (vector-map * '#(1 2 3 4 5) '#(5 4 3 2 1)))
        (vector-map! sqr vec2)
        (test '#(0 1 4 9 16) (vector-copy vec2))
        (vector-map! * vec2 vec3)
        (test '#(0 2 12 36 80) (vector-copy vec2))
        (vector-for-each (lambda (x) (set! result (cons x result))) vec)
        (test '(5 4 3 2 1 0) (cons (car result) (cdr result)))
        (test 3 (vector-count even? '#(3 1 4 1 5 9 2 5 6)))
        (test 2 (vector-count < '#(1 3 6 9) '#(2 4 6 8 10 12)))
        (test '#(3 4 8 9 14 23 25 30 36) (vector-cumulate + 0 '#(3 1 4 1 5 9 2 5 6)))
        )

      (test-group "vectors/searching"
        (define (cmp a b)
          (cond
           ((< a b) -1)
           ((= a b) 0)
           (else 1)))
        (define v '#(0 2 4 6 8 10 12))
        (test 2 (vector-index even? '#(3 1 4 1 5 9 6)))
        (test 1 (vector-index < '#(3 1 4 1 5 9 2 5 6) '#(2 7 1 8 2)))
        (test #f (vector-index = '#(3 1 4 1 5 9 2 5 6) '#(2 7 1 8 2)))
        (test 5 (vector-index-right odd? '#(3 1 4 1 5 9 6)))
        (test 3 (vector-index-right < '#(3 1 4 1 5) '#(2 7 1 8 2)))
        (test 2 (vector-skip number? '#(1 2 a b 3 4 c d)))
        (test 2 (vector-skip = '#(1 2 3 4 5) '#(1 2 -3 4)))
        (test 7 (vector-skip-right number? '#(1 2 a b 3 4 c d)))
        (test 3 (vector-skip-right = '#(1 2 3 4 5) '#(1 2 -3 -4 5)))
        (test 0 (vector-binary-search v 0 cmp))
        (test 3 (vector-binary-search v 6 cmp))
        (test #f (vector-binary-search v 1 cmp))
        (test-assert (vector-any number? '#(1 2 x y z)))
        (test-assert (vector-any < '#(1 2 3 4 5) '#(2 1 3 4 5)))
        (test #f (vector-any number? '#(a b c d e)))
        (test #f (vector-any > '#(1 2 3 4 5) '#(1 2 3 4 5)))
        (test #f (vector-every number? '#(1 2 x y z)))
        (test-assert (vector-every number? '#(1 2 3 4 5)))
        (test #f (vector-every < '#(1 2 3) '#(2 3 3)))
        (test-assert (vector-every < '#(1 2 3) '#(2 3 4)))
        (test 'yes (vector-any (lambda (x) (if (number? x) 'yes #f)) '#(1 2 x y z)))
        (let-values (((new off) (vector-partition number? '#(1 x 2 y 3 z))))
          (test '#(1 2 3 x y z) (vector-copy new))
          (test 3 (+ off 0)))
        )

      (test-group "vectors/mutation"
        (define vs (vector 1 2 3))
        (define vf0 (vector 1 2 3))
        (define vf1 (vector 1 2 3))
        (define vf2 (vector 1 2 3))
        (define vr0 (vector 1 2 3))
        (define vr1 (vector 1 2 3))
        (define vr2 (vector 1 2 3))
        (define vc0 (vector 1 2 3 4 5))
        (define vc1 (vector 1 2 3 4 5))
        (define vc2 (vector 1 2 3 4 5))
        (define vrc0 (vector 1 2 3 4 5))
        (define vrc1 (vector 1 2 3 4 5))
        (define vrc2 (vector 1 2 3 4 5))
        (define vu0 (vector 1 2 3 4 5))
        (define vu1 (vector 1 2 3 4 5))
        (define vu2 (vector 1 2 3 4 5))
        (define vur0 (vector 1 2 3 4 5))
        (define vur1 (vector 1 2 3 4 5))
        (define vur2 (vector 1 2 3 4 5))
        (vector-swap! vs 0 1)
        (test '#(2 1 3) (vector-copy vs))
        (vector-fill! vf0 0)
        (test '#(0 0 0) (vector-copy vf0))
        (vector-fill! vf1 0 1)
        (test '#(1 0 0) (vector-copy vf1))
        (vector-fill! vf2 0 0 1)
        (test '#(0 2 3) (vector-copy vf2))
        (vector-reverse! vr0)
        (test '#(3 2 1) (vector-copy vr0))
        (vector-reverse! vr1 1)
        (test '#(1 3 2) (vector-copy vr1))
        (vector-reverse! vr2 0 2)
        (test '#(2 1 3) (vector-copy vr2))
        (vector-copy! vc0 1 '#(10 20 30))
        (test '#(1 10 20 30 5) (vector-copy vc0))
        (vector-copy! vc1 1 '#(0 10 20 30 40) 1)
        (test '#(1 10 20 30 40) (vector-copy vc1))
        (vector-copy! vc2 1 '#(0 10 20 30 40) 1 4)
        (test '#(1 10 20 30 5) (vector-copy vc2))
        (vector-reverse-copy! vrc0 1 '#(10 20 30))
        (test '#(1 30 20 10 5) (vector-copy vrc0))
        (vector-reverse-copy! vrc1 1 '#(0 10 20 30 40) 1)
        (test '#(1 40 30 20 10) (vector-copy vrc1))
        (vector-reverse-copy! vrc2 1 '#(0 10 20 30 40) 1 4)
        (test '#(1 30 20 10 5) (vector-copy vrc2))
        (vector-unfold! (lambda (i) (+ 10 i)) vu0 1 4)
        (test '#(1 11 12 13 5) (vector-copy vu0))
        (vector-unfold! (lambda (i x) (values (+ i x) (+ x 1))) vu1 1 4 0)
        (test '#(1 1 3 5 5) (vector-copy vu1))
        (vector-unfold! (lambda (i x y) (values (+ i x y) (+ x 1) (+ x 1))) vu2 1 4 0 0)
        (test '#(1 1 4 7 5) (vector-copy vu2))
        (vector-unfold-right! (lambda (i) (+ 10 i)) vur0 1 4)
        (test '#(1 11 12 13 5) (vector-copy vur0))
        (vector-unfold-right! (lambda (i x) (values (+ i x) (+ x 1))) vur1 1 4 0)
        (test '#(1 3 3 3 5) (vector-copy vur1))
        (vector-unfold-right! (lambda (i x y) (values (+ i x y) (+ x 1) (+ x 1))) vur2 1 4 0 0)
        (test '#(1 5 4 3 5) (vector-copy vur2))
        )

      (test-group "vectors/conversion"
        (test '(1 2 3) (vector->list '#(1 2 3)))
        (test '(2 3) (vector->list '#(1 2 3) 1))
        (test '(1 2) (vector->list '#(1 2 3) 0 2))
        (test '#(1 2 3) (list->vector '(1 2 3)))
        (test '(3 2 1) (reverse-vector->list '#(1 2 3)))
        (test '(3 2) (reverse-vector->list '#(1 2 3) 1))
        (test '(2 1) (reverse-vector->list '#(1 2 3) 0 2))
        (test '#(3 2 1) (reverse-list->vector '(1 2 3)))
        (test "abc" (vector->string '#(#\a #\b #\c)))
        (test "bc" (vector->string '#(#\a #\b #\c) 1))
        (test "ab" (vector->string '#(#\a #\b #\c) 0 2))
        (test '#(#\a #\b #\c) (string->vector "abc"))
        (test '#(#\b #\c) (string->vector "abc" 1))
        (test '#(#\a #\b) (string->vector "abc" 0 2))
        )

      (test-end))))

(define-library (srfi 18)
  (export
   current-thread thread? make-thread thread-name
   thread-specific thread-specific-set! thread-start!
   thread-yield! thread-sleep! thread-terminate!
   thread-join! mutex? make-mutex mutex-name
   mutex-specific mutex-specific-set! mutex-state
   mutex-lock! mutex-unlock! condition-variable?
   make-condition-variable condition-variable-name
   condition-variable-specific condition-variable-specific-set!
   condition-variable-signal! condition-variable-broadcast!
   current-time time? time->seconds seconds->time
   current-exception-handler with-exception-handler raise
   join-timeout-exception? abandoned-mutex-exception?
   terminated-thread-exception? uncaught-exception?
   uncaught-exception-reason)
  (cond-expand
   (threads
    (import (chibi) (srfi 9) (chibi ast)
            (except (chibi time) time->seconds seconds->time))
    (include "18/types.scm")
    (include-shared "18/threads")
    (include "18/interface.scm"))
   (else
    (error "chibi was not compiled with threading support"))))

(define-library (srfi 14)
  (export
   char-set? char-set= char-set<=
   char-set-hash 
   char-set-cursor char-set-ref char-set-cursor-next end-of-char-set?
   char-set-fold char-set-unfold char-set-unfold!
   char-set-for-each char-set-map
   char-set-copy char-set

   list->char-set  string->char-set 
   list->char-set! string->char-set! 

   char-set-filter  ucs-range->char-set  ->char-set
   char-set-filter! ucs-range->char-set!

   char-set->list char-set->string

   char-set-size char-set-count char-set-contains?
   char-set-every char-set-any

   char-set-adjoin  char-set-delete 
   char-set-adjoin! char-set-delete!

   char-set-complement  char-set-union  char-set-intersection  
   char-set-complement! char-set-union! char-set-intersection! 

   char-set-difference  char-set-xor  char-set-diff+intersection
   char-set-difference! char-set-xor! char-set-diff+intersection!

   char-set:lower-case   char-set:upper-case    char-set:title-case
   char-set:letter       char-set:digit         char-set:letter+digit
   char-set:graphic      char-set:printing      char-set:whitespace
   char-set:iso-control  char-set:punctuation   char-set:symbol
   char-set:hex-digit    char-set:blank         char-set:ascii
   char-set:empty        char-set:full)
  (import (scheme base)
          (chibi char-set)
          (chibi char-set full)
          (chibi iset)
          (only (srfi 125) hash))
  (begin
    (define char-set= iset=)
    (define char-set<= iset<=)
    (define char-set-hash hash)
    (define char-set-cursor iset-cursor)
    (define char-set-cursor-next iset-cursor-next)
    (define (char-set-ref cs cur) (integer->char (iset-ref cs cur)))
    (define end-of-char-set? end-of-iset?)
    (define (char-set-fold kons knil cs)
      (iset-fold (lambda (i x) (kons (integer->char i) x)) knil cs))
    (define (char-set-unfold! p f g seed cs)
      (let lp ((seed seed) (cs cs))
        (if (p seed)
            cs
            (lp (g seed) (char-set-adjoin! cs (f seed))))))
    (define (char-set-unfold p f g seed . o)
      (let ((cs (if (pair? o) (char-set-copy (car o)) (char-set))))
        (char-set-unfold! p f g seed cs)))
    (define (char-set-map proc cs)
      (iset-map (lambda (i) (char->integer (proc (integer->char i)))) cs))
    (define list->char-set! list->char-set)
    (define string->char-set! string->char-set)
    (define ucs-range->char-set! ucs-range->char-set)
    (define (->char-set x)
      (cond ((char? x) (char-set x))
            ((pair? x) (list->char-set x))
            ((string? x) (string->char-set x))
            (else x)))
    (define (char-set-delete cs . o)
      (apply iset-delete cs (map char->integer o)))
    (define (char-set-delete! cs . o)
      (apply iset-delete! cs (map char->integer o)))
    (define char-set-complement! char-set-complement)
    (define (char-set-filter pred cs . o)
      (char-set-fold
       (lambda (ch res) (if (pred ch) (char-set-adjoin! res ch) res))
       (if (pair? o) (char-set-copy (car o)) (char-set))
       cs))
    (define char-set-filter! char-set-filter)
    (define (char-set-count pred cs)
      (char-set-fold (lambda (ch i) (if (pred ch) (+ i 1) i)) 0 cs))
    (define (char-set-any pred cs)
      (let lp ((cur (char-set-cursor cs)))
        (if (end-of-char-set? cur)
            #f
            (or (pred (char-set-ref cs cur))
                (lp (char-set-cursor-next cs cur))))))
    (define (char-set-every pred cs)
      (not (char-set-any (lambda (ch) (not (pred ch))) cs)))
    (define (char-set-xor2 cs1 cs2)
      (char-set-union (char-set-difference cs1 cs2)
                      (char-set-difference cs2 cs1)))
    (define (char-set-xor . o)
      (cond
       ((null? o) (char-set))
       ((null? (cdr o)) (char-set-copy (car o)))
       (else (apply char-set-xor (char-set-xor2 (car o) (cadr o)) (cddr o)))))
    (define char-set-xor! char-set-xor)
    (define (char-set-diff+intersection . o)
      (values (apply char-set-difference o)
              (apply char-set-intersection o)))
    (define char-set-diff+intersection! char-set-diff+intersection)))

(define-library (srfi 8)
  (export receive)
  (import (chibi))
  (body
   (define-syntax receive
     (syntax-rules ()
       ((receive params expr . body)
        (call-with-values (lambda () expr) (lambda params . body)))))))

(define-library (srfi 33)
  (export bitwise-not
          bitwise-and   bitwise-ior 
          bitwise-xor   bitwise-eqv
          bitwise-nand  bitwise-nor 
          bitwise-andc1 bitwise-andc2
          bitwise-orc1  bitwise-orc2 
          arithmetic-shift bit-count integer-length
          bitwise-merge 
          bit-set? any-bits-set? all-bits-set?
          first-set-bit
          extract-bit-field test-bit-field? clear-bit-field 
          replace-bit-field copy-bit-field)
  (import (scheme base)
          (rename (srfi 142)
                  (bitwise-if bitwise-merge)
                  (any-bit-set? any-bits-set?)
                  (every-bit-set? all-bits-set?)
                  (bit-field-any? test-bit-field?)
                  (bit-field-clear clear-bit-field)))
  (begin
    (define (mask len)
      (- (arithmetic-shift 1 len) 1))
    (define (extract-bit-field size position n)
      (bitwise-and (arithmetic-shift n (- position)) (mask size)))
    (define (replace-bit-field size position newfield n)
      (bitwise-ior
       (bitwise-and n (bitwise-not (arithmetic-shift (mask size) position)))
       (arithmetic-shift newfield position)))
    (define (copy-bit-field size position from to)
      (bitwise-merge (arithmetic-shift (mask size) position) to from))))

(define (string-cursor-diff str start end)
  (if (string-cursor? start)
      (- (string-cursor->index str end) (string-cursor->index str start))
      (- end start)))

(define (string-unfold/aux k stop? mapper successor seed . o)
  (let ((base (if (pair? o) (car o) ""))
        (make-final (if (and (pair? o) (pair? (cdr o))) (cadr o) (lambda (x) ""))))
    (do ((acc seed (successor acc))
         (ls '() (cons (mapper acc) ls)))
        ((stop? acc) (k base ls (make-final acc))))))

(define (string-unfold . o)
  (apply string-unfold/aux
         (lambda (base ls final)
           (string-append base (reverse-list->string ls) final))
         o))

(define (string-unfold-right . o)
  (apply string-unfold/aux
         (lambda (base ls final)
           (string-append final (list->string ls) base))
         o))

(define (string-tabulate proc len)
  (string-unfold (lambda (i) (= i len)) proc (lambda (i) (+ i 1)) 0))

(define (string->list/cursors str . o)
  (let ((start (if (pair? o) (car o) (string-cursor-start str)))
        (end (if (and (pair? o) (pair? (cdr o)))
                 (cadr o)
                 (string-cursor-end str))))
    (let lp ((i end) (res '()))
      (if (string-cursor<=? i start)
          res
          (let ((i (string-cursor-prev str i)))
            (lp i (cons (string-cursor-ref str i) res)))))))

(define (string->vector/cursors str . o)
  (list->vector (apply string->list/cursors str o)))

(define (reverse-list->string ls)
  (list->string (reverse ls)))

(define (string-join str-ls . o)
  (let ((sep (if (pair? o) (car o) ""))
        (grammar (if (and (pair? o) (pair? (cdr o))) (cadr o) 'infix)))
    (case grammar
      ((infix) (%string-join str-ls sep))
      ((strict-infix)
       (if (null? str-ls)
           (error "string-join 'strict-infix called on an empty list")
           (%string-join str-ls sep)))
      ((prefix)
       (if (null? str-ls) "" (%string-join (cons "" str-ls) sep)))
      ((suffix)
       (if (null? str-ls) "" (string-append (%string-join str-ls sep) sep)))
      (else (error "unknown string-join grammar" grammar)))))

(define (string-ref/cursor str x)
  (if (string-cursor? x)
      (string-cursor-ref str x)
      (string-ref str x)))

(define (substring/cursors str start end)
  (if (string-cursor? start)
      (substring-cursor str start end)
      (substring str start end)))

(define (string-copy/cursors str . o)
  (cond ((null? o) (substring-cursor str (string-cursor-start str)))
        ((string-cursor? (car o)) (apply substring-cursor str o))
        (else (apply substring str o))))

(define (string-arg str o)
  (if (pair? o) (apply string-copy/cursors str o) str))

(define (cursor-arg str x)
  (if (string-cursor? x) x (string-index->cursor str x)))

(define (cursor-args str o)
  (if (pair? o)
      (cons (cursor-arg str (car o)) (cursor-args str (cdr o)))
      '()))

(define (string-take str n)
  (substring str 0 n))
(define (string-take-right str n)
  (let ((start (string-cursor-back str (string-cursor-end str) n)))
    (substring-cursor str start)))
(define (string-drop str n)
  (substring str n))
(define (string-drop-right str n)
  (let ((end (string-cursor-back str (string-cursor-end str) n)))
    (substring-cursor str (string-cursor-start str) end)))

(define (string-pad str len . o)
  (let* ((pad-char (if (pair? o) (car o) #\space))
         (str (if (and (pair? o) (pair? (cdr o))) (string-arg str (cdr o)) str))
         (str-len (string-length str)))
    (cond
     ((> str-len len) (string-take-right str len))
     ((< str-len len)
      (string-append (make-string (- len str-len) pad-char) str))
     (else str))))

(define (string-pad-right str len . o)
  (let* ((pad-char (if (pair? o) (car o) #\space))
         (str (if (and (pair? o) (pair? (cdr o))) (string-arg str (cdr o)) str))
         (str-len (string-length str)))
    (cond
     ((> str-len len) (string-take str len))
     ((< str-len len)
      (string-append str (make-string (- len str-len) pad-char)))
     (else str)))) 

(define (string-trim str . o)
  (let ((pred (if (pair? o) (car o) char-whitespace?))
        (str (if (and (pair? o) (pair? (cdr o))) (string-arg str (cdr o)) str)))
    (substring-cursor str (string-skip str pred))))
(define (string-trim-right str . o)
  (let ((pred (if (pair? o) (car o) char-whitespace?))
        (str (if (and (pair? o) (pair? (cdr o))) (string-arg str (cdr o)) str)))
    (substring-cursor str (string-cursor-start str) (string-skip-right str pred))))
(define (string-trim-both str . o)
  (let ((pred (if (pair? o) (car o) char-whitespace?))
        (str (if (and (pair? o) (pair? (cdr o))) (string-arg str (cdr o)) str)))
    (string-trim-right (string-trim str pred) pred)))

(define (string-prefix-length s1 s2 . o)
  (let ((s1 (string-arg s1 o))
        (s2 (if (and (pair? o) (pair? (cdr o))) (string-arg s2 (cddr o)) s2)))
    (call-with-values (lambda () (string-mismatch s1 s2))
      (lambda (i j) (string-cursor->index s1 i)))))
(define (string-suffix-length s1 s2 . o)
  (let* ((s1 (string-arg s1 o))
         (s2 (if (and (pair? o) (pair? (cdr o))) (string-arg s2 (cddr o)) s2))
         (mismatch (call-with-values (lambda () (string-mismatch-right s2 s1))
                     (lambda (i j) j))))
    (string-cursor-diff s1
                        (string-cursor-next s1 mismatch)
                        (string-cursor-end s1))))

(define (string-prefix? s1 s2 . o)
  (equal? (string-length s1) (apply string-prefix-length s1 s2 o)))
(define (string-suffix? s1 s2 . o)
  (equal? (string-length s1) (apply string-suffix-length s1 s2 o)))

(define (string-index str pred . o)
  (apply string-find str pred (cursor-args str o)))
(define (string-index-right str pred . o)
  (apply string-find-right str pred (cursor-args str o)))

(define (string-contains s1 s2 . o)
  (let ((start1 (cursor-arg s1 (if (pair? o) (car o) (string-cursor-start s1))))
        (end1 (cursor-arg s1 (if (and (pair? o) (pair? (cdr o)))
                                 (cadr o)
                                 (string-cursor-end s1))))
        (s2 (if (and (pair? o) (pair? (cdr o))) (string-arg s2 (cddr o)) s2)))
    (let ((res (%string-contains s1 s2 start1)))
      (and res
           (string-cursor<=? (string-cursor-forward s1 res (string-length s2))
                             end1)
           res))))

(define (string-contains-right s1 s2 . o)
  (let* ((start1
          (cursor-arg s1 (if (pair? o) (car o) (string-cursor-start s1))))
         (end1 (cursor-arg s1 (if (and (pair? o) (pair? (cdr o)))
                                  (cadr o)
                                  (string-cursor-end s1))))
         (s2 (if (and (pair? o) (pair? (cdr o))) (string-arg s2 (cddr o)) s2))
         (start2 (string-cursor-start s2))
         (end2 (string-cursor-end s2)))
    (let lp ((sc1-base end1)
             (sc1 end1)
             (sc2-base end2)
             (sc2 end2))
      (cond
       ((string-cursor=? sc2 start2)
        sc1)
       ((string-cursor=? sc1 start1)
        #f)
       (else
        (let ((sc1 (string-cursor-prev s1 sc1))
              (sc2 (string-cursor-prev s2 sc2)))
          (if (eqv? (string-cursor-ref s1 sc1) (string-cursor-ref s2 sc2))
              (lp sc1-base sc1 sc2-base sc2)
              (let ((sc1-base (string-cursor-prev s1 sc1-base)))
                (lp sc1-base sc1-base sc2-base sc2-base)))))))))

(define (string-reverse str . o)
  (list->string (reverse (string->list/cursors (string-arg str o)))))

(define string-concatenate %string-join)

(define (string-concatenate-reverse str-ls . o)
  (let ((str-ls
         (if (pair? o)
             (cons (apply string-copy/cursors (car o) 0 (cdr o)) str-ls)
             str-ls)))
    (string-concatenate (reverse str-ls))))

(define (string-fold kons knil str . o)
  (%string-fold kons knil (string-arg str o)))

(define (string-fold-right kons knil str . o)
  (%string-fold-right kons knil (string-arg str o)))

(define (string-for-each-cursor proc str . o)
  (let ((end (cursor-arg str
                         (if (and (pair? o) (pair? (cdr o)))
                             (cadr o)
                             (string-cursor-end str)))))
    (let lp ((i (cursor-arg str
                            (if (pair? o) (car o) (string-cursor-start str)))))
      (when (string-cursor<? i end)
        (proc i)
        (lp (string-cursor-next str i))))))

(define (string-replicate str from to . o)
  (let* ((str (string-arg str o))
         (start (string-cursor-start str))
         (end (string-cursor-end str))
         (out (open-output-string)))
    (let lp ((i from)
             (sc (string-cursor-forward str
                                        start
                                        (modulo from (string-length str)))))
      (cond
       ((= i to)
        (get-output-string out))
       (else
        (write-char (string-cursor-ref str sc) out)
        (let ((sc (string-cursor-next str sc)))
          (lp (+ i 1) (if (string-cursor=? sc end) start sc))))))))

(define (string-count str pred . o)
  (apply string-fold (lambda (ch n) (if (pred ch) (+ n 1) n)) 0 str o))

(define (string-replace s1 s2 start1 end1 . o)
  (if (string-cursor? start1)
      (string-append (substring/cursors s1 (string-cursor-start s1) start1)
                     (string-arg s2 o)
                     (substring/cursors s1 end1 (string-cursor-end s1)))
      (string-append (substring s1 0 start1)
                     (string-arg s2 o)
                     (substring s1 end1 (string-length s1)))))

(define (string-split str delim . o)
  (let* ((delim-len (string-length delim))
         (grammar (if (pair? o) (car o) 'infix))
         (o (if (pair? o) (cdr o) '()))
         ;; default to an arbitrary limit guaranteed to be more than
         ;; the maximum number of matches
         (limit (or (and (pair? o) (car o)) (string-length str)))
         (o (if (pair? o) (cdr o) '()))
         (start (cursor-arg str
                            (if (pair? o) (car o) (string-cursor-start str))))
         (end (cursor-arg str (if (and (pair? o) (pair? (cdr o)))
                                  (cadr o)
                                  (string-cursor-end str)))))
    (if (and (eq? grammar 'strict-infix) (string-cursor>=? start end))
        (error "string-split 'strict-infix called on an empty string"))
    (let lp ((sc start) (found? #f) (i 1) (res '()))
      (cond
       ((string-cursor>=? sc end)
        (if (and found? (not (eq? 'suffix grammar)))
            (reverse (cons "" res))
            (reverse res)))
       ((string-contains str delim sc end)
        => (lambda (sc2)
             (let ((sc3 (string-cursor-forward str sc2 delim-len)))
               (cond
                ((>= i limit)
                 (let* ((res (if (equal? "" delim)
                                 res
                                 (cons (substring-cursor str sc sc2) res)))
                        (res (if (and (string-cursor=? sc3 end)
                                      (eq? 'suffix grammar))
                                 res
                                 (cons (substring-cursor str sc3 end) res))))
                   (lp end #f i res)))
                ((equal? "" delim)
                 (lp (string-cursor-forward str sc2 1)
                     #f
                     (+ i 1)
                     (cons (string (string-cursor-ref str sc2)) res)))
                ((and (string-cursor=? sc2 start) (eq? 'prefix grammar))
                 (lp sc3 #t (+ i 1) res))
                (else
                 (lp sc3 #t (+ i 1)
                     (cons (substring-cursor str sc sc2) res)))))))
       (else
        (lp end #f i (cons (substring-cursor str sc end) res)))))))

(define (string-filter pred str . o)
  (let ((out (open-output-string)))
    (apply string-fold (lambda (ch acc) (if (pred ch) (write-char ch out))) #f str o)
    (get-output-string out)))

(define (string-remove pred str . o)
  (apply string-filter (lambda (ch) (not (pred ch))) str o))
(define-syntax out
  (er-macro-transformer
   (lambda (expr rename compare)
     (for-each set-cdr! (car (cddr expr)) (cadr (cddr expr)))
     (car (cdr expr)))))

(define-syntax syntax-parameterize
  (lambda (expr use-env mac-env)
    (let* ((_let (make-syntactic-closure mac-env '() 'let))
           (_set! (make-syntactic-closure mac-env '() 'set!))
           (_out (make-syntactic-closure mac-env '() 'out))
           (_tmp (make-syntactic-closure mac-env '() 'tmp))
           (bindings (cadr expr))
           (body (cddr expr))
           (keywords (map car bindings))
           (transformers (map cadr bindings))
           (cells
            (map (lambda (keyword)
                   (env-cell use-env keyword))
                 keywords))
           (old (map cdr cells))
           (new (map (lambda (transformer)
                       (make-macro
                        (eval
                         (make-syntactic-closure use-env '() transformer))
                        use-env))
                     transformers)))
      (for-each set-cdr! cells new)
      `(,_let ((,_tmp #f))
         (,_set! ,_tmp (,_let () ,@body))
         (,_out ,_tmp ,cells ,old)))))

(define-library (srfi 23)
  (import (scheme base))
  (export error))
;;;
;;; srfi-134 reference implementation
;;;
;;;   Copyright (c) 2015  Shiro Kawai  <shiro@acm.org>
;;;
;;;   Redistribution and use in source and binary forms, with or without
;;;   modification, are permitted provided that the following conditions
;;;   are met:
;;;
;;;   1. Redistributions of source code must retain the above copyright
;;;      notice, this list of conditions and the following disclaimer.
;;;
;;;   2. Redistributions in binary form must reproduce the above copyright
;;;      notice, this list of conditions and the following disclaimer in the
;;;      documentation and/or other materials provided with the distribution.
;;;
;;;   3. Neither the name of the authors nor the names of its contributors
;;;      may be used to endorse or promote products derived from this
;;;      software without specific prior written permission.
;;;
;;;   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
;;;   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
;;;   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
;;;   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
;;;   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
;;;   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
;;;   TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
;;;   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
;;;   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
;;;   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
;;;   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
;;;

;; This implements banker's deque as described in
;; Chris Okasaki's Purely Functional Data Structures.
;; It provides amortized O(1) basic operations.
;; Originally written for Gauche, and ported to R7RS.

;; Requires srfi-1, srfi-9, srfi-121.

;; some compatibility stuff
(define-syntax receive
  (syntax-rules ()
    ((_ binds mv-expr body ...)
     (let-values ((binds mv-expr)) body ...))))

;;;
;;; Record
;;;

(define-record-type <ideque> (%make-dq lenf f lenr r) ideque?
  (lenf dq-lenf)  ; length of front chain
  (f    dq-f)     ; front chain
  (lenr dq-lenr)  ; length of rear chain
  (r    dq-r))    ; rear chain

;; We use a singleton for empty deque
(define *empty* (%make-dq 0 '() 0 '()))

;; Common type checker
(define (%check-ideque x)
  (unless (ideque? x)
    (error "ideque expected, but got:" x)))

;;;
;;; Constructors
;;;

;; API
(define (ideque . args) (list->ideque args))

;; API
(define (ideque-tabulate size init)
  (let ((lenf (quotient size 2))
        (lenr (quotient (+ size 1) 2)))
    (%make-dq lenf (list-tabulate lenf init)
              lenr (unfold (lambda (n) (= n lenr))
                           (lambda (n) (init (- size n 1)))
                           (lambda (n) (+ n 1))
                           0))))

;; API
(define (ideque-unfold p f g seed)
  (list->ideque (unfold p f g seed)))

;; API
(define (ideque-unfold-right p f g seed)
  (list->ideque (unfold-right p f g seed)))
;; alternatively:
;; (ideque-reverse (list->ideque (unfold p f g seed)))

;; Internal constructor.  Returns a new ideque, with balancing 'front' and
;; 'rear' chains.  (The name 'check' comes from Okasaki's book.)

(define C 3)

(define (check lenf f lenr r)
  (cond ((> lenf (+ (* lenr C) 1))
         (let* ((i (quotient (+ lenf lenr) 2))
                (j (- (+ lenf lenr) i))
                (f. (take f i))
                (r. (append r (reverse (drop f i)))))
           (%make-dq i f. j r.)))
        ((> lenr (+ (* lenf C) 1))
         (let* ((j (quotient (+ lenf lenr) 2))
                (i (- (+ lenf lenr) j))
                (r. (take r j))
                (f. (append f (reverse (drop r j)))))
           (%make-dq i f. j r.)))
        (else (%make-dq lenf f lenr r))))

;;;
;;; Basic operations
;;;

;; API
(define (ideque-empty? dq)
  (%check-ideque dq)
  (and (zero? (dq-lenf dq))
       (zero? (dq-lenr dq))))

;; API
(define (ideque-add-front dq x)
  (%check-ideque dq)
  (check (+ (dq-lenf dq) 1) (cons x (dq-f dq)) (dq-lenr dq) (dq-r dq)))

;; API
(define (ideque-front dq)
  (%check-ideque dq)
  (if (zero? (dq-lenf dq))
    (if (zero? (dq-lenr dq))
      (error "Empty deque:" dq)
      (car (dq-r dq)))
    (car (dq-f dq))))

;; API
(define (ideque-remove-front dq)
  (%check-ideque dq)
  (if (zero? (dq-lenf dq))
    (if (zero? (dq-lenr dq))
      (error "Empty deque:" dq)
      *empty*)
    (check (- (dq-lenf dq) 1) (cdr (dq-f dq)) (dq-lenr dq) (dq-r dq))))

;; API
(define (ideque-add-back dq x)
  (%check-ideque dq)
  (check (dq-lenf dq) (dq-f dq) (+ (dq-lenr dq) 1) (cons x (dq-r dq))))

;; API
(define (ideque-back dq)
  (%check-ideque dq)
  (if (zero? (dq-lenr dq))
    (if (zero? (dq-lenf dq))
      (error "Empty deque:" dq)
      (car (dq-f dq)))
    (car (dq-r dq))))

;; API
(define (ideque-remove-back dq)
  (%check-ideque dq)
  (if (zero? (dq-lenr dq))
    (if (zero? (dq-lenf dq))
      (error "Empty deque:" dq)
      *empty*)
    (check (dq-lenf dq) (dq-f dq) (- (dq-lenr dq) 1) (cdr (dq-r dq)))))

;; API
(define (ideque-reverse dq)
  (%check-ideque dq)
  (if (ideque-empty? dq)
    *empty*
    (%make-dq (dq-lenr dq) (dq-r dq) (dq-lenf dq) (dq-f dq))))

;;
;; Other operations
;;

;; API
(define ideque=
  (case-lambda
    ((elt=) #t)
    ((elt= ideque) (%check-ideque ideque) #t)
    ((elt= dq1 dq2)
     ;; we optimize two-arg case
     (%check-ideque dq1)
     (%check-ideque dq2)
     (or (eq? dq1 dq2)
         (let ((len1 (+ (dq-lenf dq1) (dq-lenr dq1)))
               (len2 (+ (dq-lenf dq2) (dq-lenr dq2))))
           (and (= len1 len2)
                (receive (x t1 t2) (list-prefix= elt= (dq-f dq1) (dq-f dq2))
                  (and x
                       (receive (y r1 r2) (list-prefix= elt= (dq-r dq1) (dq-r dq2))
                         (and y
                              (if (null? t1)
                                (list= elt= t2 (reverse r1))
                                (list= elt= t1 (reverse r2)))))))))))
    ((elt= . dqs)
     ;; The comparison scheme is the same as srfi-1's list=.
     (apply list= elt= (map ideque->list dqs)))))

;; Compare two lists up to whichever shorter one.
;; Returns the compare result and the tails of uncompared lists.
(define (list-prefix= elt= a b)
  (let loop ((a a) (b b))
    (cond ((or (null? a) (null? b)) (values #t a b))
          ((elt= (car a) (car b)) (loop (cdr a) (cdr b)))
          (else (values #f a b)))))

;; API
(define (ideque-ref dq n)
  (%check-ideque dq)
  (let ((len (+ (dq-lenf dq) (dq-lenr dq))))
    (cond ((or (< n 0) (>= n len)) (error "Index out of range:" n))
          ((< n (dq-lenf dq)) (list-ref (dq-f dq) n))
          (else (list-ref (dq-r dq) (- len n 1))))))

(define (%ideque-take dq n)             ; n is within the range
  (let ((lenf (dq-lenf dq))
        (f    (dq-f dq)))
    (if (<= n lenf)
      (check n (take f n) 0 '())
      (let ((lenr. (- n lenf)))
        (check lenf f lenr. (take-right (dq-r dq) lenr.))))))

(define (%ideque-drop dq n)             ; n is within the range
  (let ((lenf (dq-lenf dq))
        (f    (dq-f dq))
        (lenr (dq-lenr dq))
        (r    (dq-r dq)))
    (if (<= n lenf)
      (check n (drop f n) lenr r)
      (let ((lenr. (- lenr (- n lenf))))
        (check 0 '() lenr. (take r lenr.))))))

(define (%check-length dq n)
  (unless (<= 0 n (- (ideque-length dq) 1))
    (error "argument is out of range:" n)))

;; API
(define (ideque-take dq n)
  (%check-ideque dq)
  (%check-length dq n)
  (%ideque-take dq n))

;; API
(define (ideque-take-right dq n)
  (%check-ideque dq)
  (%check-length dq n)
  (%ideque-drop dq (- (ideque-length dq) n)))

;; API
(define (ideque-drop dq n)
  (%check-ideque dq)
  (%check-length dq n)
  (%ideque-drop dq n))

;; API
(define (ideque-drop-right dq n)
  (%check-ideque dq)
  (%check-length dq n)
  (%ideque-take dq (- (ideque-length dq) n)))

;; API
(define (ideque-split-at dq n)
  (%check-ideque dq)
  (%check-length dq n)
  (values (%ideque-take dq n)
          (%ideque-drop dq n)))

;; API
(define (ideque-length dq)
  (%check-ideque dq)
  (+ (dq-lenf dq) (dq-lenr dq)))

;; API
(define (ideque-append . dqs)
  ;; We could save some list copying by carefully split dqs into front and
  ;; rear groups and append separately, but for now we don't bother...
  (list->ideque (concatenate (map ideque->list dqs))))

;; API
(define (ideque-count pred dq)
  (%check-ideque dq)
  (+ (count pred (dq-f dq)) (count pred (dq-r dq))))

;; API
(define (ideque-zip dq . dqs)
  ;; An easy way.
  (let ((elts (apply zip (ideque->list dq) (map ideque->list dqs))))
    (check (length elts) elts 0 '())))

;; API
(define (ideque-map proc dq)
  (%check-ideque dq)
  (%make-dq (dq-lenf dq) (map proc (dq-f dq))
            (dq-lenr dq) (map proc (dq-r dq))))

;; API
(define (ideque-filter-map proc dq)
  (%check-ideque dq)
  (let ((f (filter-map proc (dq-f dq)))
        (r (filter-map proc (dq-r dq))))
    (check (length f) f (length r) r)))

;; API
(define (ideque-for-each proc dq)
  (%check-ideque dq)
  (for-each proc (dq-f dq))
  (for-each proc (reverse (dq-r dq))))

;; API
(define (ideque-for-each-right proc dq)
  (%check-ideque dq)
  (for-each proc (dq-r dq))
  (for-each proc (reverse (dq-f dq))))

;; API
(define (ideque-fold proc knil dq)
  (%check-ideque dq)
  (fold proc (fold proc knil (dq-f dq)) (reverse (dq-r dq))))

;; API
(define (ideque-fold-right proc knil dq)
  (%check-ideque dq)
  (fold-right proc (fold-right proc knil (reverse (dq-r dq))) (dq-f dq)))

;; API
(define (ideque-append-map proc dq)
  ;; can be cleverer, but for now...
  (list->ideque (append-map proc (ideque->list dq))))

(define (%ideque-filter-remove op pred dq)
  (%check-ideque dq)
  (let ((f (op pred (dq-f dq)))
        (r (op pred (dq-r dq))))
    (check (length f) f (length r) r)))

;; API
(define (ideque-filter pred dq) (%ideque-filter-remove filter pred dq))
(define (ideque-remove pred dq) (%ideque-filter-remove remove pred dq))

;; API
(define (ideque-partition pred dq)
  (%check-ideque dq)
  (receive (f1 f2) (partition pred (dq-f dq))
    (receive (r1 r2) (partition pred (dq-r dq))
      (values (check (length f1) f1 (length r1) r1)
              (check (length f2) f2 (length r2) r2)))))

(define *not-found* (cons #f #f)) ; unique value

(define (%search pred seq1 seq2 failure)
  ;; We could write seek as CPS, but we employ *not-found* instead to avoid
  ;; closure allocation.
  (define (seek pred s)
    (cond ((null? s) *not-found*)
          ((pred (car s)) (car s))
          (else (seek pred (cdr s)))))
  (let ((r (seek pred seq1)))
    (if (not (eq? r *not-found*))
      r
      (let ((r (seek pred (reverse seq2))))
        (if (not (eq? r *not-found*))
          r
          (failure))))))

;; API
(define (ideque-find pred dq . opts)
  (%check-ideque dq)
  (let ((failure (if (pair? opts) (car opts) (lambda () #f))))
    (%search pred (dq-f dq) (dq-r dq) failure)))

;; API
(define (ideque-find-right pred dq . opts)
  (%check-ideque dq)
  (let ((failure (if (pair? opts) (car opts) (lambda () #f))))
    (%search pred (dq-r dq) (dq-f dq) failure)))

;; API
(define (ideque-take-while pred dq)
  (%check-ideque dq)
  (receive (hd tl) (span pred (dq-f dq))
    (if (null? tl)
      (receive (hd. tl.) (span pred (reverse (dq-r dq)))
        (check (dq-lenf dq) (dq-f dq) (length hd.) (reverse hd.)))
      (check (length hd) hd 0 '()))))

;; API
(define (ideque-take-while-right pred dq)
  (%check-ideque dq)
  (ideque-reverse (ideque-take-while pred (ideque-reverse dq))))

;; API
(define (ideque-drop-while pred dq)
  (%check-ideque dq)
  (receive (hd tl) (span pred (dq-f dq))
    (if (null? tl)
      (receive (hd. tl.) (span pred (reverse (dq-r dq)))
        (check (length tl.) tl. 0 '()))
      (check (length tl) tl (dq-lenr dq) (dq-r dq)))))

;; API
(define (ideque-drop-while-right pred dq)
  (%check-ideque dq)
  (ideque-reverse (ideque-drop-while pred (ideque-reverse dq))))

(define (%idq-span-break op pred dq)
  (%check-ideque dq)
  (receive (head tail) (op pred (dq-f dq))
    (if (null? tail)
      (receive (head. tail.) (op pred (reverse (dq-r dq)))
        (values (check (length head) head (length head.) (reverse head.))
                (check (length tail.) tail. 0 '())))
      (values (check (length head) head 0 '())
              (check (length tail) tail (dq-lenr dq) (dq-r dq))))))

;; API
(define (ideque-span pred dq) (%idq-span-break span pred dq))
(define (ideque-break pred dq) (%idq-span-break break pred dq))

;; API
(define (ideque-any pred dq)
  (%check-ideque dq)
  (if (null? (dq-r dq))
    (any pred (dq-f dq))
    (or (any pred (dq-f dq)) (any pred (reverse (dq-r dq))))))

;; API
(define (ideque-every pred dq)
  (%check-ideque dq)
  (if (null? (dq-r dq))
    (every pred (dq-f dq))
    (and (every pred (dq-f dq)) (every pred (reverse (dq-r dq))))))

;; API
(define (ideque->list dq)
  (%check-ideque dq)
  (append (dq-f dq) (reverse (dq-r dq))))

;; API
(define (list->ideque lis) (check (length lis) lis 0 '()))

;; API
(define (ideque->generator dq)
  (%check-ideque dq)
  (lambda ()
    (if (ideque-empty? dq)
      (eof-object)
      (let ((v (ideque-front dq)))
        (set! dq (ideque-remove-front dq))
        v))))

;; API
(define (generator->ideque gen)
  (list->ideque (generator->list gen)))
;; Copyright (C) Marc Nieper-Wikirchen (2016).  All Rights Reserved. 

;; Permission is hereby granted, free of charge, to any person
;; obtaining a copy of this software and associated documentation
;; files (the "Software"), to deal in the Software without
;; restriction, including without limitation the rights to use, copy,
;; modify, merge, publish, distribute, sublicense, and/or sell copies
;; of the Software, and to permit persons to whom the Software is
;; furnished to do so, subject to the following conditions:

;; The above copyright notice and this permission notice shall be
;; included in all copies or substantial portions of the Software.

;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
;; EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
;; MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
;; NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
;; BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
;; ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
;; CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
;; SOFTWARE.

(define-library (srfi 146)
  (export mapping mapping-unfold
          mapping/ordered mapping-unfold/ordered
          mapping? mapping-contains? mapping-empty? mapping-disjoint?
          mapping-ref mapping-ref/default mapping-key-comparator
          mapping-adjoin mapping-adjoin!
          mapping-set mapping-set!
          mapping-replace mapping-replace!
          mapping-delete mapping-delete! mapping-delete-all mapping-delete-all!
          mapping-intern mapping-intern!
          mapping-update mapping-update! mapping-update/default mapping-update!/default
          mapping-pop mapping-pop!
          mapping-search mapping-search!
          mapping-size mapping-find mapping-count mapping-any? mapping-every?
          mapping-keys mapping-values mapping-entries
          mapping-map mapping-map->list mapping-for-each mapping-fold
          mapping-filter mapping-filter!
          mapping-remove mapping-remove!
          mapping-partition mapping-partition!
          mapping-copy mapping->alist alist->mapping alist->mapping!
          alist->mapping/ordered alist->mapping/ordered!
          mapping=? mapping<? mapping>? mapping<=? mapping>=?
          mapping-union mapping-intersection mapping-difference mapping-xor
          mapping-union! mapping-intersection! mapping-difference! mapping-xor!
          make-mapping-comparator
          mapping-comparator
          mapping-min-key mapping-max-key
          mapping-min-value mapping-max-value
          mapping-key-predecessor mapping-key-successor
          mapping-range= mapping-range< mapping-range> mapping-range<= mapping-range>=
          mapping-range=! mapping-range<! mapping-range>! mapping-range<=! mapping-range>=!
          mapping-split
          mapping-catenate mapping-catenate!
          mapping-map/monotone mapping-map/monotone!
          mapping-fold/reverse
          comparator?)
  (import (scheme base)
          (scheme case-lambda)
          (srfi 1)
          (srfi 2)
          (srfi 8)
          (srfi 121)
          (srfi 128)
          (srfi 145))
  (include "146/rbtree.scm"
           "146/mapping.scm"))

(define-library (srfi 116)
  (export
   ;; Syntax
   iq

   ;; Constructors
   ipair ilist
   xipair ipair* make-ilist ilist-tabulate  
   ilist-copy iiota

   ;; Predicates
   ipair? proper-ilist? ilist? dotted-ilist? 
   not-ipair? null-ilist?
   ilist=

   ;; Selectors
   icar icdr icaar icadr icdar icddr
   icaaaar icaaadr icaadar icaaddr
   icadaar icadadr icaddar icadddr
   icdaaar icdaadr icdadar icdaddr
   icddaar icddadr icdddar icddddr
   icaaar icaadr icadar icaddr
   icdaar icdadr icddar icdddr
   ilist-ref
   ifirst isecond ithird ifourth ififth isixth iseventh ieighth ininth itenth
   icar+icdr
   itake       idrop ilist-tail
   itake-right idrop-right
   isplit-at   
   ilast last-ipair

   ;; Miscellaneous: length, append, concatenate, reverse, zip & count
   ilength 
   iappend  iconcatenate  ireverse  iappend-reverse
   izip iunzip1 iunzip2 iunzip3 iunzip4 iunzip5
   icount

   ;; Fold, unfold & map
   imap        ifor-each
   ifold       iunfold        ipair-fold       ireduce 
   ifold-right iunfold-right  ipair-fold-right ireduce-right 
   iappend-map ipair-for-each ifilter-map      imap-in-order

   ;; Filtering & partitioning
   ifilter  ipartition  iremove

   ;; Searching
   imember imemq imemv
   ifind         ifind-tail 
   iany ievery
   ilist-index
   itake-while   idrop-while
   ispan ibreak

   ;; Deleting
   idelete       idelete-duplicates 

   ;; Immutable association lists
   iassoc iassq iassv
   ialist-cons  ialist-delete

   ;; Replacement
   replace-icar replace-icdr

   ;; Conversion
   pair->ipair  ipair->pair
   list->ilist  ilist->list
   tree->itree  itree->tree
   gtree->itree gtree->tree

   ;; Procedure application
   iapply

   ;; Comparators
   ipair-comparator        ilist-comparator
   make-ilist-comparator   make-improper-ilist-comparator
   make-icar-comparator    make-icdr-comparator)

  (import (scheme base)
          (rename (prefix (srfi 1 immutable) i)
                  (imake-list make-ilist)
                  (icar+cdr icar+icdr)
                  (ilast-pair last-ipair)
                  (icons ipair)
                  (ixcons xipair)
                  (icons* ipair*)
                  (inull-list? null-ilist?)
                  (idotted-list? dotted-ilist?)
                  (iproper-list? proper-ilist?))
          (rename (srfi 128)
                  (make-pair-comparator make-ipair-comparator)
                  (make-list-comparator make-ilist-comparator)))

  (begin
    (define-syntax iq
      (syntax-rules ()
        ((iq x ...)
         (ilist 'x ...))))
    (define (pair->ipair x)
      (ipair (car x) (cdr x)))
    (define (ipair->pair x)
      (cons (car x) (cdr x)))
    (define (not-ipair? x)
      (not (ipair? x)))
    (define (replace-icar x obj)
      (ipair obj (cdr x)))
    (define (replace-icdr x obj)
      (ipair (car x) obj))
    (define ilist-tail idrop)
    (define list->ilist ilist-copy)
    (define ilist->list list-copy)
    (define (tree->itree x)
      (if (pair? x)
          (ipair (tree->itree (car x)) (tree->itree (cdr x)))
          x))
    (define (itree->tree x)
      (if (ipair? x)
          (cons (itree->tree (car x)) (itree->tree (cdr x)))
          x))
    (define gtree->itree tree->itree)
    (define gtree->tree itree->tree)

    (define ipair-comparator (make-default-comparator))
    (define ilist-comparator (make-default-comparator))
    (define make-improper-ilist-comparator make-ilist-comparator)
    (define (make-field-comparator comparator pred field)
      (make-comparator
       (lambda (x)
         (and (pred x)
              ((comparator-type-test-predicate comparator) (field x))))
       (lambda (x y)
         ((comparator-equality-predicate comparator) (field x) (field y)))
       (lambda (x y)
         ((comparator-ordering-predicate comparator) (field x) (field y)))
       (lambda (x)
         ((comparator-hash-function comparator) (field x)))))
    (define (make-icar-comparator comparator)
      (make-field-comparator comparator ipair? icar))
    (define (make-icdr-comparator comparator)
      (make-field-comparator comparator ipair? icdr))
    ))
(define-library (srfi 211 identifier-syntax)
  (export identifier-syntax)
  (import (only (chibi ast) identifier-syntax)))

;; Local Variables:
;; mode: scheme
;; End:
(define-library (srfi 211 variable-transformer)
  (export make-variable-transformer)
  (import (only (chibi ast) make-variable-transformer)))

;; Local Variables:
;; mode: scheme
;; End:
(define-library (srfi 211 test)
  (export run-tests)
  (import (scheme base)
          (only (chibi) er-macro-transformer)
          (srfi 211 variable-transformer)
          (srfi 211 identifier-syntax)
          (chibi test))
  (begin
    (define (run-tests)
      (test-begin "srfi-211")

      (test '(1 2)
            (let-syntax
                ((foo (identifier-syntax (list 1 2))))
              foo))

      (test '(5 5)
            (let ((x 3))
              (let-syntax
                  ((foo (identifier-syntax
                         (_ x)
                         ((set! _ e) (set! x e)))))
                (set! foo (+ foo 2))
                (list foo x))))

      (test 42
            (let-syntax
                ((foo (make-variable-transformer
                       (er-macro-transformer
                        (lambda (e r c)
                          (list-ref e 2))))))
              (set! foo 42)))

      (test-end))))

;; Local Variables:
;; mode: scheme
;; End:

(define-library (srfi 6)
  (export open-input-string open-output-string get-output-string)
  (import (chibi)))
(define-library (srfi 130)
  (export
   ;; Cursor operations
   string-cursor?
   string-cursor-start    string-cursor-end
   string-cursor-next     string-cursor-prev
   string-cursor-forward  string-cursor-back
   string-cursor=?
   string-cursor<?        string-cursor>?
   string-cursor<=?       string-cursor>=?
   string-cursor-diff
   string-cursor->index   string-index->cursor
   ;; Predicates
   string-null? string-every string-any
   ;; Constructors
   string-tabulate string-unfold string-unfold-right
   ;; Conversion
   string->list/cursors string->vector/cursors
   reverse-list->string string-join
   ;; Selection
   string-ref/cursor
   substring/cursors  string-copy/cursors
   string-take        string-take-right
   string-drop        string-drop-right
   string-pad         string-pad-right 
   string-trim        string-trim-right string-trim-both
   ;; Prefixes & suffixes
   string-prefix-length    string-suffix-length
   string-prefix?          string-suffix?    
   ;; Searching
   string-index string-index-right
   string-skip  string-skip-right
   string-contains string-contains-right
   ;; The whole string
   string-reverse
   string-concatenate  string-concatenate-reverse
   string-fold         string-fold-right
   string-for-each-cursor
   string-replicate    string-count
   string-replace      string-split
   string-filter       string-remove)
  (import (scheme base)
          (scheme char) (scheme write)
          (rename (chibi string)
                  (string-index->cursor %string-index->cursor)
                  (string-cursor->index %string-cursor->index)
                  (string-cursor-next %string-cursor-next)
                  (string-cursor-prev %string-cursor-prev)
                  (string-fold %string-fold)
                  (string-fold-right %string-fold-right)
                  (string-contains %string-contains)
                  (string-join %string-join)
                  (string-prefix? %string-prefix?)
                  (string-suffix? %string-suffix?)))
  (begin
    (define (string-cursor-next str cursor)
      (if (string-cursor? cursor)
          (%string-cursor-next str cursor)
          (+ cursor 1)))
    (define (string-cursor-prev str cursor)
      (if (string-cursor? cursor)
          (%string-cursor-prev str cursor)
          (- cursor 1)))
    (define (string-index->cursor str i)
      (if (string-cursor? i)
          i
          (%string-index->cursor str i)))
    (define (string-cursor->index str cursor)
      (if (string-cursor? cursor)
          (%string-cursor->index str cursor)
          cursor)))
  (include "130.scm"))
(define-library (srfi 133)
  (import (scheme base))
  (export
   ;; Constructors
   make-vector vector 
   vector-unfold vector-unfold-right 
   vector-copy vector-reverse-copy 
   vector-append vector-concatenate vector-append-subvectors 
   ;; Predicates 
   vector? 
   vector-empty? 
   vector= 
   ;; Selectors 
   vector-ref 
   vector-length 
   ;; Iteration 
   vector-fold vector-fold-right 
   vector-map vector-map! 
   vector-for-each vector-count 
   vector-cumulate 
   ;; Searching 
   vector-index vector-index-right 
   vector-skip vector-skip-right 
   vector-binary-search 
   vector-any vector-every 
   vector-partition 
   ;; Mutators 
   vector-set! vector-swap! 
   vector-fill! vector-reverse! 
   vector-copy! vector-reverse-copy! 
   vector-unfold! vector-unfold-right! 
   ;; Conversion 
   vector->list reverse-vector->list 
   list->vector reverse-list->vector 
   vector->string string->vector)
  (include "133/vector.scm"))
