; ModuleID = 'code'
source_filename = "code"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%"[]u8" = type { i8*, i64 }
%std.builtin.StackTrace = type { i64, %"[]usize" }
%"[]usize" = type { i64*, i64 }
%std.target.LinuxVersionRange = type { %std.builtin.Range, %std.builtin.Version }
%std.builtin.Range = type { %std.builtin.Version, %std.builtin.Version }
%std.builtin.Version = type { i32, i32, i32 }
%std.target.Set = type { [5 x i64] }
%"[]std.target.x86.Feature" = type { i8*, i64 }
%std.target.Model = type { %"[]u8", %"?[:0]const u8", %std.target.Set }
%"?[:0]const u8" = type { %"[]u8", i1 }
%std.Thread.Mutex = type { %std.Thread.Mutex.AtomicMutex }
%std.Thread.Mutex.AtomicMutex = type { i32 }
%std.elf.Elf64_auxv_t = type { i64, %"std.elf.union:790:11" }
%"std.elf.union:790:11" = type { i64 }
%std.os.linux.tls.TLSImage = type { %"[]u8", i64, i64, i64, i64, i64, i64, i64 }
%"[][*:0]u8" = type { i8**, i64 }
%"?u64" = type { i64, i1 }
%std.event.loop.Loop = type { %"std.atomic.queue.Queue(anyframe)", %std.event.loop.LinuxOsData, %std.event.loop.ResumeNode, i64, %"[]std.Thread", %std.Thread, %"std.atomic.queue.Queue(std.event.loop.Request)", %std.linked_list.Node.0, %std.Thread.ResetEvent, %std.heap.arena_allocator.ArenaAllocator, %std.event.loop.DelayQueue, %"std.atomic.stack.Stack(std.event.loop.EventFd)", %"[]std.atomic.stack.Node" }
%"std.atomic.queue.Queue(anyframe)" = type { %std.linked_list.Node*, %std.linked_list.Node*, %std.Thread.Mutex }
%std.linked_list.Node = type { %std.linked_list.Node*, %std.linked_list.Node*, %"(anyframe header)"* }
%"(anyframe header)" = type { void (%"(anyframe header)"*, i64)*, i64, i64 }
%std.event.loop.LinuxOsData = type { i32, i32, %std.os.linux.epoll_event }
%std.os.linux.epoll_event = type <{ i32, %std.os.linux.epoll_data }>
%std.os.linux.epoll_data = type { i64 }
%std.event.loop.ResumeNode = type { i2, %"(anyframe header)"* }
%"[]std.Thread" = type { %std.Thread*, i64 }
%std.Thread = type { %std.Thread.LinuxThreadImpl }
%std.Thread.LinuxThreadImpl = type { %std.Thread.ThreadCompletion* }
%std.Thread.ThreadCompletion = type { %"std.atomic.Atomic.Atomic(std.Thread.enum:337:27)", %"std.atomic.Atomic.Atomic(i32)", i32, %"[]u8" }
%"std.atomic.Atomic.Atomic(std.Thread.enum:337:27)" = type { i8 }
%"std.atomic.Atomic.Atomic(i32)" = type { i32 }
%"std.atomic.queue.Queue(std.event.loop.Request)" = type { %std.linked_list.Node.0*, %std.linked_list.Node.0*, %std.Thread.Mutex }
%std.linked_list.Node.0 = type { %std.linked_list.Node.0*, %std.linked_list.Node.0*, %std.event.loop.Request }
%std.event.loop.Request = type { %std.event.loop.Msg, %std.event.loop.Finish }
%std.event.loop.Msg = type { { %std.event.loop.Read, [8 x i8] }, i4 }
%std.event.loop.Read = type { i32, %"[]u8", { i64, i16 } }
%std.event.loop.Finish = type { %std.linked_list.Node, i1 }
%std.Thread.ResetEvent = type { %std.Thread.StaticResetEvent.AtomicEvent }
%std.Thread.StaticResetEvent.AtomicEvent = type { i32 }
%std.heap.arena_allocator.ArenaAllocator = type { %std.mem.Allocator, %std.heap.arena_allocator.State }
%std.mem.Allocator = type { i8*, %std.mem.Allocator.VTable* }
%std.mem.Allocator.VTable = type { void ({ %"[]u8", i16 }*, i8*, i64, i29, i29, i64)*, void (%"?usize"*, i8*, %"[]u8"*, i29, i64, i29, i64)*, void (i8*, %"[]u8"*, i29, i64)* }
%"?usize" = type { i64, i1 }
%std.heap.arena_allocator.State = type { %"std.linked_list.SinglyLinkedList([]u8)", i64 }
%"std.linked_list.SinglyLinkedList([]u8)" = type { %std.linked_list.Node.1* }
%std.linked_list.Node.1 = type { %std.linked_list.Node.1*, %"[]u8" }
%std.event.loop.DelayQueue = type { %std.time.Timer, %std.event.loop.Waiters, %std.Thread, %std.Thread.AutoResetEvent, i1 }
%std.time.Timer = type { i64, i64 }
%std.event.loop.Waiters = type { %"std.atomic.queue.Queue(anyframe)" }
%std.Thread.AutoResetEvent = type { i64 }
%"std.atomic.stack.Stack(std.event.loop.EventFd)" = type { %std.atomic.stack.Node*, i1 }
%std.atomic.stack.Node = type { %std.atomic.stack.Node*, %std.event.loop.EventFd }
%std.event.loop.EventFd = type { %std.event.loop.ResumeNode, i32, i32 }
%"[]std.atomic.stack.Node" = type { %std.atomic.stack.Node*, i64 }
%std.Thread.StaticResetEvent = type { %std.Thread.StaticResetEvent.AtomicEvent }
%std.os.linux.rlimit = type { i64, i64 }
%std.fs.file.File = type { i32 }
%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)" = type { %std.fs.file.File }
%"std.debug.struct:295:56" = type { i64 }
%"std.debug.struct:297:40" = type { %"[]u8" }
%std.elf.Elf64_Phdr = type { i32, i32, i64, i64, i64, i64, i64, i64 }
%"[]std.elf.Elf64_Phdr" = type { %std.elf.Elf64_Phdr*, i64 }
%std.fmt.FormatOptions = type { %"?usize", %"?usize", i2, i8 }
%std.os.linux.tls.DTV = type { i64, [1 x i8*] }
%"?std.Thread.Mutex.State" = type { i32, i1 }
%std.os.linux.timespec = type { i64, i64 }
%"?u32" = type { i32, i1 }
%std.target.Target = type { %std.target.Cpu, %std.target.Os, i5 }
%std.target.Cpu = type { i6, %std.target.Model*, %std.target.Set }
%std.target.Os = type { i6, %std.target.VersionRange }
%std.target.VersionRange = type { %std.builtin.Range, [12 x i8] }

@panic = internal unnamed_addr constant void (%"[]u8"*, %std.builtin.StackTrace*)* @std.builtin.default_panic, align 8
@zig_is_stage2 = internal unnamed_addr constant i1 false, align 1
@output_mode = internal unnamed_addr constant i2 0, align 1
@link_libc = internal unnamed_addr constant i1 false, align 1
@os = internal unnamed_addr constant { <{ i6, [3 x i8] }>, %std.target.LinuxVersionRange } { <{ i6, [3 x i8] }> <{ i6 8, [3 x i8] undef }>, %std.target.LinuxVersionRange { %std.builtin.Range { %std.builtin.Version { i32 5, i32 13, i32 0 }, %std.builtin.Version { i32 5, i32 13, i32 0 } }, %std.builtin.Version { i32 2, i32 19, i32 0 } } }, align 4
@native_os = internal unnamed_addr constant i6 8, align 1
@featureSet = internal unnamed_addr constant void (%std.target.Set*, %"[]std.target.x86.Feature"*)* @"std.target.Feature.feature_set_fns(std.target.x86.Feature).featureSet", align 8
@0 = internal unnamed_addr constant [8 x i8] c"skylake\00", align 1
@skylake = internal unnamed_addr constant { %"[]u8", { %"[]u8", i1, [7 x i8] }, %std.target.Set } { %"[]u8" { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @0, i64 0, i64 0), i64 7 }, { %"[]u8", i1, [7 x i8] } { %"[]u8" { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @0, i64 0, i64 0), i64 7 }, i1 true, [7 x i8] undef }, %std.target.Set { [5 x i64] [i64 6190362172988590192, i64 8936892283916, i64 14608, i64 0, i64 0] } }, align 8
@cpu = internal unnamed_addr constant { <{ i6, [7 x i8] }>, %std.target.Model*, %std.target.Set } { <{ i6, [7 x i8] }> <{ i6 -30, [7 x i8] undef }>, %std.target.Model* bitcast ({ %"[]u8", { %"[]u8", i1, [7 x i8] }, %std.target.Set }* @skylake to %std.target.Model*), %std.target.Set { [5 x i64] [i64 6190362310427544688, i64 1432154786627206156, i64 15632, i64 0, i64 0] } }, align 8
@native_arch = internal unnamed_addr constant i6 -30, align 1
@1 = internal unnamed_addr constant [7 x i8] c"_start\00", align 1
@start_sym_name = internal unnamed_addr constant [7 x i8]* @1, align 8
@argc_argv_ptr = internal unnamed_addr global i64* undef, align 8
@mode = internal unnamed_addr constant i2 -1, align 1
@runtime_safety = internal unnamed_addr constant i1 false, align 1
@enable_segfault_handler = internal unnamed_addr constant i1 false, align 1
@panic_stage = internal thread_local unnamed_addr global i64 0, align 8
@panicking = internal unnamed_addr global i8 0, align 1
@single_threaded = internal unnamed_addr constant i1 false, align 1
@abi = internal unnamed_addr constant i5 1, align 1
@target = internal unnamed_addr constant { { <{ i6, [7 x i8] }>, %std.target.Model*, %std.target.Set }, { <{ i6, [3 x i8] }>, %std.target.LinuxVersionRange }, <{ i5, [7 x i8] }> } { { <{ i6, [7 x i8] }>, %std.target.Model*, %std.target.Set } { <{ i6, [7 x i8] }> <{ i6 -30, [7 x i8] undef }>, %std.target.Model* bitcast ({ %"[]u8", { %"[]u8", i1, [7 x i8] }, %std.target.Set }* @skylake to %std.target.Model*), %std.target.Set { [5 x i64] [i64 6190362310427544688, i64 1432154786627206156, i64 15632, i64 0, i64 0] } }, { <{ i6, [3 x i8] }>, %std.target.LinuxVersionRange } { <{ i6, [3 x i8] }> <{ i6 8, [3 x i8] undef }>, %std.target.LinuxVersionRange { %std.builtin.Range { %std.builtin.Version { i32 5, i32 13, i32 0 }, %std.builtin.Version { i32 5, i32 13, i32 0 } }, %std.builtin.Version { i32 2, i32 19, i32 0 } } }, <{ i5, [7 x i8] }> <{ i5 1, [7 x i8] undef }> }, align 8
@target.1 = internal unnamed_addr constant { { <{ i6, [7 x i8] }>, %std.target.Model*, %std.target.Set }, { <{ i6, [3 x i8] }>, %std.target.LinuxVersionRange }, <{ i5, [7 x i8] }> } { { <{ i6, [7 x i8] }>, %std.target.Model*, %std.target.Set } { <{ i6, [7 x i8] }> <{ i6 -30, [7 x i8] undef }>, %std.target.Model* bitcast ({ %"[]u8", { %"[]u8", i1, [7 x i8] }, %std.target.Set }* @skylake to %std.target.Model*), %std.target.Set { [5 x i64] [i64 6190362310427544688, i64 1432154786627206156, i64 15632, i64 0, i64 0] } }, { <{ i6, [3 x i8] }>, %std.target.LinuxVersionRange } { <{ i6, [3 x i8] }> <{ i6 8, [3 x i8] undef }>, %std.target.LinuxVersionRange { %std.builtin.Range { %std.builtin.Version { i32 5, i32 13, i32 0 }, %std.builtin.Version { i32 5, i32 13, i32 0 } }, %std.builtin.Version { i32 2, i32 19, i32 0 } } }, <{ i5, [7 x i8] }> <{ i5 1, [7 x i8] undef }> }, align 8
@use_pthreads = internal unnamed_addr constant i1 false, align 1
@panic_mutex = internal unnamed_addr global %std.Thread.Mutex zeroinitializer, align 4
@is_windows = internal unnamed_addr constant i1 false, align 1
@mode.2 = internal unnamed_addr constant i1 false, align 1
@is_async = internal unnamed_addr constant i1 false, align 1
@elf_aux_maybe = internal unnamed_addr global %std.elf.Elf64_auxv_t* null, align 8
@position_independent_executable = internal unnamed_addr constant i1 false, align 1
@is_windows.3 = internal unnamed_addr constant i1 false, align 1
@assert = internal unnamed_addr constant void (i1)* @std.debug.assert, align 8
@native_arch.4 = internal unnamed_addr constant i6 -30, align 1
@is_mips = internal unnamed_addr constant i1 false, align 1
@is_sparc = internal unnamed_addr constant i1 false, align 1
@strip_debug_info = internal unnamed_addr constant i1 true, align 1
@tls_image = internal unnamed_addr global %std.os.linux.tls.TLSImage undef, align 8
@main_thread_tls_buffer = internal unnamed_addr global [8448 x i8] undef, align 4096
@assert.5 = internal unnamed_addr constant void (i1)* @std.debug.assert, align 8
@argv = internal unnamed_addr global %"[][*:0]u8" undef, align 8
@environ = internal unnamed_addr global %"[][*:0]u8" undef, align 8
@errno = internal unnamed_addr constant i16 (i64)* @std.os.linux.getErrno, align 8
@tls_thread_id = internal thread_local unnamed_addr global %"?u64" { i64 undef, i1 false }, align 8
@2 = internal unnamed_addr constant [4 x i8] c"any\00", align 1
@ANY = internal unnamed_addr constant [4 x i8]* @2, align 8
@app_mask = internal unnamed_addr constant [32 x i32] [i32 -4, i32 2147483647, i32 -1, i32 -1, i32 -1, i32 -1, i32 -1, i32 -1, i32 -1, i32 -1, i32 -1, i32 -1, i32 -1, i32 -1, i32 -1, i32 -1, i32 -1, i32 -1, i32 -1, i32 -1, i32 -1, i32 -1, i32 -1, i32 -1, i32 -1, i32 -1, i32 -1, i32 -1, i32 -1, i32 -1, i32 -1, i32 -1], align 4
@native_arch.6 = internal unnamed_addr constant i6 -30, align 1
@tls_variant = internal unnamed_addr constant i1 true, align 1
@tls_tp_points_past_tcb = internal unnamed_addr constant i1 false, align 1
@syscall2 = internal unnamed_addr constant i64 (i64, i64, i64)* @std.os.linux.x86_64.syscall2, align 8
@assert.7 = internal unnamed_addr constant void (i1)* @std.debug.assert, align 8
@syscall1 = internal unnamed_addr constant i64 (i64, i64)* @std.os.linux.x86_64.syscall1, align 8
@lock_init = internal unnamed_addr constant i1 false, align 1
@default_instance = internal unnamed_addr constant %std.event.loop.Loop* null, align 8
@instance = internal unnamed_addr constant %std.event.loop.Loop* null, align 8
@syscall3 = internal unnamed_addr constant i64 (i64, i64, i64, i64)* @std.os.linux.x86_64.syscall3, align 8
@unexpected_error_tracing = internal unnamed_addr constant i1 false, align 1
@syscall0 = internal unnamed_addr constant i64 (i64)* @std.os.linux.x86_64.syscall0, align 8
@syscall4 = internal unnamed_addr constant i64 (i64, i64, i64, i64, i64)* @std.os.linux.x86_64.syscall4, align 8
@syscall6 = internal unnamed_addr constant i64 (i64, i64, i64, i64, i64, i64, i64)* @std.os.linux.x86_64.syscall6, align 8
@assert.8 = internal unnamed_addr constant void (i1)* @std.debug.assert, align 8
@target.9 = internal unnamed_addr constant { { <{ i6, [7 x i8] }>, %std.target.Model*, %std.target.Set }, { <{ i6, [3 x i8] }>, %std.target.LinuxVersionRange }, <{ i5, [7 x i8] }> } { { <{ i6, [7 x i8] }>, %std.target.Model*, %std.target.Set } { <{ i6, [7 x i8] }> <{ i6 -30, [7 x i8] undef }>, %std.target.Model* bitcast ({ %"[]u8", { %"[]u8", i1, [7 x i8] }, %std.target.Set }* @skylake to %std.target.Model*), %std.target.Set { [5 x i64] [i64 6190362310427544688, i64 1432154786627206156, i64 15632, i64 0, i64 0] } }, { <{ i6, [3 x i8] }>, %std.target.LinuxVersionRange } { <{ i6, [3 x i8] }> <{ i6 8, [3 x i8] undef }>, %std.target.LinuxVersionRange { %std.builtin.Range { %std.builtin.Version { i32 5, i32 13, i32 0 }, %std.builtin.Version { i32 5, i32 13, i32 0 } }, %std.builtin.Version { i32 2, i32 19, i32 0 } } }, <{ i5, [7 x i8] }> <{ i5 1, [7 x i8] undef }> }, align 8
@assert.10 = internal unnamed_addr constant void (i1)* @std.debug.assert, align 8
@assert.11 = internal unnamed_addr constant void (i1)* @std.debug.assert, align 8
@native_arch.12 = internal unnamed_addr constant i6 -30, align 1
@3 = internal unnamed_addr constant [5 x i64] zeroinitializer, align 8
@4 = internal unnamed_addr constant %std.Thread.StaticResetEvent zeroinitializer, align 4
@5 = internal unnamed_addr constant { %"?usize", %"?usize", i2, <{ i8, [6 x i8] }> } { %"?usize" { i64 undef, i1 false }, %"?usize" { i64 undef, i1 false }, i2 -2, <{ i8, [6 x i8] }> <{ i8 32, [6 x i8] undef }> }, align 8
@6 = internal unnamed_addr constant [18 x i8] c"thread {} panic: \00", align 1
@7 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([18 x i8], [18 x i8]* @6, i64 0, i64 0), i64 7 }, align 8
@8 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@9 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@10 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@11 = internal unnamed_addr constant %"[]u8" zeroinitializer, align 8
@12 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@13 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@14 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([18 x i8], [18 x i8]* @6, i64 0, i64 9), i64 8 }, align 8
@15 = internal unnamed_addr constant %"[]u8" zeroinitializer, align 8
@16 = internal unnamed_addr constant { %"?usize", %"?usize", i2, <{ i8, [6 x i8] }> } { %"?usize" { i64 undef, i1 false }, %"?usize" { i64 undef, i1 false }, i2 -2, <{ i8, [6 x i8] }> <{ i8 32, [6 x i8] undef }> }, align 8
@17 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@18 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@19 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@20 = internal unnamed_addr constant [5 x i8] c"{s}\0A\00", align 1
@21 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @20, i64 0, i64 1), i64 1 }, align 8
@22 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@23 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@24 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @20, i64 0, i64 3), i64 1 }, align 8
@25 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @20, i64 0, i64 1), i64 1 }, align 8
@26 = internal unnamed_addr constant [8 x i8] c"{ ... }\00", align 1
@27 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @26, i64 0, i64 0), i64 7 }, align 8
@28 = internal unnamed_addr constant %"?u64" { i64 undef, i1 false }, align 8
@29 = internal unnamed_addr constant { %"?usize", %"?usize", i2, <{ i8, [6 x i8] }> } { %"?usize" { i64 undef, i1 false }, %"?usize" { i64 undef, i1 false }, i2 -2, <{ i8, [6 x i8] }> <{ i8 32, [6 x i8] undef }> }, align 8
@30 = internal unnamed_addr constant [36 x i8] c"Panicked during a panic. Aborting.\0A\00", align 1
@31 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([36 x i8], [36 x i8]* @30, i64 0, i64 0), i64 35 }, align 8
@32 = internal unnamed_addr constant %"[]u8" zeroinitializer, align 8
@33 = internal unnamed_addr constant i64 (i8*, i64, i64, i32, i32, i64)* @std.os.linux.mmap, align 8
@34 = internal unnamed_addr constant i64 (i32, %std.os.linux.rlimit*)* @std.os.linux.setrlimit, align 8
@35 = internal unnamed_addr constant { %"?usize", %"?usize", i2, <{ i8, [6 x i8] }> } { %"?usize" { i64 undef, i1 false }, %"?usize" { i64 undef, i1 false }, i2 -2, <{ i8, [6 x i8] }> <{ i8 32, [6 x i8] undef }> }, align 8
@36 = internal unnamed_addr constant [49 x i8] c"Unable to dump stack trace: debug info stripped\0A\00", align 1
@37 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([49 x i8], [49 x i8]* @36, i64 0, i64 0), i64 48 }, align 8
@38 = internal unnamed_addr constant { %"?usize", %"?usize", i2, <{ i8, [6 x i8] }> } { %"?usize" { i64 undef, i1 false }, %"?usize" { i64 undef, i1 false }, i2 -2, <{ i8, [6 x i8] }> <{ i8 32, [6 x i8] undef }> }, align 8
@39 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([49 x i8], [49 x i8]* @36, i64 0, i64 0), i64 48 }, align 8
@40 = internal unnamed_addr constant { i32, i1, [3 x i8] } { i32 6, i1 true, [3 x i8] undef }, align 4

; Function Attrs: cold minsize nobuiltin noreturn nounwind optsize
define internal fastcc void @std.builtin.default_panic(%"[]u8"* nonnull readonly align 8 %0, %std.builtin.StackTrace* align 8 %1) unnamed_addr #0 {
Entry:
  %first_trace_addr = alloca i64, align 8
  %2 = alloca %"?usize", align 8
  %3 = alloca %"?usize", align 8
  %error_return_trace = alloca %std.builtin.StackTrace*, align 8
  store %std.builtin.StackTrace* %1, %std.builtin.StackTrace** %error_return_trace, align 8
  %4 = call i8* @llvm.returnaddress(i32 0)
  %5 = ptrtoint i8* %4 to i64
  store i64 %5, i64* %first_trace_addr, align 8
  %6 = load %std.builtin.StackTrace*, %std.builtin.StackTrace** %error_return_trace, align 8
  %7 = load i64, i64* %first_trace_addr, align 8
  %8 = getelementptr inbounds %"?usize", %"?usize"* %2, i32 0, i32 0
  store i64 %7, i64* %8, align 8
  %9 = getelementptr inbounds %"?usize", %"?usize"* %2, i32 0, i32 1
  store i1 true, i1* %9, align 1
  %10 = getelementptr inbounds %"?usize", %"?usize"* %3, i32 0, i32 0
  store i64 %7, i64* %10, align 8
  %11 = getelementptr inbounds %"?usize", %"?usize"* %3, i32 0, i32 1
  store i1 true, i1* %11, align 1
  call fastcc void @std.debug.panicImpl(%std.builtin.StackTrace* %6, %"?usize"* %3, %"[]u8"* %0)
  unreachable
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @"std.target.Feature.feature_set_fns(std.target.x86.Feature).featureSet"(%std.target.Set* nonnull sret(%std.target.Set) %0, %"[]std.target.x86.Feature"* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %x = alloca %std.target.Set, align 8
  %i = alloca i64, align 8
  %feature = alloca i8, align 1
  call fastcc void @std.target.Set.empty_workaround(%std.target.Set* sret(%std.target.Set) %x)
  store i64 0, i64* %i, align 8
  %2 = getelementptr inbounds %"[]std.target.x86.Feature", %"[]std.target.x86.Feature"* %1, i32 0, i32 1
  %3 = load i64, i64* %2, align 8
  br label %ForCond

ForCond:                                          ; preds = %ForBody, %Entry
  %4 = load i64, i64* %i, align 8
  %5 = icmp ult i64 %4, %3
  br i1 %5, label %ForBody, label %ForEnd

ForBody:                                          ; preds = %ForCond
  %6 = getelementptr inbounds %"[]std.target.x86.Feature", %"[]std.target.x86.Feature"* %1, i32 0, i32 0
  %7 = load i8*, i8** %6, align 8
  %8 = getelementptr inbounds i8, i8* %7, i64 %4
  %9 = load i8, i8* %8, align 1
  store i8 %9, i8* %feature, align 1
  %10 = load i8, i8* %feature, align 1
  %11 = zext i8 %10 to i9
  call fastcc void @std.target.Set.addFeature(%std.target.Set* %x, i9 %11)
  %12 = add nuw i64 %4, 1
  store i64 %12, i64* %i, align 8
  br label %ForCond

ForEnd:                                           ; preds = %ForCond
  %13 = bitcast %std.target.Set* %x to i8*
  %14 = bitcast %std.target.Set* %0 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %14, i8* align 8 %13, i64 40, i1 false)
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.debug.assert(i1 %0) unnamed_addr #1 {
Entry:
  %ok = alloca i1, align 1
  store i1 %0, i1* %ok, align 1
  %1 = load i1, i1* %ok, align 1
  %2 = icmp eq i1 %1, false
  br i1 %2, label %Then, label %Else

Then:                                             ; preds = %Entry
  unreachable

Else:                                             ; preds = %Entry
  br label %EndIf

EndIf:                                            ; preds = %Else
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.os.linux.getErrno(i64 %0) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %signed_r = alloca i64, align 8
  %int = alloca i64, align 8
  %r = alloca i64, align 8
  store i64 %0, i64* %r, align 8
  %1 = load i64, i64* %r, align 8
  store i64 %1, i64* %signed_r, align 8
  %2 = load i64, i64* %signed_r, align 8
  %3 = sext i64 %2 to i65
  %4 = icmp sgt i65 %3, -4096
  br i1 %4, label %BoolAndTrue, label %BoolAndFalse

BoolAndTrue:                                      ; preds = %Entry
  %5 = load i64, i64* %signed_r, align 8
  %6 = icmp slt i64 %5, 0
  br label %BoolAndFalse

BoolAndFalse:                                     ; preds = %BoolAndTrue, %Entry
  %7 = phi i1 [ %4, %Entry ], [ %6, %BoolAndTrue ]
  br i1 %7, label %Then, label %Else

Then:                                             ; preds = %BoolAndFalse
  %8 = load i64, i64* %signed_r, align 8
  %9 = sub nsw i64 0, %8
  store i64 %9, i64* %int, align 8
  br label %EndIf

Else:                                             ; preds = %BoolAndFalse
  store i64 0, i64* %int, align 8
  br label %EndIf

EndIf:                                            ; preds = %Else, %Then
  %10 = load i64, i64* %int, align 8
  %11 = trunc i64 %10 to i16
  store i16 %11, i16* %result, align 2
  %12 = load i16, i16* %result, align 2
  ret i16 %12
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i64 @std.os.linux.x86_64.syscall2(i64 %0, i64 %1, i64 %2) unnamed_addr #1 {
Entry:
  %result = alloca i64, align 8
  %number = alloca i64, align 8
  %arg1 = alloca i64, align 8
  %arg2 = alloca i64, align 8
  store i64 %0, i64* %number, align 8
  store i64 %1, i64* %arg1, align 8
  store i64 %2, i64* %arg2, align 8
  %3 = load i64, i64* %number, align 8
  %4 = load i64, i64* %arg1, align 8
  %5 = load i64, i64* %arg2, align 8
  %6 = call i64 asm sideeffect "syscall", "={rax},{rax},{rdi},{rsi},~{rcx},~{r11},~{memory},~{dirflag},~{fpsr},~{flags}"(i64 %3, i64 %4, i64 %5)
  store i64 %6, i64* %result, align 8
  %7 = load i64, i64* %result, align 8
  ret i64 %7
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i64 @std.os.linux.x86_64.syscall1(i64 %0, i64 %1) unnamed_addr #1 {
Entry:
  %result = alloca i64, align 8
  %number = alloca i64, align 8
  %arg1 = alloca i64, align 8
  store i64 %0, i64* %number, align 8
  store i64 %1, i64* %arg1, align 8
  %2 = load i64, i64* %number, align 8
  %3 = load i64, i64* %arg1, align 8
  %4 = call i64 asm sideeffect "syscall", "={rax},{rax},{rdi},~{rcx},~{r11},~{memory},~{dirflag},~{fpsr},~{flags}"(i64 %2, i64 %3)
  store i64 %4, i64* %result, align 8
  %5 = load i64, i64* %result, align 8
  ret i64 %5
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i64 @std.os.linux.x86_64.syscall3(i64 %0, i64 %1, i64 %2, i64 %3) unnamed_addr #1 {
Entry:
  %result = alloca i64, align 8
  %number = alloca i64, align 8
  %arg1 = alloca i64, align 8
  %arg2 = alloca i64, align 8
  %arg3 = alloca i64, align 8
  store i64 %0, i64* %number, align 8
  store i64 %1, i64* %arg1, align 8
  store i64 %2, i64* %arg2, align 8
  store i64 %3, i64* %arg3, align 8
  %4 = load i64, i64* %number, align 8
  %5 = load i64, i64* %arg1, align 8
  %6 = load i64, i64* %arg2, align 8
  %7 = load i64, i64* %arg3, align 8
  %8 = call i64 asm sideeffect "syscall", "={rax},{rax},{rdi},{rsi},{rdx},~{rcx},~{r11},~{memory},~{dirflag},~{fpsr},~{flags}"(i64 %4, i64 %5, i64 %6, i64 %7)
  store i64 %8, i64* %result, align 8
  %9 = load i64, i64* %result, align 8
  ret i64 %9
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i64 @std.os.linux.x86_64.syscall0(i64 %0) unnamed_addr #1 {
Entry:
  %result = alloca i64, align 8
  %number = alloca i64, align 8
  store i64 %0, i64* %number, align 8
  %1 = load i64, i64* %number, align 8
  %2 = call i64 asm sideeffect "syscall", "={rax},{rax},~{rcx},~{r11},~{memory},~{dirflag},~{fpsr},~{flags}"(i64 %1)
  store i64 %2, i64* %result, align 8
  %3 = load i64, i64* %result, align 8
  ret i64 %3
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i64 @std.os.linux.x86_64.syscall4(i64 %0, i64 %1, i64 %2, i64 %3, i64 %4) unnamed_addr #1 {
Entry:
  %result = alloca i64, align 8
  %number = alloca i64, align 8
  %arg1 = alloca i64, align 8
  %arg2 = alloca i64, align 8
  %arg3 = alloca i64, align 8
  %arg4 = alloca i64, align 8
  store i64 %0, i64* %number, align 8
  store i64 %1, i64* %arg1, align 8
  store i64 %2, i64* %arg2, align 8
  store i64 %3, i64* %arg3, align 8
  store i64 %4, i64* %arg4, align 8
  %5 = load i64, i64* %number, align 8
  %6 = load i64, i64* %arg1, align 8
  %7 = load i64, i64* %arg2, align 8
  %8 = load i64, i64* %arg3, align 8
  %9 = load i64, i64* %arg4, align 8
  %10 = call i64 asm sideeffect "syscall", "={rax},{rax},{rdi},{rsi},{rdx},{r10},~{rcx},~{r11},~{memory},~{dirflag},~{fpsr},~{flags}"(i64 %5, i64 %6, i64 %7, i64 %8, i64 %9)
  store i64 %10, i64* %result, align 8
  %11 = load i64, i64* %result, align 8
  ret i64 %11
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i64 @std.os.linux.x86_64.syscall6(i64 %0, i64 %1, i64 %2, i64 %3, i64 %4, i64 %5, i64 %6) unnamed_addr #1 {
Entry:
  %result = alloca i64, align 8
  %number = alloca i64, align 8
  %arg1 = alloca i64, align 8
  %arg2 = alloca i64, align 8
  %arg3 = alloca i64, align 8
  %arg4 = alloca i64, align 8
  %arg5 = alloca i64, align 8
  %arg6 = alloca i64, align 8
  store i64 %0, i64* %number, align 8
  store i64 %1, i64* %arg1, align 8
  store i64 %2, i64* %arg2, align 8
  store i64 %3, i64* %arg3, align 8
  store i64 %4, i64* %arg4, align 8
  store i64 %5, i64* %arg5, align 8
  store i64 %6, i64* %arg6, align 8
  %7 = load i64, i64* %number, align 8
  %8 = load i64, i64* %arg1, align 8
  %9 = load i64, i64* %arg2, align 8
  %10 = load i64, i64* %arg3, align 8
  %11 = load i64, i64* %arg4, align 8
  %12 = load i64, i64* %arg5, align 8
  %13 = load i64, i64* %arg6, align 8
  %14 = call i64 asm sideeffect "syscall", "={rax},{rax},{rdi},{rsi},{rdx},{r10},{r8},{r9},~{rcx},~{r11},~{memory},~{dirflag},~{fpsr},~{flags}"(i64 %7, i64 %8, i64 %9, i64 %10, i64 %11, i64 %12, i64 %13)
  store i64 %14, i64* %result, align 8
  %15 = load i64, i64* %result, align 8
  ret i64 %15
}

; Function Attrs: nofree nosync nounwind readnone willreturn
declare i8* @llvm.returnaddress(i32 immarg %0) #2

; Function Attrs: cold minsize nobuiltin noreturn nounwind optsize
define internal fastcc void @std.debug.panicImpl(%std.builtin.StackTrace* align 8 %0, %"?usize"* nonnull readonly align 8 %1, %"[]u8"* nonnull readonly align 8 %2) unnamed_addr #0 {
Entry:
  %3 = alloca %std.fs.file.File, align 4
  %stderr = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %current_thread_id = alloca i64, align 8
  %4 = alloca %"std.debug.struct:295:56", align 8
  %5 = alloca i16, align 2
  %6 = alloca %"std.debug.struct:297:40", align 8
  %7 = alloca i16, align 2
  %t = alloca %std.builtin.StackTrace*, align 8
  %event = alloca %std.Thread.StaticResetEvent, align 4
  %8 = alloca %std.fs.file.File, align 4
  %stderr8 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %9 = alloca i16, align 2
  %trace = alloca %std.builtin.StackTrace*, align 8
  store %std.builtin.StackTrace* %0, %std.builtin.StackTrace** %trace, align 8
  %10 = load i64, i64* @panic_stage, align 8
  switch i64 %10, label %SwitchElse [
    i64 0, label %SwitchProng
    i64 1, label %SwitchProng4
  ]

SwitchProng:                                      ; preds = %Entry
  store i64 1, i64* @panic_stage, align 8
  %11 = atomicrmw add i8* @panicking, i8 1 seq_cst, align 1
  call fastcc void @std.Thread.Mutex.lock(%std.Thread.Mutex* @panic_mutex)
  call fastcc void @std.io.getStdErr(%std.fs.file.File* sret(%std.fs.file.File) %3)
  call fastcc void @std.fs.file.File.writer(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* sret(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)") %stderr, %std.fs.file.File* %3)
  %12 = call fastcc i64 @std.Thread.getCurrentId()
  store i64 %12, i64* %current_thread_id, align 8
  %13 = load i64, i64* %current_thread_id, align 8
  %14 = getelementptr inbounds %"std.debug.struct:295:56", %"std.debug.struct:295:56"* %4, i32 0, i32 0
  store i64 %13, i64* %14, align 8
  %15 = call fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).print"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %stderr, %"std.debug.struct:295:56"* %4)
  store i16 %15, i16* %5, align 2
  %16 = icmp ne i16 %15, 0
  br i1 %16, label %UnwrapErrError, label %UnwrapErrOk

UnwrapErrError:                                   ; preds = %SwitchProng
  call fastcc void @std.os.abort()
  unreachable

UnwrapErrOk:                                      ; preds = %SwitchProng
  br label %UnwrapErrEnd

UnwrapErrEnd:                                     ; preds = %UnwrapErrOk
  %17 = getelementptr inbounds %"std.debug.struct:297:40", %"std.debug.struct:297:40"* %6, i32 0, i32 0
  %18 = bitcast %"[]u8"* %2 to i8*
  %19 = bitcast %"[]u8"* %17 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %19, i8* align 8 %18, i64 16, i1 false)
  %20 = call fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).print.13"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %stderr, %"std.debug.struct:297:40"* %6)
  store i16 %20, i16* %7, align 2
  %21 = icmp ne i16 %20, 0
  br i1 %21, label %UnwrapErrError1, label %UnwrapErrOk2

UnwrapErrError1:                                  ; preds = %UnwrapErrEnd
  call fastcc void @std.os.abort()
  unreachable

UnwrapErrOk2:                                     ; preds = %UnwrapErrEnd
  br label %UnwrapErrEnd3

UnwrapErrEnd3:                                    ; preds = %UnwrapErrOk2
  %22 = load %std.builtin.StackTrace*, %std.builtin.StackTrace** %trace, align 8
  %23 = icmp ne %std.builtin.StackTrace* %22, null
  br i1 %23, label %OptionalThen, label %OptionalElse

OptionalThen:                                     ; preds = %UnwrapErrEnd3
  %24 = load %std.builtin.StackTrace*, %std.builtin.StackTrace** %trace, align 8
  store %std.builtin.StackTrace* %24, %std.builtin.StackTrace** %t, align 8
  %25 = load %std.builtin.StackTrace*, %std.builtin.StackTrace** %t, align 8
  call fastcc void @std.debug.dumpStackTrace(%std.builtin.StackTrace* %25)
  br label %OptionalEndIf

OptionalElse:                                     ; preds = %UnwrapErrEnd3
  br label %OptionalEndIf

OptionalEndIf:                                    ; preds = %OptionalElse, %OptionalThen
  call fastcc void @std.debug.dumpCurrentStackTrace(%"?usize"* %1)
  call fastcc void @std.Thread.Mutex.unlock(%std.Thread.Mutex* @panic_mutex)
  %26 = atomicrmw sub i8* @panicking, i8 1 seq_cst, align 1
  %27 = icmp ne i8 %26, 1
  br i1 %27, label %Then, label %Else

Then:                                             ; preds = %OptionalEndIf
  %28 = bitcast %std.Thread.StaticResetEvent* %event to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %28, i8* align 4 bitcast (%std.Thread.StaticResetEvent* @4 to i8*), i64 4, i1 false)
  call fastcc void @std.Thread.StaticResetEvent.wait(%std.Thread.StaticResetEvent* %event)
  unreachable

Else:                                             ; preds = %OptionalEndIf
  br label %EndIf

SwitchProng4:                                     ; preds = %Entry
  store i64 2, i64* @panic_stage, align 8
  call fastcc void @std.io.getStdErr(%std.fs.file.File* sret(%std.fs.file.File) %8)
  call fastcc void @std.fs.file.File.writer(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* sret(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)") %stderr8, %std.fs.file.File* %8)
  %29 = call fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).print.14"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %stderr8)
  store i16 %29, i16* %9, align 2
  %30 = icmp ne i16 %29, 0
  br i1 %30, label %UnwrapErrError5, label %UnwrapErrOk6

UnwrapErrError5:                                  ; preds = %SwitchProng4
  call fastcc void @std.os.abort()
  unreachable

UnwrapErrOk6:                                     ; preds = %SwitchProng4
  br label %UnwrapErrEnd7

SwitchElse:                                       ; preds = %Entry
  br label %SwitchEnd

EndIf:                                            ; preds = %Else
  br label %SwitchEnd

UnwrapErrEnd7:                                    ; preds = %UnwrapErrOk6
  br label %SwitchEnd

SwitchEnd:                                        ; preds = %UnwrapErrEnd7, %EndIf, %SwitchElse
  call fastcc void @std.os.abort()
  unreachable
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.target.Set.empty_workaround(%std.target.Set* nonnull sret(%std.target.Set) %0) unnamed_addr #1 {
Entry:
  %1 = getelementptr inbounds %std.target.Set, %std.target.Set* %0, i32 0, i32 0
  %2 = bitcast [5 x i64]* %1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %2, i8* align 8 bitcast ([5 x i64]* @3 to i8*), i64 40, i1 false)
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.target.Set.addFeature(%std.target.Set* nonnull align 8 %0, i9 %1) unnamed_addr #1 {
Entry:
  %usize_index = alloca i9, align 2
  %bit_index = alloca i6, align 1
  %set = alloca %std.target.Set*, align 8
  %arch_feature_index = alloca i9, align 2
  store %std.target.Set* %0, %std.target.Set** %set, align 8
  store i9 %1, i9* %arch_feature_index, align 2
  %2 = load i9, i9* %arch_feature_index, align 2
  %3 = udiv i9 %2, 64
  store i9 %3, i9* %usize_index, align 2
  %4 = load i9, i9* %arch_feature_index, align 2
  %5 = urem i9 %4, 64
  %6 = trunc i9 %5 to i6
  store i6 %6, i6* %bit_index, align 1
  %7 = load %std.target.Set*, %std.target.Set** %set, align 8
  %8 = getelementptr inbounds %std.target.Set, %std.target.Set* %7, i32 0, i32 0
  %9 = load i9, i9* %usize_index, align 2
  %10 = zext i9 %9 to i64
  %11 = getelementptr inbounds [5 x i64], [5 x i64]* %8, i64 0, i64 %10
  %12 = load i64, i64* %11, align 8
  %13 = load i6, i6* %bit_index, align 1
  %14 = zext i6 %13 to i64
  %15 = shl i64 1, %14
  %16 = or i64 %12, %15
  store i64 %16, i64* %11, align 8
  ret void
}

; Function Attrs: argmemonly nofree nounwind willreturn
declare void @llvm.memcpy.p0i8.p0i8.i64(i8* noalias nocapture writeonly %0, i8* noalias nocapture readonly %1, i64 %2, i1 immarg %3) #3

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i1 @std.target.Arch.isWasm(i6 %0) unnamed_addr #1 {
Entry:
  %result = alloca i1, align 1
  %arch = alloca i6, align 1
  store i6 %0, i6* %arch, align 1
  %1 = load i6, i6* %arch, align 1
  switch i6 %1, label %SwitchElse [
    i6 -15, label %SwitchProng
    i6 -14, label %SwitchProng
  ]

SwitchElse:                                       ; preds = %Entry
  store i1 false, i1* %result, align 1
  br label %SwitchEnd

SwitchProng:                                      ; preds = %Entry, %Entry
  store i1 true, i1* %result, align 1
  br label %SwitchEnd

SwitchEnd:                                        ; preds = %SwitchProng, %SwitchElse
  %2 = load i1, i1* %result, align 1
  ret i1 %2
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i1 @std.target.Arch.isMIPS(i6 %0) unnamed_addr #1 {
Entry:
  %result = alloca i1, align 1
  %arch = alloca i6, align 1
  store i6 %0, i6* %arch, align 1
  %1 = load i6, i6* %arch, align 1
  switch i6 %1, label %SwitchElse [
    i6 12, label %SwitchProng
    i6 13, label %SwitchProng
    i6 14, label %SwitchProng
    i6 15, label %SwitchProng
  ]

SwitchElse:                                       ; preds = %Entry
  store i1 false, i1* %result, align 1
  br label %SwitchEnd

SwitchProng:                                      ; preds = %Entry, %Entry, %Entry, %Entry
  store i1 true, i1* %result, align 1
  br label %SwitchEnd

SwitchEnd:                                        ; preds = %SwitchProng, %SwitchElse
  %2 = load i1, i1* %result, align 1
  ret i1 %2
}

; Function Attrs: minsize naked nobuiltin noreturn nounwind optsize
define void @_start() #4 {
Entry:
  %0 = call i64* asm sideeffect " xor %rbp, %rbp", "={rsp},~{dirflag},~{fpsr},~{flags}"()
  store i64* %0, i64** @argc_argv_ptr, align 8
  call fastcc void @std.start.posixCallMainAndExit() #10
  unreachable
}

; Function Attrs: minsize nobuiltin noinline noreturn nounwind optsize alignstack(16)
define internal fastcc void @std.start.posixCallMainAndExit() unnamed_addr #5 {
Entry:
  %argc = alloca i64, align 8
  %argv = alloca i8**, align 8
  %envp_optional = alloca i8**, align 8
  %envp_count = alloca i64, align 8
  %_ = alloca i8*, align 8
  %0 = alloca i8**, align 8
  %envp = alloca %"[][*:0]u8", align 8
  %auxv = alloca %std.elf.Elf64_auxv_t*, align 8
  %at_hwcap = alloca i64, align 8
  %i = alloca i64, align 8
  %at_phdr = alloca i64, align 8
  %at_phnum = alloca i64, align 8
  %1 = alloca %std.elf.Elf64_Phdr*, align 8
  %phdrs = alloca %"[]std.elf.Elf64_Phdr", align 8
  %2 = load i64*, i64** @argc_argv_ptr, align 8
  %3 = getelementptr inbounds i64, i64* %2, i64 0
  %4 = load i64, i64* %3, align 8
  store i64 %4, i64* %argc, align 8
  %5 = load i64*, i64** @argc_argv_ptr, align 8
  %6 = getelementptr inbounds i64, i64* %5, i64 1
  %7 = bitcast i64* %6 to i8**
  store i8** %7, i8*** %argv, align 8
  %8 = load i8**, i8*** %argv, align 8
  %9 = load i64, i64* %argc, align 8
  %10 = getelementptr inbounds i8*, i8** %8, i64 %9
  %11 = getelementptr inbounds i8*, i8** %10, i64 1
  store i8** %11, i8*** %envp_optional, align 8
  store i64 0, i64* %envp_count, align 8
  br label %WhileCond

WhileCond:                                        ; preds = %WhileBody, %Entry
  %12 = load i64, i64* %envp_count, align 8
  %13 = load i8**, i8*** %envp_optional, align 8
  %14 = getelementptr inbounds i8*, i8** %13, i64 %12
  %15 = load i8*, i8** %14, align 8
  %16 = icmp ne i8* %15, null
  br i1 %16, label %WhileBody, label %WhileEnd

WhileBody:                                        ; preds = %WhileCond
  %17 = load i8*, i8** %14, align 8
  store i8* %17, i8** %_, align 8
  %18 = load i64, i64* %envp_count, align 8
  %19 = add nuw i64 %18, 1
  store i64 %19, i64* %envp_count, align 8
  br label %WhileCond

WhileEnd:                                         ; preds = %WhileCond
  %20 = load i8**, i8*** %envp_optional, align 8
  store i8** %20, i8*** %0, align 8
  %21 = load i64, i64* %envp_count, align 8
  %22 = load i8**, i8*** %0, align 8
  %23 = getelementptr inbounds i8*, i8** %22, i64 0
  %24 = sub nuw i64 %21, 0
  %25 = getelementptr inbounds %"[][*:0]u8", %"[][*:0]u8"* %envp, i32 0, i32 0
  store i8** %23, i8*** %25, align 8
  %26 = getelementptr inbounds %"[][*:0]u8", %"[][*:0]u8"* %envp, i32 0, i32 1
  store i64 %24, i64* %26, align 8
  %27 = getelementptr inbounds %"[][*:0]u8", %"[][*:0]u8"* %envp, i32 0, i32 0
  %28 = load i8**, i8*** %27, align 8
  %29 = load i64, i64* %envp_count, align 8
  %30 = getelementptr inbounds i8*, i8** %28, i64 %29
  %31 = getelementptr inbounds i8*, i8** %30, i64 1
  %32 = bitcast i8** %31 to %std.elf.Elf64_auxv_t*
  store %std.elf.Elf64_auxv_t* %32, %std.elf.Elf64_auxv_t** %auxv, align 8
  %33 = load %std.elf.Elf64_auxv_t*, %std.elf.Elf64_auxv_t** %auxv, align 8
  store %std.elf.Elf64_auxv_t* %33, %std.elf.Elf64_auxv_t** @elf_aux_maybe, align 8
  store i64 0, i64* %at_hwcap, align 8
  store i64 0, i64* %i, align 8
  store i64 0, i64* %at_phdr, align 8
  store i64 0, i64* %at_phnum, align 8
  br label %WhileCond1

WhileCond1:                                       ; preds = %WhileContinue, %WhileEnd
  %34 = load i64, i64* %i, align 8
  %35 = load %std.elf.Elf64_auxv_t*, %std.elf.Elf64_auxv_t** %auxv, align 8
  %36 = getelementptr inbounds %std.elf.Elf64_auxv_t, %std.elf.Elf64_auxv_t* %35, i64 %34
  %37 = getelementptr inbounds %std.elf.Elf64_auxv_t, %std.elf.Elf64_auxv_t* %36, i32 0, i32 0
  %38 = load i64, i64* %37, align 8
  %39 = icmp ne i64 %38, 0
  br i1 %39, label %WhileBody2, label %WhileEnd5

WhileBody2:                                       ; preds = %WhileCond1
  %40 = load i64, i64* %i, align 8
  %41 = load %std.elf.Elf64_auxv_t*, %std.elf.Elf64_auxv_t** %auxv, align 8
  %42 = getelementptr inbounds %std.elf.Elf64_auxv_t, %std.elf.Elf64_auxv_t* %41, i64 %40
  %43 = getelementptr inbounds %std.elf.Elf64_auxv_t, %std.elf.Elf64_auxv_t* %42, i32 0, i32 0
  %44 = load i64, i64* %43, align 8
  switch i64 %44, label %SwitchElse [
    i64 5, label %SwitchProng
    i64 3, label %SwitchProng3
    i64 16, label %SwitchProng4
  ]

SwitchElse:                                       ; preds = %WhileBody2
  br label %WhileContinue

SwitchProng:                                      ; preds = %WhileBody2
  %45 = load i64, i64* %i, align 8
  %46 = load %std.elf.Elf64_auxv_t*, %std.elf.Elf64_auxv_t** %auxv, align 8
  %47 = getelementptr inbounds %std.elf.Elf64_auxv_t, %std.elf.Elf64_auxv_t* %46, i64 %45
  %48 = getelementptr inbounds %std.elf.Elf64_auxv_t, %std.elf.Elf64_auxv_t* %47, i32 0, i32 1
  %49 = getelementptr inbounds %"std.elf.union:790:11", %"std.elf.union:790:11"* %48, i32 0, i32 0
  %50 = load i64, i64* %49, align 8
  store i64 %50, i64* %at_phnum, align 8
  br label %SwitchEnd

SwitchProng3:                                     ; preds = %WhileBody2
  %51 = load i64, i64* %i, align 8
  %52 = load %std.elf.Elf64_auxv_t*, %std.elf.Elf64_auxv_t** %auxv, align 8
  %53 = getelementptr inbounds %std.elf.Elf64_auxv_t, %std.elf.Elf64_auxv_t* %52, i64 %51
  %54 = getelementptr inbounds %std.elf.Elf64_auxv_t, %std.elf.Elf64_auxv_t* %53, i32 0, i32 1
  %55 = getelementptr inbounds %"std.elf.union:790:11", %"std.elf.union:790:11"* %54, i32 0, i32 0
  %56 = load i64, i64* %55, align 8
  store i64 %56, i64* %at_phdr, align 8
  br label %SwitchEnd

SwitchProng4:                                     ; preds = %WhileBody2
  %57 = load i64, i64* %i, align 8
  %58 = load %std.elf.Elf64_auxv_t*, %std.elf.Elf64_auxv_t** %auxv, align 8
  %59 = getelementptr inbounds %std.elf.Elf64_auxv_t, %std.elf.Elf64_auxv_t* %58, i64 %57
  %60 = getelementptr inbounds %std.elf.Elf64_auxv_t, %std.elf.Elf64_auxv_t* %59, i32 0, i32 1
  %61 = getelementptr inbounds %"std.elf.union:790:11", %"std.elf.union:790:11"* %60, i32 0, i32 0
  %62 = load i64, i64* %61, align 8
  store i64 %62, i64* %at_hwcap, align 8
  br label %SwitchEnd

SwitchEnd:                                        ; preds = %SwitchProng4, %SwitchProng3, %SwitchProng
  br label %WhileContinue

WhileContinue:                                    ; preds = %SwitchEnd, %SwitchElse
  %63 = load i64, i64* %i, align 8
  %64 = add nuw i64 %63, 1
  store i64 %64, i64* %i, align 8
  br label %WhileCond1

WhileEnd5:                                        ; preds = %WhileCond1
  %65 = load i64, i64* %at_phdr, align 8
  %66 = inttoptr i64 %65 to %std.elf.Elf64_Phdr*
  store %std.elf.Elf64_Phdr* %66, %std.elf.Elf64_Phdr** %1, align 8
  %67 = load i64, i64* %at_phnum, align 8
  %68 = load %std.elf.Elf64_Phdr*, %std.elf.Elf64_Phdr** %1, align 8
  %69 = getelementptr inbounds %std.elf.Elf64_Phdr, %std.elf.Elf64_Phdr* %68, i64 0
  %70 = sub nuw i64 %67, 0
  %71 = getelementptr inbounds %"[]std.elf.Elf64_Phdr", %"[]std.elf.Elf64_Phdr"* %phdrs, i32 0, i32 0
  store %std.elf.Elf64_Phdr* %69, %std.elf.Elf64_Phdr** %71, align 8
  %72 = getelementptr inbounds %"[]std.elf.Elf64_Phdr", %"[]std.elf.Elf64_Phdr"* %phdrs, i32 0, i32 1
  store i64 %70, i64* %72, align 8
  %73 = bitcast %"[]std.elf.Elf64_Phdr"* %phdrs to i8*
  %74 = bitcast %"[]std.elf.Elf64_Phdr"* %phdrs to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %74, i8* align 8 %73, i64 16, i1 false)
  br label %BlockEnd

BlockEnd:                                         ; preds = %WhileEnd5
  call fastcc void @std.os.linux.tls.initStaticTLS(%"[]std.elf.Elf64_Phdr"* %phdrs)
  call fastcc void @std.start.expandStackSize(%"[]std.elf.Elf64_Phdr"* %phdrs)
  %75 = load i64, i64* %argc, align 8
  %76 = load i8**, i8*** %argv, align 8
  %77 = call fastcc i8 @std.start.callMainWithArgs(i64 %75, i8** %76, %"[][*:0]u8"* %envp) #11
  call fastcc void @std.os.exit(i8 %77)
  unreachable
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.Thread.Mutex.lock(%std.Thread.Mutex* nonnull align 4 %0) unnamed_addr #1 {
Entry:
  %m = alloca %std.Thread.Mutex*, align 8
  store %std.Thread.Mutex* %0, %std.Thread.Mutex** %m, align 8
  %1 = load %std.Thread.Mutex*, %std.Thread.Mutex** %m, align 8
  %2 = getelementptr inbounds %std.Thread.Mutex, %std.Thread.Mutex* %1, i32 0, i32 0
  call fastcc void @std.Thread.Mutex.AtomicMutex.lock(%std.Thread.Mutex.AtomicMutex* %2)
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.io.getStdErr(%std.fs.file.File* nonnull sret(%std.fs.file.File) %0) unnamed_addr #1 {
Entry:
  %1 = getelementptr inbounds %std.fs.file.File, %std.fs.file.File* %0, i32 0, i32 0
  %2 = call fastcc i32 @std.io.getStdErrHandle()
  store i32 %2, i32* %1, align 4
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.fs.file.File.writer(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull sret(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)") %0, %std.fs.file.File* nonnull readonly align 4 %1) unnamed_addr #1 {
Entry:
  %2 = getelementptr inbounds %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0, i32 0, i32 0
  %3 = bitcast %std.fs.file.File* %1 to i8*
  %4 = bitcast %std.fs.file.File* %2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %4, i8* align 4 %3, i64 4, i1 false)
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i64 @std.Thread.getCurrentId() unnamed_addr #1 {
Entry:
  %result = alloca i64, align 8
  %0 = call fastcc i64 @std.Thread.LinuxThreadImpl.getCurrentId()
  store i64 %0, i64* %result, align 8
  %1 = load i64, i64* %result, align 8
  ret i64 %1
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).print"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %0, %"std.debug.struct:295:56"* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %2 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %3 = alloca %"std.debug.struct:295:56", align 8
  %4 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0 to i8*
  %5 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %5, i8* align 4 %4, i64 4, i1 false)
  %6 = bitcast %"std.debug.struct:295:56"* %1 to i8*
  %7 = bitcast %"std.debug.struct:295:56"* %3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %7, i8* align 8 %6, i64 8, i1 false)
  %8 = call fastcc i16 @std.fmt.format(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0, %"std.debug.struct:295:56"* %1)
  store i16 %8, i16* %result, align 2
  %9 = load i16, i16* %result, align 2
  ret i16 %9
}

; Function Attrs: cold minsize nobuiltin noreturn nounwind optsize
define internal fastcc void @std.os.abort() unnamed_addr #0 {
Entry:
  %0 = alloca i16, align 2
  %1 = alloca i16, align 2
  %2 = call fastcc i16 @std.os.raise(i8 6)
  store i16 %2, i16* %0, align 2
  %3 = icmp ne i16 %2, 0
  br i1 %3, label %UnwrapErrError, label %UnwrapErrOk

UnwrapErrError:                                   ; preds = %Entry
  br label %UnwrapErrEnd

UnwrapErrOk:                                      ; preds = %Entry
  br label %UnwrapErrEnd

UnwrapErrEnd:                                     ; preds = %UnwrapErrOk, %UnwrapErrError
  %4 = call fastcc i16 @std.os.raise(i8 9)
  store i16 %4, i16* %1, align 2
  %5 = icmp ne i16 %4, 0
  br i1 %5, label %UnwrapErrError1, label %UnwrapErrOk2

UnwrapErrError1:                                  ; preds = %UnwrapErrEnd
  br label %UnwrapErrEnd3

UnwrapErrOk2:                                     ; preds = %UnwrapErrEnd
  br label %UnwrapErrEnd3

UnwrapErrEnd3:                                    ; preds = %UnwrapErrOk2, %UnwrapErrError1
  call fastcc void @std.os.exit(i8 127)
  unreachable
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).print.13"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %0, %"std.debug.struct:297:40"* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %2 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %3 = alloca %"std.debug.struct:297:40", align 8
  %4 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0 to i8*
  %5 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %5, i8* align 4 %4, i64 4, i1 false)
  %6 = bitcast %"std.debug.struct:297:40"* %1 to i8*
  %7 = bitcast %"std.debug.struct:297:40"* %3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %7, i8* align 8 %6, i64 16, i1 false)
  %8 = call fastcc i16 @std.fmt.format.15(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0, %"std.debug.struct:297:40"* %1)
  store i16 %8, i16* %result, align 2
  %9 = load i16, i16* %result, align 2
  ret i16 %9
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.debug.dumpStackTrace(%std.builtin.StackTrace* nonnull readonly align 8 %0) unnamed_addr #1 {
Entry:
  %1 = alloca %std.fs.file.File, align 4
  %stderr = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %2 = alloca i16, align 2
  call fastcc void @std.io.getStdErr(%std.fs.file.File* sret(%std.fs.file.File) %1)
  call fastcc void @std.fs.file.File.writer(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* sret(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)") %stderr, %std.fs.file.File* %1)
  %3 = call fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).print.16"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %stderr)
  store i16 %3, i16* %2, align 2
  %4 = icmp ne i16 %3, 0
  br i1 %4, label %UnwrapErrError, label %UnwrapErrOk

UnwrapErrError:                                   ; preds = %Entry
  ret void

UnwrapErrOk:                                      ; preds = %Entry
  br label %UnwrapErrEnd

UnwrapErrEnd:                                     ; preds = %UnwrapErrOk
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.debug.dumpCurrentStackTrace(%"?usize"* nonnull readonly align 8 %0) unnamed_addr #1 {
Entry:
  %1 = alloca %std.fs.file.File, align 4
  %stderr = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %2 = alloca i16, align 2
  call fastcc void @std.io.getStdErr(%std.fs.file.File* sret(%std.fs.file.File) %1)
  call fastcc void @std.fs.file.File.writer(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* sret(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)") %stderr, %std.fs.file.File* %1)
  %3 = call fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).print.17"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %stderr)
  store i16 %3, i16* %2, align 2
  %4 = icmp ne i16 %3, 0
  br i1 %4, label %UnwrapErrError, label %UnwrapErrOk

UnwrapErrError:                                   ; preds = %Entry
  ret void

UnwrapErrOk:                                      ; preds = %Entry
  br label %UnwrapErrEnd

UnwrapErrEnd:                                     ; preds = %UnwrapErrOk
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.Thread.Mutex.unlock(%std.Thread.Mutex* nonnull align 4 %0) unnamed_addr #1 {
Entry:
  %m = alloca %std.Thread.Mutex*, align 8
  store %std.Thread.Mutex* %0, %std.Thread.Mutex** %m, align 8
  %1 = load %std.Thread.Mutex*, %std.Thread.Mutex** %m, align 8
  %2 = getelementptr inbounds %std.Thread.Mutex, %std.Thread.Mutex* %1, i32 0, i32 0
  call fastcc void @std.Thread.Mutex.AtomicMutex.unlock(%std.Thread.Mutex.AtomicMutex* %2)
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.Thread.StaticResetEvent.wait(%std.Thread.StaticResetEvent* nonnull align 4 %0) unnamed_addr #1 {
Entry:
  %ev = alloca %std.Thread.StaticResetEvent*, align 8
  store %std.Thread.StaticResetEvent* %0, %std.Thread.StaticResetEvent** %ev, align 8
  %1 = load %std.Thread.StaticResetEvent*, %std.Thread.StaticResetEvent** %ev, align 8
  %2 = getelementptr inbounds %std.Thread.StaticResetEvent, %std.Thread.StaticResetEvent* %1, i32 0, i32 0
  call fastcc void @std.Thread.StaticResetEvent.AtomicEvent.wait(%std.Thread.StaticResetEvent.AtomicEvent* %2)
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).print.14"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %0) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %1 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %2 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0 to i8*
  %3 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %3, i8* align 4 %2, i64 4, i1 false)
  %4 = call fastcc i16 @std.fmt.format.18(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0)
  store i16 %4, i16* %result, align 2
  %5 = load i16, i16* %result, align 2
  ret i16 %5
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.os.linux.tls.initStaticTLS(%"[]std.elf.Elf64_Phdr"* nonnull readonly align 8 %0) unnamed_addr #1 {
Entry:
  %1 = alloca { %"[]u8", i16 }, align 8
  %alloc_tls_area = alloca %"[]u8", align 8
  %begin_addr = alloca i64, align 8
  %begin_aligned_addr = alloca i64, align 8
  %start = alloca i64, align 8
  %tls_area = alloca %"[]u8", align 8
  %tp_value = alloca i64, align 8
  call fastcc void @std.os.linux.tls.initTLS(%"[]std.elf.Elf64_Phdr"* %0)
  %2 = load i64, i64* getelementptr inbounds (%std.os.linux.tls.TLSImage, %std.os.linux.tls.TLSImage* @tls_image, i32 0, i32 2), align 8
  %3 = icmp ule i64 %2, 4096
  br i1 %3, label %BoolAndTrue, label %BoolAndFalse

BoolAndTrue:                                      ; preds = %Entry
  %4 = load i64, i64* getelementptr inbounds (%std.os.linux.tls.TLSImage, %std.os.linux.tls.TLSImage* @tls_image, i32 0, i32 1), align 8
  %5 = icmp ule i64 %4, 8448
  br label %BoolAndFalse

BoolAndFalse:                                     ; preds = %BoolAndTrue, %Entry
  %6 = phi i1 [ %3, %Entry ], [ %5, %BoolAndTrue ]
  br i1 %6, label %Then, label %Else

Else:                                             ; preds = %BoolAndFalse
  br label %EndIf

EndIf:                                            ; preds = %Else
  %7 = load i64, i64* getelementptr inbounds (%std.os.linux.tls.TLSImage, %std.os.linux.tls.TLSImage* @tls_image, i32 0, i32 1), align 8
  %8 = load i64, i64* getelementptr inbounds (%std.os.linux.tls.TLSImage, %std.os.linux.tls.TLSImage* @tls_image, i32 0, i32 2), align 8
  %9 = add nuw i64 %7, %8
  %10 = sub nuw i64 %9, 1
  call fastcc void @std.os.mmap({ %"[]u8", i16 }* sret({ %"[]u8", i16 }) %1, i8* null, i64 %10, i32 3, i32 34, i32 -1, i64 0)
  %11 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %1, i32 0, i32 1
  %12 = load i16, i16* %11, align 2
  %13 = icmp ne i16 %12, 0
  br i1 %13, label %UnwrapErrError, label %UnwrapErrOk

UnwrapErrError:                                   ; preds = %EndIf
  call fastcc void @std.os.abort()
  unreachable

UnwrapErrOk:                                      ; preds = %EndIf
  %14 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %1, i32 0, i32 0
  %15 = bitcast %"[]u8"* %14 to i8*
  %16 = bitcast %"[]u8"* %alloc_tls_area to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %16, i8* align 8 %15, i64 16, i1 false)
  br label %UnwrapErrEnd

Then:                                             ; preds = %BoolAndFalse
  %17 = load i64, i64* getelementptr inbounds (%std.os.linux.tls.TLSImage, %std.os.linux.tls.TLSImage* @tls_image, i32 0, i32 1), align 8
  %18 = sub nuw i64 %17, 0
  %19 = getelementptr inbounds %"[]u8", %"[]u8"* %tls_area, i32 0, i32 0
  store i8* getelementptr inbounds ([8448 x i8], [8448 x i8]* @main_thread_tls_buffer, i64 0, i64 0), i8** %19, align 8
  %20 = getelementptr inbounds %"[]u8", %"[]u8"* %tls_area, i32 0, i32 1
  store i64 %18, i64* %20, align 8
  %21 = bitcast %"[]u8"* %tls_area to i8*
  %22 = bitcast %"[]u8"* %tls_area to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %22, i8* align 8 %21, i64 16, i1 false)
  br label %BlockEnd

UnwrapErrEnd:                                     ; preds = %UnwrapErrOk
  %23 = getelementptr inbounds %"[]u8", %"[]u8"* %alloc_tls_area, i32 0, i32 0
  %24 = load i8*, i8** %23, align 8
  %25 = ptrtoint i8* %24 to i64
  store i64 %25, i64* %begin_addr, align 8
  %26 = load i64, i64* %begin_addr, align 8
  %27 = load i64, i64* getelementptr inbounds (%std.os.linux.tls.TLSImage, %std.os.linux.tls.TLSImage* @tls_image, i32 0, i32 2), align 8
  %28 = call fastcc i64 @std.mem.alignForward(i64 %26, i64 %27)
  store i64 %28, i64* %begin_aligned_addr, align 8
  %29 = load i64, i64* %begin_aligned_addr, align 8
  %30 = load i64, i64* %begin_addr, align 8
  %31 = sub nuw i64 %29, %30
  store i64 %31, i64* %start, align 8
  %32 = load i64, i64* %start, align 8
  %33 = load i64, i64* %start, align 8
  %34 = load i64, i64* getelementptr inbounds (%std.os.linux.tls.TLSImage, %std.os.linux.tls.TLSImage* @tls_image, i32 0, i32 1), align 8
  %35 = add nuw i64 %33, %34
  %36 = getelementptr inbounds %"[]u8", %"[]u8"* %alloc_tls_area, i32 0, i32 0
  %37 = load i8*, i8** %36, align 8
  %38 = getelementptr inbounds i8, i8* %37, i64 %32
  %39 = sub nuw i64 %35, %32
  %40 = getelementptr inbounds %"[]u8", %"[]u8"* %tls_area, i32 0, i32 0
  store i8* %38, i8** %40, align 8
  %41 = getelementptr inbounds %"[]u8", %"[]u8"* %tls_area, i32 0, i32 1
  store i64 %39, i64* %41, align 8
  %42 = bitcast %"[]u8"* %tls_area to i8*
  %43 = bitcast %"[]u8"* %tls_area to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %43, i8* align 8 %42, i64 16, i1 false)
  br label %BlockEnd

BlockEnd:                                         ; preds = %UnwrapErrEnd, %Then
  %44 = call fastcc i64 @std.os.linux.tls.prepareTLS(%"[]u8"* %tls_area)
  store i64 %44, i64* %tp_value, align 8
  %45 = load i64, i64* %tp_value, align 8
  call fastcc void @std.os.linux.tls.setThreadPointer(i64 %45)
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.start.expandStackSize(%"[]std.elf.Elf64_Phdr"* nonnull readonly align 8 %0) unnamed_addr #1 {
Entry:
  %i = alloca i64, align 8
  %phdr = alloca %std.elf.Elf64_Phdr*, align 8
  %wanted_stack_size = alloca i64, align 8
  %1 = alloca %std.os.linux.rlimit, align 8
  %2 = alloca i16, align 2
  store i64 0, i64* %i, align 8
  %3 = getelementptr inbounds %"[]std.elf.Elf64_Phdr", %"[]std.elf.Elf64_Phdr"* %0, i32 0, i32 1
  %4 = load i64, i64* %3, align 8
  br label %ForCond

ForCond:                                          ; preds = %SwitchEnd, %Entry
  %5 = load i64, i64* %i, align 8
  %6 = icmp ult i64 %5, %4
  br i1 %6, label %ForBody, label %ForEnd

ForBody:                                          ; preds = %ForCond
  %7 = getelementptr inbounds %"[]std.elf.Elf64_Phdr", %"[]std.elf.Elf64_Phdr"* %0, i32 0, i32 0
  %8 = load %std.elf.Elf64_Phdr*, %std.elf.Elf64_Phdr** %7, align 8
  %9 = getelementptr inbounds %std.elf.Elf64_Phdr, %std.elf.Elf64_Phdr* %8, i64 %5
  store %std.elf.Elf64_Phdr* %9, %std.elf.Elf64_Phdr** %phdr, align 8
  %10 = load %std.elf.Elf64_Phdr*, %std.elf.Elf64_Phdr** %phdr, align 8
  %11 = getelementptr inbounds %std.elf.Elf64_Phdr, %std.elf.Elf64_Phdr* %10, i32 0, i32 0
  %12 = load i32, i32* %11, align 4
  switch i32 %12, label %SwitchElse [
    i32 1685382481, label %SwitchProng
  ]

SwitchProng:                                      ; preds = %ForBody
  %13 = load %std.elf.Elf64_Phdr*, %std.elf.Elf64_Phdr** %phdr, align 8
  %14 = getelementptr inbounds %std.elf.Elf64_Phdr, %std.elf.Elf64_Phdr* %13, i32 0, i32 6
  %15 = load i64, i64* %14, align 8
  store i64 %15, i64* %wanted_stack_size, align 8
  %16 = load i64, i64* %wanted_stack_size, align 8
  %17 = urem i64 %16, 4096
  %18 = icmp eq i64 %17, 0
  call fastcc void @std.debug.assert(i1 %18)
  %19 = getelementptr inbounds %std.os.linux.rlimit, %std.os.linux.rlimit* %1, i32 0, i32 0
  %20 = load i64, i64* %wanted_stack_size, align 8
  store i64 %20, i64* %19, align 8
  %21 = getelementptr inbounds %std.os.linux.rlimit, %std.os.linux.rlimit* %1, i32 0, i32 1
  %22 = load i64, i64* %wanted_stack_size, align 8
  store i64 %22, i64* %21, align 8
  %23 = call fastcc i16 @std.os.setrlimit(i32 3, %std.os.linux.rlimit* %1)
  store i16 %23, i16* %2, align 2
  %24 = icmp ne i16 %23, 0
  br i1 %24, label %UnwrapErrError, label %UnwrapErrOk

UnwrapErrError:                                   ; preds = %SwitchProng
  br label %UnwrapErrEnd

UnwrapErrOk:                                      ; preds = %SwitchProng
  br label %UnwrapErrEnd

UnwrapErrEnd:                                     ; preds = %UnwrapErrOk, %UnwrapErrError
  br label %ForEnd

SwitchElse:                                       ; preds = %ForBody
  br label %SwitchEnd

SwitchEnd:                                        ; preds = %SwitchElse
  %25 = add nuw i64 %5, 1
  store i64 %25, i64* %i, align 8
  br label %ForCond

ForEnd:                                           ; preds = %UnwrapErrEnd, %ForCond
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i8 @std.start.callMainWithArgs(i64 %0, i8** nonnull align 8 %1, %"[][*:0]u8"* nonnull readonly align 8 %2) unnamed_addr #1 {
Entry:
  %result = alloca i8, align 1
  %argc = alloca i64, align 8
  %argv = alloca i8**, align 8
  store i64 %0, i64* %argc, align 8
  store i8** %1, i8*** %argv, align 8
  %3 = load i64, i64* %argc, align 8
  %4 = load i8**, i8*** %argv, align 8
  %5 = getelementptr inbounds i8*, i8** %4, i64 0
  %6 = sub nuw i64 %3, 0
  store i8** %5, i8*** getelementptr inbounds (%"[][*:0]u8", %"[][*:0]u8"* @argv, i32 0, i32 0), align 8
  store i64 %6, i64* getelementptr inbounds (%"[][*:0]u8", %"[][*:0]u8"* @argv, i32 0, i32 1), align 8
  %7 = bitcast %"[][*:0]u8"* %2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 bitcast (%"[][*:0]u8"* @environ to i8*), i8* align 8 %7, i64 16, i1 false)
  call fastcc void @std.debug.maybeEnableSegfaultHandler()
  %8 = call fastcc i8 @std.start.initEventLoopAndCallMain()
  store i8 %8, i8* %result, align 1
  %9 = load i8, i8* %result, align 1
  ret i8 %9
}

; Function Attrs: minsize nobuiltin noreturn nounwind optsize
define internal fastcc void @std.os.exit(i8 %0) unnamed_addr #6 {
Entry:
  %status = alloca i8, align 1
  store i8 %0, i8* %status, align 1
  %1 = load i8, i8* %status, align 1
  %2 = zext i8 %1 to i32
  call fastcc void @std.os.linux.exit_group(i32 %2)
  unreachable
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.Thread.Mutex.AtomicMutex.lock(%std.Thread.Mutex.AtomicMutex* nonnull align 4 %0) unnamed_addr #1 {
Entry:
  %1 = alloca i32, align 4
  %s = alloca i32, align 4
  %m = alloca %std.Thread.Mutex.AtomicMutex*, align 8
  store %std.Thread.Mutex.AtomicMutex* %0, %std.Thread.Mutex.AtomicMutex** %m, align 8
  %2 = load %std.Thread.Mutex.AtomicMutex*, %std.Thread.Mutex.AtomicMutex** %m, align 8
  %3 = getelementptr inbounds %std.Thread.Mutex.AtomicMutex, %std.Thread.Mutex.AtomicMutex* %2, i32 0, i32 0
  %4 = atomicrmw xchg i32* %3, i32 1 acquire, align 4
  store i32 %4, i32* %1, align 4
  switch i32 %4, label %SwitchElse [
    i32 0, label %SwitchProng
  ]

SwitchElse:                                       ; preds = %Entry
  store i32 %4, i32* %s, align 4
  %5 = load %std.Thread.Mutex.AtomicMutex*, %std.Thread.Mutex.AtomicMutex** %m, align 8
  %6 = load i32, i32* %s, align 4
  call fastcc void @std.Thread.Mutex.AtomicMutex.lockSlow(%std.Thread.Mutex.AtomicMutex* %5, i32 %6)
  br label %SwitchEnd

SwitchProng:                                      ; preds = %Entry
  br label %SwitchEnd

SwitchEnd:                                        ; preds = %SwitchProng, %SwitchElse
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i32 @std.io.getStdErrHandle() unnamed_addr #1 {
Entry:
  %result = alloca i32, align 4
  store i32 2, i32* %result, align 4
  %0 = load i32, i32* %result, align 4
  ret i32 %0
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.fs.file.File.write({ i64, i16 }* nonnull sret({ i64, i16 }) %0, %std.fs.file.File* nonnull readonly align 4 %1, %"[]u8"* nonnull readonly align 8 %2) unnamed_addr #1 {
Entry:
  %3 = getelementptr inbounds %std.fs.file.File, %std.fs.file.File* %1, i32 0, i32 0
  %4 = load i32, i32* %3, align 4
  call fastcc void @std.os.write({ i64, i16 }* sret({ i64, i16 }) %0, i32 %4, %"[]u8"* %2)
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.os.write({ i64, i16 }* nonnull sret({ i64, i16 }) %0, i32 %1, %"[]u8"* nonnull readonly align 8 %2) unnamed_addr #1 {
Entry:
  %adjusted_len = alloca i64, align 8
  %rc = alloca i64, align 8
  %3 = alloca i16, align 2
  %err = alloca i16, align 2
  %fd = alloca i32, align 4
  store i32 %1, i32* %fd, align 4
  %4 = getelementptr inbounds %"[]u8", %"[]u8"* %2, i32 0, i32 1
  %5 = load i64, i64* %4, align 8
  %6 = call i64 @llvm.umin.i64(i64 2147479552, i64 %5)
  store i64 %6, i64* %adjusted_len, align 8
  br label %WhileCond

WhileCond:                                        ; preds = %SwitchProng1, %Entry
  br label %WhileBody

WhileBody:                                        ; preds = %WhileCond
  %7 = load i32, i32* %fd, align 4
  %8 = getelementptr inbounds %"[]u8", %"[]u8"* %2, i32 0, i32 0
  %9 = load i8*, i8** %8, align 8
  %10 = load i64, i64* %adjusted_len, align 8
  %11 = call fastcc i64 @std.os.linux.write(i32 %7, i8* %9, i64 %10)
  store i64 %11, i64* %rc, align 8
  %12 = load i64, i64* %rc, align 8
  %13 = call fastcc i16 @std.os.linux.getErrno(i64 %12)
  store i16 %13, i16* %3, align 2
  switch i16 %13, label %SwitchElse [
    i16 0, label %SwitchProng
    i16 4, label %SwitchProng1
    i16 22, label %SwitchProng2
    i16 14, label %SwitchProng3
    i16 11, label %SwitchProng4
    i16 9, label %SwitchProng5
    i16 89, label %SwitchProng6
    i16 122, label %SwitchProng7
    i16 27, label %SwitchProng8
    i16 5, label %SwitchProng9
    i16 28, label %SwitchProng10
    i16 1, label %SwitchProng11
    i16 32, label %SwitchProng12
    i16 104, label %SwitchProng13
  ]

SwitchElse:                                       ; preds = %WhileBody
  store i16 %13, i16* %err, align 2
  %14 = load i16, i16* %err, align 2
  %15 = call fastcc i16 @std.os.unexpectedErrno(i16 %14)
  %16 = getelementptr inbounds { i64, i16 }, { i64, i16 }* %0, i32 0, i32 1
  store i16 %15, i16* %16, align 2
  ret void

SwitchProng:                                      ; preds = %WhileBody
  %17 = load i64, i64* %rc, align 8
  %18 = getelementptr inbounds { i64, i16 }, { i64, i16 }* %0, i32 0, i32 1
  store i16 0, i16* %18, align 2
  %19 = getelementptr inbounds { i64, i16 }, { i64, i16 }* %0, i32 0, i32 0
  store i64 %17, i64* %19, align 8
  ret void

SwitchProng1:                                     ; preds = %WhileBody
  br label %WhileCond

SwitchProng2:                                     ; preds = %WhileBody
  unreachable

SwitchProng3:                                     ; preds = %WhileBody
  unreachable

SwitchProng4:                                     ; preds = %WhileBody
  %20 = getelementptr inbounds { i64, i16 }, { i64, i16 }* %0, i32 0, i32 1
  store i16 10, i16* %20, align 2
  ret void

SwitchProng5:                                     ; preds = %WhileBody
  %21 = getelementptr inbounds { i64, i16 }, { i64, i16 }* %0, i32 0, i32 1
  store i16 9, i16* %21, align 2
  ret void

SwitchProng6:                                     ; preds = %WhileBody
  unreachable

SwitchProng7:                                     ; preds = %WhileBody
  %22 = getelementptr inbounds { i64, i16 }, { i64, i16 }* %0, i32 0, i32 1
  store i16 1, i16* %22, align 2
  ret void

SwitchProng8:                                     ; preds = %WhileBody
  %23 = getelementptr inbounds { i64, i16 }, { i64, i16 }* %0, i32 0, i32 1
  store i16 2, i16* %23, align 2
  ret void

SwitchProng9:                                     ; preds = %WhileBody
  %24 = getelementptr inbounds { i64, i16 }, { i64, i16 }* %0, i32 0, i32 1
  store i16 3, i16* %24, align 2
  ret void

SwitchProng10:                                    ; preds = %WhileBody
  %25 = getelementptr inbounds { i64, i16 }, { i64, i16 }* %0, i32 0, i32 1
  store i16 4, i16* %25, align 2
  ret void

SwitchProng11:                                    ; preds = %WhileBody
  %26 = getelementptr inbounds { i64, i16 }, { i64, i16 }* %0, i32 0, i32 1
  store i16 5, i16* %26, align 2
  ret void

SwitchProng12:                                    ; preds = %WhileBody
  %27 = getelementptr inbounds { i64, i16 }, { i64, i16 }* %0, i32 0, i32 1
  store i16 6, i16* %27, align 2
  ret void

SwitchProng13:                                    ; preds = %WhileBody
  %28 = getelementptr inbounds { i64, i16 }, { i64, i16 }* %0, i32 0, i32 1
  store i16 11, i16* %28, align 2
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i64 @std.Thread.LinuxThreadImpl.getCurrentId() unnamed_addr #1 {
Entry:
  %result = alloca i64, align 8
  %tid = alloca i32, align 4
  %0 = load i1, i1* getelementptr inbounds (%"?u64", %"?u64"* @tls_thread_id, i32 0, i32 1), align 1
  br i1 %0, label %OptionalNonNull, label %OptionalNull

OptionalNull:                                     ; preds = %Entry
  %1 = call fastcc i32 @std.os.linux.gettid()
  store i32 %1, i32* %tid, align 4
  %2 = load i32, i32* %tid, align 4
  store i1 true, i1* getelementptr inbounds (%"?u64", %"?u64"* @tls_thread_id, i32 0, i32 1), align 1
  %3 = zext i32 %2 to i64
  store i64 %3, i64* getelementptr inbounds (%"?u64", %"?u64"* @tls_thread_id, i32 0, i32 0), align 8
  %4 = load i32, i32* %tid, align 4
  %5 = zext i32 %4 to i64
  store i64 %5, i64* %result, align 8
  %6 = load i64, i64* %result, align 8
  ret i64 %6

OptionalNonNull:                                  ; preds = %Entry
  %7 = load i64, i64* getelementptr inbounds (%"?u64", %"?u64"* @tls_thread_id, i32 0, i32 0), align 8
  store i64 %7, i64* %result, align 8
  %8 = load i64, i64* %result, align 8
  ret i64 %8
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.format(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %0, %"std.debug.struct:295:56"* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %options = alloca %std.fmt.FormatOptions, align 8
  %2 = alloca i16, align 2
  %3 = alloca i64, align 8
  %4 = alloca %std.fmt.FormatOptions, align 8
  %5 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %6 = alloca i16, align 2
  %7 = alloca i16, align 2
  %8 = bitcast %std.fmt.FormatOptions* %options to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %8, i8* align 8 bitcast ({ %"?usize", %"?usize", i2, <{ i8, [6 x i8] }> }* @5 to i8*), i64 40, i1 false)
  %9 = call fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).writeAll"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0, %"[]u8"* @7)
  store i16 %9, i16* %2, align 2
  %10 = icmp ne i16 %9, 0
  br i1 %10, label %ErrRetReturn, label %ErrRetContinue

ErrRetReturn:                                     ; preds = %Entry
  %11 = load i16, i16* %2, align 2
  store i16 %11, i16* %result, align 2
  ret i16 %11

ErrRetContinue:                                   ; preds = %Entry
  %12 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 0
  %13 = bitcast %"?usize"* %12 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %13, i8* align 8 bitcast (%"?usize"* @8 to i8*), i64 16, i1 false)
  %14 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 1
  %15 = bitcast %"?usize"* %14 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %15, i8* align 8 bitcast (%"?usize"* @9 to i8*), i64 16, i1 false)
  %16 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 2
  store i2 -2, i2* %16, align 1
  %17 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 3
  store i8 32, i8* %17, align 1
  %18 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 1
  %19 = bitcast %"?usize"* %18 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %19, i8* align 8 bitcast (%"?usize"* @12 to i8*), i64 16, i1 false)
  %20 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 0
  %21 = bitcast %"?usize"* %20 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %21, i8* align 8 bitcast (%"?usize"* @13 to i8*), i64 16, i1 false)
  %22 = getelementptr inbounds %"std.debug.struct:295:56", %"std.debug.struct:295:56"* %1, i32 0, i32 0
  %23 = load i64, i64* %22, align 8
  store i64 %23, i64* %3, align 8
  %24 = bitcast %std.fmt.FormatOptions* %options to i8*
  %25 = bitcast %std.fmt.FormatOptions* %4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %25, i8* align 8 %24, i64 40, i1 false)
  %26 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0 to i8*
  %27 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %27, i8* align 4 %26, i64 4, i1 false)
  %28 = call fastcc i16 @std.fmt.formatType(i64 %23, %std.fmt.FormatOptions* %options, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0, i64 3)
  store i16 %28, i16* %6, align 2
  %29 = icmp ne i16 %28, 0
  br i1 %29, label %ErrRetReturn1, label %ErrRetContinue2

ErrRetReturn1:                                    ; preds = %ErrRetContinue
  %30 = load i16, i16* %6, align 2
  store i16 %30, i16* %result, align 2
  ret i16 %30

ErrRetContinue2:                                  ; preds = %ErrRetContinue
  %31 = call fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).writeAll"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0, %"[]u8"* @14)
  store i16 %31, i16* %7, align 2
  %32 = icmp ne i16 %31, 0
  br i1 %32, label %ErrRetReturn3, label %ErrRetContinue4

ErrRetReturn3:                                    ; preds = %ErrRetContinue2
  %33 = load i16, i16* %7, align 2
  store i16 %33, i16* %result, align 2
  ret i16 %33

ErrRetContinue4:                                  ; preds = %ErrRetContinue2
  store i16 0, i16* %result, align 2
  ret i16 0
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.os.raise(i8 %0) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %set = alloca [32 x i32], align 4
  %tid = alloca i32, align 4
  %rc = alloca i64, align 8
  %1 = alloca i16, align 2
  %err = alloca i16, align 2
  %sig = alloca i8, align 1
  store i8 %0, i8* %sig, align 1
  %2 = call fastcc i64 @std.os.linux.sigprocmask(i32 0, [32 x i32]* @app_mask, [32 x i32]* %set)
  %3 = call fastcc i32 @std.os.linux.gettid()
  store i32 %3, i32* %tid, align 4
  %4 = load i32, i32* %tid, align 4
  %5 = load i8, i8* %sig, align 1
  %6 = zext i8 %5 to i32
  %7 = call fastcc i64 @std.os.linux.tkill(i32 %4, i32 %6)
  store i64 %7, i64* %rc, align 8
  %8 = call fastcc i64 @std.os.linux.sigprocmask(i32 2, [32 x i32]* %set, [32 x i32]* null)
  %9 = load i64, i64* %rc, align 8
  %10 = call fastcc i16 @std.os.linux.getErrno(i64 %9)
  store i16 %10, i16* %1, align 2
  switch i16 %10, label %SwitchElse [
    i16 0, label %SwitchProng
  ]

SwitchElse:                                       ; preds = %Entry
  store i16 %10, i16* %err, align 2
  %11 = load i16, i16* %err, align 2
  %12 = call fastcc i16 @std.os.unexpectedErrno(i16 %11)
  store i16 %12, i16* %result, align 2
  %13 = load i16, i16* %result, align 2
  ret i16 %13

SwitchProng:                                      ; preds = %Entry
  store i16 0, i16* %result, align 2
  %14 = load i16, i16* %result, align 2
  ret i16 %14
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.format.15(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %0, %"std.debug.struct:297:40"* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %options = alloca %std.fmt.FormatOptions, align 8
  %2 = alloca %"[]u8", align 8
  %3 = alloca %std.fmt.FormatOptions, align 8
  %4 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %5 = alloca i16, align 2
  %6 = alloca i16, align 2
  %7 = bitcast %std.fmt.FormatOptions* %options to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %7, i8* align 8 bitcast ({ %"?usize", %"?usize", i2, <{ i8, [6 x i8] }> }* @16 to i8*), i64 40, i1 false)
  %8 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 0
  %9 = bitcast %"?usize"* %8 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %9, i8* align 8 bitcast (%"?usize"* @17 to i8*), i64 16, i1 false)
  %10 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 1
  %11 = bitcast %"?usize"* %10 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %11, i8* align 8 bitcast (%"?usize"* @18 to i8*), i64 16, i1 false)
  %12 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 2
  store i2 -2, i2* %12, align 1
  %13 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 3
  store i8 32, i8* %13, align 1
  %14 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 1
  %15 = bitcast %"?usize"* %14 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %15, i8* align 8 bitcast (%"?usize"* @22 to i8*), i64 16, i1 false)
  %16 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 0
  %17 = bitcast %"?usize"* %16 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %17, i8* align 8 bitcast (%"?usize"* @23 to i8*), i64 16, i1 false)
  %18 = getelementptr inbounds %"std.debug.struct:297:40", %"std.debug.struct:297:40"* %1, i32 0, i32 0
  %19 = bitcast %"[]u8"* %18 to i8*
  %20 = bitcast %"[]u8"* %2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %20, i8* align 8 %19, i64 16, i1 false)
  %21 = bitcast %std.fmt.FormatOptions* %options to i8*
  %22 = bitcast %std.fmt.FormatOptions* %3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %22, i8* align 8 %21, i64 40, i1 false)
  %23 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0 to i8*
  %24 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %24, i8* align 4 %23, i64 4, i1 false)
  %25 = call fastcc i16 @std.fmt.formatType.19(%"[]u8"* %18, %std.fmt.FormatOptions* %options, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0, i64 3)
  store i16 %25, i16* %5, align 2
  %26 = icmp ne i16 %25, 0
  br i1 %26, label %ErrRetReturn, label %ErrRetContinue

ErrRetReturn:                                     ; preds = %Entry
  %27 = load i16, i16* %5, align 2
  store i16 %27, i16* %result, align 2
  ret i16 %27

ErrRetContinue:                                   ; preds = %Entry
  %28 = call fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).writeAll"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0, %"[]u8"* @24)
  store i16 %28, i16* %6, align 2
  %29 = icmp ne i16 %28, 0
  br i1 %29, label %ErrRetReturn1, label %ErrRetContinue2

ErrRetReturn1:                                    ; preds = %ErrRetContinue
  %30 = load i16, i16* %6, align 2
  store i16 %30, i16* %result, align 2
  ret i16 %30

ErrRetContinue2:                                  ; preds = %ErrRetContinue
  store i16 0, i16* %result, align 2
  ret i16 0
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).print.16"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %0) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %1 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %2 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0 to i8*
  %3 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %3, i8* align 4 %2, i64 4, i1 false)
  %4 = call fastcc i16 @std.fmt.format.20(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0)
  store i16 %4, i16* %result, align 2
  %5 = load i16, i16* %result, align 2
  ret i16 %5
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).print.17"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %0) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %1 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %2 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0 to i8*
  %3 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %3, i8* align 4 %2, i64 4, i1 false)
  %4 = call fastcc i16 @std.fmt.format.21(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0)
  store i16 %4, i16* %result, align 2
  %5 = load i16, i16* %result, align 2
  ret i16 %5
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.Thread.Mutex.AtomicMutex.unlock(%std.Thread.Mutex.AtomicMutex* nonnull align 4 %0) unnamed_addr #1 {
Entry:
  %1 = alloca i32, align 4
  %m = alloca %std.Thread.Mutex.AtomicMutex*, align 8
  store %std.Thread.Mutex.AtomicMutex* %0, %std.Thread.Mutex.AtomicMutex** %m, align 8
  %2 = load %std.Thread.Mutex.AtomicMutex*, %std.Thread.Mutex.AtomicMutex** %m, align 8
  %3 = getelementptr inbounds %std.Thread.Mutex.AtomicMutex, %std.Thread.Mutex.AtomicMutex* %2, i32 0, i32 0
  %4 = atomicrmw xchg i32* %3, i32 0 release, align 4
  store i32 %4, i32* %1, align 4
  switch i32 %4, label %SwitchElse [
    i32 0, label %SwitchProng
    i32 1, label %SwitchProng1
    i32 2, label %SwitchProng2
  ]

SwitchProng:                                      ; preds = %Entry
  unreachable

SwitchElse:                                       ; preds = %Entry
  unreachable

SwitchProng1:                                     ; preds = %Entry
  br label %SwitchEnd

SwitchProng2:                                     ; preds = %Entry
  %5 = load %std.Thread.Mutex.AtomicMutex*, %std.Thread.Mutex.AtomicMutex** %m, align 8
  call fastcc void @std.Thread.Mutex.AtomicMutex.unlockSlow(%std.Thread.Mutex.AtomicMutex* %5)
  br label %SwitchEnd

SwitchEnd:                                        ; preds = %SwitchProng2, %SwitchProng1
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.Thread.StaticResetEvent.AtomicEvent.wait(%std.Thread.StaticResetEvent.AtomicEvent* nonnull align 4 %0) unnamed_addr #1 {
Entry:
  %1 = alloca i1, align 1
  %ev = alloca %std.Thread.StaticResetEvent.AtomicEvent*, align 8
  store %std.Thread.StaticResetEvent.AtomicEvent* %0, %std.Thread.StaticResetEvent.AtomicEvent** %ev, align 8
  %2 = load %std.Thread.StaticResetEvent.AtomicEvent*, %std.Thread.StaticResetEvent.AtomicEvent** %ev, align 8
  %3 = call fastcc i1 @std.Thread.StaticResetEvent.AtomicEvent.timedWait(%std.Thread.StaticResetEvent.AtomicEvent* %2, %"?u64"* @28)
  store i1 %3, i1* %1, align 1
  switch i1 %3, label %SwitchElse [
    i1 true, label %SwitchProng
    i1 false, label %SwitchProng1
  ]

SwitchProng:                                      ; preds = %Entry
  unreachable

SwitchProng1:                                     ; preds = %Entry
  ret void

SwitchElse:                                       ; preds = %Entry
  unreachable
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.format.18(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %0) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %options = alloca %std.fmt.FormatOptions, align 8
  %1 = alloca i16, align 2
  %2 = bitcast %std.fmt.FormatOptions* %options to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %2, i8* align 8 bitcast ({ %"?usize", %"?usize", i2, <{ i8, [6 x i8] }> }* @29 to i8*), i64 40, i1 false)
  %3 = call fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).writeAll"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0, %"[]u8"* @31)
  store i16 %3, i16* %1, align 2
  %4 = icmp ne i16 %3, 0
  br i1 %4, label %ErrRetReturn, label %ErrRetContinue

ErrRetReturn:                                     ; preds = %Entry
  %5 = load i16, i16* %1, align 2
  store i16 %5, i16* %result, align 2
  ret i16 %5

ErrRetContinue:                                   ; preds = %Entry
  store i16 0, i16* %result, align 2
  ret i16 0
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i1 @std.target.Arch.isARM(i6 %0) unnamed_addr #1 {
Entry:
  %result = alloca i1, align 1
  %arch = alloca i6, align 1
  store i6 %0, i6* %arch, align 1
  %1 = load i6, i6* %arch, align 1
  switch i6 %1, label %SwitchElse [
    i6 0, label %SwitchProng
    i6 1, label %SwitchProng
  ]

SwitchElse:                                       ; preds = %Entry
  store i1 false, i1* %result, align 1
  br label %SwitchEnd

SwitchProng:                                      ; preds = %Entry, %Entry
  store i1 true, i1* %result, align 1
  br label %SwitchEnd

SwitchEnd:                                        ; preds = %SwitchProng, %SwitchElse
  %2 = load i1, i1* %result, align 1
  ret i1 %2
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.os.linux.tls.initTLS(%"[]std.elf.Elf64_Phdr"* nonnull readonly align 8 %0) unnamed_addr #1 {
Entry:
  %tls_phdr = alloca %std.elf.Elf64_Phdr*, align 8
  %img_base = alloca i64, align 8
  %i = alloca i64, align 8
  %phdr = alloca %std.elf.Elf64_Phdr*, align 8
  %tls_align_factor = alloca i64, align 8
  %tls_data = alloca %"[]u8", align 8
  %tls_data_alloc_size = alloca i64, align 8
  %phdr2 = alloca %std.elf.Elf64_Phdr*, align 8
  %1 = alloca i8*, align 8
  %tcb_offset = alloca i64, align 8
  %dtv_offset = alloca i64, align 8
  %data_offset = alloca i64, align 8
  %l = alloca i64, align 8
  %alloc_size = alloca i64, align 8
  store %std.elf.Elf64_Phdr* null, %std.elf.Elf64_Phdr** %tls_phdr, align 8
  store i64 0, i64* %img_base, align 8
  store i64 0, i64* %i, align 8
  %2 = getelementptr inbounds %"[]std.elf.Elf64_Phdr", %"[]std.elf.Elf64_Phdr"* %0, i32 0, i32 1
  %3 = load i64, i64* %2, align 8
  br label %ForCond

ForCond:                                          ; preds = %SwitchEnd, %Entry
  %4 = load i64, i64* %i, align 8
  %5 = icmp ult i64 %4, %3
  br i1 %5, label %ForBody, label %ForEnd

ForBody:                                          ; preds = %ForCond
  %6 = getelementptr inbounds %"[]std.elf.Elf64_Phdr", %"[]std.elf.Elf64_Phdr"* %0, i32 0, i32 0
  %7 = load %std.elf.Elf64_Phdr*, %std.elf.Elf64_Phdr** %6, align 8
  %8 = getelementptr inbounds %std.elf.Elf64_Phdr, %std.elf.Elf64_Phdr* %7, i64 %4
  store %std.elf.Elf64_Phdr* %8, %std.elf.Elf64_Phdr** %phdr, align 8
  %9 = load %std.elf.Elf64_Phdr*, %std.elf.Elf64_Phdr** %phdr, align 8
  %10 = getelementptr inbounds %std.elf.Elf64_Phdr, %std.elf.Elf64_Phdr* %9, i32 0, i32 0
  %11 = load i32, i32* %10, align 4
  switch i32 %11, label %SwitchElse [
    i32 6, label %SwitchProng
    i32 7, label %SwitchProng1
  ]

SwitchElse:                                       ; preds = %ForBody
  br label %SwitchEnd

SwitchProng:                                      ; preds = %ForBody
  %12 = getelementptr inbounds %"[]std.elf.Elf64_Phdr", %"[]std.elf.Elf64_Phdr"* %0, i32 0, i32 0
  %13 = load %std.elf.Elf64_Phdr*, %std.elf.Elf64_Phdr** %12, align 8
  %14 = ptrtoint %std.elf.Elf64_Phdr* %13 to i64
  %15 = load %std.elf.Elf64_Phdr*, %std.elf.Elf64_Phdr** %phdr, align 8
  %16 = getelementptr inbounds %std.elf.Elf64_Phdr, %std.elf.Elf64_Phdr* %15, i32 0, i32 3
  %17 = load i64, i64* %16, align 8
  %18 = sub nuw i64 %14, %17
  store i64 %18, i64* %img_base, align 8
  br label %SwitchEnd

SwitchProng1:                                     ; preds = %ForBody
  %19 = load %std.elf.Elf64_Phdr*, %std.elf.Elf64_Phdr** %phdr, align 8
  store %std.elf.Elf64_Phdr* %19, %std.elf.Elf64_Phdr** %tls_phdr, align 8
  br label %SwitchEnd

SwitchEnd:                                        ; preds = %SwitchProng1, %SwitchProng, %SwitchElse
  %20 = add nuw i64 %4, 1
  store i64 %20, i64* %i, align 8
  br label %ForCond

ForEnd:                                           ; preds = %ForCond
  %21 = load %std.elf.Elf64_Phdr*, %std.elf.Elf64_Phdr** %tls_phdr, align 8
  %22 = icmp ne %std.elf.Elf64_Phdr* %21, null
  br i1 %22, label %OptionalThen, label %OptionalElse

OptionalThen:                                     ; preds = %ForEnd
  %23 = load %std.elf.Elf64_Phdr*, %std.elf.Elf64_Phdr** %tls_phdr, align 8
  store %std.elf.Elf64_Phdr* %23, %std.elf.Elf64_Phdr** %phdr2, align 8
  %24 = load %std.elf.Elf64_Phdr*, %std.elf.Elf64_Phdr** %phdr2, align 8
  %25 = getelementptr inbounds %std.elf.Elf64_Phdr, %std.elf.Elf64_Phdr* %24, i32 0, i32 7
  %26 = load i64, i64* %25, align 8
  store i64 %26, i64* %tls_align_factor, align 8
  %27 = load i64, i64* %img_base, align 8
  %28 = load %std.elf.Elf64_Phdr*, %std.elf.Elf64_Phdr** %phdr2, align 8
  %29 = getelementptr inbounds %std.elf.Elf64_Phdr, %std.elf.Elf64_Phdr* %28, i32 0, i32 3
  %30 = load i64, i64* %29, align 8
  %31 = add nuw i64 %27, %30
  %32 = inttoptr i64 %31 to i8*
  store i8* %32, i8** %1, align 8
  %33 = load %std.elf.Elf64_Phdr*, %std.elf.Elf64_Phdr** %phdr2, align 8
  %34 = getelementptr inbounds %std.elf.Elf64_Phdr, %std.elf.Elf64_Phdr* %33, i32 0, i32 5
  %35 = load i64, i64* %34, align 8
  %36 = load i8*, i8** %1, align 8
  %37 = getelementptr inbounds i8, i8* %36, i64 0
  %38 = sub nuw i64 %35, 0
  %39 = getelementptr inbounds %"[]u8", %"[]u8"* %tls_data, i32 0, i32 0
  store i8* %37, i8** %39, align 8
  %40 = getelementptr inbounds %"[]u8", %"[]u8"* %tls_data, i32 0, i32 1
  store i64 %38, i64* %40, align 8
  %41 = load %std.elf.Elf64_Phdr*, %std.elf.Elf64_Phdr** %phdr2, align 8
  %42 = getelementptr inbounds %std.elf.Elf64_Phdr, %std.elf.Elf64_Phdr* %41, i32 0, i32 6
  %43 = load i64, i64* %42, align 8
  store i64 %43, i64* %tls_data_alloc_size, align 8
  br label %OptionalEndIf

OptionalElse:                                     ; preds = %ForEnd
  store i64 8, i64* %tls_align_factor, align 8
  %44 = bitcast %"[]u8"* %tls_data to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %44, i8* align 8 bitcast (%"[]u8"* @32 to i8*), i64 16, i1 false)
  store i64 0, i64* %tls_data_alloc_size, align 8
  br label %OptionalEndIf

OptionalEndIf:                                    ; preds = %OptionalElse, %OptionalThen
  store i64 0, i64* %l, align 8
  %45 = load i64, i64* %l, align 8
  store i64 %45, i64* %data_offset, align 8
  %46 = load i64, i64* %l, align 8
  %47 = load i64, i64* %tls_data_alloc_size, align 8
  %48 = load i64, i64* %tls_align_factor, align 8
  %49 = call fastcc i64 @std.mem.alignForward(i64 %47, i64 %48)
  %50 = add nuw i64 %46, %49
  store i64 %50, i64* %l, align 8
  %51 = load i64, i64* %l, align 8
  store i64 %51, i64* %tcb_offset, align 8
  %52 = load i64, i64* %l, align 8
  %53 = add nuw i64 %52, 8
  store i64 %53, i64* %l, align 8
  %54 = load i64, i64* %l, align 8
  %55 = add nuw i64 %54, 8
  store i64 %55, i64* %l, align 8
  %56 = load i64, i64* %l, align 8
  %57 = call fastcc i64 @std.mem.alignForward(i64 %56, i64 8)
  store i64 %57, i64* %l, align 8
  %58 = load i64, i64* %l, align 8
  store i64 %58, i64* %dtv_offset, align 8
  %59 = load i64, i64* %l, align 8
  %60 = add nuw i64 %59, 16
  store i64 %60, i64* %l, align 8
  %61 = load i64, i64* %l, align 8
  store i64 %61, i64* %alloc_size, align 8
  br label %BlockEnd

BlockEnd:                                         ; preds = %OptionalEndIf
  store i64 %61, i64* %alloc_size, align 8
  %62 = bitcast %"[]u8"* %tls_data to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 bitcast (%std.os.linux.tls.TLSImage* @tls_image to i8*), i8* align 8 %62, i64 16, i1 false)
  %63 = load i64, i64* %alloc_size, align 8
  store i64 %63, i64* getelementptr inbounds (%std.os.linux.tls.TLSImage, %std.os.linux.tls.TLSImage* @tls_image, i32 0, i32 1), align 8
  %64 = load i64, i64* %tls_align_factor, align 8
  store i64 %64, i64* getelementptr inbounds (%std.os.linux.tls.TLSImage, %std.os.linux.tls.TLSImage* @tls_image, i32 0, i32 2), align 8
  %65 = load i64, i64* %tcb_offset, align 8
  store i64 %65, i64* getelementptr inbounds (%std.os.linux.tls.TLSImage, %std.os.linux.tls.TLSImage* @tls_image, i32 0, i32 3), align 8
  %66 = load i64, i64* %dtv_offset, align 8
  store i64 %66, i64* getelementptr inbounds (%std.os.linux.tls.TLSImage, %std.os.linux.tls.TLSImage* @tls_image, i32 0, i32 4), align 8
  %67 = load i64, i64* %data_offset, align 8
  store i64 %67, i64* getelementptr inbounds (%std.os.linux.tls.TLSImage, %std.os.linux.tls.TLSImage* @tls_image, i32 0, i32 5), align 8
  %68 = load i64, i64* %tls_data_alloc_size, align 8
  store i64 %68, i64* getelementptr inbounds (%std.os.linux.tls.TLSImage, %std.os.linux.tls.TLSImage* @tls_image, i32 0, i32 6), align 8
  store i64 -1, i64* getelementptr inbounds (%std.os.linux.tls.TLSImage, %std.os.linux.tls.TLSImage* @tls_image, i32 0, i32 7), align 8
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.os.mmap({ %"[]u8", i16 }* nonnull sret({ %"[]u8", i16 }) %0, i8* align 4096 %1, i64 %2, i32 %3, i32 %4, i32 %5, i64 %6) unnamed_addr #1 {
Entry:
  %ioffset = alloca i64, align 8
  %rc = alloca i64, align 8
  %err = alloca i16, align 2
  %7 = alloca i8*, align 8
  %err10 = alloca i16, align 2
  %ptr = alloca i8*, align 8
  %length = alloca i64, align 8
  %prot = alloca i32, align 4
  %flags = alloca i32, align 4
  %fd = alloca i32, align 4
  %offset = alloca i64, align 8
  store i8* %1, i8** %ptr, align 8
  store i64 %2, i64* %length, align 8
  store i32 %3, i32* %prot, align 4
  store i32 %4, i32* %flags, align 4
  store i32 %5, i32* %fd, align 4
  store i64 %6, i64* %offset, align 8
  %8 = load i64, i64* %offset, align 8
  store i64 %8, i64* %ioffset, align 8
  %9 = load i8*, i8** %ptr, align 8
  %10 = load i64, i64* %length, align 8
  %11 = load i32, i32* %prot, align 4
  %12 = zext i32 %11 to i64
  %13 = load i32, i32* %flags, align 4
  %14 = load i32, i32* %fd, align 4
  %15 = load i64, i64* %ioffset, align 8
  %16 = call fastcc i64 @std.os.linux.mmap(i8* %9, i64 %10, i64 %12, i32 %13, i32 %14, i64 %15)
  store i64 %16, i64* %rc, align 8
  %17 = load i64, i64* %rc, align 8
  %18 = call fastcc i16 @std.os.linux.getErrno(i64 %17)
  store i16 %18, i16* %err, align 2
  %19 = load i16, i16* %err, align 2
  %20 = icmp eq i16 %19, 0
  br i1 %20, label %Then, label %Else

Then:                                             ; preds = %Entry
  %21 = load i64, i64* %rc, align 8
  %22 = inttoptr i64 %21 to i8*
  store i8* %22, i8** %7, align 8
  %23 = load i64, i64* %length, align 8
  %24 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %0, i32 0, i32 1
  store i16 0, i16* %24, align 2
  %25 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %0, i32 0, i32 0
  %26 = load i8*, i8** %7, align 8
  %27 = getelementptr inbounds i8, i8* %26, i64 0
  %28 = sub nuw i64 %23, 0
  %29 = getelementptr inbounds %"[]u8", %"[]u8"* %25, i32 0, i32 0
  store i8* %27, i8** %29, align 8
  %30 = getelementptr inbounds %"[]u8", %"[]u8"* %25, i32 0, i32 1
  store i64 %28, i64* %30, align 8
  ret void

Else:                                             ; preds = %Entry
  br label %EndIf

EndIf:                                            ; preds = %Else
  %31 = load i16, i16* %err, align 2
  store i16 %31, i16* %err10, align 2
  br label %BlockEnd

BlockEnd:                                         ; preds = %EndIf
  store i16 %31, i16* %err10, align 2
  %32 = load i16, i16* %err10, align 2
  switch i16 %32, label %SwitchElse [
    i16 0, label %SwitchProng
    i16 26, label %SwitchProng1
    i16 13, label %SwitchProng2
    i16 1, label %SwitchProng3
    i16 11, label %SwitchProng4
    i16 9, label %SwitchProng5
    i16 75, label %SwitchProng6
    i16 19, label %SwitchProng7
    i16 22, label %SwitchProng8
    i16 12, label %SwitchProng9
  ]

SwitchElse:                                       ; preds = %BlockEnd
  %33 = load i16, i16* %err10, align 2
  %34 = call fastcc i16 @std.os.unexpectedErrno(i16 %33)
  %35 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %0, i32 0, i32 1
  store i16 %34, i16* %35, align 2
  ret void

SwitchProng:                                      ; preds = %BlockEnd
  unreachable

SwitchProng1:                                     ; preds = %BlockEnd
  %36 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %0, i32 0, i32 1
  store i16 5, i16* %36, align 2
  ret void

SwitchProng2:                                     ; preds = %BlockEnd
  %37 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %0, i32 0, i32 1
  store i16 5, i16* %37, align 2
  ret void

SwitchProng3:                                     ; preds = %BlockEnd
  %38 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %0, i32 0, i32 1
  store i16 14, i16* %38, align 2
  ret void

SwitchProng4:                                     ; preds = %BlockEnd
  %39 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %0, i32 0, i32 1
  store i16 15, i16* %39, align 2
  ret void

SwitchProng5:                                     ; preds = %BlockEnd
  unreachable

SwitchProng6:                                     ; preds = %BlockEnd
  unreachable

SwitchProng7:                                     ; preds = %BlockEnd
  %40 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %0, i32 0, i32 1
  store i16 13, i16* %40, align 2
  ret void

SwitchProng8:                                     ; preds = %BlockEnd
  unreachable

SwitchProng9:                                     ; preds = %BlockEnd
  %41 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %0, i32 0, i32 1
  store i16 16, i16* %41, align 2
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i64 @std.mem.alignForward(i64 %0, i64 %1) unnamed_addr #1 {
Entry:
  %result = alloca i64, align 8
  %2 = alloca i64, align 8
  %3 = alloca i64, align 8
  %addr = alloca i64, align 8
  %alignment = alloca i64, align 8
  store i64 %0, i64* %addr, align 8
  store i64 %1, i64* %alignment, align 8
  %4 = load i64, i64* %addr, align 8
  store i64 %4, i64* %2, align 8
  %5 = load i64, i64* %alignment, align 8
  store i64 %5, i64* %3, align 8
  %6 = call fastcc i64 @std.mem.alignForwardGeneric(i64 %4, i64 %5)
  store i64 %6, i64* %result, align 8
  %7 = load i64, i64* %result, align 8
  ret i64 %7
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i64 @std.os.linux.tls.prepareTLS(%"[]u8"* nonnull readonly align 8 %0) unnamed_addr #1 {
Entry:
  %result = alloca i64, align 8
  %1 = alloca %"[]u8", align 8
  %2 = alloca i8*, align 8
  %dtv = alloca %std.os.linux.tls.DTV*, align 8
  %3 = alloca i8*, align 8
  %tcb_ptr = alloca i8**, align 8
  %4 = alloca %"[]u8", align 8
  %5 = alloca %"[]u8", align 8
  %6 = bitcast %"[]u8"* %0 to i8*
  %7 = bitcast %"[]u8"* %1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %7, i8* align 8 %6, i64 16, i1 false)
  call fastcc void @std.mem.set(%"[]u8"* %0, i8 0)
  %8 = getelementptr inbounds %"[]u8", %"[]u8"* %0, i32 0, i32 0
  %9 = load i8*, i8** %8, align 8
  %10 = load i64, i64* getelementptr inbounds (%std.os.linux.tls.TLSImage, %std.os.linux.tls.TLSImage* @tls_image, i32 0, i32 4), align 8
  %11 = getelementptr inbounds i8, i8* %9, i64 %10
  store i8* %11, i8** %2, align 8
  %12 = call fastcc %std.os.linux.tls.DTV* @std.os.linux.tls.alignPtrCast(i8* %11)
  store %std.os.linux.tls.DTV* %12, %std.os.linux.tls.DTV** %dtv, align 8
  %13 = load %std.os.linux.tls.DTV*, %std.os.linux.tls.DTV** %dtv, align 8
  %14 = getelementptr inbounds %std.os.linux.tls.DTV, %std.os.linux.tls.DTV* %13, i32 0, i32 0
  store i64 1, i64* %14, align 8
  %15 = load %std.os.linux.tls.DTV*, %std.os.linux.tls.DTV** %dtv, align 8
  %16 = getelementptr inbounds %std.os.linux.tls.DTV, %std.os.linux.tls.DTV* %15, i32 0, i32 1
  %17 = getelementptr inbounds [1 x i8*], [1 x i8*]* %16, i64 0, i64 0
  %18 = getelementptr inbounds %"[]u8", %"[]u8"* %0, i32 0, i32 0
  %19 = load i8*, i8** %18, align 8
  %20 = load i64, i64* getelementptr inbounds (%std.os.linux.tls.TLSImage, %std.os.linux.tls.TLSImage* @tls_image, i32 0, i32 5), align 8
  %21 = getelementptr inbounds i8, i8* %19, i64 %20
  store i8* %21, i8** %17, align 8
  %22 = getelementptr inbounds %"[]u8", %"[]u8"* %0, i32 0, i32 0
  %23 = load i8*, i8** %22, align 8
  %24 = load i64, i64* getelementptr inbounds (%std.os.linux.tls.TLSImage, %std.os.linux.tls.TLSImage* @tls_image, i32 0, i32 3), align 8
  %25 = getelementptr inbounds i8, i8* %23, i64 %24
  store i8* %25, i8** %3, align 8
  %26 = call fastcc i8** @std.os.linux.tls.alignPtrCast.22(i8* %25)
  store i8** %26, i8*** %tcb_ptr, align 8
  %27 = load i8**, i8*** %tcb_ptr, align 8
  %28 = getelementptr inbounds %"[]u8", %"[]u8"* %0, i32 0, i32 0
  %29 = load i8*, i8** %28, align 8
  %30 = load i64, i64* getelementptr inbounds (%std.os.linux.tls.TLSImage, %std.os.linux.tls.TLSImage* @tls_image, i32 0, i32 3), align 8
  %31 = getelementptr inbounds i8, i8* %29, i64 %30
  store i8* %31, i8** %27, align 8
  %32 = load i64, i64* getelementptr inbounds (%std.os.linux.tls.TLSImage, %std.os.linux.tls.TLSImage* @tls_image, i32 0, i32 5), align 8
  %33 = getelementptr inbounds %"[]u8", %"[]u8"* %0, i32 0, i32 1
  %34 = load i64, i64* %33, align 8
  %35 = getelementptr inbounds %"[]u8", %"[]u8"* %0, i32 0, i32 0
  %36 = load i8*, i8** %35, align 8
  %37 = getelementptr inbounds i8, i8* %36, i64 %32
  %38 = sub nuw i64 %34, %32
  %39 = getelementptr inbounds %"[]u8", %"[]u8"* %4, i32 0, i32 0
  store i8* %37, i8** %39, align 8
  %40 = getelementptr inbounds %"[]u8", %"[]u8"* %4, i32 0, i32 1
  store i64 %38, i64* %40, align 8
  %41 = bitcast %"[]u8"* %5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %41, i8* align 8 bitcast (%std.os.linux.tls.TLSImage* @tls_image to i8*), i64 16, i1 false)
  call fastcc void @std.mem.copy(%"[]u8"* %4, %"[]u8"* getelementptr inbounds (%std.os.linux.tls.TLSImage, %std.os.linux.tls.TLSImage* @tls_image, i32 0, i32 0))
  %42 = getelementptr inbounds %"[]u8", %"[]u8"* %0, i32 0, i32 0
  %43 = load i8*, i8** %42, align 8
  %44 = ptrtoint i8* %43 to i64
  %45 = add i64 %44, 0
  %46 = load i64, i64* getelementptr inbounds (%std.os.linux.tls.TLSImage, %std.os.linux.tls.TLSImage* @tls_image, i32 0, i32 3), align 8
  %47 = add i64 %45, %46
  store i64 %47, i64* %result, align 8
  %48 = load i64, i64* %result, align 8
  ret i64 %48
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.os.linux.tls.setThreadPointer(i64 %0) unnamed_addr #1 {
Entry:
  %rc = alloca i64, align 8
  %addr = alloca i64, align 8
  store i64 %0, i64* %addr, align 8
  %1 = load i64, i64* %addr, align 8
  %2 = call fastcc i64 @std.os.linux.x86_64.syscall2(i64 158, i64 4098, i64 %1)
  store i64 %2, i64* %rc, align 8
  %3 = load i64, i64* %rc, align 8
  %4 = icmp eq i64 %3, 0
  call fastcc void @std.debug.assert(i1 %4)
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.os.setrlimit(i32 %0, %std.os.linux.rlimit* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %2 = alloca i16, align 2
  %err = alloca i16, align 2
  %resource = alloca i32, align 4
  store i32 %0, i32* %resource, align 4
  %3 = load i32, i32* %resource, align 4
  %4 = call fastcc i64 @std.os.linux.setrlimit(i32 %3, %std.os.linux.rlimit* %1)
  %5 = call fastcc i16 @std.os.linux.getErrno(i64 %4)
  store i16 %5, i16* %2, align 2
  switch i16 %5, label %SwitchElse [
    i16 0, label %SwitchProng
    i16 14, label %SwitchProng1
    i16 22, label %SwitchProng2
    i16 1, label %SwitchProng3
  ]

SwitchElse:                                       ; preds = %Entry
  store i16 %5, i16* %err, align 2
  %6 = load i16, i16* %err, align 2
  %7 = call fastcc i16 @std.os.unexpectedErrno(i16 %6)
  store i16 %7, i16* %result, align 2
  %8 = load i16, i16* %result, align 2
  ret i16 %8

SwitchProng:                                      ; preds = %Entry
  store i16 0, i16* %result, align 2
  %9 = load i16, i16* %result, align 2
  ret i16 %9

SwitchProng1:                                     ; preds = %Entry
  unreachable

SwitchProng2:                                     ; preds = %Entry
  store i16 17, i16* %result, align 2
  %10 = load i16, i16* %result, align 2
  ret i16 %10

SwitchProng3:                                     ; preds = %Entry
  store i16 14, i16* %result, align 2
  %11 = load i16, i16* %result, align 2
  ret i16 %11
}

; Function Attrs: minsize nobuiltin noreturn nounwind optsize
define internal fastcc void @std.os.linux.exit_group(i32 %0) unnamed_addr #6 {
Entry:
  %status = alloca i32, align 4
  store i32 %0, i32* %status, align 4
  %1 = load i32, i32* %status, align 4
  %2 = sext i32 %1 to i64
  %3 = sext i32 %1 to i64
  %4 = call fastcc i64 @std.os.linux.x86_64.syscall1(i64 231, i64 %3)
  unreachable
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.debug.maybeEnableSegfaultHandler() unnamed_addr #1 {
Entry:
  ret void
}

; Function Attrs: alwaysinline minsize nobuiltin nounwind optsize
define internal fastcc i8 @std.start.initEventLoopAndCallMain() unnamed_addr #7 {
Entry:
  %result = alloca i8, align 1
  %0 = call fastcc i8 @std.start.callMain() #11
  store i8 %0, i8* %result, align 1
  %1 = load i8, i8* %result, align 1
  ret i8 %1
}

; Function Attrs: cold minsize nobuiltin nounwind optsize
define internal fastcc void @std.Thread.Mutex.AtomicMutex.lockSlow(%std.Thread.Mutex.AtomicMutex* nonnull align 4 %0, i32 %1) unnamed_addr #8 {
Entry:
  %new_state = alloca i32, align 4
  %spin = alloca i8, align 1
  %2 = alloca %"?std.Thread.Mutex.State", align 4
  %state = alloca i32, align 4
  %3 = alloca i8, align 1
  %iter = alloca i8, align 1
  %4 = alloca i32, align 4
  %5 = alloca i16, align 2
  %m = alloca %std.Thread.Mutex.AtomicMutex*, align 8
  %current_state = alloca i32, align 4
  store %std.Thread.Mutex.AtomicMutex* %0, %std.Thread.Mutex.AtomicMutex** %m, align 8
  store i32 %1, i32* %current_state, align 4
  %6 = load i32, i32* %current_state, align 4
  store i32 %6, i32* %new_state, align 4
  store i8 0, i8* %spin, align 1
  br label %WhileCond

WhileCond:                                        ; preds = %WhileEnd, %Entry
  %7 = load i8, i8* %spin, align 1
  %8 = icmp ult i8 %7, 100
  br i1 %8, label %WhileBody, label %WhileEnd5

WhileBody:                                        ; preds = %WhileCond
  %9 = load %std.Thread.Mutex.AtomicMutex*, %std.Thread.Mutex.AtomicMutex** %m, align 8
  %10 = getelementptr inbounds %std.Thread.Mutex.AtomicMutex, %std.Thread.Mutex.AtomicMutex* %9, i32 0, i32 0
  %11 = load i32, i32* %new_state, align 4
  %12 = cmpxchg weak i32* %10, i32 0, i32 %11 acquire monotonic, align 4
  %13 = extractvalue { i32, i1 } %12, 0
  %14 = getelementptr inbounds %"?std.Thread.Mutex.State", %"?std.Thread.Mutex.State"* %2, i32 0, i32 0
  store i32 %13, i32* %14, align 4
  %15 = extractvalue { i32, i1 } %12, 1
  %16 = xor i1 %15, true
  %17 = getelementptr inbounds %"?std.Thread.Mutex.State", %"?std.Thread.Mutex.State"* %2, i32 0, i32 1
  store i1 %16, i1* %17, align 1
  %18 = getelementptr inbounds %"?std.Thread.Mutex.State", %"?std.Thread.Mutex.State"* %2, i32 0, i32 1
  %19 = load i1, i1* %18, align 1
  br i1 %19, label %OptionalNonNull, label %OptionalNull

OptionalNull:                                     ; preds = %WhileBody
  ret void

OptionalNonNull:                                  ; preds = %WhileBody
  %20 = getelementptr inbounds %"?std.Thread.Mutex.State", %"?std.Thread.Mutex.State"* %2, i32 0, i32 0
  %21 = load i32, i32* %20, align 4
  store i32 %21, i32* %state, align 4
  br label %OptionalEnd

OptionalEnd:                                      ; preds = %OptionalNonNull
  %22 = load i32, i32* %state, align 4
  switch i32 %22, label %SwitchElse [
    i32 0, label %SwitchProng1
    i32 1, label %SwitchProng2
    i32 2, label %SwitchProng
  ]

SwitchProng:                                      ; preds = %OptionalEnd
  br label %WhileEnd5

SwitchElse:                                       ; preds = %OptionalEnd
  unreachable

SwitchProng1:                                     ; preds = %OptionalEnd
  br label %SwitchEnd

SwitchProng2:                                     ; preds = %OptionalEnd
  br label %SwitchEnd

SwitchEnd:                                        ; preds = %SwitchProng2, %SwitchProng1
  %23 = load i8, i8* %spin, align 1
  %24 = add nuw i8 %23, 1
  store i8 %24, i8* %3, align 1
  %25 = call fastcc i8 @std.math.min(i8 %24)
  store i8 %25, i8* %iter, align 1
  br label %WhileCond3

WhileCond3:                                       ; preds = %WhileBody4, %SwitchEnd
  %26 = load i8, i8* %iter, align 1
  %27 = icmp ugt i8 %26, 0
  br i1 %27, label %WhileBody4, label %WhileEnd

WhileBody4:                                       ; preds = %WhileCond3
  call fastcc void @std.atomic.spinLoopHint()
  %28 = load i8, i8* %iter, align 1
  %29 = sub nuw i8 %28, 1
  store i8 %29, i8* %iter, align 1
  br label %WhileCond3

WhileEnd:                                         ; preds = %WhileCond3
  %30 = load i8, i8* %spin, align 1
  %31 = add nuw i8 %30, 1
  store i8 %31, i8* %spin, align 1
  br label %WhileCond

WhileEnd5:                                        ; preds = %SwitchProng, %WhileCond
  store i32 2, i32* %new_state, align 4
  br label %WhileCond6

WhileCond6:                                       ; preds = %SwitchEnd15, %WhileEnd5
  br label %WhileBody7

WhileBody7:                                       ; preds = %WhileCond6
  %32 = load %std.Thread.Mutex.AtomicMutex*, %std.Thread.Mutex.AtomicMutex** %m, align 8
  %33 = getelementptr inbounds %std.Thread.Mutex.AtomicMutex, %std.Thread.Mutex.AtomicMutex* %32, i32 0, i32 0
  %34 = load i32, i32* %new_state, align 4
  %35 = atomicrmw xchg i32* %33, i32 %34 acquire, align 4
  store i32 %35, i32* %4, align 4
  switch i32 %35, label %SwitchElse9 [
    i32 0, label %SwitchProng8
  ]

SwitchProng8:                                     ; preds = %WhileBody7
  ret void

SwitchElse9:                                      ; preds = %WhileBody7
  br label %SwitchEnd10

SwitchEnd10:                                      ; preds = %SwitchElse9
  %36 = load %std.Thread.Mutex.AtomicMutex*, %std.Thread.Mutex.AtomicMutex** %m, align 8
  %37 = getelementptr inbounds %std.Thread.Mutex.AtomicMutex, %std.Thread.Mutex.AtomicMutex* %36, i32 0, i32 0
  %38 = load i32, i32* %new_state, align 4
  %39 = call fastcc i64 @std.os.linux.futex_wait(i32* %37, i32 128, i32 %38, %std.os.linux.timespec* null)
  %40 = call fastcc i16 @std.os.linux.getErrno(i64 %39)
  store i16 %40, i16* %5, align 2
  switch i16 %40, label %SwitchElse11 [
    i16 0, label %SwitchProng12
    i16 4, label %SwitchProng13
    i16 11, label %SwitchProng14
  ]

SwitchElse11:                                     ; preds = %SwitchEnd10
  unreachable

SwitchProng12:                                    ; preds = %SwitchEnd10
  br label %SwitchEnd15

SwitchProng13:                                    ; preds = %SwitchEnd10
  br label %SwitchEnd15

SwitchProng14:                                    ; preds = %SwitchEnd10
  br label %SwitchEnd15

SwitchEnd15:                                      ; preds = %SwitchProng14, %SwitchProng13, %SwitchProng12
  br label %WhileCond6
}

; Function Attrs: nofree nosync nounwind readnone speculatable willreturn
declare i64 @llvm.umin.i64(i64 %0, i64 %1) #9

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i64 @std.os.linux.write(i32 %0, i8* nonnull readonly align 1 %1, i64 %2) unnamed_addr #1 {
Entry:
  %result = alloca i64, align 8
  %fd = alloca i32, align 4
  %buf = alloca i8*, align 8
  %count = alloca i64, align 8
  store i32 %0, i32* %fd, align 4
  store i8* %1, i8** %buf, align 8
  store i64 %2, i64* %count, align 8
  %3 = load i32, i32* %fd, align 4
  %4 = sext i32 %3 to i64
  %5 = sext i32 %3 to i64
  %6 = load i8*, i8** %buf, align 8
  %7 = ptrtoint i8* %6 to i64
  %8 = load i64, i64* %count, align 8
  %9 = call fastcc i64 @std.os.linux.x86_64.syscall3(i64 1, i64 %5, i64 %7, i64 %8)
  store i64 %9, i64* %result, align 8
  %10 = load i64, i64* %result, align 8
  ret i64 %10
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.os.unexpectedErrno(i16 %0) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %err = alloca i16, align 2
  store i16 %0, i16* %err, align 2
  store i16 12, i16* %result, align 2
  %1 = load i16, i16* %result, align 2
  ret i16 %1
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i32 @std.os.linux.gettid() unnamed_addr #1 {
Entry:
  %result = alloca i32, align 4
  %0 = call fastcc i64 @std.os.linux.x86_64.syscall0(i64 186)
  %1 = trunc i64 %0 to i32
  store i32 %1, i32* %result, align 4
  %2 = load i32, i32* %result, align 4
  ret i32 %2
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).writeAll"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %0, %"[]u8"* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %index = alloca i64, align 8
  %2 = alloca %"[]u8", align 8
  %3 = alloca { i64, i16 }, align 8
  store i64 0, i64* %index, align 8
  br label %WhileCond

WhileCond:                                        ; preds = %ErrRetContinue, %Entry
  %4 = load i64, i64* %index, align 8
  %5 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 1
  %6 = load i64, i64* %5, align 8
  %7 = icmp ne i64 %4, %6
  br i1 %7, label %WhileBody, label %WhileEnd

WhileBody:                                        ; preds = %WhileCond
  %8 = load i64, i64* %index, align 8
  %9 = load i64, i64* %index, align 8
  %10 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 1
  %11 = load i64, i64* %10, align 8
  %12 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 0
  %13 = load i8*, i8** %12, align 8
  %14 = getelementptr inbounds i8, i8* %13, i64 %9
  %15 = sub nuw i64 %11, %9
  %16 = getelementptr inbounds %"[]u8", %"[]u8"* %2, i32 0, i32 0
  store i8* %14, i8** %16, align 8
  %17 = getelementptr inbounds %"[]u8", %"[]u8"* %2, i32 0, i32 1
  store i64 %15, i64* %17, align 8
  call fastcc void @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).write"({ i64, i16 }* sret({ i64, i16 }) %3, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0, %"[]u8"* %2)
  %18 = getelementptr inbounds { i64, i16 }, { i64, i16 }* %3, i32 0, i32 1
  %19 = load i16, i16* %18, align 2
  %20 = icmp ne i16 %19, 0
  br i1 %20, label %ErrRetReturn, label %ErrRetContinue

ErrRetReturn:                                     ; preds = %WhileBody
  %21 = getelementptr inbounds { i64, i16 }, { i64, i16 }* %3, i32 0, i32 1
  %22 = load i16, i16* %21, align 2
  store i16 %22, i16* %result, align 2
  ret i16 %22

ErrRetContinue:                                   ; preds = %WhileBody
  %23 = getelementptr inbounds { i64, i16 }, { i64, i16 }* %3, i32 0, i32 0
  %24 = load i64, i64* %23, align 8
  %25 = add nuw i64 %8, %24
  store i64 %25, i64* %index, align 8
  br label %WhileCond

WhileEnd:                                         ; preds = %WhileCond
  store i16 0, i16* %result, align 2
  ret i16 0
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.formatType(i64 %0, %std.fmt.FormatOptions* nonnull readonly align 8 %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %2, i64 %3) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %4 = alloca i64, align 8
  %5 = alloca %std.fmt.FormatOptions, align 8
  %6 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %value = alloca i64, align 8
  %max_depth = alloca i64, align 8
  store i64 %0, i64* %value, align 8
  store i64 %3, i64* %max_depth, align 8
  %7 = load i64, i64* %value, align 8
  store i64 %7, i64* %4, align 8
  %8 = bitcast %std.fmt.FormatOptions* %1 to i8*
  %9 = bitcast %std.fmt.FormatOptions* %5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %9, i8* align 8 %8, i64 40, i1 false)
  %10 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2 to i8*
  %11 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %6 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %11, i8* align 4 %10, i64 4, i1 false)
  %12 = call fastcc i16 @std.fmt.formatValue(i64 %7, %std.fmt.FormatOptions* %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2)
  store i16 %12, i16* %result, align 2
  %13 = load i16, i16* %result, align 2
  ret i16 %13
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).write"({ i64, i16 }* nonnull sret({ i64, i16 }) %0, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %1, %"[]u8"* nonnull readonly align 8 %2) unnamed_addr #1 {
Entry:
  %3 = getelementptr inbounds %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %1, i32 0, i32 0
  call fastcc void @std.fs.file.File.write({ i64, i16 }* sret({ i64, i16 }) %0, %std.fs.file.File* %3, %"[]u8"* %2)
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.formatValue(i64 %0, %std.fmt.FormatOptions* nonnull readonly align 8 %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %2) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %3 = alloca i64, align 8
  %4 = alloca %std.fmt.FormatOptions, align 8
  %5 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %value = alloca i64, align 8
  store i64 %0, i64* %value, align 8
  %6 = load i64, i64* %value, align 8
  store i64 %6, i64* %3, align 8
  %7 = bitcast %std.fmt.FormatOptions* %1 to i8*
  %8 = bitcast %std.fmt.FormatOptions* %4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %8, i8* align 8 %7, i64 40, i1 false)
  %9 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2 to i8*
  %10 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %10, i8* align 4 %9, i64 4, i1 false)
  %11 = call fastcc i16 @std.fmt.formatIntValue(i64 %6, %std.fmt.FormatOptions* %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2)
  store i16 %11, i16* %result, align 2
  %12 = load i16, i16* %result, align 2
  ret i16 %12
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i64 @std.os.linux.sigprocmask(i32 %0, [32 x i32]* noalias align 4 %1, [32 x i32]* noalias align 4 %2) unnamed_addr #1 {
Entry:
  %result = alloca i64, align 8
  %flags = alloca i32, align 4
  %set = alloca [32 x i32]*, align 8
  %oldset = alloca [32 x i32]*, align 8
  store i32 %0, i32* %flags, align 4
  store [32 x i32]* %1, [32 x i32]** %set, align 8
  store [32 x i32]* %2, [32 x i32]** %oldset, align 8
  %3 = load i32, i32* %flags, align 4
  %4 = zext i32 %3 to i64
  %5 = load [32 x i32]*, [32 x i32]** %set, align 8
  %6 = ptrtoint [32 x i32]* %5 to i64
  %7 = load [32 x i32]*, [32 x i32]** %oldset, align 8
  %8 = ptrtoint [32 x i32]* %7 to i64
  %9 = call fastcc i64 @std.os.linux.x86_64.syscall4(i64 14, i64 %4, i64 %6, i64 %8, i64 8)
  store i64 %9, i64* %result, align 8
  %10 = load i64, i64* %result, align 8
  ret i64 %10
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i64 @std.os.linux.tkill(i32 %0, i32 %1) unnamed_addr #1 {
Entry:
  %result = alloca i64, align 8
  %tid = alloca i32, align 4
  %sig = alloca i32, align 4
  store i32 %0, i32* %tid, align 4
  store i32 %1, i32* %sig, align 4
  %2 = load i32, i32* %tid, align 4
  %3 = sext i32 %2 to i64
  %4 = sext i32 %2 to i64
  %5 = load i32, i32* %sig, align 4
  %6 = sext i32 %5 to i64
  %7 = sext i32 %5 to i64
  %8 = call fastcc i64 @std.os.linux.x86_64.syscall2(i64 200, i64 %4, i64 %7)
  store i64 %8, i64* %result, align 8
  %9 = load i64, i64* %result, align 8
  ret i64 %9
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i1 @std.target.Arch.isSPARC(i6 %0) unnamed_addr #1 {
Entry:
  %result = alloca i1, align 1
  %arch = alloca i6, align 1
  store i6 %0, i6* %arch, align 1
  %1 = load i6, i6* %arch, align 1
  switch i6 %1, label %SwitchElse [
    i6 25, label %SwitchProng
    i6 27, label %SwitchProng
    i6 26, label %SwitchProng
  ]

SwitchElse:                                       ; preds = %Entry
  store i1 false, i1* %result, align 1
  br label %SwitchEnd

SwitchProng:                                      ; preds = %Entry, %Entry, %Entry
  store i1 true, i1* %result, align 1
  br label %SwitchEnd

SwitchEnd:                                        ; preds = %SwitchProng, %SwitchElse
  %2 = load i1, i1* %result, align 1
  ret i1 %2
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.formatType.19(%"[]u8"* nonnull readonly align 8 %0, %std.fmt.FormatOptions* nonnull readonly align 8 %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %2, i64 %3) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %4 = alloca %std.fmt.FormatOptions, align 8
  %5 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %max_depth = alloca i64, align 8
  store i64 %3, i64* %max_depth, align 8
  %6 = load i64, i64* %max_depth, align 8
  %7 = icmp eq i64 %6, 0
  br i1 %7, label %Then, label %Else

Then:                                             ; preds = %Entry
  %8 = call fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).writeAll"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2, %"[]u8"* @27)
  store i16 %8, i16* %result, align 2
  %9 = load i16, i16* %result, align 2
  ret i16 %9

Else:                                             ; preds = %Entry
  br label %EndIf

EndIf:                                            ; preds = %Else
  %10 = bitcast %std.fmt.FormatOptions* %1 to i8*
  %11 = bitcast %std.fmt.FormatOptions* %4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %11, i8* align 8 %10, i64 40, i1 false)
  %12 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2 to i8*
  %13 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %13, i8* align 4 %12, i64 4, i1 false)
  %14 = call fastcc i16 @std.fmt.formatText(%"[]u8"* %0, %std.fmt.FormatOptions* %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2)
  store i16 %14, i16* %result, align 2
  %15 = load i16, i16* %result, align 2
  ret i16 %15
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.formatText(%"[]u8"* nonnull readonly align 8 %0, %std.fmt.FormatOptions* nonnull readonly align 8 %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %2) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %3 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %4 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2 to i8*
  %5 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %5, i8* align 4 %4, i64 4, i1 false)
  %6 = call fastcc i16 @std.fmt.formatBuf(%"[]u8"* %0, %std.fmt.FormatOptions* %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2)
  store i16 %6, i16* %result, align 2
  %7 = load i16, i16* %result, align 2
  ret i16 %7
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.format.20(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %0) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %options = alloca %std.fmt.FormatOptions, align 8
  %1 = alloca i16, align 2
  %2 = bitcast %std.fmt.FormatOptions* %options to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %2, i8* align 8 bitcast ({ %"?usize", %"?usize", i2, <{ i8, [6 x i8] }> }* @35 to i8*), i64 40, i1 false)
  %3 = call fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).writeAll"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0, %"[]u8"* @37)
  store i16 %3, i16* %1, align 2
  %4 = icmp ne i16 %3, 0
  br i1 %4, label %ErrRetReturn, label %ErrRetContinue

ErrRetReturn:                                     ; preds = %Entry
  %5 = load i16, i16* %1, align 2
  store i16 %5, i16* %result, align 2
  ret i16 %5

ErrRetContinue:                                   ; preds = %Entry
  store i16 0, i16* %result, align 2
  ret i16 0
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.format.21(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %0) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %options = alloca %std.fmt.FormatOptions, align 8
  %1 = alloca i16, align 2
  %2 = bitcast %std.fmt.FormatOptions* %options to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %2, i8* align 8 bitcast ({ %"?usize", %"?usize", i2, <{ i8, [6 x i8] }> }* @38 to i8*), i64 40, i1 false)
  %3 = call fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).writeAll"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0, %"[]u8"* @39)
  store i16 %3, i16* %1, align 2
  %4 = icmp ne i16 %3, 0
  br i1 %4, label %ErrRetReturn, label %ErrRetContinue

ErrRetReturn:                                     ; preds = %Entry
  %5 = load i16, i16* %1, align 2
  store i16 %5, i16* %result, align 2
  ret i16 %5

ErrRetContinue:                                   ; preds = %Entry
  store i16 0, i16* %result, align 2
  ret i16 0
}

; Function Attrs: cold minsize nobuiltin nounwind optsize
define internal fastcc void @std.Thread.Mutex.AtomicMutex.unlockSlow(%std.Thread.Mutex.AtomicMutex* nonnull align 4 %0) unnamed_addr #8 {
Entry:
  %1 = alloca i16, align 2
  %m = alloca %std.Thread.Mutex.AtomicMutex*, align 8
  store %std.Thread.Mutex.AtomicMutex* %0, %std.Thread.Mutex.AtomicMutex** %m, align 8
  %2 = load %std.Thread.Mutex.AtomicMutex*, %std.Thread.Mutex.AtomicMutex** %m, align 8
  %3 = getelementptr inbounds %std.Thread.Mutex.AtomicMutex, %std.Thread.Mutex.AtomicMutex* %2, i32 0, i32 0
  %4 = call fastcc i64 @std.os.linux.futex_wake(i32* %3, i32 129, i32 1)
  %5 = call fastcc i16 @std.os.linux.getErrno(i64 %4)
  store i16 %5, i16* %1, align 2
  switch i16 %5, label %SwitchElse [
    i16 0, label %SwitchProng1
    i16 14, label %SwitchProng
  ]

SwitchElse:                                       ; preds = %Entry
  unreachable

SwitchProng:                                      ; preds = %Entry
  unreachable

SwitchProng1:                                     ; preds = %Entry
  br label %SwitchEnd

SwitchEnd:                                        ; preds = %SwitchProng1
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i1 @std.Thread.StaticResetEvent.AtomicEvent.timedWait(%std.Thread.StaticResetEvent.AtomicEvent* nonnull align 4 %0, %"?u64"* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %result = alloca i1, align 1
  %waiters = alloca i32, align 4
  %2 = alloca %"?u32", align 4
  %3 = alloca i16, align 2
  %_ = alloca i16, align 2
  %ev = alloca %std.Thread.StaticResetEvent.AtomicEvent*, align 8
  store %std.Thread.StaticResetEvent.AtomicEvent* %0, %std.Thread.StaticResetEvent.AtomicEvent** %ev, align 8
  %4 = load %std.Thread.StaticResetEvent.AtomicEvent*, %std.Thread.StaticResetEvent.AtomicEvent** %ev, align 8
  %5 = getelementptr inbounds %std.Thread.StaticResetEvent.AtomicEvent, %std.Thread.StaticResetEvent.AtomicEvent* %4, i32 0, i32 0
  %6 = load atomic i32, i32* %5 acquire, align 4
  store i32 %6, i32* %waiters, align 4
  br label %WhileCond

WhileCond:                                        ; preds = %OptionalEnd, %Entry
  %7 = load i32, i32* %waiters, align 4
  %8 = icmp ne i32 %7, 1
  br i1 %8, label %WhileBody, label %WhileEnd

WhileBody:                                        ; preds = %WhileCond
  %9 = load %std.Thread.StaticResetEvent.AtomicEvent*, %std.Thread.StaticResetEvent.AtomicEvent** %ev, align 8
  %10 = getelementptr inbounds %std.Thread.StaticResetEvent.AtomicEvent, %std.Thread.StaticResetEvent.AtomicEvent* %9, i32 0, i32 0
  %11 = load i32, i32* %waiters, align 4
  %12 = load i32, i32* %waiters, align 4
  %13 = add nuw i32 %12, 2
  %14 = cmpxchg weak i32* %10, i32 %11, i32 %13 acquire acquire, align 4
  %15 = extractvalue { i32, i1 } %14, 0
  %16 = getelementptr inbounds %"?u32", %"?u32"* %2, i32 0, i32 0
  store i32 %15, i32* %16, align 4
  %17 = extractvalue { i32, i1 } %14, 1
  %18 = xor i1 %17, true
  %19 = getelementptr inbounds %"?u32", %"?u32"* %2, i32 0, i32 1
  store i1 %18, i1* %19, align 1
  %20 = getelementptr inbounds %"?u32", %"?u32"* %2, i32 0, i32 1
  %21 = load i1, i1* %20, align 1
  br i1 %21, label %OptionalNonNull, label %OptionalNull

OptionalNull:                                     ; preds = %WhileBody
  %22 = load %std.Thread.StaticResetEvent.AtomicEvent*, %std.Thread.StaticResetEvent.AtomicEvent** %ev, align 8
  %23 = getelementptr inbounds %std.Thread.StaticResetEvent.AtomicEvent, %std.Thread.StaticResetEvent.AtomicEvent* %22, i32 0, i32 0
  %24 = call fastcc i16 @std.Thread.StaticResetEvent.LinuxFutex.wait(i32* %23, %"?u64"* %1)
  store i16 %24, i16* %3, align 2
  %25 = icmp ne i16 %24, 0
  br i1 %25, label %TryElse, label %TryOk

TryOk:                                            ; preds = %OptionalNull
  store i1 false, i1* %result, align 1
  %26 = load i1, i1* %result, align 1
  ret i1 %26

TryElse:                                          ; preds = %OptionalNull
  %27 = load i16, i16* %3, align 2
  store i16 %27, i16* %_, align 2
  store i1 true, i1* %result, align 1
  %28 = load i1, i1* %result, align 1
  ret i1 %28

OptionalNonNull:                                  ; preds = %WhileBody
  %29 = getelementptr inbounds %"?u32", %"?u32"* %2, i32 0, i32 0
  %30 = load i32, i32* %29, align 4
  store i32 %30, i32* %waiters, align 4
  br label %OptionalEnd

OptionalEnd:                                      ; preds = %OptionalNonNull
  br label %WhileCond

WhileEnd:                                         ; preds = %WhileCond
  store i1 false, i1* %result, align 1
  %31 = load i1, i1* %result, align 1
  ret i1 %31
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i64 @std.os.linux.mmap(i8* align 1 %0, i64 %1, i64 %2, i32 %3, i32 %4, i64 %5) unnamed_addr #1 {
Entry:
  %result = alloca i64, align 8
  %address = alloca i8*, align 8
  %length = alloca i64, align 8
  %prot = alloca i64, align 8
  %flags = alloca i32, align 4
  %fd = alloca i32, align 4
  %offset = alloca i64, align 8
  store i8* %0, i8** %address, align 8
  store i64 %1, i64* %length, align 8
  store i64 %2, i64* %prot, align 8
  store i32 %3, i32* %flags, align 4
  store i32 %4, i32* %fd, align 4
  store i64 %5, i64* %offset, align 8
  %6 = load i8*, i8** %address, align 8
  %7 = ptrtoint i8* %6 to i64
  %8 = load i64, i64* %length, align 8
  %9 = load i64, i64* %prot, align 8
  %10 = load i32, i32* %flags, align 4
  %11 = zext i32 %10 to i64
  %12 = load i32, i32* %fd, align 4
  %13 = sext i32 %12 to i64
  %14 = sext i32 %12 to i64
  %15 = load i64, i64* %offset, align 8
  %16 = call fastcc i64 @std.os.linux.x86_64.syscall6(i64 9, i64 %7, i64 %8, i64 %9, i64 %11, i64 %14, i64 %15)
  store i64 %16, i64* %result, align 8
  %17 = load i64, i64* %result, align 8
  ret i64 %17
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i64 @std.mem.alignForwardGeneric(i64 %0, i64 %1) unnamed_addr #1 {
Entry:
  %result = alloca i64, align 8
  %2 = alloca i64, align 8
  %3 = alloca i64, align 8
  %addr = alloca i64, align 8
  %alignment = alloca i64, align 8
  store i64 %0, i64* %addr, align 8
  store i64 %1, i64* %alignment, align 8
  %4 = load i64, i64* %addr, align 8
  %5 = load i64, i64* %alignment, align 8
  %6 = sub nuw i64 %5, 1
  %7 = add nuw i64 %4, %6
  store i64 %7, i64* %2, align 8
  %8 = load i64, i64* %alignment, align 8
  store i64 %8, i64* %3, align 8
  %9 = call fastcc i64 @std.mem.alignBackwardGeneric(i64 %7, i64 %8)
  store i64 %9, i64* %result, align 8
  %10 = load i64, i64* %result, align 8
  ret i64 %10
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.mem.set(%"[]u8"* nonnull readonly align 8 %0, i8 %1) unnamed_addr #1 {
Entry:
  %i = alloca i64, align 8
  %d = alloca i8*, align 8
  %value = alloca i8, align 1
  store i8 %1, i8* %value, align 1
  store i64 0, i64* %i, align 8
  %2 = getelementptr inbounds %"[]u8", %"[]u8"* %0, i32 0, i32 1
  %3 = load i64, i64* %2, align 8
  br label %ForCond

ForCond:                                          ; preds = %ForBody, %Entry
  %4 = load i64, i64* %i, align 8
  %5 = icmp ult i64 %4, %3
  br i1 %5, label %ForBody, label %ForEnd

ForBody:                                          ; preds = %ForCond
  %6 = getelementptr inbounds %"[]u8", %"[]u8"* %0, i32 0, i32 0
  %7 = load i8*, i8** %6, align 8
  %8 = getelementptr inbounds i8, i8* %7, i64 %4
  store i8* %8, i8** %d, align 8
  %9 = load i8*, i8** %d, align 8
  %10 = load i8, i8* %value, align 1
  store i8 %10, i8* %9, align 1
  %11 = add nuw i64 %4, 1
  store i64 %11, i64* %i, align 8
  br label %ForCond

ForEnd:                                           ; preds = %ForCond
  ret void
}

; Function Attrs: alwaysinline minsize nobuiltin nounwind optsize
define internal fastcc nonnull %std.os.linux.tls.DTV* @std.os.linux.tls.alignPtrCast(i8* nonnull align 1 %0) unnamed_addr #7 {
Entry:
  %result = alloca %std.os.linux.tls.DTV*, align 8
  %ptr = alloca i8*, align 8
  store i8* %0, i8** %ptr, align 8
  %1 = load i8*, i8** %ptr, align 8
  %2 = bitcast i8* %1 to %std.os.linux.tls.DTV*
  store %std.os.linux.tls.DTV* %2, %std.os.linux.tls.DTV** %result, align 8
  %3 = load %std.os.linux.tls.DTV*, %std.os.linux.tls.DTV** %result, align 8
  ret %std.os.linux.tls.DTV* %3
}

; Function Attrs: alwaysinline minsize nobuiltin nounwind optsize
define internal fastcc nonnull i8** @std.os.linux.tls.alignPtrCast.22(i8* nonnull align 1 %0) unnamed_addr #7 {
Entry:
  %result = alloca i8**, align 8
  %ptr = alloca i8*, align 8
  store i8* %0, i8** %ptr, align 8
  %1 = load i8*, i8** %ptr, align 8
  %2 = bitcast i8* %1 to i8**
  store i8** %2, i8*** %result, align 8
  %3 = load i8**, i8*** %result, align 8
  ret i8** %3
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.mem.copy(%"[]u8"* nonnull readonly align 8 %0, %"[]u8"* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %i = alloca i64, align 8
  %s = alloca i8, align 1
  %2 = getelementptr inbounds %"[]u8", %"[]u8"* %0, i32 0, i32 1
  %3 = load i64, i64* %2, align 8
  %4 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 1
  %5 = load i64, i64* %4, align 8
  %6 = icmp uge i64 %3, %5
  call fastcc void @std.debug.assert(i1 %6)
  store i64 0, i64* %i, align 8
  %7 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 1
  %8 = load i64, i64* %7, align 8
  br label %ForCond

ForCond:                                          ; preds = %ForBody, %Entry
  %9 = load i64, i64* %i, align 8
  %10 = icmp ult i64 %9, %8
  br i1 %10, label %ForBody, label %ForEnd

ForBody:                                          ; preds = %ForCond
  %11 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 0
  %12 = load i8*, i8** %11, align 8
  %13 = getelementptr inbounds i8, i8* %12, i64 %9
  %14 = load i8, i8* %13, align 1
  store i8 %14, i8* %s, align 1
  %15 = load i64, i64* %i, align 8
  %16 = getelementptr inbounds %"[]u8", %"[]u8"* %0, i32 0, i32 0
  %17 = load i8*, i8** %16, align 8
  %18 = getelementptr inbounds i8, i8* %17, i64 %15
  %19 = load i8, i8* %s, align 1
  store i8 %19, i8* %18, align 1
  %20 = add nuw i64 %9, 1
  store i64 %20, i64* %i, align 8
  br label %ForCond

ForEnd:                                           ; preds = %ForCond
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i64 @std.os.linux.setrlimit(i32 %0, %std.os.linux.rlimit* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %result = alloca i64, align 8
  %resource = alloca i32, align 4
  %rlim = alloca %std.os.linux.rlimit*, align 8
  store i32 %0, i32* %resource, align 4
  store %std.os.linux.rlimit* %1, %std.os.linux.rlimit** %rlim, align 8
  %2 = load i32, i32* %resource, align 4
  %3 = load %std.os.linux.rlimit*, %std.os.linux.rlimit** %rlim, align 8
  %4 = call fastcc i64 @std.os.linux.prlimit(i32 0, i32 %2, %std.os.linux.rlimit* %3, %std.os.linux.rlimit* null)
  store i64 %4, i64* %result, align 8
  %5 = load i64, i64* %result, align 8
  ret i64 %5
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i8 @std.start.callMain() unnamed_addr #1 {
Entry:
  %result = alloca i8, align 1
  call fastcc void @main()
  store i8 0, i8* %result, align 1
  %0 = load i8, i8* %result, align 1
  ret i8 %0
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i8 @std.math.min(i8 %0) unnamed_addr #1 {
Entry:
  %result = alloca i8, align 1
  %y = alloca i8, align 1
  store i8 %0, i8* %y, align 1
  %1 = load i8, i8* %y, align 1
  %2 = icmp ult i8 32, %1
  br i1 %2, label %Then, label %Else

Then:                                             ; preds = %Entry
  store i8 32, i8* %result, align 1
  %3 = load i8, i8* %result, align 1
  ret i8 %3

Else:                                             ; preds = %Entry
  %4 = load i8, i8* %y, align 1
  store i8 %4, i8* %result, align 1
  %5 = load i8, i8* %result, align 1
  ret i8 %5
}

; Function Attrs: alwaysinline minsize nobuiltin nounwind optsize
define internal fastcc void @std.atomic.spinLoopHint() unnamed_addr #7 {
Entry:
  call void asm sideeffect "pause", "~{memory},~{dirflag},~{fpsr},~{flags}"()
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i64 @std.os.linux.futex_wait(i32* nonnull readonly align 4 %0, i32 %1, i32 %2, %std.os.linux.timespec* align 8 %3) unnamed_addr #1 {
Entry:
  %result = alloca i64, align 8
  %uaddr = alloca i32*, align 8
  %futex_op = alloca i32, align 4
  %val = alloca i32, align 4
  %timeout = alloca %std.os.linux.timespec*, align 8
  store i32* %0, i32** %uaddr, align 8
  store i32 %1, i32* %futex_op, align 4
  store i32 %2, i32* %val, align 4
  store %std.os.linux.timespec* %3, %std.os.linux.timespec** %timeout, align 8
  %4 = load i32*, i32** %uaddr, align 8
  %5 = ptrtoint i32* %4 to i64
  %6 = load i32, i32* %futex_op, align 4
  %7 = zext i32 %6 to i64
  %8 = load i32, i32* %val, align 4
  %9 = zext i32 %8 to i64
  %10 = load %std.os.linux.timespec*, %std.os.linux.timespec** %timeout, align 8
  %11 = ptrtoint %std.os.linux.timespec* %10 to i64
  %12 = call fastcc i64 @std.os.linux.x86_64.syscall4(i64 202, i64 %5, i64 %7, i64 %9, i64 %11)
  store i64 %12, i64* %result, align 8
  %13 = load i64, i64* %result, align 8
  ret i64 %13
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.formatIntValue(i64 %0, %std.fmt.FormatOptions* nonnull readonly align 8 %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %2) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %int_value = alloca i64, align 8
  %3 = alloca i64, align 8
  %4 = alloca %std.fmt.FormatOptions, align 8
  %5 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %value = alloca i64, align 8
  store i64 %0, i64* %value, align 8
  %6 = load i64, i64* %value, align 8
  store i64 %6, i64* %int_value, align 8
  %7 = load i64, i64* %int_value, align 8
  store i64 %7, i64* %3, align 8
  %8 = bitcast %std.fmt.FormatOptions* %1 to i8*
  %9 = bitcast %std.fmt.FormatOptions* %4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %9, i8* align 8 %8, i64 40, i1 false)
  %10 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2 to i8*
  %11 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %11, i8* align 4 %10, i64 4, i1 false)
  %12 = call fastcc i16 @std.fmt.formatInt(i64 %7, i8 10, i1 false, %std.fmt.FormatOptions* %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2)
  store i16 %12, i16* %result, align 2
  %13 = load i16, i16* %result, align 2
  ret i16 %13
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.formatInt(i64 %0, i8 %1, i1 %2, %std.fmt.FormatOptions* nonnull readonly align 8 %3, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %4) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %int_value = alloca i64, align 8
  %5 = alloca i64, align 8
  %abs_value = alloca i64, align 8
  %buf = alloca [65 x i8], align 1
  %a = alloca i64, align 8
  %index = alloca i64, align 8
  %digit = alloca i64, align 8
  %6 = alloca %"[]u8", align 8
  %7 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %value = alloca i64, align 8
  %base = alloca i8, align 1
  %case = alloca i1, align 1
  store i64 %0, i64* %value, align 8
  store i8 %1, i8* %base, align 1
  store i1 %2, i1* %case, align 1
  %8 = load i8, i8* %base, align 1
  %9 = icmp uge i8 %8, 2
  call fastcc void @std.debug.assert(i1 %9)
  %10 = load i64, i64* %value, align 8
  store i64 %10, i64* %int_value, align 8
  %11 = load i64, i64* %int_value, align 8
  store i64 %11, i64* %5, align 8
  %12 = call fastcc i64 @std.math.absCast(i64 %11)
  store i64 %12, i64* %abs_value, align 8
  %13 = load i64, i64* %abs_value, align 8
  store i64 %13, i64* %a, align 8
  store i64 65, i64* %index, align 8
  br label %WhileCond

WhileCond:                                        ; preds = %EndIf, %Entry
  br label %WhileBody

WhileBody:                                        ; preds = %WhileCond
  %14 = load i64, i64* %a, align 8
  %15 = load i8, i8* %base, align 1
  %16 = zext i8 %15 to i64
  %17 = urem i64 %14, %16
  store i64 %17, i64* %digit, align 8
  %18 = load i64, i64* %index, align 8
  %19 = sub nuw i64 %18, 1
  store i64 %19, i64* %index, align 8
  %20 = load i64, i64* %index, align 8
  %21 = getelementptr inbounds [65 x i8], [65 x i8]* %buf, i64 0, i64 %20
  %22 = load i64, i64* %digit, align 8
  %23 = trunc i64 %22 to i8
  %24 = load i1, i1* %case, align 1
  %25 = call fastcc i8 @std.fmt.digitToChar(i8 %23, i1 %24)
  store i8 %25, i8* %21, align 1
  %26 = load i64, i64* %a, align 8
  %27 = load i8, i8* %base, align 1
  %28 = zext i8 %27 to i64
  %29 = udiv i64 %26, %28
  store i64 %29, i64* %a, align 8
  %30 = load i64, i64* %a, align 8
  %31 = icmp eq i64 %30, 0
  br i1 %31, label %Then, label %Else

Then:                                             ; preds = %WhileBody
  br label %WhileEnd

Else:                                             ; preds = %WhileBody
  br label %EndIf

EndIf:                                            ; preds = %Else
  br label %WhileCond

WhileEnd:                                         ; preds = %Then
  %32 = load i64, i64* %index, align 8
  %33 = getelementptr inbounds [65 x i8], [65 x i8]* %buf, i64 0, i64 %32
  %34 = sub nuw i64 65, %32
  %35 = getelementptr inbounds %"[]u8", %"[]u8"* %6, i32 0, i32 0
  store i8* %33, i8** %35, align 8
  %36 = getelementptr inbounds %"[]u8", %"[]u8"* %6, i32 0, i32 1
  store i64 %34, i64* %36, align 8
  %37 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %4 to i8*
  %38 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %7 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %38, i8* align 4 %37, i64 4, i1 false)
  %39 = call fastcc i16 @std.fmt.formatBuf(%"[]u8"* %6, %std.fmt.FormatOptions* %3, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %4)
  store i16 %39, i16* %result, align 2
  %40 = load i16, i16* %result, align 2
  ret i16 %40
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i64 @std.math.absCast(i64 %0) unnamed_addr #1 {
Entry:
  %result = alloca i64, align 8
  %x = alloca i64, align 8
  store i64 %0, i64* %x, align 8
  %1 = load i64, i64* %x, align 8
  store i64 %1, i64* %result, align 8
  %2 = load i64, i64* %result, align 8
  ret i64 %2
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i8 @std.fmt.digitToChar(i8 %0, i1 %1) unnamed_addr #1 {
Entry:
  %result = alloca i8, align 1
  %2 = alloca i8, align 1
  %digit = alloca i8, align 1
  %case = alloca i1, align 1
  store i8 %0, i8* %digit, align 1
  store i1 %1, i1* %case, align 1
  %3 = load i8, i8* %digit, align 1
  %4 = icmp ule i8 %3, 9
  %5 = and i1 true, %4
  br i1 %5, label %SwitchRangeYes, label %SwitchRangeNo

SwitchRangeYes:                                   ; preds = %Entry
  %6 = load i8, i8* %digit, align 1
  %7 = add nuw i8 %6, 48
  store i8 %7, i8* %result, align 1
  br label %SwitchEnd

SwitchRangeNo:                                    ; preds = %Entry
  %8 = icmp uge i8 %3, 10
  %9 = icmp ule i8 %3, 35
  %10 = and i1 %8, %9
  br i1 %10, label %SwitchRangeYes1, label %SwitchRangeNo2

SwitchRangeYes1:                                  ; preds = %SwitchRangeNo
  %11 = load i8, i8* %digit, align 1
  %12 = load i1, i1* %case, align 1
  %13 = icmp eq i1 %12, true
  br i1 %13, label %Then, label %Else

Then:                                             ; preds = %SwitchRangeYes1
  store i8 65, i8* %2, align 1
  store i8 65, i8* %2, align 1
  br label %EndIf

Else:                                             ; preds = %SwitchRangeYes1
  store i8 97, i8* %2, align 1
  store i8 97, i8* %2, align 1
  br label %EndIf

EndIf:                                            ; preds = %Else, %Then
  %14 = phi i8 [ 65, %Then ], [ 97, %Else ]
  %15 = sub nuw i8 %14, 10
  %16 = add nuw i8 %11, %15
  store i8 %16, i8* %result, align 1
  br label %SwitchEnd

SwitchRangeNo2:                                   ; preds = %SwitchRangeNo
  br label %SwitchElse

SwitchElse:                                       ; preds = %SwitchRangeNo2
  unreachable

SwitchEnd:                                        ; preds = %EndIf, %SwitchRangeYes
  %17 = load i8, i8* %result, align 1
  ret i8 %17
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.formatBuf(%"[]u8"* nonnull readonly align 8 %0, %std.fmt.FormatOptions* nonnull readonly align 8 %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %2) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %min_width = alloca i64, align 8
  %3 = alloca { i64, i16 }, align 8
  %width = alloca i64, align 8
  %padding = alloca i64, align 8
  %4 = alloca i16, align 2
  %5 = alloca i16, align 2
  %left_padding = alloca i64, align 8
  %right_padding = alloca i64, align 8
  %6 = alloca i16, align 2
  %7 = alloca i16, align 2
  %8 = alloca i16, align 2
  %9 = alloca i16, align 2
  %10 = alloca i16, align 2
  %11 = alloca i16, align 2
  %12 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %1, i32 0, i32 1
  %13 = getelementptr inbounds %"?usize", %"?usize"* %12, i32 0, i32 1
  %14 = load i1, i1* %13, align 1
  br i1 %14, label %OptionalThen, label %OptionalElse

OptionalThen:                                     ; preds = %Entry
  %15 = getelementptr inbounds %"?usize", %"?usize"* %12, i32 0, i32 0
  %16 = load i64, i64* %15, align 8
  store i64 %16, i64* %min_width, align 8
  call fastcc void @std.unicode.utf8CountCodepoints({ i64, i16 }* sret({ i64, i16 }) %3, %"[]u8"* %0)
  %17 = getelementptr inbounds { i64, i16 }, { i64, i16 }* %3, i32 0, i32 1
  %18 = load i16, i16* %17, align 2
  %19 = icmp ne i16 %18, 0
  br i1 %19, label %UnwrapErrError, label %UnwrapErrOk

UnwrapErrError:                                   ; preds = %OptionalThen
  %20 = getelementptr inbounds %"[]u8", %"[]u8"* %0, i32 0, i32 1
  %21 = load i64, i64* %20, align 8
  store i64 %21, i64* %width, align 8
  br label %UnwrapErrEnd

UnwrapErrOk:                                      ; preds = %OptionalThen
  %22 = getelementptr inbounds { i64, i16 }, { i64, i16 }* %3, i32 0, i32 0
  %23 = load i64, i64* %22, align 8
  store i64 %23, i64* %width, align 8
  br label %UnwrapErrEnd

UnwrapErrEnd:                                     ; preds = %UnwrapErrOk, %UnwrapErrError
  %24 = load i64, i64* %width, align 8
  %25 = load i64, i64* %min_width, align 8
  %26 = icmp ult i64 %24, %25
  br i1 %26, label %Then, label %Else

Then:                                             ; preds = %UnwrapErrEnd
  %27 = load i64, i64* %min_width, align 8
  %28 = load i64, i64* %width, align 8
  %29 = sub nuw i64 %27, %28
  store i64 %29, i64* %padding, align 8
  br label %EndIf

Else:                                             ; preds = %UnwrapErrEnd
  store i64 0, i64* %padding, align 8
  br label %EndIf

EndIf:                                            ; preds = %Else, %Then
  %30 = load i64, i64* %padding, align 8
  %31 = icmp eq i64 %30, 0
  br i1 %31, label %Then1, label %Else2

Then1:                                            ; preds = %EndIf
  %32 = call fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).writeAll"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2, %"[]u8"* %0)
  store i16 %32, i16* %result, align 2
  %33 = load i16, i16* %result, align 2
  ret i16 %33

Else2:                                            ; preds = %EndIf
  br label %EndIf3

EndIf3:                                           ; preds = %Else2
  %34 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %1, i32 0, i32 2
  %35 = load i2, i2* %34, align 1
  switch i2 %35, label %SwitchElse [
    i2 0, label %SwitchProng
    i2 1, label %SwitchProng5
    i2 -2, label %SwitchProng11
  ]

SwitchProng:                                      ; preds = %EndIf3
  %36 = call fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).writeAll"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2, %"[]u8"* %0)
  store i16 %36, i16* %4, align 2
  %37 = icmp ne i16 %36, 0
  br i1 %37, label %ErrRetReturn, label %ErrRetContinue

ErrRetReturn:                                     ; preds = %SwitchProng
  %38 = load i16, i16* %4, align 2
  store i16 %38, i16* %result, align 2
  ret i16 %38

ErrRetContinue:                                   ; preds = %SwitchProng
  %39 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %1, i32 0, i32 3
  %40 = load i8, i8* %39, align 1
  %41 = load i64, i64* %padding, align 8
  %42 = call fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).writeByteNTimes"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2, i8 %40, i64 %41)
  store i16 %42, i16* %5, align 2
  %43 = icmp ne i16 %42, 0
  br i1 %43, label %ErrRetReturn4, label %ErrRetContinue15

ErrRetReturn4:                                    ; preds = %ErrRetContinue
  %44 = load i16, i16* %5, align 2
  store i16 %44, i16* %result, align 2
  ret i16 %44

SwitchProng5:                                     ; preds = %EndIf3
  %45 = load i64, i64* %padding, align 8
  %46 = udiv i64 %45, 2
  store i64 %46, i64* %left_padding, align 8
  %47 = load i64, i64* %padding, align 8
  %48 = add nuw i64 %47, 1
  %49 = udiv i64 %48, 2
  store i64 %49, i64* %right_padding, align 8
  %50 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %1, i32 0, i32 3
  %51 = load i8, i8* %50, align 1
  %52 = load i64, i64* %left_padding, align 8
  %53 = call fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).writeByteNTimes"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2, i8 %51, i64 %52)
  store i16 %53, i16* %6, align 2
  %54 = icmp ne i16 %53, 0
  br i1 %54, label %ErrRetReturn6, label %ErrRetContinue7

ErrRetReturn6:                                    ; preds = %SwitchProng5
  %55 = load i16, i16* %6, align 2
  store i16 %55, i16* %result, align 2
  ret i16 %55

ErrRetContinue7:                                  ; preds = %SwitchProng5
  %56 = call fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).writeAll"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2, %"[]u8"* %0)
  store i16 %56, i16* %7, align 2
  %57 = icmp ne i16 %56, 0
  br i1 %57, label %ErrRetReturn8, label %ErrRetContinue9

ErrRetReturn8:                                    ; preds = %ErrRetContinue7
  %58 = load i16, i16* %7, align 2
  store i16 %58, i16* %result, align 2
  ret i16 %58

ErrRetContinue9:                                  ; preds = %ErrRetContinue7
  %59 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %1, i32 0, i32 3
  %60 = load i8, i8* %59, align 1
  %61 = load i64, i64* %right_padding, align 8
  %62 = call fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).writeByteNTimes"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2, i8 %60, i64 %61)
  store i16 %62, i16* %8, align 2
  %63 = icmp ne i16 %62, 0
  br i1 %63, label %ErrRetReturn10, label %ErrRetContinue16

ErrRetReturn10:                                   ; preds = %ErrRetContinue9
  %64 = load i16, i16* %8, align 2
  store i16 %64, i16* %result, align 2
  ret i16 %64

SwitchProng11:                                    ; preds = %EndIf3
  %65 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %1, i32 0, i32 3
  %66 = load i8, i8* %65, align 1
  %67 = load i64, i64* %padding, align 8
  %68 = call fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).writeByteNTimes"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2, i8 %66, i64 %67)
  store i16 %68, i16* %9, align 2
  %69 = icmp ne i16 %68, 0
  br i1 %69, label %ErrRetReturn12, label %ErrRetContinue13

ErrRetReturn12:                                   ; preds = %SwitchProng11
  %70 = load i16, i16* %9, align 2
  store i16 %70, i16* %result, align 2
  ret i16 %70

ErrRetContinue13:                                 ; preds = %SwitchProng11
  %71 = call fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).writeAll"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2, %"[]u8"* %0)
  store i16 %71, i16* %10, align 2
  %72 = icmp ne i16 %71, 0
  br i1 %72, label %ErrRetReturn14, label %ErrRetContinue17

ErrRetReturn14:                                   ; preds = %ErrRetContinue13
  %73 = load i16, i16* %10, align 2
  store i16 %73, i16* %result, align 2
  ret i16 %73

SwitchElse:                                       ; preds = %EndIf3
  unreachable

ErrRetContinue15:                                 ; preds = %ErrRetContinue
  br label %SwitchEnd

ErrRetContinue16:                                 ; preds = %ErrRetContinue9
  br label %SwitchEnd

ErrRetContinue17:                                 ; preds = %ErrRetContinue13
  br label %SwitchEnd

OptionalElse:                                     ; preds = %Entry
  %74 = call fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).writeAll"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2, %"[]u8"* %0)
  store i16 %74, i16* %11, align 2
  %75 = icmp ne i16 %74, 0
  br i1 %75, label %ErrRetReturn18, label %ErrRetContinue19

ErrRetReturn18:                                   ; preds = %OptionalElse
  %76 = load i16, i16* %11, align 2
  store i16 %76, i16* %result, align 2
  ret i16 %76

SwitchEnd:                                        ; preds = %ErrRetContinue17, %ErrRetContinue16, %ErrRetContinue15
  br label %OptionalEndIf

ErrRetContinue19:                                 ; preds = %OptionalElse
  br label %OptionalEndIf

OptionalEndIf:                                    ; preds = %ErrRetContinue19, %SwitchEnd
  store i16 0, i16* %result, align 2
  ret i16 0
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.unicode.utf8CountCodepoints({ i64, i16 }* nonnull sret({ i64, i16 }) %0, %"[]u8"* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %len = alloca i64, align 8
  %i = alloca i64, align 8
  %2 = alloca %"[]u8", align 8
  %3 = alloca [8 x i8]*, align 8
  %v = alloca i64, align 8
  %4 = alloca { i3, i16 }, align 2
  %5 = alloca { i64, i16 }, align 8
  %n = alloca i3, align 1
  %6 = alloca %"[]u8", align 8
  %7 = alloca { i21, i16 }, align 4
  %8 = alloca { i64, i16 }, align 8
  store i64 0, i64* %len, align 8
  store i64 0, i64* %i, align 8
  br label %WhileCond

WhileCond:                                        ; preds = %EndIf10, %Entry
  %9 = load i64, i64* %i, align 8
  %10 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 1
  %11 = load i64, i64* %10, align 8
  %12 = icmp ult i64 %9, %11
  br i1 %12, label %WhileBody, label %WhileEnd11

WhileBody:                                        ; preds = %WhileCond
  br label %WhileCond1

WhileCond1:                                       ; preds = %EndIf, %WhileBody
  %13 = load i64, i64* %i, align 8
  %14 = add nuw i64 %13, 8
  %15 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 1
  %16 = load i64, i64* %15, align 8
  %17 = icmp ule i64 %14, %16
  br i1 %17, label %WhileBody2, label %WhileEnd

WhileBody2:                                       ; preds = %WhileCond1
  %18 = load i64, i64* %i, align 8
  %19 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 1
  %20 = load i64, i64* %19, align 8
  %21 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 0
  %22 = load i8*, i8** %21, align 8
  %23 = getelementptr inbounds i8, i8* %22, i64 %18
  %24 = sub nuw i64 %20, %18
  %25 = getelementptr inbounds %"[]u8", %"[]u8"* %2, i32 0, i32 0
  store i8* %23, i8** %25, align 8
  %26 = getelementptr inbounds %"[]u8", %"[]u8"* %2, i32 0, i32 1
  store i64 %24, i64* %26, align 8
  %27 = getelementptr inbounds %"[]u8", %"[]u8"* %2, i32 0, i32 0
  %28 = load i8*, i8** %27, align 8
  %29 = getelementptr inbounds i8, i8* %28, i64 0
  %30 = bitcast i8* %29 to [8 x i8]*
  store [8 x i8]* %30, [8 x i8]** %3, align 8
  %31 = call fastcc i64 @std.mem.readIntNative([8 x i8]* %30)
  store i64 %31, i64* %v, align 8
  %32 = load i64, i64* %v, align 8
  %33 = and i64 %32, -9187201950435737472
  %34 = icmp ne i64 %33, 0
  br i1 %34, label %Then, label %Else

Then:                                             ; preds = %WhileBody2
  br label %WhileEnd

Else:                                             ; preds = %WhileBody2
  br label %EndIf

EndIf:                                            ; preds = %Else
  %35 = load i64, i64* %len, align 8
  %36 = add nuw i64 %35, 8
  store i64 %36, i64* %len, align 8
  %37 = load i64, i64* %i, align 8
  %38 = add nuw i64 %37, 8
  store i64 %38, i64* %i, align 8
  br label %WhileCond1

WhileEnd:                                         ; preds = %Then, %WhileCond1
  %39 = load i64, i64* %i, align 8
  %40 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 1
  %41 = load i64, i64* %40, align 8
  %42 = icmp ult i64 %39, %41
  br i1 %42, label %Then3, label %Else9

Then3:                                            ; preds = %WhileEnd
  %43 = load i64, i64* %i, align 8
  %44 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 0
  %45 = load i8*, i8** %44, align 8
  %46 = getelementptr inbounds i8, i8* %45, i64 %43
  %47 = load i8, i8* %46, align 1
  call fastcc void @std.unicode.utf8ByteSequenceLength({ i3, i16 }* sret({ i3, i16 }) %4, i8 %47)
  %48 = getelementptr inbounds { i3, i16 }, { i3, i16 }* %4, i32 0, i32 1
  %49 = load i16, i16* %48, align 2
  %50 = icmp ne i16 %49, 0
  br i1 %50, label %ErrRetReturn, label %ErrRetContinue

ErrRetReturn:                                     ; preds = %Then3
  %51 = getelementptr inbounds { i3, i16 }, { i3, i16 }* %4, i32 0, i32 1
  %52 = load i16, i16* %51, align 2
  %53 = getelementptr inbounds { i64, i16 }, { i64, i16 }* %0, i32 0, i32 1
  store i16 %52, i16* %53, align 2
  %54 = getelementptr inbounds { i64, i16 }, { i64, i16 }* %5, i32 0, i32 1
  store i16 %52, i16* %54, align 2
  ret void

ErrRetContinue:                                   ; preds = %Then3
  %55 = getelementptr inbounds { i3, i16 }, { i3, i16 }* %4, i32 0, i32 0
  %56 = load i3, i3* %55, align 1
  store i3 %56, i3* %n, align 1
  %57 = load i64, i64* %i, align 8
  %58 = load i3, i3* %n, align 1
  %59 = zext i3 %58 to i64
  %60 = add nuw i64 %57, %59
  %61 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 1
  %62 = load i64, i64* %61, align 8
  %63 = icmp ugt i64 %60, %62
  br i1 %63, label %Then4, label %Else5

Then4:                                            ; preds = %ErrRetContinue
  %64 = getelementptr inbounds { i64, i16 }, { i64, i16 }* %0, i32 0, i32 1
  store i16 19, i16* %64, align 2
  ret void

Else5:                                            ; preds = %ErrRetContinue
  br label %EndIf6

EndIf6:                                           ; preds = %Else5
  %65 = load i3, i3* %n, align 1
  switch i3 %65, label %SwitchElse [
    i3 1, label %SwitchProng
  ]

SwitchElse:                                       ; preds = %EndIf6
  %66 = load i64, i64* %i, align 8
  %67 = load i64, i64* %i, align 8
  %68 = load i3, i3* %n, align 1
  %69 = zext i3 %68 to i64
  %70 = add nuw i64 %67, %69
  %71 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 0
  %72 = load i8*, i8** %71, align 8
  %73 = getelementptr inbounds i8, i8* %72, i64 %66
  %74 = sub nuw i64 %70, %66
  %75 = getelementptr inbounds %"[]u8", %"[]u8"* %6, i32 0, i32 0
  store i8* %73, i8** %75, align 8
  %76 = getelementptr inbounds %"[]u8", %"[]u8"* %6, i32 0, i32 1
  store i64 %74, i64* %76, align 8
  call fastcc void @std.unicode.utf8Decode({ i21, i16 }* sret({ i21, i16 }) %7, %"[]u8"* %6)
  %77 = getelementptr inbounds { i21, i16 }, { i21, i16 }* %7, i32 0, i32 1
  %78 = load i16, i16* %77, align 2
  %79 = icmp ne i16 %78, 0
  br i1 %79, label %ErrRetReturn7, label %ErrRetContinue8

ErrRetReturn7:                                    ; preds = %SwitchElse
  %80 = getelementptr inbounds { i21, i16 }, { i21, i16 }* %7, i32 0, i32 1
  %81 = load i16, i16* %80, align 2
  %82 = getelementptr inbounds { i64, i16 }, { i64, i16 }* %0, i32 0, i32 1
  store i16 %81, i16* %82, align 2
  %83 = getelementptr inbounds { i64, i16 }, { i64, i16 }* %8, i32 0, i32 1
  store i16 %81, i16* %83, align 2
  ret void

ErrRetContinue8:                                  ; preds = %SwitchElse
  %84 = getelementptr inbounds { i21, i16 }, { i21, i16 }* %7, i32 0, i32 0
  br label %SwitchEnd

SwitchProng:                                      ; preds = %EndIf6
  br label %SwitchEnd

SwitchEnd:                                        ; preds = %SwitchProng, %ErrRetContinue8
  %85 = load i64, i64* %i, align 8
  %86 = load i3, i3* %n, align 1
  %87 = zext i3 %86 to i64
  %88 = add nuw i64 %85, %87
  store i64 %88, i64* %i, align 8
  %89 = load i64, i64* %len, align 8
  %90 = add nuw i64 %89, 1
  store i64 %90, i64* %len, align 8
  br label %EndIf10

Else9:                                            ; preds = %WhileEnd
  br label %EndIf10

EndIf10:                                          ; preds = %Else9, %SwitchEnd
  br label %WhileCond

WhileEnd11:                                       ; preds = %WhileCond
  %91 = load i64, i64* %len, align 8
  %92 = getelementptr inbounds { i64, i16 }, { i64, i16 }* %0, i32 0, i32 1
  store i16 0, i16* %92, align 2
  %93 = getelementptr inbounds { i64, i16 }, { i64, i16 }* %0, i32 0, i32 0
  store i64 %91, i64* %93, align 8
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).writeByteNTimes"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %0, i8 %1, i64 %2) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %bytes = alloca [256 x i8], align 1
  %3 = alloca [256 x i8]*, align 8
  %4 = alloca i8, align 1
  %5 = alloca %"[]u8", align 8
  %remaining = alloca i64, align 8
  %6 = alloca i64, align 8
  %to_write = alloca i64, align 8
  %7 = alloca %"[]u8", align 8
  %8 = alloca i16, align 2
  %byte = alloca i8, align 1
  %n = alloca i64, align 8
  store i8 %1, i8* %byte, align 1
  store i64 %2, i64* %n, align 8
  %9 = getelementptr inbounds [256 x i8], [256 x i8]* %bytes, i64 0, i64 0
  %10 = bitcast i8* %9 to [256 x i8]*
  store [256 x i8]* %10, [256 x i8]** %3, align 8
  %11 = load i8, i8* %byte, align 1
  store i8 %11, i8* %4, align 1
  %12 = getelementptr inbounds %"[]u8", %"[]u8"* %5, i32 0, i32 0
  %13 = getelementptr inbounds [256 x i8], [256 x i8]* %10, i64 0, i64 0
  store i8* %13, i8** %12, align 8
  %14 = getelementptr inbounds %"[]u8", %"[]u8"* %5, i32 0, i32 1
  store i64 256, i64* %14, align 8
  call fastcc void @std.mem.set(%"[]u8"* %5, i8 %11)
  %15 = load i64, i64* %n, align 8
  store i64 %15, i64* %remaining, align 8
  br label %WhileCond

WhileCond:                                        ; preds = %ErrRetContinue, %Entry
  %16 = load i64, i64* %remaining, align 8
  %17 = icmp ugt i64 %16, 0
  br i1 %17, label %WhileBody, label %WhileEnd

WhileBody:                                        ; preds = %WhileCond
  %18 = load i64, i64* %remaining, align 8
  store i64 %18, i64* %6, align 8
  %19 = call fastcc i64 @std.math.min.23(i64 %18, i64 256)
  store i64 %19, i64* %to_write, align 8
  %20 = load i64, i64* %to_write, align 8
  %21 = getelementptr inbounds [256 x i8], [256 x i8]* %bytes, i64 0, i64 0
  %22 = sub nuw i64 %20, 0
  %23 = getelementptr inbounds %"[]u8", %"[]u8"* %7, i32 0, i32 0
  store i8* %21, i8** %23, align 8
  %24 = getelementptr inbounds %"[]u8", %"[]u8"* %7, i32 0, i32 1
  store i64 %22, i64* %24, align 8
  %25 = call fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).writeAll"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0, %"[]u8"* %7)
  store i16 %25, i16* %8, align 2
  %26 = icmp ne i16 %25, 0
  br i1 %26, label %ErrRetReturn, label %ErrRetContinue

ErrRetReturn:                                     ; preds = %WhileBody
  %27 = load i16, i16* %8, align 2
  store i16 %27, i16* %result, align 2
  ret i16 %27

ErrRetContinue:                                   ; preds = %WhileBody
  %28 = load i64, i64* %remaining, align 8
  %29 = load i64, i64* %to_write, align 8
  %30 = sub nuw i64 %28, %29
  store i64 %30, i64* %remaining, align 8
  br label %WhileCond

WhileEnd:                                         ; preds = %WhileCond
  store i16 0, i16* %result, align 2
  ret i16 0
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i64 @std.mem.readIntNative([8 x i8]* nonnull readonly align 1 %0) unnamed_addr #1 {
Entry:
  %result = alloca i64, align 8
  %bytes = alloca [8 x i8]*, align 8
  store [8 x i8]* %0, [8 x i8]** %bytes, align 8
  %1 = load [8 x i8]*, [8 x i8]** %bytes, align 8
  %2 = bitcast [8 x i8]* %1 to i64*
  %3 = load i64, i64* %2, align 1
  store i64 %3, i64* %result, align 8
  %4 = load i64, i64* %result, align 8
  ret i64 %4
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.unicode.utf8ByteSequenceLength({ i3, i16 }* nonnull sret({ i3, i16 }) %0, i8 %1) unnamed_addr #1 {
Entry:
  %first_byte = alloca i8, align 1
  store i8 %1, i8* %first_byte, align 1
  %2 = load i8, i8* %first_byte, align 1
  %3 = icmp ule i8 %2, 127
  %4 = and i1 true, %3
  br i1 %4, label %SwitchRangeYes, label %SwitchRangeNo

SwitchRangeYes:                                   ; preds = %Entry
  %5 = getelementptr inbounds { i3, i16 }, { i3, i16 }* %0, i32 0, i32 1
  store i16 0, i16* %5, align 2
  %6 = getelementptr inbounds { i3, i16 }, { i3, i16 }* %0, i32 0, i32 0
  store i3 1, i3* %6, align 1
  br label %SwitchEnd

SwitchRangeNo:                                    ; preds = %Entry
  %7 = icmp uge i8 %2, -64
  %8 = icmp ule i8 %2, -33
  %9 = and i1 %7, %8
  br i1 %9, label %SwitchRangeYes1, label %SwitchRangeNo2

SwitchRangeYes1:                                  ; preds = %SwitchRangeNo
  %10 = getelementptr inbounds { i3, i16 }, { i3, i16 }* %0, i32 0, i32 1
  store i16 0, i16* %10, align 2
  %11 = getelementptr inbounds { i3, i16 }, { i3, i16 }* %0, i32 0, i32 0
  store i3 2, i3* %11, align 1
  br label %SwitchEnd

SwitchRangeNo2:                                   ; preds = %SwitchRangeNo
  %12 = icmp uge i8 %2, -32
  %13 = icmp ule i8 %2, -17
  %14 = and i1 %12, %13
  br i1 %14, label %SwitchRangeYes3, label %SwitchRangeNo4

SwitchRangeYes3:                                  ; preds = %SwitchRangeNo2
  %15 = getelementptr inbounds { i3, i16 }, { i3, i16 }* %0, i32 0, i32 1
  store i16 0, i16* %15, align 2
  %16 = getelementptr inbounds { i3, i16 }, { i3, i16 }* %0, i32 0, i32 0
  store i3 3, i3* %16, align 1
  br label %SwitchEnd

SwitchRangeNo4:                                   ; preds = %SwitchRangeNo2
  %17 = icmp uge i8 %2, -16
  %18 = icmp ule i8 %2, -9
  %19 = and i1 %17, %18
  br i1 %19, label %SwitchRangeYes5, label %SwitchRangeNo6

SwitchRangeYes5:                                  ; preds = %SwitchRangeNo4
  %20 = getelementptr inbounds { i3, i16 }, { i3, i16 }* %0, i32 0, i32 1
  store i16 0, i16* %20, align 2
  %21 = getelementptr inbounds { i3, i16 }, { i3, i16 }* %0, i32 0, i32 0
  store i3 -4, i3* %21, align 1
  br label %SwitchEnd

SwitchRangeNo6:                                   ; preds = %SwitchRangeNo4
  br label %SwitchElse

SwitchElse:                                       ; preds = %SwitchRangeNo6
  %22 = getelementptr inbounds { i3, i16 }, { i3, i16 }* %0, i32 0, i32 1
  store i16 18, i16* %22, align 2
  br label %SwitchEnd

SwitchEnd:                                        ; preds = %SwitchElse, %SwitchRangeYes5, %SwitchRangeYes3, %SwitchRangeYes1, %SwitchRangeYes
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.unicode.utf8Decode({ i21, i16 }* nonnull sret({ i21, i16 }) %0, %"[]u8"* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %2 = alloca { i21, i16 }, align 4
  %3 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 1
  %4 = load i64, i64* %3, align 8
  switch i64 %4, label %SwitchElse [
    i64 1, label %SwitchProng
    i64 2, label %SwitchProng1
    i64 3, label %SwitchProng2
    i64 4, label %SwitchProng3
  ]

SwitchElse:                                       ; preds = %Entry
  unreachable

SwitchProng:                                      ; preds = %Entry
  %5 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 0
  %6 = load i8*, i8** %5, align 8
  %7 = getelementptr inbounds i8, i8* %6, i64 0
  %8 = load i8, i8* %7, align 1
  %9 = getelementptr inbounds { i21, i16 }, { i21, i16 }* %0, i32 0, i32 1
  store i16 0, i16* %9, align 2
  %10 = getelementptr inbounds { i21, i16 }, { i21, i16 }* %0, i32 0, i32 0
  %11 = zext i8 %8 to i21
  store i21 %11, i21* %10, align 4
  %12 = zext i8 %8 to i21
  store i21 %12, i21* %10, align 4
  %13 = getelementptr inbounds { i21, i16 }, { i21, i16 }* %2, i32 0, i32 1
  store i16 0, i16* %13, align 2
  %14 = getelementptr inbounds { i21, i16 }, { i21, i16 }* %2, i32 0, i32 0
  store i21 %12, i21* %14, align 4
  br label %SwitchEnd

SwitchProng1:                                     ; preds = %Entry
  call fastcc void @std.unicode.utf8Decode2({ i21, i16 }* sret({ i21, i16 }) %0, %"[]u8"* %1)
  %15 = bitcast { i21, i16 }* %0 to i8*
  %16 = bitcast { i21, i16 }* %0 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %16, i8* align 4 %15, i64 8, i1 false)
  br label %SwitchEnd

SwitchProng2:                                     ; preds = %Entry
  call fastcc void @std.unicode.utf8Decode3({ i21, i16 }* sret({ i21, i16 }) %0, %"[]u8"* %1)
  %17 = bitcast { i21, i16 }* %0 to i8*
  %18 = bitcast { i21, i16 }* %0 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %18, i8* align 4 %17, i64 8, i1 false)
  br label %SwitchEnd

SwitchProng3:                                     ; preds = %Entry
  call fastcc void @std.unicode.utf8Decode4({ i21, i16 }* sret({ i21, i16 }) %0, %"[]u8"* %1)
  %19 = bitcast { i21, i16 }* %0 to i8*
  %20 = bitcast { i21, i16 }* %0 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %20, i8* align 4 %19, i64 8, i1 false)
  br label %SwitchEnd

SwitchEnd:                                        ; preds = %SwitchProng3, %SwitchProng2, %SwitchProng1, %SwitchProng
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.unicode.utf8Decode2({ i21, i16 }* nonnull sret({ i21, i16 }) %0, %"[]u8"* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %value = alloca i21, align 4
  %2 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 1
  %3 = load i64, i64* %2, align 8
  %4 = icmp eq i64 %3, 2
  call fastcc void @std.debug.assert(i1 %4)
  %5 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 0
  %6 = load i8*, i8** %5, align 8
  %7 = getelementptr inbounds i8, i8* %6, i64 0
  %8 = load i8, i8* %7, align 1
  %9 = and i8 %8, -32
  %10 = icmp eq i8 %9, -64
  call fastcc void @std.debug.assert(i1 %10)
  %11 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 0
  %12 = load i8*, i8** %11, align 8
  %13 = getelementptr inbounds i8, i8* %12, i64 0
  %14 = load i8, i8* %13, align 1
  %15 = and i8 %14, 31
  %16 = zext i8 %15 to i21
  store i21 %16, i21* %value, align 4
  %17 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 0
  %18 = load i8*, i8** %17, align 8
  %19 = getelementptr inbounds i8, i8* %18, i64 1
  %20 = load i8, i8* %19, align 1
  %21 = and i8 %20, -64
  %22 = icmp ne i8 %21, -128
  br i1 %22, label %Then, label %Else

Then:                                             ; preds = %Entry
  %23 = getelementptr inbounds { i21, i16 }, { i21, i16 }* %0, i32 0, i32 1
  store i16 20, i16* %23, align 2
  ret void

Else:                                             ; preds = %Entry
  br label %EndIf

EndIf:                                            ; preds = %Else
  %24 = load i21, i21* %value, align 4
  %25 = shl i21 %24, 6
  store i21 %25, i21* %value, align 4
  %26 = load i21, i21* %value, align 4
  %27 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 0
  %28 = load i8*, i8** %27, align 8
  %29 = getelementptr inbounds i8, i8* %28, i64 1
  %30 = load i8, i8* %29, align 1
  %31 = and i8 %30, 63
  %32 = zext i8 %31 to i21
  %33 = or i21 %26, %32
  store i21 %33, i21* %value, align 4
  %34 = load i21, i21* %value, align 4
  %35 = icmp ult i21 %34, 128
  br i1 %35, label %Then1, label %Else2

Then1:                                            ; preds = %EndIf
  %36 = getelementptr inbounds { i21, i16 }, { i21, i16 }* %0, i32 0, i32 1
  store i16 21, i16* %36, align 2
  ret void

Else2:                                            ; preds = %EndIf
  br label %EndIf3

EndIf3:                                           ; preds = %Else2
  %37 = load i21, i21* %value, align 4
  %38 = getelementptr inbounds { i21, i16 }, { i21, i16 }* %0, i32 0, i32 1
  store i16 0, i16* %38, align 2
  %39 = getelementptr inbounds { i21, i16 }, { i21, i16 }* %0, i32 0, i32 0
  store i21 %37, i21* %39, align 4
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.unicode.utf8Decode3({ i21, i16 }* nonnull sret({ i21, i16 }) %0, %"[]u8"* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %value = alloca i21, align 4
  %2 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 1
  %3 = load i64, i64* %2, align 8
  %4 = icmp eq i64 %3, 3
  call fastcc void @std.debug.assert(i1 %4)
  %5 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 0
  %6 = load i8*, i8** %5, align 8
  %7 = getelementptr inbounds i8, i8* %6, i64 0
  %8 = load i8, i8* %7, align 1
  %9 = and i8 %8, -16
  %10 = icmp eq i8 %9, -32
  call fastcc void @std.debug.assert(i1 %10)
  %11 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 0
  %12 = load i8*, i8** %11, align 8
  %13 = getelementptr inbounds i8, i8* %12, i64 0
  %14 = load i8, i8* %13, align 1
  %15 = and i8 %14, 15
  %16 = zext i8 %15 to i21
  store i21 %16, i21* %value, align 4
  %17 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 0
  %18 = load i8*, i8** %17, align 8
  %19 = getelementptr inbounds i8, i8* %18, i64 1
  %20 = load i8, i8* %19, align 1
  %21 = and i8 %20, -64
  %22 = icmp ne i8 %21, -128
  br i1 %22, label %Then, label %Else

Then:                                             ; preds = %Entry
  %23 = getelementptr inbounds { i21, i16 }, { i21, i16 }* %0, i32 0, i32 1
  store i16 20, i16* %23, align 2
  ret void

Else:                                             ; preds = %Entry
  br label %EndIf

EndIf:                                            ; preds = %Else
  %24 = load i21, i21* %value, align 4
  %25 = shl i21 %24, 6
  store i21 %25, i21* %value, align 4
  %26 = load i21, i21* %value, align 4
  %27 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 0
  %28 = load i8*, i8** %27, align 8
  %29 = getelementptr inbounds i8, i8* %28, i64 1
  %30 = load i8, i8* %29, align 1
  %31 = and i8 %30, 63
  %32 = zext i8 %31 to i21
  %33 = or i21 %26, %32
  store i21 %33, i21* %value, align 4
  %34 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 0
  %35 = load i8*, i8** %34, align 8
  %36 = getelementptr inbounds i8, i8* %35, i64 2
  %37 = load i8, i8* %36, align 1
  %38 = and i8 %37, -64
  %39 = icmp ne i8 %38, -128
  br i1 %39, label %Then1, label %Else2

Then1:                                            ; preds = %EndIf
  %40 = getelementptr inbounds { i21, i16 }, { i21, i16 }* %0, i32 0, i32 1
  store i16 20, i16* %40, align 2
  ret void

Else2:                                            ; preds = %EndIf
  br label %EndIf3

EndIf3:                                           ; preds = %Else2
  %41 = load i21, i21* %value, align 4
  %42 = shl i21 %41, 6
  store i21 %42, i21* %value, align 4
  %43 = load i21, i21* %value, align 4
  %44 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 0
  %45 = load i8*, i8** %44, align 8
  %46 = getelementptr inbounds i8, i8* %45, i64 2
  %47 = load i8, i8* %46, align 1
  %48 = and i8 %47, 63
  %49 = zext i8 %48 to i21
  %50 = or i21 %43, %49
  store i21 %50, i21* %value, align 4
  %51 = load i21, i21* %value, align 4
  %52 = icmp ult i21 %51, 2048
  br i1 %52, label %Then4, label %Else5

Then4:                                            ; preds = %EndIf3
  %53 = getelementptr inbounds { i21, i16 }, { i21, i16 }* %0, i32 0, i32 1
  store i16 21, i16* %53, align 2
  ret void

Else5:                                            ; preds = %EndIf3
  br label %EndIf6

EndIf6:                                           ; preds = %Else5
  %54 = load i21, i21* %value, align 4
  %55 = icmp ule i21 55296, %54
  br i1 %55, label %BoolAndTrue, label %BoolAndFalse

BoolAndTrue:                                      ; preds = %EndIf6
  %56 = load i21, i21* %value, align 4
  %57 = icmp ule i21 %56, 57343
  br label %BoolAndFalse

BoolAndFalse:                                     ; preds = %BoolAndTrue, %EndIf6
  %58 = phi i1 [ %55, %EndIf6 ], [ %57, %BoolAndTrue ]
  br i1 %58, label %Then7, label %Else8

Then7:                                            ; preds = %BoolAndFalse
  %59 = getelementptr inbounds { i21, i16 }, { i21, i16 }* %0, i32 0, i32 1
  store i16 22, i16* %59, align 2
  ret void

Else8:                                            ; preds = %BoolAndFalse
  br label %EndIf9

EndIf9:                                           ; preds = %Else8
  %60 = load i21, i21* %value, align 4
  %61 = getelementptr inbounds { i21, i16 }, { i21, i16 }* %0, i32 0, i32 1
  store i16 0, i16* %61, align 2
  %62 = getelementptr inbounds { i21, i16 }, { i21, i16 }* %0, i32 0, i32 0
  store i21 %60, i21* %62, align 4
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.unicode.utf8Decode4({ i21, i16 }* nonnull sret({ i21, i16 }) %0, %"[]u8"* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %value = alloca i21, align 4
  %2 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 1
  %3 = load i64, i64* %2, align 8
  %4 = icmp eq i64 %3, 4
  call fastcc void @std.debug.assert(i1 %4)
  %5 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 0
  %6 = load i8*, i8** %5, align 8
  %7 = getelementptr inbounds i8, i8* %6, i64 0
  %8 = load i8, i8* %7, align 1
  %9 = and i8 %8, -8
  %10 = icmp eq i8 %9, -16
  call fastcc void @std.debug.assert(i1 %10)
  %11 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 0
  %12 = load i8*, i8** %11, align 8
  %13 = getelementptr inbounds i8, i8* %12, i64 0
  %14 = load i8, i8* %13, align 1
  %15 = and i8 %14, 7
  %16 = zext i8 %15 to i21
  store i21 %16, i21* %value, align 4
  %17 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 0
  %18 = load i8*, i8** %17, align 8
  %19 = getelementptr inbounds i8, i8* %18, i64 1
  %20 = load i8, i8* %19, align 1
  %21 = and i8 %20, -64
  %22 = icmp ne i8 %21, -128
  br i1 %22, label %Then, label %Else

Then:                                             ; preds = %Entry
  %23 = getelementptr inbounds { i21, i16 }, { i21, i16 }* %0, i32 0, i32 1
  store i16 20, i16* %23, align 2
  ret void

Else:                                             ; preds = %Entry
  br label %EndIf

EndIf:                                            ; preds = %Else
  %24 = load i21, i21* %value, align 4
  %25 = shl i21 %24, 6
  store i21 %25, i21* %value, align 4
  %26 = load i21, i21* %value, align 4
  %27 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 0
  %28 = load i8*, i8** %27, align 8
  %29 = getelementptr inbounds i8, i8* %28, i64 1
  %30 = load i8, i8* %29, align 1
  %31 = and i8 %30, 63
  %32 = zext i8 %31 to i21
  %33 = or i21 %26, %32
  store i21 %33, i21* %value, align 4
  %34 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 0
  %35 = load i8*, i8** %34, align 8
  %36 = getelementptr inbounds i8, i8* %35, i64 2
  %37 = load i8, i8* %36, align 1
  %38 = and i8 %37, -64
  %39 = icmp ne i8 %38, -128
  br i1 %39, label %Then1, label %Else2

Then1:                                            ; preds = %EndIf
  %40 = getelementptr inbounds { i21, i16 }, { i21, i16 }* %0, i32 0, i32 1
  store i16 20, i16* %40, align 2
  ret void

Else2:                                            ; preds = %EndIf
  br label %EndIf3

EndIf3:                                           ; preds = %Else2
  %41 = load i21, i21* %value, align 4
  %42 = shl i21 %41, 6
  store i21 %42, i21* %value, align 4
  %43 = load i21, i21* %value, align 4
  %44 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 0
  %45 = load i8*, i8** %44, align 8
  %46 = getelementptr inbounds i8, i8* %45, i64 2
  %47 = load i8, i8* %46, align 1
  %48 = and i8 %47, 63
  %49 = zext i8 %48 to i21
  %50 = or i21 %43, %49
  store i21 %50, i21* %value, align 4
  %51 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 0
  %52 = load i8*, i8** %51, align 8
  %53 = getelementptr inbounds i8, i8* %52, i64 3
  %54 = load i8, i8* %53, align 1
  %55 = and i8 %54, -64
  %56 = icmp ne i8 %55, -128
  br i1 %56, label %Then4, label %Else5

Then4:                                            ; preds = %EndIf3
  %57 = getelementptr inbounds { i21, i16 }, { i21, i16 }* %0, i32 0, i32 1
  store i16 20, i16* %57, align 2
  ret void

Else5:                                            ; preds = %EndIf3
  br label %EndIf6

EndIf6:                                           ; preds = %Else5
  %58 = load i21, i21* %value, align 4
  %59 = shl i21 %58, 6
  store i21 %59, i21* %value, align 4
  %60 = load i21, i21* %value, align 4
  %61 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 0
  %62 = load i8*, i8** %61, align 8
  %63 = getelementptr inbounds i8, i8* %62, i64 3
  %64 = load i8, i8* %63, align 1
  %65 = and i8 %64, 63
  %66 = zext i8 %65 to i21
  %67 = or i21 %60, %66
  store i21 %67, i21* %value, align 4
  %68 = load i21, i21* %value, align 4
  %69 = icmp ult i21 %68, 65536
  br i1 %69, label %Then7, label %Else8

Then7:                                            ; preds = %EndIf6
  %70 = getelementptr inbounds { i21, i16 }, { i21, i16 }* %0, i32 0, i32 1
  store i16 21, i16* %70, align 2
  ret void

Else8:                                            ; preds = %EndIf6
  br label %EndIf9

EndIf9:                                           ; preds = %Else8
  %71 = load i21, i21* %value, align 4
  %72 = icmp ugt i21 %71, -983041
  br i1 %72, label %Then10, label %Else11

Then10:                                           ; preds = %EndIf9
  %73 = getelementptr inbounds { i21, i16 }, { i21, i16 }* %0, i32 0, i32 1
  store i16 23, i16* %73, align 2
  ret void

Else11:                                           ; preds = %EndIf9
  br label %EndIf12

EndIf12:                                          ; preds = %Else11
  %74 = load i21, i21* %value, align 4
  %75 = getelementptr inbounds { i21, i16 }, { i21, i16 }* %0, i32 0, i32 1
  store i16 0, i16* %75, align 2
  %76 = getelementptr inbounds { i21, i16 }, { i21, i16 }* %0, i32 0, i32 0
  store i21 %74, i21* %76, align 4
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i64 @std.math.min.23(i64 %0, i64 %1) unnamed_addr #1 {
Entry:
  %result = alloca i64, align 8
  %x = alloca i64, align 8
  %y = alloca i64, align 8
  store i64 %0, i64* %x, align 8
  store i64 %1, i64* %y, align 8
  %2 = load i64, i64* %x, align 8
  %3 = load i64, i64* %y, align 8
  %4 = icmp ult i64 %2, %3
  br i1 %4, label %Then, label %Else

Then:                                             ; preds = %Entry
  %5 = load i64, i64* %x, align 8
  store i64 %5, i64* %result, align 8
  %6 = load i64, i64* %result, align 8
  ret i64 %6

Else:                                             ; preds = %Entry
  %7 = load i64, i64* %y, align 8
  store i64 %7, i64* %result, align 8
  %8 = load i64, i64* %result, align 8
  ret i64 %8
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i64 @std.os.linux.futex_wake(i32* nonnull readonly align 4 %0, i32 %1, i32 %2) unnamed_addr #1 {
Entry:
  %result = alloca i64, align 8
  %uaddr = alloca i32*, align 8
  %futex_op = alloca i32, align 4
  %val = alloca i32, align 4
  store i32* %0, i32** %uaddr, align 8
  store i32 %1, i32* %futex_op, align 4
  store i32 %2, i32* %val, align 4
  %3 = load i32*, i32** %uaddr, align 8
  %4 = ptrtoint i32* %3 to i64
  %5 = load i32, i32* %futex_op, align 4
  %6 = zext i32 %5 to i64
  %7 = load i32, i32* %val, align 4
  %8 = zext i32 %7 to i64
  %9 = call fastcc i64 @std.os.linux.x86_64.syscall3(i64 202, i64 %4, i64 %6, i64 %8)
  store i64 %9, i64* %result, align 8
  %10 = load i64, i64* %result, align 8
  ret i64 %10
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.Thread.StaticResetEvent.LinuxFutex.wait(i32* nonnull align 4 %0, %"?u64"* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %ts = alloca %std.os.linux.timespec, align 8
  %ts_ptr = alloca %std.os.linux.timespec*, align 8
  %timeout_ns = alloca i64, align 8
  %waiting = alloca i32, align 4
  %expected = alloca i32, align 4
  %ptr = alloca i32*, align 8
  %rc = alloca i64, align 8
  %2 = alloca i16, align 2
  %waiters = alloca i32*, align 8
  store i32* %0, i32** %waiters, align 8
  store %std.os.linux.timespec* null, %std.os.linux.timespec** %ts_ptr, align 8
  %3 = getelementptr inbounds %"?u64", %"?u64"* %1, i32 0, i32 1
  %4 = load i1, i1* %3, align 1
  br i1 %4, label %OptionalThen, label %OptionalElse

OptionalThen:                                     ; preds = %Entry
  %5 = getelementptr inbounds %"?u64", %"?u64"* %1, i32 0, i32 0
  %6 = load i64, i64* %5, align 8
  store i64 %6, i64* %timeout_ns, align 8
  store %std.os.linux.timespec* %ts, %std.os.linux.timespec** %ts_ptr, align 8
  %7 = getelementptr inbounds %std.os.linux.timespec, %std.os.linux.timespec* %ts, i32 0, i32 0
  %8 = load i64, i64* %timeout_ns, align 8
  %9 = udiv i64 %8, 1000000000
  store i64 %9, i64* %7, align 8
  %10 = getelementptr inbounds %std.os.linux.timespec, %std.os.linux.timespec* %ts, i32 0, i32 1
  %11 = load i64, i64* %timeout_ns, align 8
  %12 = urem i64 %11, 1000000000
  store i64 %12, i64* %10, align 8
  br label %OptionalEndIf

OptionalElse:                                     ; preds = %Entry
  br label %OptionalEndIf

OptionalEndIf:                                    ; preds = %OptionalElse, %OptionalThen
  br label %WhileCond

WhileCond:                                        ; preds = %SwitchProng2, %SwitchProng, %OptionalEndIf
  br label %WhileBody

WhileBody:                                        ; preds = %WhileCond
  %13 = load i32*, i32** %waiters, align 8
  %14 = load atomic i32, i32* %13 acquire, align 4
  store i32 %14, i32* %waiting, align 4
  %15 = load i32, i32* %waiting, align 4
  %16 = icmp eq i32 %15, 1
  br i1 %16, label %Then, label %Else

Then:                                             ; preds = %WhileBody
  store i16 0, i16* %result, align 2
  %17 = load i16, i16* %result, align 2
  ret i16 %17

Else:                                             ; preds = %WhileBody
  br label %EndIf

EndIf:                                            ; preds = %Else
  %18 = load i32, i32* %waiting, align 4
  store i32 %18, i32* %expected, align 4
  %19 = load i32*, i32** %waiters, align 8
  store i32* %19, i32** %ptr, align 8
  %20 = load i32*, i32** %ptr, align 8
  %21 = load i32, i32* %expected, align 4
  %22 = load %std.os.linux.timespec*, %std.os.linux.timespec** %ts_ptr, align 8
  %23 = call fastcc i64 @std.os.linux.futex_wait(i32* %20, i32 128, i32 %21, %std.os.linux.timespec* %22)
  store i64 %23, i64* %rc, align 8
  %24 = load i64, i64* %rc, align 8
  %25 = call fastcc i16 @std.os.linux.getErrno(i64 %24)
  store i16 %25, i16* %2, align 2
  switch i16 %25, label %SwitchElse [
    i16 0, label %SwitchProng
    i16 110, label %SwitchProng1
    i16 4, label %SwitchProng2
    i16 11, label %SwitchProng3
  ]

SwitchElse:                                       ; preds = %EndIf
  unreachable

SwitchProng:                                      ; preds = %EndIf
  br label %WhileCond

SwitchProng1:                                     ; preds = %EndIf
  store i16 42, i16* %result, align 2
  %26 = load i16, i16* %result, align 2
  ret i16 %26

SwitchProng2:                                     ; preds = %EndIf
  br label %WhileCond

SwitchProng3:                                     ; preds = %EndIf
  store i16 0, i16* %result, align 2
  %27 = load i16, i16* %result, align 2
  ret i16 %27
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i64 @std.mem.alignBackwardGeneric(i64 %0, i64 %1) unnamed_addr #1 {
Entry:
  %result = alloca i64, align 8
  %addr = alloca i64, align 8
  %alignment = alloca i64, align 8
  store i64 %0, i64* %addr, align 8
  store i64 %1, i64* %alignment, align 8
  %2 = load i64, i64* %alignment, align 8
  %3 = call i64 @llvm.ctpop.i64(i64 %2)
  %4 = trunc i64 %3 to i7
  %5 = icmp eq i7 %4, 1
  call fastcc void @std.debug.assert(i1 %5)
  %6 = load i64, i64* %addr, align 8
  %7 = load i64, i64* %alignment, align 8
  %8 = sub nuw i64 %7, 1
  %9 = xor i64 %8, -1
  %10 = and i64 %6, %9
  store i64 %10, i64* %result, align 8
  %11 = load i64, i64* %result, align 8
  ret i64 %11
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i64 @std.os.linux.prlimit(i32 %0, i32 %1, %std.os.linux.rlimit* align 8 %2, %std.os.linux.rlimit* align 8 %3) unnamed_addr #1 {
Entry:
  %result = alloca i64, align 8
  %pid = alloca i32, align 4
  %resource = alloca i32, align 4
  %new_limit = alloca %std.os.linux.rlimit*, align 8
  %old_limit = alloca %std.os.linux.rlimit*, align 8
  store i32 %0, i32* %pid, align 4
  store i32 %1, i32* %resource, align 4
  store %std.os.linux.rlimit* %2, %std.os.linux.rlimit** %new_limit, align 8
  store %std.os.linux.rlimit* %3, %std.os.linux.rlimit** %old_limit, align 8
  %4 = load i32, i32* %pid, align 4
  %5 = sext i32 %4 to i64
  %6 = sext i32 %4 to i64
  %7 = load i32, i32* %resource, align 4
  %8 = sext i32 %7 to i64
  %9 = sext i32 %7 to i64
  %10 = load %std.os.linux.rlimit*, %std.os.linux.rlimit** %new_limit, align 8
  %11 = ptrtoint %std.os.linux.rlimit* %10 to i64
  %12 = load %std.os.linux.rlimit*, %std.os.linux.rlimit** %old_limit, align 8
  %13 = ptrtoint %std.os.linux.rlimit* %12 to i64
  %14 = call fastcc i64 @std.os.linux.x86_64.syscall4(i64 302, i64 %6, i64 %9, i64 %11, i64 %13)
  store i64 %14, i64* %result, align 8
  %15 = load i64, i64* %result, align 8
  ret i64 %15
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i1 @std.target.Target.isDarwin(%std.target.Target* nonnull readonly align 8 %0) unnamed_addr #1 {
Entry:
  %result = alloca i1, align 1
  %1 = getelementptr inbounds %std.target.Target, %std.target.Target* %0, i32 0, i32 1
  %2 = getelementptr inbounds %std.target.Os, %std.target.Os* %1, i32 0, i32 0
  %3 = load i6, i6* %2, align 1
  %4 = call fastcc i1 @std.target.Tag.isDarwin(i6 %3)
  store i1 %4, i1* %result, align 1
  %5 = load i1, i1* %result, align 1
  ret i1 %5
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i1 @std.target.Tag.isDarwin(i6 %0) unnamed_addr #1 {
Entry:
  %result = alloca i1, align 1
  %tag = alloca i6, align 1
  store i6 %0, i6* %tag, align 1
  %1 = load i6, i6* %tag, align 1
  switch i6 %1, label %SwitchElse [
    i6 6, label %SwitchProng
    i6 10, label %SwitchProng
    i6 27, label %SwitchProng
    i6 26, label %SwitchProng
  ]

SwitchElse:                                       ; preds = %Entry
  store i1 false, i1* %result, align 1
  br label %SwitchEnd

SwitchProng:                                      ; preds = %Entry, %Entry, %Entry, %Entry
  store i1 true, i1* %result, align 1
  br label %SwitchEnd

SwitchEnd:                                        ; preds = %SwitchProng, %SwitchElse
  %2 = load i1, i1* %result, align 1
  ret i1 %2
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @main() unnamed_addr #1 {
Entry:
  %0 = alloca %"?u32", align 4
  call fastcc void @f(%"?u32"* sret(%"?u32") %0, i1 true, i32 7)
  ret void
}

; Function Attrs: nofree nosync nounwind readnone speculatable willreturn
declare i64 @llvm.ctpop.i64(i64 %0) #9

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @f(%"?u32"* nonnull sret(%"?u32") %0, i1 %1, i32 %2) unnamed_addr #1 {
Entry:
  %val = alloca i32, align 4
  %3 = alloca %"?u32", align 4
  %use = alloca i1, align 1
  %param = alloca i32, align 4
  store i1 %1, i1* %use, align 1
  store i32 %2, i32* %param, align 4
  store i32 0, i32* %val, align 4
  %4 = load i1, i1* %use, align 1
  switch i1 %4, label %SwitchElse [
    i1 true, label %SwitchProng
  ]

SwitchElse:                                       ; preds = %Entry
  %5 = getelementptr inbounds %"?u32", %"?u32"* %0, i32 0, i32 1
  store i1 true, i1* %5, align 1
  %6 = getelementptr inbounds %"?u32", %"?u32"* %0, i32 0, i32 0
  store i32 6, i32* %6, align 4
  %7 = bitcast %"?u32"* %0 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %7, i8* align 4 bitcast ({ i32, i1, [3 x i8] }* @40 to i8*), i64 8, i1 false)
  br label %SwitchEnd

SwitchProng:                                      ; preds = %Entry
  %8 = load i32, i32* %param, align 4
  %9 = icmp eq i32 %8, 1
  %10 = getelementptr inbounds %"?u32", %"?u32"* %0, i32 0, i32 1
  store i1 true, i1* %10, align 1
  %11 = getelementptr inbounds %"?u32", %"?u32"* %0, i32 0, i32 0
  br i1 %9, label %Then, label %Else

Else:                                             ; preds = %SwitchProng
  %12 = load i32, i32* %val, align 4
  %13 = icmp eq i32 %12, 3
  br i1 %13, label %Then1, label %Else2

Then:                                             ; preds = %SwitchProng
  %14 = getelementptr inbounds %"?u32", %"?u32"* %0, i32 0, i32 1
  store i1 true, i1* %14, align 1
  %15 = getelementptr inbounds %"?u32", %"?u32"* %0, i32 0, i32 0
  store i32 2, i32* %15, align 4
  %16 = getelementptr inbounds %"?u32", %"?u32"* %0, i32 0, i32 1
  store i1 true, i1* %16, align 1
  %17 = getelementptr inbounds %"?u32", %"?u32"* %0, i32 0, i32 0
  store i32 2, i32* %17, align 4
  br label %EndIf3

Then1:                                            ; preds = %Else
  %18 = getelementptr inbounds %"?u32", %"?u32"* %0, i32 0, i32 1
  store i1 true, i1* %18, align 1
  %19 = getelementptr inbounds %"?u32", %"?u32"* %0, i32 0, i32 0
  store i32 4, i32* %19, align 4
  store i32 4, i32* %19, align 4
  br label %EndIf

Else2:                                            ; preds = %Else
  store i32 5, i32* %19, align 4
  store i32 5, i32* %19, align 4
  br label %EndIf

EndIf:                                            ; preds = %Else2, %Then1
  %20 = phi i32 [ 4, %Then1 ], [ 5, %Else2 ]
  store i32 %20, i32* %19, align 4
  br label %EndIf3

EndIf3:                                           ; preds = %EndIf, %Then
  %21 = phi i32 [ 2, %Then ], [ %20, %EndIf ]
  %22 = getelementptr inbounds %"?u32", %"?u32"* %0, i32 0, i32 1
  store i1 true, i1* %22, align 1
  %23 = getelementptr inbounds %"?u32", %"?u32"* %0, i32 0, i32 0
  store i32 %21, i32* %23, align 4
  %24 = getelementptr inbounds %"?u32", %"?u32"* %3, i32 0, i32 0
  store i32 %21, i32* %24, align 4
  %25 = getelementptr inbounds %"?u32", %"?u32"* %3, i32 0, i32 1
  store i1 true, i1* %25, align 1
  br label %SwitchEnd

SwitchEnd:                                        ; preds = %EndIf3, %SwitchElse
  ret void
}

attributes #0 = { cold minsize nobuiltin noreturn nounwind optsize "target-cpu"="skylake" "target-features"="-16bit-mode,-32bit-mode,-3dnow,-3dnowa,+64bit,+adx,+aes,-amx-bf16,-amx-int8,-amx-tile,+avx,+avx2,-avx512bf16,-avx512bitalg,-avx512bw,-avx512cd,-avx512dq,-avx512er,-avx512f,-avx512ifma,-avx512pf,-avx512vbmi,-avx512vbmi2,-avx512vl,-avx512vnni,-avx512vp2intersect,-avx512vpopcntdq,-avxvnni,+bmi,+bmi2,-branchfusion,-cldemote,+clflushopt,-clwb,-clzero,+cmov,+cx16,+cx8,-enqcmd,+ermsb,+f16c,-false-deps-lzcnt-tzcnt,+false-deps-popcnt,-fast-11bytenop,+fast-15bytenop,-fast-7bytenop,-fast-bextr,+fast-gather,-fast-hops,-fast-lzcnt,-fast-movbe,+fast-scalar-fsqrt,-fast-scalar-shift-masks,+fast-shld-rotate,+fast-variable-crosslane-shuffle,+fast-variable-perlane-shuffle,+fast-vector-fsqrt,-fast-vector-shift-masks,+fma,-fma4,+fsgsbase,-fsrm,+fxsr,-gfni,-hreset,-idivl-to-divb,+idivq-to-divl,+invpcid,-kl,-lea-sp,-lea-uses-ag,-lvi-cfi,-lvi-load-hardening,-lwp,+lzcnt,+macrofusion,+mmx,+movbe,-movdir64b,-movdiri,-mwaitx,+nopl,-pad-short-functions,+pclmul,-pconfig,-pku,+popcnt,-prefer-128-bit,-prefer-256-bit,-prefer-mask-registers,-prefetchwt1,+prfchw,-ptwrite,-rdpid,+rdrnd,+rdseed,-retpoline,-retpoline-external-thunk,-retpoline-indirect-branches,-retpoline-indirect-calls,+rtm,+sahf,-serialize,-seses,+sgx,-sha,-shstk,+slow-3ops-lea,-slow-incdec,-slow-lea,-slow-pmaddwd,-slow-pmulld,-slow-shld,-slow-two-mem-ops,-slow-unaligned-mem-16,-slow-unaligned-mem-32,-soft-float,+sse,+sse2,+sse3,+sse4.1,+sse4.2,-sse4a,-sse-unaligned-mem,+ssse3,-tbm,-tsxldtrk,-uintr,-use-aa,-use-glm-div-sqrt-costs,-vaes,-vpclmulqdq,+vzeroupper,-waitpkg,-wbnoinvd,-widekl,+x87,-xop,+xsave,+xsavec,+xsaveopt,+xsaves" }
attributes #1 = { minsize nobuiltin nounwind optsize "target-cpu"="skylake" "target-features"="-16bit-mode,-32bit-mode,-3dnow,-3dnowa,+64bit,+adx,+aes,-amx-bf16,-amx-int8,-amx-tile,+avx,+avx2,-avx512bf16,-avx512bitalg,-avx512bw,-avx512cd,-avx512dq,-avx512er,-avx512f,-avx512ifma,-avx512pf,-avx512vbmi,-avx512vbmi2,-avx512vl,-avx512vnni,-avx512vp2intersect,-avx512vpopcntdq,-avxvnni,+bmi,+bmi2,-branchfusion,-cldemote,+clflushopt,-clwb,-clzero,+cmov,+cx16,+cx8,-enqcmd,+ermsb,+f16c,-false-deps-lzcnt-tzcnt,+false-deps-popcnt,-fast-11bytenop,+fast-15bytenop,-fast-7bytenop,-fast-bextr,+fast-gather,-fast-hops,-fast-lzcnt,-fast-movbe,+fast-scalar-fsqrt,-fast-scalar-shift-masks,+fast-shld-rotate,+fast-variable-crosslane-shuffle,+fast-variable-perlane-shuffle,+fast-vector-fsqrt,-fast-vector-shift-masks,+fma,-fma4,+fsgsbase,-fsrm,+fxsr,-gfni,-hreset,-idivl-to-divb,+idivq-to-divl,+invpcid,-kl,-lea-sp,-lea-uses-ag,-lvi-cfi,-lvi-load-hardening,-lwp,+lzcnt,+macrofusion,+mmx,+movbe,-movdir64b,-movdiri,-mwaitx,+nopl,-pad-short-functions,+pclmul,-pconfig,-pku,+popcnt,-prefer-128-bit,-prefer-256-bit,-prefer-mask-registers,-prefetchwt1,+prfchw,-ptwrite,-rdpid,+rdrnd,+rdseed,-retpoline,-retpoline-external-thunk,-retpoline-indirect-branches,-retpoline-indirect-calls,+rtm,+sahf,-serialize,-seses,+sgx,-sha,-shstk,+slow-3ops-lea,-slow-incdec,-slow-lea,-slow-pmaddwd,-slow-pmulld,-slow-shld,-slow-two-mem-ops,-slow-unaligned-mem-16,-slow-unaligned-mem-32,-soft-float,+sse,+sse2,+sse3,+sse4.1,+sse4.2,-sse4a,-sse-unaligned-mem,+ssse3,-tbm,-tsxldtrk,-uintr,-use-aa,-use-glm-div-sqrt-costs,-vaes,-vpclmulqdq,+vzeroupper,-waitpkg,-wbnoinvd,-widekl,+x87,-xop,+xsave,+xsavec,+xsaveopt,+xsaves" }
attributes #2 = { nofree nosync nounwind readnone willreturn }
attributes #3 = { argmemonly nofree nounwind willreturn }
attributes #4 = { minsize naked nobuiltin noreturn nounwind optsize "target-cpu"="skylake" "target-features"="-16bit-mode,-32bit-mode,-3dnow,-3dnowa,+64bit,+adx,+aes,-amx-bf16,-amx-int8,-amx-tile,+avx,+avx2,-avx512bf16,-avx512bitalg,-avx512bw,-avx512cd,-avx512dq,-avx512er,-avx512f,-avx512ifma,-avx512pf,-avx512vbmi,-avx512vbmi2,-avx512vl,-avx512vnni,-avx512vp2intersect,-avx512vpopcntdq,-avxvnni,+bmi,+bmi2,-branchfusion,-cldemote,+clflushopt,-clwb,-clzero,+cmov,+cx16,+cx8,-enqcmd,+ermsb,+f16c,-false-deps-lzcnt-tzcnt,+false-deps-popcnt,-fast-11bytenop,+fast-15bytenop,-fast-7bytenop,-fast-bextr,+fast-gather,-fast-hops,-fast-lzcnt,-fast-movbe,+fast-scalar-fsqrt,-fast-scalar-shift-masks,+fast-shld-rotate,+fast-variable-crosslane-shuffle,+fast-variable-perlane-shuffle,+fast-vector-fsqrt,-fast-vector-shift-masks,+fma,-fma4,+fsgsbase,-fsrm,+fxsr,-gfni,-hreset,-idivl-to-divb,+idivq-to-divl,+invpcid,-kl,-lea-sp,-lea-uses-ag,-lvi-cfi,-lvi-load-hardening,-lwp,+lzcnt,+macrofusion,+mmx,+movbe,-movdir64b,-movdiri,-mwaitx,+nopl,-pad-short-functions,+pclmul,-pconfig,-pku,+popcnt,-prefer-128-bit,-prefer-256-bit,-prefer-mask-registers,-prefetchwt1,+prfchw,-ptwrite,-rdpid,+rdrnd,+rdseed,-retpoline,-retpoline-external-thunk,-retpoline-indirect-branches,-retpoline-indirect-calls,+rtm,+sahf,-serialize,-seses,+sgx,-sha,-shstk,+slow-3ops-lea,-slow-incdec,-slow-lea,-slow-pmaddwd,-slow-pmulld,-slow-shld,-slow-two-mem-ops,-slow-unaligned-mem-16,-slow-unaligned-mem-32,-soft-float,+sse,+sse2,+sse3,+sse4.1,+sse4.2,-sse4a,-sse-unaligned-mem,+ssse3,-tbm,-tsxldtrk,-uintr,-use-aa,-use-glm-div-sqrt-costs,-vaes,-vpclmulqdq,+vzeroupper,-waitpkg,-wbnoinvd,-widekl,+x87,-xop,+xsave,+xsavec,+xsaveopt,+xsaves" }
attributes #5 = { minsize nobuiltin noinline noreturn nounwind optsize alignstack=16 "target-cpu"="skylake" "target-features"="-16bit-mode,-32bit-mode,-3dnow,-3dnowa,+64bit,+adx,+aes,-amx-bf16,-amx-int8,-amx-tile,+avx,+avx2,-avx512bf16,-avx512bitalg,-avx512bw,-avx512cd,-avx512dq,-avx512er,-avx512f,-avx512ifma,-avx512pf,-avx512vbmi,-avx512vbmi2,-avx512vl,-avx512vnni,-avx512vp2intersect,-avx512vpopcntdq,-avxvnni,+bmi,+bmi2,-branchfusion,-cldemote,+clflushopt,-clwb,-clzero,+cmov,+cx16,+cx8,-enqcmd,+ermsb,+f16c,-false-deps-lzcnt-tzcnt,+false-deps-popcnt,-fast-11bytenop,+fast-15bytenop,-fast-7bytenop,-fast-bextr,+fast-gather,-fast-hops,-fast-lzcnt,-fast-movbe,+fast-scalar-fsqrt,-fast-scalar-shift-masks,+fast-shld-rotate,+fast-variable-crosslane-shuffle,+fast-variable-perlane-shuffle,+fast-vector-fsqrt,-fast-vector-shift-masks,+fma,-fma4,+fsgsbase,-fsrm,+fxsr,-gfni,-hreset,-idivl-to-divb,+idivq-to-divl,+invpcid,-kl,-lea-sp,-lea-uses-ag,-lvi-cfi,-lvi-load-hardening,-lwp,+lzcnt,+macrofusion,+mmx,+movbe,-movdir64b,-movdiri,-mwaitx,+nopl,-pad-short-functions,+pclmul,-pconfig,-pku,+popcnt,-prefer-128-bit,-prefer-256-bit,-prefer-mask-registers,-prefetchwt1,+prfchw,-ptwrite,-rdpid,+rdrnd,+rdseed,-retpoline,-retpoline-external-thunk,-retpoline-indirect-branches,-retpoline-indirect-calls,+rtm,+sahf,-serialize,-seses,+sgx,-sha,-shstk,+slow-3ops-lea,-slow-incdec,-slow-lea,-slow-pmaddwd,-slow-pmulld,-slow-shld,-slow-two-mem-ops,-slow-unaligned-mem-16,-slow-unaligned-mem-32,-soft-float,+sse,+sse2,+sse3,+sse4.1,+sse4.2,-sse4a,-sse-unaligned-mem,+ssse3,-tbm,-tsxldtrk,-uintr,-use-aa,-use-glm-div-sqrt-costs,-vaes,-vpclmulqdq,+vzeroupper,-waitpkg,-wbnoinvd,-widekl,+x87,-xop,+xsave,+xsavec,+xsaveopt,+xsaves" }
attributes #6 = { minsize nobuiltin noreturn nounwind optsize "target-cpu"="skylake" "target-features"="-16bit-mode,-32bit-mode,-3dnow,-3dnowa,+64bit,+adx,+aes,-amx-bf16,-amx-int8,-amx-tile,+avx,+avx2,-avx512bf16,-avx512bitalg,-avx512bw,-avx512cd,-avx512dq,-avx512er,-avx512f,-avx512ifma,-avx512pf,-avx512vbmi,-avx512vbmi2,-avx512vl,-avx512vnni,-avx512vp2intersect,-avx512vpopcntdq,-avxvnni,+bmi,+bmi2,-branchfusion,-cldemote,+clflushopt,-clwb,-clzero,+cmov,+cx16,+cx8,-enqcmd,+ermsb,+f16c,-false-deps-lzcnt-tzcnt,+false-deps-popcnt,-fast-11bytenop,+fast-15bytenop,-fast-7bytenop,-fast-bextr,+fast-gather,-fast-hops,-fast-lzcnt,-fast-movbe,+fast-scalar-fsqrt,-fast-scalar-shift-masks,+fast-shld-rotate,+fast-variable-crosslane-shuffle,+fast-variable-perlane-shuffle,+fast-vector-fsqrt,-fast-vector-shift-masks,+fma,-fma4,+fsgsbase,-fsrm,+fxsr,-gfni,-hreset,-idivl-to-divb,+idivq-to-divl,+invpcid,-kl,-lea-sp,-lea-uses-ag,-lvi-cfi,-lvi-load-hardening,-lwp,+lzcnt,+macrofusion,+mmx,+movbe,-movdir64b,-movdiri,-mwaitx,+nopl,-pad-short-functions,+pclmul,-pconfig,-pku,+popcnt,-prefer-128-bit,-prefer-256-bit,-prefer-mask-registers,-prefetchwt1,+prfchw,-ptwrite,-rdpid,+rdrnd,+rdseed,-retpoline,-retpoline-external-thunk,-retpoline-indirect-branches,-retpoline-indirect-calls,+rtm,+sahf,-serialize,-seses,+sgx,-sha,-shstk,+slow-3ops-lea,-slow-incdec,-slow-lea,-slow-pmaddwd,-slow-pmulld,-slow-shld,-slow-two-mem-ops,-slow-unaligned-mem-16,-slow-unaligned-mem-32,-soft-float,+sse,+sse2,+sse3,+sse4.1,+sse4.2,-sse4a,-sse-unaligned-mem,+ssse3,-tbm,-tsxldtrk,-uintr,-use-aa,-use-glm-div-sqrt-costs,-vaes,-vpclmulqdq,+vzeroupper,-waitpkg,-wbnoinvd,-widekl,+x87,-xop,+xsave,+xsavec,+xsaveopt,+xsaves" }
attributes #7 = { alwaysinline minsize nobuiltin nounwind optsize "target-cpu"="skylake" "target-features"="-16bit-mode,-32bit-mode,-3dnow,-3dnowa,+64bit,+adx,+aes,-amx-bf16,-amx-int8,-amx-tile,+avx,+avx2,-avx512bf16,-avx512bitalg,-avx512bw,-avx512cd,-avx512dq,-avx512er,-avx512f,-avx512ifma,-avx512pf,-avx512vbmi,-avx512vbmi2,-avx512vl,-avx512vnni,-avx512vp2intersect,-avx512vpopcntdq,-avxvnni,+bmi,+bmi2,-branchfusion,-cldemote,+clflushopt,-clwb,-clzero,+cmov,+cx16,+cx8,-enqcmd,+ermsb,+f16c,-false-deps-lzcnt-tzcnt,+false-deps-popcnt,-fast-11bytenop,+fast-15bytenop,-fast-7bytenop,-fast-bextr,+fast-gather,-fast-hops,-fast-lzcnt,-fast-movbe,+fast-scalar-fsqrt,-fast-scalar-shift-masks,+fast-shld-rotate,+fast-variable-crosslane-shuffle,+fast-variable-perlane-shuffle,+fast-vector-fsqrt,-fast-vector-shift-masks,+fma,-fma4,+fsgsbase,-fsrm,+fxsr,-gfni,-hreset,-idivl-to-divb,+idivq-to-divl,+invpcid,-kl,-lea-sp,-lea-uses-ag,-lvi-cfi,-lvi-load-hardening,-lwp,+lzcnt,+macrofusion,+mmx,+movbe,-movdir64b,-movdiri,-mwaitx,+nopl,-pad-short-functions,+pclmul,-pconfig,-pku,+popcnt,-prefer-128-bit,-prefer-256-bit,-prefer-mask-registers,-prefetchwt1,+prfchw,-ptwrite,-rdpid,+rdrnd,+rdseed,-retpoline,-retpoline-external-thunk,-retpoline-indirect-branches,-retpoline-indirect-calls,+rtm,+sahf,-serialize,-seses,+sgx,-sha,-shstk,+slow-3ops-lea,-slow-incdec,-slow-lea,-slow-pmaddwd,-slow-pmulld,-slow-shld,-slow-two-mem-ops,-slow-unaligned-mem-16,-slow-unaligned-mem-32,-soft-float,+sse,+sse2,+sse3,+sse4.1,+sse4.2,-sse4a,-sse-unaligned-mem,+ssse3,-tbm,-tsxldtrk,-uintr,-use-aa,-use-glm-div-sqrt-costs,-vaes,-vpclmulqdq,+vzeroupper,-waitpkg,-wbnoinvd,-widekl,+x87,-xop,+xsave,+xsavec,+xsaveopt,+xsaves" }
attributes #8 = { cold minsize nobuiltin nounwind optsize "target-cpu"="skylake" "target-features"="-16bit-mode,-32bit-mode,-3dnow,-3dnowa,+64bit,+adx,+aes,-amx-bf16,-amx-int8,-amx-tile,+avx,+avx2,-avx512bf16,-avx512bitalg,-avx512bw,-avx512cd,-avx512dq,-avx512er,-avx512f,-avx512ifma,-avx512pf,-avx512vbmi,-avx512vbmi2,-avx512vl,-avx512vnni,-avx512vp2intersect,-avx512vpopcntdq,-avxvnni,+bmi,+bmi2,-branchfusion,-cldemote,+clflushopt,-clwb,-clzero,+cmov,+cx16,+cx8,-enqcmd,+ermsb,+f16c,-false-deps-lzcnt-tzcnt,+false-deps-popcnt,-fast-11bytenop,+fast-15bytenop,-fast-7bytenop,-fast-bextr,+fast-gather,-fast-hops,-fast-lzcnt,-fast-movbe,+fast-scalar-fsqrt,-fast-scalar-shift-masks,+fast-shld-rotate,+fast-variable-crosslane-shuffle,+fast-variable-perlane-shuffle,+fast-vector-fsqrt,-fast-vector-shift-masks,+fma,-fma4,+fsgsbase,-fsrm,+fxsr,-gfni,-hreset,-idivl-to-divb,+idivq-to-divl,+invpcid,-kl,-lea-sp,-lea-uses-ag,-lvi-cfi,-lvi-load-hardening,-lwp,+lzcnt,+macrofusion,+mmx,+movbe,-movdir64b,-movdiri,-mwaitx,+nopl,-pad-short-functions,+pclmul,-pconfig,-pku,+popcnt,-prefer-128-bit,-prefer-256-bit,-prefer-mask-registers,-prefetchwt1,+prfchw,-ptwrite,-rdpid,+rdrnd,+rdseed,-retpoline,-retpoline-external-thunk,-retpoline-indirect-branches,-retpoline-indirect-calls,+rtm,+sahf,-serialize,-seses,+sgx,-sha,-shstk,+slow-3ops-lea,-slow-incdec,-slow-lea,-slow-pmaddwd,-slow-pmulld,-slow-shld,-slow-two-mem-ops,-slow-unaligned-mem-16,-slow-unaligned-mem-32,-soft-float,+sse,+sse2,+sse3,+sse4.1,+sse4.2,-sse4a,-sse-unaligned-mem,+ssse3,-tbm,-tsxldtrk,-uintr,-use-aa,-use-glm-div-sqrt-costs,-vaes,-vpclmulqdq,+vzeroupper,-waitpkg,-wbnoinvd,-widekl,+x87,-xop,+xsave,+xsavec,+xsaveopt,+xsaves" }
attributes #9 = { nofree nosync nounwind readnone speculatable willreturn }
attributes #10 = { noinline }
attributes #11 = { alwaysinline }

!llvm.module.flags = !{!0, !1}
!llvm.dbg.cu = !{!2}

!0 = !{i32 2, !"Debug Info Version", i32 3}
!1 = !{i32 2, !"Dwarf Version", i32 4}
!2 = distinct !DICompileUnit(language: DW_LANG_C99, file: !3, producer: "zig 0.10.0", isOptimized: true, runtimeVersion: 0, emissionKind: NoDebug, enums: !4)
!3 = !DIFile(filename: "code", directory: "src")
!4 = !{!5, !12, !57, !79, !225, !284, !290, !315, !322, !328, !482, !487, !849, !855, !861, !906, !921, !925, !945, !951, !956}
!5 = !DICompositeType(tag: DW_TAG_enumeration_type, name: "std.builtin.OutputMode", scope: !6, file: !6, line: 459, baseType: !7, size: 8, align: 8, elements: !8)
!6 = !DIFile(filename: "builtin.zig", directory: "/home/mike/personal/zig/build/lib/zig/std")
!7 = !DIBasicType(name: "u2", size: 8, encoding: DW_ATE_unsigned)
!8 = !{!9, !10, !11}
!9 = !DIEnumerator(name: "Exe", value: 0)
!10 = !DIEnumerator(name: "Lib", value: 1)
!11 = !DIEnumerator(name: "Obj", value: 2)
!12 = !DICompositeType(tag: DW_TAG_enumeration_type, name: "std.target.Tag", scope: !13, file: !13, line: 17, baseType: !14, size: 8, align: 8, elements: !15)
!13 = !DIFile(filename: "target.zig", directory: "/home/mike/personal/zig/build/lib/zig/std")
!14 = !DIBasicType(name: "u6", size: 8, encoding: DW_ATE_unsigned)
!15 = !{!16, !17, !18, !19, !20, !21, !22, !23, !24, !25, !26, !27, !28, !29, !30, !31, !32, !33, !34, !35, !36, !37, !38, !39, !40, !41, !42, !43, !44, !45, !46, !47, !48, !49, !50, !51, !52, !53, !54, !55, !56}
!16 = !DIEnumerator(name: "freestanding", value: 0)
!17 = !DIEnumerator(name: "ananas", value: 1)
!18 = !DIEnumerator(name: "cloudabi", value: 2)
!19 = !DIEnumerator(name: "dragonfly", value: 3)
!20 = !DIEnumerator(name: "freebsd", value: 4)
!21 = !DIEnumerator(name: "fuchsia", value: 5)
!22 = !DIEnumerator(name: "ios", value: 6)
!23 = !DIEnumerator(name: "kfreebsd", value: 7)
!24 = !DIEnumerator(name: "linux", value: 8)
!25 = !DIEnumerator(name: "lv2", value: 9)
!26 = !DIEnumerator(name: "macos", value: 10)
!27 = !DIEnumerator(name: "netbsd", value: 11)
!28 = !DIEnumerator(name: "openbsd", value: 12)
!29 = !DIEnumerator(name: "solaris", value: 13)
!30 = !DIEnumerator(name: "windows", value: 14)
!31 = !DIEnumerator(name: "zos", value: 15)
!32 = !DIEnumerator(name: "haiku", value: 16)
!33 = !DIEnumerator(name: "minix", value: 17)
!34 = !DIEnumerator(name: "rtems", value: 18)
!35 = !DIEnumerator(name: "nacl", value: 19)
!36 = !DIEnumerator(name: "aix", value: 20)
!37 = !DIEnumerator(name: "cuda", value: 21)
!38 = !DIEnumerator(name: "nvcl", value: 22)
!39 = !DIEnumerator(name: "amdhsa", value: 23)
!40 = !DIEnumerator(name: "ps4", value: 24)
!41 = !DIEnumerator(name: "elfiamcu", value: 25)
!42 = !DIEnumerator(name: "tvos", value: 26)
!43 = !DIEnumerator(name: "watchos", value: 27)
!44 = !DIEnumerator(name: "mesa3d", value: 28)
!45 = !DIEnumerator(name: "contiki", value: 29)
!46 = !DIEnumerator(name: "amdpal", value: 30)
!47 = !DIEnumerator(name: "hermit", value: 31)
!48 = !DIEnumerator(name: "hurd", value: 32)
!49 = !DIEnumerator(name: "wasi", value: 33)
!50 = !DIEnumerator(name: "emscripten", value: 34)
!51 = !DIEnumerator(name: "uefi", value: 35)
!52 = !DIEnumerator(name: "opencl", value: 36)
!53 = !DIEnumerator(name: "glsl450", value: 37)
!54 = !DIEnumerator(name: "vulkan", value: 38)
!55 = !DIEnumerator(name: "plan9", value: 39)
!56 = !DIEnumerator(name: "other", value: 40)
!57 = !DICompositeType(tag: DW_TAG_enumeration_type, name: "std.target.WindowsVersion", scope: !13, file: !13, line: 94, baseType: !58, size: 32, align: 32, elements: !59)
!58 = !DIBasicType(name: "u32", size: 32, encoding: DW_ATE_unsigned)
!59 = !{!60, !61, !62, !63, !64, !65, !66, !67, !68, !69, !70, !71, !72, !73, !74, !75, !76, !77, !78}
!60 = !DIEnumerator(name: "nt4", value: 67108864)
!61 = !DIEnumerator(name: "win2k", value: 83886080)
!62 = !DIEnumerator(name: "xp", value: 83951616)
!63 = !DIEnumerator(name: "ws2003", value: 84017152)
!64 = !DIEnumerator(name: "vista", value: 100663296)
!65 = !DIEnumerator(name: "win7", value: 100728832)
!66 = !DIEnumerator(name: "win8", value: 100794368)
!67 = !DIEnumerator(name: "win8_1", value: 100859904)
!68 = !DIEnumerator(name: "win10", value: 167772160)
!69 = !DIEnumerator(name: "win10_th2", value: 167772161)
!70 = !DIEnumerator(name: "win10_rs1", value: 167772162)
!71 = !DIEnumerator(name: "win10_rs2", value: 167772163)
!72 = !DIEnumerator(name: "win10_rs3", value: 167772164)
!73 = !DIEnumerator(name: "win10_rs4", value: 167772165)
!74 = !DIEnumerator(name: "win10_rs5", value: 167772166)
!75 = !DIEnumerator(name: "win10_19h1", value: 167772167)
!76 = !DIEnumerator(name: "win10_vb", value: 167772168)
!77 = !DIEnumerator(name: "win10_mn", value: 167772169)
!78 = !DIEnumerator(name: "win10_fe", value: 167772170)
!79 = !DICompositeType(tag: DW_TAG_enumeration_type, name: "std.target.x86.Feature", scope: !80, file: !80, line: 7, baseType: !81, size: 8, align: 8, elements: !82)
!80 = !DIFile(filename: "x86.zig", directory: "/home/mike/personal/zig/build/lib/zig/std/target")
!81 = !DIBasicType(name: "u8", size: 8, encoding: DW_ATE_unsigned_char)
!82 = !{!83, !84, !85, !86, !87, !88, !89, !90, !91, !92, !93, !94, !95, !96, !97, !98, !99, !100, !101, !102, !103, !104, !105, !106, !107, !108, !109, !110, !111, !112, !113, !114, !115, !116, !117, !118, !119, !120, !121, !122, !123, !124, !125, !126, !127, !128, !129, !130, !131, !132, !133, !134, !135, !136, !137, !138, !139, !140, !141, !142, !143, !144, !145, !146, !147, !148, !149, !150, !151, !152, !153, !154, !155, !156, !157, !158, !159, !160, !161, !162, !163, !164, !165, !166, !167, !168, !169, !170, !171, !172, !173, !174, !175, !176, !177, !178, !179, !180, !181, !182, !183, !184, !185, !186, !187, !188, !189, !190, !191, !192, !193, !194, !195, !196, !197, !198, !199, !200, !201, !202, !203, !204, !205, !206, !207, !208, !209, !210, !211, !212, !213, !214, !215, !216, !217, !218, !219, !220, !221, !222, !223, !224}
!83 = !DIEnumerator(name: "16bit_mode", value: 0)
!84 = !DIEnumerator(name: "32bit_mode", value: 1)
!85 = !DIEnumerator(name: "3dnow", value: 2)
!86 = !DIEnumerator(name: "3dnowa", value: 3)
!87 = !DIEnumerator(name: "64bit", value: 4)
!88 = !DIEnumerator(name: "adx", value: 5)
!89 = !DIEnumerator(name: "aes", value: 6)
!90 = !DIEnumerator(name: "amx_bf16", value: 7)
!91 = !DIEnumerator(name: "amx_int8", value: 8)
!92 = !DIEnumerator(name: "amx_tile", value: 9)
!93 = !DIEnumerator(name: "avx", value: 10)
!94 = !DIEnumerator(name: "avx2", value: 11)
!95 = !DIEnumerator(name: "avx512bf16", value: 12)
!96 = !DIEnumerator(name: "avx512bitalg", value: 13)
!97 = !DIEnumerator(name: "avx512bw", value: 14)
!98 = !DIEnumerator(name: "avx512cd", value: 15)
!99 = !DIEnumerator(name: "avx512dq", value: 16)
!100 = !DIEnumerator(name: "avx512er", value: 17)
!101 = !DIEnumerator(name: "avx512f", value: 18)
!102 = !DIEnumerator(name: "avx512ifma", value: 19)
!103 = !DIEnumerator(name: "avx512pf", value: 20)
!104 = !DIEnumerator(name: "avx512vbmi", value: 21)
!105 = !DIEnumerator(name: "avx512vbmi2", value: 22)
!106 = !DIEnumerator(name: "avx512vl", value: 23)
!107 = !DIEnumerator(name: "avx512vnni", value: 24)
!108 = !DIEnumerator(name: "avx512vp2intersect", value: 25)
!109 = !DIEnumerator(name: "avx512vpopcntdq", value: 26)
!110 = !DIEnumerator(name: "avxvnni", value: 27)
!111 = !DIEnumerator(name: "bmi", value: 28)
!112 = !DIEnumerator(name: "bmi2", value: 29)
!113 = !DIEnumerator(name: "branchfusion", value: 30)
!114 = !DIEnumerator(name: "cldemote", value: 31)
!115 = !DIEnumerator(name: "clflushopt", value: 32)
!116 = !DIEnumerator(name: "clwb", value: 33)
!117 = !DIEnumerator(name: "clzero", value: 34)
!118 = !DIEnumerator(name: "cmov", value: 35)
!119 = !DIEnumerator(name: "cx16", value: 36)
!120 = !DIEnumerator(name: "cx8", value: 37)
!121 = !DIEnumerator(name: "enqcmd", value: 38)
!122 = !DIEnumerator(name: "ermsb", value: 39)
!123 = !DIEnumerator(name: "f16c", value: 40)
!124 = !DIEnumerator(name: "false_deps_lzcnt_tzcnt", value: 41)
!125 = !DIEnumerator(name: "false_deps_popcnt", value: 42)
!126 = !DIEnumerator(name: "fast_11bytenop", value: 43)
!127 = !DIEnumerator(name: "fast_15bytenop", value: 44)
!128 = !DIEnumerator(name: "fast_7bytenop", value: 45)
!129 = !DIEnumerator(name: "fast_bextr", value: 46)
!130 = !DIEnumerator(name: "fast_gather", value: 47)
!131 = !DIEnumerator(name: "fast_hops", value: 48)
!132 = !DIEnumerator(name: "fast_lzcnt", value: 49)
!133 = !DIEnumerator(name: "fast_movbe", value: 50)
!134 = !DIEnumerator(name: "fast_scalar_fsqrt", value: 51)
!135 = !DIEnumerator(name: "fast_scalar_shift_masks", value: 52)
!136 = !DIEnumerator(name: "fast_shld_rotate", value: 53)
!137 = !DIEnumerator(name: "fast_variable_crosslane_shuffle", value: 54)
!138 = !DIEnumerator(name: "fast_variable_perlane_shuffle", value: 55)
!139 = !DIEnumerator(name: "fast_vector_fsqrt", value: 56)
!140 = !DIEnumerator(name: "fast_vector_shift_masks", value: 57)
!141 = !DIEnumerator(name: "fma", value: 58)
!142 = !DIEnumerator(name: "fma4", value: 59)
!143 = !DIEnumerator(name: "fsgsbase", value: 60)
!144 = !DIEnumerator(name: "fsrm", value: 61)
!145 = !DIEnumerator(name: "fxsr", value: 62)
!146 = !DIEnumerator(name: "gfni", value: 63)
!147 = !DIEnumerator(name: "hreset", value: 64)
!148 = !DIEnumerator(name: "idivl_to_divb", value: 65)
!149 = !DIEnumerator(name: "idivq_to_divl", value: 66)
!150 = !DIEnumerator(name: "invpcid", value: 67)
!151 = !DIEnumerator(name: "kl", value: 68)
!152 = !DIEnumerator(name: "lea_sp", value: 69)
!153 = !DIEnumerator(name: "lea_uses_ag", value: 70)
!154 = !DIEnumerator(name: "lvi_cfi", value: 71)
!155 = !DIEnumerator(name: "lvi_load_hardening", value: 72)
!156 = !DIEnumerator(name: "lwp", value: 73)
!157 = !DIEnumerator(name: "lzcnt", value: 74)
!158 = !DIEnumerator(name: "macrofusion", value: 75)
!159 = !DIEnumerator(name: "mmx", value: 76)
!160 = !DIEnumerator(name: "movbe", value: 77)
!161 = !DIEnumerator(name: "movdir64b", value: 78)
!162 = !DIEnumerator(name: "movdiri", value: 79)
!163 = !DIEnumerator(name: "mwaitx", value: 80)
!164 = !DIEnumerator(name: "nopl", value: 81)
!165 = !DIEnumerator(name: "pad_short_functions", value: 82)
!166 = !DIEnumerator(name: "pclmul", value: 83)
!167 = !DIEnumerator(name: "pconfig", value: 84)
!168 = !DIEnumerator(name: "pku", value: 85)
!169 = !DIEnumerator(name: "popcnt", value: 86)
!170 = !DIEnumerator(name: "prefer_128_bit", value: 87)
!171 = !DIEnumerator(name: "prefer_256_bit", value: 88)
!172 = !DIEnumerator(name: "prefer_mask_registers", value: 89)
!173 = !DIEnumerator(name: "prefetchwt1", value: 90)
!174 = !DIEnumerator(name: "prfchw", value: 91)
!175 = !DIEnumerator(name: "ptwrite", value: 92)
!176 = !DIEnumerator(name: "rdpid", value: 93)
!177 = !DIEnumerator(name: "rdrnd", value: 94)
!178 = !DIEnumerator(name: "rdseed", value: 95)
!179 = !DIEnumerator(name: "retpoline", value: 96)
!180 = !DIEnumerator(name: "retpoline_external_thunk", value: 97)
!181 = !DIEnumerator(name: "retpoline_indirect_branches", value: 98)
!182 = !DIEnumerator(name: "retpoline_indirect_calls", value: 99)
!183 = !DIEnumerator(name: "rtm", value: 100)
!184 = !DIEnumerator(name: "sahf", value: 101)
!185 = !DIEnumerator(name: "serialize", value: 102)
!186 = !DIEnumerator(name: "seses", value: 103)
!187 = !DIEnumerator(name: "sgx", value: 104)
!188 = !DIEnumerator(name: "sha", value: 105)
!189 = !DIEnumerator(name: "shstk", value: 106)
!190 = !DIEnumerator(name: "slow_3ops_lea", value: 107)
!191 = !DIEnumerator(name: "slow_incdec", value: 108)
!192 = !DIEnumerator(name: "slow_lea", value: 109)
!193 = !DIEnumerator(name: "slow_pmaddwd", value: 110)
!194 = !DIEnumerator(name: "slow_pmulld", value: 111)
!195 = !DIEnumerator(name: "slow_shld", value: 112)
!196 = !DIEnumerator(name: "slow_two_mem_ops", value: 113)
!197 = !DIEnumerator(name: "slow_unaligned_mem_16", value: 114)
!198 = !DIEnumerator(name: "slow_unaligned_mem_32", value: 115)
!199 = !DIEnumerator(name: "soft_float", value: 116)
!200 = !DIEnumerator(name: "sse", value: 117)
!201 = !DIEnumerator(name: "sse2", value: 118)
!202 = !DIEnumerator(name: "sse3", value: 119)
!203 = !DIEnumerator(name: "sse4_1", value: 120)
!204 = !DIEnumerator(name: "sse4_2", value: 121)
!205 = !DIEnumerator(name: "sse4a", value: 122)
!206 = !DIEnumerator(name: "sse_unaligned_mem", value: 123)
!207 = !DIEnumerator(name: "ssse3", value: 124)
!208 = !DIEnumerator(name: "tbm", value: 125)
!209 = !DIEnumerator(name: "tsxldtrk", value: 126)
!210 = !DIEnumerator(name: "uintr", value: 127)
!211 = !DIEnumerator(name: "use_aa", value: 128)
!212 = !DIEnumerator(name: "use_glm_div_sqrt_costs", value: 129)
!213 = !DIEnumerator(name: "vaes", value: 130)
!214 = !DIEnumerator(name: "vpclmulqdq", value: 131)
!215 = !DIEnumerator(name: "vzeroupper", value: 132)
!216 = !DIEnumerator(name: "waitpkg", value: 133)
!217 = !DIEnumerator(name: "wbnoinvd", value: 134)
!218 = !DIEnumerator(name: "widekl", value: 135)
!219 = !DIEnumerator(name: "x87", value: 136)
!220 = !DIEnumerator(name: "xop", value: 137)
!221 = !DIEnumerator(name: "xsave", value: 138)
!222 = !DIEnumerator(name: "xsavec", value: 139)
!223 = !DIEnumerator(name: "xsaveopt", value: 140)
!224 = !DIEnumerator(name: "xsaves", value: 141)
!225 = !DICompositeType(tag: DW_TAG_enumeration_type, name: "std.target.Arch", scope: !13, file: !13, line: 760, baseType: !14, size: 8, align: 8, elements: !226)
!226 = !{!227, !228, !229, !230, !231, !232, !233, !234, !235, !236, !237, !238, !239, !240, !241, !242, !243, !244, !245, !246, !247, !248, !249, !250, !251, !252, !253, !254, !255, !256, !257, !258, !259, !260, !261, !262, !263, !264, !265, !266, !267, !268, !269, !270, !271, !272, !273, !274, !275, !276, !277, !278, !279, !280, !281, !282, !283}
!227 = !DIEnumerator(name: "arm", value: 0)
!228 = !DIEnumerator(name: "armeb", value: 1)
!229 = !DIEnumerator(name: "aarch64", value: 2)
!230 = !DIEnumerator(name: "aarch64_be", value: 3)
!231 = !DIEnumerator(name: "aarch64_32", value: 4)
!232 = !DIEnumerator(name: "arc", value: 5)
!233 = !DIEnumerator(name: "avr", value: 6)
!234 = !DIEnumerator(name: "bpfel", value: 7)
!235 = !DIEnumerator(name: "bpfeb", value: 8)
!236 = !DIEnumerator(name: "csky", value: 9)
!237 = !DIEnumerator(name: "hexagon", value: 10)
!238 = !DIEnumerator(name: "m68k", value: 11)
!239 = !DIEnumerator(name: "mips", value: 12)
!240 = !DIEnumerator(name: "mipsel", value: 13)
!241 = !DIEnumerator(name: "mips64", value: 14)
!242 = !DIEnumerator(name: "mips64el", value: 15)
!243 = !DIEnumerator(name: "msp430", value: 16)
!244 = !DIEnumerator(name: "powerpc", value: 17)
!245 = !DIEnumerator(name: "powerpcle", value: 18)
!246 = !DIEnumerator(name: "powerpc64", value: 19)
!247 = !DIEnumerator(name: "powerpc64le", value: 20)
!248 = !DIEnumerator(name: "r600", value: 21)
!249 = !DIEnumerator(name: "amdgcn", value: 22)
!250 = !DIEnumerator(name: "riscv32", value: 23)
!251 = !DIEnumerator(name: "riscv64", value: 24)
!252 = !DIEnumerator(name: "sparc", value: 25)
!253 = !DIEnumerator(name: "sparcv9", value: 26)
!254 = !DIEnumerator(name: "sparcel", value: 27)
!255 = !DIEnumerator(name: "s390x", value: 28)
!256 = !DIEnumerator(name: "tce", value: 29)
!257 = !DIEnumerator(name: "tcele", value: 30)
!258 = !DIEnumerator(name: "thumb", value: 31)
!259 = !DIEnumerator(name: "thumbeb", value: 32)
!260 = !DIEnumerator(name: "i386", value: 33)
!261 = !DIEnumerator(name: "x86_64", value: 34)
!262 = !DIEnumerator(name: "xcore", value: 35)
!263 = !DIEnumerator(name: "nvptx", value: 36)
!264 = !DIEnumerator(name: "nvptx64", value: 37)
!265 = !DIEnumerator(name: "le32", value: 38)
!266 = !DIEnumerator(name: "le64", value: 39)
!267 = !DIEnumerator(name: "amdil", value: 40)
!268 = !DIEnumerator(name: "amdil64", value: 41)
!269 = !DIEnumerator(name: "hsail", value: 42)
!270 = !DIEnumerator(name: "hsail64", value: 43)
!271 = !DIEnumerator(name: "spir", value: 44)
!272 = !DIEnumerator(name: "spir64", value: 45)
!273 = !DIEnumerator(name: "kalimba", value: 46)
!274 = !DIEnumerator(name: "shave", value: 47)
!275 = !DIEnumerator(name: "lanai", value: 48)
!276 = !DIEnumerator(name: "wasm32", value: 49)
!277 = !DIEnumerator(name: "wasm64", value: 50)
!278 = !DIEnumerator(name: "renderscript32", value: 51)
!279 = !DIEnumerator(name: "renderscript64", value: 52)
!280 = !DIEnumerator(name: "ve", value: 53)
!281 = !DIEnumerator(name: "spu_2", value: 54)
!282 = !DIEnumerator(name: "spirv32", value: 55)
!283 = !DIEnumerator(name: "spirv64", value: 56)
!284 = !DICompositeType(tag: DW_TAG_enumeration_type, name: "std.builtin.Mode", scope: !6, file: !6, line: 148, baseType: !7, size: 8, align: 8, elements: !285)
!285 = !{!286, !287, !288, !289}
!286 = !DIEnumerator(name: "Debug", value: 0)
!287 = !DIEnumerator(name: "ReleaseSafe", value: 1)
!288 = !DIEnumerator(name: "ReleaseFast", value: 2)
!289 = !DIEnumerator(name: "ReleaseSmall", value: 3)
!290 = !DICompositeType(tag: DW_TAG_enumeration_type, name: "std.target.Abi", scope: !13, file: !13, line: 461, baseType: !291, size: 8, align: 8, elements: !292)
!291 = !DIBasicType(name: "u5", size: 8, encoding: DW_ATE_unsigned)
!292 = !{!293, !294, !295, !296, !297, !298, !299, !300, !301, !302, !303, !304, !305, !306, !307, !308, !309, !310, !311, !312, !313, !314}
!293 = !DIEnumerator(name: "none", value: 0)
!294 = !DIEnumerator(name: "gnu", value: 1)
!295 = !DIEnumerator(name: "gnuabin32", value: 2)
!296 = !DIEnumerator(name: "gnuabi64", value: 3)
!297 = !DIEnumerator(name: "gnueabi", value: 4)
!298 = !DIEnumerator(name: "gnueabihf", value: 5)
!299 = !DIEnumerator(name: "gnux32", value: 6)
!300 = !DIEnumerator(name: "gnuilp32", value: 7)
!301 = !DIEnumerator(name: "code16", value: 8)
!302 = !DIEnumerator(name: "eabi", value: 9)
!303 = !DIEnumerator(name: "eabihf", value: 10)
!304 = !DIEnumerator(name: "android", value: 11)
!305 = !DIEnumerator(name: "musl", value: 12)
!306 = !DIEnumerator(name: "musleabi", value: 13)
!307 = !DIEnumerator(name: "musleabihf", value: 14)
!308 = !DIEnumerator(name: "muslx32", value: 15)
!309 = !DIEnumerator(name: "msvc", value: 16)
!310 = !DIEnumerator(name: "itanium", value: 17)
!311 = !DIEnumerator(name: "cygnus", value: 18)
!312 = !DIEnumerator(name: "coreclr", value: 19)
!313 = !DIEnumerator(name: "simulator", value: 20)
!314 = !DIEnumerator(name: "macabi", value: 21)
!315 = !DICompositeType(tag: DW_TAG_enumeration_type, name: "std.Thread.Mutex.State", scope: !316, file: !316, line: 63, baseType: !317, size: 32, align: 32, elements: !318)
!316 = !DIFile(filename: "Mutex.zig", directory: "/home/mike/personal/zig/build/lib/zig/std/Thread")
!317 = !DIBasicType(name: "i32", size: 32, encoding: DW_ATE_signed)
!318 = !{!319, !320, !321}
!319 = !DIEnumerator(name: "unlocked", value: 0)
!320 = !DIEnumerator(name: "locked", value: 1)
!321 = !DIEnumerator(name: "waiting", value: 2)
!322 = !DICompositeType(tag: DW_TAG_enumeration_type, name: "std.io.Mode", scope: !323, file: !323, line: 15, baseType: !324, size: 8, align: 8, elements: !325)
!323 = !DIFile(filename: "io.zig", directory: "/home/mike/personal/zig/build/lib/zig/std")
!324 = !DIBasicType(name: "u1", size: 8, encoding: DW_ATE_unsigned)
!325 = !{!326, !327}
!326 = !DIEnumerator(name: "blocking", value: 0)
!327 = !DIEnumerator(name: "evented", value: 1)
!328 = !DICompositeType(tag: DW_TAG_enumeration_type, name: "std.os.linux.errno.generic.E", scope: !329, file: !329, line: 1, baseType: !330, size: 16, align: 16, elements: !331)
!329 = !DIFile(filename: "generic.zig", directory: "/home/mike/personal/zig/build/lib/zig/std/os/linux/errno")
!330 = !DIBasicType(name: "u16", size: 16, encoding: DW_ATE_unsigned)
!331 = !{!332, !333, !334, !335, !336, !337, !338, !339, !340, !341, !342, !343, !344, !345, !346, !347, !348, !349, !350, !351, !352, !353, !354, !355, !356, !357, !358, !359, !360, !361, !362, !363, !364, !365, !366, !367, !368, !369, !370, !371, !372, !373, !374, !375, !376, !377, !378, !379, !380, !381, !382, !383, !384, !385, !386, !387, !388, !389, !390, !391, !392, !393, !394, !395, !396, !397, !398, !399, !400, !401, !402, !403, !404, !405, !406, !407, !408, !409, !410, !411, !412, !413, !414, !415, !416, !417, !418, !419, !420, !421, !422, !423, !424, !425, !426, !427, !428, !429, !430, !431, !432, !433, !434, !435, !436, !437, !438, !439, !440, !441, !442, !443, !444, !445, !446, !447, !448, !449, !450, !451, !452, !453, !454, !455, !456, !457, !458, !459, !460, !461, !462, !463, !464, !465, !466, !467, !468, !469, !470, !471, !472, !473, !474, !475, !476, !477, !478, !479, !480, !481}
!332 = !DIEnumerator(name: "SUCCESS", value: 0)
!333 = !DIEnumerator(name: "PERM", value: 1)
!334 = !DIEnumerator(name: "NOENT", value: 2)
!335 = !DIEnumerator(name: "SRCH", value: 3)
!336 = !DIEnumerator(name: "INTR", value: 4)
!337 = !DIEnumerator(name: "IO", value: 5)
!338 = !DIEnumerator(name: "NXIO", value: 6)
!339 = !DIEnumerator(name: "2BIG", value: 7)
!340 = !DIEnumerator(name: "NOEXEC", value: 8)
!341 = !DIEnumerator(name: "BADF", value: 9)
!342 = !DIEnumerator(name: "CHILD", value: 10)
!343 = !DIEnumerator(name: "AGAIN", value: 11)
!344 = !DIEnumerator(name: "NOMEM", value: 12)
!345 = !DIEnumerator(name: "ACCES", value: 13)
!346 = !DIEnumerator(name: "FAULT", value: 14)
!347 = !DIEnumerator(name: "NOTBLK", value: 15)
!348 = !DIEnumerator(name: "BUSY", value: 16)
!349 = !DIEnumerator(name: "EXIST", value: 17)
!350 = !DIEnumerator(name: "XDEV", value: 18)
!351 = !DIEnumerator(name: "NODEV", value: 19)
!352 = !DIEnumerator(name: "NOTDIR", value: 20)
!353 = !DIEnumerator(name: "ISDIR", value: 21)
!354 = !DIEnumerator(name: "INVAL", value: 22)
!355 = !DIEnumerator(name: "NFILE", value: 23)
!356 = !DIEnumerator(name: "MFILE", value: 24)
!357 = !DIEnumerator(name: "NOTTY", value: 25)
!358 = !DIEnumerator(name: "TXTBSY", value: 26)
!359 = !DIEnumerator(name: "FBIG", value: 27)
!360 = !DIEnumerator(name: "NOSPC", value: 28)
!361 = !DIEnumerator(name: "SPIPE", value: 29)
!362 = !DIEnumerator(name: "ROFS", value: 30)
!363 = !DIEnumerator(name: "MLINK", value: 31)
!364 = !DIEnumerator(name: "PIPE", value: 32)
!365 = !DIEnumerator(name: "DOM", value: 33)
!366 = !DIEnumerator(name: "RANGE", value: 34)
!367 = !DIEnumerator(name: "DEADLK", value: 35)
!368 = !DIEnumerator(name: "NAMETOOLONG", value: 36)
!369 = !DIEnumerator(name: "NOLCK", value: 37)
!370 = !DIEnumerator(name: "NOSYS", value: 38)
!371 = !DIEnumerator(name: "NOTEMPTY", value: 39)
!372 = !DIEnumerator(name: "LOOP", value: 40)
!373 = !DIEnumerator(name: "NOMSG", value: 42)
!374 = !DIEnumerator(name: "IDRM", value: 43)
!375 = !DIEnumerator(name: "CHRNG", value: 44)
!376 = !DIEnumerator(name: "L2NSYNC", value: 45)
!377 = !DIEnumerator(name: "L3HLT", value: 46)
!378 = !DIEnumerator(name: "L3RST", value: 47)
!379 = !DIEnumerator(name: "LNRNG", value: 48)
!380 = !DIEnumerator(name: "UNATCH", value: 49)
!381 = !DIEnumerator(name: "NOCSI", value: 50)
!382 = !DIEnumerator(name: "L2HLT", value: 51)
!383 = !DIEnumerator(name: "BADE", value: 52)
!384 = !DIEnumerator(name: "BADR", value: 53)
!385 = !DIEnumerator(name: "XFULL", value: 54)
!386 = !DIEnumerator(name: "NOANO", value: 55)
!387 = !DIEnumerator(name: "BADRQC", value: 56)
!388 = !DIEnumerator(name: "BADSLT", value: 57)
!389 = !DIEnumerator(name: "BFONT", value: 59)
!390 = !DIEnumerator(name: "NOSTR", value: 60)
!391 = !DIEnumerator(name: "NODATA", value: 61)
!392 = !DIEnumerator(name: "TIME", value: 62)
!393 = !DIEnumerator(name: "NOSR", value: 63)
!394 = !DIEnumerator(name: "NONET", value: 64)
!395 = !DIEnumerator(name: "NOPKG", value: 65)
!396 = !DIEnumerator(name: "REMOTE", value: 66)
!397 = !DIEnumerator(name: "NOLINK", value: 67)
!398 = !DIEnumerator(name: "ADV", value: 68)
!399 = !DIEnumerator(name: "SRMNT", value: 69)
!400 = !DIEnumerator(name: "COMM", value: 70)
!401 = !DIEnumerator(name: "PROTO", value: 71)
!402 = !DIEnumerator(name: "MULTIHOP", value: 72)
!403 = !DIEnumerator(name: "DOTDOT", value: 73)
!404 = !DIEnumerator(name: "BADMSG", value: 74)
!405 = !DIEnumerator(name: "OVERFLOW", value: 75)
!406 = !DIEnumerator(name: "NOTUNIQ", value: 76)
!407 = !DIEnumerator(name: "BADFD", value: 77)
!408 = !DIEnumerator(name: "REMCHG", value: 78)
!409 = !DIEnumerator(name: "LIBACC", value: 79)
!410 = !DIEnumerator(name: "LIBBAD", value: 80)
!411 = !DIEnumerator(name: "LIBSCN", value: 81)
!412 = !DIEnumerator(name: "LIBMAX", value: 82)
!413 = !DIEnumerator(name: "LIBEXEC", value: 83)
!414 = !DIEnumerator(name: "ILSEQ", value: 84)
!415 = !DIEnumerator(name: "RESTART", value: 85)
!416 = !DIEnumerator(name: "STRPIPE", value: 86)
!417 = !DIEnumerator(name: "USERS", value: 87)
!418 = !DIEnumerator(name: "NOTSOCK", value: 88)
!419 = !DIEnumerator(name: "DESTADDRREQ", value: 89)
!420 = !DIEnumerator(name: "MSGSIZE", value: 90)
!421 = !DIEnumerator(name: "PROTOTYPE", value: 91)
!422 = !DIEnumerator(name: "NOPROTOOPT", value: 92)
!423 = !DIEnumerator(name: "PROTONOSUPPORT", value: 93)
!424 = !DIEnumerator(name: "SOCKTNOSUPPORT", value: 94)
!425 = !DIEnumerator(name: "OPNOTSUPP", value: 95)
!426 = !DIEnumerator(name: "PFNOSUPPORT", value: 96)
!427 = !DIEnumerator(name: "AFNOSUPPORT", value: 97)
!428 = !DIEnumerator(name: "ADDRINUSE", value: 98)
!429 = !DIEnumerator(name: "ADDRNOTAVAIL", value: 99)
!430 = !DIEnumerator(name: "NETDOWN", value: 100)
!431 = !DIEnumerator(name: "NETUNREACH", value: 101)
!432 = !DIEnumerator(name: "NETRESET", value: 102)
!433 = !DIEnumerator(name: "CONNABORTED", value: 103)
!434 = !DIEnumerator(name: "CONNRESET", value: 104)
!435 = !DIEnumerator(name: "NOBUFS", value: 105)
!436 = !DIEnumerator(name: "ISCONN", value: 106)
!437 = !DIEnumerator(name: "NOTCONN", value: 107)
!438 = !DIEnumerator(name: "SHUTDOWN", value: 108)
!439 = !DIEnumerator(name: "TOOMANYREFS", value: 109)
!440 = !DIEnumerator(name: "TIMEDOUT", value: 110)
!441 = !DIEnumerator(name: "CONNREFUSED", value: 111)
!442 = !DIEnumerator(name: "HOSTDOWN", value: 112)
!443 = !DIEnumerator(name: "HOSTUNREACH", value: 113)
!444 = !DIEnumerator(name: "ALREADY", value: 114)
!445 = !DIEnumerator(name: "INPROGRESS", value: 115)
!446 = !DIEnumerator(name: "STALE", value: 116)
!447 = !DIEnumerator(name: "UCLEAN", value: 117)
!448 = !DIEnumerator(name: "NOTNAM", value: 118)
!449 = !DIEnumerator(name: "NAVAIL", value: 119)
!450 = !DIEnumerator(name: "ISNAM", value: 120)
!451 = !DIEnumerator(name: "REMOTEIO", value: 121)
!452 = !DIEnumerator(name: "DQUOT", value: 122)
!453 = !DIEnumerator(name: "NOMEDIUM", value: 123)
!454 = !DIEnumerator(name: "MEDIUMTYPE", value: 124)
!455 = !DIEnumerator(name: "CANCELED", value: 125)
!456 = !DIEnumerator(name: "NOKEY", value: 126)
!457 = !DIEnumerator(name: "KEYEXPIRED", value: 127)
!458 = !DIEnumerator(name: "KEYREVOKED", value: 128)
!459 = !DIEnumerator(name: "KEYREJECTED", value: 129)
!460 = !DIEnumerator(name: "OWNERDEAD", value: 130)
!461 = !DIEnumerator(name: "NOTRECOVERABLE", value: 131)
!462 = !DIEnumerator(name: "RFKILL", value: 132)
!463 = !DIEnumerator(name: "HWPOISON", value: 133)
!464 = !DIEnumerator(name: "NSRNODATA", value: 160)
!465 = !DIEnumerator(name: "NSRFORMERR", value: 161)
!466 = !DIEnumerator(name: "NSRSERVFAIL", value: 162)
!467 = !DIEnumerator(name: "NSRNOTFOUND", value: 163)
!468 = !DIEnumerator(name: "NSRNOTIMP", value: 164)
!469 = !DIEnumerator(name: "NSRREFUSED", value: 165)
!470 = !DIEnumerator(name: "NSRBADQUERY", value: 166)
!471 = !DIEnumerator(name: "NSRBADNAME", value: 167)
!472 = !DIEnumerator(name: "NSRBADFAMILY", value: 168)
!473 = !DIEnumerator(name: "NSRBADRESP", value: 169)
!474 = !DIEnumerator(name: "NSRCONNREFUSED", value: 170)
!475 = !DIEnumerator(name: "NSRTIMEOUT", value: 171)
!476 = !DIEnumerator(name: "NSROF", value: 172)
!477 = !DIEnumerator(name: "NSRFILE", value: 173)
!478 = !DIEnumerator(name: "NSRNOMEM", value: 174)
!479 = !DIEnumerator(name: "NSRDESTRUCTION", value: 175)
!480 = !DIEnumerator(name: "NSRQUERYDOMAINTOOLONG", value: 176)
!481 = !DIEnumerator(name: "NSRCNAMELOOP", value: 177)
!482 = !DICompositeType(tag: DW_TAG_enumeration_type, name: "std.os.linux.tls.TLSVariant", scope: !483, file: !483, line: 45, baseType: !324, size: 8, align: 8, elements: !484)
!483 = !DIFile(filename: "tls.zig", directory: "/home/mike/personal/zig/build/lib/zig/std/os/linux")
!484 = !{!485, !486}
!485 = !DIEnumerator(name: "VariantI", value: 0)
!486 = !DIEnumerator(name: "VariantII", value: 1)
!487 = !DICompositeType(tag: DW_TAG_enumeration_type, name: "std.os.linux.x86_64.SYS", scope: !488, file: !488, line: 121, baseType: !489, size: 64, align: 64, elements: !490)
!488 = !DIFile(filename: "x86_64.zig", directory: "/home/mike/personal/zig/build/lib/zig/std/os/linux")
!489 = !DIBasicType(name: "usize", size: 64, encoding: DW_ATE_unsigned)
!490 = !{!491, !492, !493, !494, !495, !496, !497, !498, !499, !500, !501, !502, !503, !504, !505, !506, !507, !508, !509, !510, !511, !512, !513, !514, !515, !516, !517, !518, !519, !520, !521, !522, !523, !524, !525, !526, !527, !528, !529, !530, !531, !532, !533, !534, !535, !536, !537, !538, !539, !540, !541, !542, !543, !544, !545, !546, !547, !548, !549, !550, !551, !552, !553, !554, !555, !556, !557, !558, !559, !560, !561, !562, !563, !564, !565, !566, !567, !568, !569, !570, !571, !572, !573, !574, !575, !576, !577, !578, !579, !580, !581, !582, !583, !584, !585, !586, !587, !588, !589, !590, !591, !592, !593, !594, !595, !596, !597, !598, !599, !600, !601, !602, !603, !604, !605, !606, !607, !608, !609, !610, !611, !612, !613, !614, !615, !616, !617, !618, !619, !620, !621, !622, !623, !624, !625, !626, !627, !628, !629, !630, !631, !632, !633, !634, !635, !636, !637, !638, !639, !640, !641, !642, !643, !644, !645, !646, !647, !648, !649, !650, !651, !652, !653, !654, !655, !656, !657, !658, !659, !660, !661, !662, !663, !664, !665, !666, !667, !668, !669, !670, !671, !672, !673, !674, !675, !676, !677, !678, !679, !680, !681, !682, !683, !684, !685, !686, !687, !688, !689, !690, !691, !692, !693, !694, !695, !696, !697, !698, !699, !700, !701, !702, !703, !704, !705, !706, !707, !708, !709, !710, !711, !712, !713, !714, !715, !716, !717, !718, !719, !720, !721, !722, !723, !724, !725, !726, !727, !728, !729, !730, !731, !732, !733, !734, !735, !736, !737, !738, !739, !740, !741, !742, !743, !744, !745, !746, !747, !748, !749, !750, !751, !752, !753, !754, !755, !756, !757, !758, !759, !760, !761, !762, !763, !764, !765, !766, !767, !768, !769, !770, !771, !772, !773, !774, !775, !776, !777, !778, !779, !780, !781, !782, !783, !784, !785, !786, !787, !788, !789, !790, !791, !792, !793, !794, !795, !796, !797, !798, !799, !800, !801, !802, !803, !804, !805, !806, !807, !808, !809, !810, !811, !812, !813, !814, !815, !816, !817, !818, !819, !820, !821, !822, !823, !824, !825, !826, !827, !828, !829, !830, !831, !832, !833, !834, !835, !836, !837, !838, !839, !840, !841, !842, !843, !844, !845, !846, !847, !848}
!491 = !DIEnumerator(name: "read", value: 0)
!492 = !DIEnumerator(name: "write", value: 1)
!493 = !DIEnumerator(name: "open", value: 2)
!494 = !DIEnumerator(name: "close", value: 3)
!495 = !DIEnumerator(name: "stat", value: 4)
!496 = !DIEnumerator(name: "fstat", value: 5)
!497 = !DIEnumerator(name: "lstat", value: 6)
!498 = !DIEnumerator(name: "poll", value: 7)
!499 = !DIEnumerator(name: "lseek", value: 8)
!500 = !DIEnumerator(name: "mmap", value: 9)
!501 = !DIEnumerator(name: "mprotect", value: 10)
!502 = !DIEnumerator(name: "munmap", value: 11)
!503 = !DIEnumerator(name: "brk", value: 12)
!504 = !DIEnumerator(name: "rt_sigaction", value: 13)
!505 = !DIEnumerator(name: "rt_sigprocmask", value: 14)
!506 = !DIEnumerator(name: "rt_sigreturn", value: 15)
!507 = !DIEnumerator(name: "ioctl", value: 16)
!508 = !DIEnumerator(name: "pread", value: 17)
!509 = !DIEnumerator(name: "pwrite", value: 18)
!510 = !DIEnumerator(name: "readv", value: 19)
!511 = !DIEnumerator(name: "writev", value: 20)
!512 = !DIEnumerator(name: "access", value: 21)
!513 = !DIEnumerator(name: "pipe", value: 22)
!514 = !DIEnumerator(name: "select", value: 23)
!515 = !DIEnumerator(name: "sched_yield", value: 24)
!516 = !DIEnumerator(name: "mremap", value: 25)
!517 = !DIEnumerator(name: "msync", value: 26)
!518 = !DIEnumerator(name: "mincore", value: 27)
!519 = !DIEnumerator(name: "madvise", value: 28)
!520 = !DIEnumerator(name: "shmget", value: 29)
!521 = !DIEnumerator(name: "shmat", value: 30)
!522 = !DIEnumerator(name: "shmctl", value: 31)
!523 = !DIEnumerator(name: "dup", value: 32)
!524 = !DIEnumerator(name: "dup2", value: 33)
!525 = !DIEnumerator(name: "pause", value: 34)
!526 = !DIEnumerator(name: "nanosleep", value: 35)
!527 = !DIEnumerator(name: "getitimer", value: 36)
!528 = !DIEnumerator(name: "alarm", value: 37)
!529 = !DIEnumerator(name: "setitimer", value: 38)
!530 = !DIEnumerator(name: "getpid", value: 39)
!531 = !DIEnumerator(name: "sendfile", value: 40)
!532 = !DIEnumerator(name: "socket", value: 41)
!533 = !DIEnumerator(name: "connect", value: 42)
!534 = !DIEnumerator(name: "accept", value: 43)
!535 = !DIEnumerator(name: "sendto", value: 44)
!536 = !DIEnumerator(name: "recvfrom", value: 45)
!537 = !DIEnumerator(name: "sendmsg", value: 46)
!538 = !DIEnumerator(name: "recvmsg", value: 47)
!539 = !DIEnumerator(name: "shutdown", value: 48)
!540 = !DIEnumerator(name: "bind", value: 49)
!541 = !DIEnumerator(name: "listen", value: 50)
!542 = !DIEnumerator(name: "getsockname", value: 51)
!543 = !DIEnumerator(name: "getpeername", value: 52)
!544 = !DIEnumerator(name: "socketpair", value: 53)
!545 = !DIEnumerator(name: "setsockopt", value: 54)
!546 = !DIEnumerator(name: "getsockopt", value: 55)
!547 = !DIEnumerator(name: "clone", value: 56)
!548 = !DIEnumerator(name: "fork", value: 57)
!549 = !DIEnumerator(name: "vfork", value: 58)
!550 = !DIEnumerator(name: "execve", value: 59)
!551 = !DIEnumerator(name: "exit", value: 60)
!552 = !DIEnumerator(name: "wait4", value: 61)
!553 = !DIEnumerator(name: "kill", value: 62)
!554 = !DIEnumerator(name: "uname", value: 63)
!555 = !DIEnumerator(name: "semget", value: 64)
!556 = !DIEnumerator(name: "semop", value: 65)
!557 = !DIEnumerator(name: "semctl", value: 66)
!558 = !DIEnumerator(name: "shmdt", value: 67)
!559 = !DIEnumerator(name: "msgget", value: 68)
!560 = !DIEnumerator(name: "msgsnd", value: 69)
!561 = !DIEnumerator(name: "msgrcv", value: 70)
!562 = !DIEnumerator(name: "msgctl", value: 71)
!563 = !DIEnumerator(name: "fcntl", value: 72)
!564 = !DIEnumerator(name: "flock", value: 73)
!565 = !DIEnumerator(name: "fsync", value: 74)
!566 = !DIEnumerator(name: "fdatasync", value: 75)
!567 = !DIEnumerator(name: "truncate", value: 76)
!568 = !DIEnumerator(name: "ftruncate", value: 77)
!569 = !DIEnumerator(name: "getdents", value: 78)
!570 = !DIEnumerator(name: "getcwd", value: 79)
!571 = !DIEnumerator(name: "chdir", value: 80)
!572 = !DIEnumerator(name: "fchdir", value: 81)
!573 = !DIEnumerator(name: "rename", value: 82)
!574 = !DIEnumerator(name: "mkdir", value: 83)
!575 = !DIEnumerator(name: "rmdir", value: 84)
!576 = !DIEnumerator(name: "creat", value: 85)
!577 = !DIEnumerator(name: "link", value: 86)
!578 = !DIEnumerator(name: "unlink", value: 87)
!579 = !DIEnumerator(name: "symlink", value: 88)
!580 = !DIEnumerator(name: "readlink", value: 89)
!581 = !DIEnumerator(name: "chmod", value: 90)
!582 = !DIEnumerator(name: "fchmod", value: 91)
!583 = !DIEnumerator(name: "chown", value: 92)
!584 = !DIEnumerator(name: "fchown", value: 93)
!585 = !DIEnumerator(name: "lchown", value: 94)
!586 = !DIEnumerator(name: "umask", value: 95)
!587 = !DIEnumerator(name: "gettimeofday", value: 96)
!588 = !DIEnumerator(name: "getrlimit", value: 97)
!589 = !DIEnumerator(name: "getrusage", value: 98)
!590 = !DIEnumerator(name: "sysinfo", value: 99)
!591 = !DIEnumerator(name: "times", value: 100)
!592 = !DIEnumerator(name: "ptrace", value: 101)
!593 = !DIEnumerator(name: "getuid", value: 102)
!594 = !DIEnumerator(name: "syslog", value: 103)
!595 = !DIEnumerator(name: "getgid", value: 104)
!596 = !DIEnumerator(name: "setuid", value: 105)
!597 = !DIEnumerator(name: "setgid", value: 106)
!598 = !DIEnumerator(name: "geteuid", value: 107)
!599 = !DIEnumerator(name: "getegid", value: 108)
!600 = !DIEnumerator(name: "setpgid", value: 109)
!601 = !DIEnumerator(name: "getppid", value: 110)
!602 = !DIEnumerator(name: "getpgrp", value: 111)
!603 = !DIEnumerator(name: "setsid", value: 112)
!604 = !DIEnumerator(name: "setreuid", value: 113)
!605 = !DIEnumerator(name: "setregid", value: 114)
!606 = !DIEnumerator(name: "getgroups", value: 115)
!607 = !DIEnumerator(name: "setgroups", value: 116)
!608 = !DIEnumerator(name: "setresuid", value: 117)
!609 = !DIEnumerator(name: "getresuid", value: 118)
!610 = !DIEnumerator(name: "setresgid", value: 119)
!611 = !DIEnumerator(name: "getresgid", value: 120)
!612 = !DIEnumerator(name: "getpgid", value: 121)
!613 = !DIEnumerator(name: "setfsuid", value: 122)
!614 = !DIEnumerator(name: "setfsgid", value: 123)
!615 = !DIEnumerator(name: "getsid", value: 124)
!616 = !DIEnumerator(name: "capget", value: 125)
!617 = !DIEnumerator(name: "capset", value: 126)
!618 = !DIEnumerator(name: "rt_sigpending", value: 127)
!619 = !DIEnumerator(name: "rt_sigtimedwait", value: 128)
!620 = !DIEnumerator(name: "rt_sigqueueinfo", value: 129)
!621 = !DIEnumerator(name: "rt_sigsuspend", value: 130)
!622 = !DIEnumerator(name: "sigaltstack", value: 131)
!623 = !DIEnumerator(name: "utime", value: 132)
!624 = !DIEnumerator(name: "mknod", value: 133)
!625 = !DIEnumerator(name: "uselib", value: 134)
!626 = !DIEnumerator(name: "personality", value: 135)
!627 = !DIEnumerator(name: "ustat", value: 136)
!628 = !DIEnumerator(name: "statfs", value: 137)
!629 = !DIEnumerator(name: "fstatfs", value: 138)
!630 = !DIEnumerator(name: "sysfs", value: 139)
!631 = !DIEnumerator(name: "getpriority", value: 140)
!632 = !DIEnumerator(name: "setpriority", value: 141)
!633 = !DIEnumerator(name: "sched_setparam", value: 142)
!634 = !DIEnumerator(name: "sched_getparam", value: 143)
!635 = !DIEnumerator(name: "sched_setscheduler", value: 144)
!636 = !DIEnumerator(name: "sched_getscheduler", value: 145)
!637 = !DIEnumerator(name: "sched_get_priority_max", value: 146)
!638 = !DIEnumerator(name: "sched_get_priority_min", value: 147)
!639 = !DIEnumerator(name: "sched_rr_get_interval", value: 148)
!640 = !DIEnumerator(name: "mlock", value: 149)
!641 = !DIEnumerator(name: "munlock", value: 150)
!642 = !DIEnumerator(name: "mlockall", value: 151)
!643 = !DIEnumerator(name: "munlockall", value: 152)
!644 = !DIEnumerator(name: "vhangup", value: 153)
!645 = !DIEnumerator(name: "modify_ldt", value: 154)
!646 = !DIEnumerator(name: "pivot_root", value: 155)
!647 = !DIEnumerator(name: "_sysctl", value: 156)
!648 = !DIEnumerator(name: "prctl", value: 157)
!649 = !DIEnumerator(name: "arch_prctl", value: 158)
!650 = !DIEnumerator(name: "adjtimex", value: 159)
!651 = !DIEnumerator(name: "setrlimit", value: 160)
!652 = !DIEnumerator(name: "chroot", value: 161)
!653 = !DIEnumerator(name: "sync", value: 162)
!654 = !DIEnumerator(name: "acct", value: 163)
!655 = !DIEnumerator(name: "settimeofday", value: 164)
!656 = !DIEnumerator(name: "mount", value: 165)
!657 = !DIEnumerator(name: "umount2", value: 166)
!658 = !DIEnumerator(name: "swapon", value: 167)
!659 = !DIEnumerator(name: "swapoff", value: 168)
!660 = !DIEnumerator(name: "reboot", value: 169)
!661 = !DIEnumerator(name: "sethostname", value: 170)
!662 = !DIEnumerator(name: "setdomainname", value: 171)
!663 = !DIEnumerator(name: "iopl", value: 172)
!664 = !DIEnumerator(name: "ioperm", value: 173)
!665 = !DIEnumerator(name: "create_module", value: 174)
!666 = !DIEnumerator(name: "init_module", value: 175)
!667 = !DIEnumerator(name: "delete_module", value: 176)
!668 = !DIEnumerator(name: "get_kernel_syms", value: 177)
!669 = !DIEnumerator(name: "query_module", value: 178)
!670 = !DIEnumerator(name: "quotactl", value: 179)
!671 = !DIEnumerator(name: "nfsservctl", value: 180)
!672 = !DIEnumerator(name: "getpmsg", value: 181)
!673 = !DIEnumerator(name: "putpmsg", value: 182)
!674 = !DIEnumerator(name: "afs_syscall", value: 183)
!675 = !DIEnumerator(name: "tuxcall", value: 184)
!676 = !DIEnumerator(name: "security", value: 185)
!677 = !DIEnumerator(name: "gettid", value: 186)
!678 = !DIEnumerator(name: "readahead", value: 187)
!679 = !DIEnumerator(name: "setxattr", value: 188)
!680 = !DIEnumerator(name: "lsetxattr", value: 189)
!681 = !DIEnumerator(name: "fsetxattr", value: 190)
!682 = !DIEnumerator(name: "getxattr", value: 191)
!683 = !DIEnumerator(name: "lgetxattr", value: 192)
!684 = !DIEnumerator(name: "fgetxattr", value: 193)
!685 = !DIEnumerator(name: "listxattr", value: 194)
!686 = !DIEnumerator(name: "llistxattr", value: 195)
!687 = !DIEnumerator(name: "flistxattr", value: 196)
!688 = !DIEnumerator(name: "removexattr", value: 197)
!689 = !DIEnumerator(name: "lremovexattr", value: 198)
!690 = !DIEnumerator(name: "fremovexattr", value: 199)
!691 = !DIEnumerator(name: "tkill", value: 200)
!692 = !DIEnumerator(name: "time", value: 201)
!693 = !DIEnumerator(name: "futex", value: 202)
!694 = !DIEnumerator(name: "sched_setaffinity", value: 203)
!695 = !DIEnumerator(name: "sched_getaffinity", value: 204)
!696 = !DIEnumerator(name: "set_thread_area", value: 205)
!697 = !DIEnumerator(name: "io_setup", value: 206)
!698 = !DIEnumerator(name: "io_destroy", value: 207)
!699 = !DIEnumerator(name: "io_getevents", value: 208)
!700 = !DIEnumerator(name: "io_submit", value: 209)
!701 = !DIEnumerator(name: "io_cancel", value: 210)
!702 = !DIEnumerator(name: "get_thread_area", value: 211)
!703 = !DIEnumerator(name: "lookup_dcookie", value: 212)
!704 = !DIEnumerator(name: "epoll_create", value: 213)
!705 = !DIEnumerator(name: "epoll_ctl_old", value: 214)
!706 = !DIEnumerator(name: "epoll_wait_old", value: 215)
!707 = !DIEnumerator(name: "remap_file_pages", value: 216)
!708 = !DIEnumerator(name: "getdents64", value: 217)
!709 = !DIEnumerator(name: "set_tid_address", value: 218)
!710 = !DIEnumerator(name: "restart_syscall", value: 219)
!711 = !DIEnumerator(name: "semtimedop", value: 220)
!712 = !DIEnumerator(name: "fadvise64", value: 221)
!713 = !DIEnumerator(name: "timer_create", value: 222)
!714 = !DIEnumerator(name: "timer_settime", value: 223)
!715 = !DIEnumerator(name: "timer_gettime", value: 224)
!716 = !DIEnumerator(name: "timer_getoverrun", value: 225)
!717 = !DIEnumerator(name: "timer_delete", value: 226)
!718 = !DIEnumerator(name: "clock_settime", value: 227)
!719 = !DIEnumerator(name: "clock_gettime", value: 228)
!720 = !DIEnumerator(name: "clock_getres", value: 229)
!721 = !DIEnumerator(name: "clock_nanosleep", value: 230)
!722 = !DIEnumerator(name: "exit_group", value: 231)
!723 = !DIEnumerator(name: "epoll_wait", value: 232)
!724 = !DIEnumerator(name: "epoll_ctl", value: 233)
!725 = !DIEnumerator(name: "tgkill", value: 234)
!726 = !DIEnumerator(name: "utimes", value: 235)
!727 = !DIEnumerator(name: "vserver", value: 236)
!728 = !DIEnumerator(name: "mbind", value: 237)
!729 = !DIEnumerator(name: "set_mempolicy", value: 238)
!730 = !DIEnumerator(name: "get_mempolicy", value: 239)
!731 = !DIEnumerator(name: "mq_open", value: 240)
!732 = !DIEnumerator(name: "mq_unlink", value: 241)
!733 = !DIEnumerator(name: "mq_timedsend", value: 242)
!734 = !DIEnumerator(name: "mq_timedreceive", value: 243)
!735 = !DIEnumerator(name: "mq_notify", value: 244)
!736 = !DIEnumerator(name: "mq_getsetattr", value: 245)
!737 = !DIEnumerator(name: "kexec_load", value: 246)
!738 = !DIEnumerator(name: "waitid", value: 247)
!739 = !DIEnumerator(name: "add_key", value: 248)
!740 = !DIEnumerator(name: "request_key", value: 249)
!741 = !DIEnumerator(name: "keyctl", value: 250)
!742 = !DIEnumerator(name: "ioprio_set", value: 251)
!743 = !DIEnumerator(name: "ioprio_get", value: 252)
!744 = !DIEnumerator(name: "inotify_init", value: 253)
!745 = !DIEnumerator(name: "inotify_add_watch", value: 254)
!746 = !DIEnumerator(name: "inotify_rm_watch", value: 255)
!747 = !DIEnumerator(name: "migrate_pages", value: 256)
!748 = !DIEnumerator(name: "openat", value: 257)
!749 = !DIEnumerator(name: "mkdirat", value: 258)
!750 = !DIEnumerator(name: "mknodat", value: 259)
!751 = !DIEnumerator(name: "fchownat", value: 260)
!752 = !DIEnumerator(name: "futimesat", value: 261)
!753 = !DIEnumerator(name: "fstatat", value: 262)
!754 = !DIEnumerator(name: "unlinkat", value: 263)
!755 = !DIEnumerator(name: "renameat", value: 264)
!756 = !DIEnumerator(name: "linkat", value: 265)
!757 = !DIEnumerator(name: "symlinkat", value: 266)
!758 = !DIEnumerator(name: "readlinkat", value: 267)
!759 = !DIEnumerator(name: "fchmodat", value: 268)
!760 = !DIEnumerator(name: "faccessat", value: 269)
!761 = !DIEnumerator(name: "pselect6", value: 270)
!762 = !DIEnumerator(name: "ppoll", value: 271)
!763 = !DIEnumerator(name: "unshare", value: 272)
!764 = !DIEnumerator(name: "set_robust_list", value: 273)
!765 = !DIEnumerator(name: "get_robust_list", value: 274)
!766 = !DIEnumerator(name: "splice", value: 275)
!767 = !DIEnumerator(name: "tee", value: 276)
!768 = !DIEnumerator(name: "sync_file_range", value: 277)
!769 = !DIEnumerator(name: "vmsplice", value: 278)
!770 = !DIEnumerator(name: "move_pages", value: 279)
!771 = !DIEnumerator(name: "utimensat", value: 280)
!772 = !DIEnumerator(name: "epoll_pwait", value: 281)
!773 = !DIEnumerator(name: "signalfd", value: 282)
!774 = !DIEnumerator(name: "timerfd_create", value: 283)
!775 = !DIEnumerator(name: "eventfd", value: 284)
!776 = !DIEnumerator(name: "fallocate", value: 285)
!777 = !DIEnumerator(name: "timerfd_settime", value: 286)
!778 = !DIEnumerator(name: "timerfd_gettime", value: 287)
!779 = !DIEnumerator(name: "accept4", value: 288)
!780 = !DIEnumerator(name: "signalfd4", value: 289)
!781 = !DIEnumerator(name: "eventfd2", value: 290)
!782 = !DIEnumerator(name: "epoll_create1", value: 291)
!783 = !DIEnumerator(name: "dup3", value: 292)
!784 = !DIEnumerator(name: "pipe2", value: 293)
!785 = !DIEnumerator(name: "inotify_init1", value: 294)
!786 = !DIEnumerator(name: "preadv", value: 295)
!787 = !DIEnumerator(name: "pwritev", value: 296)
!788 = !DIEnumerator(name: "rt_tgsigqueueinfo", value: 297)
!789 = !DIEnumerator(name: "perf_event_open", value: 298)
!790 = !DIEnumerator(name: "recvmmsg", value: 299)
!791 = !DIEnumerator(name: "fanotify_init", value: 300)
!792 = !DIEnumerator(name: "fanotify_mark", value: 301)
!793 = !DIEnumerator(name: "prlimit64", value: 302)
!794 = !DIEnumerator(name: "name_to_handle_at", value: 303)
!795 = !DIEnumerator(name: "open_by_handle_at", value: 304)
!796 = !DIEnumerator(name: "clock_adjtime", value: 305)
!797 = !DIEnumerator(name: "syncfs", value: 306)
!798 = !DIEnumerator(name: "sendmmsg", value: 307)
!799 = !DIEnumerator(name: "setns", value: 308)
!800 = !DIEnumerator(name: "getcpu", value: 309)
!801 = !DIEnumerator(name: "process_vm_readv", value: 310)
!802 = !DIEnumerator(name: "process_vm_writev", value: 311)
!803 = !DIEnumerator(name: "kcmp", value: 312)
!804 = !DIEnumerator(name: "finit_module", value: 313)
!805 = !DIEnumerator(name: "sched_setattr", value: 314)
!806 = !DIEnumerator(name: "sched_getattr", value: 315)
!807 = !DIEnumerator(name: "renameat2", value: 316)
!808 = !DIEnumerator(name: "seccomp", value: 317)
!809 = !DIEnumerator(name: "getrandom", value: 318)
!810 = !DIEnumerator(name: "memfd_create", value: 319)
!811 = !DIEnumerator(name: "kexec_file_load", value: 320)
!812 = !DIEnumerator(name: "bpf", value: 321)
!813 = !DIEnumerator(name: "execveat", value: 322)
!814 = !DIEnumerator(name: "userfaultfd", value: 323)
!815 = !DIEnumerator(name: "membarrier", value: 324)
!816 = !DIEnumerator(name: "mlock2", value: 325)
!817 = !DIEnumerator(name: "copy_file_range", value: 326)
!818 = !DIEnumerator(name: "preadv2", value: 327)
!819 = !DIEnumerator(name: "pwritev2", value: 328)
!820 = !DIEnumerator(name: "pkey_mprotect", value: 329)
!821 = !DIEnumerator(name: "pkey_alloc", value: 330)
!822 = !DIEnumerator(name: "pkey_free", value: 331)
!823 = !DIEnumerator(name: "statx", value: 332)
!824 = !DIEnumerator(name: "io_pgetevents", value: 333)
!825 = !DIEnumerator(name: "rseq", value: 334)
!826 = !DIEnumerator(name: "pidfd_send_signal", value: 424)
!827 = !DIEnumerator(name: "io_uring_setup", value: 425)
!828 = !DIEnumerator(name: "io_uring_enter", value: 426)
!829 = !DIEnumerator(name: "io_uring_register", value: 427)
!830 = !DIEnumerator(name: "open_tree", value: 428)
!831 = !DIEnumerator(name: "move_mount", value: 429)
!832 = !DIEnumerator(name: "fsopen", value: 430)
!833 = !DIEnumerator(name: "fsconfig", value: 431)
!834 = !DIEnumerator(name: "fsmount", value: 432)
!835 = !DIEnumerator(name: "fspick", value: 433)
!836 = !DIEnumerator(name: "pidfd_open", value: 434)
!837 = !DIEnumerator(name: "clone3", value: 435)
!838 = !DIEnumerator(name: "close_range", value: 436)
!839 = !DIEnumerator(name: "openat2", value: 437)
!840 = !DIEnumerator(name: "pidfd_getfd", value: 438)
!841 = !DIEnumerator(name: "faccessat2", value: 439)
!842 = !DIEnumerator(name: "process_madvise", value: 440)
!843 = !DIEnumerator(name: "epoll_pwait2", value: 441)
!844 = !DIEnumerator(name: "mount_setattr", value: 442)
!845 = !DIEnumerator(name: "landlock_create_ruleset", value: 444)
!846 = !DIEnumerator(name: "landlock_add_rule", value: 445)
!847 = !DIEnumerator(name: "landlock_restrict_self", value: 446)
!848 = !DIEnumerator(name: "memfd_secret", value: 447)
!849 = !DICompositeType(tag: DW_TAG_enumeration_type, name: "std.event.loop.Id", scope: !850, file: !850, line: 64, baseType: !7, size: 8, align: 8, elements: !851)
!850 = !DIFile(filename: "loop.zig", directory: "/home/mike/personal/zig/build/lib/zig/std/event")
!851 = !{!852, !853, !854}
!852 = !DIEnumerator(name: "Basic", value: 0)
!853 = !DIEnumerator(name: "Stop", value: 1)
!854 = !DIEnumerator(name: "EventFd", value: 2)
!855 = !DICompositeType(tag: DW_TAG_enumeration_type, name: "std.Thread.enum:337:27", scope: !856, file: !856, line: 337, baseType: !81, size: 8, align: 8, elements: !857)
!856 = !DIFile(filename: "Thread.zig", directory: "/home/mike/personal/zig/build/lib/zig/std")
!857 = !{!858, !859, !860}
!858 = !DIEnumerator(name: "running", value: 0)
!859 = !DIEnumerator(name: "detached", value: 1)
!860 = !DIEnumerator(name: "completed", value: 2)
!861 = !DICompositeType(tag: DW_TAG_enumeration_type, name: "anyerror", baseType: !330, size: 16, align: 16, elements: !862)
!862 = !{!863, !864, !865, !866, !867, !868, !869, !870, !871, !872, !873, !874, !875, !876, !877, !878, !879, !880, !881, !882, !883, !884, !885, !886, !887, !888, !889, !890, !891, !892, !893, !894, !895, !896, !897, !898, !899, !900, !901, !902, !903, !904, !905}
!863 = !DIEnumerator(name: "(none)", value: 0)
!864 = !DIEnumerator(name: "DiskQuota", value: 1)
!865 = !DIEnumerator(name: "FileTooBig", value: 2)
!866 = !DIEnumerator(name: "InputOutput", value: 3)
!867 = !DIEnumerator(name: "NoSpaceLeft", value: 4)
!868 = !DIEnumerator(name: "AccessDenied", value: 5)
!869 = !DIEnumerator(name: "BrokenPipe", value: 6)
!870 = !DIEnumerator(name: "SystemResources", value: 7)
!871 = !DIEnumerator(name: "OperationAborted", value: 8)
!872 = !DIEnumerator(name: "NotOpenForWriting", value: 9)
!873 = !DIEnumerator(name: "WouldBlock", value: 10)
!874 = !DIEnumerator(name: "ConnectionResetByPeer", value: 11)
!875 = !DIEnumerator(name: "Unexpected", value: 12)
!876 = !DIEnumerator(name: "MemoryMappingNotSupported", value: 13)
!877 = !DIEnumerator(name: "PermissionDenied", value: 14)
!878 = !DIEnumerator(name: "LockedMemoryLimitExceeded", value: 15)
!879 = !DIEnumerator(name: "OutOfMemory", value: 16)
!880 = !DIEnumerator(name: "LimitTooBig", value: 17)
!881 = !DIEnumerator(name: "Utf8InvalidStartByte", value: 18)
!882 = !DIEnumerator(name: "TruncatedInput", value: 19)
!883 = !DIEnumerator(name: "Utf8ExpectedContinuation", value: 20)
!884 = !DIEnumerator(name: "Utf8OverlongEncoding", value: 21)
!885 = !DIEnumerator(name: "Utf8EncodesSurrogateHalf", value: 22)
!886 = !DIEnumerator(name: "Utf8CodepointTooLarge", value: 23)
!887 = !DIEnumerator(name: "IsDir", value: 24)
!888 = !DIEnumerator(name: "ConnectionTimedOut", value: 25)
!889 = !DIEnumerator(name: "NotOpenForReading", value: 26)
!890 = !DIEnumerator(name: "Unseekable", value: 27)
!891 = !DIEnumerator(name: "SymLinkLoop", value: 28)
!892 = !DIEnumerator(name: "ProcessFdQuotaExceeded", value: 29)
!893 = !DIEnumerator(name: "SystemFdQuotaExceeded", value: 30)
!894 = !DIEnumerator(name: "NoDevice", value: 31)
!895 = !DIEnumerator(name: "FileNotFound", value: 32)
!896 = !DIEnumerator(name: "NameTooLong", value: 33)
!897 = !DIEnumerator(name: "NotDir", value: 34)
!898 = !DIEnumerator(name: "PathAlreadyExists", value: 35)
!899 = !DIEnumerator(name: "DeviceBusy", value: 36)
!900 = !DIEnumerator(name: "FileLocksNotSupported", value: 37)
!901 = !DIEnumerator(name: "BadPathName", value: 38)
!902 = !DIEnumerator(name: "InvalidUtf8", value: 39)
!903 = !DIEnumerator(name: "FileBusy", value: 40)
!904 = !DIEnumerator(name: "ReadOnlyFileSystem", value: 41)
!905 = !DIEnumerator(name: "TimedOut", value: 42)
!906 = !DICompositeType(tag: DW_TAG_enumeration_type, name: "@typeInfo(std.event.loop.Msg).Union.tag_type.?", scope: !850, file: !850, line: 1577, baseType: !907, size: 8, align: 8, elements: !908)
!907 = !DIBasicType(name: "u4", size: 8, encoding: DW_ATE_unsigned)
!908 = !{!491, !909, !910, !911, !912, !913, !914, !915, !916, !917, !918, !919, !920}
!909 = !DIEnumerator(name: "readv", value: 1)
!910 = !DIEnumerator(name: "write", value: 2)
!911 = !DIEnumerator(name: "writev", value: 3)
!912 = !DIEnumerator(name: "pwrite", value: 4)
!913 = !DIEnumerator(name: "pwritev", value: 5)
!914 = !DIEnumerator(name: "pread", value: 6)
!915 = !DIEnumerator(name: "preadv", value: 7)
!916 = !DIEnumerator(name: "open", value: 8)
!917 = !DIEnumerator(name: "openat", value: 9)
!918 = !DIEnumerator(name: "close", value: 10)
!919 = !DIEnumerator(name: "faccessat", value: 11)
!920 = !DIEnumerator(name: "end", value: 12)
!921 = !DICompositeType(tag: DW_TAG_enumeration_type, name: "@typeInfo(std.event.loop.Finish).Union.tag_type.?", scope: !850, file: !850, line: 1572, baseType: !324, size: 8, align: 8, elements: !922)
!922 = !{!923, !924}
!923 = !DIEnumerator(name: "TickNode", value: 0)
!924 = !DIEnumerator(name: "NoAction", value: 1)
!925 = !DICompositeType(tag: DW_TAG_enumeration_type, name: "std.os.linux.rlimit_resource", scope: !926, file: !926, line: 4209, baseType: !927, size: 32, align: 32, elements: !928)
!926 = !DIFile(filename: "linux.zig", directory: "/home/mike/personal/zig/build/lib/zig/std/os")
!927 = !DIBasicType(name: "c_int", size: 32, encoding: DW_ATE_signed)
!928 = !{!929, !930, !931, !932, !933, !934, !935, !936, !937, !938, !939, !940, !941, !942, !943, !944}
!929 = !DIEnumerator(name: "CPU", value: 0)
!930 = !DIEnumerator(name: "FSIZE", value: 1)
!931 = !DIEnumerator(name: "DATA", value: 2)
!932 = !DIEnumerator(name: "STACK", value: 3)
!933 = !DIEnumerator(name: "CORE", value: 4)
!934 = !DIEnumerator(name: "RSS", value: 5)
!935 = !DIEnumerator(name: "NPROC", value: 6)
!936 = !DIEnumerator(name: "NOFILE", value: 7)
!937 = !DIEnumerator(name: "MEMLOCK", value: 8)
!938 = !DIEnumerator(name: "AS", value: 9)
!939 = !DIEnumerator(name: "LOCKS", value: 10)
!940 = !DIEnumerator(name: "SIGPENDING", value: 11)
!941 = !DIEnumerator(name: "MSGQUEUE", value: 12)
!942 = !DIEnumerator(name: "NICE", value: 13)
!943 = !DIEnumerator(name: "RTPRIO", value: 14)
!944 = !DIEnumerator(name: "RTTIME", value: 15)
!945 = !DICompositeType(tag: DW_TAG_enumeration_type, name: "std.fmt.Alignment", scope: !946, file: !946, line: 14, baseType: !7, size: 8, align: 8, elements: !947)
!946 = !DIFile(filename: "fmt.zig", directory: "/home/mike/personal/zig/build/lib/zig/std")
!947 = !{!948, !949, !950}
!948 = !DIEnumerator(name: "Left", value: 0)
!949 = !DIEnumerator(name: "Center", value: 1)
!950 = !DIEnumerator(name: "Right", value: 2)
!951 = !DICompositeType(tag: DW_TAG_enumeration_type, name: "std.Thread.ResetEvent.TimedWaitResult", scope: !952, file: !952, line: 65, baseType: !324, size: 8, align: 8, elements: !953)
!952 = !DIFile(filename: "ResetEvent.zig", directory: "/home/mike/personal/zig/build/lib/zig/std/Thread")
!953 = !{!954, !955}
!954 = !DIEnumerator(name: "event_set", value: 0)
!955 = !DIEnumerator(name: "timed_out", value: 1)
!956 = !DICompositeType(tag: DW_TAG_enumeration_type, name: "std.fmt.Case", scope: !946, file: !946, line: 735, baseType: !324, size: 8, align: 8, elements: !957)
!957 = !{!958, !959}
!958 = !DIEnumerator(name: "lower", value: 0)
!959 = !DIEnumerator(name: "upper", value: 1)

;;; broken LLVM module found: Instruction does not dominate all uses!
;;;   %19 = getelementptr inbounds %"?u32", %"?u32"* %0, i32 0, i32 0
;;;   store i32 5, i32* %19, align 4
;;; Instruction does not dominate all uses!
;;;   %19 = getelementptr inbounds %"?u32", %"?u32"* %0, i32 0, i32 0
;;;   store i32 5, i32* %19, align 4
;;; Instruction does not dominate all uses!
;;;   %19 = getelementptr inbounds %"?u32", %"?u32"* %0, i32 0, i32 0
;;;   store i32 %20, i32* %19, align 4

;;; This is a bug in the Zig compiler.thread 2653385 panic: 
;;; ???:?:?: 0x55c02598cad7 in ??? (???)
;;; ???:?:?: 0x55c026924719 in ??? (???)
;;; ???:?:?: 0x55c02694b9e9 in ??? (???)
;;; ???:?:?: 0x55c026950b6f in ??? (???)
;;; ???:?:?: 0x55c026920273 in ??? (???)
;;; ???:?:?: 0x55c025d8fde4 in ??? (???)
;;; ???:?:?: 0x55c025d5068a in ??? (???)
;;; ???:?:?: 0x55c025b24205 in ??? (???)
;;; ???:?:?: 0x55c025b17432 in ??? (???)
;;; ???:?:?: 0x55c025b12fd1 in ??? (???)
;;; ???:?:?: 0x55c025aa15ff in ??? (???)
;;; ???:?:?: 0x55c0259bb486 in ??? (???)
;;; ???:?:?: 0x55c02598b097 in ??? (???)
;;; ???:?:?: 0x55c02598aaa9 in ??? (???)
