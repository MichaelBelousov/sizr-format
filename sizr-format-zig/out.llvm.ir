; ModuleID = 'test'
source_filename = "test"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%"[]u8" = type { i8*, i64 }
%std.builtin.StackTrace = type { i64, %"[]usize" }
%"[]usize" = type { i64*, i64 }
%std.target.LinuxVersionRange = type { %std.builtin.Range, %std.builtin.Version }
%std.builtin.Range = type { %std.builtin.Version, %std.builtin.Version }
%std.builtin.Version = type { i32, i32, i32 }
%std.target.Set = type { [5 x i64] }
%"[]std.target.x86.Feature" = type { i8*, i64 }
%std.target.Model = type { %"[]u8", %"?[:0]const u8", %std.target.Set }
%"?[:0]const u8" = type { %"[]u8", i1 }
%std.Thread.Mutex = type { %std.Thread.Mutex.AtomicMutex }
%std.Thread.Mutex.AtomicMutex = type { i32 }
%std.elf.Elf64_auxv_t = type { i64, %"std.elf.union:790:11" }
%"std.elf.union:790:11" = type { i64 }
%std.os.linux.tls.TLSImage = type { %"[]u8", i64, i64, i64, i64, i64, i64, i64 }
%"[][*:0]u8" = type { i8**, i64 }
%"?u64" = type { i64, i1 }
%std.event.loop.Loop = type { %"std.atomic.queue.Queue(anyframe)", %std.event.loop.LinuxOsData, %std.event.loop.ResumeNode, i64, %"[]std.Thread", %std.Thread, %"std.atomic.queue.Queue(std.event.loop.Request)", %std.linked_list.Node.0, %std.Thread.ResetEvent, %std.heap.arena_allocator.ArenaAllocator, %std.event.loop.DelayQueue, %"std.atomic.stack.Stack(std.event.loop.EventFd)", %"[]std.atomic.stack.Node" }
%"std.atomic.queue.Queue(anyframe)" = type { %std.linked_list.Node*, %std.linked_list.Node*, %std.Thread.Mutex }
%std.linked_list.Node = type { %std.linked_list.Node*, %std.linked_list.Node*, %"(anyframe header)"* }
%"(anyframe header)" = type { void (%"(anyframe header)"*, i64)*, i64, i64 }
%std.event.loop.LinuxOsData = type { i32, i32, %std.os.linux.epoll_event }
%std.os.linux.epoll_event = type <{ i32, %std.os.linux.epoll_data }>
%std.os.linux.epoll_data = type { i64 }
%std.event.loop.ResumeNode = type { i2, %"(anyframe header)"* }
%"[]std.Thread" = type { %std.Thread*, i64 }
%std.Thread = type { %std.Thread.LinuxThreadImpl }
%std.Thread.LinuxThreadImpl = type { %std.Thread.ThreadCompletion* }
%std.Thread.ThreadCompletion = type { %"std.atomic.Atomic.Atomic(std.Thread.enum:337:27)", %"std.atomic.Atomic.Atomic(i32)", i32, %"[]u8" }
%"std.atomic.Atomic.Atomic(std.Thread.enum:337:27)" = type { i8 }
%"std.atomic.Atomic.Atomic(i32)" = type { i32 }
%"std.atomic.queue.Queue(std.event.loop.Request)" = type { %std.linked_list.Node.0*, %std.linked_list.Node.0*, %std.Thread.Mutex }
%std.linked_list.Node.0 = type { %std.linked_list.Node.0*, %std.linked_list.Node.0*, %std.event.loop.Request }
%std.event.loop.Request = type { %std.event.loop.Msg, %std.event.loop.Finish }
%std.event.loop.Msg = type { { %std.event.loop.Read, [8 x i8] }, i4 }
%std.event.loop.Read = type { i32, %"[]u8", { i64, i16 } }
%std.event.loop.Finish = type { %std.linked_list.Node, i1 }
%std.Thread.ResetEvent = type { %std.Thread.StaticResetEvent.AtomicEvent }
%std.Thread.StaticResetEvent.AtomicEvent = type { i32 }
%std.heap.arena_allocator.ArenaAllocator = type { %std.mem.Allocator, %std.heap.arena_allocator.State }
%std.mem.Allocator = type { i8*, %std.mem.Allocator.VTable* }
%std.mem.Allocator.VTable = type { void ({ %"[]u8", i16 }*, i8*, i64, i29, i29, i64)*, void (%"?usize"*, i8*, %"[]u8"*, i29, i64, i29, i64)*, void (i8*, %"[]u8"*, i29, i64)* }
%"?usize" = type { i64, i1 }
%std.heap.arena_allocator.State = type { %"std.linked_list.SinglyLinkedList([]u8)", i64 }
%"std.linked_list.SinglyLinkedList([]u8)" = type { %std.linked_list.Node.1* }
%std.linked_list.Node.1 = type { %std.linked_list.Node.1*, %"[]u8" }
%std.event.loop.DelayQueue = type { %std.time.Timer, %std.event.loop.Waiters, %std.Thread, %std.Thread.AutoResetEvent, i1 }
%std.time.Timer = type { i64, i64 }
%std.event.loop.Waiters = type { %"std.atomic.queue.Queue(anyframe)" }
%std.Thread.AutoResetEvent = type { i64 }
%"std.atomic.stack.Stack(std.event.loop.EventFd)" = type { %std.atomic.stack.Node*, i1 }
%std.atomic.stack.Node = type { %std.atomic.stack.Node*, %std.event.loop.EventFd }
%std.event.loop.EventFd = type { %std.event.loop.ResumeNode, i32, i32 }
%"[]std.atomic.stack.Node" = type { %std.atomic.stack.Node*, i64 }
%std.builtin.TestFn = type { %"[]u8", i16 ()*, %"?usize" }
%"[]std.builtin.TestFn" = type { %std.builtin.TestFn*, i64 }
%std.heap.general_purpose_allocator.BucketHeader = type { %std.heap.general_purpose_allocator.BucketHeader*, %std.heap.general_purpose_allocator.BucketHeader*, i8*, i13, i13 }
%"std.hash_map.HashMapUnmanaged(usize,std.heap.general_purpose_allocator.LargeAlloc,std.hash_map.AutoContext(usize),80)" = type { %std.hash_map.Metadata*, i32, i32 }
%std.hash_map.Metadata = type <{ i8 }>
%std.heap.FixedBufferAllocator = type { i64, %"[]u8" }
%Expr = type { i32, i1 }
%std.Thread.StaticResetEvent = type { %std.Thread.StaticResetEvent.AtomicEvent }
%std.os.linux.rlimit = type { i64, i64 }
%"?std.fs.file.File" = type { %std.fs.file.File, i1 }
%std.fs.file.File = type { i32 }
%std.Progress.Node = type { %std.Progress*, %std.Progress.Node*, %"[]u8", %std.Progress.Node*, i64, i64 }
%std.Progress = type { %"?std.fs.file.File", i1, i1, i1, %std.Progress.Node, %std.time.Timer, i64, [100 x i8], i64, i64, i1, %std.Thread.Mutex, i64 }
%"?[:0]u8" = type { %"[]u8", i1 }
%"[][]u8" = type { %"[]u8"*, i64 }
%"?[]const u8" = type { %"[]u8", i1 }
%"?Value" = type { %Value, i1 }
%Value = type { i32, i1 }
%std.os.linux.timespec = type { i64, i64 }
%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)" = type { %std.fs.file.File }
%"std.debug.struct:295:56" = type { i64 }
%"std.debug.struct:297:40" = type { %"[]u8" }
%std.elf.Elf64_Phdr = type { i32, i32, i64, i64, i64, i64, i64, i64 }
%"[]std.elf.Elf64_Phdr" = type { %std.elf.Elf64_Phdr*, i64 }
%std.fmt.FormatOptions = type { %"?usize", %"?usize", i2, i8 }
%std.os.linux.tls.DTV = type { i64, [1 x i8*] }
%"?std.Thread.Mutex.State" = type { i32, i1 }
%"?u32" = type { i32, i1 }
%std.target.Target = type { %std.target.Cpu, %std.target.Os, i5 }
%std.target.Cpu = type { i6, %std.target.Model*, %std.target.Set }
%std.target.Os = type { i6, %std.target.VersionRange }
%std.target.VersionRange = type { %std.builtin.Range, [12 x i8] }
%"std.special.struct:62:49" = type { i64, i64, %"[]u8" }
%"std.special.struct:76:61" = type { %"[]u8" }
%"std.special.struct:95:54" = type { %"[]u8", %"[]u8" }
%"std.special.struct:96:65" = type { %"[]u8" }
%"std.special.struct:89:48" = type { %"[]u8" }
%"std.special.struct:105:53" = type { i64 }
%"std.special.struct:107:68" = type { i64, i64, i64 }
%"std.special.struct:110:55" = type { i64 }
%"std.special.struct:113:56" = type { i64 }
%"std.heap.general_purpose_allocator.GeneralPurposeAllocator((struct std.heap.general_purpose_allocator.Config constant))" = type { %std.mem.Allocator, [12 x %std.heap.general_purpose_allocator.BucketHeader*], %"std.hash_map.HashMapUnmanaged(usize,std.heap.general_purpose_allocator.LargeAlloc,std.hash_map.AutoContext(usize),80)", %std.Thread.Mutex }
%"std.special.struct:19:57" = type { %"[]u8" }
%std.process.ArgIterator = type { %std.process.ArgIteratorPosix }
%std.process.ArgIteratorPosix = type { i64, i64 }
%"std.array_list.ArrayListAligned(u8,null)" = type { %"[]u8", i64, %std.mem.Allocator }
%"std.array_list.ArrayListAligned(usize,null)" = type { %"[]usize", i64, %std.mem.Allocator }
%"std.Progress.struct:202:79" = type { i64 }
%"std.Progress.struct:264:49" = type { %"[]u8" }
%"std.Progress.struct:269:56" = type { i64, i64 }
%"std.Progress.struct:273:52" = type { i64 }
%std.os.linux.winsize = type { i16, i16, i16, i16 }
%std.hash.wyhash.WyhashStateless = type { i64, i64 }
%"std.io.fixed_buffer_stream.FixedBufferStream([]u8)" = type { %"[]u8", i64 }
%"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)" = type { %"std.io.fixed_buffer_stream.FixedBufferStream([]u8)"* }
%std.hash_map.Header = type <{ %std.heap.general_purpose_allocator.LargeAlloc*, i64*, i32 }>
%std.heap.general_purpose_allocator.LargeAlloc = type { %"[]u8" }
%std.elf.Elf64_Ehdr = type { [16 x i8], i16, i16, i32, i64, i64, i64, i32, i16, i16, i16, i16, i16, i16 }
%std.elf.Elf64_Sym = type { i32, i8, i8, i16, i64, i64 }
%std.elf.Elf64_Verdef = type { i16, i16, i16, i16, i32, i32, i32 }
%std.elf.Elf64_Verdaux = type { i32, i32 }

@0 = private unnamed_addr constant [9 x i8] c"DiskQuota", align 1
@1 = private unnamed_addr constant [10 x i8] c"FileTooBig", align 1
@2 = private unnamed_addr constant [11 x i8] c"InputOutput", align 1
@3 = private unnamed_addr constant [11 x i8] c"NoSpaceLeft", align 1
@4 = private unnamed_addr constant [12 x i8] c"AccessDenied", align 1
@5 = private unnamed_addr constant [10 x i8] c"BrokenPipe", align 1
@6 = private unnamed_addr constant [15 x i8] c"SystemResources", align 1
@7 = private unnamed_addr constant [16 x i8] c"OperationAborted", align 1
@8 = private unnamed_addr constant [17 x i8] c"NotOpenForWriting", align 1
@9 = private unnamed_addr constant [10 x i8] c"WouldBlock", align 1
@10 = private unnamed_addr constant [21 x i8] c"ConnectionResetByPeer", align 1
@11 = private unnamed_addr constant [10 x i8] c"Unexpected", align 1
@12 = private unnamed_addr constant [25 x i8] c"MemoryMappingNotSupported", align 1
@13 = private unnamed_addr constant [16 x i8] c"PermissionDenied", align 1
@14 = private unnamed_addr constant [25 x i8] c"LockedMemoryLimitExceeded", align 1
@15 = private unnamed_addr constant [11 x i8] c"OutOfMemory", align 1
@16 = private unnamed_addr constant [11 x i8] c"LimitTooBig", align 1
@17 = private unnamed_addr constant [20 x i8] c"Utf8InvalidStartByte", align 1
@18 = private unnamed_addr constant [14 x i8] c"TruncatedInput", align 1
@19 = private unnamed_addr constant [24 x i8] c"Utf8ExpectedContinuation", align 1
@20 = private unnamed_addr constant [20 x i8] c"Utf8OverlongEncoding", align 1
@21 = private unnamed_addr constant [24 x i8] c"Utf8EncodesSurrogateHalf", align 1
@22 = private unnamed_addr constant [21 x i8] c"Utf8CodepointTooLarge", align 1
@23 = private unnamed_addr constant [5 x i8] c"IsDir", align 1
@24 = private unnamed_addr constant [18 x i8] c"ConnectionTimedOut", align 1
@25 = private unnamed_addr constant [17 x i8] c"NotOpenForReading", align 1
@26 = private unnamed_addr constant [10 x i8] c"Unseekable", align 1
@27 = private unnamed_addr constant [11 x i8] c"SymLinkLoop", align 1
@28 = private unnamed_addr constant [22 x i8] c"ProcessFdQuotaExceeded", align 1
@29 = private unnamed_addr constant [21 x i8] c"SystemFdQuotaExceeded", align 1
@30 = private unnamed_addr constant [8 x i8] c"NoDevice", align 1
@31 = private unnamed_addr constant [12 x i8] c"FileNotFound", align 1
@32 = private unnamed_addr constant [11 x i8] c"NameTooLong", align 1
@33 = private unnamed_addr constant [6 x i8] c"NotDir", align 1
@34 = private unnamed_addr constant [17 x i8] c"PathAlreadyExists", align 1
@35 = private unnamed_addr constant [10 x i8] c"DeviceBusy", align 1
@36 = private unnamed_addr constant [21 x i8] c"FileLocksNotSupported", align 1
@37 = private unnamed_addr constant [11 x i8] c"BadPathName", align 1
@38 = private unnamed_addr constant [11 x i8] c"InvalidUtf8", align 1
@39 = private unnamed_addr constant [8 x i8] c"FileBusy", align 1
@40 = private unnamed_addr constant [18 x i8] c"ReadOnlyFileSystem", align 1
@41 = private unnamed_addr constant [8 x i8] c"TimedOut", align 1
@42 = private unnamed_addr constant [16 x i8] c"TimerUnsupported", align 1
@43 = private unnamed_addr constant [11 x i8] c"SkipZigTest", align 1
@44 = private unnamed_addr constant [14 x i8] c"InvalidCmdLine", align 1
@45 = private unnamed_addr constant [8 x i8] c"Overflow", align 1
@46 = private unnamed_addr constant [16 x i8] c"UnsupportedClock", align 1
@__zig_err_name_table = private unnamed_addr constant [48 x %"[]u8"] [%"[]u8" undef, %"[]u8" { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @0, i32 0, i32 0), i64 9 }, %"[]u8" { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @1, i32 0, i32 0), i64 10 }, %"[]u8" { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @2, i32 0, i32 0), i64 11 }, %"[]u8" { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @3, i32 0, i32 0), i64 11 }, %"[]u8" { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @4, i32 0, i32 0), i64 12 }, %"[]u8" { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @5, i32 0, i32 0), i64 10 }, %"[]u8" { i8* getelementptr inbounds ([15 x i8], [15 x i8]* @6, i32 0, i32 0), i64 15 }, %"[]u8" { i8* getelementptr inbounds ([16 x i8], [16 x i8]* @7, i32 0, i32 0), i64 16 }, %"[]u8" { i8* getelementptr inbounds ([17 x i8], [17 x i8]* @8, i32 0, i32 0), i64 17 }, %"[]u8" { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @9, i32 0, i32 0), i64 10 }, %"[]u8" { i8* getelementptr inbounds ([21 x i8], [21 x i8]* @10, i32 0, i32 0), i64 21 }, %"[]u8" { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @11, i32 0, i32 0), i64 10 }, %"[]u8" { i8* getelementptr inbounds ([25 x i8], [25 x i8]* @12, i32 0, i32 0), i64 25 }, %"[]u8" { i8* getelementptr inbounds ([16 x i8], [16 x i8]* @13, i32 0, i32 0), i64 16 }, %"[]u8" { i8* getelementptr inbounds ([25 x i8], [25 x i8]* @14, i32 0, i32 0), i64 25 }, %"[]u8" { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @15, i32 0, i32 0), i64 11 }, %"[]u8" { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @16, i32 0, i32 0), i64 11 }, %"[]u8" { i8* getelementptr inbounds ([20 x i8], [20 x i8]* @17, i32 0, i32 0), i64 20 }, %"[]u8" { i8* getelementptr inbounds ([14 x i8], [14 x i8]* @18, i32 0, i32 0), i64 14 }, %"[]u8" { i8* getelementptr inbounds ([24 x i8], [24 x i8]* @19, i32 0, i32 0), i64 24 }, %"[]u8" { i8* getelementptr inbounds ([20 x i8], [20 x i8]* @20, i32 0, i32 0), i64 20 }, %"[]u8" { i8* getelementptr inbounds ([24 x i8], [24 x i8]* @21, i32 0, i32 0), i64 24 }, %"[]u8" { i8* getelementptr inbounds ([21 x i8], [21 x i8]* @22, i32 0, i32 0), i64 21 }, %"[]u8" { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @23, i32 0, i32 0), i64 5 }, %"[]u8" { i8* getelementptr inbounds ([18 x i8], [18 x i8]* @24, i32 0, i32 0), i64 18 }, %"[]u8" { i8* getelementptr inbounds ([17 x i8], [17 x i8]* @25, i32 0, i32 0), i64 17 }, %"[]u8" { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @26, i32 0, i32 0), i64 10 }, %"[]u8" { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @27, i32 0, i32 0), i64 11 }, %"[]u8" { i8* getelementptr inbounds ([22 x i8], [22 x i8]* @28, i32 0, i32 0), i64 22 }, %"[]u8" { i8* getelementptr inbounds ([21 x i8], [21 x i8]* @29, i32 0, i32 0), i64 21 }, %"[]u8" { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @30, i32 0, i32 0), i64 8 }, %"[]u8" { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @31, i32 0, i32 0), i64 12 }, %"[]u8" { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @32, i32 0, i32 0), i64 11 }, %"[]u8" { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @33, i32 0, i32 0), i64 6 }, %"[]u8" { i8* getelementptr inbounds ([17 x i8], [17 x i8]* @34, i32 0, i32 0), i64 17 }, %"[]u8" { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @35, i32 0, i32 0), i64 10 }, %"[]u8" { i8* getelementptr inbounds ([21 x i8], [21 x i8]* @36, i32 0, i32 0), i64 21 }, %"[]u8" { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @37, i32 0, i32 0), i64 11 }, %"[]u8" { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @38, i32 0, i32 0), i64 11 }, %"[]u8" { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @39, i32 0, i32 0), i64 8 }, %"[]u8" { i8* getelementptr inbounds ([18 x i8], [18 x i8]* @40, i32 0, i32 0), i64 18 }, %"[]u8" { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @41, i32 0, i32 0), i64 8 }, %"[]u8" { i8* getelementptr inbounds ([16 x i8], [16 x i8]* @42, i32 0, i32 0), i64 16 }, %"[]u8" { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @43, i32 0, i32 0), i64 11 }, %"[]u8" { i8* getelementptr inbounds ([14 x i8], [14 x i8]* @44, i32 0, i32 0), i64 14 }, %"[]u8" { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @45, i32 0, i32 0), i64 8 }, %"[]u8" { i8* getelementptr inbounds ([16 x i8], [16 x i8]* @46, i32 0, i32 0), i64 16 }], align 8
@panic = internal unnamed_addr constant void (%"[]u8"*, %std.builtin.StackTrace*)* @std.builtin.default_panic, align 8
@zig_is_stage2 = internal unnamed_addr constant i1 false, align 1
@output_mode = internal unnamed_addr constant i2 0, align 1
@link_libc = internal unnamed_addr constant i1 false, align 1
@os = internal unnamed_addr constant { <{ i6, [3 x i8] }>, %std.target.LinuxVersionRange } { <{ i6, [3 x i8] }> <{ i6 8, [3 x i8] undef }>, %std.target.LinuxVersionRange { %std.builtin.Range { %std.builtin.Version { i32 5, i32 13, i32 0 }, %std.builtin.Version { i32 5, i32 13, i32 0 } }, %std.builtin.Version { i32 2, i32 19, i32 0 } } }, align 4
@native_os = internal unnamed_addr constant i6 8, align 1
@featureSet = internal unnamed_addr constant void (%std.target.Set*, %"[]std.target.x86.Feature"*)* @"std.target.Feature.feature_set_fns(std.target.x86.Feature).featureSet", align 8
@47 = internal unnamed_addr constant [8 x i8] c"skylake\00", align 1
@skylake = internal unnamed_addr constant { %"[]u8", { %"[]u8", i1, [7 x i8] }, %std.target.Set } { %"[]u8" { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @47, i64 0, i64 0), i64 7 }, { %"[]u8", i1, [7 x i8] } { %"[]u8" { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @47, i64 0, i64 0), i64 7 }, i1 true, [7 x i8] undef }, %std.target.Set { [5 x i64] [i64 6190362172988590192, i64 8936892283916, i64 14608, i64 0, i64 0] } }, align 8
@cpu = internal unnamed_addr constant { <{ i6, [7 x i8] }>, %std.target.Model*, %std.target.Set } { <{ i6, [7 x i8] }> <{ i6 -30, [7 x i8] undef }>, %std.target.Model* bitcast ({ %"[]u8", { %"[]u8", i1, [7 x i8] }, %std.target.Set }* @skylake to %std.target.Model*), %std.target.Set { [5 x i64] [i64 6190362310427544688, i64 1432154786627206156, i64 15632, i64 0, i64 0] } }, align 8
@native_arch = internal unnamed_addr constant i6 -30, align 1
@48 = internal unnamed_addr constant [7 x i8] c"_start\00", align 1
@start_sym_name = internal unnamed_addr constant [7 x i8]* @48, align 8
@argc_argv_ptr = internal unnamed_addr global i64* undef, align 8
@mode = internal unnamed_addr constant i2 -1, align 1
@runtime_safety = internal unnamed_addr constant i1 false, align 1
@enable_segfault_handler = internal unnamed_addr constant i1 false, align 1
@panic_stage = internal thread_local unnamed_addr global i64 0, align 8
@panicking = internal unnamed_addr global i8 0, align 1
@single_threaded = internal unnamed_addr constant i1 false, align 1
@abi = internal unnamed_addr constant i5 1, align 1
@target = internal unnamed_addr constant { { <{ i6, [7 x i8] }>, %std.target.Model*, %std.target.Set }, { <{ i6, [3 x i8] }>, %std.target.LinuxVersionRange }, <{ i5, [7 x i8] }> } { { <{ i6, [7 x i8] }>, %std.target.Model*, %std.target.Set } { <{ i6, [7 x i8] }> <{ i6 -30, [7 x i8] undef }>, %std.target.Model* bitcast ({ %"[]u8", { %"[]u8", i1, [7 x i8] }, %std.target.Set }* @skylake to %std.target.Model*), %std.target.Set { [5 x i64] [i64 6190362310427544688, i64 1432154786627206156, i64 15632, i64 0, i64 0] } }, { <{ i6, [3 x i8] }>, %std.target.LinuxVersionRange } { <{ i6, [3 x i8] }> <{ i6 8, [3 x i8] undef }>, %std.target.LinuxVersionRange { %std.builtin.Range { %std.builtin.Version { i32 5, i32 13, i32 0 }, %std.builtin.Version { i32 5, i32 13, i32 0 } }, %std.builtin.Version { i32 2, i32 19, i32 0 } } }, <{ i5, [7 x i8] }> <{ i5 1, [7 x i8] undef }> }, align 8
@target.1 = internal unnamed_addr constant { { <{ i6, [7 x i8] }>, %std.target.Model*, %std.target.Set }, { <{ i6, [3 x i8] }>, %std.target.LinuxVersionRange }, <{ i5, [7 x i8] }> } { { <{ i6, [7 x i8] }>, %std.target.Model*, %std.target.Set } { <{ i6, [7 x i8] }> <{ i6 -30, [7 x i8] undef }>, %std.target.Model* bitcast ({ %"[]u8", { %"[]u8", i1, [7 x i8] }, %std.target.Set }* @skylake to %std.target.Model*), %std.target.Set { [5 x i64] [i64 6190362310427544688, i64 1432154786627206156, i64 15632, i64 0, i64 0] } }, { <{ i6, [3 x i8] }>, %std.target.LinuxVersionRange } { <{ i6, [3 x i8] }> <{ i6 8, [3 x i8] undef }>, %std.target.LinuxVersionRange { %std.builtin.Range { %std.builtin.Version { i32 5, i32 13, i32 0 }, %std.builtin.Version { i32 5, i32 13, i32 0 } }, %std.builtin.Version { i32 2, i32 19, i32 0 } } }, <{ i5, [7 x i8] }> <{ i5 1, [7 x i8] undef }> }, align 8
@use_pthreads = internal unnamed_addr constant i1 false, align 1
@panic_mutex = internal unnamed_addr global %std.Thread.Mutex zeroinitializer, align 4
@is_windows = internal unnamed_addr constant i1 false, align 1
@io_mode = internal unnamed_addr constant i1 false, align 1
@mode.2 = internal unnamed_addr constant i1 false, align 1
@is_async = internal unnamed_addr constant i1 false, align 1
@elf_aux_maybe = internal unnamed_addr global %std.elf.Elf64_auxv_t* null, align 8
@position_independent_executable = internal unnamed_addr constant i1 false, align 1
@is_windows.3 = internal unnamed_addr constant i1 false, align 1
@assert = internal unnamed_addr constant void (i1)* @std.debug.assert, align 8
@native_arch.4 = internal unnamed_addr constant i6 -30, align 1
@is_mips = internal unnamed_addr constant i1 false, align 1
@is_sparc = internal unnamed_addr constant i1 false, align 1
@strip_debug_info = internal unnamed_addr constant i1 true, align 1
@tls_image = internal unnamed_addr global %std.os.linux.tls.TLSImage undef, align 8
@main_thread_tls_buffer = internal unnamed_addr global [8448 x i8] undef, align 4096
@assert.5 = internal unnamed_addr constant void (i1)* @std.debug.assert, align 8
@argv = internal unnamed_addr global %"[][*:0]u8" undef, align 8
@environ = internal unnamed_addr global %"[][*:0]u8" undef, align 8
@errno = internal unnamed_addr constant i16 (i64)* @std.os.linux.getErrno, align 8
@tls_thread_id = internal thread_local unnamed_addr global %"?u64" { i64 undef, i1 false }, align 8
@49 = internal unnamed_addr constant [4 x i8] c"any\00", align 1
@ANY = internal unnamed_addr constant [4 x i8]* @49, align 8
@app_mask = internal unnamed_addr constant [32 x i32] [i32 -4, i32 2147483647, i32 -1, i32 -1, i32 -1, i32 -1, i32 -1, i32 -1, i32 -1, i32 -1, i32 -1, i32 -1, i32 -1, i32 -1, i32 -1, i32 -1, i32 -1, i32 -1, i32 -1, i32 -1, i32 -1, i32 -1, i32 -1, i32 -1, i32 -1, i32 -1, i32 -1, i32 -1, i32 -1, i32 -1, i32 -1, i32 -1], align 4
@native_arch.6 = internal unnamed_addr constant i6 -30, align 1
@tls_variant = internal unnamed_addr constant i1 true, align 1
@tls_tp_points_past_tcb = internal unnamed_addr constant i1 false, align 1
@syscall2 = internal unnamed_addr constant i64 (i64, i64, i64)* @std.os.linux.x86_64.syscall2, align 8
@assert.7 = internal unnamed_addr constant void (i1)* @std.debug.assert, align 8
@syscall1 = internal unnamed_addr constant i64 (i64, i64)* @std.os.linux.x86_64.syscall1, align 8
@lock_init = internal unnamed_addr constant i1 false, align 1
@default_instance = internal unnamed_addr constant %std.event.loop.Loop* null, align 8
@instance = internal unnamed_addr constant %std.event.loop.Loop* null, align 8
@syscall3 = internal unnamed_addr constant i64 (i64, i64, i64, i64)* @std.os.linux.x86_64.syscall3, align 8
@unexpected_error_tracing = internal unnamed_addr constant i1 false, align 1
@syscall0 = internal unnamed_addr constant i64 (i64)* @std.os.linux.x86_64.syscall0, align 8
@syscall4 = internal unnamed_addr constant i64 (i64, i64, i64, i64, i64)* @std.os.linux.x86_64.syscall4, align 8
@syscall6 = internal unnamed_addr constant i64 (i64, i64, i64, i64, i64, i64, i64)* @std.os.linux.x86_64.syscall6, align 8
@assert.8 = internal unnamed_addr constant void (i1)* @std.debug.assert, align 8
@target.9 = internal unnamed_addr constant { { <{ i6, [7 x i8] }>, %std.target.Model*, %std.target.Set }, { <{ i6, [3 x i8] }>, %std.target.LinuxVersionRange }, <{ i5, [7 x i8] }> } { { <{ i6, [7 x i8] }>, %std.target.Model*, %std.target.Set } { <{ i6, [7 x i8] }> <{ i6 -30, [7 x i8] undef }>, %std.target.Model* bitcast ({ %"[]u8", { %"[]u8", i1, [7 x i8] }, %std.target.Set }* @skylake to %std.target.Model*), %std.target.Set { [5 x i64] [i64 6190362310427544688, i64 1432154786627206156, i64 15632, i64 0, i64 0] } }, { <{ i6, [3 x i8] }>, %std.target.LinuxVersionRange } { <{ i6, [3 x i8] }> <{ i6 8, [3 x i8] undef }>, %std.target.LinuxVersionRange { %std.builtin.Range { %std.builtin.Version { i32 5, i32 13, i32 0 }, %std.builtin.Version { i32 5, i32 13, i32 0 } }, %std.builtin.Version { i32 2, i32 19, i32 0 } } }, <{ i5, [7 x i8] }> <{ i5 1, [7 x i8] undef }> }, align 8
@assert.10 = internal unnamed_addr constant void (i1)* @std.debug.assert, align 8
@50 = internal unnamed_addr constant [8 x i8] c"test \22\22\00", align 1
@51 = internal unnamed_addr constant [1 x %std.builtin.TestFn] [%std.builtin.TestFn { %"[]u8" { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @50, i64 0, i64 0), i64 7 }, i16 ()* @"test \22\22", %"?usize" { i64 undef, i1 false } }], align 8
@test_functions = internal unnamed_addr global %"[]std.builtin.TestFn" { %std.builtin.TestFn* getelementptr inbounds ([1 x %std.builtin.TestFn], [1 x %std.builtin.TestFn]* @51, i64 0, i64 0), i64 1 }, align 8
@default_stack_trace_frames = internal unnamed_addr constant i64 0, align 8
@assert.11 = internal unnamed_addr constant void (i1)* @std.debug.assert, align 8
@hash = internal unnamed_addr constant i64 (i64)* @"std.hash_map.getAutoHashFn(usize,std.hash_map.AutoContext(usize)).hash", align 8
@eql = internal unnamed_addr constant i1 (i64, i64)* @"std.hash_map.getAutoEqlFn(usize,std.hash_map.AutoContext(usize)).eql", align 8
@mutex_init = internal unnamed_addr constant %std.Thread.Mutex zeroinitializer, align 4
@vtable = internal unnamed_addr constant %std.mem.Allocator.VTable { void ({ %"[]u8", i16 }*, i8*, i64, i29, i29, i64)* @std.heap.PageAllocator.alloc, void (%"?usize"*, i8*, %"[]u8"*, i29, i64, i29, i64)* @std.heap.PageAllocator.resize, void (i8*, %"[]u8"*, i29, i64)* @std.heap.PageAllocator.free }, align 8
@page_allocator = internal unnamed_addr constant %std.mem.Allocator { i8* undef, %std.mem.Allocator.VTable* @vtable }, align 8
@allocator_instance = internal unnamed_addr global { %std.mem.Allocator, [12 x %std.heap.general_purpose_allocator.BucketHeader*], %"std.hash_map.HashMapUnmanaged(usize,std.heap.general_purpose_allocator.LargeAlloc,std.hash_map.AutoContext(usize),80)", <{ %std.Thread.Mutex, [4 x i8] }> } { %std.mem.Allocator { i8* undef, %std.mem.Allocator.VTable* @vtable }, [12 x %std.heap.general_purpose_allocator.BucketHeader*] zeroinitializer, %"std.hash_map.HashMapUnmanaged(usize,std.heap.general_purpose_allocator.LargeAlloc,std.hash_map.AutoContext(usize),80)" zeroinitializer, <{ %std.Thread.Mutex, [4 x i8] }> <{ %std.Thread.Mutex zeroinitializer, [4 x i8] undef }> }, align 8
@log_level = internal unnamed_addr global i2 1, align 1
@log_err_count = internal unnamed_addr global i64 0, align 8
@exit = internal unnamed_addr constant void (i8)* @std.os.exit, align 8
@args_buffer = internal unnamed_addr global [8192 x i8] undef, align 1
@args_allocator = internal unnamed_addr global %std.heap.FixedBufferAllocator { i64 0, %"[]u8" { i8* getelementptr inbounds ([8192 x i8], [8192 x i8]* @args_buffer, i64 0, i64 0), i64 8192 } }, align 8
@zig_exe_path = internal unnamed_addr global %"[]u8" undef, align 8
@is_windows.12 = internal unnamed_addr constant i1 false, align 1
@assert.13 = internal unnamed_addr constant void (i1)* @std.debug.assert, align 8
@assert.14 = internal unnamed_addr constant void (i1)* @std.debug.assert, align 8
@next_mmap_addr_hint = internal unnamed_addr global i8* null, align 8
@stderr_mutex = internal unnamed_addr global %std.Thread.Mutex zeroinitializer, align 4
@assert.15 = internal unnamed_addr constant void (i1)* @std.debug.assert, align 8
@assert.16 = internal unnamed_addr constant void (i1)* @std.debug.assert, align 8
@vtable.17 = internal unnamed_addr constant %std.mem.Allocator.VTable { void ({ %"[]u8", i16 }*, i8*, i64, i29, i29, i64)* @std.mem.Allocator.gen.allocImpl, void (%"?usize"*, i8*, %"[]u8"*, i29, i64, i29, i64)* @std.mem.Allocator.gen.resizeImpl, void (i8*, %"[]u8"*, i29, i64)* @std.mem.Allocator.gen.freeImpl }, align 8
@is_ppc64 = internal unnamed_addr constant i1 false, align 1
@vdso_clock_gettime = internal unnamed_addr global i8* bitcast (i64 (i32, %std.os.linux.timespec*)* @std.os.linux.init_vdso_clock_gettime to i8*), align 8
@stack_n = internal unnamed_addr constant i64 0, align 8
@52 = internal unnamed_addr constant [10 x i8] c"LINUX_2.6\00", align 1
@CGT_VER = internal unnamed_addr constant [10 x i8]* @52, align 8
@53 = internal unnamed_addr constant [21 x i8] c"__vdso_clock_gettime\00", align 1
@CGT_SYM = internal unnamed_addr constant [21 x i8]* @53, align 8
@primes = internal unnamed_addr constant [5 x i64] [i64 -6884282663029611473, i64 -1800455987208640293, i64 -8161530843051276573, i64 6384245875588680899, i64 2129725606500045391], align 8
@native_endian = internal unnamed_addr constant i1 true, align 1
@assert.18 = internal unnamed_addr constant void (i1)* @std.debug.assert, align 8
@native_arch.19 = internal unnamed_addr constant i6 -30, align 1
@54 = internal unnamed_addr constant %Expr zeroinitializer, align 4
@55 = internal unnamed_addr constant [5 x i64] zeroinitializer, align 8
@56 = internal unnamed_addr constant %std.Thread.StaticResetEvent zeroinitializer, align 4
@57 = internal unnamed_addr constant { %"?usize", %"?usize", i2, <{ i8, [6 x i8] }> } { %"?usize" { i64 undef, i1 false }, %"?usize" { i64 undef, i1 false }, i2 -2, <{ i8, [6 x i8] }> <{ i8 32, [6 x i8] undef }> }, align 8
@58 = internal unnamed_addr constant [18 x i8] c"thread {} panic: \00", align 1
@59 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([18 x i8], [18 x i8]* @58, i64 0, i64 0), i64 7 }, align 8
@60 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@61 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@62 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@63 = internal unnamed_addr constant %"[]u8" zeroinitializer, align 8
@64 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@65 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@66 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([18 x i8], [18 x i8]* @58, i64 0, i64 9), i64 8 }, align 8
@67 = internal unnamed_addr constant %"[]u8" zeroinitializer, align 8
@68 = internal unnamed_addr constant { %"?usize", %"?usize", i2, <{ i8, [6 x i8] }> } { %"?usize" { i64 undef, i1 false }, %"?usize" { i64 undef, i1 false }, i2 -2, <{ i8, [6 x i8] }> <{ i8 32, [6 x i8] undef }> }, align 8
@69 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@70 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@71 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@72 = internal unnamed_addr constant [5 x i8] c"{s}\0A\00", align 1
@73 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @72, i64 0, i64 1), i64 1 }, align 8
@74 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@75 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@76 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @72, i64 0, i64 3), i64 1 }, align 8
@77 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @72, i64 0, i64 1), i64 1 }, align 8
@78 = internal unnamed_addr constant [8 x i8] c"{ ... }\00", align 1
@79 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @78, i64 0, i64 0), i64 7 }, align 8
@80 = internal unnamed_addr constant %"?u64" { i64 undef, i1 false }, align 8
@81 = internal unnamed_addr constant { %"?usize", %"?usize", i2, <{ i8, [6 x i8] }> } { %"?usize" { i64 undef, i1 false }, %"?usize" { i64 undef, i1 false }, i2 -2, <{ i8, [6 x i8] }> <{ i8 32, [6 x i8] undef }> }, align 8
@82 = internal unnamed_addr constant [36 x i8] c"Panicked during a panic. Aborting.\0A\00", align 1
@83 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([36 x i8], [36 x i8]* @82, i64 0, i64 0), i64 35 }, align 8
@84 = internal unnamed_addr constant %"[]u8" zeroinitializer, align 8
@85 = internal unnamed_addr constant i64 (i8*, i64, i64, i32, i32, i64)* @std.os.linux.mmap, align 8
@86 = internal unnamed_addr constant i64 (i32, %std.os.linux.rlimit*)* @std.os.linux.setrlimit, align 8
@87 = internal unnamed_addr constant { %"?usize", %"?usize", i2, <{ i8, [6 x i8] }> } { %"?usize" { i64 undef, i1 false }, %"?usize" { i64 undef, i1 false }, i2 -2, <{ i8, [6 x i8] }> <{ i8 32, [6 x i8] undef }> }, align 8
@88 = internal unnamed_addr constant [49 x i8] c"Unable to dump stack trace: debug info stripped\0A\00", align 1
@89 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([49 x i8], [49 x i8]* @88, i64 0, i64 0), i64 48 }, align 8
@90 = internal unnamed_addr constant { %"?usize", %"?usize", i2, <{ i8, [6 x i8] }> } { %"?usize" { i64 undef, i1 false }, %"?usize" { i64 undef, i1 false }, i2 -2, <{ i8, [6 x i8] }> <{ i8 32, [6 x i8] undef }> }, align 8
@91 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([49 x i8], [49 x i8]* @88, i64 0, i64 0), i64 48 }, align 8
@92 = internal unnamed_addr constant { %"?std.fs.file.File", i1, i1, <{ i1, [5 x i8] }>, %std.Progress.Node, %std.time.Timer, i64, <{ [100 x i8], [4 x i8] }>, i64, i64, <{ i1, [3 x i8] }>, %std.Thread.Mutex, i64 } { %"?std.fs.file.File" undef, i1 false, i1 false, <{ i1, [5 x i8] }> <{ i1 true, [5 x i8] undef }>, %std.Progress.Node undef, %std.time.Timer undef, i64 undef, <{ [100 x i8], [4 x i8] }> undef, i64 50000000, i64 500000000, <{ i1, [3 x i8] }> <{ i1 true, [3 x i8] undef }>, %std.Thread.Mutex zeroinitializer, i64 undef }, align 8
@93 = internal unnamed_addr constant [5 x i8] c"Test\00", align 1
@94 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @93, i64 0, i64 0), i64 4 }, align 8
@95 = internal unnamed_addr constant [18 x i8] c"timer unsupported\00", align 1
@96 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([18 x i8], [18 x i8]* @95, i64 0, i64 0), i64 17 }, align 8
@97 = internal unnamed_addr constant %"[]u8" zeroinitializer, align 8
@98 = internal unnamed_addr constant %std.mem.Allocator { i8* undef, %std.mem.Allocator.VTable* @vtable }, align 8
@99 = internal unnamed_addr constant [12 x %std.heap.general_purpose_allocator.BucketHeader*] zeroinitializer, align 8
@100 = internal unnamed_addr constant %"std.hash_map.HashMapUnmanaged(usize,std.heap.general_purpose_allocator.LargeAlloc,std.hash_map.AutoContext(usize),80)" zeroinitializer, align 8
@101 = internal unnamed_addr constant %std.Thread.Mutex zeroinitializer, align 4
@102 = internal unnamed_addr constant [54 x i8] c"Too many bytes passed over the CLI to the test runner\00", align 1
@103 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([54 x i8], [54 x i8]* @102, i64 0, i64 0), i64 53 }, align 8
@104 = internal unnamed_addr constant [5 x i8] c"test\00", align 1
@105 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @104, i64 0, i64 0), i64 4 }, align 8
@106 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @104, i64 0, i64 0), i64 4 }, align 8
@107 = internal unnamed_addr constant [1 x i8]* undef, align 8
@108 = internal unnamed_addr constant [39 x i8] c"Wrong number of command line arguments\00", align 1
@109 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([39 x i8], [39 x i8]* @108, i64 0, i64 0), i64 38 }, align 8
@110 = internal unnamed_addr constant %"?std.fs.file.File" { %std.fs.file.File undef, i1 false }, align 4
@111 = internal unnamed_addr constant [5 x i8] c"TERM\00", align 1
@112 = internal unnamed_addr constant [5 x i8] c"dumb\00", align 1
@113 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @112, i64 0, i64 0), i64 4 }, align 8
@114 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@115 = internal unnamed_addr constant %"?std.fs.file.File" { %std.fs.file.File undef, i1 false }, align 4
@116 = internal unnamed_addr constant i1 false, align 1
@117 = internal unnamed_addr constant %"?std.fs.file.File" { %std.fs.file.File undef, i1 false }, align 4
@118 = internal unnamed_addr constant %"?std.fs.file.File" { %std.fs.file.File undef, i1 false }, align 4
@119 = internal unnamed_addr constant [18 x i8] c"sentinel mismatch\00", align 1
@120 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([18 x i8], [18 x i8]* @119, i64 0, i64 0), i64 17 }, align 8
@121 = internal unnamed_addr constant %"[]u8" zeroinitializer, align 8
@122 = internal unnamed_addr constant %"[]usize" zeroinitializer, align 8
@123 = internal unnamed_addr constant %"?[:0]u8" { %"[]u8" undef, i1 false }, align 8
@124 = internal unnamed_addr constant %"[][]u8" zeroinitializer, align 8
@125 = internal unnamed_addr constant %"?std.fs.file.File" { %std.fs.file.File undef, i1 false }, align 4
@126 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@127 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@128 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@129 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@130 = internal unnamed_addr constant %"?[:0]const u8" { %"[]u8" undef, i1 false }, align 8
@131 = internal unnamed_addr constant %"[]u8" zeroinitializer, align 8
@132 = internal unnamed_addr constant %"[]u8" zeroinitializer, align 8
@133 = internal unnamed_addr constant %"[]usize" zeroinitializer, align 8
@134 = internal unnamed_addr constant i29 8, align 4
@135 = internal unnamed_addr constant %"[]u8" zeroinitializer, align 8
@136 = internal unnamed_addr constant %"?[]const u8" { %"[]u8" undef, i1 false }, align 8
@137 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@138 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@139 = internal unnamed_addr constant [5 x i8] c"... \00", align 1
@140 = internal unnamed_addr constant [5 x i8]* @139, align 8
@141 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @139, i64 0, i64 0), i64 4 }, align 8
@142 = internal unnamed_addr constant [5 x i8]* @139, align 8
@143 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @139, i64 0, i64 0), i64 4 }, align 8
@144 = internal unnamed_addr constant [5 x i8]* @139, align 8
@145 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @139, i64 0, i64 0), i64 4 }, align 8
@146 = internal unnamed_addr constant [5 x i8]* @139, align 8
@147 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @139, i64 0, i64 0), i64 4 }, align 8
@148 = internal unnamed_addr constant [5 x i8]* @139, align 8
@149 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @139, i64 0, i64 0), i64 4 }, align 8
@150 = internal unnamed_addr constant [5 x i8]* @139, align 8
@151 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @139, i64 0, i64 0), i64 4 }, align 8
@152 = internal unnamed_addr constant [5 x i8]* @139, align 8
@153 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @139, i64 0, i64 0), i64 4 }, align 8
@154 = internal unnamed_addr constant { %"?usize", %"?usize", i2, <{ i8, [6 x i8] }> } { %"?usize" { i64 undef, i1 false }, %"?usize" { i64 undef, i1 false }, i2 -2, <{ i8, [6 x i8] }> <{ i8 32, [6 x i8] undef }> }, align 8
@155 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@156 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@157 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@158 = internal unnamed_addr constant [16 x i8] c"{d}/{d} {s}... \00", align 1
@159 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([16 x i8], [16 x i8]* @158, i64 0, i64 1), i64 1 }, align 8
@160 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@161 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@162 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([16 x i8], [16 x i8]* @158, i64 0, i64 3), i64 1 }, align 8
@163 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@164 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@165 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@166 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([16 x i8], [16 x i8]* @158, i64 0, i64 5), i64 1 }, align 8
@167 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@168 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@169 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([16 x i8], [16 x i8]* @158, i64 0, i64 7), i64 1 }, align 8
@170 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@171 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@172 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@173 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([16 x i8], [16 x i8]* @158, i64 0, i64 9), i64 1 }, align 8
@174 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@175 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@176 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([16 x i8], [16 x i8]* @158, i64 0, i64 11), i64 4 }, align 8
@177 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([16 x i8], [16 x i8]* @158, i64 0, i64 1), i64 1 }, align 8
@178 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([16 x i8], [16 x i8]* @158, i64 0, i64 5), i64 1 }, align 8
@179 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([16 x i8], [16 x i8]* @158, i64 0, i64 9), i64 1 }, align 8
@180 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @78, i64 0, i64 0), i64 7 }, align 8
@181 = internal unnamed_addr constant { %"?usize", %"?usize", i2, <{ i8, [6 x i8] }> } { %"?usize" { i64 undef, i1 false }, %"?usize" { i64 undef, i1 false }, i2 -2, <{ i8, [6 x i8] }> <{ i8 32, [6 x i8] undef }> }, align 8
@182 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@183 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@184 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@185 = internal unnamed_addr constant [26 x i8] c"{s}... SKIP (async test)\0A\00", align 1
@186 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([26 x i8], [26 x i8]* @185, i64 0, i64 1), i64 1 }, align 8
@187 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@188 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@189 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([26 x i8], [26 x i8]* @185, i64 0, i64 3), i64 22 }, align 8
@190 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([26 x i8], [26 x i8]* @185, i64 0, i64 1), i64 1 }, align 8
@191 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @78, i64 0, i64 0), i64 7 }, align 8
@192 = internal unnamed_addr constant { %"?usize", %"?usize", i2, <{ i8, [6 x i8] }> } { %"?usize" { i64 undef, i1 false }, %"?usize" { i64 undef, i1 false }, i2 -2, <{ i8, [6 x i8] }> <{ i8 32, [6 x i8] undef }> }, align 8
@193 = internal unnamed_addr constant [19 x i8] c"SKIP (async test)\0A\00", align 1
@194 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @193, i64 0, i64 0), i64 18 }, align 8
@195 = internal unnamed_addr constant { %"?usize", %"?usize", i2, <{ i8, [6 x i8] }> } { %"?usize" { i64 undef, i1 false }, %"?usize" { i64 undef, i1 false }, i2 -2, <{ i8, [6 x i8] }> <{ i8 32, [6 x i8] undef }> }, align 8
@196 = internal unnamed_addr constant [4 x i8] c"OK\0A\00", align 1
@197 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @196, i64 0, i64 0), i64 3 }, align 8
@198 = internal unnamed_addr constant { %"?usize", %"?usize", i2, <{ i8, [6 x i8] }> } { %"?usize" { i64 undef, i1 false }, %"?usize" { i64 undef, i1 false }, i2 -2, <{ i8, [6 x i8] }> <{ i8 32, [6 x i8] undef }> }, align 8
@199 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@200 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@201 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@202 = internal unnamed_addr constant [19 x i8] c"{s}... FAIL ({s})\0A\00", align 1
@203 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @202, i64 0, i64 1), i64 1 }, align 8
@204 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@205 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@206 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @202, i64 0, i64 3), i64 10 }, align 8
@207 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@208 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@209 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@210 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @202, i64 0, i64 14), i64 1 }, align 8
@211 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@212 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@213 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @202, i64 0, i64 16), i64 2 }, align 8
@214 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @202, i64 0, i64 1), i64 1 }, align 8
@215 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @78, i64 0, i64 0), i64 7 }, align 8
@216 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @202, i64 0, i64 14), i64 1 }, align 8
@217 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @78, i64 0, i64 0), i64 7 }, align 8
@218 = internal unnamed_addr constant { %"?usize", %"?usize", i2, <{ i8, [6 x i8] }> } { %"?usize" { i64 undef, i1 false }, %"?usize" { i64 undef, i1 false }, i2 -2, <{ i8, [6 x i8] }> <{ i8 32, [6 x i8] undef }> }, align 8
@219 = internal unnamed_addr constant [12 x i8] c"FAIL ({s})\0A\00", align 1
@220 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @219, i64 0, i64 0), i64 6 }, align 8
@221 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@222 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@223 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@224 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @219, i64 0, i64 7), i64 1 }, align 8
@225 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@226 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@227 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @219, i64 0, i64 9), i64 2 }, align 8
@228 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @219, i64 0, i64 7), i64 1 }, align 8
@229 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @78, i64 0, i64 0), i64 7 }, align 8
@230 = internal unnamed_addr constant { %"?usize", %"?usize", i2, <{ i8, [6 x i8] }> } { %"?usize" { i64 undef, i1 false }, %"?usize" { i64 undef, i1 false }, i2 -2, <{ i8, [6 x i8] }> <{ i8 32, [6 x i8] undef }> }, align 8
@231 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@232 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@233 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@234 = internal unnamed_addr constant [13 x i8] c"{s}... SKIP\0A\00", align 1
@235 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @234, i64 0, i64 1), i64 1 }, align 8
@236 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@237 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@238 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @234, i64 0, i64 3), i64 9 }, align 8
@239 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @234, i64 0, i64 1), i64 1 }, align 8
@240 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @78, i64 0, i64 0), i64 7 }, align 8
@241 = internal unnamed_addr constant { %"?usize", %"?usize", i2, <{ i8, [6 x i8] }> } { %"?usize" { i64 undef, i1 false }, %"?usize" { i64 undef, i1 false }, i2 -2, <{ i8, [6 x i8] }> <{ i8 32, [6 x i8] undef }> }, align 8
@242 = internal unnamed_addr constant [6 x i8] c"SKIP\0A\00", align 1
@243 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @242, i64 0, i64 0), i64 5 }, align 8
@244 = internal unnamed_addr constant { %"?usize", %"?usize", i2, <{ i8, [6 x i8] }> } { %"?usize" { i64 undef, i1 false }, %"?usize" { i64 undef, i1 false }, i2 -2, <{ i8, [6 x i8] }> <{ i8 32, [6 x i8] undef }> }, align 8
@245 = internal unnamed_addr constant [23 x i8] c"All {d} tests passed.\0A\00", align 1
@246 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([23 x i8], [23 x i8]* @245, i64 0, i64 0), i64 4 }, align 8
@247 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@248 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@249 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@250 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([23 x i8], [23 x i8]* @245, i64 0, i64 5), i64 1 }, align 8
@251 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@252 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@253 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([23 x i8], [23 x i8]* @245, i64 0, i64 7), i64 15 }, align 8
@254 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([23 x i8], [23 x i8]* @245, i64 0, i64 5), i64 1 }, align 8
@255 = internal unnamed_addr constant { %"?usize", %"?usize", i2, <{ i8, [6 x i8] }> } { %"?usize" { i64 undef, i1 false }, %"?usize" { i64 undef, i1 false }, i2 -2, <{ i8, [6 x i8] }> <{ i8 32, [6 x i8] undef }> }, align 8
@256 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@257 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@258 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@259 = internal unnamed_addr constant [38 x i8] c"{d} passed; {d} skipped; {d} failed.\0A\00", align 1
@260 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([38 x i8], [38 x i8]* @259, i64 0, i64 1), i64 1 }, align 8
@261 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@262 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@263 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([38 x i8], [38 x i8]* @259, i64 0, i64 3), i64 9 }, align 8
@264 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@265 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@266 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@267 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([38 x i8], [38 x i8]* @259, i64 0, i64 13), i64 1 }, align 8
@268 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@269 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@270 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([38 x i8], [38 x i8]* @259, i64 0, i64 15), i64 10 }, align 8
@271 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@272 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@273 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@274 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([38 x i8], [38 x i8]* @259, i64 0, i64 26), i64 1 }, align 8
@275 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@276 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@277 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([38 x i8], [38 x i8]* @259, i64 0, i64 28), i64 9 }, align 8
@278 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([38 x i8], [38 x i8]* @259, i64 0, i64 1), i64 1 }, align 8
@279 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([38 x i8], [38 x i8]* @259, i64 0, i64 13), i64 1 }, align 8
@280 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([38 x i8], [38 x i8]* @259, i64 0, i64 26), i64 1 }, align 8
@281 = internal unnamed_addr constant { %"?usize", %"?usize", i2, <{ i8, [6 x i8] }> } { %"?usize" { i64 undef, i1 false }, %"?usize" { i64 undef, i1 false }, i2 -2, <{ i8, [6 x i8] }> <{ i8 32, [6 x i8] undef }> }, align 8
@282 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@283 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@284 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@285 = internal unnamed_addr constant [25 x i8] c"{d} errors were logged.\0A\00", align 1
@286 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([25 x i8], [25 x i8]* @285, i64 0, i64 1), i64 1 }, align 8
@287 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@288 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@289 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([25 x i8], [25 x i8]* @285, i64 0, i64 3), i64 21 }, align 8
@290 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([25 x i8], [25 x i8]* @285, i64 0, i64 1), i64 1 }, align 8
@291 = internal unnamed_addr constant { %"?usize", %"?usize", i2, <{ i8, [6 x i8] }> } { %"?usize" { i64 undef, i1 false }, %"?usize" { i64 undef, i1 false }, i2 -2, <{ i8, [6 x i8] }> <{ i8 32, [6 x i8] undef }> }, align 8
@292 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@293 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@294 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@295 = internal unnamed_addr constant [26 x i8] c"{d} tests leaked memory.\0A\00", align 1
@296 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([26 x i8], [26 x i8]* @295, i64 0, i64 1), i64 1 }, align 8
@297 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@298 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@299 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([26 x i8], [26 x i8]* @295, i64 0, i64 3), i64 22 }, align 8
@300 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([26 x i8], [26 x i8]* @295, i64 0, i64 1), i64 1 }, align 8
@301 = internal unnamed_addr constant %"[]u8" zeroinitializer, align 8
@302 = internal unnamed_addr constant %"[]u8" zeroinitializer, align 8
@303 = internal unnamed_addr constant %"[]u8" zeroinitializer, align 8
@304 = internal unnamed_addr constant %"[]u8" zeroinitializer, align 8
@305 = internal unnamed_addr constant %"[]usize" zeroinitializer, align 8
@306 = internal unnamed_addr constant %"[]u8" zeroinitializer, align 8
@307 = internal unnamed_addr constant { %"?usize", %"?usize", i2, <{ i8, [6 x i8] }> } { %"?usize" { i64 undef, i1 false }, %"?usize" { i64 undef, i1 false }, i2 -2, <{ i8, [6 x i8] }> <{ i8 32, [6 x i8] undef }> }, align 8
@308 = internal unnamed_addr constant [27 x i8] c"Usage: {s} path/to/zig{s}\0A\00", align 1
@309 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([27 x i8], [27 x i8]* @308, i64 0, i64 0), i64 7 }, align 8
@310 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@311 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@312 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@313 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([27 x i8], [27 x i8]* @308, i64 0, i64 8), i64 1 }, align 8
@314 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@315 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@316 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([27 x i8], [27 x i8]* @308, i64 0, i64 10), i64 12 }, align 8
@317 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@318 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@319 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@320 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([27 x i8], [27 x i8]* @308, i64 0, i64 23), i64 1 }, align 8
@321 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@322 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@323 = internal unnamed_addr constant [1 x i8] zeroinitializer, align 1
@324 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([27 x i8], [27 x i8]* @308, i64 0, i64 25), i64 1 }, align 8
@325 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([27 x i8], [27 x i8]* @308, i64 0, i64 8), i64 1 }, align 8
@326 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @78, i64 0, i64 0), i64 7 }, align 8
@327 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([27 x i8], [27 x i8]* @308, i64 0, i64 23), i64 1 }, align 8
@328 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([1 x i8], [1 x i8]* @323, i64 0, i64 0), i64 0 }, align 8
@329 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @52, i64 0, i64 0), i64 9 }, align 8
@330 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([21 x i8], [21 x i8]* @53, i64 0, i64 0), i64 20 }, align 8
@331 = internal unnamed_addr constant { %"?usize", %"?usize", i2, <{ i8, [6 x i8] }> } { %"?usize" { i64 undef, i1 false }, %"?usize" { i64 undef, i1 false }, i2 -2, <{ i8, [6 x i8] }> <{ i8 32, [6 x i8] undef }> }, align 8
@332 = internal unnamed_addr constant [7 x i8] c"\1B[{d}D\00", align 1
@333 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @332, i64 0, i64 0), i64 2 }, align 8
@334 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@335 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@336 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@337 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @332, i64 0, i64 3), i64 1 }, align 8
@338 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@339 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@340 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @332, i64 0, i64 5), i64 1 }, align 8
@341 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @332, i64 0, i64 3), i64 1 }, align 8
@342 = internal unnamed_addr constant { %"?usize", %"?usize", i2, <{ i8, [6 x i8] }> } { %"?usize" { i64 undef, i1 false }, %"?usize" { i64 undef, i1 false }, i2 -2, <{ i8, [6 x i8] }> <{ i8 32, [6 x i8] undef }> }, align 8
@343 = internal unnamed_addr constant [5 x i8] c"\1B[0K\00", align 1
@344 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @343, i64 0, i64 0), i64 4 }, align 8
@345 = internal unnamed_addr constant %"[]usize" zeroinitializer, align 8
@346 = internal unnamed_addr constant { %"?usize", %"?usize", i2, <{ i8, [6 x i8] }> } { %"?usize" { i64 undef, i1 false }, %"?usize" { i64 undef, i1 false }, i2 -2, <{ i8, [6 x i8] }> <{ i8 32, [6 x i8] undef }> }, align 8
@347 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @139, i64 0, i64 0), i64 4 }, align 8
@348 = internal unnamed_addr constant { %"?usize", %"?usize", i2, <{ i8, [6 x i8] }> } { %"?usize" { i64 undef, i1 false }, %"?usize" { i64 undef, i1 false }, i2 -2, <{ i8, [6 x i8] }> <{ i8 32, [6 x i8] undef }> }, align 8
@349 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@350 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@351 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@352 = internal unnamed_addr constant [4 x i8] c"{s}\00", align 1
@353 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @352, i64 0, i64 1), i64 1 }, align 8
@354 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@355 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@356 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @352, i64 0, i64 1), i64 1 }, align 8
@357 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @78, i64 0, i64 0), i64 7 }, align 8
@358 = internal unnamed_addr constant { %"?usize", %"?usize", i2, <{ i8, [6 x i8] }> } { %"?usize" { i64 undef, i1 false }, %"?usize" { i64 undef, i1 false }, i2 -2, <{ i8, [6 x i8] }> <{ i8 32, [6 x i8] undef }> }, align 8
@359 = internal unnamed_addr constant [2 x i8] c" \00", align 1
@360 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([2 x i8], [2 x i8]* @359, i64 0, i64 0), i64 1 }, align 8
@361 = internal unnamed_addr constant { %"?usize", %"?usize", i2, <{ i8, [6 x i8] }> } { %"?usize" { i64 undef, i1 false }, %"?usize" { i64 undef, i1 false }, i2 -2, <{ i8, [6 x i8] }> <{ i8 32, [6 x i8] undef }> }, align 8
@362 = internal unnamed_addr constant [11 x i8] c"[{d}/{d}] \00", align 1
@363 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @362, i64 0, i64 0), i64 1 }, align 8
@364 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@365 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@366 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@367 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @362, i64 0, i64 2), i64 1 }, align 8
@368 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@369 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@370 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @362, i64 0, i64 4), i64 1 }, align 8
@371 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@372 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@373 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@374 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @362, i64 0, i64 6), i64 1 }, align 8
@375 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@376 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@377 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @362, i64 0, i64 8), i64 2 }, align 8
@378 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @362, i64 0, i64 2), i64 1 }, align 8
@379 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @362, i64 0, i64 6), i64 1 }, align 8
@380 = internal unnamed_addr constant { %"?usize", %"?usize", i2, <{ i8, [6 x i8] }> } { %"?usize" { i64 undef, i1 false }, %"?usize" { i64 undef, i1 false }, i2 -2, <{ i8, [6 x i8] }> <{ i8 32, [6 x i8] undef }> }, align 8
@381 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([2 x i8], [2 x i8]* @359, i64 0, i64 0), i64 1 }, align 8
@382 = internal unnamed_addr constant { %"?usize", %"?usize", i2, <{ i8, [6 x i8] }> } { %"?usize" { i64 undef, i1 false }, %"?usize" { i64 undef, i1 false }, i2 -2, <{ i8, [6 x i8] }> <{ i8 32, [6 x i8] undef }> }, align 8
@383 = internal unnamed_addr constant [7 x i8] c"[{d}] \00", align 1
@384 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @383, i64 0, i64 0), i64 1 }, align 8
@385 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@386 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@387 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@388 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @383, i64 0, i64 2), i64 1 }, align 8
@389 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@390 = internal unnamed_addr constant %"?usize" { i64 undef, i1 false }, align 8
@391 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @383, i64 0, i64 4), i64 2 }, align 8
@392 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @383, i64 0, i64 2), i64 1 }, align 8
@393 = internal unnamed_addr constant { %"?usize", %"?usize", i2, <{ i8, [6 x i8] }> } { %"?usize" { i64 undef, i1 false }, %"?usize" { i64 undef, i1 false }, i2 -2, <{ i8, [6 x i8] }> <{ i8 32, [6 x i8] undef }> }, align 8
@394 = internal unnamed_addr constant %"[]u8" { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @139, i64 0, i64 0), i64 4 }, align 8
@395 = internal unnamed_addr constant %"[]u8" zeroinitializer, align 8

; Function Attrs: cold minsize nobuiltin noreturn nounwind optsize
define internal fastcc void @std.builtin.default_panic(%"[]u8"* nonnull readonly align 8 %0, %std.builtin.StackTrace* align 8 %1) unnamed_addr #0 {
Entry:
  %first_trace_addr = alloca i64, align 8
  %2 = alloca %"?usize", align 8
  %3 = alloca %"?usize", align 8
  %error_return_trace = alloca %std.builtin.StackTrace*, align 8
  store %std.builtin.StackTrace* %1, %std.builtin.StackTrace** %error_return_trace, align 8
  %4 = call i8* @llvm.returnaddress(i32 0)
  %5 = ptrtoint i8* %4 to i64
  store i64 %5, i64* %first_trace_addr, align 8
  %6 = load %std.builtin.StackTrace*, %std.builtin.StackTrace** %error_return_trace, align 8
  %7 = load i64, i64* %first_trace_addr, align 8
  %8 = getelementptr inbounds %"?usize", %"?usize"* %2, i32 0, i32 0
  store i64 %7, i64* %8, align 8
  %9 = getelementptr inbounds %"?usize", %"?usize"* %2, i32 0, i32 1
  store i1 true, i1* %9, align 1
  %10 = getelementptr inbounds %"?usize", %"?usize"* %3, i32 0, i32 0
  store i64 %7, i64* %10, align 8
  %11 = getelementptr inbounds %"?usize", %"?usize"* %3, i32 0, i32 1
  store i1 true, i1* %11, align 1
  call fastcc void @std.debug.panicImpl(%std.builtin.StackTrace* %6, %"?usize"* %3, %"[]u8"* %0)
  unreachable
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @"std.target.Feature.feature_set_fns(std.target.x86.Feature).featureSet"(%std.target.Set* nonnull sret(%std.target.Set) %0, %"[]std.target.x86.Feature"* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %x = alloca %std.target.Set, align 8
  %i = alloca i64, align 8
  %feature = alloca i8, align 1
  call fastcc void @std.target.Set.empty_workaround(%std.target.Set* sret(%std.target.Set) %x)
  store i64 0, i64* %i, align 8
  %2 = getelementptr inbounds %"[]std.target.x86.Feature", %"[]std.target.x86.Feature"* %1, i32 0, i32 1
  %3 = load i64, i64* %2, align 8
  br label %ForCond

ForCond:                                          ; preds = %ForBody, %Entry
  %4 = load i64, i64* %i, align 8
  %5 = icmp ult i64 %4, %3
  br i1 %5, label %ForBody, label %ForEnd

ForBody:                                          ; preds = %ForCond
  %6 = getelementptr inbounds %"[]std.target.x86.Feature", %"[]std.target.x86.Feature"* %1, i32 0, i32 0
  %7 = load i8*, i8** %6, align 8
  %8 = getelementptr inbounds i8, i8* %7, i64 %4
  %9 = load i8, i8* %8, align 1
  store i8 %9, i8* %feature, align 1
  %10 = load i8, i8* %feature, align 1
  %11 = zext i8 %10 to i9
  call fastcc void @std.target.Set.addFeature(%std.target.Set* %x, i9 %11)
  %12 = add nuw i64 %4, 1
  store i64 %12, i64* %i, align 8
  br label %ForCond

ForEnd:                                           ; preds = %ForCond
  %13 = bitcast %std.target.Set* %x to i8*
  %14 = bitcast %std.target.Set* %0 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %14, i8* align 8 %13, i64 40, i1 false)
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.debug.assert(i1 %0) unnamed_addr #1 {
Entry:
  %ok = alloca i1, align 1
  store i1 %0, i1* %ok, align 1
  %1 = load i1, i1* %ok, align 1
  %2 = icmp eq i1 %1, false
  br i1 %2, label %Then, label %Else

Then:                                             ; preds = %Entry
  unreachable

Else:                                             ; preds = %Entry
  br label %EndIf

EndIf:                                            ; preds = %Else
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.os.linux.getErrno(i64 %0) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %signed_r = alloca i64, align 8
  %int = alloca i64, align 8
  %r = alloca i64, align 8
  store i64 %0, i64* %r, align 8
  %1 = load i64, i64* %r, align 8
  store i64 %1, i64* %signed_r, align 8
  %2 = load i64, i64* %signed_r, align 8
  %3 = sext i64 %2 to i65
  %4 = icmp sgt i65 %3, -4096
  br i1 %4, label %BoolAndTrue, label %BoolAndFalse

BoolAndTrue:                                      ; preds = %Entry
  %5 = load i64, i64* %signed_r, align 8
  %6 = icmp slt i64 %5, 0
  br label %BoolAndFalse

BoolAndFalse:                                     ; preds = %BoolAndTrue, %Entry
  %7 = phi i1 [ %4, %Entry ], [ %6, %BoolAndTrue ]
  br i1 %7, label %Then, label %Else

Then:                                             ; preds = %BoolAndFalse
  %8 = load i64, i64* %signed_r, align 8
  %9 = sub nsw i64 0, %8
  store i64 %9, i64* %int, align 8
  br label %EndIf

Else:                                             ; preds = %BoolAndFalse
  store i64 0, i64* %int, align 8
  br label %EndIf

EndIf:                                            ; preds = %Else, %Then
  %10 = load i64, i64* %int, align 8
  %11 = trunc i64 %10 to i16
  store i16 %11, i16* %result, align 2
  %12 = load i16, i16* %result, align 2
  ret i16 %12
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i64 @std.os.linux.x86_64.syscall2(i64 %0, i64 %1, i64 %2) unnamed_addr #1 {
Entry:
  %result = alloca i64, align 8
  %number = alloca i64, align 8
  %arg1 = alloca i64, align 8
  %arg2 = alloca i64, align 8
  store i64 %0, i64* %number, align 8
  store i64 %1, i64* %arg1, align 8
  store i64 %2, i64* %arg2, align 8
  %3 = load i64, i64* %number, align 8
  %4 = load i64, i64* %arg1, align 8
  %5 = load i64, i64* %arg2, align 8
  %6 = call i64 asm sideeffect "syscall", "={rax},{rax},{rdi},{rsi},~{rcx},~{r11},~{memory},~{dirflag},~{fpsr},~{flags}"(i64 %3, i64 %4, i64 %5)
  store i64 %6, i64* %result, align 8
  %7 = load i64, i64* %result, align 8
  ret i64 %7
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i64 @std.os.linux.x86_64.syscall1(i64 %0, i64 %1) unnamed_addr #1 {
Entry:
  %result = alloca i64, align 8
  %number = alloca i64, align 8
  %arg1 = alloca i64, align 8
  store i64 %0, i64* %number, align 8
  store i64 %1, i64* %arg1, align 8
  %2 = load i64, i64* %number, align 8
  %3 = load i64, i64* %arg1, align 8
  %4 = call i64 asm sideeffect "syscall", "={rax},{rax},{rdi},~{rcx},~{r11},~{memory},~{dirflag},~{fpsr},~{flags}"(i64 %2, i64 %3)
  store i64 %4, i64* %result, align 8
  %5 = load i64, i64* %result, align 8
  ret i64 %5
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i64 @std.os.linux.x86_64.syscall3(i64 %0, i64 %1, i64 %2, i64 %3) unnamed_addr #1 {
Entry:
  %result = alloca i64, align 8
  %number = alloca i64, align 8
  %arg1 = alloca i64, align 8
  %arg2 = alloca i64, align 8
  %arg3 = alloca i64, align 8
  store i64 %0, i64* %number, align 8
  store i64 %1, i64* %arg1, align 8
  store i64 %2, i64* %arg2, align 8
  store i64 %3, i64* %arg3, align 8
  %4 = load i64, i64* %number, align 8
  %5 = load i64, i64* %arg1, align 8
  %6 = load i64, i64* %arg2, align 8
  %7 = load i64, i64* %arg3, align 8
  %8 = call i64 asm sideeffect "syscall", "={rax},{rax},{rdi},{rsi},{rdx},~{rcx},~{r11},~{memory},~{dirflag},~{fpsr},~{flags}"(i64 %4, i64 %5, i64 %6, i64 %7)
  store i64 %8, i64* %result, align 8
  %9 = load i64, i64* %result, align 8
  ret i64 %9
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i64 @std.os.linux.x86_64.syscall0(i64 %0) unnamed_addr #1 {
Entry:
  %result = alloca i64, align 8
  %number = alloca i64, align 8
  store i64 %0, i64* %number, align 8
  %1 = load i64, i64* %number, align 8
  %2 = call i64 asm sideeffect "syscall", "={rax},{rax},~{rcx},~{r11},~{memory},~{dirflag},~{fpsr},~{flags}"(i64 %1)
  store i64 %2, i64* %result, align 8
  %3 = load i64, i64* %result, align 8
  ret i64 %3
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i64 @std.os.linux.x86_64.syscall4(i64 %0, i64 %1, i64 %2, i64 %3, i64 %4) unnamed_addr #1 {
Entry:
  %result = alloca i64, align 8
  %number = alloca i64, align 8
  %arg1 = alloca i64, align 8
  %arg2 = alloca i64, align 8
  %arg3 = alloca i64, align 8
  %arg4 = alloca i64, align 8
  store i64 %0, i64* %number, align 8
  store i64 %1, i64* %arg1, align 8
  store i64 %2, i64* %arg2, align 8
  store i64 %3, i64* %arg3, align 8
  store i64 %4, i64* %arg4, align 8
  %5 = load i64, i64* %number, align 8
  %6 = load i64, i64* %arg1, align 8
  %7 = load i64, i64* %arg2, align 8
  %8 = load i64, i64* %arg3, align 8
  %9 = load i64, i64* %arg4, align 8
  %10 = call i64 asm sideeffect "syscall", "={rax},{rax},{rdi},{rsi},{rdx},{r10},~{rcx},~{r11},~{memory},~{dirflag},~{fpsr},~{flags}"(i64 %5, i64 %6, i64 %7, i64 %8, i64 %9)
  store i64 %10, i64* %result, align 8
  %11 = load i64, i64* %result, align 8
  ret i64 %11
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i64 @std.os.linux.x86_64.syscall6(i64 %0, i64 %1, i64 %2, i64 %3, i64 %4, i64 %5, i64 %6) unnamed_addr #1 {
Entry:
  %result = alloca i64, align 8
  %number = alloca i64, align 8
  %arg1 = alloca i64, align 8
  %arg2 = alloca i64, align 8
  %arg3 = alloca i64, align 8
  %arg4 = alloca i64, align 8
  %arg5 = alloca i64, align 8
  %arg6 = alloca i64, align 8
  store i64 %0, i64* %number, align 8
  store i64 %1, i64* %arg1, align 8
  store i64 %2, i64* %arg2, align 8
  store i64 %3, i64* %arg3, align 8
  store i64 %4, i64* %arg4, align 8
  store i64 %5, i64* %arg5, align 8
  store i64 %6, i64* %arg6, align 8
  %7 = load i64, i64* %number, align 8
  %8 = load i64, i64* %arg1, align 8
  %9 = load i64, i64* %arg2, align 8
  %10 = load i64, i64* %arg3, align 8
  %11 = load i64, i64* %arg4, align 8
  %12 = load i64, i64* %arg5, align 8
  %13 = load i64, i64* %arg6, align 8
  %14 = call i64 asm sideeffect "syscall", "={rax},{rax},{rdi},{rsi},{rdx},{r10},{r8},{r9},~{rcx},~{r11},~{memory},~{dirflag},~{fpsr},~{flags}"(i64 %7, i64 %8, i64 %9, i64 %10, i64 %11, i64 %12, i64 %13)
  store i64 %14, i64* %result, align 8
  %15 = load i64, i64* %result, align 8
  ret i64 %15
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @"test \22\22"() unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %0 = alloca %"?Value", align 4
  call fastcc void @f(%"?Value"* sret(%"?Value") %0, %Expr* @54)
  store i16 0, i16* %result, align 2
  ret i16 0
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i64 @"std.hash_map.getAutoHashFn(usize,std.hash_map.AutoContext(usize)).hash"(i64 %0) unnamed_addr #1 {
Entry:
  %result = alloca i64, align 8
  %1 = alloca i64*, align 8
  %2 = alloca %"[]u8", align 8
  %3 = alloca %"[]u8", align 8
  %key = alloca i64, align 8
  store i64 %0, i64* %key, align 8
  store i64* %key, i64** %1, align 8
  %4 = call fastcc [8 x i8]* @std.mem.asBytes(i64* %key)
  %5 = getelementptr inbounds %"[]u8", %"[]u8"* %2, i32 0, i32 0
  %6 = getelementptr inbounds [8 x i8], [8 x i8]* %4, i64 0, i64 0
  store i8* %6, i8** %5, align 8
  %7 = getelementptr inbounds %"[]u8", %"[]u8"* %2, i32 0, i32 1
  store i64 8, i64* %7, align 8
  %8 = getelementptr inbounds %"[]u8", %"[]u8"* %3, i32 0, i32 0
  %9 = getelementptr inbounds [8 x i8], [8 x i8]* %4, i64 0, i64 0
  store i8* %9, i8** %8, align 8
  %10 = getelementptr inbounds %"[]u8", %"[]u8"* %3, i32 0, i32 1
  store i64 8, i64* %10, align 8
  %11 = call fastcc i64 @std.hash.wyhash.Wyhash.hash(i64 0, %"[]u8"* %3)
  store i64 %11, i64* %result, align 8
  %12 = load i64, i64* %result, align 8
  ret i64 %12
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i1 @"std.hash_map.getAutoEqlFn(usize,std.hash_map.AutoContext(usize)).eql"(i64 %0, i64 %1) unnamed_addr #1 {
Entry:
  %result = alloca i1, align 1
  %2 = alloca i64, align 8
  %3 = alloca i64, align 8
  %a = alloca i64, align 8
  %b = alloca i64, align 8
  store i64 %0, i64* %a, align 8
  store i64 %1, i64* %b, align 8
  %4 = load i64, i64* %a, align 8
  store i64 %4, i64* %2, align 8
  %5 = load i64, i64* %b, align 8
  store i64 %5, i64* %3, align 8
  %6 = call fastcc i1 @std.meta.eql(i64 %4, i64 %5)
  store i1 %6, i1* %result, align 1
  %7 = load i1, i1* %result, align 1
  ret i1 %7
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.heap.PageAllocator.alloc({ %"[]u8", i16 }* nonnull sret({ %"[]u8", i16 }) %0, i8* nonnull align 1 %1, i64 %2, i29 %3, i29 %4, i64 %5) unnamed_addr #1 {
Entry:
  %aligned_len = alloca i64, align 8
  %max_drop_len = alloca i29, align 4
  %alloc_len = alloca i64, align 8
  %hint = alloca i8*, align 8
  %6 = alloca { %"[]u8", i16 }, align 8
  %slice = alloca %"[]u8", align 8
  %7 = alloca i8*, align 8
  %8 = alloca i29, align 4
  %9 = alloca i8*, align 8
  %result_ptr = alloca i8*, align 8
  %drop_len = alloca i64, align 8
  %10 = alloca %"[]u8", align 8
  %aligned_buffer_len = alloca i64, align 8
  %11 = alloca %"[]u8", align 8
  %new_hint = alloca i8*, align 8
  %_ = alloca i8*, align 8
  %n = alloca i64, align 8
  %alignment = alloca i29, align 4
  %len_align = alloca i29, align 4
  %ra = alloca i64, align 8
  store i8* %1, i8** %_, align 8
  store i64 %2, i64* %n, align 8
  store i29 %3, i29* %alignment, align 4
  store i29 %4, i29* %len_align, align 4
  store i64 %5, i64* %ra, align 8
  %12 = load i64, i64* %n, align 8
  %13 = icmp ugt i64 %12, 0
  call fastcc void @std.debug.assert(i1 %13)
  %14 = load i64, i64* %n, align 8
  %15 = call fastcc i64 @std.mem.alignForward(i64 %14, i64 4096)
  store i64 %15, i64* %aligned_len, align 8
  %16 = load i29, i29* %alignment, align 4
  %17 = load i29, i29* %alignment, align 4
  %18 = call i29 @llvm.umin.i29(i29 %17, i29 4096)
  %19 = sub nuw i29 %16, %18
  store i29 %19, i29* %max_drop_len, align 4
  %20 = load i29, i29* %max_drop_len, align 4
  %21 = load i64, i64* %aligned_len, align 8
  %22 = load i64, i64* %n, align 8
  %23 = sub nuw i64 %21, %22
  %24 = zext i29 %20 to i64
  %25 = icmp ule i64 %24, %23
  br i1 %25, label %Then, label %Else

Then:                                             ; preds = %Entry
  %26 = load i64, i64* %aligned_len, align 8
  store i64 %26, i64* %alloc_len, align 8
  br label %EndIf

Else:                                             ; preds = %Entry
  %27 = load i64, i64* %aligned_len, align 8
  %28 = load i29, i29* %max_drop_len, align 4
  %29 = zext i29 %28 to i64
  %30 = add nuw i64 %27, %29
  %31 = call fastcc i64 @std.mem.alignForward(i64 %30, i64 4096)
  store i64 %31, i64* %alloc_len, align 8
  br label %EndIf

EndIf:                                            ; preds = %Else, %Then
  %32 = load i8*, i8** @next_mmap_addr_hint, align 8
  store i8* %32, i8** %hint, align 8
  %33 = load i8*, i8** %hint, align 8
  %34 = load i64, i64* %alloc_len, align 8
  call fastcc void @std.os.mmap({ %"[]u8", i16 }* sret({ %"[]u8", i16 }) %6, i8* %33, i64 %34, i32 3, i32 34, i32 -1, i64 0)
  %35 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %6, i32 0, i32 1
  %36 = load i16, i16* %35, align 2
  %37 = icmp ne i16 %36, 0
  br i1 %37, label %UnwrapErrError, label %UnwrapErrOk

UnwrapErrError:                                   ; preds = %EndIf
  %38 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %0, i32 0, i32 1
  store i16 16, i16* %38, align 2
  ret void

UnwrapErrOk:                                      ; preds = %EndIf
  %39 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %6, i32 0, i32 0
  %40 = bitcast %"[]u8"* %39 to i8*
  %41 = bitcast %"[]u8"* %slice to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %41, i8* align 8 %40, i64 16, i1 false)
  br label %UnwrapErrEnd

UnwrapErrEnd:                                     ; preds = %UnwrapErrOk
  %42 = getelementptr inbounds %"[]u8", %"[]u8"* %slice, i32 0, i32 0
  %43 = load i8*, i8** %42, align 8
  %44 = ptrtoint i8* %43 to i64
  %45 = call fastcc i1 @std.mem.isAligned(i64 %44, i64 4096)
  call fastcc void @std.debug.assert(i1 %45)
  %46 = getelementptr inbounds %"[]u8", %"[]u8"* %slice, i32 0, i32 0
  %47 = load i8*, i8** %46, align 8
  store i8* %47, i8** %7, align 8
  %48 = load i29, i29* %alignment, align 4
  store i29 %48, i29* %8, align 4
  %49 = call fastcc i8* @std.mem.alignPointer(i8* %47, i29 %48)
  store i8* %49, i8** %9, align 8
  %50 = icmp ne i8* %49, null
  br i1 %50, label %OptionalNonNull, label %OptionalNull

OptionalNull:                                     ; preds = %UnwrapErrEnd
  %51 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %0, i32 0, i32 1
  store i16 16, i16* %51, align 2
  ret void

OptionalNonNull:                                  ; preds = %UnwrapErrEnd
  %52 = load i8*, i8** %9, align 8
  store i8* %52, i8** %result_ptr, align 8
  br label %OptionalEnd

OptionalEnd:                                      ; preds = %OptionalNonNull
  %53 = load i8*, i8** %result_ptr, align 8
  %54 = ptrtoint i8* %53 to i64
  %55 = getelementptr inbounds %"[]u8", %"[]u8"* %slice, i32 0, i32 0
  %56 = load i8*, i8** %55, align 8
  %57 = ptrtoint i8* %56 to i64
  %58 = sub nuw i64 %54, %57
  store i64 %58, i64* %drop_len, align 8
  %59 = load i64, i64* %drop_len, align 8
  %60 = icmp ne i64 %59, 0
  br i1 %60, label %Then1, label %Else2

Then1:                                            ; preds = %OptionalEnd
  %61 = load i64, i64* %drop_len, align 8
  %62 = getelementptr inbounds %"[]u8", %"[]u8"* %slice, i32 0, i32 0
  %63 = load i8*, i8** %62, align 8
  %64 = getelementptr inbounds i8, i8* %63, i64 0
  %65 = sub nuw i64 %61, 0
  %66 = getelementptr inbounds %"[]u8", %"[]u8"* %10, i32 0, i32 0
  store i8* %64, i8** %66, align 8
  %67 = getelementptr inbounds %"[]u8", %"[]u8"* %10, i32 0, i32 1
  store i64 %65, i64* %67, align 8
  call fastcc void @std.os.munmap(%"[]u8"* %10)
  br label %EndIf3

Else2:                                            ; preds = %OptionalEnd
  br label %EndIf3

EndIf3:                                           ; preds = %Else2, %Then1
  %68 = load i64, i64* %alloc_len, align 8
  %69 = load i64, i64* %drop_len, align 8
  %70 = sub nuw i64 %68, %69
  store i64 %70, i64* %aligned_buffer_len, align 8
  %71 = load i64, i64* %aligned_buffer_len, align 8
  %72 = load i64, i64* %aligned_len, align 8
  %73 = icmp ugt i64 %71, %72
  br i1 %73, label %Then4, label %Else5

Then4:                                            ; preds = %EndIf3
  %74 = load i64, i64* %aligned_len, align 8
  %75 = load i64, i64* %aligned_buffer_len, align 8
  %76 = load i8*, i8** %result_ptr, align 8
  %77 = getelementptr inbounds i8, i8* %76, i64 %74
  %78 = sub nuw i64 %75, %74
  %79 = getelementptr inbounds %"[]u8", %"[]u8"* %11, i32 0, i32 0
  store i8* %77, i8** %79, align 8
  %80 = getelementptr inbounds %"[]u8", %"[]u8"* %11, i32 0, i32 1
  store i64 %78, i64* %80, align 8
  call fastcc void @std.os.munmap(%"[]u8"* %11)
  br label %EndIf6

Else5:                                            ; preds = %EndIf3
  br label %EndIf6

EndIf6:                                           ; preds = %Else5, %Then4
  %81 = load i8*, i8** %result_ptr, align 8
  %82 = load i64, i64* %aligned_len, align 8
  %83 = getelementptr inbounds i8, i8* %81, i64 %82
  store i8* %83, i8** %new_hint, align 8
  %84 = load i8*, i8** %hint, align 8
  %85 = load i8*, i8** %new_hint, align 8
  %86 = cmpxchg i8** @next_mmap_addr_hint, i8* %84, i8* %85 monotonic monotonic, align 8
  %87 = load i64, i64* %aligned_len, align 8
  %88 = load i64, i64* %n, align 8
  %89 = load i29, i29* %len_align, align 4
  %90 = call fastcc i64 @std.heap.alignPageAllocLen(i64 %87, i64 %88, i29 %89)
  %91 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %0, i32 0, i32 1
  store i16 0, i16* %91, align 2
  %92 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %0, i32 0, i32 0
  %93 = load i8*, i8** %result_ptr, align 8
  %94 = getelementptr inbounds i8, i8* %93, i64 0
  %95 = sub nuw i64 %90, 0
  %96 = getelementptr inbounds %"[]u8", %"[]u8"* %92, i32 0, i32 0
  store i8* %94, i8** %96, align 8
  %97 = getelementptr inbounds %"[]u8", %"[]u8"* %92, i32 0, i32 1
  store i64 %95, i64* %97, align 8
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.heap.PageAllocator.resize(%"?usize"* nonnull sret(%"?usize") %0, i8* nonnull align 1 %1, %"[]u8"* nonnull readonly align 8 %2, i29 %3, i64 %4, i29 %5, i64 %6) unnamed_addr #1 {
Entry:
  %new_size_aligned = alloca i64, align 8
  %buf_aligned_len = alloca i64, align 8
  %ptr = alloca i8*, align 8
  %7 = alloca %"[]u8", align 8
  %_ = alloca i8*, align 8
  %buf_align = alloca i29, align 4
  %new_size = alloca i64, align 8
  %len_align = alloca i29, align 4
  %return_address = alloca i64, align 8
  store i8* %1, i8** %_, align 8
  store i29 %3, i29* %buf_align, align 4
  store i64 %4, i64* %new_size, align 8
  store i29 %5, i29* %len_align, align 4
  store i64 %6, i64* %return_address, align 8
  %8 = load i64, i64* %new_size, align 8
  %9 = call fastcc i64 @std.mem.alignForward(i64 %8, i64 4096)
  store i64 %9, i64* %new_size_aligned, align 8
  %10 = getelementptr inbounds %"[]u8", %"[]u8"* %2, i32 0, i32 1
  %11 = load i64, i64* %10, align 8
  %12 = call fastcc i64 @std.mem.alignForward(i64 %11, i64 4096)
  store i64 %12, i64* %buf_aligned_len, align 8
  %13 = load i64, i64* %new_size_aligned, align 8
  %14 = load i64, i64* %buf_aligned_len, align 8
  %15 = icmp eq i64 %13, %14
  br i1 %15, label %Then, label %Else

Then:                                             ; preds = %Entry
  %16 = load i64, i64* %new_size_aligned, align 8
  %17 = load i64, i64* %new_size, align 8
  %18 = load i29, i29* %len_align, align 4
  %19 = call fastcc i64 @std.heap.alignPageAllocLen(i64 %16, i64 %17, i29 %18)
  %20 = getelementptr inbounds %"?usize", %"?usize"* %0, i32 0, i32 1
  store i1 true, i1* %20, align 1
  %21 = getelementptr inbounds %"?usize", %"?usize"* %0, i32 0, i32 0
  store i64 %19, i64* %21, align 8
  ret void

Else:                                             ; preds = %Entry
  br label %EndIf

EndIf:                                            ; preds = %Else
  %22 = load i64, i64* %new_size_aligned, align 8
  %23 = load i64, i64* %buf_aligned_len, align 8
  %24 = icmp ult i64 %22, %23
  br i1 %24, label %Then1, label %Else2

Then1:                                            ; preds = %EndIf
  %25 = getelementptr inbounds %"[]u8", %"[]u8"* %2, i32 0, i32 0
  %26 = load i8*, i8** %25, align 8
  %27 = load i64, i64* %new_size_aligned, align 8
  %28 = getelementptr inbounds i8, i8* %26, i64 %27
  store i8* %28, i8** %ptr, align 8
  %29 = load i64, i64* %buf_aligned_len, align 8
  %30 = load i64, i64* %new_size_aligned, align 8
  %31 = sub nuw i64 %29, %30
  %32 = load i8*, i8** %ptr, align 8
  %33 = getelementptr inbounds i8, i8* %32, i64 0
  %34 = sub nuw i64 %31, 0
  %35 = getelementptr inbounds %"[]u8", %"[]u8"* %7, i32 0, i32 0
  store i8* %33, i8** %35, align 8
  %36 = getelementptr inbounds %"[]u8", %"[]u8"* %7, i32 0, i32 1
  store i64 %34, i64* %36, align 8
  call fastcc void @std.os.munmap(%"[]u8"* %7)
  %37 = load i64, i64* %new_size_aligned, align 8
  %38 = load i64, i64* %new_size, align 8
  %39 = load i29, i29* %len_align, align 4
  %40 = call fastcc i64 @std.heap.alignPageAllocLen(i64 %37, i64 %38, i29 %39)
  %41 = getelementptr inbounds %"?usize", %"?usize"* %0, i32 0, i32 1
  store i1 true, i1* %41, align 1
  %42 = getelementptr inbounds %"?usize", %"?usize"* %0, i32 0, i32 0
  store i64 %40, i64* %42, align 8
  ret void

Else2:                                            ; preds = %EndIf
  br label %EndIf3

EndIf3:                                           ; preds = %Else2
  %43 = bitcast %"?usize"* %0 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %43, i8* align 8 bitcast (%"?usize"* @114 to i8*), i64 16, i1 false)
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.heap.PageAllocator.free(i8* nonnull align 1 %0, %"[]u8"* nonnull readonly align 8 %1, i29 %2, i64 %3) unnamed_addr #1 {
Entry:
  %buf_aligned_len = alloca i64, align 8
  %ptr = alloca i8*, align 8
  %4 = alloca %"[]u8", align 8
  %_ = alloca i8*, align 8
  %buf_align = alloca i29, align 4
  %return_address = alloca i64, align 8
  store i8* %0, i8** %_, align 8
  store i29 %2, i29* %buf_align, align 4
  store i64 %3, i64* %return_address, align 8
  %5 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 1
  %6 = load i64, i64* %5, align 8
  %7 = call fastcc i64 @std.mem.alignForward(i64 %6, i64 4096)
  store i64 %7, i64* %buf_aligned_len, align 8
  %8 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 0
  %9 = load i8*, i8** %8, align 8
  store i8* %9, i8** %ptr, align 8
  %10 = load i64, i64* %buf_aligned_len, align 8
  %11 = load i8*, i8** %ptr, align 8
  %12 = getelementptr inbounds i8, i8* %11, i64 0
  %13 = sub nuw i64 %10, 0
  %14 = getelementptr inbounds %"[]u8", %"[]u8"* %4, i32 0, i32 0
  store i8* %12, i8** %14, align 8
  %15 = getelementptr inbounds %"[]u8", %"[]u8"* %4, i32 0, i32 1
  store i64 %13, i64* %15, align 8
  call fastcc void @std.os.munmap(%"[]u8"* %4)
  ret void
}

; Function Attrs: minsize nobuiltin noreturn nounwind optsize
define internal fastcc void @std.os.exit(i8 %0) unnamed_addr #2 {
Entry:
  %status = alloca i8, align 1
  store i8 %0, i8* %status, align 1
  %1 = load i8, i8* %status, align 1
  %2 = zext i8 %1 to i32
  call fastcc void @std.os.linux.exit_group(i32 %2)
  unreachable
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.mem.Allocator.gen.allocImpl({ %"[]u8", i16 }* nonnull sret({ %"[]u8", i16 }) %0, i8* nonnull align 1 %1, i64 %2, i29 %3, i29 %4, i64 %5) unnamed_addr #1 {
Entry:
  %self = alloca %std.heap.FixedBufferAllocator*, align 8
  %ptr = alloca i8*, align 8
  %len = alloca i64, align 8
  %ptr_align = alloca i29, align 4
  %len_align = alloca i29, align 4
  %ret_addr = alloca i64, align 8
  store i8* %1, i8** %ptr, align 8
  store i64 %2, i64* %len, align 8
  store i29 %3, i29* %ptr_align, align 4
  store i29 %4, i29* %len_align, align 4
  store i64 %5, i64* %ret_addr, align 8
  %6 = load i8*, i8** %ptr, align 8
  %7 = bitcast i8* %6 to %std.heap.FixedBufferAllocator*
  store %std.heap.FixedBufferAllocator* %7, %std.heap.FixedBufferAllocator** %self, align 8
  %8 = load %std.heap.FixedBufferAllocator*, %std.heap.FixedBufferAllocator** %self, align 8
  %9 = load i64, i64* %len, align 8
  %10 = load i29, i29* %ptr_align, align 4
  %11 = load i29, i29* %len_align, align 4
  %12 = load i64, i64* %ret_addr, align 8
  call fastcc void @std.heap.FixedBufferAllocator.alloc({ %"[]u8", i16 }* sret({ %"[]u8", i16 }) %0, %std.heap.FixedBufferAllocator* %8, i64 %9, i29 %10, i29 %11, i64 %12) #10
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.mem.Allocator.gen.resizeImpl(%"?usize"* nonnull sret(%"?usize") %0, i8* nonnull align 1 %1, %"[]u8"* nonnull readonly align 8 %2, i29 %3, i64 %4, i29 %5, i64 %6) unnamed_addr #1 {
Entry:
  %self = alloca %std.heap.FixedBufferAllocator*, align 8
  %ptr = alloca i8*, align 8
  %buf_align = alloca i29, align 4
  %new_len = alloca i64, align 8
  %len_align = alloca i29, align 4
  %ret_addr = alloca i64, align 8
  store i8* %1, i8** %ptr, align 8
  store i29 %3, i29* %buf_align, align 4
  store i64 %4, i64* %new_len, align 8
  store i29 %5, i29* %len_align, align 4
  store i64 %6, i64* %ret_addr, align 8
  %7 = load i64, i64* %new_len, align 8
  %8 = icmp ne i64 %7, 0
  call fastcc void @std.debug.assert(i1 %8)
  %9 = load i8*, i8** %ptr, align 8
  %10 = bitcast i8* %9 to %std.heap.FixedBufferAllocator*
  store %std.heap.FixedBufferAllocator* %10, %std.heap.FixedBufferAllocator** %self, align 8
  %11 = load %std.heap.FixedBufferAllocator*, %std.heap.FixedBufferAllocator** %self, align 8
  %12 = load i29, i29* %buf_align, align 4
  %13 = load i64, i64* %new_len, align 8
  %14 = load i29, i29* %len_align, align 4
  %15 = load i64, i64* %ret_addr, align 8
  call fastcc void @std.heap.FixedBufferAllocator.resize(%"?usize"* sret(%"?usize") %0, %std.heap.FixedBufferAllocator* %11, %"[]u8"* %2, i29 %12, i64 %13, i29 %14, i64 %15) #10
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.mem.Allocator.gen.freeImpl(i8* nonnull align 1 %0, %"[]u8"* nonnull readonly align 8 %1, i29 %2, i64 %3) unnamed_addr #1 {
Entry:
  %self = alloca %std.heap.FixedBufferAllocator*, align 8
  %ptr = alloca i8*, align 8
  %buf_align = alloca i29, align 4
  %ret_addr = alloca i64, align 8
  store i8* %0, i8** %ptr, align 8
  store i29 %2, i29* %buf_align, align 4
  store i64 %3, i64* %ret_addr, align 8
  %4 = load i8*, i8** %ptr, align 8
  %5 = bitcast i8* %4 to %std.heap.FixedBufferAllocator*
  store %std.heap.FixedBufferAllocator* %5, %std.heap.FixedBufferAllocator** %self, align 8
  %6 = load %std.heap.FixedBufferAllocator*, %std.heap.FixedBufferAllocator** %self, align 8
  %7 = load i29, i29* %buf_align, align 4
  %8 = load i64, i64* %ret_addr, align 8
  call fastcc void @std.heap.FixedBufferAllocator.free(%std.heap.FixedBufferAllocator* %6, %"[]u8"* %1, i29 %7, i64 %8) #10
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal i64 @std.os.linux.init_vdso_clock_gettime(i32 %0, %std.os.linux.timespec* nonnull %1) unnamed_addr #1 {
Entry:
  %result = alloca i64, align 8
  %ptr = alloca i8*, align 8
  %fn_ptr = alloca i8*, align 8
  %f = alloca i64 (i32, %std.os.linux.timespec*)*, align 8
  %clk = alloca i32, align 4
  %ts = alloca %std.os.linux.timespec*, align 8
  store i32 %0, i32* %clk, align 4
  store %std.os.linux.timespec* %1, %std.os.linux.timespec** %ts, align 8
  %2 = call fastcc i64 @std.os.linux.vdso.lookup(%"[]u8"* @329, %"[]u8"* @330)
  %3 = inttoptr i64 %2 to i8*
  store i8* %3, i8** %ptr, align 8
  %4 = load i8*, i8** %ptr, align 8
  store atomic i8* %4, i8** @vdso_clock_gettime monotonic, align 8
  %5 = load i8*, i8** %ptr, align 8
  %6 = icmp ne i8* %5, null
  br i1 %6, label %OptionalThen, label %OptionalElse

OptionalThen:                                     ; preds = %Entry
  %7 = load i8*, i8** %ptr, align 8
  store i8* %7, i8** %fn_ptr, align 8
  %8 = load i8*, i8** %fn_ptr, align 8
  %9 = bitcast i8* %8 to i64 (i32, %std.os.linux.timespec*)*
  store i64 (i32, %std.os.linux.timespec*)* %9, i64 (i32, %std.os.linux.timespec*)** %f, align 8
  %10 = load i64 (i32, %std.os.linux.timespec*)*, i64 (i32, %std.os.linux.timespec*)** %f, align 8
  %11 = load i32, i32* %clk, align 4
  %12 = load %std.os.linux.timespec*, %std.os.linux.timespec** %ts, align 8
  %13 = call i64 %10(i32 %11, %std.os.linux.timespec* %12)
  store i64 %13, i64* %result, align 8
  %14 = load i64, i64* %result, align 8
  ret i64 %14

OptionalElse:                                     ; preds = %Entry
  br label %OptionalEndIf

OptionalEndIf:                                    ; preds = %OptionalElse
  store i64 -38, i64* %result, align 8
  %15 = load i64, i64* %result, align 8
  ret i64 %15
}

; Function Attrs: nofree nosync nounwind readnone willreturn
declare i8* @llvm.returnaddress(i32 immarg %0) #3

; Function Attrs: cold minsize nobuiltin noreturn nounwind optsize
define internal fastcc void @std.debug.panicImpl(%std.builtin.StackTrace* align 8 %0, %"?usize"* nonnull readonly align 8 %1, %"[]u8"* nonnull readonly align 8 %2) unnamed_addr #0 {
Entry:
  %3 = alloca %std.fs.file.File, align 4
  %stderr = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %current_thread_id = alloca i64, align 8
  %4 = alloca %"std.debug.struct:295:56", align 8
  %5 = alloca i16, align 2
  %6 = alloca %"std.debug.struct:297:40", align 8
  %7 = alloca i16, align 2
  %t = alloca %std.builtin.StackTrace*, align 8
  %event = alloca %std.Thread.StaticResetEvent, align 4
  %8 = alloca %std.fs.file.File, align 4
  %stderr8 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %9 = alloca i16, align 2
  %trace = alloca %std.builtin.StackTrace*, align 8
  store %std.builtin.StackTrace* %0, %std.builtin.StackTrace** %trace, align 8
  %10 = load i64, i64* @panic_stage, align 8
  switch i64 %10, label %SwitchElse [
    i64 0, label %SwitchProng
    i64 1, label %SwitchProng4
  ]

SwitchProng:                                      ; preds = %Entry
  store i64 1, i64* @panic_stage, align 8
  %11 = atomicrmw add i8* @panicking, i8 1 seq_cst, align 1
  call fastcc void @std.Thread.Mutex.lock(%std.Thread.Mutex* @panic_mutex)
  call fastcc void @std.io.getStdErr(%std.fs.file.File* sret(%std.fs.file.File) %3)
  call fastcc void @std.fs.file.File.writer(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* sret(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)") %stderr, %std.fs.file.File* %3)
  %12 = call fastcc i64 @std.Thread.getCurrentId()
  store i64 %12, i64* %current_thread_id, align 8
  %13 = load i64, i64* %current_thread_id, align 8
  %14 = getelementptr inbounds %"std.debug.struct:295:56", %"std.debug.struct:295:56"* %4, i32 0, i32 0
  store i64 %13, i64* %14, align 8
  %15 = call fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).print"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %stderr, %"std.debug.struct:295:56"* %4)
  store i16 %15, i16* %5, align 2
  %16 = icmp ne i16 %15, 0
  br i1 %16, label %UnwrapErrError, label %UnwrapErrOk

UnwrapErrError:                                   ; preds = %SwitchProng
  call fastcc void @std.os.abort()
  unreachable

UnwrapErrOk:                                      ; preds = %SwitchProng
  br label %UnwrapErrEnd

UnwrapErrEnd:                                     ; preds = %UnwrapErrOk
  %17 = getelementptr inbounds %"std.debug.struct:297:40", %"std.debug.struct:297:40"* %6, i32 0, i32 0
  %18 = bitcast %"[]u8"* %2 to i8*
  %19 = bitcast %"[]u8"* %17 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %19, i8* align 8 %18, i64 16, i1 false)
  %20 = call fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).print.20"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %stderr, %"std.debug.struct:297:40"* %6)
  store i16 %20, i16* %7, align 2
  %21 = icmp ne i16 %20, 0
  br i1 %21, label %UnwrapErrError1, label %UnwrapErrOk2

UnwrapErrError1:                                  ; preds = %UnwrapErrEnd
  call fastcc void @std.os.abort()
  unreachable

UnwrapErrOk2:                                     ; preds = %UnwrapErrEnd
  br label %UnwrapErrEnd3

UnwrapErrEnd3:                                    ; preds = %UnwrapErrOk2
  %22 = load %std.builtin.StackTrace*, %std.builtin.StackTrace** %trace, align 8
  %23 = icmp ne %std.builtin.StackTrace* %22, null
  br i1 %23, label %OptionalThen, label %OptionalElse

OptionalThen:                                     ; preds = %UnwrapErrEnd3
  %24 = load %std.builtin.StackTrace*, %std.builtin.StackTrace** %trace, align 8
  store %std.builtin.StackTrace* %24, %std.builtin.StackTrace** %t, align 8
  %25 = load %std.builtin.StackTrace*, %std.builtin.StackTrace** %t, align 8
  call fastcc void @std.debug.dumpStackTrace(%std.builtin.StackTrace* %25)
  br label %OptionalEndIf

OptionalElse:                                     ; preds = %UnwrapErrEnd3
  br label %OptionalEndIf

OptionalEndIf:                                    ; preds = %OptionalElse, %OptionalThen
  call fastcc void @std.debug.dumpCurrentStackTrace(%"?usize"* %1)
  call fastcc void @std.Thread.Mutex.unlock(%std.Thread.Mutex* @panic_mutex)
  %26 = atomicrmw sub i8* @panicking, i8 1 seq_cst, align 1
  %27 = icmp ne i8 %26, 1
  br i1 %27, label %Then, label %Else

Then:                                             ; preds = %OptionalEndIf
  %28 = bitcast %std.Thread.StaticResetEvent* %event to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %28, i8* align 4 bitcast (%std.Thread.StaticResetEvent* @56 to i8*), i64 4, i1 false)
  call fastcc void @std.Thread.StaticResetEvent.wait(%std.Thread.StaticResetEvent* %event)
  unreachable

Else:                                             ; preds = %OptionalEndIf
  br label %EndIf

SwitchProng4:                                     ; preds = %Entry
  store i64 2, i64* @panic_stage, align 8
  call fastcc void @std.io.getStdErr(%std.fs.file.File* sret(%std.fs.file.File) %8)
  call fastcc void @std.fs.file.File.writer(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* sret(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)") %stderr8, %std.fs.file.File* %8)
  %29 = call fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).print.21"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %stderr8)
  store i16 %29, i16* %9, align 2
  %30 = icmp ne i16 %29, 0
  br i1 %30, label %UnwrapErrError5, label %UnwrapErrOk6

UnwrapErrError5:                                  ; preds = %SwitchProng4
  call fastcc void @std.os.abort()
  unreachable

UnwrapErrOk6:                                     ; preds = %SwitchProng4
  br label %UnwrapErrEnd7

SwitchElse:                                       ; preds = %Entry
  br label %SwitchEnd

EndIf:                                            ; preds = %Else
  br label %SwitchEnd

UnwrapErrEnd7:                                    ; preds = %UnwrapErrOk6
  br label %SwitchEnd

SwitchEnd:                                        ; preds = %UnwrapErrEnd7, %EndIf, %SwitchElse
  call fastcc void @std.os.abort()
  unreachable
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @f(%"?Value"* nonnull sret(%"?Value") %0, %Expr* nonnull readonly align 4 %1) unnamed_addr #1 {
Entry:
  %val = alloca i32, align 4
  %a = alloca i32, align 4
  %2 = alloca %"?Value", align 4
  %3 = alloca %"?Value", align 4
  store i32 0, i32* %val, align 4
  %4 = getelementptr inbounds %Expr, %Expr* %1, i32 0, i32 1
  %5 = load i1, i1* %4, align 1
  switch i1 %5, label %SwitchElse [
    i1 false, label %SwitchProng
  ]

SwitchElse:                                       ; preds = %Entry
  %6 = getelementptr inbounds %"?Value", %"?Value"* %0, i32 0, i32 1
  store i1 true, i1* %6, align 1
  %7 = getelementptr inbounds %"?Value", %"?Value"* %0, i32 0, i32 0
  %8 = getelementptr inbounds %Value, %Value* %7, i32 0, i32 1
  store i1 true, i1* %8, align 1
  %9 = bitcast %Value* %7 to i8*
  %10 = bitcast %Value* %7 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %10, i8* align 4 %9, i64 8, i1 false)
  %11 = getelementptr inbounds %"?Value", %"?Value"* %2, i32 0, i32 0
  %12 = bitcast %Value* %7 to i8*
  %13 = bitcast %Value* %11 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %13, i8* align 4 %12, i64 8, i1 false)
  %14 = getelementptr inbounds %"?Value", %"?Value"* %2, i32 0, i32 1
  store i1 true, i1* %14, align 1
  br label %SwitchEnd

SwitchProng:                                      ; preds = %Entry
  %15 = getelementptr inbounds %Expr, %Expr* %1, i32 0, i32 0
  %16 = load i32, i32* %15, align 4
  store i32 %16, i32* %a, align 4
  %17 = load i32, i32* %a, align 4
  %18 = icmp eq i32 %17, 0
  %19 = getelementptr inbounds %"?Value", %"?Value"* %0, i32 0, i32 1
  store i1 true, i1* %19, align 1
  %20 = getelementptr inbounds %"?Value", %"?Value"* %0, i32 0, i32 0
  br i1 %18, label %Then, label %Else

Else:                                             ; preds = %SwitchProng
  %21 = load i32, i32* %val, align 4
  %22 = icmp eq i32 %21, 0
  br i1 %22, label %Then1, label %Else2

Then:                                             ; preds = %SwitchProng
  %23 = getelementptr inbounds %"?Value", %"?Value"* %0, i32 0, i32 1
  store i1 true, i1* %23, align 1
  %24 = getelementptr inbounds %"?Value", %"?Value"* %0, i32 0, i32 0
  %25 = getelementptr inbounds %Value, %Value* %24, i32 0, i32 1
  store i1 false, i1* %25, align 1
  %26 = getelementptr inbounds %Value, %Value* %24, i32 0, i32 0
  store i32 0, i32* %26, align 4
  %27 = bitcast %Value* %24 to i8*
  %28 = bitcast %Value* %24 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %28, i8* align 4 %27, i64 8, i1 false)
  br label %EndIf3

Then1:                                            ; preds = %Else
  %29 = getelementptr inbounds %"?Value", %"?Value"* %0, i32 0, i32 1
  store i1 true, i1* %29, align 1
  %30 = getelementptr inbounds %"?Value", %"?Value"* %0, i32 0, i32 0
  %31 = getelementptr inbounds %Value, %Value* %30, i32 0, i32 1
  store i1 true, i1* %31, align 1
  %32 = bitcast %Value* %30 to i8*
  %33 = bitcast %Value* %30 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %33, i8* align 4 %32, i64 8, i1 false)
  br label %EndIf

Else2:                                            ; preds = %Else
  %34 = getelementptr inbounds %Value, %Value* %30, i32 0, i32 1
  store i1 true, i1* %34, align 1
  %35 = bitcast %Value* %30 to i8*
  %36 = bitcast %Value* %30 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %36, i8* align 4 %35, i64 8, i1 false)
  br label %EndIf

EndIf:                                            ; preds = %Else2, %Then1
  %37 = phi %Value* [ %30, %Then1 ], [ %30, %Else2 ]
  %38 = bitcast %Value* %37 to i8*
  %39 = bitcast %Value* %30 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %39, i8* align 4 %38, i64 8, i1 false)
  br label %EndIf3

EndIf3:                                           ; preds = %EndIf, %Then
  %40 = phi %Value* [ %24, %Then ], [ %37, %EndIf ]
  %41 = getelementptr inbounds %"?Value", %"?Value"* %0, i32 0, i32 1
  store i1 true, i1* %41, align 1
  %42 = getelementptr inbounds %"?Value", %"?Value"* %0, i32 0, i32 0
  %43 = bitcast %Value* %40 to i8*
  %44 = bitcast %Value* %42 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %44, i8* align 4 %43, i64 8, i1 false)
  %45 = getelementptr inbounds %"?Value", %"?Value"* %3, i32 0, i32 0
  %46 = bitcast %Value* %40 to i8*
  %47 = bitcast %Value* %45 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %47, i8* align 4 %46, i64 8, i1 false)
  %48 = getelementptr inbounds %"?Value", %"?Value"* %3, i32 0, i32 1
  store i1 true, i1* %48, align 1
  br label %SwitchEnd

SwitchEnd:                                        ; preds = %EndIf3, %SwitchElse
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.target.Set.empty_workaround(%std.target.Set* nonnull sret(%std.target.Set) %0) unnamed_addr #1 {
Entry:
  %1 = getelementptr inbounds %std.target.Set, %std.target.Set* %0, i32 0, i32 0
  %2 = bitcast [5 x i64]* %1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %2, i8* align 8 bitcast ([5 x i64]* @55 to i8*), i64 40, i1 false)
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.target.Set.addFeature(%std.target.Set* nonnull align 8 %0, i9 %1) unnamed_addr #1 {
Entry:
  %usize_index = alloca i9, align 2
  %bit_index = alloca i6, align 1
  %set = alloca %std.target.Set*, align 8
  %arch_feature_index = alloca i9, align 2
  store %std.target.Set* %0, %std.target.Set** %set, align 8
  store i9 %1, i9* %arch_feature_index, align 2
  %2 = load i9, i9* %arch_feature_index, align 2
  %3 = udiv i9 %2, 64
  store i9 %3, i9* %usize_index, align 2
  %4 = load i9, i9* %arch_feature_index, align 2
  %5 = urem i9 %4, 64
  %6 = trunc i9 %5 to i6
  store i6 %6, i6* %bit_index, align 1
  %7 = load %std.target.Set*, %std.target.Set** %set, align 8
  %8 = getelementptr inbounds %std.target.Set, %std.target.Set* %7, i32 0, i32 0
  %9 = load i9, i9* %usize_index, align 2
  %10 = zext i9 %9 to i64
  %11 = getelementptr inbounds [5 x i64], [5 x i64]* %8, i64 0, i64 %10
  %12 = load i64, i64* %11, align 8
  %13 = load i6, i6* %bit_index, align 1
  %14 = zext i6 %13 to i64
  %15 = shl i64 1, %14
  %16 = or i64 %12, %15
  store i64 %16, i64* %11, align 8
  ret void
}

; Function Attrs: argmemonly nofree nounwind willreturn
declare void @llvm.memcpy.p0i8.p0i8.i64(i8* noalias nocapture writeonly %0, i8* noalias nocapture readonly %1, i64 %2, i1 immarg %3) #4

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i1 @std.target.Arch.isWasm(i6 %0) unnamed_addr #1 {
Entry:
  %result = alloca i1, align 1
  %arch = alloca i6, align 1
  store i6 %0, i6* %arch, align 1
  %1 = load i6, i6* %arch, align 1
  switch i6 %1, label %SwitchElse [
    i6 -15, label %SwitchProng
    i6 -14, label %SwitchProng
  ]

SwitchElse:                                       ; preds = %Entry
  store i1 false, i1* %result, align 1
  br label %SwitchEnd

SwitchProng:                                      ; preds = %Entry, %Entry
  store i1 true, i1* %result, align 1
  br label %SwitchEnd

SwitchEnd:                                        ; preds = %SwitchProng, %SwitchElse
  %2 = load i1, i1* %result, align 1
  ret i1 %2
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i1 @std.target.Arch.isMIPS(i6 %0) unnamed_addr #1 {
Entry:
  %result = alloca i1, align 1
  %arch = alloca i6, align 1
  store i6 %0, i6* %arch, align 1
  %1 = load i6, i6* %arch, align 1
  switch i6 %1, label %SwitchElse [
    i6 12, label %SwitchProng
    i6 13, label %SwitchProng
    i6 14, label %SwitchProng
    i6 15, label %SwitchProng
  ]

SwitchElse:                                       ; preds = %Entry
  store i1 false, i1* %result, align 1
  br label %SwitchEnd

SwitchProng:                                      ; preds = %Entry, %Entry, %Entry, %Entry
  store i1 true, i1* %result, align 1
  br label %SwitchEnd

SwitchEnd:                                        ; preds = %SwitchProng, %SwitchElse
  %2 = load i1, i1* %result, align 1
  ret i1 %2
}

; Function Attrs: minsize naked nobuiltin noreturn nounwind optsize
define void @_start() #5 {
Entry:
  %0 = call i64* asm sideeffect " xor %rbp, %rbp", "={rsp},~{dirflag},~{fpsr},~{flags}"()
  store i64* %0, i64** @argc_argv_ptr, align 8
  call fastcc void @std.start.posixCallMainAndExit() #11
  unreachable
}

; Function Attrs: minsize nobuiltin noinline noreturn nounwind optsize alignstack(16)
define internal fastcc void @std.start.posixCallMainAndExit() unnamed_addr #6 {
Entry:
  %argc = alloca i64, align 8
  %argv = alloca i8**, align 8
  %envp_optional = alloca i8**, align 8
  %envp_count = alloca i64, align 8
  %_ = alloca i8*, align 8
  %0 = alloca i8**, align 8
  %envp = alloca %"[][*:0]u8", align 8
  %auxv = alloca %std.elf.Elf64_auxv_t*, align 8
  %at_hwcap = alloca i64, align 8
  %i = alloca i64, align 8
  %at_phdr = alloca i64, align 8
  %at_phnum = alloca i64, align 8
  %1 = alloca %std.elf.Elf64_Phdr*, align 8
  %phdrs = alloca %"[]std.elf.Elf64_Phdr", align 8
  %2 = load i64*, i64** @argc_argv_ptr, align 8
  %3 = getelementptr inbounds i64, i64* %2, i64 0
  %4 = load i64, i64* %3, align 8
  store i64 %4, i64* %argc, align 8
  %5 = load i64*, i64** @argc_argv_ptr, align 8
  %6 = getelementptr inbounds i64, i64* %5, i64 1
  %7 = bitcast i64* %6 to i8**
  store i8** %7, i8*** %argv, align 8
  %8 = load i8**, i8*** %argv, align 8
  %9 = load i64, i64* %argc, align 8
  %10 = getelementptr inbounds i8*, i8** %8, i64 %9
  %11 = getelementptr inbounds i8*, i8** %10, i64 1
  store i8** %11, i8*** %envp_optional, align 8
  store i64 0, i64* %envp_count, align 8
  br label %WhileCond

WhileCond:                                        ; preds = %WhileBody, %Entry
  %12 = load i64, i64* %envp_count, align 8
  %13 = load i8**, i8*** %envp_optional, align 8
  %14 = getelementptr inbounds i8*, i8** %13, i64 %12
  %15 = load i8*, i8** %14, align 8
  %16 = icmp ne i8* %15, null
  br i1 %16, label %WhileBody, label %WhileEnd

WhileBody:                                        ; preds = %WhileCond
  %17 = load i8*, i8** %14, align 8
  store i8* %17, i8** %_, align 8
  %18 = load i64, i64* %envp_count, align 8
  %19 = add nuw i64 %18, 1
  store i64 %19, i64* %envp_count, align 8
  br label %WhileCond

WhileEnd:                                         ; preds = %WhileCond
  %20 = load i8**, i8*** %envp_optional, align 8
  store i8** %20, i8*** %0, align 8
  %21 = load i64, i64* %envp_count, align 8
  %22 = load i8**, i8*** %0, align 8
  %23 = getelementptr inbounds i8*, i8** %22, i64 0
  %24 = sub nuw i64 %21, 0
  %25 = getelementptr inbounds %"[][*:0]u8", %"[][*:0]u8"* %envp, i32 0, i32 0
  store i8** %23, i8*** %25, align 8
  %26 = getelementptr inbounds %"[][*:0]u8", %"[][*:0]u8"* %envp, i32 0, i32 1
  store i64 %24, i64* %26, align 8
  %27 = getelementptr inbounds %"[][*:0]u8", %"[][*:0]u8"* %envp, i32 0, i32 0
  %28 = load i8**, i8*** %27, align 8
  %29 = load i64, i64* %envp_count, align 8
  %30 = getelementptr inbounds i8*, i8** %28, i64 %29
  %31 = getelementptr inbounds i8*, i8** %30, i64 1
  %32 = bitcast i8** %31 to %std.elf.Elf64_auxv_t*
  store %std.elf.Elf64_auxv_t* %32, %std.elf.Elf64_auxv_t** %auxv, align 8
  %33 = load %std.elf.Elf64_auxv_t*, %std.elf.Elf64_auxv_t** %auxv, align 8
  store %std.elf.Elf64_auxv_t* %33, %std.elf.Elf64_auxv_t** @elf_aux_maybe, align 8
  store i64 0, i64* %at_hwcap, align 8
  store i64 0, i64* %i, align 8
  store i64 0, i64* %at_phdr, align 8
  store i64 0, i64* %at_phnum, align 8
  br label %WhileCond1

WhileCond1:                                       ; preds = %WhileContinue, %WhileEnd
  %34 = load i64, i64* %i, align 8
  %35 = load %std.elf.Elf64_auxv_t*, %std.elf.Elf64_auxv_t** %auxv, align 8
  %36 = getelementptr inbounds %std.elf.Elf64_auxv_t, %std.elf.Elf64_auxv_t* %35, i64 %34
  %37 = getelementptr inbounds %std.elf.Elf64_auxv_t, %std.elf.Elf64_auxv_t* %36, i32 0, i32 0
  %38 = load i64, i64* %37, align 8
  %39 = icmp ne i64 %38, 0
  br i1 %39, label %WhileBody2, label %WhileEnd5

WhileBody2:                                       ; preds = %WhileCond1
  %40 = load i64, i64* %i, align 8
  %41 = load %std.elf.Elf64_auxv_t*, %std.elf.Elf64_auxv_t** %auxv, align 8
  %42 = getelementptr inbounds %std.elf.Elf64_auxv_t, %std.elf.Elf64_auxv_t* %41, i64 %40
  %43 = getelementptr inbounds %std.elf.Elf64_auxv_t, %std.elf.Elf64_auxv_t* %42, i32 0, i32 0
  %44 = load i64, i64* %43, align 8
  switch i64 %44, label %SwitchElse [
    i64 5, label %SwitchProng
    i64 3, label %SwitchProng3
    i64 16, label %SwitchProng4
  ]

SwitchElse:                                       ; preds = %WhileBody2
  br label %WhileContinue

SwitchProng:                                      ; preds = %WhileBody2
  %45 = load i64, i64* %i, align 8
  %46 = load %std.elf.Elf64_auxv_t*, %std.elf.Elf64_auxv_t** %auxv, align 8
  %47 = getelementptr inbounds %std.elf.Elf64_auxv_t, %std.elf.Elf64_auxv_t* %46, i64 %45
  %48 = getelementptr inbounds %std.elf.Elf64_auxv_t, %std.elf.Elf64_auxv_t* %47, i32 0, i32 1
  %49 = getelementptr inbounds %"std.elf.union:790:11", %"std.elf.union:790:11"* %48, i32 0, i32 0
  %50 = load i64, i64* %49, align 8
  store i64 %50, i64* %at_phnum, align 8
  br label %SwitchEnd

SwitchProng3:                                     ; preds = %WhileBody2
  %51 = load i64, i64* %i, align 8
  %52 = load %std.elf.Elf64_auxv_t*, %std.elf.Elf64_auxv_t** %auxv, align 8
  %53 = getelementptr inbounds %std.elf.Elf64_auxv_t, %std.elf.Elf64_auxv_t* %52, i64 %51
  %54 = getelementptr inbounds %std.elf.Elf64_auxv_t, %std.elf.Elf64_auxv_t* %53, i32 0, i32 1
  %55 = getelementptr inbounds %"std.elf.union:790:11", %"std.elf.union:790:11"* %54, i32 0, i32 0
  %56 = load i64, i64* %55, align 8
  store i64 %56, i64* %at_phdr, align 8
  br label %SwitchEnd

SwitchProng4:                                     ; preds = %WhileBody2
  %57 = load i64, i64* %i, align 8
  %58 = load %std.elf.Elf64_auxv_t*, %std.elf.Elf64_auxv_t** %auxv, align 8
  %59 = getelementptr inbounds %std.elf.Elf64_auxv_t, %std.elf.Elf64_auxv_t* %58, i64 %57
  %60 = getelementptr inbounds %std.elf.Elf64_auxv_t, %std.elf.Elf64_auxv_t* %59, i32 0, i32 1
  %61 = getelementptr inbounds %"std.elf.union:790:11", %"std.elf.union:790:11"* %60, i32 0, i32 0
  %62 = load i64, i64* %61, align 8
  store i64 %62, i64* %at_hwcap, align 8
  br label %SwitchEnd

SwitchEnd:                                        ; preds = %SwitchProng4, %SwitchProng3, %SwitchProng
  br label %WhileContinue

WhileContinue:                                    ; preds = %SwitchEnd, %SwitchElse
  %63 = load i64, i64* %i, align 8
  %64 = add nuw i64 %63, 1
  store i64 %64, i64* %i, align 8
  br label %WhileCond1

WhileEnd5:                                        ; preds = %WhileCond1
  %65 = load i64, i64* %at_phdr, align 8
  %66 = inttoptr i64 %65 to %std.elf.Elf64_Phdr*
  store %std.elf.Elf64_Phdr* %66, %std.elf.Elf64_Phdr** %1, align 8
  %67 = load i64, i64* %at_phnum, align 8
  %68 = load %std.elf.Elf64_Phdr*, %std.elf.Elf64_Phdr** %1, align 8
  %69 = getelementptr inbounds %std.elf.Elf64_Phdr, %std.elf.Elf64_Phdr* %68, i64 0
  %70 = sub nuw i64 %67, 0
  %71 = getelementptr inbounds %"[]std.elf.Elf64_Phdr", %"[]std.elf.Elf64_Phdr"* %phdrs, i32 0, i32 0
  store %std.elf.Elf64_Phdr* %69, %std.elf.Elf64_Phdr** %71, align 8
  %72 = getelementptr inbounds %"[]std.elf.Elf64_Phdr", %"[]std.elf.Elf64_Phdr"* %phdrs, i32 0, i32 1
  store i64 %70, i64* %72, align 8
  %73 = bitcast %"[]std.elf.Elf64_Phdr"* %phdrs to i8*
  %74 = bitcast %"[]std.elf.Elf64_Phdr"* %phdrs to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %74, i8* align 8 %73, i64 16, i1 false)
  br label %BlockEnd

BlockEnd:                                         ; preds = %WhileEnd5
  call fastcc void @std.os.linux.tls.initStaticTLS(%"[]std.elf.Elf64_Phdr"* %phdrs)
  call fastcc void @std.start.expandStackSize(%"[]std.elf.Elf64_Phdr"* %phdrs)
  %75 = load i64, i64* %argc, align 8
  %76 = load i8**, i8*** %argv, align 8
  %77 = call fastcc i8 @std.start.callMainWithArgs(i64 %75, i8** %76, %"[][*:0]u8"* %envp) #10
  call fastcc void @std.os.exit(i8 %77)
  unreachable
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.Thread.Mutex.lock(%std.Thread.Mutex* nonnull align 4 %0) unnamed_addr #1 {
Entry:
  %m = alloca %std.Thread.Mutex*, align 8
  store %std.Thread.Mutex* %0, %std.Thread.Mutex** %m, align 8
  %1 = load %std.Thread.Mutex*, %std.Thread.Mutex** %m, align 8
  %2 = getelementptr inbounds %std.Thread.Mutex, %std.Thread.Mutex* %1, i32 0, i32 0
  call fastcc void @std.Thread.Mutex.AtomicMutex.lock(%std.Thread.Mutex.AtomicMutex* %2)
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.io.getStdErr(%std.fs.file.File* nonnull sret(%std.fs.file.File) %0) unnamed_addr #1 {
Entry:
  %1 = getelementptr inbounds %std.fs.file.File, %std.fs.file.File* %0, i32 0, i32 0
  %2 = call fastcc i32 @std.io.getStdErrHandle()
  store i32 %2, i32* %1, align 4
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.fs.file.File.writer(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull sret(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)") %0, %std.fs.file.File* nonnull readonly align 4 %1) unnamed_addr #1 {
Entry:
  %2 = getelementptr inbounds %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0, i32 0, i32 0
  %3 = bitcast %std.fs.file.File* %1 to i8*
  %4 = bitcast %std.fs.file.File* %2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %4, i8* align 4 %3, i64 4, i1 false)
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i64 @std.Thread.getCurrentId() unnamed_addr #1 {
Entry:
  %result = alloca i64, align 8
  %0 = call fastcc i64 @std.Thread.LinuxThreadImpl.getCurrentId()
  store i64 %0, i64* %result, align 8
  %1 = load i64, i64* %result, align 8
  ret i64 %1
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).print"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %0, %"std.debug.struct:295:56"* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %2 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %3 = alloca %"std.debug.struct:295:56", align 8
  %4 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0 to i8*
  %5 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %5, i8* align 4 %4, i64 4, i1 false)
  %6 = bitcast %"std.debug.struct:295:56"* %1 to i8*
  %7 = bitcast %"std.debug.struct:295:56"* %3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %7, i8* align 8 %6, i64 8, i1 false)
  %8 = call fastcc i16 @std.fmt.format(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0, %"std.debug.struct:295:56"* %1)
  store i16 %8, i16* %result, align 2
  %9 = load i16, i16* %result, align 2
  ret i16 %9
}

; Function Attrs: cold minsize nobuiltin noreturn nounwind optsize
define internal fastcc void @std.os.abort() unnamed_addr #0 {
Entry:
  %0 = alloca i16, align 2
  %1 = alloca i16, align 2
  %2 = call fastcc i16 @std.os.raise(i8 6)
  store i16 %2, i16* %0, align 2
  %3 = icmp ne i16 %2, 0
  br i1 %3, label %UnwrapErrError, label %UnwrapErrOk

UnwrapErrError:                                   ; preds = %Entry
  br label %UnwrapErrEnd

UnwrapErrOk:                                      ; preds = %Entry
  br label %UnwrapErrEnd

UnwrapErrEnd:                                     ; preds = %UnwrapErrOk, %UnwrapErrError
  %4 = call fastcc i16 @std.os.raise(i8 9)
  store i16 %4, i16* %1, align 2
  %5 = icmp ne i16 %4, 0
  br i1 %5, label %UnwrapErrError1, label %UnwrapErrOk2

UnwrapErrError1:                                  ; preds = %UnwrapErrEnd
  br label %UnwrapErrEnd3

UnwrapErrOk2:                                     ; preds = %UnwrapErrEnd
  br label %UnwrapErrEnd3

UnwrapErrEnd3:                                    ; preds = %UnwrapErrOk2, %UnwrapErrError1
  call fastcc void @std.os.exit(i8 127)
  unreachable
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).print.20"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %0, %"std.debug.struct:297:40"* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %2 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %3 = alloca %"std.debug.struct:297:40", align 8
  %4 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0 to i8*
  %5 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %5, i8* align 4 %4, i64 4, i1 false)
  %6 = bitcast %"std.debug.struct:297:40"* %1 to i8*
  %7 = bitcast %"std.debug.struct:297:40"* %3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %7, i8* align 8 %6, i64 16, i1 false)
  %8 = call fastcc i16 @std.fmt.format.22(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0, %"std.debug.struct:297:40"* %1)
  store i16 %8, i16* %result, align 2
  %9 = load i16, i16* %result, align 2
  ret i16 %9
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.debug.dumpStackTrace(%std.builtin.StackTrace* nonnull readonly align 8 %0) unnamed_addr #1 {
Entry:
  %1 = alloca %std.fs.file.File, align 4
  %stderr = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %2 = alloca i16, align 2
  call fastcc void @std.io.getStdErr(%std.fs.file.File* sret(%std.fs.file.File) %1)
  call fastcc void @std.fs.file.File.writer(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* sret(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)") %stderr, %std.fs.file.File* %1)
  %3 = call fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).print.23"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %stderr)
  store i16 %3, i16* %2, align 2
  %4 = icmp ne i16 %3, 0
  br i1 %4, label %UnwrapErrError, label %UnwrapErrOk

UnwrapErrError:                                   ; preds = %Entry
  ret void

UnwrapErrOk:                                      ; preds = %Entry
  br label %UnwrapErrEnd

UnwrapErrEnd:                                     ; preds = %UnwrapErrOk
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.debug.dumpCurrentStackTrace(%"?usize"* nonnull readonly align 8 %0) unnamed_addr #1 {
Entry:
  %1 = alloca %std.fs.file.File, align 4
  %stderr = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %2 = alloca i16, align 2
  call fastcc void @std.io.getStdErr(%std.fs.file.File* sret(%std.fs.file.File) %1)
  call fastcc void @std.fs.file.File.writer(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* sret(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)") %stderr, %std.fs.file.File* %1)
  %3 = call fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).print.24"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %stderr)
  store i16 %3, i16* %2, align 2
  %4 = icmp ne i16 %3, 0
  br i1 %4, label %UnwrapErrError, label %UnwrapErrOk

UnwrapErrError:                                   ; preds = %Entry
  ret void

UnwrapErrOk:                                      ; preds = %Entry
  br label %UnwrapErrEnd

UnwrapErrEnd:                                     ; preds = %UnwrapErrOk
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.Thread.Mutex.unlock(%std.Thread.Mutex* nonnull align 4 %0) unnamed_addr #1 {
Entry:
  %m = alloca %std.Thread.Mutex*, align 8
  store %std.Thread.Mutex* %0, %std.Thread.Mutex** %m, align 8
  %1 = load %std.Thread.Mutex*, %std.Thread.Mutex** %m, align 8
  %2 = getelementptr inbounds %std.Thread.Mutex, %std.Thread.Mutex* %1, i32 0, i32 0
  call fastcc void @std.Thread.Mutex.AtomicMutex.unlock(%std.Thread.Mutex.AtomicMutex* %2)
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.Thread.StaticResetEvent.wait(%std.Thread.StaticResetEvent* nonnull align 4 %0) unnamed_addr #1 {
Entry:
  %ev = alloca %std.Thread.StaticResetEvent*, align 8
  store %std.Thread.StaticResetEvent* %0, %std.Thread.StaticResetEvent** %ev, align 8
  %1 = load %std.Thread.StaticResetEvent*, %std.Thread.StaticResetEvent** %ev, align 8
  %2 = getelementptr inbounds %std.Thread.StaticResetEvent, %std.Thread.StaticResetEvent* %1, i32 0, i32 0
  call fastcc void @std.Thread.StaticResetEvent.AtomicEvent.wait(%std.Thread.StaticResetEvent.AtomicEvent* %2)
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).print.21"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %0) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %1 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %2 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0 to i8*
  %3 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %3, i8* align 4 %2, i64 4, i1 false)
  %4 = call fastcc i16 @std.fmt.format.25(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0)
  store i16 %4, i16* %result, align 2
  %5 = load i16, i16* %result, align 2
  ret i16 %5
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.os.linux.tls.initStaticTLS(%"[]std.elf.Elf64_Phdr"* nonnull readonly align 8 %0) unnamed_addr #1 {
Entry:
  %1 = alloca { %"[]u8", i16 }, align 8
  %alloc_tls_area = alloca %"[]u8", align 8
  %begin_addr = alloca i64, align 8
  %begin_aligned_addr = alloca i64, align 8
  %start = alloca i64, align 8
  %tls_area = alloca %"[]u8", align 8
  %tp_value = alloca i64, align 8
  call fastcc void @std.os.linux.tls.initTLS(%"[]std.elf.Elf64_Phdr"* %0)
  %2 = load i64, i64* getelementptr inbounds (%std.os.linux.tls.TLSImage, %std.os.linux.tls.TLSImage* @tls_image, i32 0, i32 2), align 8
  %3 = icmp ule i64 %2, 4096
  br i1 %3, label %BoolAndTrue, label %BoolAndFalse

BoolAndTrue:                                      ; preds = %Entry
  %4 = load i64, i64* getelementptr inbounds (%std.os.linux.tls.TLSImage, %std.os.linux.tls.TLSImage* @tls_image, i32 0, i32 1), align 8
  %5 = icmp ule i64 %4, 8448
  br label %BoolAndFalse

BoolAndFalse:                                     ; preds = %BoolAndTrue, %Entry
  %6 = phi i1 [ %3, %Entry ], [ %5, %BoolAndTrue ]
  br i1 %6, label %Then, label %Else

Else:                                             ; preds = %BoolAndFalse
  br label %EndIf

EndIf:                                            ; preds = %Else
  %7 = load i64, i64* getelementptr inbounds (%std.os.linux.tls.TLSImage, %std.os.linux.tls.TLSImage* @tls_image, i32 0, i32 1), align 8
  %8 = load i64, i64* getelementptr inbounds (%std.os.linux.tls.TLSImage, %std.os.linux.tls.TLSImage* @tls_image, i32 0, i32 2), align 8
  %9 = add nuw i64 %7, %8
  %10 = sub nuw i64 %9, 1
  call fastcc void @std.os.mmap({ %"[]u8", i16 }* sret({ %"[]u8", i16 }) %1, i8* null, i64 %10, i32 3, i32 34, i32 -1, i64 0)
  %11 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %1, i32 0, i32 1
  %12 = load i16, i16* %11, align 2
  %13 = icmp ne i16 %12, 0
  br i1 %13, label %UnwrapErrError, label %UnwrapErrOk

UnwrapErrError:                                   ; preds = %EndIf
  call fastcc void @std.os.abort()
  unreachable

UnwrapErrOk:                                      ; preds = %EndIf
  %14 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %1, i32 0, i32 0
  %15 = bitcast %"[]u8"* %14 to i8*
  %16 = bitcast %"[]u8"* %alloc_tls_area to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %16, i8* align 8 %15, i64 16, i1 false)
  br label %UnwrapErrEnd

Then:                                             ; preds = %BoolAndFalse
  %17 = load i64, i64* getelementptr inbounds (%std.os.linux.tls.TLSImage, %std.os.linux.tls.TLSImage* @tls_image, i32 0, i32 1), align 8
  %18 = sub nuw i64 %17, 0
  %19 = getelementptr inbounds %"[]u8", %"[]u8"* %tls_area, i32 0, i32 0
  store i8* getelementptr inbounds ([8448 x i8], [8448 x i8]* @main_thread_tls_buffer, i64 0, i64 0), i8** %19, align 8
  %20 = getelementptr inbounds %"[]u8", %"[]u8"* %tls_area, i32 0, i32 1
  store i64 %18, i64* %20, align 8
  %21 = bitcast %"[]u8"* %tls_area to i8*
  %22 = bitcast %"[]u8"* %tls_area to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %22, i8* align 8 %21, i64 16, i1 false)
  br label %BlockEnd

UnwrapErrEnd:                                     ; preds = %UnwrapErrOk
  %23 = getelementptr inbounds %"[]u8", %"[]u8"* %alloc_tls_area, i32 0, i32 0
  %24 = load i8*, i8** %23, align 8
  %25 = ptrtoint i8* %24 to i64
  store i64 %25, i64* %begin_addr, align 8
  %26 = load i64, i64* %begin_addr, align 8
  %27 = load i64, i64* getelementptr inbounds (%std.os.linux.tls.TLSImage, %std.os.linux.tls.TLSImage* @tls_image, i32 0, i32 2), align 8
  %28 = call fastcc i64 @std.mem.alignForward(i64 %26, i64 %27)
  store i64 %28, i64* %begin_aligned_addr, align 8
  %29 = load i64, i64* %begin_aligned_addr, align 8
  %30 = load i64, i64* %begin_addr, align 8
  %31 = sub nuw i64 %29, %30
  store i64 %31, i64* %start, align 8
  %32 = load i64, i64* %start, align 8
  %33 = load i64, i64* %start, align 8
  %34 = load i64, i64* getelementptr inbounds (%std.os.linux.tls.TLSImage, %std.os.linux.tls.TLSImage* @tls_image, i32 0, i32 1), align 8
  %35 = add nuw i64 %33, %34
  %36 = getelementptr inbounds %"[]u8", %"[]u8"* %alloc_tls_area, i32 0, i32 0
  %37 = load i8*, i8** %36, align 8
  %38 = getelementptr inbounds i8, i8* %37, i64 %32
  %39 = sub nuw i64 %35, %32
  %40 = getelementptr inbounds %"[]u8", %"[]u8"* %tls_area, i32 0, i32 0
  store i8* %38, i8** %40, align 8
  %41 = getelementptr inbounds %"[]u8", %"[]u8"* %tls_area, i32 0, i32 1
  store i64 %39, i64* %41, align 8
  %42 = bitcast %"[]u8"* %tls_area to i8*
  %43 = bitcast %"[]u8"* %tls_area to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %43, i8* align 8 %42, i64 16, i1 false)
  br label %BlockEnd

BlockEnd:                                         ; preds = %UnwrapErrEnd, %Then
  %44 = call fastcc i64 @std.os.linux.tls.prepareTLS(%"[]u8"* %tls_area)
  store i64 %44, i64* %tp_value, align 8
  %45 = load i64, i64* %tp_value, align 8
  call fastcc void @std.os.linux.tls.setThreadPointer(i64 %45)
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.start.expandStackSize(%"[]std.elf.Elf64_Phdr"* nonnull readonly align 8 %0) unnamed_addr #1 {
Entry:
  %i = alloca i64, align 8
  %phdr = alloca %std.elf.Elf64_Phdr*, align 8
  %wanted_stack_size = alloca i64, align 8
  %1 = alloca %std.os.linux.rlimit, align 8
  %2 = alloca i16, align 2
  store i64 0, i64* %i, align 8
  %3 = getelementptr inbounds %"[]std.elf.Elf64_Phdr", %"[]std.elf.Elf64_Phdr"* %0, i32 0, i32 1
  %4 = load i64, i64* %3, align 8
  br label %ForCond

ForCond:                                          ; preds = %SwitchEnd, %Entry
  %5 = load i64, i64* %i, align 8
  %6 = icmp ult i64 %5, %4
  br i1 %6, label %ForBody, label %ForEnd

ForBody:                                          ; preds = %ForCond
  %7 = getelementptr inbounds %"[]std.elf.Elf64_Phdr", %"[]std.elf.Elf64_Phdr"* %0, i32 0, i32 0
  %8 = load %std.elf.Elf64_Phdr*, %std.elf.Elf64_Phdr** %7, align 8
  %9 = getelementptr inbounds %std.elf.Elf64_Phdr, %std.elf.Elf64_Phdr* %8, i64 %5
  store %std.elf.Elf64_Phdr* %9, %std.elf.Elf64_Phdr** %phdr, align 8
  %10 = load %std.elf.Elf64_Phdr*, %std.elf.Elf64_Phdr** %phdr, align 8
  %11 = getelementptr inbounds %std.elf.Elf64_Phdr, %std.elf.Elf64_Phdr* %10, i32 0, i32 0
  %12 = load i32, i32* %11, align 4
  switch i32 %12, label %SwitchElse [
    i32 1685382481, label %SwitchProng
  ]

SwitchProng:                                      ; preds = %ForBody
  %13 = load %std.elf.Elf64_Phdr*, %std.elf.Elf64_Phdr** %phdr, align 8
  %14 = getelementptr inbounds %std.elf.Elf64_Phdr, %std.elf.Elf64_Phdr* %13, i32 0, i32 6
  %15 = load i64, i64* %14, align 8
  store i64 %15, i64* %wanted_stack_size, align 8
  %16 = load i64, i64* %wanted_stack_size, align 8
  %17 = urem i64 %16, 4096
  %18 = icmp eq i64 %17, 0
  call fastcc void @std.debug.assert(i1 %18)
  %19 = getelementptr inbounds %std.os.linux.rlimit, %std.os.linux.rlimit* %1, i32 0, i32 0
  %20 = load i64, i64* %wanted_stack_size, align 8
  store i64 %20, i64* %19, align 8
  %21 = getelementptr inbounds %std.os.linux.rlimit, %std.os.linux.rlimit* %1, i32 0, i32 1
  %22 = load i64, i64* %wanted_stack_size, align 8
  store i64 %22, i64* %21, align 8
  %23 = call fastcc i16 @std.os.setrlimit(i32 3, %std.os.linux.rlimit* %1)
  store i16 %23, i16* %2, align 2
  %24 = icmp ne i16 %23, 0
  br i1 %24, label %UnwrapErrError, label %UnwrapErrOk

UnwrapErrError:                                   ; preds = %SwitchProng
  br label %UnwrapErrEnd

UnwrapErrOk:                                      ; preds = %SwitchProng
  br label %UnwrapErrEnd

UnwrapErrEnd:                                     ; preds = %UnwrapErrOk, %UnwrapErrError
  br label %ForEnd

SwitchElse:                                       ; preds = %ForBody
  br label %SwitchEnd

SwitchEnd:                                        ; preds = %SwitchElse
  %25 = add nuw i64 %5, 1
  store i64 %25, i64* %i, align 8
  br label %ForCond

ForEnd:                                           ; preds = %UnwrapErrEnd, %ForCond
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i8 @std.start.callMainWithArgs(i64 %0, i8** nonnull align 8 %1, %"[][*:0]u8"* nonnull readonly align 8 %2) unnamed_addr #1 {
Entry:
  %result = alloca i8, align 1
  %argc = alloca i64, align 8
  %argv = alloca i8**, align 8
  store i64 %0, i64* %argc, align 8
  store i8** %1, i8*** %argv, align 8
  %3 = load i64, i64* %argc, align 8
  %4 = load i8**, i8*** %argv, align 8
  %5 = getelementptr inbounds i8*, i8** %4, i64 0
  %6 = sub nuw i64 %3, 0
  store i8** %5, i8*** getelementptr inbounds (%"[][*:0]u8", %"[][*:0]u8"* @argv, i32 0, i32 0), align 8
  store i64 %6, i64* getelementptr inbounds (%"[][*:0]u8", %"[][*:0]u8"* @argv, i32 0, i32 1), align 8
  %7 = bitcast %"[][*:0]u8"* %2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 bitcast (%"[][*:0]u8"* @environ to i8*), i8* align 8 %7, i64 16, i1 false)
  call fastcc void @std.debug.maybeEnableSegfaultHandler()
  %8 = call fastcc i8 @std.start.initEventLoopAndCallMain()
  store i8 %8, i8* %result, align 1
  %9 = load i8, i8* %result, align 1
  ret i8 %9
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.Thread.Mutex.AtomicMutex.lock(%std.Thread.Mutex.AtomicMutex* nonnull align 4 %0) unnamed_addr #1 {
Entry:
  %1 = alloca i32, align 4
  %s = alloca i32, align 4
  %m = alloca %std.Thread.Mutex.AtomicMutex*, align 8
  store %std.Thread.Mutex.AtomicMutex* %0, %std.Thread.Mutex.AtomicMutex** %m, align 8
  %2 = load %std.Thread.Mutex.AtomicMutex*, %std.Thread.Mutex.AtomicMutex** %m, align 8
  %3 = getelementptr inbounds %std.Thread.Mutex.AtomicMutex, %std.Thread.Mutex.AtomicMutex* %2, i32 0, i32 0
  %4 = atomicrmw xchg i32* %3, i32 1 acquire, align 4
  store i32 %4, i32* %1, align 4
  switch i32 %4, label %SwitchElse [
    i32 0, label %SwitchProng
  ]

SwitchElse:                                       ; preds = %Entry
  store i32 %4, i32* %s, align 4
  %5 = load %std.Thread.Mutex.AtomicMutex*, %std.Thread.Mutex.AtomicMutex** %m, align 8
  %6 = load i32, i32* %s, align 4
  call fastcc void @std.Thread.Mutex.AtomicMutex.lockSlow(%std.Thread.Mutex.AtomicMutex* %5, i32 %6)
  br label %SwitchEnd

SwitchProng:                                      ; preds = %Entry
  br label %SwitchEnd

SwitchEnd:                                        ; preds = %SwitchProng, %SwitchElse
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i32 @std.io.getStdErrHandle() unnamed_addr #1 {
Entry:
  %result = alloca i32, align 4
  store i32 2, i32* %result, align 4
  %0 = load i32, i32* %result, align 4
  ret i32 %0
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.fs.file.File.write({ i64, i16 }* nonnull sret({ i64, i16 }) %0, %std.fs.file.File* nonnull readonly align 4 %1, %"[]u8"* nonnull readonly align 8 %2) unnamed_addr #1 {
Entry:
  %3 = getelementptr inbounds %std.fs.file.File, %std.fs.file.File* %1, i32 0, i32 0
  %4 = load i32, i32* %3, align 4
  call fastcc void @std.os.write({ i64, i16 }* sret({ i64, i16 }) %0, i32 %4, %"[]u8"* %2)
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.os.write({ i64, i16 }* nonnull sret({ i64, i16 }) %0, i32 %1, %"[]u8"* nonnull readonly align 8 %2) unnamed_addr #1 {
Entry:
  %adjusted_len = alloca i64, align 8
  %rc = alloca i64, align 8
  %3 = alloca i16, align 2
  %err = alloca i16, align 2
  %fd = alloca i32, align 4
  store i32 %1, i32* %fd, align 4
  %4 = getelementptr inbounds %"[]u8", %"[]u8"* %2, i32 0, i32 1
  %5 = load i64, i64* %4, align 8
  %6 = call i64 @llvm.umin.i64(i64 2147479552, i64 %5)
  store i64 %6, i64* %adjusted_len, align 8
  br label %WhileCond

WhileCond:                                        ; preds = %SwitchProng1, %Entry
  br label %WhileBody

WhileBody:                                        ; preds = %WhileCond
  %7 = load i32, i32* %fd, align 4
  %8 = getelementptr inbounds %"[]u8", %"[]u8"* %2, i32 0, i32 0
  %9 = load i8*, i8** %8, align 8
  %10 = load i64, i64* %adjusted_len, align 8
  %11 = call fastcc i64 @std.os.linux.write(i32 %7, i8* %9, i64 %10)
  store i64 %11, i64* %rc, align 8
  %12 = load i64, i64* %rc, align 8
  %13 = call fastcc i16 @std.os.linux.getErrno(i64 %12)
  store i16 %13, i16* %3, align 2
  switch i16 %13, label %SwitchElse [
    i16 0, label %SwitchProng
    i16 4, label %SwitchProng1
    i16 22, label %SwitchProng2
    i16 14, label %SwitchProng3
    i16 11, label %SwitchProng4
    i16 9, label %SwitchProng5
    i16 89, label %SwitchProng6
    i16 122, label %SwitchProng7
    i16 27, label %SwitchProng8
    i16 5, label %SwitchProng9
    i16 28, label %SwitchProng10
    i16 1, label %SwitchProng11
    i16 32, label %SwitchProng12
    i16 104, label %SwitchProng13
  ]

SwitchElse:                                       ; preds = %WhileBody
  store i16 %13, i16* %err, align 2
  %14 = load i16, i16* %err, align 2
  %15 = call fastcc i16 @std.os.unexpectedErrno(i16 %14)
  %16 = getelementptr inbounds { i64, i16 }, { i64, i16 }* %0, i32 0, i32 1
  store i16 %15, i16* %16, align 2
  ret void

SwitchProng:                                      ; preds = %WhileBody
  %17 = load i64, i64* %rc, align 8
  %18 = getelementptr inbounds { i64, i16 }, { i64, i16 }* %0, i32 0, i32 1
  store i16 0, i16* %18, align 2
  %19 = getelementptr inbounds { i64, i16 }, { i64, i16 }* %0, i32 0, i32 0
  store i64 %17, i64* %19, align 8
  ret void

SwitchProng1:                                     ; preds = %WhileBody
  br label %WhileCond

SwitchProng2:                                     ; preds = %WhileBody
  unreachable

SwitchProng3:                                     ; preds = %WhileBody
  unreachable

SwitchProng4:                                     ; preds = %WhileBody
  %20 = getelementptr inbounds { i64, i16 }, { i64, i16 }* %0, i32 0, i32 1
  store i16 10, i16* %20, align 2
  ret void

SwitchProng5:                                     ; preds = %WhileBody
  %21 = getelementptr inbounds { i64, i16 }, { i64, i16 }* %0, i32 0, i32 1
  store i16 9, i16* %21, align 2
  ret void

SwitchProng6:                                     ; preds = %WhileBody
  unreachable

SwitchProng7:                                     ; preds = %WhileBody
  %22 = getelementptr inbounds { i64, i16 }, { i64, i16 }* %0, i32 0, i32 1
  store i16 1, i16* %22, align 2
  ret void

SwitchProng8:                                     ; preds = %WhileBody
  %23 = getelementptr inbounds { i64, i16 }, { i64, i16 }* %0, i32 0, i32 1
  store i16 2, i16* %23, align 2
  ret void

SwitchProng9:                                     ; preds = %WhileBody
  %24 = getelementptr inbounds { i64, i16 }, { i64, i16 }* %0, i32 0, i32 1
  store i16 3, i16* %24, align 2
  ret void

SwitchProng10:                                    ; preds = %WhileBody
  %25 = getelementptr inbounds { i64, i16 }, { i64, i16 }* %0, i32 0, i32 1
  store i16 4, i16* %25, align 2
  ret void

SwitchProng11:                                    ; preds = %WhileBody
  %26 = getelementptr inbounds { i64, i16 }, { i64, i16 }* %0, i32 0, i32 1
  store i16 5, i16* %26, align 2
  ret void

SwitchProng12:                                    ; preds = %WhileBody
  %27 = getelementptr inbounds { i64, i16 }, { i64, i16 }* %0, i32 0, i32 1
  store i16 6, i16* %27, align 2
  ret void

SwitchProng13:                                    ; preds = %WhileBody
  %28 = getelementptr inbounds { i64, i16 }, { i64, i16 }* %0, i32 0, i32 1
  store i16 11, i16* %28, align 2
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i64 @std.Thread.LinuxThreadImpl.getCurrentId() unnamed_addr #1 {
Entry:
  %result = alloca i64, align 8
  %tid = alloca i32, align 4
  %0 = load i1, i1* getelementptr inbounds (%"?u64", %"?u64"* @tls_thread_id, i32 0, i32 1), align 1
  br i1 %0, label %OptionalNonNull, label %OptionalNull

OptionalNull:                                     ; preds = %Entry
  %1 = call fastcc i32 @std.os.linux.gettid()
  store i32 %1, i32* %tid, align 4
  %2 = load i32, i32* %tid, align 4
  store i1 true, i1* getelementptr inbounds (%"?u64", %"?u64"* @tls_thread_id, i32 0, i32 1), align 1
  %3 = zext i32 %2 to i64
  store i64 %3, i64* getelementptr inbounds (%"?u64", %"?u64"* @tls_thread_id, i32 0, i32 0), align 8
  %4 = load i32, i32* %tid, align 4
  %5 = zext i32 %4 to i64
  store i64 %5, i64* %result, align 8
  %6 = load i64, i64* %result, align 8
  ret i64 %6

OptionalNonNull:                                  ; preds = %Entry
  %7 = load i64, i64* getelementptr inbounds (%"?u64", %"?u64"* @tls_thread_id, i32 0, i32 0), align 8
  store i64 %7, i64* %result, align 8
  %8 = load i64, i64* %result, align 8
  ret i64 %8
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.format(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %0, %"std.debug.struct:295:56"* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %options = alloca %std.fmt.FormatOptions, align 8
  %2 = alloca i16, align 2
  %3 = alloca i64, align 8
  %4 = alloca %std.fmt.FormatOptions, align 8
  %5 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %6 = alloca i16, align 2
  %7 = alloca i16, align 2
  %8 = bitcast %std.fmt.FormatOptions* %options to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %8, i8* align 8 bitcast ({ %"?usize", %"?usize", i2, <{ i8, [6 x i8] }> }* @57 to i8*), i64 40, i1 false)
  %9 = call fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).writeAll"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0, %"[]u8"* @59)
  store i16 %9, i16* %2, align 2
  %10 = icmp ne i16 %9, 0
  br i1 %10, label %ErrRetReturn, label %ErrRetContinue

ErrRetReturn:                                     ; preds = %Entry
  %11 = load i16, i16* %2, align 2
  store i16 %11, i16* %result, align 2
  ret i16 %11

ErrRetContinue:                                   ; preds = %Entry
  %12 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 0
  %13 = bitcast %"?usize"* %12 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %13, i8* align 8 bitcast (%"?usize"* @60 to i8*), i64 16, i1 false)
  %14 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 1
  %15 = bitcast %"?usize"* %14 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %15, i8* align 8 bitcast (%"?usize"* @61 to i8*), i64 16, i1 false)
  %16 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 2
  store i2 -2, i2* %16, align 1
  %17 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 3
  store i8 32, i8* %17, align 1
  %18 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 1
  %19 = bitcast %"?usize"* %18 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %19, i8* align 8 bitcast (%"?usize"* @64 to i8*), i64 16, i1 false)
  %20 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 0
  %21 = bitcast %"?usize"* %20 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %21, i8* align 8 bitcast (%"?usize"* @65 to i8*), i64 16, i1 false)
  %22 = getelementptr inbounds %"std.debug.struct:295:56", %"std.debug.struct:295:56"* %1, i32 0, i32 0
  %23 = load i64, i64* %22, align 8
  store i64 %23, i64* %3, align 8
  %24 = bitcast %std.fmt.FormatOptions* %options to i8*
  %25 = bitcast %std.fmt.FormatOptions* %4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %25, i8* align 8 %24, i64 40, i1 false)
  %26 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0 to i8*
  %27 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %27, i8* align 4 %26, i64 4, i1 false)
  %28 = call fastcc i16 @std.fmt.formatType(i64 %23, %std.fmt.FormatOptions* %options, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0, i64 3)
  store i16 %28, i16* %6, align 2
  %29 = icmp ne i16 %28, 0
  br i1 %29, label %ErrRetReturn1, label %ErrRetContinue2

ErrRetReturn1:                                    ; preds = %ErrRetContinue
  %30 = load i16, i16* %6, align 2
  store i16 %30, i16* %result, align 2
  ret i16 %30

ErrRetContinue2:                                  ; preds = %ErrRetContinue
  %31 = call fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).writeAll"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0, %"[]u8"* @66)
  store i16 %31, i16* %7, align 2
  %32 = icmp ne i16 %31, 0
  br i1 %32, label %ErrRetReturn3, label %ErrRetContinue4

ErrRetReturn3:                                    ; preds = %ErrRetContinue2
  %33 = load i16, i16* %7, align 2
  store i16 %33, i16* %result, align 2
  ret i16 %33

ErrRetContinue4:                                  ; preds = %ErrRetContinue2
  store i16 0, i16* %result, align 2
  ret i16 0
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.os.raise(i8 %0) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %set = alloca [32 x i32], align 4
  %tid = alloca i32, align 4
  %rc = alloca i64, align 8
  %1 = alloca i16, align 2
  %err = alloca i16, align 2
  %sig = alloca i8, align 1
  store i8 %0, i8* %sig, align 1
  %2 = call fastcc i64 @std.os.linux.sigprocmask(i32 0, [32 x i32]* @app_mask, [32 x i32]* %set)
  %3 = call fastcc i32 @std.os.linux.gettid()
  store i32 %3, i32* %tid, align 4
  %4 = load i32, i32* %tid, align 4
  %5 = load i8, i8* %sig, align 1
  %6 = zext i8 %5 to i32
  %7 = call fastcc i64 @std.os.linux.tkill(i32 %4, i32 %6)
  store i64 %7, i64* %rc, align 8
  %8 = call fastcc i64 @std.os.linux.sigprocmask(i32 2, [32 x i32]* %set, [32 x i32]* null)
  %9 = load i64, i64* %rc, align 8
  %10 = call fastcc i16 @std.os.linux.getErrno(i64 %9)
  store i16 %10, i16* %1, align 2
  switch i16 %10, label %SwitchElse [
    i16 0, label %SwitchProng
  ]

SwitchElse:                                       ; preds = %Entry
  store i16 %10, i16* %err, align 2
  %11 = load i16, i16* %err, align 2
  %12 = call fastcc i16 @std.os.unexpectedErrno(i16 %11)
  store i16 %12, i16* %result, align 2
  %13 = load i16, i16* %result, align 2
  ret i16 %13

SwitchProng:                                      ; preds = %Entry
  store i16 0, i16* %result, align 2
  %14 = load i16, i16* %result, align 2
  ret i16 %14
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.format.22(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %0, %"std.debug.struct:297:40"* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %options = alloca %std.fmt.FormatOptions, align 8
  %2 = alloca %"[]u8", align 8
  %3 = alloca %std.fmt.FormatOptions, align 8
  %4 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %5 = alloca i16, align 2
  %6 = alloca i16, align 2
  %7 = bitcast %std.fmt.FormatOptions* %options to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %7, i8* align 8 bitcast ({ %"?usize", %"?usize", i2, <{ i8, [6 x i8] }> }* @68 to i8*), i64 40, i1 false)
  %8 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 0
  %9 = bitcast %"?usize"* %8 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %9, i8* align 8 bitcast (%"?usize"* @69 to i8*), i64 16, i1 false)
  %10 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 1
  %11 = bitcast %"?usize"* %10 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %11, i8* align 8 bitcast (%"?usize"* @70 to i8*), i64 16, i1 false)
  %12 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 2
  store i2 -2, i2* %12, align 1
  %13 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 3
  store i8 32, i8* %13, align 1
  %14 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 1
  %15 = bitcast %"?usize"* %14 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %15, i8* align 8 bitcast (%"?usize"* @74 to i8*), i64 16, i1 false)
  %16 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 0
  %17 = bitcast %"?usize"* %16 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %17, i8* align 8 bitcast (%"?usize"* @75 to i8*), i64 16, i1 false)
  %18 = getelementptr inbounds %"std.debug.struct:297:40", %"std.debug.struct:297:40"* %1, i32 0, i32 0
  %19 = bitcast %"[]u8"* %18 to i8*
  %20 = bitcast %"[]u8"* %2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %20, i8* align 8 %19, i64 16, i1 false)
  %21 = bitcast %std.fmt.FormatOptions* %options to i8*
  %22 = bitcast %std.fmt.FormatOptions* %3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %22, i8* align 8 %21, i64 40, i1 false)
  %23 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0 to i8*
  %24 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %24, i8* align 4 %23, i64 4, i1 false)
  %25 = call fastcc i16 @std.fmt.formatType.26(%"[]u8"* %18, %std.fmt.FormatOptions* %options, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0, i64 3)
  store i16 %25, i16* %5, align 2
  %26 = icmp ne i16 %25, 0
  br i1 %26, label %ErrRetReturn, label %ErrRetContinue

ErrRetReturn:                                     ; preds = %Entry
  %27 = load i16, i16* %5, align 2
  store i16 %27, i16* %result, align 2
  ret i16 %27

ErrRetContinue:                                   ; preds = %Entry
  %28 = call fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).writeAll"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0, %"[]u8"* @76)
  store i16 %28, i16* %6, align 2
  %29 = icmp ne i16 %28, 0
  br i1 %29, label %ErrRetReturn1, label %ErrRetContinue2

ErrRetReturn1:                                    ; preds = %ErrRetContinue
  %30 = load i16, i16* %6, align 2
  store i16 %30, i16* %result, align 2
  ret i16 %30

ErrRetContinue2:                                  ; preds = %ErrRetContinue
  store i16 0, i16* %result, align 2
  ret i16 0
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).print.23"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %0) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %1 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %2 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0 to i8*
  %3 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %3, i8* align 4 %2, i64 4, i1 false)
  %4 = call fastcc i16 @std.fmt.format.27(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0)
  store i16 %4, i16* %result, align 2
  %5 = load i16, i16* %result, align 2
  ret i16 %5
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).print.24"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %0) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %1 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %2 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0 to i8*
  %3 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %3, i8* align 4 %2, i64 4, i1 false)
  %4 = call fastcc i16 @std.fmt.format.28(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0)
  store i16 %4, i16* %result, align 2
  %5 = load i16, i16* %result, align 2
  ret i16 %5
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.Thread.Mutex.AtomicMutex.unlock(%std.Thread.Mutex.AtomicMutex* nonnull align 4 %0) unnamed_addr #1 {
Entry:
  %1 = alloca i32, align 4
  %m = alloca %std.Thread.Mutex.AtomicMutex*, align 8
  store %std.Thread.Mutex.AtomicMutex* %0, %std.Thread.Mutex.AtomicMutex** %m, align 8
  %2 = load %std.Thread.Mutex.AtomicMutex*, %std.Thread.Mutex.AtomicMutex** %m, align 8
  %3 = getelementptr inbounds %std.Thread.Mutex.AtomicMutex, %std.Thread.Mutex.AtomicMutex* %2, i32 0, i32 0
  %4 = atomicrmw xchg i32* %3, i32 0 release, align 4
  store i32 %4, i32* %1, align 4
  switch i32 %4, label %SwitchElse [
    i32 0, label %SwitchProng
    i32 1, label %SwitchProng1
    i32 2, label %SwitchProng2
  ]

SwitchProng:                                      ; preds = %Entry
  unreachable

SwitchElse:                                       ; preds = %Entry
  unreachable

SwitchProng1:                                     ; preds = %Entry
  br label %SwitchEnd

SwitchProng2:                                     ; preds = %Entry
  %5 = load %std.Thread.Mutex.AtomicMutex*, %std.Thread.Mutex.AtomicMutex** %m, align 8
  call fastcc void @std.Thread.Mutex.AtomicMutex.unlockSlow(%std.Thread.Mutex.AtomicMutex* %5)
  br label %SwitchEnd

SwitchEnd:                                        ; preds = %SwitchProng2, %SwitchProng1
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.Thread.StaticResetEvent.AtomicEvent.wait(%std.Thread.StaticResetEvent.AtomicEvent* nonnull align 4 %0) unnamed_addr #1 {
Entry:
  %1 = alloca i1, align 1
  %ev = alloca %std.Thread.StaticResetEvent.AtomicEvent*, align 8
  store %std.Thread.StaticResetEvent.AtomicEvent* %0, %std.Thread.StaticResetEvent.AtomicEvent** %ev, align 8
  %2 = load %std.Thread.StaticResetEvent.AtomicEvent*, %std.Thread.StaticResetEvent.AtomicEvent** %ev, align 8
  %3 = call fastcc i1 @std.Thread.StaticResetEvent.AtomicEvent.timedWait(%std.Thread.StaticResetEvent.AtomicEvent* %2, %"?u64"* @80)
  store i1 %3, i1* %1, align 1
  switch i1 %3, label %SwitchElse [
    i1 true, label %SwitchProng
    i1 false, label %SwitchProng1
  ]

SwitchProng:                                      ; preds = %Entry
  unreachable

SwitchProng1:                                     ; preds = %Entry
  ret void

SwitchElse:                                       ; preds = %Entry
  unreachable
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.format.25(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %0) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %options = alloca %std.fmt.FormatOptions, align 8
  %1 = alloca i16, align 2
  %2 = bitcast %std.fmt.FormatOptions* %options to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %2, i8* align 8 bitcast ({ %"?usize", %"?usize", i2, <{ i8, [6 x i8] }> }* @81 to i8*), i64 40, i1 false)
  %3 = call fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).writeAll"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0, %"[]u8"* @83)
  store i16 %3, i16* %1, align 2
  %4 = icmp ne i16 %3, 0
  br i1 %4, label %ErrRetReturn, label %ErrRetContinue

ErrRetReturn:                                     ; preds = %Entry
  %5 = load i16, i16* %1, align 2
  store i16 %5, i16* %result, align 2
  ret i16 %5

ErrRetContinue:                                   ; preds = %Entry
  store i16 0, i16* %result, align 2
  ret i16 0
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i1 @std.target.Arch.isARM(i6 %0) unnamed_addr #1 {
Entry:
  %result = alloca i1, align 1
  %arch = alloca i6, align 1
  store i6 %0, i6* %arch, align 1
  %1 = load i6, i6* %arch, align 1
  switch i6 %1, label %SwitchElse [
    i6 0, label %SwitchProng
    i6 1, label %SwitchProng
  ]

SwitchElse:                                       ; preds = %Entry
  store i1 false, i1* %result, align 1
  br label %SwitchEnd

SwitchProng:                                      ; preds = %Entry, %Entry
  store i1 true, i1* %result, align 1
  br label %SwitchEnd

SwitchEnd:                                        ; preds = %SwitchProng, %SwitchElse
  %2 = load i1, i1* %result, align 1
  ret i1 %2
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.os.linux.tls.initTLS(%"[]std.elf.Elf64_Phdr"* nonnull readonly align 8 %0) unnamed_addr #1 {
Entry:
  %tls_phdr = alloca %std.elf.Elf64_Phdr*, align 8
  %img_base = alloca i64, align 8
  %i = alloca i64, align 8
  %phdr = alloca %std.elf.Elf64_Phdr*, align 8
  %tls_align_factor = alloca i64, align 8
  %tls_data = alloca %"[]u8", align 8
  %tls_data_alloc_size = alloca i64, align 8
  %phdr2 = alloca %std.elf.Elf64_Phdr*, align 8
  %1 = alloca i8*, align 8
  %tcb_offset = alloca i64, align 8
  %dtv_offset = alloca i64, align 8
  %data_offset = alloca i64, align 8
  %l = alloca i64, align 8
  %alloc_size = alloca i64, align 8
  store %std.elf.Elf64_Phdr* null, %std.elf.Elf64_Phdr** %tls_phdr, align 8
  store i64 0, i64* %img_base, align 8
  store i64 0, i64* %i, align 8
  %2 = getelementptr inbounds %"[]std.elf.Elf64_Phdr", %"[]std.elf.Elf64_Phdr"* %0, i32 0, i32 1
  %3 = load i64, i64* %2, align 8
  br label %ForCond

ForCond:                                          ; preds = %SwitchEnd, %Entry
  %4 = load i64, i64* %i, align 8
  %5 = icmp ult i64 %4, %3
  br i1 %5, label %ForBody, label %ForEnd

ForBody:                                          ; preds = %ForCond
  %6 = getelementptr inbounds %"[]std.elf.Elf64_Phdr", %"[]std.elf.Elf64_Phdr"* %0, i32 0, i32 0
  %7 = load %std.elf.Elf64_Phdr*, %std.elf.Elf64_Phdr** %6, align 8
  %8 = getelementptr inbounds %std.elf.Elf64_Phdr, %std.elf.Elf64_Phdr* %7, i64 %4
  store %std.elf.Elf64_Phdr* %8, %std.elf.Elf64_Phdr** %phdr, align 8
  %9 = load %std.elf.Elf64_Phdr*, %std.elf.Elf64_Phdr** %phdr, align 8
  %10 = getelementptr inbounds %std.elf.Elf64_Phdr, %std.elf.Elf64_Phdr* %9, i32 0, i32 0
  %11 = load i32, i32* %10, align 4
  switch i32 %11, label %SwitchElse [
    i32 6, label %SwitchProng
    i32 7, label %SwitchProng1
  ]

SwitchElse:                                       ; preds = %ForBody
  br label %SwitchEnd

SwitchProng:                                      ; preds = %ForBody
  %12 = getelementptr inbounds %"[]std.elf.Elf64_Phdr", %"[]std.elf.Elf64_Phdr"* %0, i32 0, i32 0
  %13 = load %std.elf.Elf64_Phdr*, %std.elf.Elf64_Phdr** %12, align 8
  %14 = ptrtoint %std.elf.Elf64_Phdr* %13 to i64
  %15 = load %std.elf.Elf64_Phdr*, %std.elf.Elf64_Phdr** %phdr, align 8
  %16 = getelementptr inbounds %std.elf.Elf64_Phdr, %std.elf.Elf64_Phdr* %15, i32 0, i32 3
  %17 = load i64, i64* %16, align 8
  %18 = sub nuw i64 %14, %17
  store i64 %18, i64* %img_base, align 8
  br label %SwitchEnd

SwitchProng1:                                     ; preds = %ForBody
  %19 = load %std.elf.Elf64_Phdr*, %std.elf.Elf64_Phdr** %phdr, align 8
  store %std.elf.Elf64_Phdr* %19, %std.elf.Elf64_Phdr** %tls_phdr, align 8
  br label %SwitchEnd

SwitchEnd:                                        ; preds = %SwitchProng1, %SwitchProng, %SwitchElse
  %20 = add nuw i64 %4, 1
  store i64 %20, i64* %i, align 8
  br label %ForCond

ForEnd:                                           ; preds = %ForCond
  %21 = load %std.elf.Elf64_Phdr*, %std.elf.Elf64_Phdr** %tls_phdr, align 8
  %22 = icmp ne %std.elf.Elf64_Phdr* %21, null
  br i1 %22, label %OptionalThen, label %OptionalElse

OptionalThen:                                     ; preds = %ForEnd
  %23 = load %std.elf.Elf64_Phdr*, %std.elf.Elf64_Phdr** %tls_phdr, align 8
  store %std.elf.Elf64_Phdr* %23, %std.elf.Elf64_Phdr** %phdr2, align 8
  %24 = load %std.elf.Elf64_Phdr*, %std.elf.Elf64_Phdr** %phdr2, align 8
  %25 = getelementptr inbounds %std.elf.Elf64_Phdr, %std.elf.Elf64_Phdr* %24, i32 0, i32 7
  %26 = load i64, i64* %25, align 8
  store i64 %26, i64* %tls_align_factor, align 8
  %27 = load i64, i64* %img_base, align 8
  %28 = load %std.elf.Elf64_Phdr*, %std.elf.Elf64_Phdr** %phdr2, align 8
  %29 = getelementptr inbounds %std.elf.Elf64_Phdr, %std.elf.Elf64_Phdr* %28, i32 0, i32 3
  %30 = load i64, i64* %29, align 8
  %31 = add nuw i64 %27, %30
  %32 = inttoptr i64 %31 to i8*
  store i8* %32, i8** %1, align 8
  %33 = load %std.elf.Elf64_Phdr*, %std.elf.Elf64_Phdr** %phdr2, align 8
  %34 = getelementptr inbounds %std.elf.Elf64_Phdr, %std.elf.Elf64_Phdr* %33, i32 0, i32 5
  %35 = load i64, i64* %34, align 8
  %36 = load i8*, i8** %1, align 8
  %37 = getelementptr inbounds i8, i8* %36, i64 0
  %38 = sub nuw i64 %35, 0
  %39 = getelementptr inbounds %"[]u8", %"[]u8"* %tls_data, i32 0, i32 0
  store i8* %37, i8** %39, align 8
  %40 = getelementptr inbounds %"[]u8", %"[]u8"* %tls_data, i32 0, i32 1
  store i64 %38, i64* %40, align 8
  %41 = load %std.elf.Elf64_Phdr*, %std.elf.Elf64_Phdr** %phdr2, align 8
  %42 = getelementptr inbounds %std.elf.Elf64_Phdr, %std.elf.Elf64_Phdr* %41, i32 0, i32 6
  %43 = load i64, i64* %42, align 8
  store i64 %43, i64* %tls_data_alloc_size, align 8
  br label %OptionalEndIf

OptionalElse:                                     ; preds = %ForEnd
  store i64 8, i64* %tls_align_factor, align 8
  %44 = bitcast %"[]u8"* %tls_data to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %44, i8* align 8 bitcast (%"[]u8"* @84 to i8*), i64 16, i1 false)
  store i64 0, i64* %tls_data_alloc_size, align 8
  br label %OptionalEndIf

OptionalEndIf:                                    ; preds = %OptionalElse, %OptionalThen
  store i64 0, i64* %l, align 8
  %45 = load i64, i64* %l, align 8
  store i64 %45, i64* %data_offset, align 8
  %46 = load i64, i64* %l, align 8
  %47 = load i64, i64* %tls_data_alloc_size, align 8
  %48 = load i64, i64* %tls_align_factor, align 8
  %49 = call fastcc i64 @std.mem.alignForward(i64 %47, i64 %48)
  %50 = add nuw i64 %46, %49
  store i64 %50, i64* %l, align 8
  %51 = load i64, i64* %l, align 8
  store i64 %51, i64* %tcb_offset, align 8
  %52 = load i64, i64* %l, align 8
  %53 = add nuw i64 %52, 8
  store i64 %53, i64* %l, align 8
  %54 = load i64, i64* %l, align 8
  %55 = add nuw i64 %54, 8
  store i64 %55, i64* %l, align 8
  %56 = load i64, i64* %l, align 8
  %57 = call fastcc i64 @std.mem.alignForward(i64 %56, i64 8)
  store i64 %57, i64* %l, align 8
  %58 = load i64, i64* %l, align 8
  store i64 %58, i64* %dtv_offset, align 8
  %59 = load i64, i64* %l, align 8
  %60 = add nuw i64 %59, 16
  store i64 %60, i64* %l, align 8
  %61 = load i64, i64* %l, align 8
  store i64 %61, i64* %alloc_size, align 8
  br label %BlockEnd

BlockEnd:                                         ; preds = %OptionalEndIf
  store i64 %61, i64* %alloc_size, align 8
  %62 = bitcast %"[]u8"* %tls_data to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 bitcast (%std.os.linux.tls.TLSImage* @tls_image to i8*), i8* align 8 %62, i64 16, i1 false)
  %63 = load i64, i64* %alloc_size, align 8
  store i64 %63, i64* getelementptr inbounds (%std.os.linux.tls.TLSImage, %std.os.linux.tls.TLSImage* @tls_image, i32 0, i32 1), align 8
  %64 = load i64, i64* %tls_align_factor, align 8
  store i64 %64, i64* getelementptr inbounds (%std.os.linux.tls.TLSImage, %std.os.linux.tls.TLSImage* @tls_image, i32 0, i32 2), align 8
  %65 = load i64, i64* %tcb_offset, align 8
  store i64 %65, i64* getelementptr inbounds (%std.os.linux.tls.TLSImage, %std.os.linux.tls.TLSImage* @tls_image, i32 0, i32 3), align 8
  %66 = load i64, i64* %dtv_offset, align 8
  store i64 %66, i64* getelementptr inbounds (%std.os.linux.tls.TLSImage, %std.os.linux.tls.TLSImage* @tls_image, i32 0, i32 4), align 8
  %67 = load i64, i64* %data_offset, align 8
  store i64 %67, i64* getelementptr inbounds (%std.os.linux.tls.TLSImage, %std.os.linux.tls.TLSImage* @tls_image, i32 0, i32 5), align 8
  %68 = load i64, i64* %tls_data_alloc_size, align 8
  store i64 %68, i64* getelementptr inbounds (%std.os.linux.tls.TLSImage, %std.os.linux.tls.TLSImage* @tls_image, i32 0, i32 6), align 8
  store i64 -1, i64* getelementptr inbounds (%std.os.linux.tls.TLSImage, %std.os.linux.tls.TLSImage* @tls_image, i32 0, i32 7), align 8
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.os.mmap({ %"[]u8", i16 }* nonnull sret({ %"[]u8", i16 }) %0, i8* align 4096 %1, i64 %2, i32 %3, i32 %4, i32 %5, i64 %6) unnamed_addr #1 {
Entry:
  %ioffset = alloca i64, align 8
  %rc = alloca i64, align 8
  %err = alloca i16, align 2
  %7 = alloca i8*, align 8
  %err10 = alloca i16, align 2
  %ptr = alloca i8*, align 8
  %length = alloca i64, align 8
  %prot = alloca i32, align 4
  %flags = alloca i32, align 4
  %fd = alloca i32, align 4
  %offset = alloca i64, align 8
  store i8* %1, i8** %ptr, align 8
  store i64 %2, i64* %length, align 8
  store i32 %3, i32* %prot, align 4
  store i32 %4, i32* %flags, align 4
  store i32 %5, i32* %fd, align 4
  store i64 %6, i64* %offset, align 8
  %8 = load i64, i64* %offset, align 8
  store i64 %8, i64* %ioffset, align 8
  %9 = load i8*, i8** %ptr, align 8
  %10 = load i64, i64* %length, align 8
  %11 = load i32, i32* %prot, align 4
  %12 = zext i32 %11 to i64
  %13 = load i32, i32* %flags, align 4
  %14 = load i32, i32* %fd, align 4
  %15 = load i64, i64* %ioffset, align 8
  %16 = call fastcc i64 @std.os.linux.mmap(i8* %9, i64 %10, i64 %12, i32 %13, i32 %14, i64 %15)
  store i64 %16, i64* %rc, align 8
  %17 = load i64, i64* %rc, align 8
  %18 = call fastcc i16 @std.os.linux.getErrno(i64 %17)
  store i16 %18, i16* %err, align 2
  %19 = load i16, i16* %err, align 2
  %20 = icmp eq i16 %19, 0
  br i1 %20, label %Then, label %Else

Then:                                             ; preds = %Entry
  %21 = load i64, i64* %rc, align 8
  %22 = inttoptr i64 %21 to i8*
  store i8* %22, i8** %7, align 8
  %23 = load i64, i64* %length, align 8
  %24 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %0, i32 0, i32 1
  store i16 0, i16* %24, align 2
  %25 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %0, i32 0, i32 0
  %26 = load i8*, i8** %7, align 8
  %27 = getelementptr inbounds i8, i8* %26, i64 0
  %28 = sub nuw i64 %23, 0
  %29 = getelementptr inbounds %"[]u8", %"[]u8"* %25, i32 0, i32 0
  store i8* %27, i8** %29, align 8
  %30 = getelementptr inbounds %"[]u8", %"[]u8"* %25, i32 0, i32 1
  store i64 %28, i64* %30, align 8
  ret void

Else:                                             ; preds = %Entry
  br label %EndIf

EndIf:                                            ; preds = %Else
  %31 = load i16, i16* %err, align 2
  store i16 %31, i16* %err10, align 2
  br label %BlockEnd

BlockEnd:                                         ; preds = %EndIf
  store i16 %31, i16* %err10, align 2
  %32 = load i16, i16* %err10, align 2
  switch i16 %32, label %SwitchElse [
    i16 0, label %SwitchProng
    i16 26, label %SwitchProng1
    i16 13, label %SwitchProng2
    i16 1, label %SwitchProng3
    i16 11, label %SwitchProng4
    i16 9, label %SwitchProng5
    i16 75, label %SwitchProng6
    i16 19, label %SwitchProng7
    i16 22, label %SwitchProng8
    i16 12, label %SwitchProng9
  ]

SwitchElse:                                       ; preds = %BlockEnd
  %33 = load i16, i16* %err10, align 2
  %34 = call fastcc i16 @std.os.unexpectedErrno(i16 %33)
  %35 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %0, i32 0, i32 1
  store i16 %34, i16* %35, align 2
  ret void

SwitchProng:                                      ; preds = %BlockEnd
  unreachable

SwitchProng1:                                     ; preds = %BlockEnd
  %36 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %0, i32 0, i32 1
  store i16 5, i16* %36, align 2
  ret void

SwitchProng2:                                     ; preds = %BlockEnd
  %37 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %0, i32 0, i32 1
  store i16 5, i16* %37, align 2
  ret void

SwitchProng3:                                     ; preds = %BlockEnd
  %38 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %0, i32 0, i32 1
  store i16 14, i16* %38, align 2
  ret void

SwitchProng4:                                     ; preds = %BlockEnd
  %39 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %0, i32 0, i32 1
  store i16 15, i16* %39, align 2
  ret void

SwitchProng5:                                     ; preds = %BlockEnd
  unreachable

SwitchProng6:                                     ; preds = %BlockEnd
  unreachable

SwitchProng7:                                     ; preds = %BlockEnd
  %40 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %0, i32 0, i32 1
  store i16 13, i16* %40, align 2
  ret void

SwitchProng8:                                     ; preds = %BlockEnd
  unreachable

SwitchProng9:                                     ; preds = %BlockEnd
  %41 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %0, i32 0, i32 1
  store i16 16, i16* %41, align 2
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i64 @std.mem.alignForward(i64 %0, i64 %1) unnamed_addr #1 {
Entry:
  %result = alloca i64, align 8
  %2 = alloca i64, align 8
  %3 = alloca i64, align 8
  %addr = alloca i64, align 8
  %alignment = alloca i64, align 8
  store i64 %0, i64* %addr, align 8
  store i64 %1, i64* %alignment, align 8
  %4 = load i64, i64* %addr, align 8
  store i64 %4, i64* %2, align 8
  %5 = load i64, i64* %alignment, align 8
  store i64 %5, i64* %3, align 8
  %6 = call fastcc i64 @std.mem.alignForwardGeneric(i64 %4, i64 %5)
  store i64 %6, i64* %result, align 8
  %7 = load i64, i64* %result, align 8
  ret i64 %7
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i64 @std.os.linux.tls.prepareTLS(%"[]u8"* nonnull readonly align 8 %0) unnamed_addr #1 {
Entry:
  %result = alloca i64, align 8
  %1 = alloca %"[]u8", align 8
  %2 = alloca i8*, align 8
  %dtv = alloca %std.os.linux.tls.DTV*, align 8
  %3 = alloca i8*, align 8
  %tcb_ptr = alloca i8**, align 8
  %4 = alloca %"[]u8", align 8
  %5 = alloca %"[]u8", align 8
  %6 = bitcast %"[]u8"* %0 to i8*
  %7 = bitcast %"[]u8"* %1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %7, i8* align 8 %6, i64 16, i1 false)
  call fastcc void @std.mem.set(%"[]u8"* %0, i8 0)
  %8 = getelementptr inbounds %"[]u8", %"[]u8"* %0, i32 0, i32 0
  %9 = load i8*, i8** %8, align 8
  %10 = load i64, i64* getelementptr inbounds (%std.os.linux.tls.TLSImage, %std.os.linux.tls.TLSImage* @tls_image, i32 0, i32 4), align 8
  %11 = getelementptr inbounds i8, i8* %9, i64 %10
  store i8* %11, i8** %2, align 8
  %12 = call fastcc %std.os.linux.tls.DTV* @std.os.linux.tls.alignPtrCast(i8* %11)
  store %std.os.linux.tls.DTV* %12, %std.os.linux.tls.DTV** %dtv, align 8
  %13 = load %std.os.linux.tls.DTV*, %std.os.linux.tls.DTV** %dtv, align 8
  %14 = getelementptr inbounds %std.os.linux.tls.DTV, %std.os.linux.tls.DTV* %13, i32 0, i32 0
  store i64 1, i64* %14, align 8
  %15 = load %std.os.linux.tls.DTV*, %std.os.linux.tls.DTV** %dtv, align 8
  %16 = getelementptr inbounds %std.os.linux.tls.DTV, %std.os.linux.tls.DTV* %15, i32 0, i32 1
  %17 = getelementptr inbounds [1 x i8*], [1 x i8*]* %16, i64 0, i64 0
  %18 = getelementptr inbounds %"[]u8", %"[]u8"* %0, i32 0, i32 0
  %19 = load i8*, i8** %18, align 8
  %20 = load i64, i64* getelementptr inbounds (%std.os.linux.tls.TLSImage, %std.os.linux.tls.TLSImage* @tls_image, i32 0, i32 5), align 8
  %21 = getelementptr inbounds i8, i8* %19, i64 %20
  store i8* %21, i8** %17, align 8
  %22 = getelementptr inbounds %"[]u8", %"[]u8"* %0, i32 0, i32 0
  %23 = load i8*, i8** %22, align 8
  %24 = load i64, i64* getelementptr inbounds (%std.os.linux.tls.TLSImage, %std.os.linux.tls.TLSImage* @tls_image, i32 0, i32 3), align 8
  %25 = getelementptr inbounds i8, i8* %23, i64 %24
  store i8* %25, i8** %3, align 8
  %26 = call fastcc i8** @std.os.linux.tls.alignPtrCast.29(i8* %25)
  store i8** %26, i8*** %tcb_ptr, align 8
  %27 = load i8**, i8*** %tcb_ptr, align 8
  %28 = getelementptr inbounds %"[]u8", %"[]u8"* %0, i32 0, i32 0
  %29 = load i8*, i8** %28, align 8
  %30 = load i64, i64* getelementptr inbounds (%std.os.linux.tls.TLSImage, %std.os.linux.tls.TLSImage* @tls_image, i32 0, i32 3), align 8
  %31 = getelementptr inbounds i8, i8* %29, i64 %30
  store i8* %31, i8** %27, align 8
  %32 = load i64, i64* getelementptr inbounds (%std.os.linux.tls.TLSImage, %std.os.linux.tls.TLSImage* @tls_image, i32 0, i32 5), align 8
  %33 = getelementptr inbounds %"[]u8", %"[]u8"* %0, i32 0, i32 1
  %34 = load i64, i64* %33, align 8
  %35 = getelementptr inbounds %"[]u8", %"[]u8"* %0, i32 0, i32 0
  %36 = load i8*, i8** %35, align 8
  %37 = getelementptr inbounds i8, i8* %36, i64 %32
  %38 = sub nuw i64 %34, %32
  %39 = getelementptr inbounds %"[]u8", %"[]u8"* %4, i32 0, i32 0
  store i8* %37, i8** %39, align 8
  %40 = getelementptr inbounds %"[]u8", %"[]u8"* %4, i32 0, i32 1
  store i64 %38, i64* %40, align 8
  %41 = bitcast %"[]u8"* %5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %41, i8* align 8 bitcast (%std.os.linux.tls.TLSImage* @tls_image to i8*), i64 16, i1 false)
  call fastcc void @std.mem.copy(%"[]u8"* %4, %"[]u8"* getelementptr inbounds (%std.os.linux.tls.TLSImage, %std.os.linux.tls.TLSImage* @tls_image, i32 0, i32 0))
  %42 = getelementptr inbounds %"[]u8", %"[]u8"* %0, i32 0, i32 0
  %43 = load i8*, i8** %42, align 8
  %44 = ptrtoint i8* %43 to i64
  %45 = add i64 %44, 0
  %46 = load i64, i64* getelementptr inbounds (%std.os.linux.tls.TLSImage, %std.os.linux.tls.TLSImage* @tls_image, i32 0, i32 3), align 8
  %47 = add i64 %45, %46
  store i64 %47, i64* %result, align 8
  %48 = load i64, i64* %result, align 8
  ret i64 %48
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.os.linux.tls.setThreadPointer(i64 %0) unnamed_addr #1 {
Entry:
  %rc = alloca i64, align 8
  %addr = alloca i64, align 8
  store i64 %0, i64* %addr, align 8
  %1 = load i64, i64* %addr, align 8
  %2 = call fastcc i64 @std.os.linux.x86_64.syscall2(i64 158, i64 4098, i64 %1)
  store i64 %2, i64* %rc, align 8
  %3 = load i64, i64* %rc, align 8
  %4 = icmp eq i64 %3, 0
  call fastcc void @std.debug.assert(i1 %4)
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.os.setrlimit(i32 %0, %std.os.linux.rlimit* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %2 = alloca i16, align 2
  %err = alloca i16, align 2
  %resource = alloca i32, align 4
  store i32 %0, i32* %resource, align 4
  %3 = load i32, i32* %resource, align 4
  %4 = call fastcc i64 @std.os.linux.setrlimit(i32 %3, %std.os.linux.rlimit* %1)
  %5 = call fastcc i16 @std.os.linux.getErrno(i64 %4)
  store i16 %5, i16* %2, align 2
  switch i16 %5, label %SwitchElse [
    i16 0, label %SwitchProng
    i16 14, label %SwitchProng1
    i16 22, label %SwitchProng2
    i16 1, label %SwitchProng3
  ]

SwitchElse:                                       ; preds = %Entry
  store i16 %5, i16* %err, align 2
  %6 = load i16, i16* %err, align 2
  %7 = call fastcc i16 @std.os.unexpectedErrno(i16 %6)
  store i16 %7, i16* %result, align 2
  %8 = load i16, i16* %result, align 2
  ret i16 %8

SwitchProng:                                      ; preds = %Entry
  store i16 0, i16* %result, align 2
  %9 = load i16, i16* %result, align 2
  ret i16 %9

SwitchProng1:                                     ; preds = %Entry
  unreachable

SwitchProng2:                                     ; preds = %Entry
  store i16 17, i16* %result, align 2
  %10 = load i16, i16* %result, align 2
  ret i16 %10

SwitchProng3:                                     ; preds = %Entry
  store i16 14, i16* %result, align 2
  %11 = load i16, i16* %result, align 2
  ret i16 %11
}

; Function Attrs: minsize nobuiltin noreturn nounwind optsize
define internal fastcc void @std.os.linux.exit_group(i32 %0) unnamed_addr #2 {
Entry:
  %status = alloca i32, align 4
  store i32 %0, i32* %status, align 4
  %1 = load i32, i32* %status, align 4
  %2 = sext i32 %1 to i64
  %3 = sext i32 %1 to i64
  %4 = call fastcc i64 @std.os.linux.x86_64.syscall1(i64 231, i64 %3)
  unreachable
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.debug.maybeEnableSegfaultHandler() unnamed_addr #1 {
Entry:
  ret void
}

; Function Attrs: alwaysinline minsize nobuiltin nounwind optsize
define internal fastcc i8 @std.start.initEventLoopAndCallMain() unnamed_addr #7 {
Entry:
  %result = alloca i8, align 1
  %0 = call fastcc i8 @std.start.callMain() #10
  store i8 %0, i8* %result, align 1
  %1 = load i8, i8* %result, align 1
  ret i8 %1
}

; Function Attrs: cold minsize nobuiltin nounwind optsize
define internal fastcc void @std.Thread.Mutex.AtomicMutex.lockSlow(%std.Thread.Mutex.AtomicMutex* nonnull align 4 %0, i32 %1) unnamed_addr #8 {
Entry:
  %new_state = alloca i32, align 4
  %spin = alloca i8, align 1
  %2 = alloca %"?std.Thread.Mutex.State", align 4
  %state = alloca i32, align 4
  %3 = alloca i8, align 1
  %iter = alloca i8, align 1
  %4 = alloca i32, align 4
  %5 = alloca i16, align 2
  %m = alloca %std.Thread.Mutex.AtomicMutex*, align 8
  %current_state = alloca i32, align 4
  store %std.Thread.Mutex.AtomicMutex* %0, %std.Thread.Mutex.AtomicMutex** %m, align 8
  store i32 %1, i32* %current_state, align 4
  %6 = load i32, i32* %current_state, align 4
  store i32 %6, i32* %new_state, align 4
  store i8 0, i8* %spin, align 1
  br label %WhileCond

WhileCond:                                        ; preds = %WhileEnd, %Entry
  %7 = load i8, i8* %spin, align 1
  %8 = icmp ult i8 %7, 100
  br i1 %8, label %WhileBody, label %WhileEnd5

WhileBody:                                        ; preds = %WhileCond
  %9 = load %std.Thread.Mutex.AtomicMutex*, %std.Thread.Mutex.AtomicMutex** %m, align 8
  %10 = getelementptr inbounds %std.Thread.Mutex.AtomicMutex, %std.Thread.Mutex.AtomicMutex* %9, i32 0, i32 0
  %11 = load i32, i32* %new_state, align 4
  %12 = cmpxchg weak i32* %10, i32 0, i32 %11 acquire monotonic, align 4
  %13 = extractvalue { i32, i1 } %12, 0
  %14 = getelementptr inbounds %"?std.Thread.Mutex.State", %"?std.Thread.Mutex.State"* %2, i32 0, i32 0
  store i32 %13, i32* %14, align 4
  %15 = extractvalue { i32, i1 } %12, 1
  %16 = xor i1 %15, true
  %17 = getelementptr inbounds %"?std.Thread.Mutex.State", %"?std.Thread.Mutex.State"* %2, i32 0, i32 1
  store i1 %16, i1* %17, align 1
  %18 = getelementptr inbounds %"?std.Thread.Mutex.State", %"?std.Thread.Mutex.State"* %2, i32 0, i32 1
  %19 = load i1, i1* %18, align 1
  br i1 %19, label %OptionalNonNull, label %OptionalNull

OptionalNull:                                     ; preds = %WhileBody
  ret void

OptionalNonNull:                                  ; preds = %WhileBody
  %20 = getelementptr inbounds %"?std.Thread.Mutex.State", %"?std.Thread.Mutex.State"* %2, i32 0, i32 0
  %21 = load i32, i32* %20, align 4
  store i32 %21, i32* %state, align 4
  br label %OptionalEnd

OptionalEnd:                                      ; preds = %OptionalNonNull
  %22 = load i32, i32* %state, align 4
  switch i32 %22, label %SwitchElse [
    i32 0, label %SwitchProng1
    i32 1, label %SwitchProng2
    i32 2, label %SwitchProng
  ]

SwitchProng:                                      ; preds = %OptionalEnd
  br label %WhileEnd5

SwitchElse:                                       ; preds = %OptionalEnd
  unreachable

SwitchProng1:                                     ; preds = %OptionalEnd
  br label %SwitchEnd

SwitchProng2:                                     ; preds = %OptionalEnd
  br label %SwitchEnd

SwitchEnd:                                        ; preds = %SwitchProng2, %SwitchProng1
  %23 = load i8, i8* %spin, align 1
  %24 = add nuw i8 %23, 1
  store i8 %24, i8* %3, align 1
  %25 = call fastcc i8 @std.math.min(i8 %24)
  store i8 %25, i8* %iter, align 1
  br label %WhileCond3

WhileCond3:                                       ; preds = %WhileBody4, %SwitchEnd
  %26 = load i8, i8* %iter, align 1
  %27 = icmp ugt i8 %26, 0
  br i1 %27, label %WhileBody4, label %WhileEnd

WhileBody4:                                       ; preds = %WhileCond3
  call fastcc void @std.atomic.spinLoopHint()
  %28 = load i8, i8* %iter, align 1
  %29 = sub nuw i8 %28, 1
  store i8 %29, i8* %iter, align 1
  br label %WhileCond3

WhileEnd:                                         ; preds = %WhileCond3
  %30 = load i8, i8* %spin, align 1
  %31 = add nuw i8 %30, 1
  store i8 %31, i8* %spin, align 1
  br label %WhileCond

WhileEnd5:                                        ; preds = %SwitchProng, %WhileCond
  store i32 2, i32* %new_state, align 4
  br label %WhileCond6

WhileCond6:                                       ; preds = %SwitchEnd15, %WhileEnd5
  br label %WhileBody7

WhileBody7:                                       ; preds = %WhileCond6
  %32 = load %std.Thread.Mutex.AtomicMutex*, %std.Thread.Mutex.AtomicMutex** %m, align 8
  %33 = getelementptr inbounds %std.Thread.Mutex.AtomicMutex, %std.Thread.Mutex.AtomicMutex* %32, i32 0, i32 0
  %34 = load i32, i32* %new_state, align 4
  %35 = atomicrmw xchg i32* %33, i32 %34 acquire, align 4
  store i32 %35, i32* %4, align 4
  switch i32 %35, label %SwitchElse9 [
    i32 0, label %SwitchProng8
  ]

SwitchProng8:                                     ; preds = %WhileBody7
  ret void

SwitchElse9:                                      ; preds = %WhileBody7
  br label %SwitchEnd10

SwitchEnd10:                                      ; preds = %SwitchElse9
  %36 = load %std.Thread.Mutex.AtomicMutex*, %std.Thread.Mutex.AtomicMutex** %m, align 8
  %37 = getelementptr inbounds %std.Thread.Mutex.AtomicMutex, %std.Thread.Mutex.AtomicMutex* %36, i32 0, i32 0
  %38 = load i32, i32* %new_state, align 4
  %39 = call fastcc i64 @std.os.linux.futex_wait(i32* %37, i32 128, i32 %38, %std.os.linux.timespec* null)
  %40 = call fastcc i16 @std.os.linux.getErrno(i64 %39)
  store i16 %40, i16* %5, align 2
  switch i16 %40, label %SwitchElse11 [
    i16 0, label %SwitchProng12
    i16 4, label %SwitchProng13
    i16 11, label %SwitchProng14
  ]

SwitchElse11:                                     ; preds = %SwitchEnd10
  unreachable

SwitchProng12:                                    ; preds = %SwitchEnd10
  br label %SwitchEnd15

SwitchProng13:                                    ; preds = %SwitchEnd10
  br label %SwitchEnd15

SwitchProng14:                                    ; preds = %SwitchEnd10
  br label %SwitchEnd15

SwitchEnd15:                                      ; preds = %SwitchProng14, %SwitchProng13, %SwitchProng12
  br label %WhileCond6
}

; Function Attrs: nofree nosync nounwind readnone speculatable willreturn
declare i64 @llvm.umin.i64(i64 %0, i64 %1) #9

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i64 @std.os.linux.write(i32 %0, i8* nonnull readonly align 1 %1, i64 %2) unnamed_addr #1 {
Entry:
  %result = alloca i64, align 8
  %fd = alloca i32, align 4
  %buf = alloca i8*, align 8
  %count = alloca i64, align 8
  store i32 %0, i32* %fd, align 4
  store i8* %1, i8** %buf, align 8
  store i64 %2, i64* %count, align 8
  %3 = load i32, i32* %fd, align 4
  %4 = sext i32 %3 to i64
  %5 = sext i32 %3 to i64
  %6 = load i8*, i8** %buf, align 8
  %7 = ptrtoint i8* %6 to i64
  %8 = load i64, i64* %count, align 8
  %9 = call fastcc i64 @std.os.linux.x86_64.syscall3(i64 1, i64 %5, i64 %7, i64 %8)
  store i64 %9, i64* %result, align 8
  %10 = load i64, i64* %result, align 8
  ret i64 %10
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.os.unexpectedErrno(i16 %0) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %err = alloca i16, align 2
  store i16 %0, i16* %err, align 2
  store i16 12, i16* %result, align 2
  %1 = load i16, i16* %result, align 2
  ret i16 %1
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i32 @std.os.linux.gettid() unnamed_addr #1 {
Entry:
  %result = alloca i32, align 4
  %0 = call fastcc i64 @std.os.linux.x86_64.syscall0(i64 186)
  %1 = trunc i64 %0 to i32
  store i32 %1, i32* %result, align 4
  %2 = load i32, i32* %result, align 4
  ret i32 %2
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).writeAll"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %0, %"[]u8"* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %index = alloca i64, align 8
  %2 = alloca %"[]u8", align 8
  %3 = alloca { i64, i16 }, align 8
  store i64 0, i64* %index, align 8
  br label %WhileCond

WhileCond:                                        ; preds = %ErrRetContinue, %Entry
  %4 = load i64, i64* %index, align 8
  %5 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 1
  %6 = load i64, i64* %5, align 8
  %7 = icmp ne i64 %4, %6
  br i1 %7, label %WhileBody, label %WhileEnd

WhileBody:                                        ; preds = %WhileCond
  %8 = load i64, i64* %index, align 8
  %9 = load i64, i64* %index, align 8
  %10 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 1
  %11 = load i64, i64* %10, align 8
  %12 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 0
  %13 = load i8*, i8** %12, align 8
  %14 = getelementptr inbounds i8, i8* %13, i64 %9
  %15 = sub nuw i64 %11, %9
  %16 = getelementptr inbounds %"[]u8", %"[]u8"* %2, i32 0, i32 0
  store i8* %14, i8** %16, align 8
  %17 = getelementptr inbounds %"[]u8", %"[]u8"* %2, i32 0, i32 1
  store i64 %15, i64* %17, align 8
  call fastcc void @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).write"({ i64, i16 }* sret({ i64, i16 }) %3, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0, %"[]u8"* %2)
  %18 = getelementptr inbounds { i64, i16 }, { i64, i16 }* %3, i32 0, i32 1
  %19 = load i16, i16* %18, align 2
  %20 = icmp ne i16 %19, 0
  br i1 %20, label %ErrRetReturn, label %ErrRetContinue

ErrRetReturn:                                     ; preds = %WhileBody
  %21 = getelementptr inbounds { i64, i16 }, { i64, i16 }* %3, i32 0, i32 1
  %22 = load i16, i16* %21, align 2
  store i16 %22, i16* %result, align 2
  ret i16 %22

ErrRetContinue:                                   ; preds = %WhileBody
  %23 = getelementptr inbounds { i64, i16 }, { i64, i16 }* %3, i32 0, i32 0
  %24 = load i64, i64* %23, align 8
  %25 = add nuw i64 %8, %24
  store i64 %25, i64* %index, align 8
  br label %WhileCond

WhileEnd:                                         ; preds = %WhileCond
  store i16 0, i16* %result, align 2
  ret i16 0
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.formatType(i64 %0, %std.fmt.FormatOptions* nonnull readonly align 8 %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %2, i64 %3) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %4 = alloca i64, align 8
  %5 = alloca %std.fmt.FormatOptions, align 8
  %6 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %value = alloca i64, align 8
  %max_depth = alloca i64, align 8
  store i64 %0, i64* %value, align 8
  store i64 %3, i64* %max_depth, align 8
  %7 = load i64, i64* %value, align 8
  store i64 %7, i64* %4, align 8
  %8 = bitcast %std.fmt.FormatOptions* %1 to i8*
  %9 = bitcast %std.fmt.FormatOptions* %5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %9, i8* align 8 %8, i64 40, i1 false)
  %10 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2 to i8*
  %11 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %6 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %11, i8* align 4 %10, i64 4, i1 false)
  %12 = call fastcc i16 @std.fmt.formatValue(i64 %7, %std.fmt.FormatOptions* %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2)
  store i16 %12, i16* %result, align 2
  %13 = load i16, i16* %result, align 2
  ret i16 %13
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).write"({ i64, i16 }* nonnull sret({ i64, i16 }) %0, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %1, %"[]u8"* nonnull readonly align 8 %2) unnamed_addr #1 {
Entry:
  %3 = getelementptr inbounds %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %1, i32 0, i32 0
  call fastcc void @std.fs.file.File.write({ i64, i16 }* sret({ i64, i16 }) %0, %std.fs.file.File* %3, %"[]u8"* %2)
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.formatValue(i64 %0, %std.fmt.FormatOptions* nonnull readonly align 8 %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %2) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %3 = alloca i64, align 8
  %4 = alloca %std.fmt.FormatOptions, align 8
  %5 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %value = alloca i64, align 8
  store i64 %0, i64* %value, align 8
  %6 = load i64, i64* %value, align 8
  store i64 %6, i64* %3, align 8
  %7 = bitcast %std.fmt.FormatOptions* %1 to i8*
  %8 = bitcast %std.fmt.FormatOptions* %4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %8, i8* align 8 %7, i64 40, i1 false)
  %9 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2 to i8*
  %10 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %10, i8* align 4 %9, i64 4, i1 false)
  %11 = call fastcc i16 @std.fmt.formatIntValue(i64 %6, %std.fmt.FormatOptions* %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2)
  store i16 %11, i16* %result, align 2
  %12 = load i16, i16* %result, align 2
  ret i16 %12
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i64 @std.os.linux.sigprocmask(i32 %0, [32 x i32]* noalias align 4 %1, [32 x i32]* noalias align 4 %2) unnamed_addr #1 {
Entry:
  %result = alloca i64, align 8
  %flags = alloca i32, align 4
  %set = alloca [32 x i32]*, align 8
  %oldset = alloca [32 x i32]*, align 8
  store i32 %0, i32* %flags, align 4
  store [32 x i32]* %1, [32 x i32]** %set, align 8
  store [32 x i32]* %2, [32 x i32]** %oldset, align 8
  %3 = load i32, i32* %flags, align 4
  %4 = zext i32 %3 to i64
  %5 = load [32 x i32]*, [32 x i32]** %set, align 8
  %6 = ptrtoint [32 x i32]* %5 to i64
  %7 = load [32 x i32]*, [32 x i32]** %oldset, align 8
  %8 = ptrtoint [32 x i32]* %7 to i64
  %9 = call fastcc i64 @std.os.linux.x86_64.syscall4(i64 14, i64 %4, i64 %6, i64 %8, i64 8)
  store i64 %9, i64* %result, align 8
  %10 = load i64, i64* %result, align 8
  ret i64 %10
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i64 @std.os.linux.tkill(i32 %0, i32 %1) unnamed_addr #1 {
Entry:
  %result = alloca i64, align 8
  %tid = alloca i32, align 4
  %sig = alloca i32, align 4
  store i32 %0, i32* %tid, align 4
  store i32 %1, i32* %sig, align 4
  %2 = load i32, i32* %tid, align 4
  %3 = sext i32 %2 to i64
  %4 = sext i32 %2 to i64
  %5 = load i32, i32* %sig, align 4
  %6 = sext i32 %5 to i64
  %7 = sext i32 %5 to i64
  %8 = call fastcc i64 @std.os.linux.x86_64.syscall2(i64 200, i64 %4, i64 %7)
  store i64 %8, i64* %result, align 8
  %9 = load i64, i64* %result, align 8
  ret i64 %9
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i1 @std.target.Arch.isSPARC(i6 %0) unnamed_addr #1 {
Entry:
  %result = alloca i1, align 1
  %arch = alloca i6, align 1
  store i6 %0, i6* %arch, align 1
  %1 = load i6, i6* %arch, align 1
  switch i6 %1, label %SwitchElse [
    i6 25, label %SwitchProng
    i6 27, label %SwitchProng
    i6 26, label %SwitchProng
  ]

SwitchElse:                                       ; preds = %Entry
  store i1 false, i1* %result, align 1
  br label %SwitchEnd

SwitchProng:                                      ; preds = %Entry, %Entry, %Entry
  store i1 true, i1* %result, align 1
  br label %SwitchEnd

SwitchEnd:                                        ; preds = %SwitchProng, %SwitchElse
  %2 = load i1, i1* %result, align 1
  ret i1 %2
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.formatType.26(%"[]u8"* nonnull readonly align 8 %0, %std.fmt.FormatOptions* nonnull readonly align 8 %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %2, i64 %3) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %4 = alloca %std.fmt.FormatOptions, align 8
  %5 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %max_depth = alloca i64, align 8
  store i64 %3, i64* %max_depth, align 8
  %6 = load i64, i64* %max_depth, align 8
  %7 = icmp eq i64 %6, 0
  br i1 %7, label %Then, label %Else

Then:                                             ; preds = %Entry
  %8 = call fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).writeAll"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2, %"[]u8"* @79)
  store i16 %8, i16* %result, align 2
  %9 = load i16, i16* %result, align 2
  ret i16 %9

Else:                                             ; preds = %Entry
  br label %EndIf

EndIf:                                            ; preds = %Else
  %10 = bitcast %std.fmt.FormatOptions* %1 to i8*
  %11 = bitcast %std.fmt.FormatOptions* %4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %11, i8* align 8 %10, i64 40, i1 false)
  %12 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2 to i8*
  %13 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %13, i8* align 4 %12, i64 4, i1 false)
  %14 = call fastcc i16 @std.fmt.formatText(%"[]u8"* %0, %std.fmt.FormatOptions* %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2)
  store i16 %14, i16* %result, align 2
  %15 = load i16, i16* %result, align 2
  ret i16 %15
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.formatText(%"[]u8"* nonnull readonly align 8 %0, %std.fmt.FormatOptions* nonnull readonly align 8 %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %2) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %3 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %4 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2 to i8*
  %5 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %5, i8* align 4 %4, i64 4, i1 false)
  %6 = call fastcc i16 @std.fmt.formatBuf(%"[]u8"* %0, %std.fmt.FormatOptions* %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2)
  store i16 %6, i16* %result, align 2
  %7 = load i16, i16* %result, align 2
  ret i16 %7
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.format.27(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %0) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %options = alloca %std.fmt.FormatOptions, align 8
  %1 = alloca i16, align 2
  %2 = bitcast %std.fmt.FormatOptions* %options to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %2, i8* align 8 bitcast ({ %"?usize", %"?usize", i2, <{ i8, [6 x i8] }> }* @87 to i8*), i64 40, i1 false)
  %3 = call fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).writeAll"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0, %"[]u8"* @89)
  store i16 %3, i16* %1, align 2
  %4 = icmp ne i16 %3, 0
  br i1 %4, label %ErrRetReturn, label %ErrRetContinue

ErrRetReturn:                                     ; preds = %Entry
  %5 = load i16, i16* %1, align 2
  store i16 %5, i16* %result, align 2
  ret i16 %5

ErrRetContinue:                                   ; preds = %Entry
  store i16 0, i16* %result, align 2
  ret i16 0
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.format.28(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %0) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %options = alloca %std.fmt.FormatOptions, align 8
  %1 = alloca i16, align 2
  %2 = bitcast %std.fmt.FormatOptions* %options to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %2, i8* align 8 bitcast ({ %"?usize", %"?usize", i2, <{ i8, [6 x i8] }> }* @90 to i8*), i64 40, i1 false)
  %3 = call fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).writeAll"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0, %"[]u8"* @91)
  store i16 %3, i16* %1, align 2
  %4 = icmp ne i16 %3, 0
  br i1 %4, label %ErrRetReturn, label %ErrRetContinue

ErrRetReturn:                                     ; preds = %Entry
  %5 = load i16, i16* %1, align 2
  store i16 %5, i16* %result, align 2
  ret i16 %5

ErrRetContinue:                                   ; preds = %Entry
  store i16 0, i16* %result, align 2
  ret i16 0
}

; Function Attrs: cold minsize nobuiltin nounwind optsize
define internal fastcc void @std.Thread.Mutex.AtomicMutex.unlockSlow(%std.Thread.Mutex.AtomicMutex* nonnull align 4 %0) unnamed_addr #8 {
Entry:
  %1 = alloca i16, align 2
  %m = alloca %std.Thread.Mutex.AtomicMutex*, align 8
  store %std.Thread.Mutex.AtomicMutex* %0, %std.Thread.Mutex.AtomicMutex** %m, align 8
  %2 = load %std.Thread.Mutex.AtomicMutex*, %std.Thread.Mutex.AtomicMutex** %m, align 8
  %3 = getelementptr inbounds %std.Thread.Mutex.AtomicMutex, %std.Thread.Mutex.AtomicMutex* %2, i32 0, i32 0
  %4 = call fastcc i64 @std.os.linux.futex_wake(i32* %3, i32 129, i32 1)
  %5 = call fastcc i16 @std.os.linux.getErrno(i64 %4)
  store i16 %5, i16* %1, align 2
  switch i16 %5, label %SwitchElse [
    i16 0, label %SwitchProng1
    i16 14, label %SwitchProng
  ]

SwitchElse:                                       ; preds = %Entry
  unreachable

SwitchProng:                                      ; preds = %Entry
  unreachable

SwitchProng1:                                     ; preds = %Entry
  br label %SwitchEnd

SwitchEnd:                                        ; preds = %SwitchProng1
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i1 @std.Thread.StaticResetEvent.AtomicEvent.timedWait(%std.Thread.StaticResetEvent.AtomicEvent* nonnull align 4 %0, %"?u64"* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %result = alloca i1, align 1
  %waiters = alloca i32, align 4
  %2 = alloca %"?u32", align 4
  %3 = alloca i16, align 2
  %_ = alloca i16, align 2
  %ev = alloca %std.Thread.StaticResetEvent.AtomicEvent*, align 8
  store %std.Thread.StaticResetEvent.AtomicEvent* %0, %std.Thread.StaticResetEvent.AtomicEvent** %ev, align 8
  %4 = load %std.Thread.StaticResetEvent.AtomicEvent*, %std.Thread.StaticResetEvent.AtomicEvent** %ev, align 8
  %5 = getelementptr inbounds %std.Thread.StaticResetEvent.AtomicEvent, %std.Thread.StaticResetEvent.AtomicEvent* %4, i32 0, i32 0
  %6 = load atomic i32, i32* %5 acquire, align 4
  store i32 %6, i32* %waiters, align 4
  br label %WhileCond

WhileCond:                                        ; preds = %OptionalEnd, %Entry
  %7 = load i32, i32* %waiters, align 4
  %8 = icmp ne i32 %7, 1
  br i1 %8, label %WhileBody, label %WhileEnd

WhileBody:                                        ; preds = %WhileCond
  %9 = load %std.Thread.StaticResetEvent.AtomicEvent*, %std.Thread.StaticResetEvent.AtomicEvent** %ev, align 8
  %10 = getelementptr inbounds %std.Thread.StaticResetEvent.AtomicEvent, %std.Thread.StaticResetEvent.AtomicEvent* %9, i32 0, i32 0
  %11 = load i32, i32* %waiters, align 4
  %12 = load i32, i32* %waiters, align 4
  %13 = add nuw i32 %12, 2
  %14 = cmpxchg weak i32* %10, i32 %11, i32 %13 acquire acquire, align 4
  %15 = extractvalue { i32, i1 } %14, 0
  %16 = getelementptr inbounds %"?u32", %"?u32"* %2, i32 0, i32 0
  store i32 %15, i32* %16, align 4
  %17 = extractvalue { i32, i1 } %14, 1
  %18 = xor i1 %17, true
  %19 = getelementptr inbounds %"?u32", %"?u32"* %2, i32 0, i32 1
  store i1 %18, i1* %19, align 1
  %20 = getelementptr inbounds %"?u32", %"?u32"* %2, i32 0, i32 1
  %21 = load i1, i1* %20, align 1
  br i1 %21, label %OptionalNonNull, label %OptionalNull

OptionalNull:                                     ; preds = %WhileBody
  %22 = load %std.Thread.StaticResetEvent.AtomicEvent*, %std.Thread.StaticResetEvent.AtomicEvent** %ev, align 8
  %23 = getelementptr inbounds %std.Thread.StaticResetEvent.AtomicEvent, %std.Thread.StaticResetEvent.AtomicEvent* %22, i32 0, i32 0
  %24 = call fastcc i16 @std.Thread.StaticResetEvent.LinuxFutex.wait(i32* %23, %"?u64"* %1)
  store i16 %24, i16* %3, align 2
  %25 = icmp ne i16 %24, 0
  br i1 %25, label %TryElse, label %TryOk

TryOk:                                            ; preds = %OptionalNull
  store i1 false, i1* %result, align 1
  %26 = load i1, i1* %result, align 1
  ret i1 %26

TryElse:                                          ; preds = %OptionalNull
  %27 = load i16, i16* %3, align 2
  store i16 %27, i16* %_, align 2
  store i1 true, i1* %result, align 1
  %28 = load i1, i1* %result, align 1
  ret i1 %28

OptionalNonNull:                                  ; preds = %WhileBody
  %29 = getelementptr inbounds %"?u32", %"?u32"* %2, i32 0, i32 0
  %30 = load i32, i32* %29, align 4
  store i32 %30, i32* %waiters, align 4
  br label %OptionalEnd

OptionalEnd:                                      ; preds = %OptionalNonNull
  br label %WhileCond

WhileEnd:                                         ; preds = %WhileCond
  store i1 false, i1* %result, align 1
  %31 = load i1, i1* %result, align 1
  ret i1 %31
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i64 @std.os.linux.mmap(i8* align 1 %0, i64 %1, i64 %2, i32 %3, i32 %4, i64 %5) unnamed_addr #1 {
Entry:
  %result = alloca i64, align 8
  %address = alloca i8*, align 8
  %length = alloca i64, align 8
  %prot = alloca i64, align 8
  %flags = alloca i32, align 4
  %fd = alloca i32, align 4
  %offset = alloca i64, align 8
  store i8* %0, i8** %address, align 8
  store i64 %1, i64* %length, align 8
  store i64 %2, i64* %prot, align 8
  store i32 %3, i32* %flags, align 4
  store i32 %4, i32* %fd, align 4
  store i64 %5, i64* %offset, align 8
  %6 = load i8*, i8** %address, align 8
  %7 = ptrtoint i8* %6 to i64
  %8 = load i64, i64* %length, align 8
  %9 = load i64, i64* %prot, align 8
  %10 = load i32, i32* %flags, align 4
  %11 = zext i32 %10 to i64
  %12 = load i32, i32* %fd, align 4
  %13 = sext i32 %12 to i64
  %14 = sext i32 %12 to i64
  %15 = load i64, i64* %offset, align 8
  %16 = call fastcc i64 @std.os.linux.x86_64.syscall6(i64 9, i64 %7, i64 %8, i64 %9, i64 %11, i64 %14, i64 %15)
  store i64 %16, i64* %result, align 8
  %17 = load i64, i64* %result, align 8
  ret i64 %17
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i64 @std.mem.alignForwardGeneric(i64 %0, i64 %1) unnamed_addr #1 {
Entry:
  %result = alloca i64, align 8
  %2 = alloca i64, align 8
  %3 = alloca i64, align 8
  %addr = alloca i64, align 8
  %alignment = alloca i64, align 8
  store i64 %0, i64* %addr, align 8
  store i64 %1, i64* %alignment, align 8
  %4 = load i64, i64* %addr, align 8
  %5 = load i64, i64* %alignment, align 8
  %6 = sub nuw i64 %5, 1
  %7 = add nuw i64 %4, %6
  store i64 %7, i64* %2, align 8
  %8 = load i64, i64* %alignment, align 8
  store i64 %8, i64* %3, align 8
  %9 = call fastcc i64 @std.mem.alignBackwardGeneric(i64 %7, i64 %8)
  store i64 %9, i64* %result, align 8
  %10 = load i64, i64* %result, align 8
  ret i64 %10
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.mem.set(%"[]u8"* nonnull readonly align 8 %0, i8 %1) unnamed_addr #1 {
Entry:
  %i = alloca i64, align 8
  %d = alloca i8*, align 8
  %value = alloca i8, align 1
  store i8 %1, i8* %value, align 1
  store i64 0, i64* %i, align 8
  %2 = getelementptr inbounds %"[]u8", %"[]u8"* %0, i32 0, i32 1
  %3 = load i64, i64* %2, align 8
  br label %ForCond

ForCond:                                          ; preds = %ForBody, %Entry
  %4 = load i64, i64* %i, align 8
  %5 = icmp ult i64 %4, %3
  br i1 %5, label %ForBody, label %ForEnd

ForBody:                                          ; preds = %ForCond
  %6 = getelementptr inbounds %"[]u8", %"[]u8"* %0, i32 0, i32 0
  %7 = load i8*, i8** %6, align 8
  %8 = getelementptr inbounds i8, i8* %7, i64 %4
  store i8* %8, i8** %d, align 8
  %9 = load i8*, i8** %d, align 8
  %10 = load i8, i8* %value, align 1
  store i8 %10, i8* %9, align 1
  %11 = add nuw i64 %4, 1
  store i64 %11, i64* %i, align 8
  br label %ForCond

ForEnd:                                           ; preds = %ForCond
  ret void
}

; Function Attrs: alwaysinline minsize nobuiltin nounwind optsize
define internal fastcc nonnull %std.os.linux.tls.DTV* @std.os.linux.tls.alignPtrCast(i8* nonnull align 1 %0) unnamed_addr #7 {
Entry:
  %result = alloca %std.os.linux.tls.DTV*, align 8
  %ptr = alloca i8*, align 8
  store i8* %0, i8** %ptr, align 8
  %1 = load i8*, i8** %ptr, align 8
  %2 = bitcast i8* %1 to %std.os.linux.tls.DTV*
  store %std.os.linux.tls.DTV* %2, %std.os.linux.tls.DTV** %result, align 8
  %3 = load %std.os.linux.tls.DTV*, %std.os.linux.tls.DTV** %result, align 8
  ret %std.os.linux.tls.DTV* %3
}

; Function Attrs: alwaysinline minsize nobuiltin nounwind optsize
define internal fastcc nonnull i8** @std.os.linux.tls.alignPtrCast.29(i8* nonnull align 1 %0) unnamed_addr #7 {
Entry:
  %result = alloca i8**, align 8
  %ptr = alloca i8*, align 8
  store i8* %0, i8** %ptr, align 8
  %1 = load i8*, i8** %ptr, align 8
  %2 = bitcast i8* %1 to i8**
  store i8** %2, i8*** %result, align 8
  %3 = load i8**, i8*** %result, align 8
  ret i8** %3
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.mem.copy(%"[]u8"* nonnull readonly align 8 %0, %"[]u8"* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %i = alloca i64, align 8
  %s = alloca i8, align 1
  %2 = getelementptr inbounds %"[]u8", %"[]u8"* %0, i32 0, i32 1
  %3 = load i64, i64* %2, align 8
  %4 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 1
  %5 = load i64, i64* %4, align 8
  %6 = icmp uge i64 %3, %5
  call fastcc void @std.debug.assert(i1 %6)
  store i64 0, i64* %i, align 8
  %7 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 1
  %8 = load i64, i64* %7, align 8
  br label %ForCond

ForCond:                                          ; preds = %ForBody, %Entry
  %9 = load i64, i64* %i, align 8
  %10 = icmp ult i64 %9, %8
  br i1 %10, label %ForBody, label %ForEnd

ForBody:                                          ; preds = %ForCond
  %11 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 0
  %12 = load i8*, i8** %11, align 8
  %13 = getelementptr inbounds i8, i8* %12, i64 %9
  %14 = load i8, i8* %13, align 1
  store i8 %14, i8* %s, align 1
  %15 = load i64, i64* %i, align 8
  %16 = getelementptr inbounds %"[]u8", %"[]u8"* %0, i32 0, i32 0
  %17 = load i8*, i8** %16, align 8
  %18 = getelementptr inbounds i8, i8* %17, i64 %15
  %19 = load i8, i8* %s, align 1
  store i8 %19, i8* %18, align 1
  %20 = add nuw i64 %9, 1
  store i64 %20, i64* %i, align 8
  br label %ForCond

ForEnd:                                           ; preds = %ForCond
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i64 @std.os.linux.setrlimit(i32 %0, %std.os.linux.rlimit* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %result = alloca i64, align 8
  %resource = alloca i32, align 4
  %rlim = alloca %std.os.linux.rlimit*, align 8
  store i32 %0, i32* %resource, align 4
  store %std.os.linux.rlimit* %1, %std.os.linux.rlimit** %rlim, align 8
  %2 = load i32, i32* %resource, align 4
  %3 = load %std.os.linux.rlimit*, %std.os.linux.rlimit** %rlim, align 8
  %4 = call fastcc i64 @std.os.linux.prlimit(i32 0, i32 %2, %std.os.linux.rlimit* %3, %std.os.linux.rlimit* null)
  store i64 %4, i64* %result, align 8
  %5 = load i64, i64* %result, align 8
  ret i64 %5
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i8 @std.start.callMain() unnamed_addr #1 {
Entry:
  %result = alloca i8, align 1
  call fastcc void @std.special.main()
  store i8 0, i8* %result, align 1
  %0 = load i8, i8* %result, align 1
  ret i8 %0
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i8 @std.math.min(i8 %0) unnamed_addr #1 {
Entry:
  %result = alloca i8, align 1
  %y = alloca i8, align 1
  store i8 %0, i8* %y, align 1
  %1 = load i8, i8* %y, align 1
  %2 = icmp ult i8 32, %1
  br i1 %2, label %Then, label %Else

Then:                                             ; preds = %Entry
  store i8 32, i8* %result, align 1
  %3 = load i8, i8* %result, align 1
  ret i8 %3

Else:                                             ; preds = %Entry
  %4 = load i8, i8* %y, align 1
  store i8 %4, i8* %result, align 1
  %5 = load i8, i8* %result, align 1
  ret i8 %5
}

; Function Attrs: alwaysinline minsize nobuiltin nounwind optsize
define internal fastcc void @std.atomic.spinLoopHint() unnamed_addr #7 {
Entry:
  call void asm sideeffect "pause", "~{memory},~{dirflag},~{fpsr},~{flags}"()
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i64 @std.os.linux.futex_wait(i32* nonnull readonly align 4 %0, i32 %1, i32 %2, %std.os.linux.timespec* align 8 %3) unnamed_addr #1 {
Entry:
  %result = alloca i64, align 8
  %uaddr = alloca i32*, align 8
  %futex_op = alloca i32, align 4
  %val = alloca i32, align 4
  %timeout = alloca %std.os.linux.timespec*, align 8
  store i32* %0, i32** %uaddr, align 8
  store i32 %1, i32* %futex_op, align 4
  store i32 %2, i32* %val, align 4
  store %std.os.linux.timespec* %3, %std.os.linux.timespec** %timeout, align 8
  %4 = load i32*, i32** %uaddr, align 8
  %5 = ptrtoint i32* %4 to i64
  %6 = load i32, i32* %futex_op, align 4
  %7 = zext i32 %6 to i64
  %8 = load i32, i32* %val, align 4
  %9 = zext i32 %8 to i64
  %10 = load %std.os.linux.timespec*, %std.os.linux.timespec** %timeout, align 8
  %11 = ptrtoint %std.os.linux.timespec* %10 to i64
  %12 = call fastcc i64 @std.os.linux.x86_64.syscall4(i64 202, i64 %5, i64 %7, i64 %9, i64 %11)
  store i64 %12, i64* %result, align 8
  %13 = load i64, i64* %result, align 8
  ret i64 %13
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.formatIntValue(i64 %0, %std.fmt.FormatOptions* nonnull readonly align 8 %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %2) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %int_value = alloca i64, align 8
  %3 = alloca i64, align 8
  %4 = alloca %std.fmt.FormatOptions, align 8
  %5 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %value = alloca i64, align 8
  store i64 %0, i64* %value, align 8
  %6 = load i64, i64* %value, align 8
  store i64 %6, i64* %int_value, align 8
  %7 = load i64, i64* %int_value, align 8
  store i64 %7, i64* %3, align 8
  %8 = bitcast %std.fmt.FormatOptions* %1 to i8*
  %9 = bitcast %std.fmt.FormatOptions* %4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %9, i8* align 8 %8, i64 40, i1 false)
  %10 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2 to i8*
  %11 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %11, i8* align 4 %10, i64 4, i1 false)
  %12 = call fastcc i16 @std.fmt.formatInt(i64 %7, i8 10, i1 false, %std.fmt.FormatOptions* %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2)
  store i16 %12, i16* %result, align 2
  %13 = load i16, i16* %result, align 2
  ret i16 %13
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.formatInt(i64 %0, i8 %1, i1 %2, %std.fmt.FormatOptions* nonnull readonly align 8 %3, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %4) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %int_value = alloca i64, align 8
  %5 = alloca i64, align 8
  %abs_value = alloca i64, align 8
  %buf = alloca [65 x i8], align 1
  %a = alloca i64, align 8
  %index = alloca i64, align 8
  %digit = alloca i64, align 8
  %6 = alloca %"[]u8", align 8
  %7 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %value = alloca i64, align 8
  %base = alloca i8, align 1
  %case = alloca i1, align 1
  store i64 %0, i64* %value, align 8
  store i8 %1, i8* %base, align 1
  store i1 %2, i1* %case, align 1
  %8 = load i8, i8* %base, align 1
  %9 = icmp uge i8 %8, 2
  call fastcc void @std.debug.assert(i1 %9)
  %10 = load i64, i64* %value, align 8
  store i64 %10, i64* %int_value, align 8
  %11 = load i64, i64* %int_value, align 8
  store i64 %11, i64* %5, align 8
  %12 = call fastcc i64 @std.math.absCast(i64 %11)
  store i64 %12, i64* %abs_value, align 8
  %13 = load i64, i64* %abs_value, align 8
  store i64 %13, i64* %a, align 8
  store i64 65, i64* %index, align 8
  br label %WhileCond

WhileCond:                                        ; preds = %EndIf, %Entry
  br label %WhileBody

WhileBody:                                        ; preds = %WhileCond
  %14 = load i64, i64* %a, align 8
  %15 = load i8, i8* %base, align 1
  %16 = zext i8 %15 to i64
  %17 = urem i64 %14, %16
  store i64 %17, i64* %digit, align 8
  %18 = load i64, i64* %index, align 8
  %19 = sub nuw i64 %18, 1
  store i64 %19, i64* %index, align 8
  %20 = load i64, i64* %index, align 8
  %21 = getelementptr inbounds [65 x i8], [65 x i8]* %buf, i64 0, i64 %20
  %22 = load i64, i64* %digit, align 8
  %23 = trunc i64 %22 to i8
  %24 = load i1, i1* %case, align 1
  %25 = call fastcc i8 @std.fmt.digitToChar(i8 %23, i1 %24)
  store i8 %25, i8* %21, align 1
  %26 = load i64, i64* %a, align 8
  %27 = load i8, i8* %base, align 1
  %28 = zext i8 %27 to i64
  %29 = udiv i64 %26, %28
  store i64 %29, i64* %a, align 8
  %30 = load i64, i64* %a, align 8
  %31 = icmp eq i64 %30, 0
  br i1 %31, label %Then, label %Else

Then:                                             ; preds = %WhileBody
  br label %WhileEnd

Else:                                             ; preds = %WhileBody
  br label %EndIf

EndIf:                                            ; preds = %Else
  br label %WhileCond

WhileEnd:                                         ; preds = %Then
  %32 = load i64, i64* %index, align 8
  %33 = getelementptr inbounds [65 x i8], [65 x i8]* %buf, i64 0, i64 %32
  %34 = sub nuw i64 65, %32
  %35 = getelementptr inbounds %"[]u8", %"[]u8"* %6, i32 0, i32 0
  store i8* %33, i8** %35, align 8
  %36 = getelementptr inbounds %"[]u8", %"[]u8"* %6, i32 0, i32 1
  store i64 %34, i64* %36, align 8
  %37 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %4 to i8*
  %38 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %7 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %38, i8* align 4 %37, i64 4, i1 false)
  %39 = call fastcc i16 @std.fmt.formatBuf(%"[]u8"* %6, %std.fmt.FormatOptions* %3, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %4)
  store i16 %39, i16* %result, align 2
  %40 = load i16, i16* %result, align 2
  ret i16 %40
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i64 @std.math.absCast(i64 %0) unnamed_addr #1 {
Entry:
  %result = alloca i64, align 8
  %x = alloca i64, align 8
  store i64 %0, i64* %x, align 8
  %1 = load i64, i64* %x, align 8
  store i64 %1, i64* %result, align 8
  %2 = load i64, i64* %result, align 8
  ret i64 %2
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i8 @std.fmt.digitToChar(i8 %0, i1 %1) unnamed_addr #1 {
Entry:
  %result = alloca i8, align 1
  %2 = alloca i8, align 1
  %digit = alloca i8, align 1
  %case = alloca i1, align 1
  store i8 %0, i8* %digit, align 1
  store i1 %1, i1* %case, align 1
  %3 = load i8, i8* %digit, align 1
  %4 = icmp ule i8 %3, 9
  %5 = and i1 true, %4
  br i1 %5, label %SwitchRangeYes, label %SwitchRangeNo

SwitchRangeYes:                                   ; preds = %Entry
  %6 = load i8, i8* %digit, align 1
  %7 = add nuw i8 %6, 48
  store i8 %7, i8* %result, align 1
  br label %SwitchEnd

SwitchRangeNo:                                    ; preds = %Entry
  %8 = icmp uge i8 %3, 10
  %9 = icmp ule i8 %3, 35
  %10 = and i1 %8, %9
  br i1 %10, label %SwitchRangeYes1, label %SwitchRangeNo2

SwitchRangeYes1:                                  ; preds = %SwitchRangeNo
  %11 = load i8, i8* %digit, align 1
  %12 = load i1, i1* %case, align 1
  %13 = icmp eq i1 %12, true
  br i1 %13, label %Then, label %Else

Then:                                             ; preds = %SwitchRangeYes1
  store i8 65, i8* %2, align 1
  store i8 65, i8* %2, align 1
  br label %EndIf

Else:                                             ; preds = %SwitchRangeYes1
  store i8 97, i8* %2, align 1
  store i8 97, i8* %2, align 1
  br label %EndIf

EndIf:                                            ; preds = %Else, %Then
  %14 = phi i8 [ 65, %Then ], [ 97, %Else ]
  %15 = sub nuw i8 %14, 10
  %16 = add nuw i8 %11, %15
  store i8 %16, i8* %result, align 1
  br label %SwitchEnd

SwitchRangeNo2:                                   ; preds = %SwitchRangeNo
  br label %SwitchElse

SwitchElse:                                       ; preds = %SwitchRangeNo2
  unreachable

SwitchEnd:                                        ; preds = %EndIf, %SwitchRangeYes
  %17 = load i8, i8* %result, align 1
  ret i8 %17
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.formatBuf(%"[]u8"* nonnull readonly align 8 %0, %std.fmt.FormatOptions* nonnull readonly align 8 %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %2) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %min_width = alloca i64, align 8
  %3 = alloca { i64, i16 }, align 8
  %width = alloca i64, align 8
  %padding = alloca i64, align 8
  %4 = alloca i16, align 2
  %5 = alloca i16, align 2
  %left_padding = alloca i64, align 8
  %right_padding = alloca i64, align 8
  %6 = alloca i16, align 2
  %7 = alloca i16, align 2
  %8 = alloca i16, align 2
  %9 = alloca i16, align 2
  %10 = alloca i16, align 2
  %11 = alloca i16, align 2
  %12 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %1, i32 0, i32 1
  %13 = getelementptr inbounds %"?usize", %"?usize"* %12, i32 0, i32 1
  %14 = load i1, i1* %13, align 1
  br i1 %14, label %OptionalThen, label %OptionalElse

OptionalThen:                                     ; preds = %Entry
  %15 = getelementptr inbounds %"?usize", %"?usize"* %12, i32 0, i32 0
  %16 = load i64, i64* %15, align 8
  store i64 %16, i64* %min_width, align 8
  call fastcc void @std.unicode.utf8CountCodepoints({ i64, i16 }* sret({ i64, i16 }) %3, %"[]u8"* %0)
  %17 = getelementptr inbounds { i64, i16 }, { i64, i16 }* %3, i32 0, i32 1
  %18 = load i16, i16* %17, align 2
  %19 = icmp ne i16 %18, 0
  br i1 %19, label %UnwrapErrError, label %UnwrapErrOk

UnwrapErrError:                                   ; preds = %OptionalThen
  %20 = getelementptr inbounds %"[]u8", %"[]u8"* %0, i32 0, i32 1
  %21 = load i64, i64* %20, align 8
  store i64 %21, i64* %width, align 8
  br label %UnwrapErrEnd

UnwrapErrOk:                                      ; preds = %OptionalThen
  %22 = getelementptr inbounds { i64, i16 }, { i64, i16 }* %3, i32 0, i32 0
  %23 = load i64, i64* %22, align 8
  store i64 %23, i64* %width, align 8
  br label %UnwrapErrEnd

UnwrapErrEnd:                                     ; preds = %UnwrapErrOk, %UnwrapErrError
  %24 = load i64, i64* %width, align 8
  %25 = load i64, i64* %min_width, align 8
  %26 = icmp ult i64 %24, %25
  br i1 %26, label %Then, label %Else

Then:                                             ; preds = %UnwrapErrEnd
  %27 = load i64, i64* %min_width, align 8
  %28 = load i64, i64* %width, align 8
  %29 = sub nuw i64 %27, %28
  store i64 %29, i64* %padding, align 8
  br label %EndIf

Else:                                             ; preds = %UnwrapErrEnd
  store i64 0, i64* %padding, align 8
  br label %EndIf

EndIf:                                            ; preds = %Else, %Then
  %30 = load i64, i64* %padding, align 8
  %31 = icmp eq i64 %30, 0
  br i1 %31, label %Then1, label %Else2

Then1:                                            ; preds = %EndIf
  %32 = call fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).writeAll"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2, %"[]u8"* %0)
  store i16 %32, i16* %result, align 2
  %33 = load i16, i16* %result, align 2
  ret i16 %33

Else2:                                            ; preds = %EndIf
  br label %EndIf3

EndIf3:                                           ; preds = %Else2
  %34 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %1, i32 0, i32 2
  %35 = load i2, i2* %34, align 1
  switch i2 %35, label %SwitchElse [
    i2 0, label %SwitchProng
    i2 1, label %SwitchProng5
    i2 -2, label %SwitchProng11
  ]

SwitchProng:                                      ; preds = %EndIf3
  %36 = call fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).writeAll"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2, %"[]u8"* %0)
  store i16 %36, i16* %4, align 2
  %37 = icmp ne i16 %36, 0
  br i1 %37, label %ErrRetReturn, label %ErrRetContinue

ErrRetReturn:                                     ; preds = %SwitchProng
  %38 = load i16, i16* %4, align 2
  store i16 %38, i16* %result, align 2
  ret i16 %38

ErrRetContinue:                                   ; preds = %SwitchProng
  %39 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %1, i32 0, i32 3
  %40 = load i8, i8* %39, align 1
  %41 = load i64, i64* %padding, align 8
  %42 = call fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).writeByteNTimes"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2, i8 %40, i64 %41)
  store i16 %42, i16* %5, align 2
  %43 = icmp ne i16 %42, 0
  br i1 %43, label %ErrRetReturn4, label %ErrRetContinue15

ErrRetReturn4:                                    ; preds = %ErrRetContinue
  %44 = load i16, i16* %5, align 2
  store i16 %44, i16* %result, align 2
  ret i16 %44

SwitchProng5:                                     ; preds = %EndIf3
  %45 = load i64, i64* %padding, align 8
  %46 = udiv i64 %45, 2
  store i64 %46, i64* %left_padding, align 8
  %47 = load i64, i64* %padding, align 8
  %48 = add nuw i64 %47, 1
  %49 = udiv i64 %48, 2
  store i64 %49, i64* %right_padding, align 8
  %50 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %1, i32 0, i32 3
  %51 = load i8, i8* %50, align 1
  %52 = load i64, i64* %left_padding, align 8
  %53 = call fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).writeByteNTimes"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2, i8 %51, i64 %52)
  store i16 %53, i16* %6, align 2
  %54 = icmp ne i16 %53, 0
  br i1 %54, label %ErrRetReturn6, label %ErrRetContinue7

ErrRetReturn6:                                    ; preds = %SwitchProng5
  %55 = load i16, i16* %6, align 2
  store i16 %55, i16* %result, align 2
  ret i16 %55

ErrRetContinue7:                                  ; preds = %SwitchProng5
  %56 = call fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).writeAll"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2, %"[]u8"* %0)
  store i16 %56, i16* %7, align 2
  %57 = icmp ne i16 %56, 0
  br i1 %57, label %ErrRetReturn8, label %ErrRetContinue9

ErrRetReturn8:                                    ; preds = %ErrRetContinue7
  %58 = load i16, i16* %7, align 2
  store i16 %58, i16* %result, align 2
  ret i16 %58

ErrRetContinue9:                                  ; preds = %ErrRetContinue7
  %59 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %1, i32 0, i32 3
  %60 = load i8, i8* %59, align 1
  %61 = load i64, i64* %right_padding, align 8
  %62 = call fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).writeByteNTimes"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2, i8 %60, i64 %61)
  store i16 %62, i16* %8, align 2
  %63 = icmp ne i16 %62, 0
  br i1 %63, label %ErrRetReturn10, label %ErrRetContinue16

ErrRetReturn10:                                   ; preds = %ErrRetContinue9
  %64 = load i16, i16* %8, align 2
  store i16 %64, i16* %result, align 2
  ret i16 %64

SwitchProng11:                                    ; preds = %EndIf3
  %65 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %1, i32 0, i32 3
  %66 = load i8, i8* %65, align 1
  %67 = load i64, i64* %padding, align 8
  %68 = call fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).writeByteNTimes"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2, i8 %66, i64 %67)
  store i16 %68, i16* %9, align 2
  %69 = icmp ne i16 %68, 0
  br i1 %69, label %ErrRetReturn12, label %ErrRetContinue13

ErrRetReturn12:                                   ; preds = %SwitchProng11
  %70 = load i16, i16* %9, align 2
  store i16 %70, i16* %result, align 2
  ret i16 %70

ErrRetContinue13:                                 ; preds = %SwitchProng11
  %71 = call fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).writeAll"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2, %"[]u8"* %0)
  store i16 %71, i16* %10, align 2
  %72 = icmp ne i16 %71, 0
  br i1 %72, label %ErrRetReturn14, label %ErrRetContinue17

ErrRetReturn14:                                   ; preds = %ErrRetContinue13
  %73 = load i16, i16* %10, align 2
  store i16 %73, i16* %result, align 2
  ret i16 %73

SwitchElse:                                       ; preds = %EndIf3
  unreachable

ErrRetContinue15:                                 ; preds = %ErrRetContinue
  br label %SwitchEnd

ErrRetContinue16:                                 ; preds = %ErrRetContinue9
  br label %SwitchEnd

ErrRetContinue17:                                 ; preds = %ErrRetContinue13
  br label %SwitchEnd

OptionalElse:                                     ; preds = %Entry
  %74 = call fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).writeAll"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2, %"[]u8"* %0)
  store i16 %74, i16* %11, align 2
  %75 = icmp ne i16 %74, 0
  br i1 %75, label %ErrRetReturn18, label %ErrRetContinue19

ErrRetReturn18:                                   ; preds = %OptionalElse
  %76 = load i16, i16* %11, align 2
  store i16 %76, i16* %result, align 2
  ret i16 %76

SwitchEnd:                                        ; preds = %ErrRetContinue17, %ErrRetContinue16, %ErrRetContinue15
  br label %OptionalEndIf

ErrRetContinue19:                                 ; preds = %OptionalElse
  br label %OptionalEndIf

OptionalEndIf:                                    ; preds = %ErrRetContinue19, %SwitchEnd
  store i16 0, i16* %result, align 2
  ret i16 0
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.unicode.utf8CountCodepoints({ i64, i16 }* nonnull sret({ i64, i16 }) %0, %"[]u8"* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %len = alloca i64, align 8
  %i = alloca i64, align 8
  %2 = alloca %"[]u8", align 8
  %3 = alloca [8 x i8]*, align 8
  %v = alloca i64, align 8
  %4 = alloca { i3, i16 }, align 2
  %5 = alloca { i64, i16 }, align 8
  %n = alloca i3, align 1
  %6 = alloca %"[]u8", align 8
  %7 = alloca { i21, i16 }, align 4
  %8 = alloca { i64, i16 }, align 8
  store i64 0, i64* %len, align 8
  store i64 0, i64* %i, align 8
  br label %WhileCond

WhileCond:                                        ; preds = %EndIf10, %Entry
  %9 = load i64, i64* %i, align 8
  %10 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 1
  %11 = load i64, i64* %10, align 8
  %12 = icmp ult i64 %9, %11
  br i1 %12, label %WhileBody, label %WhileEnd11

WhileBody:                                        ; preds = %WhileCond
  br label %WhileCond1

WhileCond1:                                       ; preds = %EndIf, %WhileBody
  %13 = load i64, i64* %i, align 8
  %14 = add nuw i64 %13, 8
  %15 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 1
  %16 = load i64, i64* %15, align 8
  %17 = icmp ule i64 %14, %16
  br i1 %17, label %WhileBody2, label %WhileEnd

WhileBody2:                                       ; preds = %WhileCond1
  %18 = load i64, i64* %i, align 8
  %19 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 1
  %20 = load i64, i64* %19, align 8
  %21 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 0
  %22 = load i8*, i8** %21, align 8
  %23 = getelementptr inbounds i8, i8* %22, i64 %18
  %24 = sub nuw i64 %20, %18
  %25 = getelementptr inbounds %"[]u8", %"[]u8"* %2, i32 0, i32 0
  store i8* %23, i8** %25, align 8
  %26 = getelementptr inbounds %"[]u8", %"[]u8"* %2, i32 0, i32 1
  store i64 %24, i64* %26, align 8
  %27 = getelementptr inbounds %"[]u8", %"[]u8"* %2, i32 0, i32 0
  %28 = load i8*, i8** %27, align 8
  %29 = getelementptr inbounds i8, i8* %28, i64 0
  %30 = bitcast i8* %29 to [8 x i8]*
  store [8 x i8]* %30, [8 x i8]** %3, align 8
  %31 = call fastcc i64 @std.mem.readIntNative([8 x i8]* %30)
  store i64 %31, i64* %v, align 8
  %32 = load i64, i64* %v, align 8
  %33 = and i64 %32, -9187201950435737472
  %34 = icmp ne i64 %33, 0
  br i1 %34, label %Then, label %Else

Then:                                             ; preds = %WhileBody2
  br label %WhileEnd

Else:                                             ; preds = %WhileBody2
  br label %EndIf

EndIf:                                            ; preds = %Else
  %35 = load i64, i64* %len, align 8
  %36 = add nuw i64 %35, 8
  store i64 %36, i64* %len, align 8
  %37 = load i64, i64* %i, align 8
  %38 = add nuw i64 %37, 8
  store i64 %38, i64* %i, align 8
  br label %WhileCond1

WhileEnd:                                         ; preds = %Then, %WhileCond1
  %39 = load i64, i64* %i, align 8
  %40 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 1
  %41 = load i64, i64* %40, align 8
  %42 = icmp ult i64 %39, %41
  br i1 %42, label %Then3, label %Else9

Then3:                                            ; preds = %WhileEnd
  %43 = load i64, i64* %i, align 8
  %44 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 0
  %45 = load i8*, i8** %44, align 8
  %46 = getelementptr inbounds i8, i8* %45, i64 %43
  %47 = load i8, i8* %46, align 1
  call fastcc void @std.unicode.utf8ByteSequenceLength({ i3, i16 }* sret({ i3, i16 }) %4, i8 %47)
  %48 = getelementptr inbounds { i3, i16 }, { i3, i16 }* %4, i32 0, i32 1
  %49 = load i16, i16* %48, align 2
  %50 = icmp ne i16 %49, 0
  br i1 %50, label %ErrRetReturn, label %ErrRetContinue

ErrRetReturn:                                     ; preds = %Then3
  %51 = getelementptr inbounds { i3, i16 }, { i3, i16 }* %4, i32 0, i32 1
  %52 = load i16, i16* %51, align 2
  %53 = getelementptr inbounds { i64, i16 }, { i64, i16 }* %0, i32 0, i32 1
  store i16 %52, i16* %53, align 2
  %54 = getelementptr inbounds { i64, i16 }, { i64, i16 }* %5, i32 0, i32 1
  store i16 %52, i16* %54, align 2
  ret void

ErrRetContinue:                                   ; preds = %Then3
  %55 = getelementptr inbounds { i3, i16 }, { i3, i16 }* %4, i32 0, i32 0
  %56 = load i3, i3* %55, align 1
  store i3 %56, i3* %n, align 1
  %57 = load i64, i64* %i, align 8
  %58 = load i3, i3* %n, align 1
  %59 = zext i3 %58 to i64
  %60 = add nuw i64 %57, %59
  %61 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 1
  %62 = load i64, i64* %61, align 8
  %63 = icmp ugt i64 %60, %62
  br i1 %63, label %Then4, label %Else5

Then4:                                            ; preds = %ErrRetContinue
  %64 = getelementptr inbounds { i64, i16 }, { i64, i16 }* %0, i32 0, i32 1
  store i16 19, i16* %64, align 2
  ret void

Else5:                                            ; preds = %ErrRetContinue
  br label %EndIf6

EndIf6:                                           ; preds = %Else5
  %65 = load i3, i3* %n, align 1
  switch i3 %65, label %SwitchElse [
    i3 1, label %SwitchProng
  ]

SwitchElse:                                       ; preds = %EndIf6
  %66 = load i64, i64* %i, align 8
  %67 = load i64, i64* %i, align 8
  %68 = load i3, i3* %n, align 1
  %69 = zext i3 %68 to i64
  %70 = add nuw i64 %67, %69
  %71 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 0
  %72 = load i8*, i8** %71, align 8
  %73 = getelementptr inbounds i8, i8* %72, i64 %66
  %74 = sub nuw i64 %70, %66
  %75 = getelementptr inbounds %"[]u8", %"[]u8"* %6, i32 0, i32 0
  store i8* %73, i8** %75, align 8
  %76 = getelementptr inbounds %"[]u8", %"[]u8"* %6, i32 0, i32 1
  store i64 %74, i64* %76, align 8
  call fastcc void @std.unicode.utf8Decode({ i21, i16 }* sret({ i21, i16 }) %7, %"[]u8"* %6)
  %77 = getelementptr inbounds { i21, i16 }, { i21, i16 }* %7, i32 0, i32 1
  %78 = load i16, i16* %77, align 2
  %79 = icmp ne i16 %78, 0
  br i1 %79, label %ErrRetReturn7, label %ErrRetContinue8

ErrRetReturn7:                                    ; preds = %SwitchElse
  %80 = getelementptr inbounds { i21, i16 }, { i21, i16 }* %7, i32 0, i32 1
  %81 = load i16, i16* %80, align 2
  %82 = getelementptr inbounds { i64, i16 }, { i64, i16 }* %0, i32 0, i32 1
  store i16 %81, i16* %82, align 2
  %83 = getelementptr inbounds { i64, i16 }, { i64, i16 }* %8, i32 0, i32 1
  store i16 %81, i16* %83, align 2
  ret void

ErrRetContinue8:                                  ; preds = %SwitchElse
  %84 = getelementptr inbounds { i21, i16 }, { i21, i16 }* %7, i32 0, i32 0
  br label %SwitchEnd

SwitchProng:                                      ; preds = %EndIf6
  br label %SwitchEnd

SwitchEnd:                                        ; preds = %SwitchProng, %ErrRetContinue8
  %85 = load i64, i64* %i, align 8
  %86 = load i3, i3* %n, align 1
  %87 = zext i3 %86 to i64
  %88 = add nuw i64 %85, %87
  store i64 %88, i64* %i, align 8
  %89 = load i64, i64* %len, align 8
  %90 = add nuw i64 %89, 1
  store i64 %90, i64* %len, align 8
  br label %EndIf10

Else9:                                            ; preds = %WhileEnd
  br label %EndIf10

EndIf10:                                          ; preds = %Else9, %SwitchEnd
  br label %WhileCond

WhileEnd11:                                       ; preds = %WhileCond
  %91 = load i64, i64* %len, align 8
  %92 = getelementptr inbounds { i64, i16 }, { i64, i16 }* %0, i32 0, i32 1
  store i16 0, i16* %92, align 2
  %93 = getelementptr inbounds { i64, i16 }, { i64, i16 }* %0, i32 0, i32 0
  store i64 %91, i64* %93, align 8
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).writeByteNTimes"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %0, i8 %1, i64 %2) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %bytes = alloca [256 x i8], align 1
  %3 = alloca [256 x i8]*, align 8
  %4 = alloca i8, align 1
  %5 = alloca %"[]u8", align 8
  %remaining = alloca i64, align 8
  %6 = alloca i64, align 8
  %to_write = alloca i64, align 8
  %7 = alloca %"[]u8", align 8
  %8 = alloca i16, align 2
  %byte = alloca i8, align 1
  %n = alloca i64, align 8
  store i8 %1, i8* %byte, align 1
  store i64 %2, i64* %n, align 8
  %9 = getelementptr inbounds [256 x i8], [256 x i8]* %bytes, i64 0, i64 0
  %10 = bitcast i8* %9 to [256 x i8]*
  store [256 x i8]* %10, [256 x i8]** %3, align 8
  %11 = load i8, i8* %byte, align 1
  store i8 %11, i8* %4, align 1
  %12 = getelementptr inbounds %"[]u8", %"[]u8"* %5, i32 0, i32 0
  %13 = getelementptr inbounds [256 x i8], [256 x i8]* %10, i64 0, i64 0
  store i8* %13, i8** %12, align 8
  %14 = getelementptr inbounds %"[]u8", %"[]u8"* %5, i32 0, i32 1
  store i64 256, i64* %14, align 8
  call fastcc void @std.mem.set(%"[]u8"* %5, i8 %11)
  %15 = load i64, i64* %n, align 8
  store i64 %15, i64* %remaining, align 8
  br label %WhileCond

WhileCond:                                        ; preds = %ErrRetContinue, %Entry
  %16 = load i64, i64* %remaining, align 8
  %17 = icmp ugt i64 %16, 0
  br i1 %17, label %WhileBody, label %WhileEnd

WhileBody:                                        ; preds = %WhileCond
  %18 = load i64, i64* %remaining, align 8
  store i64 %18, i64* %6, align 8
  %19 = call fastcc i64 @std.math.min.30(i64 %18, i64 256)
  store i64 %19, i64* %to_write, align 8
  %20 = load i64, i64* %to_write, align 8
  %21 = getelementptr inbounds [256 x i8], [256 x i8]* %bytes, i64 0, i64 0
  %22 = sub nuw i64 %20, 0
  %23 = getelementptr inbounds %"[]u8", %"[]u8"* %7, i32 0, i32 0
  store i8* %21, i8** %23, align 8
  %24 = getelementptr inbounds %"[]u8", %"[]u8"* %7, i32 0, i32 1
  store i64 %22, i64* %24, align 8
  %25 = call fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).writeAll"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0, %"[]u8"* %7)
  store i16 %25, i16* %8, align 2
  %26 = icmp ne i16 %25, 0
  br i1 %26, label %ErrRetReturn, label %ErrRetContinue

ErrRetReturn:                                     ; preds = %WhileBody
  %27 = load i16, i16* %8, align 2
  store i16 %27, i16* %result, align 2
  ret i16 %27

ErrRetContinue:                                   ; preds = %WhileBody
  %28 = load i64, i64* %remaining, align 8
  %29 = load i64, i64* %to_write, align 8
  %30 = sub nuw i64 %28, %29
  store i64 %30, i64* %remaining, align 8
  br label %WhileCond

WhileEnd:                                         ; preds = %WhileCond
  store i16 0, i16* %result, align 2
  ret i16 0
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i64 @std.mem.readIntNative([8 x i8]* nonnull readonly align 1 %0) unnamed_addr #1 {
Entry:
  %result = alloca i64, align 8
  %bytes = alloca [8 x i8]*, align 8
  store [8 x i8]* %0, [8 x i8]** %bytes, align 8
  %1 = load [8 x i8]*, [8 x i8]** %bytes, align 8
  %2 = bitcast [8 x i8]* %1 to i64*
  %3 = load i64, i64* %2, align 1
  store i64 %3, i64* %result, align 8
  %4 = load i64, i64* %result, align 8
  ret i64 %4
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.unicode.utf8ByteSequenceLength({ i3, i16 }* nonnull sret({ i3, i16 }) %0, i8 %1) unnamed_addr #1 {
Entry:
  %first_byte = alloca i8, align 1
  store i8 %1, i8* %first_byte, align 1
  %2 = load i8, i8* %first_byte, align 1
  %3 = icmp ule i8 %2, 127
  %4 = and i1 true, %3
  br i1 %4, label %SwitchRangeYes, label %SwitchRangeNo

SwitchRangeYes:                                   ; preds = %Entry
  %5 = getelementptr inbounds { i3, i16 }, { i3, i16 }* %0, i32 0, i32 1
  store i16 0, i16* %5, align 2
  %6 = getelementptr inbounds { i3, i16 }, { i3, i16 }* %0, i32 0, i32 0
  store i3 1, i3* %6, align 1
  br label %SwitchEnd

SwitchRangeNo:                                    ; preds = %Entry
  %7 = icmp uge i8 %2, -64
  %8 = icmp ule i8 %2, -33
  %9 = and i1 %7, %8
  br i1 %9, label %SwitchRangeYes1, label %SwitchRangeNo2

SwitchRangeYes1:                                  ; preds = %SwitchRangeNo
  %10 = getelementptr inbounds { i3, i16 }, { i3, i16 }* %0, i32 0, i32 1
  store i16 0, i16* %10, align 2
  %11 = getelementptr inbounds { i3, i16 }, { i3, i16 }* %0, i32 0, i32 0
  store i3 2, i3* %11, align 1
  br label %SwitchEnd

SwitchRangeNo2:                                   ; preds = %SwitchRangeNo
  %12 = icmp uge i8 %2, -32
  %13 = icmp ule i8 %2, -17
  %14 = and i1 %12, %13
  br i1 %14, label %SwitchRangeYes3, label %SwitchRangeNo4

SwitchRangeYes3:                                  ; preds = %SwitchRangeNo2
  %15 = getelementptr inbounds { i3, i16 }, { i3, i16 }* %0, i32 0, i32 1
  store i16 0, i16* %15, align 2
  %16 = getelementptr inbounds { i3, i16 }, { i3, i16 }* %0, i32 0, i32 0
  store i3 3, i3* %16, align 1
  br label %SwitchEnd

SwitchRangeNo4:                                   ; preds = %SwitchRangeNo2
  %17 = icmp uge i8 %2, -16
  %18 = icmp ule i8 %2, -9
  %19 = and i1 %17, %18
  br i1 %19, label %SwitchRangeYes5, label %SwitchRangeNo6

SwitchRangeYes5:                                  ; preds = %SwitchRangeNo4
  %20 = getelementptr inbounds { i3, i16 }, { i3, i16 }* %0, i32 0, i32 1
  store i16 0, i16* %20, align 2
  %21 = getelementptr inbounds { i3, i16 }, { i3, i16 }* %0, i32 0, i32 0
  store i3 -4, i3* %21, align 1
  br label %SwitchEnd

SwitchRangeNo6:                                   ; preds = %SwitchRangeNo4
  br label %SwitchElse

SwitchElse:                                       ; preds = %SwitchRangeNo6
  %22 = getelementptr inbounds { i3, i16 }, { i3, i16 }* %0, i32 0, i32 1
  store i16 18, i16* %22, align 2
  br label %SwitchEnd

SwitchEnd:                                        ; preds = %SwitchElse, %SwitchRangeYes5, %SwitchRangeYes3, %SwitchRangeYes1, %SwitchRangeYes
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.unicode.utf8Decode({ i21, i16 }* nonnull sret({ i21, i16 }) %0, %"[]u8"* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %2 = alloca { i21, i16 }, align 4
  %3 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 1
  %4 = load i64, i64* %3, align 8
  switch i64 %4, label %SwitchElse [
    i64 1, label %SwitchProng
    i64 2, label %SwitchProng1
    i64 3, label %SwitchProng2
    i64 4, label %SwitchProng3
  ]

SwitchElse:                                       ; preds = %Entry
  unreachable

SwitchProng:                                      ; preds = %Entry
  %5 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 0
  %6 = load i8*, i8** %5, align 8
  %7 = getelementptr inbounds i8, i8* %6, i64 0
  %8 = load i8, i8* %7, align 1
  %9 = getelementptr inbounds { i21, i16 }, { i21, i16 }* %0, i32 0, i32 1
  store i16 0, i16* %9, align 2
  %10 = getelementptr inbounds { i21, i16 }, { i21, i16 }* %0, i32 0, i32 0
  %11 = zext i8 %8 to i21
  store i21 %11, i21* %10, align 4
  %12 = zext i8 %8 to i21
  store i21 %12, i21* %10, align 4
  %13 = getelementptr inbounds { i21, i16 }, { i21, i16 }* %2, i32 0, i32 1
  store i16 0, i16* %13, align 2
  %14 = getelementptr inbounds { i21, i16 }, { i21, i16 }* %2, i32 0, i32 0
  store i21 %12, i21* %14, align 4
  br label %SwitchEnd

SwitchProng1:                                     ; preds = %Entry
  call fastcc void @std.unicode.utf8Decode2({ i21, i16 }* sret({ i21, i16 }) %0, %"[]u8"* %1)
  %15 = bitcast { i21, i16 }* %0 to i8*
  %16 = bitcast { i21, i16 }* %0 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %16, i8* align 4 %15, i64 8, i1 false)
  br label %SwitchEnd

SwitchProng2:                                     ; preds = %Entry
  call fastcc void @std.unicode.utf8Decode3({ i21, i16 }* sret({ i21, i16 }) %0, %"[]u8"* %1)
  %17 = bitcast { i21, i16 }* %0 to i8*
  %18 = bitcast { i21, i16 }* %0 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %18, i8* align 4 %17, i64 8, i1 false)
  br label %SwitchEnd

SwitchProng3:                                     ; preds = %Entry
  call fastcc void @std.unicode.utf8Decode4({ i21, i16 }* sret({ i21, i16 }) %0, %"[]u8"* %1)
  %19 = bitcast { i21, i16 }* %0 to i8*
  %20 = bitcast { i21, i16 }* %0 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %20, i8* align 4 %19, i64 8, i1 false)
  br label %SwitchEnd

SwitchEnd:                                        ; preds = %SwitchProng3, %SwitchProng2, %SwitchProng1, %SwitchProng
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.unicode.utf8Decode2({ i21, i16 }* nonnull sret({ i21, i16 }) %0, %"[]u8"* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %value = alloca i21, align 4
  %2 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 1
  %3 = load i64, i64* %2, align 8
  %4 = icmp eq i64 %3, 2
  call fastcc void @std.debug.assert(i1 %4)
  %5 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 0
  %6 = load i8*, i8** %5, align 8
  %7 = getelementptr inbounds i8, i8* %6, i64 0
  %8 = load i8, i8* %7, align 1
  %9 = and i8 %8, -32
  %10 = icmp eq i8 %9, -64
  call fastcc void @std.debug.assert(i1 %10)
  %11 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 0
  %12 = load i8*, i8** %11, align 8
  %13 = getelementptr inbounds i8, i8* %12, i64 0
  %14 = load i8, i8* %13, align 1
  %15 = and i8 %14, 31
  %16 = zext i8 %15 to i21
  store i21 %16, i21* %value, align 4
  %17 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 0
  %18 = load i8*, i8** %17, align 8
  %19 = getelementptr inbounds i8, i8* %18, i64 1
  %20 = load i8, i8* %19, align 1
  %21 = and i8 %20, -64
  %22 = icmp ne i8 %21, -128
  br i1 %22, label %Then, label %Else

Then:                                             ; preds = %Entry
  %23 = getelementptr inbounds { i21, i16 }, { i21, i16 }* %0, i32 0, i32 1
  store i16 20, i16* %23, align 2
  ret void

Else:                                             ; preds = %Entry
  br label %EndIf

EndIf:                                            ; preds = %Else
  %24 = load i21, i21* %value, align 4
  %25 = shl i21 %24, 6
  store i21 %25, i21* %value, align 4
  %26 = load i21, i21* %value, align 4
  %27 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 0
  %28 = load i8*, i8** %27, align 8
  %29 = getelementptr inbounds i8, i8* %28, i64 1
  %30 = load i8, i8* %29, align 1
  %31 = and i8 %30, 63
  %32 = zext i8 %31 to i21
  %33 = or i21 %26, %32
  store i21 %33, i21* %value, align 4
  %34 = load i21, i21* %value, align 4
  %35 = icmp ult i21 %34, 128
  br i1 %35, label %Then1, label %Else2

Then1:                                            ; preds = %EndIf
  %36 = getelementptr inbounds { i21, i16 }, { i21, i16 }* %0, i32 0, i32 1
  store i16 21, i16* %36, align 2
  ret void

Else2:                                            ; preds = %EndIf
  br label %EndIf3

EndIf3:                                           ; preds = %Else2
  %37 = load i21, i21* %value, align 4
  %38 = getelementptr inbounds { i21, i16 }, { i21, i16 }* %0, i32 0, i32 1
  store i16 0, i16* %38, align 2
  %39 = getelementptr inbounds { i21, i16 }, { i21, i16 }* %0, i32 0, i32 0
  store i21 %37, i21* %39, align 4
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.unicode.utf8Decode3({ i21, i16 }* nonnull sret({ i21, i16 }) %0, %"[]u8"* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %value = alloca i21, align 4
  %2 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 1
  %3 = load i64, i64* %2, align 8
  %4 = icmp eq i64 %3, 3
  call fastcc void @std.debug.assert(i1 %4)
  %5 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 0
  %6 = load i8*, i8** %5, align 8
  %7 = getelementptr inbounds i8, i8* %6, i64 0
  %8 = load i8, i8* %7, align 1
  %9 = and i8 %8, -16
  %10 = icmp eq i8 %9, -32
  call fastcc void @std.debug.assert(i1 %10)
  %11 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 0
  %12 = load i8*, i8** %11, align 8
  %13 = getelementptr inbounds i8, i8* %12, i64 0
  %14 = load i8, i8* %13, align 1
  %15 = and i8 %14, 15
  %16 = zext i8 %15 to i21
  store i21 %16, i21* %value, align 4
  %17 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 0
  %18 = load i8*, i8** %17, align 8
  %19 = getelementptr inbounds i8, i8* %18, i64 1
  %20 = load i8, i8* %19, align 1
  %21 = and i8 %20, -64
  %22 = icmp ne i8 %21, -128
  br i1 %22, label %Then, label %Else

Then:                                             ; preds = %Entry
  %23 = getelementptr inbounds { i21, i16 }, { i21, i16 }* %0, i32 0, i32 1
  store i16 20, i16* %23, align 2
  ret void

Else:                                             ; preds = %Entry
  br label %EndIf

EndIf:                                            ; preds = %Else
  %24 = load i21, i21* %value, align 4
  %25 = shl i21 %24, 6
  store i21 %25, i21* %value, align 4
  %26 = load i21, i21* %value, align 4
  %27 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 0
  %28 = load i8*, i8** %27, align 8
  %29 = getelementptr inbounds i8, i8* %28, i64 1
  %30 = load i8, i8* %29, align 1
  %31 = and i8 %30, 63
  %32 = zext i8 %31 to i21
  %33 = or i21 %26, %32
  store i21 %33, i21* %value, align 4
  %34 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 0
  %35 = load i8*, i8** %34, align 8
  %36 = getelementptr inbounds i8, i8* %35, i64 2
  %37 = load i8, i8* %36, align 1
  %38 = and i8 %37, -64
  %39 = icmp ne i8 %38, -128
  br i1 %39, label %Then1, label %Else2

Then1:                                            ; preds = %EndIf
  %40 = getelementptr inbounds { i21, i16 }, { i21, i16 }* %0, i32 0, i32 1
  store i16 20, i16* %40, align 2
  ret void

Else2:                                            ; preds = %EndIf
  br label %EndIf3

EndIf3:                                           ; preds = %Else2
  %41 = load i21, i21* %value, align 4
  %42 = shl i21 %41, 6
  store i21 %42, i21* %value, align 4
  %43 = load i21, i21* %value, align 4
  %44 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 0
  %45 = load i8*, i8** %44, align 8
  %46 = getelementptr inbounds i8, i8* %45, i64 2
  %47 = load i8, i8* %46, align 1
  %48 = and i8 %47, 63
  %49 = zext i8 %48 to i21
  %50 = or i21 %43, %49
  store i21 %50, i21* %value, align 4
  %51 = load i21, i21* %value, align 4
  %52 = icmp ult i21 %51, 2048
  br i1 %52, label %Then4, label %Else5

Then4:                                            ; preds = %EndIf3
  %53 = getelementptr inbounds { i21, i16 }, { i21, i16 }* %0, i32 0, i32 1
  store i16 21, i16* %53, align 2
  ret void

Else5:                                            ; preds = %EndIf3
  br label %EndIf6

EndIf6:                                           ; preds = %Else5
  %54 = load i21, i21* %value, align 4
  %55 = icmp ule i21 55296, %54
  br i1 %55, label %BoolAndTrue, label %BoolAndFalse

BoolAndTrue:                                      ; preds = %EndIf6
  %56 = load i21, i21* %value, align 4
  %57 = icmp ule i21 %56, 57343
  br label %BoolAndFalse

BoolAndFalse:                                     ; preds = %BoolAndTrue, %EndIf6
  %58 = phi i1 [ %55, %EndIf6 ], [ %57, %BoolAndTrue ]
  br i1 %58, label %Then7, label %Else8

Then7:                                            ; preds = %BoolAndFalse
  %59 = getelementptr inbounds { i21, i16 }, { i21, i16 }* %0, i32 0, i32 1
  store i16 22, i16* %59, align 2
  ret void

Else8:                                            ; preds = %BoolAndFalse
  br label %EndIf9

EndIf9:                                           ; preds = %Else8
  %60 = load i21, i21* %value, align 4
  %61 = getelementptr inbounds { i21, i16 }, { i21, i16 }* %0, i32 0, i32 1
  store i16 0, i16* %61, align 2
  %62 = getelementptr inbounds { i21, i16 }, { i21, i16 }* %0, i32 0, i32 0
  store i21 %60, i21* %62, align 4
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.unicode.utf8Decode4({ i21, i16 }* nonnull sret({ i21, i16 }) %0, %"[]u8"* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %value = alloca i21, align 4
  %2 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 1
  %3 = load i64, i64* %2, align 8
  %4 = icmp eq i64 %3, 4
  call fastcc void @std.debug.assert(i1 %4)
  %5 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 0
  %6 = load i8*, i8** %5, align 8
  %7 = getelementptr inbounds i8, i8* %6, i64 0
  %8 = load i8, i8* %7, align 1
  %9 = and i8 %8, -8
  %10 = icmp eq i8 %9, -16
  call fastcc void @std.debug.assert(i1 %10)
  %11 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 0
  %12 = load i8*, i8** %11, align 8
  %13 = getelementptr inbounds i8, i8* %12, i64 0
  %14 = load i8, i8* %13, align 1
  %15 = and i8 %14, 7
  %16 = zext i8 %15 to i21
  store i21 %16, i21* %value, align 4
  %17 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 0
  %18 = load i8*, i8** %17, align 8
  %19 = getelementptr inbounds i8, i8* %18, i64 1
  %20 = load i8, i8* %19, align 1
  %21 = and i8 %20, -64
  %22 = icmp ne i8 %21, -128
  br i1 %22, label %Then, label %Else

Then:                                             ; preds = %Entry
  %23 = getelementptr inbounds { i21, i16 }, { i21, i16 }* %0, i32 0, i32 1
  store i16 20, i16* %23, align 2
  ret void

Else:                                             ; preds = %Entry
  br label %EndIf

EndIf:                                            ; preds = %Else
  %24 = load i21, i21* %value, align 4
  %25 = shl i21 %24, 6
  store i21 %25, i21* %value, align 4
  %26 = load i21, i21* %value, align 4
  %27 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 0
  %28 = load i8*, i8** %27, align 8
  %29 = getelementptr inbounds i8, i8* %28, i64 1
  %30 = load i8, i8* %29, align 1
  %31 = and i8 %30, 63
  %32 = zext i8 %31 to i21
  %33 = or i21 %26, %32
  store i21 %33, i21* %value, align 4
  %34 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 0
  %35 = load i8*, i8** %34, align 8
  %36 = getelementptr inbounds i8, i8* %35, i64 2
  %37 = load i8, i8* %36, align 1
  %38 = and i8 %37, -64
  %39 = icmp ne i8 %38, -128
  br i1 %39, label %Then1, label %Else2

Then1:                                            ; preds = %EndIf
  %40 = getelementptr inbounds { i21, i16 }, { i21, i16 }* %0, i32 0, i32 1
  store i16 20, i16* %40, align 2
  ret void

Else2:                                            ; preds = %EndIf
  br label %EndIf3

EndIf3:                                           ; preds = %Else2
  %41 = load i21, i21* %value, align 4
  %42 = shl i21 %41, 6
  store i21 %42, i21* %value, align 4
  %43 = load i21, i21* %value, align 4
  %44 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 0
  %45 = load i8*, i8** %44, align 8
  %46 = getelementptr inbounds i8, i8* %45, i64 2
  %47 = load i8, i8* %46, align 1
  %48 = and i8 %47, 63
  %49 = zext i8 %48 to i21
  %50 = or i21 %43, %49
  store i21 %50, i21* %value, align 4
  %51 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 0
  %52 = load i8*, i8** %51, align 8
  %53 = getelementptr inbounds i8, i8* %52, i64 3
  %54 = load i8, i8* %53, align 1
  %55 = and i8 %54, -64
  %56 = icmp ne i8 %55, -128
  br i1 %56, label %Then4, label %Else5

Then4:                                            ; preds = %EndIf3
  %57 = getelementptr inbounds { i21, i16 }, { i21, i16 }* %0, i32 0, i32 1
  store i16 20, i16* %57, align 2
  ret void

Else5:                                            ; preds = %EndIf3
  br label %EndIf6

EndIf6:                                           ; preds = %Else5
  %58 = load i21, i21* %value, align 4
  %59 = shl i21 %58, 6
  store i21 %59, i21* %value, align 4
  %60 = load i21, i21* %value, align 4
  %61 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 0
  %62 = load i8*, i8** %61, align 8
  %63 = getelementptr inbounds i8, i8* %62, i64 3
  %64 = load i8, i8* %63, align 1
  %65 = and i8 %64, 63
  %66 = zext i8 %65 to i21
  %67 = or i21 %60, %66
  store i21 %67, i21* %value, align 4
  %68 = load i21, i21* %value, align 4
  %69 = icmp ult i21 %68, 65536
  br i1 %69, label %Then7, label %Else8

Then7:                                            ; preds = %EndIf6
  %70 = getelementptr inbounds { i21, i16 }, { i21, i16 }* %0, i32 0, i32 1
  store i16 21, i16* %70, align 2
  ret void

Else8:                                            ; preds = %EndIf6
  br label %EndIf9

EndIf9:                                           ; preds = %Else8
  %71 = load i21, i21* %value, align 4
  %72 = icmp ugt i21 %71, -983041
  br i1 %72, label %Then10, label %Else11

Then10:                                           ; preds = %EndIf9
  %73 = getelementptr inbounds { i21, i16 }, { i21, i16 }* %0, i32 0, i32 1
  store i16 23, i16* %73, align 2
  ret void

Else11:                                           ; preds = %EndIf9
  br label %EndIf12

EndIf12:                                          ; preds = %Else11
  %74 = load i21, i21* %value, align 4
  %75 = getelementptr inbounds { i21, i16 }, { i21, i16 }* %0, i32 0, i32 1
  store i16 0, i16* %75, align 2
  %76 = getelementptr inbounds { i21, i16 }, { i21, i16 }* %0, i32 0, i32 0
  store i21 %74, i21* %76, align 4
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i64 @std.math.min.30(i64 %0, i64 %1) unnamed_addr #1 {
Entry:
  %result = alloca i64, align 8
  %x = alloca i64, align 8
  %y = alloca i64, align 8
  store i64 %0, i64* %x, align 8
  store i64 %1, i64* %y, align 8
  %2 = load i64, i64* %x, align 8
  %3 = load i64, i64* %y, align 8
  %4 = icmp ult i64 %2, %3
  br i1 %4, label %Then, label %Else

Then:                                             ; preds = %Entry
  %5 = load i64, i64* %x, align 8
  store i64 %5, i64* %result, align 8
  %6 = load i64, i64* %result, align 8
  ret i64 %6

Else:                                             ; preds = %Entry
  %7 = load i64, i64* %y, align 8
  store i64 %7, i64* %result, align 8
  %8 = load i64, i64* %result, align 8
  ret i64 %8
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i64 @std.os.linux.futex_wake(i32* nonnull readonly align 4 %0, i32 %1, i32 %2) unnamed_addr #1 {
Entry:
  %result = alloca i64, align 8
  %uaddr = alloca i32*, align 8
  %futex_op = alloca i32, align 4
  %val = alloca i32, align 4
  store i32* %0, i32** %uaddr, align 8
  store i32 %1, i32* %futex_op, align 4
  store i32 %2, i32* %val, align 4
  %3 = load i32*, i32** %uaddr, align 8
  %4 = ptrtoint i32* %3 to i64
  %5 = load i32, i32* %futex_op, align 4
  %6 = zext i32 %5 to i64
  %7 = load i32, i32* %val, align 4
  %8 = zext i32 %7 to i64
  %9 = call fastcc i64 @std.os.linux.x86_64.syscall3(i64 202, i64 %4, i64 %6, i64 %8)
  store i64 %9, i64* %result, align 8
  %10 = load i64, i64* %result, align 8
  ret i64 %10
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.Thread.StaticResetEvent.LinuxFutex.wait(i32* nonnull align 4 %0, %"?u64"* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %ts = alloca %std.os.linux.timespec, align 8
  %ts_ptr = alloca %std.os.linux.timespec*, align 8
  %timeout_ns = alloca i64, align 8
  %waiting = alloca i32, align 4
  %expected = alloca i32, align 4
  %ptr = alloca i32*, align 8
  %rc = alloca i64, align 8
  %2 = alloca i16, align 2
  %waiters = alloca i32*, align 8
  store i32* %0, i32** %waiters, align 8
  store %std.os.linux.timespec* null, %std.os.linux.timespec** %ts_ptr, align 8
  %3 = getelementptr inbounds %"?u64", %"?u64"* %1, i32 0, i32 1
  %4 = load i1, i1* %3, align 1
  br i1 %4, label %OptionalThen, label %OptionalElse

OptionalThen:                                     ; preds = %Entry
  %5 = getelementptr inbounds %"?u64", %"?u64"* %1, i32 0, i32 0
  %6 = load i64, i64* %5, align 8
  store i64 %6, i64* %timeout_ns, align 8
  store %std.os.linux.timespec* %ts, %std.os.linux.timespec** %ts_ptr, align 8
  %7 = getelementptr inbounds %std.os.linux.timespec, %std.os.linux.timespec* %ts, i32 0, i32 0
  %8 = load i64, i64* %timeout_ns, align 8
  %9 = udiv i64 %8, 1000000000
  store i64 %9, i64* %7, align 8
  %10 = getelementptr inbounds %std.os.linux.timespec, %std.os.linux.timespec* %ts, i32 0, i32 1
  %11 = load i64, i64* %timeout_ns, align 8
  %12 = urem i64 %11, 1000000000
  store i64 %12, i64* %10, align 8
  br label %OptionalEndIf

OptionalElse:                                     ; preds = %Entry
  br label %OptionalEndIf

OptionalEndIf:                                    ; preds = %OptionalElse, %OptionalThen
  br label %WhileCond

WhileCond:                                        ; preds = %SwitchProng2, %SwitchProng, %OptionalEndIf
  br label %WhileBody

WhileBody:                                        ; preds = %WhileCond
  %13 = load i32*, i32** %waiters, align 8
  %14 = load atomic i32, i32* %13 acquire, align 4
  store i32 %14, i32* %waiting, align 4
  %15 = load i32, i32* %waiting, align 4
  %16 = icmp eq i32 %15, 1
  br i1 %16, label %Then, label %Else

Then:                                             ; preds = %WhileBody
  store i16 0, i16* %result, align 2
  %17 = load i16, i16* %result, align 2
  ret i16 %17

Else:                                             ; preds = %WhileBody
  br label %EndIf

EndIf:                                            ; preds = %Else
  %18 = load i32, i32* %waiting, align 4
  store i32 %18, i32* %expected, align 4
  %19 = load i32*, i32** %waiters, align 8
  store i32* %19, i32** %ptr, align 8
  %20 = load i32*, i32** %ptr, align 8
  %21 = load i32, i32* %expected, align 4
  %22 = load %std.os.linux.timespec*, %std.os.linux.timespec** %ts_ptr, align 8
  %23 = call fastcc i64 @std.os.linux.futex_wait(i32* %20, i32 128, i32 %21, %std.os.linux.timespec* %22)
  store i64 %23, i64* %rc, align 8
  %24 = load i64, i64* %rc, align 8
  %25 = call fastcc i16 @std.os.linux.getErrno(i64 %24)
  store i16 %25, i16* %2, align 2
  switch i16 %25, label %SwitchElse [
    i16 0, label %SwitchProng
    i16 110, label %SwitchProng1
    i16 4, label %SwitchProng2
    i16 11, label %SwitchProng3
  ]

SwitchElse:                                       ; preds = %EndIf
  unreachable

SwitchProng:                                      ; preds = %EndIf
  br label %WhileCond

SwitchProng1:                                     ; preds = %EndIf
  store i16 42, i16* %result, align 2
  %26 = load i16, i16* %result, align 2
  ret i16 %26

SwitchProng2:                                     ; preds = %EndIf
  br label %WhileCond

SwitchProng3:                                     ; preds = %EndIf
  store i16 0, i16* %result, align 2
  %27 = load i16, i16* %result, align 2
  ret i16 %27
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i64 @std.mem.alignBackwardGeneric(i64 %0, i64 %1) unnamed_addr #1 {
Entry:
  %result = alloca i64, align 8
  %addr = alloca i64, align 8
  %alignment = alloca i64, align 8
  store i64 %0, i64* %addr, align 8
  store i64 %1, i64* %alignment, align 8
  %2 = load i64, i64* %alignment, align 8
  %3 = call i64 @llvm.ctpop.i64(i64 %2)
  %4 = trunc i64 %3 to i7
  %5 = icmp eq i7 %4, 1
  call fastcc void @std.debug.assert(i1 %5)
  %6 = load i64, i64* %addr, align 8
  %7 = load i64, i64* %alignment, align 8
  %8 = sub nuw i64 %7, 1
  %9 = xor i64 %8, -1
  %10 = and i64 %6, %9
  store i64 %10, i64* %result, align 8
  %11 = load i64, i64* %result, align 8
  ret i64 %11
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i64 @std.os.linux.prlimit(i32 %0, i32 %1, %std.os.linux.rlimit* align 8 %2, %std.os.linux.rlimit* align 8 %3) unnamed_addr #1 {
Entry:
  %result = alloca i64, align 8
  %pid = alloca i32, align 4
  %resource = alloca i32, align 4
  %new_limit = alloca %std.os.linux.rlimit*, align 8
  %old_limit = alloca %std.os.linux.rlimit*, align 8
  store i32 %0, i32* %pid, align 4
  store i32 %1, i32* %resource, align 4
  store %std.os.linux.rlimit* %2, %std.os.linux.rlimit** %new_limit, align 8
  store %std.os.linux.rlimit* %3, %std.os.linux.rlimit** %old_limit, align 8
  %4 = load i32, i32* %pid, align 4
  %5 = sext i32 %4 to i64
  %6 = sext i32 %4 to i64
  %7 = load i32, i32* %resource, align 4
  %8 = sext i32 %7 to i64
  %9 = sext i32 %7 to i64
  %10 = load %std.os.linux.rlimit*, %std.os.linux.rlimit** %new_limit, align 8
  %11 = ptrtoint %std.os.linux.rlimit* %10 to i64
  %12 = load %std.os.linux.rlimit*, %std.os.linux.rlimit** %old_limit, align 8
  %13 = ptrtoint %std.os.linux.rlimit* %12 to i64
  %14 = call fastcc i64 @std.os.linux.x86_64.syscall4(i64 302, i64 %6, i64 %9, i64 %11, i64 %13)
  store i64 %14, i64* %result, align 8
  %15 = load i64, i64* %result, align 8
  ret i64 %15
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i1 @std.target.Target.isDarwin(%std.target.Target* nonnull readonly align 8 %0) unnamed_addr #1 {
Entry:
  %result = alloca i1, align 1
  %1 = getelementptr inbounds %std.target.Target, %std.target.Target* %0, i32 0, i32 1
  %2 = getelementptr inbounds %std.target.Os, %std.target.Os* %1, i32 0, i32 0
  %3 = load i6, i6* %2, align 1
  %4 = call fastcc i1 @std.target.Tag.isDarwin(i6 %3)
  store i1 %4, i1* %result, align 1
  %5 = load i1, i1* %result, align 1
  ret i1 %5
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i1 @std.target.Tag.isDarwin(i6 %0) unnamed_addr #1 {
Entry:
  %result = alloca i1, align 1
  %tag = alloca i6, align 1
  store i6 %0, i6* %tag, align 1
  %1 = load i6, i6* %tag, align 1
  switch i6 %1, label %SwitchElse [
    i6 6, label %SwitchProng
    i6 10, label %SwitchProng
    i6 27, label %SwitchProng
    i6 26, label %SwitchProng
  ]

SwitchElse:                                       ; preds = %Entry
  store i1 false, i1* %result, align 1
  br label %SwitchEnd

SwitchProng:                                      ; preds = %Entry, %Entry, %Entry, %Entry
  store i1 true, i1* %result, align 1
  br label %SwitchEnd

SwitchEnd:                                        ; preds = %SwitchProng, %SwitchElse
  %2 = load i1, i1* %result, align 1
  ret i1 %2
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.special.main() unnamed_addr #1 {
Entry:
  %test_fn_list = alloca %"[]std.builtin.TestFn", align 8
  %ok_count = alloca i64, align 8
  %skip_count = alloca i64, align 8
  %fail_count = alloca i64, align 8
  %progress = alloca %std.Progress, align 8
  %0 = alloca { %std.Progress.Node*, i16 }, align 8
  %err = alloca i16, align 2
  %root_node = alloca %std.Progress.Node*, align 8
  %have_tty = alloca i1, align 1
  %async_frame_buffer = alloca %"[]u8", align 8
  %leaks = alloca i64, align 8
  %i = alloca i64, align 8
  %test_fn = alloca %std.builtin.TestFn, align 8
  %test_node = alloca %std.Progress.Node, align 8
  %1 = alloca %"std.special.struct:62:49", align 8
  %size = alloca i64, align 8
  %2 = alloca %"std.special.struct:76:61", align 8
  %result = alloca i16, align 2
  %err35 = alloca i16, align 2
  %3 = alloca %"std.special.struct:95:54", align 8
  %4 = alloca %"std.special.struct:96:65", align 8
  %5 = alloca %"std.special.struct:89:48", align 8
  %6 = alloca %"std.special.struct:105:53", align 8
  %7 = alloca %"std.special.struct:107:68", align 8
  %8 = alloca %"std.special.struct:110:55", align 8
  %9 = alloca %"std.special.struct:113:56", align 8
  call fastcc void @std.special.processArgs()
  %10 = bitcast %"[]std.builtin.TestFn"* %test_fn_list to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %10, i8* align 8 bitcast (%"[]std.builtin.TestFn"* @test_functions to i8*), i64 16, i1 false)
  store i64 0, i64* %ok_count, align 8
  store i64 0, i64* %skip_count, align 8
  store i64 0, i64* %fail_count, align 8
  %11 = bitcast %std.Progress* %progress to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %11, i8* align 8 bitcast ({ %"?std.fs.file.File", i1, i1, <{ i1, [5 x i8] }>, %std.Progress.Node, %std.time.Timer, i64, <{ [100 x i8], [4 x i8] }>, i64, i64, <{ i1, [3 x i8] }>, %std.Thread.Mutex, i64 }* @92 to i8*), i64 232, i1 false)
  %12 = getelementptr inbounds %"[]std.builtin.TestFn", %"[]std.builtin.TestFn"* %test_fn_list, i32 0, i32 1
  %13 = load i64, i64* %12, align 8
  call fastcc void @std.Progress.start({ %std.Progress.Node*, i16 }* sret({ %std.Progress.Node*, i16 }) %0, %std.Progress* %progress, %"[]u8"* @94, i64 %13)
  %14 = getelementptr inbounds { %std.Progress.Node*, i16 }, { %std.Progress.Node*, i16 }* %0, i32 0, i32 1
  %15 = load i16, i16* %14, align 2
  %16 = icmp ne i16 %15, 0
  br i1 %16, label %UnwrapErrError, label %UnwrapErrOk

UnwrapErrError:                                   ; preds = %Entry
  %17 = getelementptr inbounds { %std.Progress.Node*, i16 }, { %std.Progress.Node*, i16 }* %0, i32 0, i32 1
  %18 = load i16, i16* %17, align 2
  store i16 %18, i16* %err, align 2
  %19 = load i16, i16* %err, align 2
  switch i16 %19, label %SwitchElse [
    i16 43, label %SwitchProng
  ]

SwitchProng:                                      ; preds = %UnwrapErrError
  call fastcc void @std.builtin.default_panic(%"[]u8"* @96, %std.builtin.StackTrace* null)
  unreachable

SwitchElse:                                       ; preds = %UnwrapErrError
  unreachable

UnwrapErrOk:                                      ; preds = %Entry
  %20 = getelementptr inbounds { %std.Progress.Node*, i16 }, { %std.Progress.Node*, i16 }* %0, i32 0, i32 0
  %21 = load %std.Progress.Node*, %std.Progress.Node** %20, align 8
  store %std.Progress.Node* %21, %std.Progress.Node** %root_node, align 8
  br label %UnwrapErrEnd

UnwrapErrEnd:                                     ; preds = %UnwrapErrOk
  %22 = getelementptr inbounds %std.Progress, %std.Progress* %progress, i32 0, i32 0
  %23 = getelementptr inbounds %"?std.fs.file.File", %"?std.fs.file.File"* %22, i32 0, i32 1
  %24 = load i1, i1* %23, align 1
  br i1 %24, label %BoolAndTrue, label %BoolAndFalse

BoolAndTrue:                                      ; preds = %UnwrapErrEnd
  %25 = getelementptr inbounds %std.Progress, %std.Progress* %progress, i32 0, i32 2
  %26 = load i1, i1* %25, align 1
  br label %BoolAndFalse

BoolAndFalse:                                     ; preds = %BoolAndTrue, %UnwrapErrEnd
  %27 = phi i1 [ %24, %UnwrapErrEnd ], [ %26, %BoolAndTrue ]
  store i1 %27, i1* %have_tty, align 1
  %28 = bitcast %"[]u8"* %async_frame_buffer to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %28, i8* align 8 bitcast (%"[]u8"* @97 to i8*), i64 16, i1 false)
  store i64 0, i64* %leaks, align 8
  store i64 0, i64* %i, align 8
  %29 = getelementptr inbounds %"[]std.builtin.TestFn", %"[]std.builtin.TestFn"* %test_fn_list, i32 0, i32 1
  %30 = load i64, i64* %29, align 8
  br label %ForCond

ForCond:                                          ; preds = %ForContinue, %BoolAndFalse
  %31 = load i64, i64* %i, align 8
  %32 = icmp ult i64 %31, %30
  br i1 %32, label %ForBody, label %ForEnd

ForBody:                                          ; preds = %ForCond
  %33 = getelementptr inbounds %"[]std.builtin.TestFn", %"[]std.builtin.TestFn"* %test_fn_list, i32 0, i32 0
  %34 = load %std.builtin.TestFn*, %std.builtin.TestFn** %33, align 8
  %35 = getelementptr inbounds %std.builtin.TestFn, %std.builtin.TestFn* %34, i64 %31
  %36 = bitcast %std.builtin.TestFn* %35 to i8*
  %37 = bitcast %std.builtin.TestFn* %test_fn to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %37, i8* align 8 %36, i64 40, i1 false)
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 bitcast ({ %std.mem.Allocator, [12 x %std.heap.general_purpose_allocator.BucketHeader*], %"std.hash_map.HashMapUnmanaged(usize,std.heap.general_purpose_allocator.LargeAlloc,std.hash_map.AutoContext(usize),80)", <{ %std.Thread.Mutex, [4 x i8] }> }* @allocator_instance to i8*), i8* align 8 bitcast (%std.mem.Allocator* @98 to i8*), i64 16, i1 false)
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 bitcast ([12 x %std.heap.general_purpose_allocator.BucketHeader*]* getelementptr inbounds (%"std.heap.general_purpose_allocator.GeneralPurposeAllocator((struct std.heap.general_purpose_allocator.Config constant))", %"std.heap.general_purpose_allocator.GeneralPurposeAllocator((struct std.heap.general_purpose_allocator.Config constant))"* bitcast ({ %std.mem.Allocator, [12 x %std.heap.general_purpose_allocator.BucketHeader*], %"std.hash_map.HashMapUnmanaged(usize,std.heap.general_purpose_allocator.LargeAlloc,std.hash_map.AutoContext(usize),80)", <{ %std.Thread.Mutex, [4 x i8] }> }* @allocator_instance to %"std.heap.general_purpose_allocator.GeneralPurposeAllocator((struct std.heap.general_purpose_allocator.Config constant))"*), i32 0, i32 1) to i8*), i8* align 8 bitcast ([12 x %std.heap.general_purpose_allocator.BucketHeader*]* @99 to i8*), i64 96, i1 false)
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 bitcast (%"std.hash_map.HashMapUnmanaged(usize,std.heap.general_purpose_allocator.LargeAlloc,std.hash_map.AutoContext(usize),80)"* getelementptr inbounds (%"std.heap.general_purpose_allocator.GeneralPurposeAllocator((struct std.heap.general_purpose_allocator.Config constant))", %"std.heap.general_purpose_allocator.GeneralPurposeAllocator((struct std.heap.general_purpose_allocator.Config constant))"* bitcast ({ %std.mem.Allocator, [12 x %std.heap.general_purpose_allocator.BucketHeader*], %"std.hash_map.HashMapUnmanaged(usize,std.heap.general_purpose_allocator.LargeAlloc,std.hash_map.AutoContext(usize),80)", <{ %std.Thread.Mutex, [4 x i8] }> }* @allocator_instance to %"std.heap.general_purpose_allocator.GeneralPurposeAllocator((struct std.heap.general_purpose_allocator.Config constant))"*), i32 0, i32 2) to i8*), i8* align 8 bitcast (%"std.hash_map.HashMapUnmanaged(usize,std.heap.general_purpose_allocator.LargeAlloc,std.hash_map.AutoContext(usize),80)"* @100 to i8*), i64 16, i1 false)
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 bitcast (%std.Thread.Mutex* getelementptr inbounds (%"std.heap.general_purpose_allocator.GeneralPurposeAllocator((struct std.heap.general_purpose_allocator.Config constant))", %"std.heap.general_purpose_allocator.GeneralPurposeAllocator((struct std.heap.general_purpose_allocator.Config constant))"* bitcast ({ %std.mem.Allocator, [12 x %std.heap.general_purpose_allocator.BucketHeader*], %"std.hash_map.HashMapUnmanaged(usize,std.heap.general_purpose_allocator.LargeAlloc,std.hash_map.AutoContext(usize),80)", <{ %std.Thread.Mutex, [4 x i8] }> }* @allocator_instance to %"std.heap.general_purpose_allocator.GeneralPurposeAllocator((struct std.heap.general_purpose_allocator.Config constant))"*), i32 0, i32 3) to i8*), i8* align 4 bitcast (%std.Thread.Mutex* @101 to i8*), i64 4, i1 false)
  store i2 1, i2* @log_level, align 1
  %38 = load %std.Progress.Node*, %std.Progress.Node** %root_node, align 8
  %39 = getelementptr inbounds %std.builtin.TestFn, %std.builtin.TestFn* %test_fn, i32 0, i32 0
  call fastcc void @std.Progress.Node.start(%std.Progress.Node* sret(%std.Progress.Node) %test_node, %std.Progress.Node* %38, %"[]u8"* %39, i64 0)
  call fastcc void @std.Progress.Node.activate(%std.Progress.Node* %test_node)
  call fastcc void @std.Progress.refresh(%std.Progress* %progress)
  %40 = load i1, i1* %have_tty, align 1
  %41 = icmp eq i1 %40, false
  br i1 %41, label %Then, label %Else

Then:                                             ; preds = %ForBody
  %42 = load i64, i64* %i, align 8
  %43 = add nuw i64 %42, 1
  %44 = getelementptr inbounds %"std.special.struct:62:49", %"std.special.struct:62:49"* %1, i32 0, i32 0
  store i64 %43, i64* %44, align 8
  %45 = getelementptr inbounds %"[]std.builtin.TestFn", %"[]std.builtin.TestFn"* %test_fn_list, i32 0, i32 1
  %46 = load i64, i64* %45, align 8
  %47 = getelementptr inbounds %"std.special.struct:62:49", %"std.special.struct:62:49"* %1, i32 0, i32 1
  store i64 %46, i64* %47, align 8
  %48 = getelementptr inbounds %std.builtin.TestFn, %std.builtin.TestFn* %test_fn, i32 0, i32 0
  %49 = getelementptr inbounds %"std.special.struct:62:49", %"std.special.struct:62:49"* %1, i32 0, i32 2
  %50 = bitcast %"[]u8"* %48 to i8*
  %51 = bitcast %"[]u8"* %49 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %51, i8* align 8 %50, i64 16, i1 false)
  call fastcc void @std.debug.print(%"std.special.struct:62:49"* %1)
  br label %EndIf

Else:                                             ; preds = %ForBody
  br label %EndIf

EndIf:                                            ; preds = %Else, %Then
  %52 = getelementptr inbounds %std.builtin.TestFn, %std.builtin.TestFn* %test_fn, i32 0, i32 2
  %53 = getelementptr inbounds %"?usize", %"?usize"* %52, i32 0, i32 1
  %54 = load i1, i1* %53, align 1
  br i1 %54, label %OptionalThen, label %OptionalElse

OptionalThen:                                     ; preds = %EndIf
  %55 = getelementptr inbounds %"?usize", %"?usize"* %52, i32 0, i32 0
  %56 = load i64, i64* %55, align 8
  store i64 %56, i64* %size, align 8
  %57 = load i64, i64* %skip_count, align 8
  %58 = add nuw i64 %57, 1
  store i64 %58, i64* %skip_count, align 8
  call fastcc void @std.Progress.Node.end(%std.Progress.Node* %test_node)
  %59 = getelementptr inbounds %std.builtin.TestFn, %std.builtin.TestFn* %test_fn, i32 0, i32 0
  %60 = getelementptr inbounds %"std.special.struct:76:61", %"std.special.struct:76:61"* %2, i32 0, i32 0
  %61 = bitcast %"[]u8"* %59 to i8*
  %62 = bitcast %"[]u8"* %60 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %62, i8* align 8 %61, i64 16, i1 false)
  call fastcc void @std.Progress.log(%std.Progress* %progress, %"std.special.struct:76:61"* %2)
  %63 = load i1, i1* %have_tty, align 1
  %64 = icmp eq i1 %63, false
  br i1 %64, label %Then1, label %Else2

Then1:                                            ; preds = %OptionalThen
  call fastcc void @std.debug.print.31()
  br label %EndIf3

Else2:                                            ; preds = %OptionalThen
  br label %EndIf3

EndIf3:                                           ; preds = %Else2, %Then1
  %65 = call fastcc i1 @"std.heap.general_purpose_allocator.GeneralPurposeAllocator((struct std.heap.general_purpose_allocator.Config constant)).deinit"(%"std.heap.general_purpose_allocator.GeneralPurposeAllocator((struct std.heap.general_purpose_allocator.Config constant))"* bitcast ({ %std.mem.Allocator, [12 x %std.heap.general_purpose_allocator.BucketHeader*], %"std.hash_map.HashMapUnmanaged(usize,std.heap.general_purpose_allocator.LargeAlloc,std.hash_map.AutoContext(usize),80)", <{ %std.Thread.Mutex, [4 x i8] }> }* @allocator_instance to %"std.heap.general_purpose_allocator.GeneralPurposeAllocator((struct std.heap.general_purpose_allocator.Config constant))"*))
  br i1 %65, label %Then4, label %Else5

Then4:                                            ; preds = %EndIf3
  %66 = load i64, i64* %leaks, align 8
  %67 = add nuw i64 %66, 1
  store i64 %67, i64* %leaks, align 8
  br label %EndIf6

Else5:                                            ; preds = %EndIf3
  br label %EndIf6

EndIf6:                                           ; preds = %Else5, %Then4
  br label %ForContinue

OptionalElse:                                     ; preds = %EndIf
  %68 = getelementptr inbounds %std.builtin.TestFn, %std.builtin.TestFn* %test_fn, i32 0, i32 1
  %69 = load i16 ()*, i16 ()** %68, align 8
  %70 = call fastcc i16 %69()
  store i16 %70, i16* %result, align 2
  br label %OptionalEndIf

OptionalEndIf:                                    ; preds = %OptionalElse
  %71 = load i16, i16* %result, align 2
  %72 = icmp ne i16 %71, 0
  br i1 %72, label %TryElse, label %TryOk

TryOk:                                            ; preds = %OptionalEndIf
  %73 = load i64, i64* %ok_count, align 8
  %74 = add nuw i64 %73, 1
  store i64 %74, i64* %ok_count, align 8
  call fastcc void @std.Progress.Node.end(%std.Progress.Node* %test_node)
  %75 = load i1, i1* %have_tty, align 1
  %76 = icmp eq i1 %75, false
  br i1 %76, label %Then7, label %Else8

Then7:                                            ; preds = %TryOk
  call fastcc void @std.debug.print.32()
  br label %EndIf15

Else8:                                            ; preds = %TryOk
  br label %EndIf15

TryElse:                                          ; preds = %OptionalEndIf
  %77 = load i16, i16* %result, align 2
  store i16 %77, i16* %err35, align 2
  %78 = load i16, i16* %err35, align 2
  switch i16 %78, label %SwitchElse9 [
    i16 44, label %SwitchProng12
  ]

SwitchElse9:                                      ; preds = %TryElse
  %79 = load i64, i64* %fail_count, align 8
  %80 = add nuw i64 %79, 1
  store i64 %80, i64* %fail_count, align 8
  call fastcc void @std.Progress.Node.end(%std.Progress.Node* %test_node)
  %81 = getelementptr inbounds %std.builtin.TestFn, %std.builtin.TestFn* %test_fn, i32 0, i32 0
  %82 = getelementptr inbounds %"std.special.struct:95:54", %"std.special.struct:95:54"* %3, i32 0, i32 0
  %83 = bitcast %"[]u8"* %81 to i8*
  %84 = bitcast %"[]u8"* %82 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %84, i8* align 8 %83, i64 16, i1 false)
  %85 = load i16, i16* %err35, align 2
  %86 = getelementptr inbounds [48 x %"[]u8"], [48 x %"[]u8"]* @__zig_err_name_table, i64 0, i16 %85
  %87 = getelementptr inbounds %"std.special.struct:95:54", %"std.special.struct:95:54"* %3, i32 0, i32 1
  %88 = bitcast %"[]u8"* %86 to i8*
  %89 = bitcast %"[]u8"* %87 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %89, i8* align 8 %88, i64 16, i1 false)
  call fastcc void @std.Progress.log.33(%std.Progress* %progress, %"std.special.struct:95:54"* %3)
  %90 = load i1, i1* %have_tty, align 1
  %91 = icmp eq i1 %90, false
  br i1 %91, label %Then10, label %Else11

Then10:                                           ; preds = %SwitchElse9
  %92 = load i16, i16* %err35, align 2
  %93 = getelementptr inbounds [48 x %"[]u8"], [48 x %"[]u8"]* @__zig_err_name_table, i64 0, i16 %92
  %94 = getelementptr inbounds %"std.special.struct:96:65", %"std.special.struct:96:65"* %4, i32 0, i32 0
  %95 = bitcast %"[]u8"* %93 to i8*
  %96 = bitcast %"[]u8"* %94 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %96, i8* align 8 %95, i64 16, i1 false)
  call fastcc void @std.debug.print.34(%"std.special.struct:96:65"* %4)
  br label %EndIf16

Else11:                                           ; preds = %SwitchElse9
  br label %EndIf16

SwitchProng12:                                    ; preds = %TryElse
  %97 = load i64, i64* %skip_count, align 8
  %98 = add nuw i64 %97, 1
  store i64 %98, i64* %skip_count, align 8
  call fastcc void @std.Progress.Node.end(%std.Progress.Node* %test_node)
  %99 = getelementptr inbounds %std.builtin.TestFn, %std.builtin.TestFn* %test_fn, i32 0, i32 0
  %100 = getelementptr inbounds %"std.special.struct:89:48", %"std.special.struct:89:48"* %5, i32 0, i32 0
  %101 = bitcast %"[]u8"* %99 to i8*
  %102 = bitcast %"[]u8"* %100 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %102, i8* align 8 %101, i64 16, i1 false)
  call fastcc void @std.Progress.log.35(%std.Progress* %progress, %"std.special.struct:89:48"* %5)
  %103 = load i1, i1* %have_tty, align 1
  %104 = icmp eq i1 %103, false
  br i1 %104, label %Then13, label %Else14

Then13:                                           ; preds = %SwitchProng12
  call fastcc void @std.debug.print.36()
  br label %EndIf17

Else14:                                           ; preds = %SwitchProng12
  br label %EndIf17

EndIf15:                                          ; preds = %Else8, %Then7
  br label %TryEnd

EndIf16:                                          ; preds = %Else11, %Then10
  br label %SwitchEnd

EndIf17:                                          ; preds = %Else14, %Then13
  br label %SwitchEnd

SwitchEnd:                                        ; preds = %EndIf17, %EndIf16
  br label %TryEnd

TryEnd:                                           ; preds = %SwitchEnd, %EndIf15
  %105 = call fastcc i1 @"std.heap.general_purpose_allocator.GeneralPurposeAllocator((struct std.heap.general_purpose_allocator.Config constant)).deinit"(%"std.heap.general_purpose_allocator.GeneralPurposeAllocator((struct std.heap.general_purpose_allocator.Config constant))"* bitcast ({ %std.mem.Allocator, [12 x %std.heap.general_purpose_allocator.BucketHeader*], %"std.hash_map.HashMapUnmanaged(usize,std.heap.general_purpose_allocator.LargeAlloc,std.hash_map.AutoContext(usize),80)", <{ %std.Thread.Mutex, [4 x i8] }> }* @allocator_instance to %"std.heap.general_purpose_allocator.GeneralPurposeAllocator((struct std.heap.general_purpose_allocator.Config constant))"*))
  br i1 %105, label %Then18, label %Else19

Then18:                                           ; preds = %TryEnd
  %106 = load i64, i64* %leaks, align 8
  %107 = add nuw i64 %106, 1
  store i64 %107, i64* %leaks, align 8
  br label %EndIf20

Else19:                                           ; preds = %TryEnd
  br label %EndIf20

EndIf20:                                          ; preds = %Else19, %Then18
  br label %ForContinue

ForContinue:                                      ; preds = %EndIf20, %EndIf6
  %108 = add nuw i64 %31, 1
  store i64 %108, i64* %i, align 8
  br label %ForCond

ForEnd:                                           ; preds = %ForCond
  %109 = load %std.Progress.Node*, %std.Progress.Node** %root_node, align 8
  call fastcc void @std.Progress.Node.end(%std.Progress.Node* %109)
  %110 = load i64, i64* %ok_count, align 8
  %111 = getelementptr inbounds %"[]std.builtin.TestFn", %"[]std.builtin.TestFn"* %test_fn_list, i32 0, i32 1
  %112 = load i64, i64* %111, align 8
  %113 = icmp eq i64 %110, %112
  br i1 %113, label %Then21, label %Else22

Then21:                                           ; preds = %ForEnd
  %114 = load i64, i64* %ok_count, align 8
  %115 = getelementptr inbounds %"std.special.struct:105:53", %"std.special.struct:105:53"* %6, i32 0, i32 0
  store i64 %114, i64* %115, align 8
  call fastcc void @std.debug.print.37(%"std.special.struct:105:53"* %6)
  br label %EndIf23

Else22:                                           ; preds = %ForEnd
  %116 = load i64, i64* %ok_count, align 8
  %117 = getelementptr inbounds %"std.special.struct:107:68", %"std.special.struct:107:68"* %7, i32 0, i32 0
  store i64 %116, i64* %117, align 8
  %118 = load i64, i64* %skip_count, align 8
  %119 = getelementptr inbounds %"std.special.struct:107:68", %"std.special.struct:107:68"* %7, i32 0, i32 1
  store i64 %118, i64* %119, align 8
  %120 = load i64, i64* %fail_count, align 8
  %121 = getelementptr inbounds %"std.special.struct:107:68", %"std.special.struct:107:68"* %7, i32 0, i32 2
  store i64 %120, i64* %121, align 8
  call fastcc void @std.debug.print.38(%"std.special.struct:107:68"* %7)
  br label %EndIf23

EndIf23:                                          ; preds = %Else22, %Then21
  %122 = load i64, i64* @log_err_count, align 8
  %123 = icmp ne i64 %122, 0
  br i1 %123, label %Then24, label %Else25

Then24:                                           ; preds = %EndIf23
  %124 = load i64, i64* @log_err_count, align 8
  %125 = getelementptr inbounds %"std.special.struct:110:55", %"std.special.struct:110:55"* %8, i32 0, i32 0
  store i64 %124, i64* %125, align 8
  call fastcc void @std.debug.print.39(%"std.special.struct:110:55"* %8)
  br label %EndIf26

Else25:                                           ; preds = %EndIf23
  br label %EndIf26

EndIf26:                                          ; preds = %Else25, %Then24
  %126 = load i64, i64* %leaks, align 8
  %127 = icmp ne i64 %126, 0
  br i1 %127, label %Then27, label %Else28

Then27:                                           ; preds = %EndIf26
  %128 = load i64, i64* %leaks, align 8
  %129 = getelementptr inbounds %"std.special.struct:113:56", %"std.special.struct:113:56"* %9, i32 0, i32 0
  store i64 %128, i64* %129, align 8
  call fastcc void @std.debug.print.40(%"std.special.struct:113:56"* %9)
  br label %EndIf29

Else28:                                           ; preds = %EndIf26
  br label %EndIf29

EndIf29:                                          ; preds = %Else28, %Then27
  %130 = load i64, i64* %leaks, align 8
  %131 = icmp ne i64 %130, 0
  br i1 %131, label %BoolOrTrue, label %BoolOrFalse

BoolOrFalse:                                      ; preds = %EndIf29
  %132 = load i64, i64* @log_err_count, align 8
  %133 = icmp ne i64 %132, 0
  br label %BoolOrTrue

BoolOrTrue:                                       ; preds = %BoolOrFalse, %EndIf29
  %134 = phi i1 [ %131, %EndIf29 ], [ %133, %BoolOrFalse ]
  br i1 %134, label %BoolOrTrue31, label %BoolOrFalse30

BoolOrFalse30:                                    ; preds = %BoolOrTrue
  %135 = load i64, i64* %fail_count, align 8
  %136 = icmp ne i64 %135, 0
  br label %BoolOrTrue31

BoolOrTrue31:                                     ; preds = %BoolOrFalse30, %BoolOrTrue
  %137 = phi i1 [ %134, %BoolOrTrue ], [ %136, %BoolOrFalse30 ]
  br i1 %137, label %Then32, label %Else33

Then32:                                           ; preds = %BoolOrTrue31
  call fastcc void @std.os.exit(i8 1)
  unreachable

Else33:                                           ; preds = %BoolOrTrue31
  br label %EndIf34

EndIf34:                                          ; preds = %Else33
  ret void
}

; Function Attrs: nofree nosync nounwind readnone speculatable willreturn
declare i64 @llvm.ctpop.i64(i64 %0) #9

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.special.processArgs() unnamed_addr #1 {
Entry:
  %0 = alloca %std.mem.Allocator, align 8
  %1 = alloca { %"[][]u8", i16 }, align 8
  %args = alloca %"[][]u8", align 8
  %self_name = alloca %"[]u8", align 8
  %2 = alloca %"std.special.struct:19:57", align 8
  call fastcc void @std.heap.FixedBufferAllocator.allocator(%std.mem.Allocator* sret(%std.mem.Allocator) %0, %std.heap.FixedBufferAllocator* @args_allocator)
  call fastcc void @std.process.argsAlloc({ %"[][]u8", i16 }* sret({ %"[][]u8", i16 }) %1, %std.mem.Allocator* %0)
  %3 = getelementptr inbounds { %"[][]u8", i16 }, { %"[][]u8", i16 }* %1, i32 0, i32 1
  %4 = load i16, i16* %3, align 2
  %5 = icmp ne i16 %4, 0
  br i1 %5, label %UnwrapErrError, label %UnwrapErrOk

UnwrapErrError:                                   ; preds = %Entry
  call fastcc void @std.builtin.default_panic(%"[]u8"* @103, %std.builtin.StackTrace* null)
  unreachable

UnwrapErrOk:                                      ; preds = %Entry
  %6 = getelementptr inbounds { %"[][]u8", i16 }, { %"[][]u8", i16 }* %1, i32 0, i32 0
  %7 = bitcast %"[][]u8"* %6 to i8*
  %8 = bitcast %"[][]u8"* %args to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %8, i8* align 8 %7, i64 16, i1 false)
  br label %UnwrapErrEnd

UnwrapErrEnd:                                     ; preds = %UnwrapErrOk
  %9 = getelementptr inbounds %"[][]u8", %"[][]u8"* %args, i32 0, i32 1
  %10 = load i64, i64* %9, align 8
  %11 = icmp ne i64 %10, 2
  br i1 %11, label %Then, label %Else2

Then:                                             ; preds = %UnwrapErrEnd
  %12 = getelementptr inbounds %"[][]u8", %"[][]u8"* %args, i32 0, i32 1
  %13 = load i64, i64* %12, align 8
  %14 = icmp uge i64 %13, 1
  br i1 %14, label %Then1, label %Else

Then1:                                            ; preds = %Then
  %15 = getelementptr inbounds %"[][]u8", %"[][]u8"* %args, i32 0, i32 0
  %16 = load %"[]u8"*, %"[]u8"** %15, align 8
  %17 = getelementptr inbounds %"[]u8", %"[]u8"* %16, i64 0
  %18 = bitcast %"[]u8"* %17 to i8*
  %19 = bitcast %"[]u8"* %self_name to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %19, i8* align 8 %18, i64 16, i1 false)
  br label %EndIf

Else:                                             ; preds = %Then
  %20 = bitcast %"[]u8"* %self_name to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %20, i8* align 8 bitcast (%"[]u8"* @105 to i8*), i64 16, i1 false)
  %21 = bitcast %"[]u8"* %self_name to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %21, i8* align 8 bitcast (%"[]u8"* @106 to i8*), i64 16, i1 false)
  br label %EndIf

EndIf:                                            ; preds = %Else, %Then1
  %22 = getelementptr inbounds %"std.special.struct:19:57", %"std.special.struct:19:57"* %2, i32 0, i32 0
  %23 = bitcast %"[]u8"* %self_name to i8*
  %24 = bitcast %"[]u8"* %22 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %24, i8* align 8 %23, i64 16, i1 false)
  call fastcc void @std.debug.print.41(%"std.special.struct:19:57"* %2)
  call fastcc void @std.builtin.default_panic(%"[]u8"* @109, %std.builtin.StackTrace* null)
  unreachable

Else2:                                            ; preds = %UnwrapErrEnd
  br label %EndIf3

EndIf3:                                           ; preds = %Else2
  %25 = getelementptr inbounds %"[][]u8", %"[][]u8"* %args, i32 0, i32 0
  %26 = load %"[]u8"*, %"[]u8"** %25, align 8
  %27 = getelementptr inbounds %"[]u8", %"[]u8"* %26, i64 1
  %28 = bitcast %"[]u8"* %27 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 bitcast (%"[]u8"* @zig_exe_path to i8*), i8* align 8 %28, i64 16, i1 false)
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.Progress.start({ %std.Progress.Node*, i16 }* nonnull sret({ %std.Progress.Node*, i16 }) %0, %std.Progress* nonnull align 8 %1, %"[]u8"* nonnull readonly align 8 %2, i64 %3) unnamed_addr #1 {
Entry:
  %stderr = alloca %std.fs.file.File, align 4
  %4 = alloca { %std.time.Timer, i16 }, align 8
  %5 = alloca { %std.Progress.Node*, i16 }, align 8
  %self = alloca %std.Progress*, align 8
  %estimated_total_items = alloca i64, align 8
  store %std.Progress* %1, %std.Progress** %self, align 8
  store i64 %3, i64* %estimated_total_items, align 8
  call fastcc void @std.io.getStdErr(%std.fs.file.File* sret(%std.fs.file.File) %stderr)
  %6 = load %std.Progress*, %std.Progress** %self, align 8
  %7 = getelementptr inbounds %std.Progress, %std.Progress* %6, i32 0, i32 0
  %8 = bitcast %"?std.fs.file.File"* %7 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %8, i8* align 4 bitcast (%"?std.fs.file.File"* @110 to i8*), i64 8, i1 false)
  %9 = call fastcc i1 @std.fs.file.File.supportsAnsiEscapeCodes(%std.fs.file.File* %stderr)
  br i1 %9, label %Then, label %Else

Then:                                             ; preds = %Entry
  %10 = load %std.Progress*, %std.Progress** %self, align 8
  %11 = getelementptr inbounds %std.Progress, %std.Progress* %10, i32 0, i32 0
  %12 = getelementptr inbounds %"?std.fs.file.File", %"?std.fs.file.File"* %11, i32 0, i32 1
  store i1 true, i1* %12, align 1
  %13 = getelementptr inbounds %"?std.fs.file.File", %"?std.fs.file.File"* %11, i32 0, i32 0
  %14 = bitcast %std.fs.file.File* %stderr to i8*
  %15 = bitcast %std.fs.file.File* %13 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %15, i8* align 4 %14, i64 4, i1 false)
  %16 = load %std.Progress*, %std.Progress** %self, align 8
  %17 = getelementptr inbounds %std.Progress, %std.Progress* %16, i32 0, i32 2
  store i1 true, i1* %17, align 1
  br label %EndIf

Else:                                             ; preds = %Entry
  %18 = load %std.Progress*, %std.Progress** %self, align 8
  %19 = getelementptr inbounds %std.Progress, %std.Progress* %18, i32 0, i32 0
  %20 = getelementptr inbounds %"?std.fs.file.File", %"?std.fs.file.File"* %19, i32 0, i32 1
  store i1 true, i1* %20, align 1
  %21 = getelementptr inbounds %"?std.fs.file.File", %"?std.fs.file.File"* %19, i32 0, i32 0
  %22 = bitcast %std.fs.file.File* %stderr to i8*
  %23 = bitcast %std.fs.file.File* %21 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %23, i8* align 4 %22, i64 4, i1 false)
  br label %EndIf

EndIf:                                            ; preds = %Else, %Then
  %24 = load %std.Progress*, %std.Progress** %self, align 8
  %25 = getelementptr inbounds %std.Progress, %std.Progress* %24, i32 0, i32 4
  %26 = getelementptr inbounds %std.Progress.Node, %std.Progress.Node* %25, i32 0, i32 0
  %27 = load %std.Progress*, %std.Progress** %self, align 8
  store %std.Progress* %27, %std.Progress** %26, align 8
  %28 = getelementptr inbounds %std.Progress.Node, %std.Progress.Node* %25, i32 0, i32 1
  store %std.Progress.Node* null, %std.Progress.Node** %28, align 8
  %29 = getelementptr inbounds %std.Progress.Node, %std.Progress.Node* %25, i32 0, i32 2
  %30 = bitcast %"[]u8"* %2 to i8*
  %31 = bitcast %"[]u8"* %29 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %31, i8* align 8 %30, i64 16, i1 false)
  %32 = getelementptr inbounds %std.Progress.Node, %std.Progress.Node* %25, i32 0, i32 4
  %33 = load i64, i64* %estimated_total_items, align 8
  store i64 %33, i64* %32, align 8
  %34 = getelementptr inbounds %std.Progress.Node, %std.Progress.Node* %25, i32 0, i32 5
  store i64 0, i64* %34, align 8
  %35 = getelementptr inbounds %std.Progress.Node, %std.Progress.Node* %25, i32 0, i32 3
  store %std.Progress.Node* null, %std.Progress.Node** %35, align 8
  %36 = load %std.Progress*, %std.Progress** %self, align 8
  %37 = getelementptr inbounds %std.Progress, %std.Progress* %36, i32 0, i32 12
  store i64 0, i64* %37, align 8
  %38 = load %std.Progress*, %std.Progress** %self, align 8
  %39 = getelementptr inbounds %std.Progress, %std.Progress* %38, i32 0, i32 6
  store i64 0, i64* %39, align 8
  %40 = load %std.Progress*, %std.Progress** %self, align 8
  %41 = getelementptr inbounds %std.Progress, %std.Progress* %40, i32 0, i32 5
  call fastcc void @std.time.Timer.start({ %std.time.Timer, i16 }* sret({ %std.time.Timer, i16 }) %4)
  %42 = getelementptr inbounds { %std.time.Timer, i16 }, { %std.time.Timer, i16 }* %4, i32 0, i32 1
  %43 = load i16, i16* %42, align 2
  %44 = icmp ne i16 %43, 0
  br i1 %44, label %ErrRetReturn, label %ErrRetContinue

ErrRetReturn:                                     ; preds = %EndIf
  %45 = getelementptr inbounds { %std.time.Timer, i16 }, { %std.time.Timer, i16 }* %4, i32 0, i32 1
  %46 = load i16, i16* %45, align 2
  %47 = getelementptr inbounds { %std.Progress.Node*, i16 }, { %std.Progress.Node*, i16 }* %0, i32 0, i32 1
  store i16 %46, i16* %47, align 2
  %48 = getelementptr inbounds { %std.Progress.Node*, i16 }, { %std.Progress.Node*, i16 }* %5, i32 0, i32 1
  store i16 %46, i16* %48, align 2
  ret void

ErrRetContinue:                                   ; preds = %EndIf
  %49 = getelementptr inbounds { %std.time.Timer, i16 }, { %std.time.Timer, i16 }* %4, i32 0, i32 0
  %50 = bitcast %std.time.Timer* %49 to i8*
  %51 = bitcast %std.time.Timer* %41 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %51, i8* align 8 %50, i64 16, i1 false)
  %52 = load %std.Progress*, %std.Progress** %self, align 8
  %53 = getelementptr inbounds %std.Progress, %std.Progress* %52, i32 0, i32 10
  store i1 false, i1* %53, align 1
  %54 = load %std.Progress*, %std.Progress** %self, align 8
  %55 = getelementptr inbounds %std.Progress, %std.Progress* %54, i32 0, i32 4
  %56 = getelementptr inbounds { %std.Progress.Node*, i16 }, { %std.Progress.Node*, i16 }* %0, i32 0, i32 1
  store i16 0, i16* %56, align 2
  %57 = getelementptr inbounds { %std.Progress.Node*, i16 }, { %std.Progress.Node*, i16 }* %0, i32 0, i32 0
  store %std.Progress.Node* %55, %std.Progress.Node** %57, align 8
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.Progress.Node.start(%std.Progress.Node* nonnull sret(%std.Progress.Node) %0, %std.Progress.Node* nonnull align 8 %1, %"[]u8"* nonnull readonly align 8 %2, i64 %3) unnamed_addr #1 {
Entry:
  %self = alloca %std.Progress.Node*, align 8
  %estimated_total_items = alloca i64, align 8
  store %std.Progress.Node* %1, %std.Progress.Node** %self, align 8
  store i64 %3, i64* %estimated_total_items, align 8
  %4 = getelementptr inbounds %std.Progress.Node, %std.Progress.Node* %0, i32 0, i32 0
  %5 = load %std.Progress.Node*, %std.Progress.Node** %self, align 8
  %6 = getelementptr inbounds %std.Progress.Node, %std.Progress.Node* %5, i32 0, i32 0
  %7 = load %std.Progress*, %std.Progress** %6, align 8
  store %std.Progress* %7, %std.Progress** %4, align 8
  %8 = getelementptr inbounds %std.Progress.Node, %std.Progress.Node* %0, i32 0, i32 1
  %9 = load %std.Progress.Node*, %std.Progress.Node** %self, align 8
  store %std.Progress.Node* %9, %std.Progress.Node** %8, align 8
  %10 = getelementptr inbounds %std.Progress.Node, %std.Progress.Node* %0, i32 0, i32 2
  %11 = bitcast %"[]u8"* %2 to i8*
  %12 = bitcast %"[]u8"* %10 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %12, i8* align 8 %11, i64 16, i1 false)
  %13 = getelementptr inbounds %std.Progress.Node, %std.Progress.Node* %0, i32 0, i32 4
  %14 = load i64, i64* %estimated_total_items, align 8
  store i64 %14, i64* %13, align 8
  %15 = getelementptr inbounds %std.Progress.Node, %std.Progress.Node* %0, i32 0, i32 5
  store i64 0, i64* %15, align 8
  %16 = getelementptr inbounds %std.Progress.Node, %std.Progress.Node* %0, i32 0, i32 3
  store %std.Progress.Node* null, %std.Progress.Node** %16, align 8
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.Progress.Node.activate(%std.Progress.Node* nonnull align 8 %0) unnamed_addr #1 {
Entry:
  %parent = alloca %std.Progress.Node*, align 8
  %self = alloca %std.Progress.Node*, align 8
  store %std.Progress.Node* %0, %std.Progress.Node** %self, align 8
  %1 = load %std.Progress.Node*, %std.Progress.Node** %self, align 8
  %2 = getelementptr inbounds %std.Progress.Node, %std.Progress.Node* %1, i32 0, i32 1
  %3 = load %std.Progress.Node*, %std.Progress.Node** %2, align 8
  %4 = icmp ne %std.Progress.Node* %3, null
  br i1 %4, label %OptionalThen, label %OptionalElse

OptionalThen:                                     ; preds = %Entry
  %5 = load %std.Progress.Node*, %std.Progress.Node** %2, align 8
  store %std.Progress.Node* %5, %std.Progress.Node** %parent, align 8
  %6 = load %std.Progress.Node*, %std.Progress.Node** %parent, align 8
  %7 = getelementptr inbounds %std.Progress.Node, %std.Progress.Node* %6, i32 0, i32 3
  %8 = load %std.Progress.Node*, %std.Progress.Node** %self, align 8
  store atomic %std.Progress.Node* %8, %std.Progress.Node** %7 release, align 8
  br label %OptionalEndIf

OptionalElse:                                     ; preds = %Entry
  br label %OptionalEndIf

OptionalEndIf:                                    ; preds = %OptionalElse, %OptionalThen
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.Progress.refresh(%std.Progress* nonnull align 8 %0) unnamed_addr #1 {
Entry:
  %self = alloca %std.Progress*, align 8
  store %std.Progress* %0, %std.Progress** %self, align 8
  %1 = load %std.Progress*, %std.Progress** %self, align 8
  %2 = getelementptr inbounds %std.Progress, %std.Progress* %1, i32 0, i32 11
  %3 = call fastcc i1 @std.Thread.Mutex.tryLock(%std.Thread.Mutex* %2)
  %4 = icmp eq i1 %3, false
  br i1 %4, label %Then, label %Else

Then:                                             ; preds = %Entry
  ret void

Else:                                             ; preds = %Entry
  br label %EndIf

EndIf:                                            ; preds = %Else
  %5 = load %std.Progress*, %std.Progress** %self, align 8
  call fastcc void @std.Progress.refreshWithHeldLock(%std.Progress* %5)
  %6 = load %std.Progress*, %std.Progress** %self, align 8
  %7 = getelementptr inbounds %std.Progress, %std.Progress* %6, i32 0, i32 11
  call fastcc void @std.Thread.Mutex.unlock(%std.Thread.Mutex* %7)
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.debug.print(%"std.special.struct:62:49"* nonnull readonly align 8 %0) unnamed_addr #1 {
Entry:
  %1 = alloca %std.fs.file.File, align 4
  %stderr = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %2 = alloca %"std.special.struct:62:49", align 8
  %3 = alloca i16, align 2
  call fastcc void @std.Thread.Mutex.lock(%std.Thread.Mutex* @stderr_mutex)
  call fastcc void @std.io.getStdErr(%std.fs.file.File* sret(%std.fs.file.File) %1)
  call fastcc void @std.fs.file.File.writer(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* sret(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)") %stderr, %std.fs.file.File* %1)
  %4 = bitcast %"std.special.struct:62:49"* %0 to i8*
  %5 = bitcast %"std.special.struct:62:49"* %2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %5, i8* align 8 %4, i64 32, i1 false)
  %6 = call fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).print.42"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %stderr, %"std.special.struct:62:49"* %0)
  store i16 %6, i16* %3, align 2
  %7 = icmp ne i16 %6, 0
  br i1 %7, label %UnwrapErrError, label %UnwrapErrOk

UnwrapErrError:                                   ; preds = %Entry
  call fastcc void @std.Thread.Mutex.unlock(%std.Thread.Mutex* @stderr_mutex)
  ret void

UnwrapErrOk:                                      ; preds = %Entry
  br label %UnwrapErrEnd

UnwrapErrEnd:                                     ; preds = %UnwrapErrOk
  call fastcc void @std.Thread.Mutex.unlock(%std.Thread.Mutex* @stderr_mutex)
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.Progress.Node.end(%std.Progress.Node* nonnull align 8 %0) unnamed_addr #1 {
Entry:
  %parent = alloca %std.Progress.Node*, align 8
  %self = alloca %std.Progress.Node*, align 8
  store %std.Progress.Node* %0, %std.Progress.Node** %self, align 8
  %1 = load %std.Progress.Node*, %std.Progress.Node** %self, align 8
  %2 = getelementptr inbounds %std.Progress.Node, %std.Progress.Node* %1, i32 0, i32 0
  %3 = load %std.Progress*, %std.Progress** %2, align 8
  call fastcc void @std.Progress.maybeRefresh(%std.Progress* %3)
  %4 = load %std.Progress.Node*, %std.Progress.Node** %self, align 8
  %5 = getelementptr inbounds %std.Progress.Node, %std.Progress.Node* %4, i32 0, i32 1
  %6 = load %std.Progress.Node*, %std.Progress.Node** %5, align 8
  %7 = icmp ne %std.Progress.Node* %6, null
  br i1 %7, label %OptionalThen, label %OptionalElse

OptionalThen:                                     ; preds = %Entry
  %8 = load %std.Progress.Node*, %std.Progress.Node** %5, align 8
  store %std.Progress.Node* %8, %std.Progress.Node** %parent, align 8
  %9 = load %std.Progress.Node*, %std.Progress.Node** %self, align 8
  %10 = getelementptr inbounds %std.Progress.Node, %std.Progress.Node* %9, i32 0, i32 0
  %11 = load %std.Progress*, %std.Progress** %10, align 8
  %12 = getelementptr inbounds %std.Progress, %std.Progress* %11, i32 0, i32 11
  call fastcc void @std.Thread.Mutex.lock(%std.Thread.Mutex* %12)
  %13 = load %std.Progress.Node*, %std.Progress.Node** %parent, align 8
  %14 = getelementptr inbounds %std.Progress.Node, %std.Progress.Node* %13, i32 0, i32 3
  %15 = load %std.Progress.Node*, %std.Progress.Node** %self, align 8
  %16 = cmpxchg %std.Progress.Node** %14, %std.Progress.Node* %15, %std.Progress.Node* null monotonic monotonic, align 8
  %17 = load %std.Progress.Node*, %std.Progress.Node** %self, align 8
  %18 = getelementptr inbounds %std.Progress.Node, %std.Progress.Node* %17, i32 0, i32 0
  %19 = load %std.Progress*, %std.Progress** %18, align 8
  %20 = getelementptr inbounds %std.Progress, %std.Progress* %19, i32 0, i32 11
  call fastcc void @std.Thread.Mutex.unlock(%std.Thread.Mutex* %20)
  %21 = load %std.Progress.Node*, %std.Progress.Node** %parent, align 8
  call fastcc void @std.Progress.Node.completeOne(%std.Progress.Node* %21)
  br label %OptionalEndIf

OptionalElse:                                     ; preds = %Entry
  %22 = load %std.Progress.Node*, %std.Progress.Node** %self, align 8
  %23 = getelementptr inbounds %std.Progress.Node, %std.Progress.Node* %22, i32 0, i32 0
  %24 = load %std.Progress*, %std.Progress** %23, align 8
  %25 = getelementptr inbounds %std.Progress, %std.Progress* %24, i32 0, i32 11
  call fastcc void @std.Thread.Mutex.lock(%std.Thread.Mutex* %25)
  %26 = load %std.Progress.Node*, %std.Progress.Node** %self, align 8
  %27 = getelementptr inbounds %std.Progress.Node, %std.Progress.Node* %26, i32 0, i32 0
  %28 = load %std.Progress*, %std.Progress** %27, align 8
  %29 = getelementptr inbounds %std.Progress, %std.Progress* %28, i32 0, i32 10
  store i1 true, i1* %29, align 1
  %30 = load %std.Progress.Node*, %std.Progress.Node** %self, align 8
  %31 = getelementptr inbounds %std.Progress.Node, %std.Progress.Node* %30, i32 0, i32 0
  %32 = load %std.Progress*, %std.Progress** %31, align 8
  call fastcc void @std.Progress.refreshWithHeldLock(%std.Progress* %32)
  %33 = load %std.Progress.Node*, %std.Progress.Node** %self, align 8
  %34 = getelementptr inbounds %std.Progress.Node, %std.Progress.Node* %33, i32 0, i32 0
  %35 = load %std.Progress*, %std.Progress** %34, align 8
  %36 = getelementptr inbounds %std.Progress, %std.Progress* %35, i32 0, i32 11
  call fastcc void @std.Thread.Mutex.unlock(%std.Thread.Mutex* %36)
  br label %OptionalEndIf

OptionalEndIf:                                    ; preds = %OptionalElse, %OptionalThen
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.Progress.log(%std.Progress* nonnull align 8 %0, %"std.special.struct:76:61"* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %file = alloca %std.fs.file.File, align 4
  %2 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %3 = alloca %"std.special.struct:76:61", align 8
  %4 = alloca i16, align 2
  %self = alloca %std.Progress*, align 8
  store %std.Progress* %0, %std.Progress** %self, align 8
  %5 = load %std.Progress*, %std.Progress** %self, align 8
  %6 = getelementptr inbounds %std.Progress, %std.Progress* %5, i32 0, i32 0
  %7 = getelementptr inbounds %"?std.fs.file.File", %"?std.fs.file.File"* %6, i32 0, i32 1
  %8 = load i1, i1* %7, align 1
  br i1 %8, label %OptionalNonNull, label %OptionalNull

OptionalNull:                                     ; preds = %Entry
  ret void

OptionalNonNull:                                  ; preds = %Entry
  %9 = getelementptr inbounds %"?std.fs.file.File", %"?std.fs.file.File"* %6, i32 0, i32 0
  %10 = bitcast %std.fs.file.File* %9 to i8*
  %11 = bitcast %std.fs.file.File* %file to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %11, i8* align 4 %10, i64 4, i1 false)
  br label %OptionalEnd

OptionalEnd:                                      ; preds = %OptionalNonNull
  %12 = load %std.Progress*, %std.Progress** %self, align 8
  call fastcc void @std.Progress.refresh(%std.Progress* %12)
  call fastcc void @std.fs.file.File.writer(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* sret(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)") %2, %std.fs.file.File* %file)
  %13 = bitcast %"std.special.struct:76:61"* %1 to i8*
  %14 = bitcast %"std.special.struct:76:61"* %3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %14, i8* align 8 %13, i64 16, i1 false)
  %15 = call fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).print.43"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2, %"std.special.struct:76:61"* %1)
  store i16 %15, i16* %4, align 2
  %16 = icmp ne i16 %15, 0
  br i1 %16, label %UnwrapErrError, label %UnwrapErrOk

UnwrapErrError:                                   ; preds = %OptionalEnd
  %17 = load %std.Progress*, %std.Progress** %self, align 8
  %18 = getelementptr inbounds %std.Progress, %std.Progress* %17, i32 0, i32 0
  %19 = bitcast %"?std.fs.file.File"* %18 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %19, i8* align 4 bitcast (%"?std.fs.file.File"* @115 to i8*), i64 8, i1 false)
  ret void

UnwrapErrOk:                                      ; preds = %OptionalEnd
  br label %UnwrapErrEnd

UnwrapErrEnd:                                     ; preds = %UnwrapErrOk
  %20 = load %std.Progress*, %std.Progress** %self, align 8
  %21 = getelementptr inbounds %std.Progress, %std.Progress* %20, i32 0, i32 12
  store i64 0, i64* %21, align 8
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.debug.print.31() unnamed_addr #1 {
Entry:
  %0 = alloca %std.fs.file.File, align 4
  %stderr = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %1 = alloca i16, align 2
  call fastcc void @std.Thread.Mutex.lock(%std.Thread.Mutex* @stderr_mutex)
  call fastcc void @std.io.getStdErr(%std.fs.file.File* sret(%std.fs.file.File) %0)
  call fastcc void @std.fs.file.File.writer(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* sret(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)") %stderr, %std.fs.file.File* %0)
  %2 = call fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).print.44"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %stderr)
  store i16 %2, i16* %1, align 2
  %3 = icmp ne i16 %2, 0
  br i1 %3, label %UnwrapErrError, label %UnwrapErrOk

UnwrapErrError:                                   ; preds = %Entry
  call fastcc void @std.Thread.Mutex.unlock(%std.Thread.Mutex* @stderr_mutex)
  ret void

UnwrapErrOk:                                      ; preds = %Entry
  br label %UnwrapErrEnd

UnwrapErrEnd:                                     ; preds = %UnwrapErrOk
  call fastcc void @std.Thread.Mutex.unlock(%std.Thread.Mutex* @stderr_mutex)
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i1 @"std.heap.general_purpose_allocator.GeneralPurposeAllocator((struct std.heap.general_purpose_allocator.Config constant)).deinit"(%"std.heap.general_purpose_allocator.GeneralPurposeAllocator((struct std.heap.general_purpose_allocator.Config constant))"* nonnull align 8 %0) unnamed_addr #1 {
Entry:
  %result = alloca i1, align 1
  %self = alloca %"std.heap.general_purpose_allocator.GeneralPurposeAllocator((struct std.heap.general_purpose_allocator.Config constant))"*, align 8
  store %"std.heap.general_purpose_allocator.GeneralPurposeAllocator((struct std.heap.general_purpose_allocator.Config constant))"* %0, %"std.heap.general_purpose_allocator.GeneralPurposeAllocator((struct std.heap.general_purpose_allocator.Config constant))"** %self, align 8
  %1 = load %"std.heap.general_purpose_allocator.GeneralPurposeAllocator((struct std.heap.general_purpose_allocator.Config constant))"*, %"std.heap.general_purpose_allocator.GeneralPurposeAllocator((struct std.heap.general_purpose_allocator.Config constant))"** %self, align 8
  %2 = getelementptr inbounds %"std.heap.general_purpose_allocator.GeneralPurposeAllocator((struct std.heap.general_purpose_allocator.Config constant))", %"std.heap.general_purpose_allocator.GeneralPurposeAllocator((struct std.heap.general_purpose_allocator.Config constant))"* %1, i32 0, i32 2
  %3 = load %"std.heap.general_purpose_allocator.GeneralPurposeAllocator((struct std.heap.general_purpose_allocator.Config constant))"*, %"std.heap.general_purpose_allocator.GeneralPurposeAllocator((struct std.heap.general_purpose_allocator.Config constant))"** %self, align 8
  %4 = getelementptr inbounds %"std.heap.general_purpose_allocator.GeneralPurposeAllocator((struct std.heap.general_purpose_allocator.Config constant))", %"std.heap.general_purpose_allocator.GeneralPurposeAllocator((struct std.heap.general_purpose_allocator.Config constant))"* %3, i32 0, i32 0
  call fastcc void @"std.hash_map.HashMapUnmanaged(usize,std.heap.general_purpose_allocator.LargeAlloc,std.hash_map.AutoContext(usize),80).deinit"(%"std.hash_map.HashMapUnmanaged(usize,std.heap.general_purpose_allocator.LargeAlloc,std.hash_map.AutoContext(usize),80)"* %2, %std.mem.Allocator* %4)
  %5 = load %"std.heap.general_purpose_allocator.GeneralPurposeAllocator((struct std.heap.general_purpose_allocator.Config constant))"*, %"std.heap.general_purpose_allocator.GeneralPurposeAllocator((struct std.heap.general_purpose_allocator.Config constant))"** %self, align 8
  store i1 false, i1* %result, align 1
  %6 = load i1, i1* %result, align 1
  ret i1 %6
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.debug.print.32() unnamed_addr #1 {
Entry:
  %0 = alloca %std.fs.file.File, align 4
  %stderr = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %1 = alloca i16, align 2
  call fastcc void @std.Thread.Mutex.lock(%std.Thread.Mutex* @stderr_mutex)
  call fastcc void @std.io.getStdErr(%std.fs.file.File* sret(%std.fs.file.File) %0)
  call fastcc void @std.fs.file.File.writer(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* sret(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)") %stderr, %std.fs.file.File* %0)
  %2 = call fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).print.45"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %stderr)
  store i16 %2, i16* %1, align 2
  %3 = icmp ne i16 %2, 0
  br i1 %3, label %UnwrapErrError, label %UnwrapErrOk

UnwrapErrError:                                   ; preds = %Entry
  call fastcc void @std.Thread.Mutex.unlock(%std.Thread.Mutex* @stderr_mutex)
  ret void

UnwrapErrOk:                                      ; preds = %Entry
  br label %UnwrapErrEnd

UnwrapErrEnd:                                     ; preds = %UnwrapErrOk
  call fastcc void @std.Thread.Mutex.unlock(%std.Thread.Mutex* @stderr_mutex)
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.Progress.log.33(%std.Progress* nonnull align 8 %0, %"std.special.struct:95:54"* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %file = alloca %std.fs.file.File, align 4
  %2 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %3 = alloca %"std.special.struct:95:54", align 8
  %4 = alloca i16, align 2
  %self = alloca %std.Progress*, align 8
  store %std.Progress* %0, %std.Progress** %self, align 8
  %5 = load %std.Progress*, %std.Progress** %self, align 8
  %6 = getelementptr inbounds %std.Progress, %std.Progress* %5, i32 0, i32 0
  %7 = getelementptr inbounds %"?std.fs.file.File", %"?std.fs.file.File"* %6, i32 0, i32 1
  %8 = load i1, i1* %7, align 1
  br i1 %8, label %OptionalNonNull, label %OptionalNull

OptionalNull:                                     ; preds = %Entry
  ret void

OptionalNonNull:                                  ; preds = %Entry
  %9 = getelementptr inbounds %"?std.fs.file.File", %"?std.fs.file.File"* %6, i32 0, i32 0
  %10 = bitcast %std.fs.file.File* %9 to i8*
  %11 = bitcast %std.fs.file.File* %file to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %11, i8* align 4 %10, i64 4, i1 false)
  br label %OptionalEnd

OptionalEnd:                                      ; preds = %OptionalNonNull
  %12 = load %std.Progress*, %std.Progress** %self, align 8
  call fastcc void @std.Progress.refresh(%std.Progress* %12)
  call fastcc void @std.fs.file.File.writer(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* sret(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)") %2, %std.fs.file.File* %file)
  %13 = bitcast %"std.special.struct:95:54"* %1 to i8*
  %14 = bitcast %"std.special.struct:95:54"* %3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %14, i8* align 8 %13, i64 32, i1 false)
  %15 = call fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).print.46"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2, %"std.special.struct:95:54"* %1)
  store i16 %15, i16* %4, align 2
  %16 = icmp ne i16 %15, 0
  br i1 %16, label %UnwrapErrError, label %UnwrapErrOk

UnwrapErrError:                                   ; preds = %OptionalEnd
  %17 = load %std.Progress*, %std.Progress** %self, align 8
  %18 = getelementptr inbounds %std.Progress, %std.Progress* %17, i32 0, i32 0
  %19 = bitcast %"?std.fs.file.File"* %18 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %19, i8* align 4 bitcast (%"?std.fs.file.File"* @117 to i8*), i64 8, i1 false)
  ret void

UnwrapErrOk:                                      ; preds = %OptionalEnd
  br label %UnwrapErrEnd

UnwrapErrEnd:                                     ; preds = %UnwrapErrOk
  %20 = load %std.Progress*, %std.Progress** %self, align 8
  %21 = getelementptr inbounds %std.Progress, %std.Progress* %20, i32 0, i32 12
  store i64 0, i64* %21, align 8
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.debug.print.34(%"std.special.struct:96:65"* nonnull readonly align 8 %0) unnamed_addr #1 {
Entry:
  %1 = alloca %std.fs.file.File, align 4
  %stderr = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %2 = alloca %"std.special.struct:96:65", align 8
  %3 = alloca i16, align 2
  call fastcc void @std.Thread.Mutex.lock(%std.Thread.Mutex* @stderr_mutex)
  call fastcc void @std.io.getStdErr(%std.fs.file.File* sret(%std.fs.file.File) %1)
  call fastcc void @std.fs.file.File.writer(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* sret(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)") %stderr, %std.fs.file.File* %1)
  %4 = bitcast %"std.special.struct:96:65"* %0 to i8*
  %5 = bitcast %"std.special.struct:96:65"* %2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %5, i8* align 8 %4, i64 16, i1 false)
  %6 = call fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).print.47"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %stderr, %"std.special.struct:96:65"* %0)
  store i16 %6, i16* %3, align 2
  %7 = icmp ne i16 %6, 0
  br i1 %7, label %UnwrapErrError, label %UnwrapErrOk

UnwrapErrError:                                   ; preds = %Entry
  call fastcc void @std.Thread.Mutex.unlock(%std.Thread.Mutex* @stderr_mutex)
  ret void

UnwrapErrOk:                                      ; preds = %Entry
  br label %UnwrapErrEnd

UnwrapErrEnd:                                     ; preds = %UnwrapErrOk
  call fastcc void @std.Thread.Mutex.unlock(%std.Thread.Mutex* @stderr_mutex)
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.Progress.log.35(%std.Progress* nonnull align 8 %0, %"std.special.struct:89:48"* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %file = alloca %std.fs.file.File, align 4
  %2 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %3 = alloca %"std.special.struct:89:48", align 8
  %4 = alloca i16, align 2
  %self = alloca %std.Progress*, align 8
  store %std.Progress* %0, %std.Progress** %self, align 8
  %5 = load %std.Progress*, %std.Progress** %self, align 8
  %6 = getelementptr inbounds %std.Progress, %std.Progress* %5, i32 0, i32 0
  %7 = getelementptr inbounds %"?std.fs.file.File", %"?std.fs.file.File"* %6, i32 0, i32 1
  %8 = load i1, i1* %7, align 1
  br i1 %8, label %OptionalNonNull, label %OptionalNull

OptionalNull:                                     ; preds = %Entry
  ret void

OptionalNonNull:                                  ; preds = %Entry
  %9 = getelementptr inbounds %"?std.fs.file.File", %"?std.fs.file.File"* %6, i32 0, i32 0
  %10 = bitcast %std.fs.file.File* %9 to i8*
  %11 = bitcast %std.fs.file.File* %file to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %11, i8* align 4 %10, i64 4, i1 false)
  br label %OptionalEnd

OptionalEnd:                                      ; preds = %OptionalNonNull
  %12 = load %std.Progress*, %std.Progress** %self, align 8
  call fastcc void @std.Progress.refresh(%std.Progress* %12)
  call fastcc void @std.fs.file.File.writer(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* sret(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)") %2, %std.fs.file.File* %file)
  %13 = bitcast %"std.special.struct:89:48"* %1 to i8*
  %14 = bitcast %"std.special.struct:89:48"* %3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %14, i8* align 8 %13, i64 16, i1 false)
  %15 = call fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).print.48"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2, %"std.special.struct:89:48"* %1)
  store i16 %15, i16* %4, align 2
  %16 = icmp ne i16 %15, 0
  br i1 %16, label %UnwrapErrError, label %UnwrapErrOk

UnwrapErrError:                                   ; preds = %OptionalEnd
  %17 = load %std.Progress*, %std.Progress** %self, align 8
  %18 = getelementptr inbounds %std.Progress, %std.Progress* %17, i32 0, i32 0
  %19 = bitcast %"?std.fs.file.File"* %18 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %19, i8* align 4 bitcast (%"?std.fs.file.File"* @118 to i8*), i64 8, i1 false)
  ret void

UnwrapErrOk:                                      ; preds = %OptionalEnd
  br label %UnwrapErrEnd

UnwrapErrEnd:                                     ; preds = %UnwrapErrOk
  %20 = load %std.Progress*, %std.Progress** %self, align 8
  %21 = getelementptr inbounds %std.Progress, %std.Progress* %20, i32 0, i32 12
  store i64 0, i64* %21, align 8
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.debug.print.36() unnamed_addr #1 {
Entry:
  %0 = alloca %std.fs.file.File, align 4
  %stderr = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %1 = alloca i16, align 2
  call fastcc void @std.Thread.Mutex.lock(%std.Thread.Mutex* @stderr_mutex)
  call fastcc void @std.io.getStdErr(%std.fs.file.File* sret(%std.fs.file.File) %0)
  call fastcc void @std.fs.file.File.writer(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* sret(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)") %stderr, %std.fs.file.File* %0)
  %2 = call fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).print.49"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %stderr)
  store i16 %2, i16* %1, align 2
  %3 = icmp ne i16 %2, 0
  br i1 %3, label %UnwrapErrError, label %UnwrapErrOk

UnwrapErrError:                                   ; preds = %Entry
  call fastcc void @std.Thread.Mutex.unlock(%std.Thread.Mutex* @stderr_mutex)
  ret void

UnwrapErrOk:                                      ; preds = %Entry
  br label %UnwrapErrEnd

UnwrapErrEnd:                                     ; preds = %UnwrapErrOk
  call fastcc void @std.Thread.Mutex.unlock(%std.Thread.Mutex* @stderr_mutex)
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.debug.print.37(%"std.special.struct:105:53"* nonnull readonly align 8 %0) unnamed_addr #1 {
Entry:
  %1 = alloca %std.fs.file.File, align 4
  %stderr = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %2 = alloca %"std.special.struct:105:53", align 8
  %3 = alloca i16, align 2
  call fastcc void @std.Thread.Mutex.lock(%std.Thread.Mutex* @stderr_mutex)
  call fastcc void @std.io.getStdErr(%std.fs.file.File* sret(%std.fs.file.File) %1)
  call fastcc void @std.fs.file.File.writer(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* sret(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)") %stderr, %std.fs.file.File* %1)
  %4 = bitcast %"std.special.struct:105:53"* %0 to i8*
  %5 = bitcast %"std.special.struct:105:53"* %2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %5, i8* align 8 %4, i64 8, i1 false)
  %6 = call fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).print.50"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %stderr, %"std.special.struct:105:53"* %0)
  store i16 %6, i16* %3, align 2
  %7 = icmp ne i16 %6, 0
  br i1 %7, label %UnwrapErrError, label %UnwrapErrOk

UnwrapErrError:                                   ; preds = %Entry
  call fastcc void @std.Thread.Mutex.unlock(%std.Thread.Mutex* @stderr_mutex)
  ret void

UnwrapErrOk:                                      ; preds = %Entry
  br label %UnwrapErrEnd

UnwrapErrEnd:                                     ; preds = %UnwrapErrOk
  call fastcc void @std.Thread.Mutex.unlock(%std.Thread.Mutex* @stderr_mutex)
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.debug.print.38(%"std.special.struct:107:68"* nonnull readonly align 8 %0) unnamed_addr #1 {
Entry:
  %1 = alloca %std.fs.file.File, align 4
  %stderr = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %2 = alloca %"std.special.struct:107:68", align 8
  %3 = alloca i16, align 2
  call fastcc void @std.Thread.Mutex.lock(%std.Thread.Mutex* @stderr_mutex)
  call fastcc void @std.io.getStdErr(%std.fs.file.File* sret(%std.fs.file.File) %1)
  call fastcc void @std.fs.file.File.writer(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* sret(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)") %stderr, %std.fs.file.File* %1)
  %4 = bitcast %"std.special.struct:107:68"* %0 to i8*
  %5 = bitcast %"std.special.struct:107:68"* %2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %5, i8* align 8 %4, i64 24, i1 false)
  %6 = call fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).print.51"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %stderr, %"std.special.struct:107:68"* %0)
  store i16 %6, i16* %3, align 2
  %7 = icmp ne i16 %6, 0
  br i1 %7, label %UnwrapErrError, label %UnwrapErrOk

UnwrapErrError:                                   ; preds = %Entry
  call fastcc void @std.Thread.Mutex.unlock(%std.Thread.Mutex* @stderr_mutex)
  ret void

UnwrapErrOk:                                      ; preds = %Entry
  br label %UnwrapErrEnd

UnwrapErrEnd:                                     ; preds = %UnwrapErrOk
  call fastcc void @std.Thread.Mutex.unlock(%std.Thread.Mutex* @stderr_mutex)
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.debug.print.39(%"std.special.struct:110:55"* nonnull readonly align 8 %0) unnamed_addr #1 {
Entry:
  %1 = alloca %std.fs.file.File, align 4
  %stderr = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %2 = alloca %"std.special.struct:110:55", align 8
  %3 = alloca i16, align 2
  call fastcc void @std.Thread.Mutex.lock(%std.Thread.Mutex* @stderr_mutex)
  call fastcc void @std.io.getStdErr(%std.fs.file.File* sret(%std.fs.file.File) %1)
  call fastcc void @std.fs.file.File.writer(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* sret(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)") %stderr, %std.fs.file.File* %1)
  %4 = bitcast %"std.special.struct:110:55"* %0 to i8*
  %5 = bitcast %"std.special.struct:110:55"* %2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %5, i8* align 8 %4, i64 8, i1 false)
  %6 = call fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).print.52"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %stderr, %"std.special.struct:110:55"* %0)
  store i16 %6, i16* %3, align 2
  %7 = icmp ne i16 %6, 0
  br i1 %7, label %UnwrapErrError, label %UnwrapErrOk

UnwrapErrError:                                   ; preds = %Entry
  call fastcc void @std.Thread.Mutex.unlock(%std.Thread.Mutex* @stderr_mutex)
  ret void

UnwrapErrOk:                                      ; preds = %Entry
  br label %UnwrapErrEnd

UnwrapErrEnd:                                     ; preds = %UnwrapErrOk
  call fastcc void @std.Thread.Mutex.unlock(%std.Thread.Mutex* @stderr_mutex)
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.debug.print.40(%"std.special.struct:113:56"* nonnull readonly align 8 %0) unnamed_addr #1 {
Entry:
  %1 = alloca %std.fs.file.File, align 4
  %stderr = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %2 = alloca %"std.special.struct:113:56", align 8
  %3 = alloca i16, align 2
  call fastcc void @std.Thread.Mutex.lock(%std.Thread.Mutex* @stderr_mutex)
  call fastcc void @std.io.getStdErr(%std.fs.file.File* sret(%std.fs.file.File) %1)
  call fastcc void @std.fs.file.File.writer(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* sret(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)") %stderr, %std.fs.file.File* %1)
  %4 = bitcast %"std.special.struct:113:56"* %0 to i8*
  %5 = bitcast %"std.special.struct:113:56"* %2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %5, i8* align 8 %4, i64 8, i1 false)
  %6 = call fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).print.53"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %stderr, %"std.special.struct:113:56"* %0)
  store i16 %6, i16* %3, align 2
  %7 = icmp ne i16 %6, 0
  br i1 %7, label %UnwrapErrError, label %UnwrapErrOk

UnwrapErrError:                                   ; preds = %Entry
  call fastcc void @std.Thread.Mutex.unlock(%std.Thread.Mutex* @stderr_mutex)
  ret void

UnwrapErrOk:                                      ; preds = %Entry
  br label %UnwrapErrEnd

UnwrapErrEnd:                                     ; preds = %UnwrapErrOk
  call fastcc void @std.Thread.Mutex.unlock(%std.Thread.Mutex* @stderr_mutex)
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.heap.FixedBufferAllocator.allocator(%std.mem.Allocator* nonnull sret(%std.mem.Allocator) %0, %std.heap.FixedBufferAllocator* nonnull align 8 %1) unnamed_addr #1 {
Entry:
  %2 = alloca %std.heap.FixedBufferAllocator*, align 8
  %self = alloca %std.heap.FixedBufferAllocator*, align 8
  store %std.heap.FixedBufferAllocator* %1, %std.heap.FixedBufferAllocator** %self, align 8
  %3 = load %std.heap.FixedBufferAllocator*, %std.heap.FixedBufferAllocator** %self, align 8
  store %std.heap.FixedBufferAllocator* %3, %std.heap.FixedBufferAllocator** %2, align 8
  call fastcc void @std.mem.Allocator.init(%std.mem.Allocator* sret(%std.mem.Allocator) %0, %std.heap.FixedBufferAllocator* %3)
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.process.argsAlloc({ %"[][]u8", i16 }* nonnull sret({ %"[][]u8", i16 }) %0, %std.mem.Allocator* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %it = alloca %std.process.ArgIterator, align 8
  %contents = alloca %"std.array_list.ArrayListAligned(u8,null)", align 8
  %slice_list = alloca %"std.array_list.ArrayListAligned(usize,null)", align 8
  %2 = alloca { %"?[:0]u8", i16 }, align 8
  %3 = alloca { %"[][]u8", i16 }, align 8
  %arg = alloca %"[]u8", align 8
  %4 = alloca %"[]u8", align 8
  %5 = alloca i16, align 2
  %6 = alloca %"[]u8", align 8
  %7 = alloca { %"[][]u8", i16 }, align 8
  %8 = alloca i16, align 2
  %9 = alloca %"[]u8", align 8
  %10 = alloca { %"[][]u8", i16 }, align 8
  %11 = alloca %"[]u8", align 8
  %contents_slice = alloca %"[]u8", align 8
  %slice_sizes = alloca %"[]usize", align 8
  %12 = alloca i64, align 8
  %13 = alloca i64, align 8
  %14 = alloca { i64, i16 }, align 8
  %15 = alloca { %"[][]u8", i16 }, align 8
  %contents_size_bytes = alloca i64, align 8
  %16 = alloca i64, align 8
  %17 = alloca { i64, i16 }, align 8
  %18 = alloca { %"[][]u8", i16 }, align 8
  %slice_list_bytes = alloca i64, align 8
  %19 = alloca i64, align 8
  %20 = alloca i64, align 8
  %21 = alloca { i64, i16 }, align 8
  %22 = alloca { %"[][]u8", i16 }, align 8
  %total_bytes = alloca i64, align 8
  %23 = alloca i64, align 8
  %24 = alloca { %"[]u8", i16 }, align 8
  %25 = alloca { %"[][]u8", i16 }, align 8
  %buf = alloca %"[]u8", align 8
  %26 = alloca %"[]u8", align 8
  %result_slice_list = alloca %"[][]u8", align 8
  %result_contents = alloca %"[]u8", align 8
  %27 = alloca %"[]u8", align 8
  %28 = alloca %"[]u8", align 8
  %contents_index = alloca i64, align 8
  %i = alloca i64, align 8
  %len = alloca i64, align 8
  %new_index = alloca i64, align 8
  call fastcc void @std.process.args(%std.process.ArgIterator* sret(%std.process.ArgIterator) %it)
  %29 = bitcast %std.process.ArgIterator* %it to i8*
  %30 = bitcast %std.process.ArgIterator* %it to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %30, i8* align 8 %29, i64 16, i1 false)
  call fastcc void @"std.array_list.ArrayListAligned(u8,null).init"(%"std.array_list.ArrayListAligned(u8,null)"* sret(%"std.array_list.ArrayListAligned(u8,null)") %contents, %std.mem.Allocator* %1)
  call fastcc void @"std.array_list.ArrayListAligned(usize,null).init"(%"std.array_list.ArrayListAligned(usize,null)"* sret(%"std.array_list.ArrayListAligned(usize,null)") %slice_list, %std.mem.Allocator* %1)
  br label %WhileCond

WhileCond:                                        ; preds = %ErrRetContinue4, %Entry
  call fastcc void @std.process.ArgIterator.next({ %"?[:0]u8", i16 }* sret({ %"?[:0]u8", i16 }) %2, %std.process.ArgIterator* %it, %std.mem.Allocator* %1)
  %31 = getelementptr inbounds { %"?[:0]u8", i16 }, { %"?[:0]u8", i16 }* %2, i32 0, i32 1
  %32 = load i16, i16* %31, align 2
  %33 = icmp ne i16 %32, 0
  br i1 %33, label %ErrRetReturn, label %ErrRetContinue

ErrRetReturn:                                     ; preds = %WhileCond
  %34 = getelementptr inbounds { %"?[:0]u8", i16 }, { %"?[:0]u8", i16 }* %2, i32 0, i32 1
  %35 = load i16, i16* %34, align 2
  %36 = getelementptr inbounds { %"[][]u8", i16 }, { %"[][]u8", i16 }* %0, i32 0, i32 1
  store i16 %35, i16* %36, align 2
  call fastcc void @"std.array_list.ArrayListAligned(usize,null).deinit"(%"std.array_list.ArrayListAligned(usize,null)"* %slice_list)
  call fastcc void @"std.array_list.ArrayListAligned(u8,null).deinit"(%"std.array_list.ArrayListAligned(u8,null)"* %contents)
  call fastcc void @std.process.ArgIterator.deinit(%std.process.ArgIterator* %it)
  %37 = getelementptr inbounds { %"[][]u8", i16 }, { %"[][]u8", i16 }* %3, i32 0, i32 1
  store i16 %35, i16* %37, align 2
  ret void

ErrRetContinue:                                   ; preds = %WhileCond
  %38 = getelementptr inbounds { %"?[:0]u8", i16 }, { %"?[:0]u8", i16 }* %2, i32 0, i32 0
  %39 = getelementptr inbounds %"?[:0]u8", %"?[:0]u8"* %38, i32 0, i32 1
  %40 = load i1, i1* %39, align 1
  br i1 %40, label %WhileBody, label %WhileEnd

WhileBody:                                        ; preds = %ErrRetContinue
  %41 = getelementptr inbounds %"?[:0]u8", %"?[:0]u8"* %38, i32 0, i32 0
  %42 = bitcast %"[]u8"* %41 to i8*
  %43 = bitcast %"[]u8"* %arg to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %43, i8* align 8 %42, i64 16, i1 false)
  %44 = getelementptr inbounds %"[]u8", %"[]u8"* %arg, i32 0, i32 1
  %45 = load i64, i64* %44, align 8
  %46 = add nuw i64 %45, 1
  %47 = getelementptr inbounds %"[]u8", %"[]u8"* %arg, i32 0, i32 0
  %48 = load i8*, i8** %47, align 8
  %49 = getelementptr inbounds i8, i8* %48, i64 0
  %50 = sub nuw i64 %46, 0
  %51 = getelementptr inbounds %"[]u8", %"[]u8"* %4, i32 0, i32 0
  store i8* %49, i8** %51, align 8
  %52 = getelementptr inbounds %"[]u8", %"[]u8"* %4, i32 0, i32 1
  store i64 %50, i64* %52, align 8
  %53 = call fastcc i16 @"std.array_list.ArrayListAligned(u8,null).appendSlice"(%"std.array_list.ArrayListAligned(u8,null)"* %contents, %"[]u8"* %4)
  store i16 %53, i16* %5, align 2
  %54 = icmp ne i16 %53, 0
  br i1 %54, label %ErrRetReturn1, label %ErrRetContinue2

ErrRetReturn1:                                    ; preds = %WhileBody
  %55 = load i16, i16* %5, align 2
  %56 = getelementptr inbounds { %"[][]u8", i16 }, { %"[][]u8", i16 }* %0, i32 0, i32 1
  store i16 %55, i16* %56, align 2
  %57 = bitcast %"[]u8"* %arg to i8*
  %58 = bitcast %"[]u8"* %6 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %58, i8* align 8 %57, i64 16, i1 false)
  call fastcc void @std.mem.Allocator.free(%std.mem.Allocator* %1, %"[]u8"* %arg)
  call fastcc void @"std.array_list.ArrayListAligned(usize,null).deinit"(%"std.array_list.ArrayListAligned(usize,null)"* %slice_list)
  call fastcc void @"std.array_list.ArrayListAligned(u8,null).deinit"(%"std.array_list.ArrayListAligned(u8,null)"* %contents)
  call fastcc void @std.process.ArgIterator.deinit(%std.process.ArgIterator* %it)
  %59 = getelementptr inbounds { %"[][]u8", i16 }, { %"[][]u8", i16 }* %7, i32 0, i32 1
  store i16 %55, i16* %59, align 2
  ret void

ErrRetContinue2:                                  ; preds = %WhileBody
  %60 = getelementptr inbounds %"[]u8", %"[]u8"* %arg, i32 0, i32 1
  %61 = load i64, i64* %60, align 8
  %62 = call fastcc i16 @"std.array_list.ArrayListAligned(usize,null).append"(%"std.array_list.ArrayListAligned(usize,null)"* %slice_list, i64 %61)
  store i16 %62, i16* %8, align 2
  %63 = icmp ne i16 %62, 0
  br i1 %63, label %ErrRetReturn3, label %ErrRetContinue4

ErrRetReturn3:                                    ; preds = %ErrRetContinue2
  %64 = load i16, i16* %8, align 2
  %65 = getelementptr inbounds { %"[][]u8", i16 }, { %"[][]u8", i16 }* %0, i32 0, i32 1
  store i16 %64, i16* %65, align 2
  %66 = bitcast %"[]u8"* %arg to i8*
  %67 = bitcast %"[]u8"* %9 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %67, i8* align 8 %66, i64 16, i1 false)
  call fastcc void @std.mem.Allocator.free(%std.mem.Allocator* %1, %"[]u8"* %arg)
  call fastcc void @"std.array_list.ArrayListAligned(usize,null).deinit"(%"std.array_list.ArrayListAligned(usize,null)"* %slice_list)
  call fastcc void @"std.array_list.ArrayListAligned(u8,null).deinit"(%"std.array_list.ArrayListAligned(u8,null)"* %contents)
  call fastcc void @std.process.ArgIterator.deinit(%std.process.ArgIterator* %it)
  %68 = getelementptr inbounds { %"[][]u8", i16 }, { %"[][]u8", i16 }* %10, i32 0, i32 1
  store i16 %64, i16* %68, align 2
  ret void

ErrRetContinue4:                                  ; preds = %ErrRetContinue2
  %69 = bitcast %"[]u8"* %arg to i8*
  %70 = bitcast %"[]u8"* %11 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %70, i8* align 8 %69, i64 16, i1 false)
  call fastcc void @std.mem.Allocator.free(%std.mem.Allocator* %1, %"[]u8"* %arg)
  br label %WhileCond

WhileEnd:                                         ; preds = %ErrRetContinue
  %71 = getelementptr inbounds %"std.array_list.ArrayListAligned(u8,null)", %"std.array_list.ArrayListAligned(u8,null)"* %contents, i32 0, i32 0
  %72 = bitcast %"[]u8"* %71 to i8*
  %73 = bitcast %"[]u8"* %contents_slice to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %73, i8* align 8 %72, i64 16, i1 false)
  %74 = getelementptr inbounds %"std.array_list.ArrayListAligned(usize,null)", %"std.array_list.ArrayListAligned(usize,null)"* %slice_list, i32 0, i32 0
  %75 = bitcast %"[]usize"* %74 to i8*
  %76 = bitcast %"[]usize"* %slice_sizes to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %76, i8* align 8 %75, i64 16, i1 false)
  %77 = getelementptr inbounds %"[]u8", %"[]u8"* %contents_slice, i32 0, i32 1
  %78 = load i64, i64* %77, align 8
  store i64 %78, i64* %12, align 8
  %79 = getelementptr inbounds %"[]usize", %"[]usize"* %slice_sizes, i32 0, i32 1
  %80 = load i64, i64* %79, align 8
  store i64 %80, i64* %13, align 8
  call fastcc void @std.math.add({ i64, i16 }* sret({ i64, i16 }) %14, i64 %78, i64 %80)
  %81 = getelementptr inbounds { i64, i16 }, { i64, i16 }* %14, i32 0, i32 1
  %82 = load i16, i16* %81, align 2
  %83 = icmp ne i16 %82, 0
  br i1 %83, label %ErrRetReturn5, label %ErrRetContinue6

ErrRetReturn5:                                    ; preds = %WhileEnd
  %84 = getelementptr inbounds { i64, i16 }, { i64, i16 }* %14, i32 0, i32 1
  %85 = load i16, i16* %84, align 2
  %86 = getelementptr inbounds { %"[][]u8", i16 }, { %"[][]u8", i16 }* %0, i32 0, i32 1
  store i16 %85, i16* %86, align 2
  call fastcc void @"std.array_list.ArrayListAligned(usize,null).deinit"(%"std.array_list.ArrayListAligned(usize,null)"* %slice_list)
  call fastcc void @"std.array_list.ArrayListAligned(u8,null).deinit"(%"std.array_list.ArrayListAligned(u8,null)"* %contents)
  call fastcc void @std.process.ArgIterator.deinit(%std.process.ArgIterator* %it)
  %87 = getelementptr inbounds { %"[][]u8", i16 }, { %"[][]u8", i16 }* %15, i32 0, i32 1
  store i16 %85, i16* %87, align 2
  ret void

ErrRetContinue6:                                  ; preds = %WhileEnd
  %88 = getelementptr inbounds { i64, i16 }, { i64, i16 }* %14, i32 0, i32 0
  %89 = load i64, i64* %88, align 8
  store i64 %89, i64* %contents_size_bytes, align 8
  %90 = getelementptr inbounds %"[]usize", %"[]usize"* %slice_sizes, i32 0, i32 1
  %91 = load i64, i64* %90, align 8
  store i64 %91, i64* %16, align 8
  call fastcc void @std.math.mul({ i64, i16 }* sret({ i64, i16 }) %17, i64 16, i64 %91)
  %92 = getelementptr inbounds { i64, i16 }, { i64, i16 }* %17, i32 0, i32 1
  %93 = load i16, i16* %92, align 2
  %94 = icmp ne i16 %93, 0
  br i1 %94, label %ErrRetReturn7, label %ErrRetContinue8

ErrRetReturn7:                                    ; preds = %ErrRetContinue6
  %95 = getelementptr inbounds { i64, i16 }, { i64, i16 }* %17, i32 0, i32 1
  %96 = load i16, i16* %95, align 2
  %97 = getelementptr inbounds { %"[][]u8", i16 }, { %"[][]u8", i16 }* %0, i32 0, i32 1
  store i16 %96, i16* %97, align 2
  call fastcc void @"std.array_list.ArrayListAligned(usize,null).deinit"(%"std.array_list.ArrayListAligned(usize,null)"* %slice_list)
  call fastcc void @"std.array_list.ArrayListAligned(u8,null).deinit"(%"std.array_list.ArrayListAligned(u8,null)"* %contents)
  call fastcc void @std.process.ArgIterator.deinit(%std.process.ArgIterator* %it)
  %98 = getelementptr inbounds { %"[][]u8", i16 }, { %"[][]u8", i16 }* %18, i32 0, i32 1
  store i16 %96, i16* %98, align 2
  ret void

ErrRetContinue8:                                  ; preds = %ErrRetContinue6
  %99 = getelementptr inbounds { i64, i16 }, { i64, i16 }* %17, i32 0, i32 0
  %100 = load i64, i64* %99, align 8
  store i64 %100, i64* %slice_list_bytes, align 8
  %101 = load i64, i64* %slice_list_bytes, align 8
  store i64 %101, i64* %19, align 8
  %102 = load i64, i64* %contents_size_bytes, align 8
  store i64 %102, i64* %20, align 8
  call fastcc void @std.math.add({ i64, i16 }* sret({ i64, i16 }) %21, i64 %101, i64 %102)
  %103 = getelementptr inbounds { i64, i16 }, { i64, i16 }* %21, i32 0, i32 1
  %104 = load i16, i16* %103, align 2
  %105 = icmp ne i16 %104, 0
  br i1 %105, label %ErrRetReturn9, label %ErrRetContinue10

ErrRetReturn9:                                    ; preds = %ErrRetContinue8
  %106 = getelementptr inbounds { i64, i16 }, { i64, i16 }* %21, i32 0, i32 1
  %107 = load i16, i16* %106, align 2
  %108 = getelementptr inbounds { %"[][]u8", i16 }, { %"[][]u8", i16 }* %0, i32 0, i32 1
  store i16 %107, i16* %108, align 2
  call fastcc void @"std.array_list.ArrayListAligned(usize,null).deinit"(%"std.array_list.ArrayListAligned(usize,null)"* %slice_list)
  call fastcc void @"std.array_list.ArrayListAligned(u8,null).deinit"(%"std.array_list.ArrayListAligned(u8,null)"* %contents)
  call fastcc void @std.process.ArgIterator.deinit(%std.process.ArgIterator* %it)
  %109 = getelementptr inbounds { %"[][]u8", i16 }, { %"[][]u8", i16 }* %22, i32 0, i32 1
  store i16 %107, i16* %109, align 2
  ret void

ErrRetContinue10:                                 ; preds = %ErrRetContinue8
  %110 = getelementptr inbounds { i64, i16 }, { i64, i16 }* %21, i32 0, i32 0
  %111 = load i64, i64* %110, align 8
  store i64 %111, i64* %total_bytes, align 8
  %112 = load i64, i64* %total_bytes, align 8
  store i64 %112, i64* %23, align 8
  call fastcc void @std.mem.Allocator.alignedAlloc({ %"[]u8", i16 }* sret({ %"[]u8", i16 }) %24, %std.mem.Allocator* %1, i64 %112)
  %113 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %24, i32 0, i32 1
  %114 = load i16, i16* %113, align 2
  %115 = icmp ne i16 %114, 0
  br i1 %115, label %ErrRetReturn11, label %ErrRetContinue12

ErrRetReturn11:                                   ; preds = %ErrRetContinue10
  %116 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %24, i32 0, i32 1
  %117 = load i16, i16* %116, align 2
  %118 = getelementptr inbounds { %"[][]u8", i16 }, { %"[][]u8", i16 }* %0, i32 0, i32 1
  store i16 %117, i16* %118, align 2
  call fastcc void @"std.array_list.ArrayListAligned(usize,null).deinit"(%"std.array_list.ArrayListAligned(usize,null)"* %slice_list)
  call fastcc void @"std.array_list.ArrayListAligned(u8,null).deinit"(%"std.array_list.ArrayListAligned(u8,null)"* %contents)
  call fastcc void @std.process.ArgIterator.deinit(%std.process.ArgIterator* %it)
  %119 = getelementptr inbounds { %"[][]u8", i16 }, { %"[][]u8", i16 }* %25, i32 0, i32 1
  store i16 %117, i16* %119, align 2
  ret void

ErrRetContinue12:                                 ; preds = %ErrRetContinue10
  %120 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %24, i32 0, i32 0
  %121 = bitcast %"[]u8"* %120 to i8*
  %122 = bitcast %"[]u8"* %buf to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %122, i8* align 8 %121, i64 16, i1 false)
  %123 = load i64, i64* %slice_list_bytes, align 8
  %124 = getelementptr inbounds %"[]u8", %"[]u8"* %buf, i32 0, i32 0
  %125 = load i8*, i8** %124, align 8
  %126 = getelementptr inbounds i8, i8* %125, i64 0
  %127 = sub nuw i64 %123, 0
  %128 = getelementptr inbounds %"[]u8", %"[]u8"* %26, i32 0, i32 0
  store i8* %126, i8** %128, align 8
  %129 = getelementptr inbounds %"[]u8", %"[]u8"* %26, i32 0, i32 1
  store i64 %127, i64* %129, align 8
  call fastcc void @std.mem.bytesAsSlice(%"[][]u8"* sret(%"[][]u8") %result_slice_list, %"[]u8"* %26)
  %130 = load i64, i64* %slice_list_bytes, align 8
  %131 = getelementptr inbounds %"[]u8", %"[]u8"* %buf, i32 0, i32 1
  %132 = load i64, i64* %131, align 8
  %133 = getelementptr inbounds %"[]u8", %"[]u8"* %buf, i32 0, i32 0
  %134 = load i8*, i8** %133, align 8
  %135 = getelementptr inbounds i8, i8* %134, i64 %130
  %136 = sub nuw i64 %132, %130
  %137 = getelementptr inbounds %"[]u8", %"[]u8"* %result_contents, i32 0, i32 0
  store i8* %135, i8** %137, align 8
  %138 = getelementptr inbounds %"[]u8", %"[]u8"* %result_contents, i32 0, i32 1
  store i64 %136, i64* %138, align 8
  %139 = bitcast %"[]u8"* %result_contents to i8*
  %140 = bitcast %"[]u8"* %27 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %140, i8* align 8 %139, i64 16, i1 false)
  %141 = bitcast %"[]u8"* %contents_slice to i8*
  %142 = bitcast %"[]u8"* %28 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %142, i8* align 8 %141, i64 16, i1 false)
  call fastcc void @std.mem.copy(%"[]u8"* %result_contents, %"[]u8"* %contents_slice)
  store i64 0, i64* %contents_index, align 8
  store i64 0, i64* %i, align 8
  %143 = getelementptr inbounds %"[]usize", %"[]usize"* %slice_sizes, i32 0, i32 1
  %144 = load i64, i64* %143, align 8
  br label %ForCond

ForCond:                                          ; preds = %SentinelOk, %ErrRetContinue12
  %145 = load i64, i64* %i, align 8
  %146 = icmp ult i64 %145, %144
  br i1 %146, label %ForBody, label %ForEnd

ForBody:                                          ; preds = %ForCond
  %147 = getelementptr inbounds %"[]usize", %"[]usize"* %slice_sizes, i32 0, i32 0
  %148 = load i64*, i64** %147, align 8
  %149 = getelementptr inbounds i64, i64* %148, i64 %145
  %150 = load i64, i64* %149, align 8
  store i64 %150, i64* %len, align 8
  %151 = load i64, i64* %contents_index, align 8
  %152 = load i64, i64* %len, align 8
  %153 = add nuw i64 %151, %152
  store i64 %153, i64* %new_index, align 8
  %154 = load i64, i64* %i, align 8
  %155 = getelementptr inbounds %"[][]u8", %"[][]u8"* %result_slice_list, i32 0, i32 0
  %156 = load %"[]u8"*, %"[]u8"** %155, align 8
  %157 = getelementptr inbounds %"[]u8", %"[]u8"* %156, i64 %154
  %158 = load i64, i64* %contents_index, align 8
  %159 = load i64, i64* %new_index, align 8
  %160 = getelementptr inbounds %"[]u8", %"[]u8"* %result_contents, i32 0, i32 0
  %161 = load i8*, i8** %160, align 8
  %162 = getelementptr inbounds i8, i8* %161, i64 %159
  %163 = load i8, i8* %162, align 1
  %164 = icmp eq i8 %163, 0
  br i1 %164, label %SentinelOk, label %SentinelFail

ForEnd:                                           ; preds = %ForCond
  %165 = getelementptr inbounds { %"[][]u8", i16 }, { %"[][]u8", i16 }* %0, i32 0, i32 1
  store i16 0, i16* %165, align 2
  %166 = getelementptr inbounds { %"[][]u8", i16 }, { %"[][]u8", i16 }* %0, i32 0, i32 0
  %167 = bitcast %"[][]u8"* %result_slice_list to i8*
  %168 = bitcast %"[][]u8"* %166 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %168, i8* align 8 %167, i64 16, i1 false)
  call fastcc void @"std.array_list.ArrayListAligned(usize,null).deinit"(%"std.array_list.ArrayListAligned(usize,null)"* %slice_list)
  call fastcc void @"std.array_list.ArrayListAligned(u8,null).deinit"(%"std.array_list.ArrayListAligned(u8,null)"* %contents)
  call fastcc void @std.process.ArgIterator.deinit(%std.process.ArgIterator* %it)
  ret void

SentinelFail:                                     ; preds = %ForBody
  call fastcc void @std.builtin.default_panic(%"[]u8"* @120, %std.builtin.StackTrace* null)
  unreachable

SentinelOk:                                       ; preds = %ForBody
  %169 = getelementptr inbounds i8, i8* %161, i64 %158
  %170 = sub nuw i64 %159, %158
  %171 = getelementptr inbounds %"[]u8", %"[]u8"* %157, i32 0, i32 0
  store i8* %169, i8** %171, align 8
  %172 = getelementptr inbounds %"[]u8", %"[]u8"* %157, i32 0, i32 1
  store i64 %170, i64* %172, align 8
  %173 = load i64, i64* %new_index, align 8
  %174 = add nuw i64 %173, 1
  store i64 %174, i64* %contents_index, align 8
  %175 = add nuw i64 %145, 1
  store i64 %175, i64* %i, align 8
  br label %ForCond
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.debug.print.41(%"std.special.struct:19:57"* nonnull readonly align 8 %0) unnamed_addr #1 {
Entry:
  %1 = alloca %std.fs.file.File, align 4
  %stderr = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %2 = alloca %"std.special.struct:19:57", align 8
  %3 = alloca i16, align 2
  call fastcc void @std.Thread.Mutex.lock(%std.Thread.Mutex* @stderr_mutex)
  call fastcc void @std.io.getStdErr(%std.fs.file.File* sret(%std.fs.file.File) %1)
  call fastcc void @std.fs.file.File.writer(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* sret(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)") %stderr, %std.fs.file.File* %1)
  %4 = bitcast %"std.special.struct:19:57"* %0 to i8*
  %5 = bitcast %"std.special.struct:19:57"* %2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %5, i8* align 8 %4, i64 16, i1 false)
  %6 = call fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).print.58"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %stderr, %"std.special.struct:19:57"* %0)
  store i16 %6, i16* %3, align 2
  %7 = icmp ne i16 %6, 0
  br i1 %7, label %UnwrapErrError, label %UnwrapErrOk

UnwrapErrError:                                   ; preds = %Entry
  call fastcc void @std.Thread.Mutex.unlock(%std.Thread.Mutex* @stderr_mutex)
  ret void

UnwrapErrOk:                                      ; preds = %Entry
  br label %UnwrapErrEnd

UnwrapErrEnd:                                     ; preds = %UnwrapErrOk
  call fastcc void @std.Thread.Mutex.unlock(%std.Thread.Mutex* @stderr_mutex)
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i1 @std.fs.file.File.supportsAnsiEscapeCodes(%std.fs.file.File* nonnull readonly align 4 %0) unnamed_addr #1 {
Entry:
  %result = alloca i1, align 1
  %1 = alloca %"?[]const u8", align 8
  %term = alloca %"[]u8", align 8
  %2 = alloca %"[]u8", align 8
  %3 = call fastcc i1 @std.fs.file.File.isTty(%std.fs.file.File* %0)
  br i1 %3, label %Then, label %Else5

Then:                                             ; preds = %Entry
  %4 = getelementptr inbounds %std.fs.file.File, %std.fs.file.File* %0, i32 0, i32 0
  %5 = load i32, i32* %4, align 4
  %6 = icmp eq i32 %5, 1
  br i1 %6, label %BoolOrTrue, label %BoolOrFalse

BoolOrFalse:                                      ; preds = %Then
  %7 = getelementptr inbounds %std.fs.file.File, %std.fs.file.File* %0, i32 0, i32 0
  %8 = load i32, i32* %7, align 4
  %9 = icmp eq i32 %8, 2
  br label %BoolOrTrue

BoolOrTrue:                                       ; preds = %BoolOrFalse, %Then
  %10 = phi i1 [ %6, %Then ], [ %9, %BoolOrFalse ]
  br i1 %10, label %Then1, label %Else3

Then1:                                            ; preds = %BoolOrTrue
  call fastcc void @std.os.getenvZ(%"?[]const u8"* sret(%"?[]const u8") %1, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @111, i64 0, i64 0))
  %11 = getelementptr inbounds %"?[]const u8", %"?[]const u8"* %1, i32 0, i32 1
  %12 = load i1, i1* %11, align 1
  br i1 %12, label %OptionalThen, label %OptionalElse

OptionalThen:                                     ; preds = %Then1
  %13 = getelementptr inbounds %"?[]const u8", %"?[]const u8"* %1, i32 0, i32 0
  %14 = bitcast %"[]u8"* %13 to i8*
  %15 = bitcast %"[]u8"* %term to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %15, i8* align 8 %14, i64 16, i1 false)
  %16 = bitcast %"[]u8"* %term to i8*
  %17 = bitcast %"[]u8"* %2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %17, i8* align 8 %16, i64 16, i1 false)
  %18 = call fastcc i1 @std.mem.eql(%"[]u8"* %term, %"[]u8"* @113)
  br i1 %18, label %Then2, label %Else

Then2:                                            ; preds = %OptionalThen
  store i1 false, i1* %result, align 1
  %19 = load i1, i1* %result, align 1
  ret i1 %19

Else:                                             ; preds = %OptionalThen
  br label %EndIf

EndIf:                                            ; preds = %Else
  br label %OptionalEndIf

OptionalElse:                                     ; preds = %Then1
  br label %OptionalEndIf

OptionalEndIf:                                    ; preds = %OptionalElse, %EndIf
  br label %EndIf4

Else3:                                            ; preds = %BoolOrTrue
  br label %EndIf4

EndIf4:                                           ; preds = %Else3, %OptionalEndIf
  store i1 true, i1* %result, align 1
  %20 = load i1, i1* %result, align 1
  ret i1 %20

Else5:                                            ; preds = %Entry
  br label %EndIf6

EndIf6:                                           ; preds = %Else5
  store i1 false, i1* %result, align 1
  %21 = load i1, i1* %result, align 1
  ret i1 %21
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.time.Timer.start({ %std.time.Timer, i16 }* nonnull sret({ %std.time.Timer, i16 }) %0) unnamed_addr #1 {
Entry:
  %res = alloca %std.os.linux.timespec, align 8
  %1 = alloca i16, align 2
  %ts = alloca %std.os.linux.timespec, align 8
  %2 = alloca i16, align 2
  %3 = call fastcc i16 @std.os.clock_getres(i32 1, %std.os.linux.timespec* %res)
  store i16 %3, i16* %1, align 2
  %4 = icmp ne i16 %3, 0
  br i1 %4, label %UnwrapErrError, label %UnwrapErrOk

UnwrapErrError:                                   ; preds = %Entry
  %5 = getelementptr inbounds { %std.time.Timer, i16 }, { %std.time.Timer, i16 }* %0, i32 0, i32 1
  store i16 43, i16* %5, align 2
  ret void

UnwrapErrOk:                                      ; preds = %Entry
  br label %UnwrapErrEnd

UnwrapErrEnd:                                     ; preds = %UnwrapErrOk
  %6 = call fastcc i16 @std.os.clock_gettime(i32 1, %std.os.linux.timespec* %ts)
  store i16 %6, i16* %2, align 2
  %7 = icmp ne i16 %6, 0
  br i1 %7, label %UnwrapErrError1, label %UnwrapErrOk2

UnwrapErrError1:                                  ; preds = %UnwrapErrEnd
  %8 = getelementptr inbounds { %std.time.Timer, i16 }, { %std.time.Timer, i16 }* %0, i32 0, i32 1
  store i16 43, i16* %8, align 2
  ret void

UnwrapErrOk2:                                     ; preds = %UnwrapErrEnd
  br label %UnwrapErrEnd3

UnwrapErrEnd3:                                    ; preds = %UnwrapErrOk2
  %9 = getelementptr inbounds { %std.time.Timer, i16 }, { %std.time.Timer, i16 }* %0, i32 0, i32 1
  store i16 0, i16* %9, align 2
  %10 = getelementptr inbounds { %std.time.Timer, i16 }, { %std.time.Timer, i16 }* %0, i32 0, i32 0
  %11 = getelementptr inbounds %std.time.Timer, %std.time.Timer* %10, i32 0, i32 0
  %12 = getelementptr inbounds %std.os.linux.timespec, %std.os.linux.timespec* %res, i32 0, i32 0
  %13 = load i64, i64* %12, align 8
  %14 = mul nuw i64 %13, 1000000000
  %15 = getelementptr inbounds %std.os.linux.timespec, %std.os.linux.timespec* %res, i32 0, i32 1
  %16 = load i64, i64* %15, align 8
  %17 = add nuw i64 %14, %16
  store i64 %17, i64* %11, align 8
  %18 = getelementptr inbounds %std.time.Timer, %std.time.Timer* %10, i32 0, i32 1
  %19 = getelementptr inbounds %std.os.linux.timespec, %std.os.linux.timespec* %ts, i32 0, i32 0
  %20 = load i64, i64* %19, align 8
  %21 = mul nuw i64 %20, 1000000000
  %22 = getelementptr inbounds %std.os.linux.timespec, %std.os.linux.timespec* %ts, i32 0, i32 1
  %23 = load i64, i64* %22, align 8
  %24 = add nuw i64 %21, %23
  store i64 %24, i64* %18, align 8
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i1 @std.fs.file.File.isTty(%std.fs.file.File* nonnull readonly align 4 %0) unnamed_addr #1 {
Entry:
  %result = alloca i1, align 1
  %1 = getelementptr inbounds %std.fs.file.File, %std.fs.file.File* %0, i32 0, i32 0
  %2 = load i32, i32* %1, align 4
  %3 = call fastcc i1 @std.os.isatty(i32 %2)
  store i1 %3, i1* %result, align 1
  %4 = load i1, i1* %result, align 1
  ret i1 %4
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.os.getenvZ(%"?[]const u8"* nonnull sret(%"?[]const u8") %0, i8* nonnull readonly align 1 %1) unnamed_addr #1 {
Entry:
  %2 = alloca i8*, align 8
  %3 = alloca %"[]u8", align 8
  %key = alloca i8*, align 8
  store i8* %1, i8** %key, align 8
  %4 = load i8*, i8** %key, align 8
  store i8* %4, i8** %2, align 8
  call fastcc void @std.mem.sliceTo(%"[]u8"* sret(%"[]u8") %3, i8* %4)
  call fastcc void @std.os.getenv(%"?[]const u8"* sret(%"?[]const u8") %0, %"[]u8"* %3)
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i1 @std.mem.eql(%"[]u8"* nonnull readonly align 8 %0, %"[]u8"* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %result = alloca i1, align 1
  %index = alloca i64, align 8
  %item = alloca i8, align 1
  %2 = getelementptr inbounds %"[]u8", %"[]u8"* %0, i32 0, i32 1
  %3 = load i64, i64* %2, align 8
  %4 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 1
  %5 = load i64, i64* %4, align 8
  %6 = icmp ne i64 %3, %5
  br i1 %6, label %Then, label %Else

Then:                                             ; preds = %Entry
  store i1 false, i1* %result, align 1
  %7 = load i1, i1* %result, align 1
  ret i1 %7

Else:                                             ; preds = %Entry
  br label %EndIf

EndIf:                                            ; preds = %Else
  %8 = getelementptr inbounds %"[]u8", %"[]u8"* %0, i32 0, i32 0
  %9 = load i8*, i8** %8, align 8
  %10 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 0
  %11 = load i8*, i8** %10, align 8
  %12 = icmp eq i8* %9, %11
  br i1 %12, label %Then1, label %Else2

Then1:                                            ; preds = %EndIf
  store i1 true, i1* %result, align 1
  %13 = load i1, i1* %result, align 1
  ret i1 %13

Else2:                                            ; preds = %EndIf
  br label %EndIf3

EndIf3:                                           ; preds = %Else2
  store i64 0, i64* %index, align 8
  %14 = getelementptr inbounds %"[]u8", %"[]u8"* %0, i32 0, i32 1
  %15 = load i64, i64* %14, align 8
  br label %ForCond

ForCond:                                          ; preds = %EndIf6, %EndIf3
  %16 = load i64, i64* %index, align 8
  %17 = icmp ult i64 %16, %15
  br i1 %17, label %ForBody, label %ForEnd

ForBody:                                          ; preds = %ForCond
  %18 = getelementptr inbounds %"[]u8", %"[]u8"* %0, i32 0, i32 0
  %19 = load i8*, i8** %18, align 8
  %20 = getelementptr inbounds i8, i8* %19, i64 %16
  %21 = load i8, i8* %20, align 1
  store i8 %21, i8* %item, align 1
  %22 = load i64, i64* %index, align 8
  %23 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 0
  %24 = load i8*, i8** %23, align 8
  %25 = getelementptr inbounds i8, i8* %24, i64 %22
  %26 = load i8, i8* %25, align 1
  %27 = load i8, i8* %item, align 1
  %28 = icmp ne i8 %26, %27
  br i1 %28, label %Then4, label %Else5

Then4:                                            ; preds = %ForBody
  store i1 false, i1* %result, align 1
  %29 = load i1, i1* %result, align 1
  ret i1 %29

Else5:                                            ; preds = %ForBody
  br label %EndIf6

EndIf6:                                           ; preds = %Else5
  %30 = add nuw i64 %16, 1
  store i64 %30, i64* %index, align 8
  br label %ForCond

ForEnd:                                           ; preds = %ForCond
  store i1 true, i1* %result, align 1
  %31 = load i1, i1* %result, align 1
  ret i1 %31
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.os.clock_getres(i32 %0, %std.os.linux.timespec* nonnull align 8 %1) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %2 = alloca i16, align 2
  %err = alloca i16, align 2
  %clk_id = alloca i32, align 4
  %res = alloca %std.os.linux.timespec*, align 8
  store i32 %0, i32* %clk_id, align 4
  store %std.os.linux.timespec* %1, %std.os.linux.timespec** %res, align 8
  %3 = load i32, i32* %clk_id, align 4
  %4 = load %std.os.linux.timespec*, %std.os.linux.timespec** %res, align 8
  %5 = call fastcc i64 @std.os.linux.clock_getres(i32 %3, %std.os.linux.timespec* %4)
  %6 = call fastcc i16 @std.os.linux.getErrno(i64 %5)
  store i16 %6, i16* %2, align 2
  switch i16 %6, label %SwitchElse [
    i16 0, label %SwitchProng
    i16 14, label %SwitchProng1
    i16 22, label %SwitchProng2
  ]

SwitchElse:                                       ; preds = %Entry
  store i16 %6, i16* %err, align 2
  %7 = load i16, i16* %err, align 2
  %8 = call fastcc i16 @std.os.unexpectedErrno(i16 %7)
  store i16 %8, i16* %result, align 2
  %9 = load i16, i16* %result, align 2
  ret i16 %9

SwitchProng:                                      ; preds = %Entry
  store i16 0, i16* %result, align 2
  %10 = load i16, i16* %result, align 2
  ret i16 %10

SwitchProng1:                                     ; preds = %Entry
  unreachable

SwitchProng2:                                     ; preds = %Entry
  store i16 47, i16* %result, align 2
  %11 = load i16, i16* %result, align 2
  ret i16 %11
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.os.clock_gettime(i32 %0, %std.os.linux.timespec* nonnull align 8 %1) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %2 = alloca i16, align 2
  %err = alloca i16, align 2
  %clk_id = alloca i32, align 4
  %tp = alloca %std.os.linux.timespec*, align 8
  store i32 %0, i32* %clk_id, align 4
  store %std.os.linux.timespec* %1, %std.os.linux.timespec** %tp, align 8
  %3 = load i32, i32* %clk_id, align 4
  %4 = load %std.os.linux.timespec*, %std.os.linux.timespec** %tp, align 8
  %5 = call fastcc i64 @std.os.linux.clock_gettime(i32 %3, %std.os.linux.timespec* %4)
  %6 = call fastcc i16 @std.os.linux.getErrno(i64 %5)
  store i16 %6, i16* %2, align 2
  switch i16 %6, label %SwitchElse [
    i16 0, label %SwitchProng
    i16 14, label %SwitchProng1
    i16 22, label %SwitchProng2
  ]

SwitchElse:                                       ; preds = %Entry
  store i16 %6, i16* %err, align 2
  %7 = load i16, i16* %err, align 2
  %8 = call fastcc i16 @std.os.unexpectedErrno(i16 %7)
  store i16 %8, i16* %result, align 2
  %9 = load i16, i16* %result, align 2
  ret i16 %9

SwitchProng:                                      ; preds = %Entry
  store i16 0, i16* %result, align 2
  %10 = load i16, i16* %result, align 2
  ret i16 %10

SwitchProng1:                                     ; preds = %Entry
  unreachable

SwitchProng2:                                     ; preds = %Entry
  store i16 47, i16* %result, align 2
  %11 = load i16, i16* %result, align 2
  ret i16 %11
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc nonnull [8 x i8]* @std.mem.asBytes(i64* nonnull readonly align 8 %0) unnamed_addr #1 {
Entry:
  %result = alloca [8 x i8]*, align 8
  %ptr = alloca i64*, align 8
  store i64* %0, i64** %ptr, align 8
  %1 = load i64*, i64** %ptr, align 8
  %2 = bitcast i64* %1 to [8 x i8]*
  store [8 x i8]* %2, [8 x i8]** %result, align 8
  %3 = load [8 x i8]*, [8 x i8]** %result, align 8
  ret [8 x i8]* %3
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i64 @std.hash.wyhash.Wyhash.hash(i64 %0, %"[]u8"* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %result = alloca i64, align 8
  %seed = alloca i64, align 8
  store i64 %0, i64* %seed, align 8
  %2 = load i64, i64* %seed, align 8
  %3 = call fastcc i64 @std.hash.wyhash.WyhashStateless.hash(i64 %2, %"[]u8"* %1)
  store i64 %3, i64* %result, align 8
  %4 = load i64, i64* %result, align 8
  ret i64 %4
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i1 @std.meta.eql(i64 %0, i64 %1) unnamed_addr #1 {
Entry:
  %result = alloca i1, align 1
  %a = alloca i64, align 8
  %b = alloca i64, align 8
  store i64 %0, i64* %a, align 8
  store i64 %1, i64* %b, align 8
  %2 = load i64, i64* %a, align 8
  %3 = load i64, i64* %b, align 8
  %4 = icmp eq i64 %2, %3
  store i1 %4, i1* %result, align 1
  %5 = load i1, i1* %result, align 1
  ret i1 %5
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i1 @std.target.Target.isWasm(%std.target.Target* nonnull readonly align 8 %0) unnamed_addr #1 {
Entry:
  %result = alloca i1, align 1
  %1 = getelementptr inbounds %std.target.Target, %std.target.Target* %0, i32 0, i32 0
  %2 = getelementptr inbounds %std.target.Cpu, %std.target.Cpu* %1, i32 0, i32 0
  %3 = load i6, i6* %2, align 1
  %4 = call fastcc i1 @std.target.Arch.isWasm(i6 %3)
  store i1 %4, i1* %result, align 1
  %5 = load i1, i1* %result, align 1
  ret i1 %5
}

; Function Attrs: nofree nosync nounwind readnone speculatable willreturn
declare i29 @llvm.umin.i29(i29 %0, i29 %1) #9

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i1 @std.mem.isAligned(i64 %0, i64 %1) unnamed_addr #1 {
Entry:
  %result = alloca i1, align 1
  %2 = alloca i64, align 8
  %3 = alloca i64, align 8
  %addr = alloca i64, align 8
  %alignment = alloca i64, align 8
  store i64 %0, i64* %addr, align 8
  store i64 %1, i64* %alignment, align 8
  %4 = load i64, i64* %addr, align 8
  store i64 %4, i64* %2, align 8
  %5 = load i64, i64* %alignment, align 8
  store i64 %5, i64* %3, align 8
  %6 = call fastcc i1 @std.mem.isAlignedGeneric(i64 %4, i64 %5)
  store i1 %6, i1* %result, align 1
  %7 = load i1, i1* %result, align 1
  ret i1 %7
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i8* @std.mem.alignPointer(i8* nonnull align 4096 %0, i29 %1) unnamed_addr #1 {
Entry:
  %result = alloca i8*, align 8
  %2 = alloca i8*, align 8
  %3 = alloca i29, align 4
  %4 = alloca %"?usize", align 8
  %adjust_off = alloca i64, align 8
  %ptr = alloca i8*, align 8
  %align_to = alloca i29, align 4
  store i8* %0, i8** %ptr, align 8
  store i29 %1, i29* %align_to, align 4
  %5 = load i8*, i8** %ptr, align 8
  store i8* %5, i8** %2, align 8
  %6 = load i29, i29* %align_to, align 4
  store i29 %6, i29* %3, align 4
  call fastcc void @std.mem.alignPointerOffset(%"?usize"* sret(%"?usize") %4, i8* %5, i29 %6)
  %7 = getelementptr inbounds %"?usize", %"?usize"* %4, i32 0, i32 1
  %8 = load i1, i1* %7, align 1
  br i1 %8, label %OptionalNonNull, label %OptionalNull

OptionalNull:                                     ; preds = %Entry
  store i8* null, i8** %result, align 8
  %9 = load i8*, i8** %result, align 8
  ret i8* %9

OptionalNonNull:                                  ; preds = %Entry
  %10 = getelementptr inbounds %"?usize", %"?usize"* %4, i32 0, i32 0
  %11 = load i64, i64* %10, align 8
  store i64 %11, i64* %adjust_off, align 8
  br label %OptionalEnd

OptionalEnd:                                      ; preds = %OptionalNonNull
  %12 = load i8*, i8** %ptr, align 8
  %13 = load i64, i64* %adjust_off, align 8
  %14 = getelementptr inbounds i8, i8* %12, i64 %13
  store i8* %14, i8** %result, align 8
  %15 = load i8*, i8** %result, align 8
  ret i8* %15
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.os.munmap(%"[]u8"* nonnull readonly align 8 %0) unnamed_addr #1 {
Entry:
  %1 = alloca i16, align 2
  %2 = getelementptr inbounds %"[]u8", %"[]u8"* %0, i32 0, i32 0
  %3 = load i8*, i8** %2, align 8
  %4 = getelementptr inbounds %"[]u8", %"[]u8"* %0, i32 0, i32 1
  %5 = load i64, i64* %4, align 8
  %6 = call fastcc i64 @std.os.linux.munmap(i8* %3, i64 %5)
  %7 = call fastcc i16 @std.os.linux.getErrno(i64 %6)
  store i16 %7, i16* %1, align 2
  switch i16 %7, label %SwitchElse [
    i16 0, label %SwitchProng
    i16 22, label %SwitchProng1
    i16 12, label %SwitchProng2
  ]

SwitchElse:                                       ; preds = %Entry
  unreachable

SwitchProng:                                      ; preds = %Entry
  ret void

SwitchProng1:                                     ; preds = %Entry
  unreachable

SwitchProng2:                                     ; preds = %Entry
  unreachable
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i64 @std.heap.alignPageAllocLen(i64 %0, i64 %1, i29 %2) unnamed_addr #1 {
Entry:
  %result = alloca i64, align 8
  %aligned_len = alloca i64, align 8
  %full_len = alloca i64, align 8
  %len = alloca i64, align 8
  %len_align = alloca i29, align 4
  store i64 %0, i64* %full_len, align 8
  store i64 %1, i64* %len, align 8
  store i29 %2, i29* %len_align, align 4
  %3 = load i64, i64* %full_len, align 8
  %4 = load i64, i64* %len, align 8
  %5 = load i29, i29* %len_align, align 4
  %6 = call fastcc i64 @std.mem.alignAllocLen(i64 %3, i64 %4, i29 %5)
  store i64 %6, i64* %aligned_len, align 8
  %7 = load i64, i64* %aligned_len, align 8
  %8 = call fastcc i64 @std.mem.alignForward(i64 %7, i64 4096)
  %9 = load i64, i64* %full_len, align 8
  %10 = icmp eq i64 %8, %9
  call fastcc void @std.debug.assert(i1 %10)
  %11 = load i64, i64* %aligned_len, align 8
  store i64 %11, i64* %result, align 8
  %12 = load i64, i64* %result, align 8
  ret i64 %12
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i1 @std.Thread.Mutex.tryLock(%std.Thread.Mutex* nonnull align 4 %0) unnamed_addr #1 {
Entry:
  %result = alloca i1, align 1
  %m = alloca %std.Thread.Mutex*, align 8
  store %std.Thread.Mutex* %0, %std.Thread.Mutex** %m, align 8
  %1 = load %std.Thread.Mutex*, %std.Thread.Mutex** %m, align 8
  %2 = getelementptr inbounds %std.Thread.Mutex, %std.Thread.Mutex* %1, i32 0, i32 0
  %3 = call fastcc i1 @std.Thread.Mutex.AtomicMutex.tryLock(%std.Thread.Mutex.AtomicMutex* %2)
  store i1 %3, i1* %result, align 1
  %4 = load i1, i1* %result, align 1
  ret i1 %4
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.Progress.refreshWithHeldLock(%std.Progress* nonnull align 8 %0) unnamed_addr #1 {
Entry:
  %is_dumb = alloca i1, align 1
  %file = alloca %std.fs.file.File, align 4
  %end = alloca i64, align 8
  %1 = alloca %"[]u8", align 8
  %2 = alloca %"std.Progress.struct:202:79", align 8
  %3 = alloca { %"[]u8", i16 }, align 8
  %4 = alloca %"[]u8", align 8
  %5 = alloca { %"[]u8", i16 }, align 8
  %need_ellipse = alloca i1, align 1
  %maybe_node = alloca %std.Progress.Node*, align 8
  %node = alloca %std.Progress.Node*, align 8
  %eti = alloca i64, align 8
  %completed_items = alloca i64, align 8
  %6 = alloca %"std.Progress.struct:264:49", align 8
  %7 = alloca %"std.Progress.struct:269:56", align 8
  %8 = alloca %"std.Progress.struct:273:52", align 8
  %9 = alloca %"[]u8", align 8
  %10 = alloca { i64, i16 }, align 8
  %self = alloca %std.Progress*, align 8
  store %std.Progress* %0, %std.Progress** %self, align 8
  %11 = load %std.Progress*, %std.Progress** %self, align 8
  %12 = getelementptr inbounds %std.Progress, %std.Progress* %11, i32 0, i32 2
  %13 = load i1, i1* %12, align 1
  %14 = icmp eq i1 %13, false
  br i1 %14, label %BoolAndTrue, label %BoolAndFalse

BoolAndTrue:                                      ; preds = %Entry
  %15 = load %std.Progress*, %std.Progress** %self, align 8
  %16 = getelementptr inbounds %std.Progress, %std.Progress* %15, i32 0, i32 1
  %17 = load i1, i1* %16, align 1
  %18 = icmp eq i1 %17, false
  br label %BoolAndFalse

BoolAndFalse:                                     ; preds = %BoolAndTrue, %Entry
  %19 = phi i1 [ %14, %Entry ], [ %18, %BoolAndTrue ]
  store i1 %19, i1* %is_dumb, align 1
  %20 = load i1, i1* %is_dumb, align 1
  br i1 %20, label %BoolAndTrue1, label %BoolAndFalse2

BoolAndTrue1:                                     ; preds = %BoolAndFalse
  %21 = load %std.Progress*, %std.Progress** %self, align 8
  %22 = getelementptr inbounds %std.Progress, %std.Progress* %21, i32 0, i32 3
  %23 = load i1, i1* %22, align 1
  br label %BoolAndFalse2

BoolAndFalse2:                                    ; preds = %BoolAndTrue1, %BoolAndFalse
  %24 = phi i1 [ %20, %BoolAndFalse ], [ %23, %BoolAndTrue1 ]
  br i1 %24, label %Then, label %Else

Then:                                             ; preds = %BoolAndFalse2
  ret void

Else:                                             ; preds = %BoolAndFalse2
  br label %EndIf

EndIf:                                            ; preds = %Else
  %25 = load %std.Progress*, %std.Progress** %self, align 8
  %26 = getelementptr inbounds %std.Progress, %std.Progress* %25, i32 0, i32 0
  %27 = getelementptr inbounds %"?std.fs.file.File", %"?std.fs.file.File"* %26, i32 0, i32 1
  %28 = load i1, i1* %27, align 1
  br i1 %28, label %OptionalNonNull, label %OptionalNull

OptionalNull:                                     ; preds = %EndIf
  ret void

OptionalNonNull:                                  ; preds = %EndIf
  %29 = getelementptr inbounds %"?std.fs.file.File", %"?std.fs.file.File"* %26, i32 0, i32 0
  %30 = bitcast %std.fs.file.File* %29 to i8*
  %31 = bitcast %std.fs.file.File* %file to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %31, i8* align 4 %30, i64 4, i1 false)
  br label %OptionalEnd

OptionalEnd:                                      ; preds = %OptionalNonNull
  store i64 0, i64* %end, align 8
  %32 = load %std.Progress*, %std.Progress** %self, align 8
  %33 = getelementptr inbounds %std.Progress, %std.Progress* %32, i32 0, i32 12
  %34 = load i64, i64* %33, align 8
  %35 = icmp ugt i64 %34, 0
  br i1 %35, label %Then3, label %Else7

Then3:                                            ; preds = %OptionalEnd
  %36 = load %std.Progress*, %std.Progress** %self, align 8
  %37 = getelementptr inbounds %std.Progress, %std.Progress* %36, i32 0, i32 2
  %38 = load i1, i1* %37, align 1
  br i1 %38, label %Then4, label %Else5

Then4:                                            ; preds = %Then3
  %39 = load i64, i64* %end, align 8
  %40 = load %std.Progress*, %std.Progress** %self, align 8
  %41 = getelementptr inbounds %std.Progress, %std.Progress* %40, i32 0, i32 7
  %42 = load i64, i64* %end, align 8
  %43 = getelementptr inbounds [100 x i8], [100 x i8]* %41, i64 0, i64 %42
  %44 = sub nuw i64 100, %42
  %45 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 0
  store i8* %43, i8** %45, align 8
  %46 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 1
  store i64 %44, i64* %46, align 8
  %47 = load %std.Progress*, %std.Progress** %self, align 8
  %48 = getelementptr inbounds %std.Progress, %std.Progress* %47, i32 0, i32 12
  %49 = load i64, i64* %48, align 8
  %50 = getelementptr inbounds %"std.Progress.struct:202:79", %"std.Progress.struct:202:79"* %2, i32 0, i32 0
  store i64 %49, i64* %50, align 8
  call fastcc void @std.fmt.bufPrint({ %"[]u8", i16 }* sret({ %"[]u8", i16 }) %3, %"[]u8"* %1, %"std.Progress.struct:202:79"* %2)
  %51 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %3, i32 0, i32 0
  %52 = getelementptr inbounds %"[]u8", %"[]u8"* %51, i32 0, i32 1
  %53 = load i64, i64* %52, align 8
  %54 = add nuw i64 %39, %53
  store i64 %54, i64* %end, align 8
  %55 = load i64, i64* %end, align 8
  %56 = load %std.Progress*, %std.Progress** %self, align 8
  %57 = getelementptr inbounds %std.Progress, %std.Progress* %56, i32 0, i32 7
  %58 = load i64, i64* %end, align 8
  %59 = getelementptr inbounds [100 x i8], [100 x i8]* %57, i64 0, i64 %58
  %60 = sub nuw i64 100, %58
  %61 = getelementptr inbounds %"[]u8", %"[]u8"* %4, i32 0, i32 0
  store i8* %59, i8** %61, align 8
  %62 = getelementptr inbounds %"[]u8", %"[]u8"* %4, i32 0, i32 1
  store i64 %60, i64* %62, align 8
  call fastcc void @std.fmt.bufPrint.59({ %"[]u8", i16 }* sret({ %"[]u8", i16 }) %5, %"[]u8"* %4)
  %63 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %5, i32 0, i32 0
  %64 = getelementptr inbounds %"[]u8", %"[]u8"* %63, i32 0, i32 1
  %65 = load i64, i64* %64, align 8
  %66 = add nuw i64 %55, %65
  store i64 %66, i64* %end, align 8
  br label %EndIf6

Else5:                                            ; preds = %Then3
  %67 = load %std.Progress*, %std.Progress** %self, align 8
  %68 = getelementptr inbounds %std.Progress, %std.Progress* %67, i32 0, i32 7
  %69 = load i64, i64* %end, align 8
  %70 = getelementptr inbounds [100 x i8], [100 x i8]* %68, i64 0, i64 %69
  store i8 10, i8* %70, align 1
  %71 = load i64, i64* %end, align 8
  %72 = add nuw i64 %71, 1
  store i64 %72, i64* %end, align 8
  br label %EndIf6

EndIf6:                                           ; preds = %Else5, %Then4
  %73 = load %std.Progress*, %std.Progress** %self, align 8
  %74 = getelementptr inbounds %std.Progress, %std.Progress* %73, i32 0, i32 12
  store i64 0, i64* %74, align 8
  br label %EndIf8

Else7:                                            ; preds = %OptionalEnd
  br label %EndIf8

EndIf8:                                           ; preds = %Else7, %EndIf6
  %75 = load %std.Progress*, %std.Progress** %self, align 8
  %76 = getelementptr inbounds %std.Progress, %std.Progress* %75, i32 0, i32 10
  %77 = load i1, i1* %76, align 1
  %78 = icmp eq i1 %77, false
  br i1 %78, label %Then9, label %Else34

Then9:                                            ; preds = %EndIf8
  store i1 false, i1* %need_ellipse, align 1
  %79 = load %std.Progress*, %std.Progress** %self, align 8
  %80 = getelementptr inbounds %std.Progress, %std.Progress* %79, i32 0, i32 4
  store %std.Progress.Node* %80, %std.Progress.Node** %maybe_node, align 8
  br label %WhileCond

WhileCond:                                        ; preds = %EndIf30, %Then9
  %81 = load %std.Progress.Node*, %std.Progress.Node** %maybe_node, align 8
  %82 = icmp ne %std.Progress.Node* %81, null
  br i1 %82, label %WhileBody, label %WhileEnd

WhileBody:                                        ; preds = %WhileCond
  %83 = load %std.Progress.Node*, %std.Progress.Node** %maybe_node, align 8
  store %std.Progress.Node* %83, %std.Progress.Node** %node, align 8
  %84 = load i1, i1* %need_ellipse, align 1
  br i1 %84, label %Then10, label %Else11

Then10:                                           ; preds = %WhileBody
  %85 = load %std.Progress*, %std.Progress** %self, align 8
  call fastcc void @std.Progress.bufWrite(%std.Progress* %85, i64* %end)
  br label %EndIf12

Else11:                                           ; preds = %WhileBody
  br label %EndIf12

EndIf12:                                          ; preds = %Else11, %Then10
  store i1 false, i1* %need_ellipse, align 1
  %86 = load %std.Progress.Node*, %std.Progress.Node** %node, align 8
  %87 = getelementptr inbounds %std.Progress.Node, %std.Progress.Node* %86, i32 0, i32 4
  %88 = load atomic i64, i64* %87 monotonic, align 8
  store i64 %88, i64* %eti, align 8
  %89 = load %std.Progress.Node*, %std.Progress.Node** %node, align 8
  %90 = getelementptr inbounds %std.Progress.Node, %std.Progress.Node* %89, i32 0, i32 5
  %91 = load atomic i64, i64* %90 monotonic, align 8
  store i64 %91, i64* %completed_items, align 8
  %92 = load %std.Progress.Node*, %std.Progress.Node** %node, align 8
  %93 = getelementptr inbounds %std.Progress.Node, %std.Progress.Node* %92, i32 0, i32 2
  %94 = getelementptr inbounds %"[]u8", %"[]u8"* %93, i32 0, i32 1
  %95 = load i64, i64* %94, align 8
  %96 = icmp ne i64 %95, 0
  br i1 %96, label %BoolOrTrue, label %BoolOrFalse

BoolOrFalse:                                      ; preds = %EndIf12
  %97 = load i64, i64* %eti, align 8
  %98 = icmp ugt i64 %97, 0
  br label %BoolOrTrue

BoolOrTrue:                                       ; preds = %BoolOrFalse, %EndIf12
  %99 = phi i1 [ %96, %EndIf12 ], [ %98, %BoolOrFalse ]
  br i1 %99, label %Then13, label %Else29

Then13:                                           ; preds = %BoolOrTrue
  %100 = load %std.Progress.Node*, %std.Progress.Node** %node, align 8
  %101 = getelementptr inbounds %std.Progress.Node, %std.Progress.Node* %100, i32 0, i32 2
  %102 = getelementptr inbounds %"[]u8", %"[]u8"* %101, i32 0, i32 1
  %103 = load i64, i64* %102, align 8
  %104 = icmp ne i64 %103, 0
  br i1 %104, label %Then14, label %Else15

Then14:                                           ; preds = %Then13
  %105 = load %std.Progress*, %std.Progress** %self, align 8
  %106 = load %std.Progress.Node*, %std.Progress.Node** %node, align 8
  %107 = getelementptr inbounds %std.Progress.Node, %std.Progress.Node* %106, i32 0, i32 2
  %108 = getelementptr inbounds %"std.Progress.struct:264:49", %"std.Progress.struct:264:49"* %6, i32 0, i32 0
  %109 = bitcast %"[]u8"* %107 to i8*
  %110 = bitcast %"[]u8"* %108 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %110, i8* align 8 %109, i64 16, i1 false)
  call fastcc void @std.Progress.bufWrite.60(%std.Progress* %105, i64* %end, %"std.Progress.struct:264:49"* %6)
  store i1 true, i1* %need_ellipse, align 1
  br label %EndIf16

Else15:                                           ; preds = %Then13
  br label %EndIf16

EndIf16:                                          ; preds = %Else15, %Then14
  %111 = load i64, i64* %eti, align 8
  %112 = icmp ugt i64 %111, 0
  br i1 %112, label %Then17, label %Else20

Then17:                                           ; preds = %EndIf16
  %113 = load i1, i1* %need_ellipse, align 1
  br i1 %113, label %Then18, label %Else19

Then18:                                           ; preds = %Then17
  %114 = load %std.Progress*, %std.Progress** %self, align 8
  call fastcc void @std.Progress.bufWrite.61(%std.Progress* %114, i64* %end)
  br label %EndIf24

Else19:                                           ; preds = %Then17
  br label %EndIf24

Else20:                                           ; preds = %EndIf16
  %115 = load i64, i64* %completed_items, align 8
  %116 = icmp ne i64 %115, 0
  br i1 %116, label %Then21, label %Else26

Then21:                                           ; preds = %Else20
  %117 = load i1, i1* %need_ellipse, align 1
  br i1 %117, label %Then22, label %Else23

Then22:                                           ; preds = %Then21
  %118 = load %std.Progress*, %std.Progress** %self, align 8
  call fastcc void @std.Progress.bufWrite.62(%std.Progress* %118, i64* %end)
  br label %EndIf25

Else23:                                           ; preds = %Then21
  br label %EndIf25

EndIf24:                                          ; preds = %Else19, %Then18
  %119 = load %std.Progress*, %std.Progress** %self, align 8
  %120 = load i64, i64* %completed_items, align 8
  %121 = getelementptr inbounds %"std.Progress.struct:269:56", %"std.Progress.struct:269:56"* %7, i32 0, i32 0
  store i64 %120, i64* %121, align 8
  %122 = load i64, i64* %eti, align 8
  %123 = getelementptr inbounds %"std.Progress.struct:269:56", %"std.Progress.struct:269:56"* %7, i32 0, i32 1
  store i64 %122, i64* %123, align 8
  call fastcc void @std.Progress.bufWrite.63(%std.Progress* %119, i64* %end, %"std.Progress.struct:269:56"* %7)
  store i1 false, i1* %need_ellipse, align 1
  br label %EndIf28

EndIf25:                                          ; preds = %Else23, %Then22
  %124 = load %std.Progress*, %std.Progress** %self, align 8
  %125 = load i64, i64* %completed_items, align 8
  %126 = getelementptr inbounds %"std.Progress.struct:273:52", %"std.Progress.struct:273:52"* %8, i32 0, i32 0
  store i64 %125, i64* %126, align 8
  call fastcc void @std.Progress.bufWrite.64(%std.Progress* %124, i64* %end, %"std.Progress.struct:273:52"* %8)
  store i1 false, i1* %need_ellipse, align 1
  br label %EndIf27

Else26:                                           ; preds = %Else20
  br label %EndIf27

EndIf27:                                          ; preds = %Else26, %EndIf25
  br label %EndIf28

EndIf28:                                          ; preds = %EndIf27, %EndIf24
  br label %EndIf30

Else29:                                           ; preds = %BoolOrTrue
  br label %EndIf30

EndIf30:                                          ; preds = %Else29, %EndIf28
  %127 = load %std.Progress.Node*, %std.Progress.Node** %node, align 8
  %128 = getelementptr inbounds %std.Progress.Node, %std.Progress.Node* %127, i32 0, i32 3
  %129 = load atomic %std.Progress.Node*, %std.Progress.Node** %128 acquire, align 8
  store %std.Progress.Node* %129, %std.Progress.Node** %maybe_node, align 8
  br label %WhileCond

WhileEnd:                                         ; preds = %WhileCond
  %130 = load i1, i1* %need_ellipse, align 1
  br i1 %130, label %Then31, label %Else32

Then31:                                           ; preds = %WhileEnd
  %131 = load %std.Progress*, %std.Progress** %self, align 8
  call fastcc void @std.Progress.bufWrite.65(%std.Progress* %131, i64* %end)
  br label %EndIf33

Else32:                                           ; preds = %WhileEnd
  br label %EndIf33

EndIf33:                                          ; preds = %Else32, %Then31
  br label %EndIf35

Else34:                                           ; preds = %EndIf8
  br label %EndIf35

EndIf35:                                          ; preds = %Else34, %EndIf33
  %132 = load %std.Progress*, %std.Progress** %self, align 8
  %133 = getelementptr inbounds %std.Progress, %std.Progress* %132, i32 0, i32 7
  %134 = load i64, i64* %end, align 8
  %135 = getelementptr inbounds [100 x i8], [100 x i8]* %133, i64 0, i64 0
  %136 = sub nuw i64 %134, 0
  %137 = getelementptr inbounds %"[]u8", %"[]u8"* %9, i32 0, i32 0
  store i8* %135, i8** %137, align 8
  %138 = getelementptr inbounds %"[]u8", %"[]u8"* %9, i32 0, i32 1
  store i64 %136, i64* %138, align 8
  call fastcc void @std.fs.file.File.write({ i64, i16 }* sret({ i64, i16 }) %10, %std.fs.file.File* %file, %"[]u8"* %9)
  %139 = getelementptr inbounds { i64, i16 }, { i64, i16 }* %10, i32 0, i32 1
  %140 = load i16, i16* %139, align 2
  %141 = icmp ne i16 %140, 0
  br i1 %141, label %UnwrapErrError, label %UnwrapErrOk

UnwrapErrError:                                   ; preds = %EndIf35
  %142 = load %std.Progress*, %std.Progress** %self, align 8
  %143 = getelementptr inbounds %std.Progress, %std.Progress* %142, i32 0, i32 0
  %144 = bitcast %"?std.fs.file.File"* %143 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %144, i8* align 4 bitcast (%"?std.fs.file.File"* @125 to i8*), i64 8, i1 false)
  br label %UnwrapErrEnd

UnwrapErrOk:                                      ; preds = %EndIf35
  %145 = getelementptr inbounds { i64, i16 }, { i64, i16 }* %10, i32 0, i32 0
  br label %UnwrapErrEnd

UnwrapErrEnd:                                     ; preds = %UnwrapErrOk, %UnwrapErrError
  %146 = load %std.Progress*, %std.Progress** %self, align 8
  %147 = getelementptr inbounds %std.Progress, %std.Progress* %146, i32 0, i32 6
  %148 = load %std.Progress*, %std.Progress** %self, align 8
  %149 = getelementptr inbounds %std.Progress, %std.Progress* %148, i32 0, i32 5
  %150 = call fastcc i64 @std.time.Timer.read(%std.time.Timer* %149)
  store i64 %150, i64* %147, align 8
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).print.42"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %0, %"std.special.struct:62:49"* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %2 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %3 = alloca %"std.special.struct:62:49", align 8
  %4 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0 to i8*
  %5 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %5, i8* align 4 %4, i64 4, i1 false)
  %6 = bitcast %"std.special.struct:62:49"* %1 to i8*
  %7 = bitcast %"std.special.struct:62:49"* %3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %7, i8* align 8 %6, i64 32, i1 false)
  %8 = call fastcc i16 @std.fmt.format.66(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0, %"std.special.struct:62:49"* %1)
  store i16 %8, i16* %result, align 2
  %9 = load i16, i16* %result, align 2
  ret i16 %9
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.Progress.maybeRefresh(%std.Progress* nonnull align 8 %0) unnamed_addr #1 {
Entry:
  %now = alloca i64, align 8
  %self = alloca %std.Progress*, align 8
  store %std.Progress* %0, %std.Progress** %self, align 8
  %1 = load %std.Progress*, %std.Progress** %self, align 8
  %2 = getelementptr inbounds %std.Progress, %std.Progress* %1, i32 0, i32 5
  %3 = call fastcc i64 @std.time.Timer.read(%std.time.Timer* %2)
  store i64 %3, i64* %now, align 8
  %4 = load i64, i64* %now, align 8
  %5 = load %std.Progress*, %std.Progress** %self, align 8
  %6 = getelementptr inbounds %std.Progress, %std.Progress* %5, i32 0, i32 9
  %7 = load i64, i64* %6, align 8
  %8 = icmp ult i64 %4, %7
  br i1 %8, label %Then, label %Else

Then:                                             ; preds = %Entry
  ret void

Else:                                             ; preds = %Entry
  br label %EndIf

EndIf:                                            ; preds = %Else
  %9 = load %std.Progress*, %std.Progress** %self, align 8
  %10 = getelementptr inbounds %std.Progress, %std.Progress* %9, i32 0, i32 11
  %11 = call fastcc i1 @std.Thread.Mutex.tryLock(%std.Thread.Mutex* %10)
  %12 = icmp eq i1 %11, false
  br i1 %12, label %Then1, label %Else2

Then1:                                            ; preds = %EndIf
  ret void

Else2:                                            ; preds = %EndIf
  br label %EndIf3

EndIf3:                                           ; preds = %Else2
  %13 = load i64, i64* %now, align 8
  %14 = load %std.Progress*, %std.Progress** %self, align 8
  %15 = getelementptr inbounds %std.Progress, %std.Progress* %14, i32 0, i32 6
  %16 = load i64, i64* %15, align 8
  %17 = icmp ult i64 %13, %16
  br i1 %17, label %Then4, label %Else5

Then4:                                            ; preds = %EndIf3
  %18 = load %std.Progress*, %std.Progress** %self, align 8
  %19 = getelementptr inbounds %std.Progress, %std.Progress* %18, i32 0, i32 11
  call fastcc void @std.Thread.Mutex.unlock(%std.Thread.Mutex* %19)
  ret void

Else5:                                            ; preds = %EndIf3
  br label %EndIf6

EndIf6:                                           ; preds = %Else5
  %20 = load i64, i64* %now, align 8
  %21 = load %std.Progress*, %std.Progress** %self, align 8
  %22 = getelementptr inbounds %std.Progress, %std.Progress* %21, i32 0, i32 6
  %23 = load i64, i64* %22, align 8
  %24 = sub nuw i64 %20, %23
  %25 = load %std.Progress*, %std.Progress** %self, align 8
  %26 = getelementptr inbounds %std.Progress, %std.Progress* %25, i32 0, i32 8
  %27 = load i64, i64* %26, align 8
  %28 = icmp ult i64 %24, %27
  br i1 %28, label %Then7, label %Else8

Then7:                                            ; preds = %EndIf6
  %29 = load %std.Progress*, %std.Progress** %self, align 8
  %30 = getelementptr inbounds %std.Progress, %std.Progress* %29, i32 0, i32 11
  call fastcc void @std.Thread.Mutex.unlock(%std.Thread.Mutex* %30)
  ret void

Else8:                                            ; preds = %EndIf6
  br label %EndIf9

EndIf9:                                           ; preds = %Else8
  %31 = load %std.Progress*, %std.Progress** %self, align 8
  call fastcc void @std.Progress.refreshWithHeldLock(%std.Progress* %31)
  %32 = load %std.Progress*, %std.Progress** %self, align 8
  %33 = getelementptr inbounds %std.Progress, %std.Progress* %32, i32 0, i32 11
  call fastcc void @std.Thread.Mutex.unlock(%std.Thread.Mutex* %33)
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.Progress.Node.completeOne(%std.Progress.Node* nonnull align 8 %0) unnamed_addr #1 {
Entry:
  %self = alloca %std.Progress.Node*, align 8
  store %std.Progress.Node* %0, %std.Progress.Node** %self, align 8
  %1 = load %std.Progress.Node*, %std.Progress.Node** %self, align 8
  call fastcc void @std.Progress.Node.activate(%std.Progress.Node* %1)
  %2 = load %std.Progress.Node*, %std.Progress.Node** %self, align 8
  %3 = getelementptr inbounds %std.Progress.Node, %std.Progress.Node* %2, i32 0, i32 5
  %4 = atomicrmw add i64* %3, i64 1 monotonic, align 8
  %5 = load %std.Progress.Node*, %std.Progress.Node** %self, align 8
  %6 = getelementptr inbounds %std.Progress.Node, %std.Progress.Node* %5, i32 0, i32 0
  %7 = load %std.Progress*, %std.Progress** %6, align 8
  call fastcc void @std.Progress.maybeRefresh(%std.Progress* %7)
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).print.43"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %0, %"std.special.struct:76:61"* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %2 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %3 = alloca %"std.special.struct:76:61", align 8
  %4 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0 to i8*
  %5 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %5, i8* align 4 %4, i64 4, i1 false)
  %6 = bitcast %"std.special.struct:76:61"* %1 to i8*
  %7 = bitcast %"std.special.struct:76:61"* %3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %7, i8* align 8 %6, i64 16, i1 false)
  %8 = call fastcc i16 @std.fmt.format.67(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0, %"std.special.struct:76:61"* %1)
  store i16 %8, i16* %result, align 2
  %9 = load i16, i16* %result, align 2
  ret i16 %9
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).print.44"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %0) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %1 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %2 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0 to i8*
  %3 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %3, i8* align 4 %2, i64 4, i1 false)
  %4 = call fastcc i16 @std.fmt.format.68(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0)
  store i16 %4, i16* %result, align 2
  %5 = load i16, i16* %result, align 2
  ret i16 %5
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @"std.hash_map.HashMapUnmanaged(usize,std.heap.general_purpose_allocator.LargeAlloc,std.hash_map.AutoContext(usize),80).deinit"(%"std.hash_map.HashMapUnmanaged(usize,std.heap.general_purpose_allocator.LargeAlloc,std.hash_map.AutoContext(usize),80)"* nonnull align 8 %0, %std.mem.Allocator* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %self = alloca %"std.hash_map.HashMapUnmanaged(usize,std.heap.general_purpose_allocator.LargeAlloc,std.hash_map.AutoContext(usize),80)"*, align 8
  store %"std.hash_map.HashMapUnmanaged(usize,std.heap.general_purpose_allocator.LargeAlloc,std.hash_map.AutoContext(usize),80)"* %0, %"std.hash_map.HashMapUnmanaged(usize,std.heap.general_purpose_allocator.LargeAlloc,std.hash_map.AutoContext(usize),80)"** %self, align 8
  %2 = load %"std.hash_map.HashMapUnmanaged(usize,std.heap.general_purpose_allocator.LargeAlloc,std.hash_map.AutoContext(usize),80)"*, %"std.hash_map.HashMapUnmanaged(usize,std.heap.general_purpose_allocator.LargeAlloc,std.hash_map.AutoContext(usize),80)"** %self, align 8
  call fastcc void @"std.hash_map.HashMapUnmanaged(usize,std.heap.general_purpose_allocator.LargeAlloc,std.hash_map.AutoContext(usize),80).deallocate"(%"std.hash_map.HashMapUnmanaged(usize,std.heap.general_purpose_allocator.LargeAlloc,std.hash_map.AutoContext(usize),80)"* %2, %std.mem.Allocator* %1)
  %3 = load %"std.hash_map.HashMapUnmanaged(usize,std.heap.general_purpose_allocator.LargeAlloc,std.hash_map.AutoContext(usize),80)"*, %"std.hash_map.HashMapUnmanaged(usize,std.heap.general_purpose_allocator.LargeAlloc,std.hash_map.AutoContext(usize),80)"** %self, align 8
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).print.45"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %0) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %1 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %2 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0 to i8*
  %3 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %3, i8* align 4 %2, i64 4, i1 false)
  %4 = call fastcc i16 @std.fmt.format.69(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0)
  store i16 %4, i16* %result, align 2
  %5 = load i16, i16* %result, align 2
  ret i16 %5
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).print.46"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %0, %"std.special.struct:95:54"* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %2 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %3 = alloca %"std.special.struct:95:54", align 8
  %4 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0 to i8*
  %5 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %5, i8* align 4 %4, i64 4, i1 false)
  %6 = bitcast %"std.special.struct:95:54"* %1 to i8*
  %7 = bitcast %"std.special.struct:95:54"* %3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %7, i8* align 8 %6, i64 32, i1 false)
  %8 = call fastcc i16 @std.fmt.format.70(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0, %"std.special.struct:95:54"* %1)
  store i16 %8, i16* %result, align 2
  %9 = load i16, i16* %result, align 2
  ret i16 %9
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).print.47"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %0, %"std.special.struct:96:65"* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %2 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %3 = alloca %"std.special.struct:96:65", align 8
  %4 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0 to i8*
  %5 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %5, i8* align 4 %4, i64 4, i1 false)
  %6 = bitcast %"std.special.struct:96:65"* %1 to i8*
  %7 = bitcast %"std.special.struct:96:65"* %3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %7, i8* align 8 %6, i64 16, i1 false)
  %8 = call fastcc i16 @std.fmt.format.71(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0, %"std.special.struct:96:65"* %1)
  store i16 %8, i16* %result, align 2
  %9 = load i16, i16* %result, align 2
  ret i16 %9
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).print.48"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %0, %"std.special.struct:89:48"* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %2 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %3 = alloca %"std.special.struct:89:48", align 8
  %4 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0 to i8*
  %5 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %5, i8* align 4 %4, i64 4, i1 false)
  %6 = bitcast %"std.special.struct:89:48"* %1 to i8*
  %7 = bitcast %"std.special.struct:89:48"* %3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %7, i8* align 8 %6, i64 16, i1 false)
  %8 = call fastcc i16 @std.fmt.format.72(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0, %"std.special.struct:89:48"* %1)
  store i16 %8, i16* %result, align 2
  %9 = load i16, i16* %result, align 2
  ret i16 %9
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).print.49"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %0) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %1 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %2 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0 to i8*
  %3 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %3, i8* align 4 %2, i64 4, i1 false)
  %4 = call fastcc i16 @std.fmt.format.73(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0)
  store i16 %4, i16* %result, align 2
  %5 = load i16, i16* %result, align 2
  ret i16 %5
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).print.50"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %0, %"std.special.struct:105:53"* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %2 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %3 = alloca %"std.special.struct:105:53", align 8
  %4 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0 to i8*
  %5 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %5, i8* align 4 %4, i64 4, i1 false)
  %6 = bitcast %"std.special.struct:105:53"* %1 to i8*
  %7 = bitcast %"std.special.struct:105:53"* %3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %7, i8* align 8 %6, i64 8, i1 false)
  %8 = call fastcc i16 @std.fmt.format.74(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0, %"std.special.struct:105:53"* %1)
  store i16 %8, i16* %result, align 2
  %9 = load i16, i16* %result, align 2
  ret i16 %9
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).print.51"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %0, %"std.special.struct:107:68"* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %2 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %3 = alloca %"std.special.struct:107:68", align 8
  %4 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0 to i8*
  %5 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %5, i8* align 4 %4, i64 4, i1 false)
  %6 = bitcast %"std.special.struct:107:68"* %1 to i8*
  %7 = bitcast %"std.special.struct:107:68"* %3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %7, i8* align 8 %6, i64 24, i1 false)
  %8 = call fastcc i16 @std.fmt.format.75(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0, %"std.special.struct:107:68"* %1)
  store i16 %8, i16* %result, align 2
  %9 = load i16, i16* %result, align 2
  ret i16 %9
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).print.52"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %0, %"std.special.struct:110:55"* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %2 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %3 = alloca %"std.special.struct:110:55", align 8
  %4 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0 to i8*
  %5 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %5, i8* align 4 %4, i64 4, i1 false)
  %6 = bitcast %"std.special.struct:110:55"* %1 to i8*
  %7 = bitcast %"std.special.struct:110:55"* %3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %7, i8* align 8 %6, i64 8, i1 false)
  %8 = call fastcc i16 @std.fmt.format.76(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0, %"std.special.struct:110:55"* %1)
  store i16 %8, i16* %result, align 2
  %9 = load i16, i16* %result, align 2
  ret i16 %9
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).print.53"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %0, %"std.special.struct:113:56"* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %2 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %3 = alloca %"std.special.struct:113:56", align 8
  %4 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0 to i8*
  %5 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %5, i8* align 4 %4, i64 4, i1 false)
  %6 = bitcast %"std.special.struct:113:56"* %1 to i8*
  %7 = bitcast %"std.special.struct:113:56"* %3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %7, i8* align 8 %6, i64 8, i1 false)
  %8 = call fastcc i16 @std.fmt.format.77(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0, %"std.special.struct:113:56"* %1)
  store i16 %8, i16* %result, align 2
  %9 = load i16, i16* %result, align 2
  ret i16 %9
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.process.args(%std.process.ArgIterator* nonnull sret(%std.process.ArgIterator) %0) unnamed_addr #1 {
Entry:
  call fastcc void @std.process.ArgIterator.init(%std.process.ArgIterator* sret(%std.process.ArgIterator) %0)
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @"std.array_list.ArrayListAligned(u8,null).init"(%"std.array_list.ArrayListAligned(u8,null)"* nonnull sret(%"std.array_list.ArrayListAligned(u8,null)") %0, %std.mem.Allocator* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %2 = getelementptr inbounds %"std.array_list.ArrayListAligned(u8,null)", %"std.array_list.ArrayListAligned(u8,null)"* %0, i32 0, i32 0
  %3 = bitcast %"[]u8"* %2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %3, i8* align 8 bitcast (%"[]u8"* @121 to i8*), i64 16, i1 false)
  %4 = getelementptr inbounds %"std.array_list.ArrayListAligned(u8,null)", %"std.array_list.ArrayListAligned(u8,null)"* %0, i32 0, i32 1
  store i64 0, i64* %4, align 8
  %5 = getelementptr inbounds %"std.array_list.ArrayListAligned(u8,null)", %"std.array_list.ArrayListAligned(u8,null)"* %0, i32 0, i32 2
  %6 = bitcast %std.mem.Allocator* %1 to i8*
  %7 = bitcast %std.mem.Allocator* %5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %7, i8* align 8 %6, i64 16, i1 false)
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @"std.array_list.ArrayListAligned(usize,null).init"(%"std.array_list.ArrayListAligned(usize,null)"* nonnull sret(%"std.array_list.ArrayListAligned(usize,null)") %0, %std.mem.Allocator* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %2 = getelementptr inbounds %"std.array_list.ArrayListAligned(usize,null)", %"std.array_list.ArrayListAligned(usize,null)"* %0, i32 0, i32 0
  %3 = bitcast %"[]usize"* %2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %3, i8* align 8 bitcast (%"[]usize"* @122 to i8*), i64 16, i1 false)
  %4 = getelementptr inbounds %"std.array_list.ArrayListAligned(usize,null)", %"std.array_list.ArrayListAligned(usize,null)"* %0, i32 0, i32 1
  store i64 0, i64* %4, align 8
  %5 = getelementptr inbounds %"std.array_list.ArrayListAligned(usize,null)", %"std.array_list.ArrayListAligned(usize,null)"* %0, i32 0, i32 2
  %6 = bitcast %std.mem.Allocator* %1 to i8*
  %7 = bitcast %std.mem.Allocator* %5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %7, i8* align 8 %6, i64 16, i1 false)
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.process.ArgIterator.next({ %"?[:0]u8", i16 }* nonnull sret({ %"?[:0]u8", i16 }) %0, %std.process.ArgIterator* nonnull align 8 %1, %std.mem.Allocator* nonnull readonly align 8 %2) unnamed_addr #1 {
Entry:
  %3 = alloca %"?[:0]const u8", align 8
  %4 = alloca %"[]u8", align 8
  %5 = alloca { %"[]u8", i16 }, align 8
  %6 = alloca { %"?[:0]u8", i16 }, align 8
  %self = alloca %std.process.ArgIterator*, align 8
  store %std.process.ArgIterator* %1, %std.process.ArgIterator** %self, align 8
  %7 = load %std.process.ArgIterator*, %std.process.ArgIterator** %self, align 8
  %8 = getelementptr inbounds %std.process.ArgIterator, %std.process.ArgIterator* %7, i32 0, i32 0
  call fastcc void @std.process.ArgIteratorPosix.next(%"?[:0]const u8"* sret(%"?[:0]const u8") %3, %std.process.ArgIteratorPosix* %8)
  %9 = getelementptr inbounds %"?[:0]const u8", %"?[:0]const u8"* %3, i32 0, i32 1
  %10 = load i1, i1* %9, align 1
  br i1 %10, label %OptionalNonNull, label %OptionalNull

OptionalNull:                                     ; preds = %Entry
  %11 = getelementptr inbounds { %"?[:0]u8", i16 }, { %"?[:0]u8", i16 }* %0, i32 0, i32 1
  store i16 0, i16* %11, align 2
  %12 = getelementptr inbounds { %"?[:0]u8", i16 }, { %"?[:0]u8", i16 }* %0, i32 0, i32 0
  %13 = bitcast %"?[:0]u8"* %12 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %13, i8* align 8 bitcast (%"?[:0]u8"* @123 to i8*), i64 24, i1 false)
  ret void

OptionalNonNull:                                  ; preds = %Entry
  %14 = getelementptr inbounds %"?[:0]const u8", %"?[:0]const u8"* %3, i32 0, i32 0
  %15 = bitcast %"[]u8"* %14 to i8*
  %16 = bitcast %"[]u8"* %4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %16, i8* align 8 %15, i64 16, i1 false)
  br label %OptionalEnd

OptionalEnd:                                      ; preds = %OptionalNonNull
  call fastcc void @std.mem.Allocator.dupeZ({ %"[]u8", i16 }* sret({ %"[]u8", i16 }) %5, %std.mem.Allocator* %2, %"[]u8"* %14)
  %17 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %5, i32 0, i32 1
  %18 = load i16, i16* %17, align 2
  %19 = icmp ne i16 %18, 0
  br i1 %19, label %ErrRetReturn, label %ErrRetContinue

ErrRetReturn:                                     ; preds = %OptionalEnd
  %20 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %5, i32 0, i32 1
  %21 = load i16, i16* %20, align 2
  %22 = getelementptr inbounds { %"?[:0]u8", i16 }, { %"?[:0]u8", i16 }* %0, i32 0, i32 1
  store i16 %21, i16* %22, align 2
  %23 = getelementptr inbounds { %"?[:0]u8", i16 }, { %"?[:0]u8", i16 }* %6, i32 0, i32 1
  store i16 %21, i16* %23, align 2
  ret void

ErrRetContinue:                                   ; preds = %OptionalEnd
  %24 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %5, i32 0, i32 0
  %25 = getelementptr inbounds { %"?[:0]u8", i16 }, { %"?[:0]u8", i16 }* %0, i32 0, i32 1
  store i16 0, i16* %25, align 2
  %26 = getelementptr inbounds { %"?[:0]u8", i16 }, { %"?[:0]u8", i16 }* %0, i32 0, i32 0
  %27 = getelementptr inbounds %"?[:0]u8", %"?[:0]u8"* %26, i32 0, i32 1
  store i1 true, i1* %27, align 1
  %28 = getelementptr inbounds %"?[:0]u8", %"?[:0]u8"* %26, i32 0, i32 0
  %29 = bitcast %"[]u8"* %24 to i8*
  %30 = bitcast %"[]u8"* %28 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %30, i8* align 8 %29, i64 16, i1 false)
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @"std.array_list.ArrayListAligned(usize,null).deinit"(%"std.array_list.ArrayListAligned(usize,null)"* nonnull readonly align 8 %0) unnamed_addr #1 {
Entry:
  %1 = alloca %"[]usize", align 8
  %2 = getelementptr inbounds %"std.array_list.ArrayListAligned(usize,null)", %"std.array_list.ArrayListAligned(usize,null)"* %0, i32 0, i32 2
  call fastcc void @"std.array_list.ArrayListAligned(usize,null).allocatedSlice"(%"[]usize"* sret(%"[]usize") %1, %"std.array_list.ArrayListAligned(usize,null)"* %0)
  call fastcc void @std.mem.Allocator.free.54(%std.mem.Allocator* %2, %"[]usize"* %1)
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @"std.array_list.ArrayListAligned(u8,null).deinit"(%"std.array_list.ArrayListAligned(u8,null)"* nonnull readonly align 8 %0) unnamed_addr #1 {
Entry:
  %1 = alloca %"[]u8", align 8
  %2 = getelementptr inbounds %"std.array_list.ArrayListAligned(u8,null)", %"std.array_list.ArrayListAligned(u8,null)"* %0, i32 0, i32 2
  call fastcc void @"std.array_list.ArrayListAligned(u8,null).allocatedSlice"(%"[]u8"* sret(%"[]u8") %1, %"std.array_list.ArrayListAligned(u8,null)"* %0)
  call fastcc void @std.mem.Allocator.free.55(%std.mem.Allocator* %2, %"[]u8"* %1)
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.process.ArgIterator.deinit(%std.process.ArgIterator* nonnull align 8 %0) unnamed_addr #1 {
Entry:
  %self = alloca %std.process.ArgIterator*, align 8
  store %std.process.ArgIterator* %0, %std.process.ArgIterator** %self, align 8
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @"std.array_list.ArrayListAligned(u8,null).appendSlice"(%"std.array_list.ArrayListAligned(u8,null)"* nonnull align 8 %0, %"[]u8"* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %2 = alloca i16, align 2
  %self = alloca %"std.array_list.ArrayListAligned(u8,null)"*, align 8
  store %"std.array_list.ArrayListAligned(u8,null)"* %0, %"std.array_list.ArrayListAligned(u8,null)"** %self, align 8
  %3 = load %"std.array_list.ArrayListAligned(u8,null)"*, %"std.array_list.ArrayListAligned(u8,null)"** %self, align 8
  %4 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 1
  %5 = load i64, i64* %4, align 8
  %6 = call fastcc i16 @"std.array_list.ArrayListAligned(u8,null).ensureUnusedCapacity"(%"std.array_list.ArrayListAligned(u8,null)"* %3, i64 %5)
  store i16 %6, i16* %2, align 2
  %7 = icmp ne i16 %6, 0
  br i1 %7, label %ErrRetReturn, label %ErrRetContinue

ErrRetReturn:                                     ; preds = %Entry
  %8 = load i16, i16* %2, align 2
  store i16 %8, i16* %result, align 2
  ret i16 %8

ErrRetContinue:                                   ; preds = %Entry
  %9 = load %"std.array_list.ArrayListAligned(u8,null)"*, %"std.array_list.ArrayListAligned(u8,null)"** %self, align 8
  call fastcc void @"std.array_list.ArrayListAligned(u8,null).appendSliceAssumeCapacity"(%"std.array_list.ArrayListAligned(u8,null)"* %9, %"[]u8"* %1)
  store i16 0, i16* %result, align 2
  ret i16 0
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.mem.Allocator.free(%std.mem.Allocator* nonnull readonly align 8 %0, %"[]u8"* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %2 = alloca %"[]u8", align 8
  %bytes = alloca %"[]u8", align 8
  %bytes_len = alloca i64, align 8
  %non_const_ptr = alloca i8*, align 8
  %3 = alloca %"[]u8", align 8
  %4 = bitcast %"[]u8"* %1 to i8*
  %5 = bitcast %"[]u8"* %2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %5, i8* align 8 %4, i64 16, i1 false)
  call fastcc void @std.mem.sliceAsBytes(%"[]u8"* sret(%"[]u8") %bytes, %"[]u8"* %1)
  %6 = getelementptr inbounds %"[]u8", %"[]u8"* %bytes, i32 0, i32 1
  %7 = load i64, i64* %6, align 8
  %8 = add nuw i64 %7, 1
  store i64 %8, i64* %bytes_len, align 8
  %9 = load i64, i64* %bytes_len, align 8
  %10 = icmp eq i64 %9, 0
  br i1 %10, label %Then, label %Else

Then:                                             ; preds = %Entry
  ret void

Else:                                             ; preds = %Entry
  br label %EndIf

EndIf:                                            ; preds = %Else
  %11 = getelementptr inbounds %"[]u8", %"[]u8"* %bytes, i32 0, i32 0
  %12 = load i8*, i8** %11, align 8
  %13 = ptrtoint i8* %12 to i64
  %14 = inttoptr i64 %13 to i8*
  store i8* %14, i8** %non_const_ptr, align 8
  %15 = load i8*, i8** %non_const_ptr, align 8
  %16 = load i64, i64* %bytes_len, align 8
  %17 = load i64, i64* %bytes_len, align 8
  %18 = load i8*, i8** %non_const_ptr, align 8
  %19 = getelementptr inbounds i8, i8* %18, i64 0
  %20 = sub nuw i64 %17, 0
  %21 = getelementptr inbounds %"[]u8", %"[]u8"* %3, i32 0, i32 0
  store i8* %19, i8** %21, align 8
  %22 = getelementptr inbounds %"[]u8", %"[]u8"* %3, i32 0, i32 1
  store i64 %20, i64* %22, align 8
  %23 = call i8* @llvm.returnaddress(i32 0)
  %24 = ptrtoint i8* %23 to i64
  call fastcc void @std.mem.Allocator.rawFree(%std.mem.Allocator* %0, %"[]u8"* %3, i29 1, i64 %24)
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @"std.array_list.ArrayListAligned(usize,null).append"(%"std.array_list.ArrayListAligned(usize,null)"* nonnull align 8 %0, i64 %1) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %2 = alloca { i64*, i16 }, align 8
  %new_item_ptr = alloca i64*, align 8
  %self = alloca %"std.array_list.ArrayListAligned(usize,null)"*, align 8
  %item = alloca i64, align 8
  store %"std.array_list.ArrayListAligned(usize,null)"* %0, %"std.array_list.ArrayListAligned(usize,null)"** %self, align 8
  store i64 %1, i64* %item, align 8
  %3 = load %"std.array_list.ArrayListAligned(usize,null)"*, %"std.array_list.ArrayListAligned(usize,null)"** %self, align 8
  call fastcc void @"std.array_list.ArrayListAligned(usize,null).addOne"({ i64*, i16 }* sret({ i64*, i16 }) %2, %"std.array_list.ArrayListAligned(usize,null)"* %3)
  %4 = getelementptr inbounds { i64*, i16 }, { i64*, i16 }* %2, i32 0, i32 1
  %5 = load i16, i16* %4, align 2
  %6 = icmp ne i16 %5, 0
  br i1 %6, label %ErrRetReturn, label %ErrRetContinue

ErrRetReturn:                                     ; preds = %Entry
  %7 = getelementptr inbounds { i64*, i16 }, { i64*, i16 }* %2, i32 0, i32 1
  %8 = load i16, i16* %7, align 2
  store i16 %8, i16* %result, align 2
  ret i16 %8

ErrRetContinue:                                   ; preds = %Entry
  %9 = getelementptr inbounds { i64*, i16 }, { i64*, i16 }* %2, i32 0, i32 0
  %10 = load i64*, i64** %9, align 8
  store i64* %10, i64** %new_item_ptr, align 8
  %11 = load i64*, i64** %new_item_ptr, align 8
  %12 = load i64, i64* %item, align 8
  store i64 %12, i64* %11, align 8
  store i16 0, i16* %result, align 2
  ret i16 0
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.math.add({ i64, i16 }* nonnull sret({ i64, i16 }) %0, i64 %1, i64 %2) unnamed_addr #1 {
Entry:
  %answer = alloca i64, align 8
  %3 = alloca { i64, i16 }, align 8
  %a = alloca i64, align 8
  %b = alloca i64, align 8
  store i64 %1, i64* %a, align 8
  store i64 %2, i64* %b, align 8
  %4 = load i64, i64* %a, align 8
  %5 = load i64, i64* %b, align 8
  %6 = call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %4, i64 %5)
  %7 = extractvalue { i64, i1 } %6, 0
  %8 = extractvalue { i64, i1 } %6, 1
  store i64 %7, i64* %answer, align 8
  br i1 %8, label %Then, label %Else

Then:                                             ; preds = %Entry
  %9 = getelementptr inbounds { i64, i16 }, { i64, i16 }* %0, i32 0, i32 1
  store i16 46, i16* %9, align 2
  br label %EndIf

Else:                                             ; preds = %Entry
  %10 = load i64, i64* %answer, align 8
  %11 = getelementptr inbounds { i64, i16 }, { i64, i16 }* %0, i32 0, i32 1
  store i16 0, i16* %11, align 2
  %12 = getelementptr inbounds { i64, i16 }, { i64, i16 }* %0, i32 0, i32 0
  store i64 %10, i64* %12, align 8
  %13 = getelementptr inbounds { i64, i16 }, { i64, i16 }* %3, i32 0, i32 1
  store i16 0, i16* %13, align 2
  %14 = getelementptr inbounds { i64, i16 }, { i64, i16 }* %3, i32 0, i32 0
  store i64 %10, i64* %14, align 8
  br label %EndIf

EndIf:                                            ; preds = %Else, %Then
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.math.mul({ i64, i16 }* nonnull sret({ i64, i16 }) %0, i64 %1, i64 %2) unnamed_addr #1 {
Entry:
  %answer = alloca i64, align 8
  %3 = alloca { i64, i16 }, align 8
  %a = alloca i64, align 8
  %b = alloca i64, align 8
  store i64 %1, i64* %a, align 8
  store i64 %2, i64* %b, align 8
  %4 = load i64, i64* %a, align 8
  %5 = load i64, i64* %b, align 8
  %6 = call { i64, i1 } @llvm.umul.with.overflow.i64(i64 %4, i64 %5)
  %7 = extractvalue { i64, i1 } %6, 0
  %8 = extractvalue { i64, i1 } %6, 1
  store i64 %7, i64* %answer, align 8
  br i1 %8, label %Then, label %Else

Then:                                             ; preds = %Entry
  %9 = getelementptr inbounds { i64, i16 }, { i64, i16 }* %0, i32 0, i32 1
  store i16 46, i16* %9, align 2
  br label %EndIf

Else:                                             ; preds = %Entry
  %10 = load i64, i64* %answer, align 8
  %11 = getelementptr inbounds { i64, i16 }, { i64, i16 }* %0, i32 0, i32 1
  store i16 0, i16* %11, align 2
  %12 = getelementptr inbounds { i64, i16 }, { i64, i16 }* %0, i32 0, i32 0
  store i64 %10, i64* %12, align 8
  %13 = getelementptr inbounds { i64, i16 }, { i64, i16 }* %3, i32 0, i32 1
  store i16 0, i16* %13, align 2
  %14 = getelementptr inbounds { i64, i16 }, { i64, i16 }* %3, i32 0, i32 0
  store i64 %10, i64* %14, align 8
  br label %EndIf

EndIf:                                            ; preds = %Else, %Then
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.mem.Allocator.alignedAlloc({ %"[]u8", i16 }* nonnull sret({ %"[]u8", i16 }) %0, %std.mem.Allocator* nonnull readonly align 8 %1, i64 %2) unnamed_addr #1 {
Entry:
  %3 = alloca i64, align 8
  %4 = alloca i64, align 8
  %n = alloca i64, align 8
  store i64 %2, i64* %n, align 8
  %5 = load i64, i64* %n, align 8
  store i64 %5, i64* %3, align 8
  %6 = call i8* @llvm.returnaddress(i32 0)
  %7 = ptrtoint i8* %6 to i64
  store i64 %7, i64* %4, align 8
  call fastcc void @std.mem.Allocator.allocAdvancedWithRetAddr({ %"[]u8", i16 }* sret({ %"[]u8", i16 }) %0, %std.mem.Allocator* %1, i64 %5, i1 false, i64 %7)
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.mem.bytesAsSlice(%"[][]u8"* nonnull sret(%"[][]u8") %0, %"[]u8"* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %2 = alloca %"[]u8"*, align 8
  %3 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 1
  %4 = load i64, i64* %3, align 8
  %5 = icmp eq i64 %4, 0
  br i1 %5, label %Then, label %Else

Then:                                             ; preds = %Entry
  %6 = bitcast %"[][]u8"* %0 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %6, i8* align 8 bitcast (%"[][]u8"* @124 to i8*), i64 16, i1 false)
  ret void

Else:                                             ; preds = %Entry
  br label %EndIf

EndIf:                                            ; preds = %Else
  %7 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 0
  %8 = load i8*, i8** %7, align 8
  %9 = bitcast i8* %8 to %"[]u8"*
  store %"[]u8"* %9, %"[]u8"** %2, align 8
  %10 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 1
  %11 = load i64, i64* %10, align 8
  %12 = udiv exact i64 %11, 16
  %13 = load %"[]u8"*, %"[]u8"** %2, align 8
  %14 = getelementptr inbounds %"[]u8", %"[]u8"* %13, i64 0
  %15 = sub nuw i64 %12, 0
  %16 = getelementptr inbounds %"[][]u8", %"[][]u8"* %0, i32 0, i32 0
  store %"[]u8"* %14, %"[]u8"** %16, align 8
  %17 = getelementptr inbounds %"[][]u8", %"[][]u8"* %0, i32 0, i32 1
  store i64 %15, i64* %17, align 8
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.heap.FixedBufferAllocator.init(%std.heap.FixedBufferAllocator* nonnull sret(%std.heap.FixedBufferAllocator) %0, %"[]u8"* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %2 = getelementptr inbounds %std.heap.FixedBufferAllocator, %std.heap.FixedBufferAllocator* %0, i32 0, i32 1
  %3 = bitcast %"[]u8"* %1 to i8*
  %4 = bitcast %"[]u8"* %2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %4, i8* align 8 %3, i64 16, i1 false)
  %5 = getelementptr inbounds %std.heap.FixedBufferAllocator, %std.heap.FixedBufferAllocator* %0, i32 0, i32 0
  store i64 0, i64* %5, align 8
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.mem.Allocator.init(%std.mem.Allocator* nonnull sret(%std.mem.Allocator) %0, %std.heap.FixedBufferAllocator* nonnull align 8 %1) unnamed_addr #1 {
Entry:
  %pointer = alloca %std.heap.FixedBufferAllocator*, align 8
  store %std.heap.FixedBufferAllocator* %1, %std.heap.FixedBufferAllocator** %pointer, align 8
  call fastcc void @std.debug.assert(i1 true)
  call fastcc void @std.debug.assert(i1 true)
  %2 = getelementptr inbounds %std.mem.Allocator, %std.mem.Allocator* %0, i32 0, i32 0
  %3 = load %std.heap.FixedBufferAllocator*, %std.heap.FixedBufferAllocator** %pointer, align 8
  %4 = bitcast %std.heap.FixedBufferAllocator* %3 to i8*
  store i8* %4, i8** %2, align 8
  %5 = getelementptr inbounds %std.mem.Allocator, %std.mem.Allocator* %0, i32 0, i32 1
  store %std.mem.Allocator.VTable* @vtable.17, %std.mem.Allocator.VTable** %5, align 8
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.process.ArgIterator.init(%std.process.ArgIterator* nonnull sret(%std.process.ArgIterator) %0) unnamed_addr #1 {
Entry:
  %1 = getelementptr inbounds %std.process.ArgIterator, %std.process.ArgIterator* %0, i32 0, i32 0
  call fastcc void @std.process.ArgIteratorPosix.init(%std.process.ArgIteratorPosix* sret(%std.process.ArgIteratorPosix) %1)
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.process.ArgIteratorPosix.next(%"?[:0]const u8"* nonnull sret(%"?[:0]const u8") %0, %std.process.ArgIteratorPosix* nonnull align 8 %1) unnamed_addr #1 {
Entry:
  %s = alloca i8*, align 8
  %2 = alloca i8*, align 8
  %self = alloca %std.process.ArgIteratorPosix*, align 8
  store %std.process.ArgIteratorPosix* %1, %std.process.ArgIteratorPosix** %self, align 8
  %3 = load %std.process.ArgIteratorPosix*, %std.process.ArgIteratorPosix** %self, align 8
  %4 = getelementptr inbounds %std.process.ArgIteratorPosix, %std.process.ArgIteratorPosix* %3, i32 0, i32 0
  %5 = load i64, i64* %4, align 8
  %6 = load %std.process.ArgIteratorPosix*, %std.process.ArgIteratorPosix** %self, align 8
  %7 = getelementptr inbounds %std.process.ArgIteratorPosix, %std.process.ArgIteratorPosix* %6, i32 0, i32 1
  %8 = load i64, i64* %7, align 8
  %9 = icmp eq i64 %5, %8
  br i1 %9, label %Then, label %Else

Then:                                             ; preds = %Entry
  %10 = bitcast %"?[:0]const u8"* %0 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %10, i8* align 8 bitcast (%"?[:0]const u8"* @130 to i8*), i64 24, i1 false)
  ret void

Else:                                             ; preds = %Entry
  br label %EndIf

EndIf:                                            ; preds = %Else
  %11 = load %std.process.ArgIteratorPosix*, %std.process.ArgIteratorPosix** %self, align 8
  %12 = getelementptr inbounds %std.process.ArgIteratorPosix, %std.process.ArgIteratorPosix* %11, i32 0, i32 0
  %13 = load i64, i64* %12, align 8
  %14 = load i8**, i8*** getelementptr inbounds (%"[][*:0]u8", %"[][*:0]u8"* @argv, i32 0, i32 0), align 8
  %15 = getelementptr inbounds i8*, i8** %14, i64 %13
  %16 = load i8*, i8** %15, align 8
  store i8* %16, i8** %s, align 8
  %17 = load %std.process.ArgIteratorPosix*, %std.process.ArgIteratorPosix** %self, align 8
  %18 = getelementptr inbounds %std.process.ArgIteratorPosix, %std.process.ArgIteratorPosix* %17, i32 0, i32 0
  %19 = load i64, i64* %18, align 8
  %20 = add nuw i64 %19, 1
  store i64 %20, i64* %18, align 8
  %21 = load i8*, i8** %s, align 8
  store i8* %21, i8** %2, align 8
  %22 = getelementptr inbounds %"?[:0]const u8", %"?[:0]const u8"* %0, i32 0, i32 1
  store i1 true, i1* %22, align 1
  %23 = getelementptr inbounds %"?[:0]const u8", %"?[:0]const u8"* %0, i32 0, i32 0
  call fastcc void @std.mem.sliceTo.79(%"[]u8"* sret(%"[]u8") %23, i8* %21)
  %24 = getelementptr inbounds %"?[:0]const u8", %"?[:0]const u8"* %0, i32 0, i32 1
  store i1 true, i1* %24, align 1
  %25 = getelementptr inbounds %"?[:0]const u8", %"?[:0]const u8"* %0, i32 0, i32 0
  %26 = bitcast %"[]u8"* %23 to i8*
  %27 = bitcast %"[]u8"* %25 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %27, i8* align 8 %26, i64 16, i1 false)
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.mem.Allocator.dupeZ({ %"[]u8", i16 }* nonnull sret({ %"[]u8", i16 }) %0, %std.mem.Allocator* nonnull readonly align 8 %1, %"[]u8"* nonnull readonly align 8 %2) unnamed_addr #1 {
Entry:
  %3 = alloca i64, align 8
  %4 = alloca { %"[]u8", i16 }, align 8
  %5 = alloca { %"[]u8", i16 }, align 8
  %new_buf = alloca %"[]u8", align 8
  %6 = alloca %"[]u8", align 8
  %7 = alloca %"[]u8", align 8
  %8 = getelementptr inbounds %"[]u8", %"[]u8"* %2, i32 0, i32 1
  %9 = load i64, i64* %8, align 8
  %10 = add nuw i64 %9, 1
  store i64 %10, i64* %3, align 8
  call fastcc void @std.mem.Allocator.alloc({ %"[]u8", i16 }* sret({ %"[]u8", i16 }) %4, %std.mem.Allocator* %1, i64 %10)
  %11 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %4, i32 0, i32 1
  %12 = load i16, i16* %11, align 2
  %13 = icmp ne i16 %12, 0
  br i1 %13, label %ErrRetReturn, label %ErrRetContinue

ErrRetReturn:                                     ; preds = %Entry
  %14 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %4, i32 0, i32 1
  %15 = load i16, i16* %14, align 2
  %16 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %0, i32 0, i32 1
  store i16 %15, i16* %16, align 2
  %17 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %5, i32 0, i32 1
  store i16 %15, i16* %17, align 2
  ret void

ErrRetContinue:                                   ; preds = %Entry
  %18 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %4, i32 0, i32 0
  %19 = bitcast %"[]u8"* %18 to i8*
  %20 = bitcast %"[]u8"* %new_buf to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %20, i8* align 8 %19, i64 16, i1 false)
  %21 = bitcast %"[]u8"* %new_buf to i8*
  %22 = bitcast %"[]u8"* %6 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %22, i8* align 8 %21, i64 16, i1 false)
  %23 = bitcast %"[]u8"* %2 to i8*
  %24 = bitcast %"[]u8"* %7 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %24, i8* align 8 %23, i64 16, i1 false)
  call fastcc void @std.mem.copy(%"[]u8"* %new_buf, %"[]u8"* %2)
  %25 = getelementptr inbounds %"[]u8", %"[]u8"* %2, i32 0, i32 1
  %26 = load i64, i64* %25, align 8
  %27 = getelementptr inbounds %"[]u8", %"[]u8"* %new_buf, i32 0, i32 0
  %28 = load i8*, i8** %27, align 8
  %29 = getelementptr inbounds i8, i8* %28, i64 %26
  store i8 0, i8* %29, align 1
  %30 = getelementptr inbounds %"[]u8", %"[]u8"* %2, i32 0, i32 1
  %31 = load i64, i64* %30, align 8
  %32 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %0, i32 0, i32 1
  store i16 0, i16* %32, align 2
  %33 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %0, i32 0, i32 0
  %34 = getelementptr inbounds %"[]u8", %"[]u8"* %new_buf, i32 0, i32 0
  %35 = load i8*, i8** %34, align 8
  %36 = getelementptr inbounds i8, i8* %35, i64 %31
  %37 = load i8, i8* %36, align 1
  %38 = icmp eq i8 %37, 0
  br i1 %38, label %SentinelOk, label %SentinelFail

SentinelFail:                                     ; preds = %ErrRetContinue
  call fastcc void @std.builtin.default_panic(%"[]u8"* @120, %std.builtin.StackTrace* null)
  unreachable

SentinelOk:                                       ; preds = %ErrRetContinue
  %39 = getelementptr inbounds i8, i8* %35, i64 0
  %40 = sub nuw i64 %31, 0
  %41 = getelementptr inbounds %"[]u8", %"[]u8"* %33, i32 0, i32 0
  store i8* %39, i8** %41, align 8
  %42 = getelementptr inbounds %"[]u8", %"[]u8"* %33, i32 0, i32 1
  store i64 %40, i64* %42, align 8
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @"std.array_list.ArrayListAligned(usize,null).allocatedSlice"(%"[]usize"* nonnull sret(%"[]usize") %0, %"std.array_list.ArrayListAligned(usize,null)"* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %2 = getelementptr inbounds %"std.array_list.ArrayListAligned(usize,null)", %"std.array_list.ArrayListAligned(usize,null)"* %1, i32 0, i32 0
  %3 = getelementptr inbounds %"[]usize", %"[]usize"* %2, i32 0, i32 0
  %4 = getelementptr inbounds %"std.array_list.ArrayListAligned(usize,null)", %"std.array_list.ArrayListAligned(usize,null)"* %1, i32 0, i32 1
  %5 = load i64, i64* %4, align 8
  %6 = load i64*, i64** %3, align 8
  %7 = getelementptr inbounds i64, i64* %6, i64 0
  %8 = sub nuw i64 %5, 0
  %9 = getelementptr inbounds %"[]usize", %"[]usize"* %0, i32 0, i32 0
  store i64* %7, i64** %9, align 8
  %10 = getelementptr inbounds %"[]usize", %"[]usize"* %0, i32 0, i32 1
  store i64 %8, i64* %10, align 8
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.mem.Allocator.free.54(%std.mem.Allocator* nonnull readonly align 8 %0, %"[]usize"* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %2 = alloca %"[]usize", align 8
  %bytes = alloca %"[]u8", align 8
  %bytes_len = alloca i64, align 8
  %non_const_ptr = alloca i8*, align 8
  %3 = alloca %"[]u8", align 8
  %4 = bitcast %"[]usize"* %1 to i8*
  %5 = bitcast %"[]usize"* %2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %5, i8* align 8 %4, i64 16, i1 false)
  call fastcc void @std.mem.sliceAsBytes.81(%"[]u8"* sret(%"[]u8") %bytes, %"[]usize"* %1)
  %6 = getelementptr inbounds %"[]u8", %"[]u8"* %bytes, i32 0, i32 1
  %7 = load i64, i64* %6, align 8
  %8 = add nuw i64 %7, 0
  store i64 %8, i64* %bytes_len, align 8
  %9 = load i64, i64* %bytes_len, align 8
  %10 = icmp eq i64 %9, 0
  br i1 %10, label %Then, label %Else

Then:                                             ; preds = %Entry
  ret void

Else:                                             ; preds = %Entry
  br label %EndIf

EndIf:                                            ; preds = %Else
  %11 = getelementptr inbounds %"[]u8", %"[]u8"* %bytes, i32 0, i32 0
  %12 = load i8*, i8** %11, align 8
  %13 = ptrtoint i8* %12 to i64
  %14 = inttoptr i64 %13 to i8*
  store i8* %14, i8** %non_const_ptr, align 8
  %15 = load i8*, i8** %non_const_ptr, align 8
  %16 = load i64, i64* %bytes_len, align 8
  %17 = load i64, i64* %bytes_len, align 8
  %18 = load i8*, i8** %non_const_ptr, align 8
  %19 = getelementptr inbounds i8, i8* %18, i64 0
  %20 = sub nuw i64 %17, 0
  %21 = getelementptr inbounds %"[]u8", %"[]u8"* %3, i32 0, i32 0
  store i8* %19, i8** %21, align 8
  %22 = getelementptr inbounds %"[]u8", %"[]u8"* %3, i32 0, i32 1
  store i64 %20, i64* %22, align 8
  %23 = call i8* @llvm.returnaddress(i32 0)
  %24 = ptrtoint i8* %23 to i64
  call fastcc void @std.mem.Allocator.rawFree(%std.mem.Allocator* %0, %"[]u8"* %3, i29 8, i64 %24)
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @"std.array_list.ArrayListAligned(u8,null).allocatedSlice"(%"[]u8"* nonnull sret(%"[]u8") %0, %"std.array_list.ArrayListAligned(u8,null)"* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %2 = getelementptr inbounds %"std.array_list.ArrayListAligned(u8,null)", %"std.array_list.ArrayListAligned(u8,null)"* %1, i32 0, i32 0
  %3 = getelementptr inbounds %"[]u8", %"[]u8"* %2, i32 0, i32 0
  %4 = getelementptr inbounds %"std.array_list.ArrayListAligned(u8,null)", %"std.array_list.ArrayListAligned(u8,null)"* %1, i32 0, i32 1
  %5 = load i64, i64* %4, align 8
  %6 = load i8*, i8** %3, align 8
  %7 = getelementptr inbounds i8, i8* %6, i64 0
  %8 = sub nuw i64 %5, 0
  %9 = getelementptr inbounds %"[]u8", %"[]u8"* %0, i32 0, i32 0
  store i8* %7, i8** %9, align 8
  %10 = getelementptr inbounds %"[]u8", %"[]u8"* %0, i32 0, i32 1
  store i64 %8, i64* %10, align 8
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.mem.Allocator.free.55(%std.mem.Allocator* nonnull readonly align 8 %0, %"[]u8"* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %2 = alloca %"[]u8", align 8
  %bytes = alloca %"[]u8", align 8
  %bytes_len = alloca i64, align 8
  %non_const_ptr = alloca i8*, align 8
  %3 = alloca %"[]u8", align 8
  %4 = bitcast %"[]u8"* %1 to i8*
  %5 = bitcast %"[]u8"* %2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %5, i8* align 8 %4, i64 16, i1 false)
  call fastcc void @std.mem.sliceAsBytes.82(%"[]u8"* sret(%"[]u8") %bytes, %"[]u8"* %1)
  %6 = getelementptr inbounds %"[]u8", %"[]u8"* %bytes, i32 0, i32 1
  %7 = load i64, i64* %6, align 8
  %8 = add nuw i64 %7, 0
  store i64 %8, i64* %bytes_len, align 8
  %9 = load i64, i64* %bytes_len, align 8
  %10 = icmp eq i64 %9, 0
  br i1 %10, label %Then, label %Else

Then:                                             ; preds = %Entry
  ret void

Else:                                             ; preds = %Entry
  br label %EndIf

EndIf:                                            ; preds = %Else
  %11 = getelementptr inbounds %"[]u8", %"[]u8"* %bytes, i32 0, i32 0
  %12 = load i8*, i8** %11, align 8
  %13 = ptrtoint i8* %12 to i64
  %14 = inttoptr i64 %13 to i8*
  store i8* %14, i8** %non_const_ptr, align 8
  %15 = load i8*, i8** %non_const_ptr, align 8
  %16 = load i64, i64* %bytes_len, align 8
  %17 = load i64, i64* %bytes_len, align 8
  %18 = load i8*, i8** %non_const_ptr, align 8
  %19 = getelementptr inbounds i8, i8* %18, i64 0
  %20 = sub nuw i64 %17, 0
  %21 = getelementptr inbounds %"[]u8", %"[]u8"* %3, i32 0, i32 0
  store i8* %19, i8** %21, align 8
  %22 = getelementptr inbounds %"[]u8", %"[]u8"* %3, i32 0, i32 1
  store i64 %20, i64* %22, align 8
  %23 = call i8* @llvm.returnaddress(i32 0)
  %24 = ptrtoint i8* %23 to i64
  call fastcc void @std.mem.Allocator.rawFree(%std.mem.Allocator* %0, %"[]u8"* %3, i29 1, i64 %24)
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @"std.array_list.ArrayListAligned(u8,null).ensureUnusedCapacity"(%"std.array_list.ArrayListAligned(u8,null)"* nonnull align 8 %0, i64 %1) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %self = alloca %"std.array_list.ArrayListAligned(u8,null)"*, align 8
  %additional_count = alloca i64, align 8
  store %"std.array_list.ArrayListAligned(u8,null)"* %0, %"std.array_list.ArrayListAligned(u8,null)"** %self, align 8
  store i64 %1, i64* %additional_count, align 8
  %2 = load %"std.array_list.ArrayListAligned(u8,null)"*, %"std.array_list.ArrayListAligned(u8,null)"** %self, align 8
  %3 = load %"std.array_list.ArrayListAligned(u8,null)"*, %"std.array_list.ArrayListAligned(u8,null)"** %self, align 8
  %4 = getelementptr inbounds %"std.array_list.ArrayListAligned(u8,null)", %"std.array_list.ArrayListAligned(u8,null)"* %3, i32 0, i32 0
  %5 = getelementptr inbounds %"[]u8", %"[]u8"* %4, i32 0, i32 1
  %6 = load i64, i64* %5, align 8
  %7 = load i64, i64* %additional_count, align 8
  %8 = add nuw i64 %6, %7
  %9 = call fastcc i16 @"std.array_list.ArrayListAligned(u8,null).ensureTotalCapacity"(%"std.array_list.ArrayListAligned(u8,null)"* %2, i64 %8)
  store i16 %9, i16* %result, align 2
  %10 = load i16, i16* %result, align 2
  ret i16 %10
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @"std.array_list.ArrayListAligned(u8,null).appendSliceAssumeCapacity"(%"std.array_list.ArrayListAligned(u8,null)"* nonnull align 8 %0, %"[]u8"* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %old_len = alloca i64, align 8
  %new_len = alloca i64, align 8
  %2 = alloca %"[]u8", align 8
  %3 = alloca %"[]u8", align 8
  %self = alloca %"std.array_list.ArrayListAligned(u8,null)"*, align 8
  store %"std.array_list.ArrayListAligned(u8,null)"* %0, %"std.array_list.ArrayListAligned(u8,null)"** %self, align 8
  %4 = load %"std.array_list.ArrayListAligned(u8,null)"*, %"std.array_list.ArrayListAligned(u8,null)"** %self, align 8
  %5 = getelementptr inbounds %"std.array_list.ArrayListAligned(u8,null)", %"std.array_list.ArrayListAligned(u8,null)"* %4, i32 0, i32 0
  %6 = getelementptr inbounds %"[]u8", %"[]u8"* %5, i32 0, i32 1
  %7 = load i64, i64* %6, align 8
  store i64 %7, i64* %old_len, align 8
  %8 = load i64, i64* %old_len, align 8
  %9 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 1
  %10 = load i64, i64* %9, align 8
  %11 = add nuw i64 %8, %10
  store i64 %11, i64* %new_len, align 8
  %12 = load i64, i64* %new_len, align 8
  %13 = load %"std.array_list.ArrayListAligned(u8,null)"*, %"std.array_list.ArrayListAligned(u8,null)"** %self, align 8
  %14 = getelementptr inbounds %"std.array_list.ArrayListAligned(u8,null)", %"std.array_list.ArrayListAligned(u8,null)"* %13, i32 0, i32 1
  %15 = load i64, i64* %14, align 8
  %16 = icmp ule i64 %12, %15
  call fastcc void @std.debug.assert(i1 %16)
  %17 = load %"std.array_list.ArrayListAligned(u8,null)"*, %"std.array_list.ArrayListAligned(u8,null)"** %self, align 8
  %18 = getelementptr inbounds %"std.array_list.ArrayListAligned(u8,null)", %"std.array_list.ArrayListAligned(u8,null)"* %17, i32 0, i32 0
  %19 = getelementptr inbounds %"[]u8", %"[]u8"* %18, i32 0, i32 1
  %20 = load i64, i64* %new_len, align 8
  store i64 %20, i64* %19, align 8
  %21 = load %"std.array_list.ArrayListAligned(u8,null)"*, %"std.array_list.ArrayListAligned(u8,null)"** %self, align 8
  %22 = getelementptr inbounds %"std.array_list.ArrayListAligned(u8,null)", %"std.array_list.ArrayListAligned(u8,null)"* %21, i32 0, i32 0
  %23 = load i64, i64* %old_len, align 8
  %24 = getelementptr inbounds %"[]u8", %"[]u8"* %22, i32 0, i32 1
  %25 = load i64, i64* %24, align 8
  %26 = getelementptr inbounds %"[]u8", %"[]u8"* %22, i32 0, i32 0
  %27 = load i8*, i8** %26, align 8
  %28 = getelementptr inbounds i8, i8* %27, i64 %23
  %29 = sub nuw i64 %25, %23
  %30 = getelementptr inbounds %"[]u8", %"[]u8"* %2, i32 0, i32 0
  store i8* %28, i8** %30, align 8
  %31 = getelementptr inbounds %"[]u8", %"[]u8"* %2, i32 0, i32 1
  store i64 %29, i64* %31, align 8
  %32 = bitcast %"[]u8"* %1 to i8*
  %33 = bitcast %"[]u8"* %3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %33, i8* align 8 %32, i64 16, i1 false)
  call fastcc void @std.mem.copy(%"[]u8"* %2, %"[]u8"* %1)
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @"std.array_list.ArrayListAligned(u8,null).ensureTotalCapacity"(%"std.array_list.ArrayListAligned(u8,null)"* nonnull align 8 %0, i64 %1) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %better_capacity = alloca i64, align 8
  %self = alloca %"std.array_list.ArrayListAligned(u8,null)"*, align 8
  %new_capacity = alloca i64, align 8
  store %"std.array_list.ArrayListAligned(u8,null)"* %0, %"std.array_list.ArrayListAligned(u8,null)"** %self, align 8
  store i64 %1, i64* %new_capacity, align 8
  %2 = load %"std.array_list.ArrayListAligned(u8,null)"*, %"std.array_list.ArrayListAligned(u8,null)"** %self, align 8
  %3 = getelementptr inbounds %"std.array_list.ArrayListAligned(u8,null)", %"std.array_list.ArrayListAligned(u8,null)"* %2, i32 0, i32 1
  %4 = load i64, i64* %3, align 8
  store i64 %4, i64* %better_capacity, align 8
  %5 = load i64, i64* %better_capacity, align 8
  %6 = load i64, i64* %new_capacity, align 8
  %7 = icmp uge i64 %5, %6
  br i1 %7, label %Then, label %Else

Then:                                             ; preds = %Entry
  store i16 0, i16* %result, align 2
  %8 = load i16, i16* %result, align 2
  ret i16 %8

Else:                                             ; preds = %Entry
  br label %EndIf

EndIf:                                            ; preds = %Else
  br label %WhileCond

WhileCond:                                        ; preds = %EndIf3, %EndIf
  br label %WhileBody

WhileBody:                                        ; preds = %WhileCond
  %9 = load i64, i64* %better_capacity, align 8
  %10 = load i64, i64* %better_capacity, align 8
  %11 = udiv i64 %10, 2
  %12 = add nuw i64 %11, 8
  %13 = add nuw i64 %9, %12
  store i64 %13, i64* %better_capacity, align 8
  %14 = load i64, i64* %better_capacity, align 8
  %15 = load i64, i64* %new_capacity, align 8
  %16 = icmp uge i64 %14, %15
  br i1 %16, label %Then1, label %Else2

Then1:                                            ; preds = %WhileBody
  br label %WhileEnd

Else2:                                            ; preds = %WhileBody
  br label %EndIf3

EndIf3:                                           ; preds = %Else2
  br label %WhileCond

WhileEnd:                                         ; preds = %Then1
  %17 = load %"std.array_list.ArrayListAligned(u8,null)"*, %"std.array_list.ArrayListAligned(u8,null)"** %self, align 8
  %18 = load i64, i64* %better_capacity, align 8
  %19 = call fastcc i16 @"std.array_list.ArrayListAligned(u8,null).ensureTotalCapacityPrecise"(%"std.array_list.ArrayListAligned(u8,null)"* %17, i64 %18)
  store i16 %19, i16* %result, align 2
  %20 = load i16, i16* %result, align 2
  ret i16 %20
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @"std.array_list.ArrayListAligned(u8,null).ensureTotalCapacityPrecise"(%"std.array_list.ArrayListAligned(u8,null)"* nonnull align 8 %0, i64 %1) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %2 = alloca %"[]u8", align 8
  %3 = alloca i64, align 8
  %4 = alloca { %"[]u8", i16 }, align 8
  %new_memory = alloca %"[]u8", align 8
  %self = alloca %"std.array_list.ArrayListAligned(u8,null)"*, align 8
  %new_capacity = alloca i64, align 8
  store %"std.array_list.ArrayListAligned(u8,null)"* %0, %"std.array_list.ArrayListAligned(u8,null)"** %self, align 8
  store i64 %1, i64* %new_capacity, align 8
  %5 = load %"std.array_list.ArrayListAligned(u8,null)"*, %"std.array_list.ArrayListAligned(u8,null)"** %self, align 8
  %6 = getelementptr inbounds %"std.array_list.ArrayListAligned(u8,null)", %"std.array_list.ArrayListAligned(u8,null)"* %5, i32 0, i32 1
  %7 = load i64, i64* %6, align 8
  %8 = load i64, i64* %new_capacity, align 8
  %9 = icmp uge i64 %7, %8
  br i1 %9, label %Then, label %Else

Then:                                             ; preds = %Entry
  store i16 0, i16* %result, align 2
  %10 = load i16, i16* %result, align 2
  ret i16 %10

Else:                                             ; preds = %Entry
  br label %EndIf

EndIf:                                            ; preds = %Else
  %11 = load %"std.array_list.ArrayListAligned(u8,null)"*, %"std.array_list.ArrayListAligned(u8,null)"** %self, align 8
  %12 = getelementptr inbounds %"std.array_list.ArrayListAligned(u8,null)", %"std.array_list.ArrayListAligned(u8,null)"* %11, i32 0, i32 2
  %13 = load %"std.array_list.ArrayListAligned(u8,null)"*, %"std.array_list.ArrayListAligned(u8,null)"** %self, align 8
  call fastcc void @"std.array_list.ArrayListAligned(u8,null).allocatedSlice"(%"[]u8"* sret(%"[]u8") %2, %"std.array_list.ArrayListAligned(u8,null)"* %13)
  %14 = load i64, i64* %new_capacity, align 8
  store i64 %14, i64* %3, align 8
  call fastcc void @std.mem.Allocator.reallocAtLeast({ %"[]u8", i16 }* sret({ %"[]u8", i16 }) %4, %std.mem.Allocator* %12, %"[]u8"* %2, i64 %14)
  %15 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %4, i32 0, i32 1
  %16 = load i16, i16* %15, align 2
  %17 = icmp ne i16 %16, 0
  br i1 %17, label %ErrRetReturn, label %ErrRetContinue

ErrRetReturn:                                     ; preds = %EndIf
  %18 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %4, i32 0, i32 1
  %19 = load i16, i16* %18, align 2
  store i16 %19, i16* %result, align 2
  ret i16 %19

ErrRetContinue:                                   ; preds = %EndIf
  %20 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %4, i32 0, i32 0
  %21 = bitcast %"[]u8"* %20 to i8*
  %22 = bitcast %"[]u8"* %new_memory to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %22, i8* align 8 %21, i64 16, i1 false)
  %23 = load %"std.array_list.ArrayListAligned(u8,null)"*, %"std.array_list.ArrayListAligned(u8,null)"** %self, align 8
  %24 = getelementptr inbounds %"std.array_list.ArrayListAligned(u8,null)", %"std.array_list.ArrayListAligned(u8,null)"* %23, i32 0, i32 0
  %25 = getelementptr inbounds %"[]u8", %"[]u8"* %24, i32 0, i32 0
  %26 = getelementptr inbounds %"[]u8", %"[]u8"* %new_memory, i32 0, i32 0
  %27 = load i8*, i8** %26, align 8
  store i8* %27, i8** %25, align 8
  %28 = load %"std.array_list.ArrayListAligned(u8,null)"*, %"std.array_list.ArrayListAligned(u8,null)"** %self, align 8
  %29 = getelementptr inbounds %"std.array_list.ArrayListAligned(u8,null)", %"std.array_list.ArrayListAligned(u8,null)"* %28, i32 0, i32 1
  %30 = getelementptr inbounds %"[]u8", %"[]u8"* %new_memory, i32 0, i32 1
  %31 = load i64, i64* %30, align 8
  store i64 %31, i64* %29, align 8
  store i16 0, i16* %result, align 2
  ret i16 0
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.mem.Allocator.reallocAtLeast({ %"[]u8", i16 }* nonnull sret({ %"[]u8", i16 }) %0, %std.mem.Allocator* nonnull readonly align 8 %1, %"[]u8"* nonnull readonly align 8 %2, i64 %3) unnamed_addr #1 {
Entry:
  %4 = alloca %"[]u8", align 8
  %5 = alloca i64, align 8
  %6 = alloca i64, align 8
  %new_n = alloca i64, align 8
  store i64 %3, i64* %new_n, align 8
  %7 = bitcast %"[]u8"* %2 to i8*
  %8 = bitcast %"[]u8"* %4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %8, i8* align 8 %7, i64 16, i1 false)
  %9 = load i64, i64* %new_n, align 8
  store i64 %9, i64* %5, align 8
  %10 = call i8* @llvm.returnaddress(i32 0)
  %11 = ptrtoint i8* %10 to i64
  store i64 %11, i64* %6, align 8
  call fastcc void @std.mem.Allocator.reallocAdvancedWithRetAddr({ %"[]u8", i16 }* sret({ %"[]u8", i16 }) %0, %std.mem.Allocator* %1, %"[]u8"* %2, i64 %9, i1 true, i64 %11)
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.mem.Allocator.reallocAdvancedWithRetAddr({ %"[]u8", i16 }* nonnull sret({ %"[]u8", i16 }) %0, %std.mem.Allocator* nonnull readonly align 8 %1, %"[]u8"* nonnull readonly align 8 %2, i64 %3, i1 %4, i64 %5) unnamed_addr #1 {
Entry:
  %6 = alloca i64, align 8
  %7 = alloca i1, align 1
  %8 = alloca i64, align 8
  %9 = alloca %"[]u8", align 8
  %10 = alloca %"[]u8", align 8
  %old_byte_slice = alloca %"[]u8", align 8
  %11 = alloca i64, align 8
  %12 = alloca { i64, i16 }, align 8
  %byte_count = alloca i64, align 8
  %len_align = alloca i29, align 4
  %shrunk_len = alloca i64, align 8
  %13 = alloca %"[]u8", align 8
  %14 = alloca %"[]u8", align 8
  %15 = alloca %"?usize", align 8
  %resized_len = alloca i64, align 8
  %16 = alloca %"[]u8", align 8
  %17 = alloca %"[]u8", align 8
  %18 = alloca { %"[]u8", i16 }, align 8
  %19 = alloca { %"[]u8", i16 }, align 8
  %new_mem = alloca %"[]u8", align 8
  %20 = alloca i64, align 8
  %21 = alloca i64, align 8
  %22 = alloca %"[]u8", align 8
  %new_n = alloca i64, align 8
  %exact = alloca i1, align 1
  %return_address = alloca i64, align 8
  store i64 %3, i64* %new_n, align 8
  store i1 %4, i1* %exact, align 1
  store i64 %5, i64* %return_address, align 8
  %23 = getelementptr inbounds %"[]u8", %"[]u8"* %2, i32 0, i32 1
  %24 = load i64, i64* %23, align 8
  %25 = icmp eq i64 %24, 0
  br i1 %25, label %Then, label %Else

Then:                                             ; preds = %Entry
  %26 = load i64, i64* %new_n, align 8
  store i64 %26, i64* %6, align 8
  %27 = load i1, i1* %exact, align 1
  store i1 %27, i1* %7, align 1
  %28 = load i64, i64* %return_address, align 8
  store i64 %28, i64* %8, align 8
  call fastcc void @std.mem.Allocator.allocAdvancedWithRetAddr.83({ %"[]u8", i16 }* sret({ %"[]u8", i16 }) %0, %std.mem.Allocator* %1, i64 %26, i1 %27, i64 %28)
  ret void

Else:                                             ; preds = %Entry
  br label %EndIf

EndIf:                                            ; preds = %Else
  %29 = load i64, i64* %new_n, align 8
  %30 = icmp eq i64 %29, 0
  br i1 %30, label %Then1, label %Else2

Then1:                                            ; preds = %EndIf
  %31 = bitcast %"[]u8"* %2 to i8*
  %32 = bitcast %"[]u8"* %9 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %32, i8* align 8 %31, i64 16, i1 false)
  call fastcc void @std.mem.Allocator.free.55(%std.mem.Allocator* %1, %"[]u8"* %2)
  %33 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %0, i32 0, i32 1
  store i16 0, i16* %33, align 2
  %34 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %0, i32 0, i32 0
  %35 = bitcast %"[]u8"* %34 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %35, i8* align 8 bitcast (%"[]u8"* @131 to i8*), i64 16, i1 false)
  ret void

Else2:                                            ; preds = %EndIf
  br label %EndIf3

EndIf3:                                           ; preds = %Else2
  %36 = bitcast %"[]u8"* %2 to i8*
  %37 = bitcast %"[]u8"* %10 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %37, i8* align 8 %36, i64 16, i1 false)
  call fastcc void @std.mem.sliceAsBytes.82(%"[]u8"* sret(%"[]u8") %old_byte_slice, %"[]u8"* %2)
  %38 = load i64, i64* %new_n, align 8
  store i64 %38, i64* %11, align 8
  call fastcc void @std.math.mul({ i64, i16 }* sret({ i64, i16 }) %12, i64 1, i64 %38)
  %39 = getelementptr inbounds { i64, i16 }, { i64, i16 }* %12, i32 0, i32 1
  %40 = load i16, i16* %39, align 2
  %41 = icmp ne i16 %40, 0
  br i1 %41, label %UnwrapErrError, label %UnwrapErrOk

UnwrapErrError:                                   ; preds = %EndIf3
  %42 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %0, i32 0, i32 1
  store i16 16, i16* %42, align 2
  ret void

UnwrapErrOk:                                      ; preds = %EndIf3
  %43 = getelementptr inbounds { i64, i16 }, { i64, i16 }* %12, i32 0, i32 0
  %44 = load i64, i64* %43, align 8
  store i64 %44, i64* %byte_count, align 8
  br label %UnwrapErrEnd

UnwrapErrEnd:                                     ; preds = %UnwrapErrOk
  %45 = load i1, i1* %exact, align 1
  switch i1 %45, label %SwitchElse [
    i1 false, label %SwitchProng
    i1 true, label %SwitchProng4
  ]

SwitchProng:                                      ; preds = %UnwrapErrEnd
  store i29 0, i29* %len_align, align 4
  br label %SwitchEnd

SwitchProng4:                                     ; preds = %UnwrapErrEnd
  store i29 1, i29* %len_align, align 4
  br label %SwitchEnd

SwitchElse:                                       ; preds = %UnwrapErrEnd
  unreachable

SwitchEnd:                                        ; preds = %SwitchProng4, %SwitchProng
  %46 = getelementptr inbounds %"[]u8", %"[]u8"* %old_byte_slice, i32 0, i32 0
  %47 = load i8*, i8** %46, align 8
  %48 = ptrtoint i8* %47 to i64
  %49 = call fastcc i1 @std.mem.isAligned(i64 %48, i64 1)
  br i1 %49, label %Then5, label %Else9

Then5:                                            ; preds = %SwitchEnd
  %50 = load i64, i64* %byte_count, align 8
  %51 = getelementptr inbounds %"[]u8", %"[]u8"* %old_byte_slice, i32 0, i32 1
  %52 = load i64, i64* %51, align 8
  %53 = icmp ule i64 %50, %52
  br i1 %53, label %Then6, label %Else7

Then6:                                            ; preds = %Then5
  %54 = load i64, i64* %byte_count, align 8
  %55 = load i29, i29* %len_align, align 4
  %56 = load i64, i64* %return_address, align 8
  %57 = call fastcc i64 @std.mem.Allocator.shrinkBytes(%std.mem.Allocator* %1, %"[]u8"* %old_byte_slice, i29 1, i64 %54, i29 %55, i64 %56)
  store i64 %57, i64* %shrunk_len, align 8
  %58 = getelementptr inbounds %"[]u8", %"[]u8"* %old_byte_slice, i32 0, i32 0
  %59 = load i64, i64* %shrunk_len, align 8
  %60 = load i8*, i8** %58, align 8
  %61 = getelementptr inbounds i8, i8* %60, i64 0
  %62 = sub nuw i64 %59, 0
  %63 = getelementptr inbounds %"[]u8", %"[]u8"* %13, i32 0, i32 0
  store i8* %61, i8** %63, align 8
  %64 = getelementptr inbounds %"[]u8", %"[]u8"* %13, i32 0, i32 1
  store i64 %62, i64* %64, align 8
  %65 = bitcast %"[]u8"* %13 to i8*
  %66 = bitcast %"[]u8"* %14 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %66, i8* align 8 %65, i64 16, i1 false)
  %67 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %0, i32 0, i32 1
  store i16 0, i16* %67, align 2
  %68 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %0, i32 0, i32 0
  call fastcc void @std.mem.bytesAsSlice.84(%"[]u8"* sret(%"[]u8") %68, %"[]u8"* %13)
  ret void

Else7:                                            ; preds = %Then5
  br label %EndIf8

EndIf8:                                           ; preds = %Else7
  %69 = load i64, i64* %byte_count, align 8
  %70 = load i29, i29* %len_align, align 4
  %71 = load i64, i64* %return_address, align 8
  call fastcc void @std.mem.Allocator.rawResize(%"?usize"* sret(%"?usize") %15, %std.mem.Allocator* %1, %"[]u8"* %old_byte_slice, i29 1, i64 %69, i29 %70, i64 %71)
  %72 = getelementptr inbounds %"?usize", %"?usize"* %15, i32 0, i32 1
  %73 = load i1, i1* %72, align 1
  br i1 %73, label %OptionalThen, label %OptionalElse

OptionalThen:                                     ; preds = %EndIf8
  %74 = getelementptr inbounds %"?usize", %"?usize"* %15, i32 0, i32 0
  %75 = load i64, i64* %74, align 8
  store i64 %75, i64* %resized_len, align 8
  %76 = getelementptr inbounds %"[]u8", %"[]u8"* %old_byte_slice, i32 0, i32 0
  %77 = load i8*, i8** %76, align 8
  %78 = load i64, i64* %byte_count, align 8
  %79 = getelementptr inbounds i8, i8* %77, i64 %78
  %80 = load i64, i64* %resized_len, align 8
  %81 = load i64, i64* %byte_count, align 8
  %82 = sub nuw i64 %80, %81
  %83 = getelementptr inbounds %"[]u8", %"[]u8"* %old_byte_slice, i32 0, i32 0
  %84 = load i64, i64* %resized_len, align 8
  %85 = load i8*, i8** %83, align 8
  %86 = getelementptr inbounds i8, i8* %85, i64 0
  %87 = sub nuw i64 %84, 0
  %88 = getelementptr inbounds %"[]u8", %"[]u8"* %16, i32 0, i32 0
  store i8* %86, i8** %88, align 8
  %89 = getelementptr inbounds %"[]u8", %"[]u8"* %16, i32 0, i32 1
  store i64 %87, i64* %89, align 8
  %90 = bitcast %"[]u8"* %16 to i8*
  %91 = bitcast %"[]u8"* %17 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %91, i8* align 8 %90, i64 16, i1 false)
  %92 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %0, i32 0, i32 1
  store i16 0, i16* %92, align 2
  %93 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %0, i32 0, i32 0
  call fastcc void @std.mem.bytesAsSlice.84(%"[]u8"* sret(%"[]u8") %93, %"[]u8"* %16)
  ret void

OptionalElse:                                     ; preds = %EndIf8
  br label %OptionalEndIf

OptionalEndIf:                                    ; preds = %OptionalElse
  br label %EndIf10

Else9:                                            ; preds = %SwitchEnd
  br label %EndIf10

EndIf10:                                          ; preds = %Else9, %OptionalEndIf
  %94 = load i64, i64* %byte_count, align 8
  %95 = getelementptr inbounds %"[]u8", %"[]u8"* %old_byte_slice, i32 0, i32 1
  %96 = load i64, i64* %95, align 8
  %97 = icmp ule i64 %94, %96
  br i1 %97, label %BoolAndTrue, label %BoolAndFalse

BoolAndTrue:                                      ; preds = %EndIf10
  br label %BoolAndFalse

BoolAndFalse:                                     ; preds = %BoolAndTrue, %EndIf10
  %98 = phi i1 [ %97, %EndIf10 ], [ true, %BoolAndTrue ]
  br i1 %98, label %Then11, label %Else12

Then11:                                           ; preds = %BoolAndFalse
  %99 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %0, i32 0, i32 1
  store i16 16, i16* %99, align 2
  ret void

Else12:                                           ; preds = %BoolAndFalse
  br label %EndIf13

EndIf13:                                          ; preds = %Else12
  %100 = load i64, i64* %byte_count, align 8
  %101 = load i29, i29* %len_align, align 4
  %102 = load i64, i64* %return_address, align 8
  call fastcc void @std.mem.Allocator.rawAlloc({ %"[]u8", i16 }* sret({ %"[]u8", i16 }) %18, %std.mem.Allocator* %1, i64 %100, i29 1, i29 %101, i64 %102)
  %103 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %18, i32 0, i32 1
  %104 = load i16, i16* %103, align 2
  %105 = icmp ne i16 %104, 0
  br i1 %105, label %ErrRetReturn, label %ErrRetContinue

ErrRetReturn:                                     ; preds = %EndIf13
  %106 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %18, i32 0, i32 1
  %107 = load i16, i16* %106, align 2
  %108 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %0, i32 0, i32 1
  store i16 %107, i16* %108, align 2
  %109 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %19, i32 0, i32 1
  store i16 %107, i16* %109, align 2
  ret void

ErrRetContinue:                                   ; preds = %EndIf13
  %110 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %18, i32 0, i32 0
  %111 = bitcast %"[]u8"* %110 to i8*
  %112 = bitcast %"[]u8"* %new_mem to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %112, i8* align 8 %111, i64 16, i1 false)
  %113 = getelementptr inbounds %"[]u8", %"[]u8"* %new_mem, i32 0, i32 0
  %114 = load i8*, i8** %113, align 8
  %115 = getelementptr inbounds %"[]u8", %"[]u8"* %old_byte_slice, i32 0, i32 0
  %116 = load i8*, i8** %115, align 8
  %117 = load i64, i64* %byte_count, align 8
  store i64 %117, i64* %20, align 8
  %118 = getelementptr inbounds %"[]u8", %"[]u8"* %old_byte_slice, i32 0, i32 1
  %119 = load i64, i64* %118, align 8
  store i64 %119, i64* %21, align 8
  %120 = call fastcc i64 @std.math.min.30(i64 %117, i64 %119)
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %114, i8* align 1 %116, i64 %120, i1 false)
  %121 = getelementptr inbounds %"[]u8", %"[]u8"* %old_byte_slice, i32 0, i32 0
  %122 = load i8*, i8** %121, align 8
  %123 = getelementptr inbounds %"[]u8", %"[]u8"* %old_byte_slice, i32 0, i32 1
  %124 = load i64, i64* %123, align 8
  %125 = load i64, i64* %return_address, align 8
  call fastcc void @std.mem.Allocator.rawFree(%std.mem.Allocator* %1, %"[]u8"* %old_byte_slice, i29 1, i64 %125)
  %126 = bitcast %"[]u8"* %new_mem to i8*
  %127 = bitcast %"[]u8"* %22 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %127, i8* align 8 %126, i64 16, i1 false)
  %128 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %0, i32 0, i32 1
  store i16 0, i16* %128, align 2
  %129 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %0, i32 0, i32 0
  call fastcc void @std.mem.bytesAsSlice.84(%"[]u8"* sret(%"[]u8") %129, %"[]u8"* %new_mem)
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.mem.sliceAsBytes(%"[]u8"* nonnull sret(%"[]u8") %0, %"[]u8"* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %2 = alloca i8*, align 8
  %3 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 1
  %4 = load i64, i64* %3, align 8
  %5 = icmp eq i64 %4, 0
  br i1 %5, label %BoolAndTrue, label %BoolAndFalse

BoolAndTrue:                                      ; preds = %Entry
  br label %BoolAndFalse

BoolAndFalse:                                     ; preds = %BoolAndTrue, %Entry
  %6 = phi i1 [ %5, %Entry ], [ false, %BoolAndTrue ]
  br i1 %6, label %Then, label %Else

Then:                                             ; preds = %BoolAndFalse
  %7 = bitcast %"[]u8"* %0 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %7, i8* align 8 bitcast (%"[]u8"* @132 to i8*), i64 16, i1 false)
  ret void

Else:                                             ; preds = %BoolAndFalse
  br label %EndIf

EndIf:                                            ; preds = %Else
  %8 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 0
  %9 = load i8*, i8** %8, align 8
  store i8* %9, i8** %2, align 8
  %10 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 1
  %11 = load i64, i64* %10, align 8
  %12 = mul nuw i64 %11, 1
  %13 = load i8*, i8** %2, align 8
  %14 = getelementptr inbounds i8, i8* %13, i64 0
  %15 = sub nuw i64 %12, 0
  %16 = getelementptr inbounds %"[]u8", %"[]u8"* %0, i32 0, i32 0
  store i8* %14, i8** %16, align 8
  %17 = getelementptr inbounds %"[]u8", %"[]u8"* %0, i32 0, i32 1
  store i64 %15, i64* %17, align 8
  ret void
}

; Function Attrs: alwaysinline minsize nobuiltin nounwind optsize
define internal fastcc void @std.mem.Allocator.rawFree(%std.mem.Allocator* nonnull readonly align 8 %0, %"[]u8"* nonnull readonly align 8 %1, i29 %2, i64 %3) unnamed_addr #7 {
Entry:
  %buf_align = alloca i29, align 4
  %ret_addr = alloca i64, align 8
  store i29 %2, i29* %buf_align, align 4
  store i64 %3, i64* %ret_addr, align 8
  %4 = getelementptr inbounds %std.mem.Allocator, %std.mem.Allocator* %0, i32 0, i32 1
  %5 = load %std.mem.Allocator.VTable*, %std.mem.Allocator.VTable** %4, align 8
  %6 = getelementptr inbounds %std.mem.Allocator.VTable, %std.mem.Allocator.VTable* %5, i32 0, i32 2
  %7 = load void (i8*, %"[]u8"*, i29, i64)*, void (i8*, %"[]u8"*, i29, i64)** %6, align 8
  %8 = getelementptr inbounds %std.mem.Allocator, %std.mem.Allocator* %0, i32 0, i32 0
  %9 = load i8*, i8** %8, align 8
  %10 = load i29, i29* %buf_align, align 4
  %11 = load i64, i64* %ret_addr, align 8
  call fastcc void %7(i8* %9, %"[]u8"* %1, i29 %10, i64 %11)
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @"std.array_list.ArrayListAligned(usize,null).addOne"({ i64*, i16 }* nonnull sret({ i64*, i16 }) %0, %"std.array_list.ArrayListAligned(usize,null)"* nonnull align 8 %1) unnamed_addr #1 {
Entry:
  %newlen = alloca i64, align 8
  %2 = alloca i16, align 2
  %3 = alloca { i64*, i16 }, align 8
  %self = alloca %"std.array_list.ArrayListAligned(usize,null)"*, align 8
  store %"std.array_list.ArrayListAligned(usize,null)"* %1, %"std.array_list.ArrayListAligned(usize,null)"** %self, align 8
  %4 = load %"std.array_list.ArrayListAligned(usize,null)"*, %"std.array_list.ArrayListAligned(usize,null)"** %self, align 8
  %5 = getelementptr inbounds %"std.array_list.ArrayListAligned(usize,null)", %"std.array_list.ArrayListAligned(usize,null)"* %4, i32 0, i32 0
  %6 = getelementptr inbounds %"[]usize", %"[]usize"* %5, i32 0, i32 1
  %7 = load i64, i64* %6, align 8
  %8 = add nuw i64 %7, 1
  store i64 %8, i64* %newlen, align 8
  %9 = load %"std.array_list.ArrayListAligned(usize,null)"*, %"std.array_list.ArrayListAligned(usize,null)"** %self, align 8
  %10 = load i64, i64* %newlen, align 8
  %11 = call fastcc i16 @"std.array_list.ArrayListAligned(usize,null).ensureTotalCapacity"(%"std.array_list.ArrayListAligned(usize,null)"* %9, i64 %10)
  store i16 %11, i16* %2, align 2
  %12 = icmp ne i16 %11, 0
  br i1 %12, label %ErrRetReturn, label %ErrRetContinue

ErrRetReturn:                                     ; preds = %Entry
  %13 = load i16, i16* %2, align 2
  %14 = getelementptr inbounds { i64*, i16 }, { i64*, i16 }* %0, i32 0, i32 1
  store i16 %13, i16* %14, align 2
  %15 = getelementptr inbounds { i64*, i16 }, { i64*, i16 }* %3, i32 0, i32 1
  store i16 %13, i16* %15, align 2
  ret void

ErrRetContinue:                                   ; preds = %Entry
  %16 = load %"std.array_list.ArrayListAligned(usize,null)"*, %"std.array_list.ArrayListAligned(usize,null)"** %self, align 8
  %17 = call fastcc i64* @"std.array_list.ArrayListAligned(usize,null).addOneAssumeCapacity"(%"std.array_list.ArrayListAligned(usize,null)"* %16)
  %18 = getelementptr inbounds { i64*, i16 }, { i64*, i16 }* %0, i32 0, i32 1
  store i16 0, i16* %18, align 2
  %19 = getelementptr inbounds { i64*, i16 }, { i64*, i16 }* %0, i32 0, i32 0
  store i64* %17, i64** %19, align 8
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @"std.array_list.ArrayListAligned(usize,null).ensureTotalCapacity"(%"std.array_list.ArrayListAligned(usize,null)"* nonnull align 8 %0, i64 %1) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %better_capacity = alloca i64, align 8
  %self = alloca %"std.array_list.ArrayListAligned(usize,null)"*, align 8
  %new_capacity = alloca i64, align 8
  store %"std.array_list.ArrayListAligned(usize,null)"* %0, %"std.array_list.ArrayListAligned(usize,null)"** %self, align 8
  store i64 %1, i64* %new_capacity, align 8
  %2 = load %"std.array_list.ArrayListAligned(usize,null)"*, %"std.array_list.ArrayListAligned(usize,null)"** %self, align 8
  %3 = getelementptr inbounds %"std.array_list.ArrayListAligned(usize,null)", %"std.array_list.ArrayListAligned(usize,null)"* %2, i32 0, i32 1
  %4 = load i64, i64* %3, align 8
  store i64 %4, i64* %better_capacity, align 8
  %5 = load i64, i64* %better_capacity, align 8
  %6 = load i64, i64* %new_capacity, align 8
  %7 = icmp uge i64 %5, %6
  br i1 %7, label %Then, label %Else

Then:                                             ; preds = %Entry
  store i16 0, i16* %result, align 2
  %8 = load i16, i16* %result, align 2
  ret i16 %8

Else:                                             ; preds = %Entry
  br label %EndIf

EndIf:                                            ; preds = %Else
  br label %WhileCond

WhileCond:                                        ; preds = %EndIf3, %EndIf
  br label %WhileBody

WhileBody:                                        ; preds = %WhileCond
  %9 = load i64, i64* %better_capacity, align 8
  %10 = load i64, i64* %better_capacity, align 8
  %11 = udiv i64 %10, 2
  %12 = add nuw i64 %11, 8
  %13 = add nuw i64 %9, %12
  store i64 %13, i64* %better_capacity, align 8
  %14 = load i64, i64* %better_capacity, align 8
  %15 = load i64, i64* %new_capacity, align 8
  %16 = icmp uge i64 %14, %15
  br i1 %16, label %Then1, label %Else2

Then1:                                            ; preds = %WhileBody
  br label %WhileEnd

Else2:                                            ; preds = %WhileBody
  br label %EndIf3

EndIf3:                                           ; preds = %Else2
  br label %WhileCond

WhileEnd:                                         ; preds = %Then1
  %17 = load %"std.array_list.ArrayListAligned(usize,null)"*, %"std.array_list.ArrayListAligned(usize,null)"** %self, align 8
  %18 = load i64, i64* %better_capacity, align 8
  %19 = call fastcc i16 @"std.array_list.ArrayListAligned(usize,null).ensureTotalCapacityPrecise"(%"std.array_list.ArrayListAligned(usize,null)"* %17, i64 %18)
  store i16 %19, i16* %result, align 2
  %20 = load i16, i16* %result, align 2
  ret i16 %20
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc nonnull i64* @"std.array_list.ArrayListAligned(usize,null).addOneAssumeCapacity"(%"std.array_list.ArrayListAligned(usize,null)"* nonnull align 8 %0) unnamed_addr #1 {
Entry:
  %result = alloca i64*, align 8
  %self = alloca %"std.array_list.ArrayListAligned(usize,null)"*, align 8
  store %"std.array_list.ArrayListAligned(usize,null)"* %0, %"std.array_list.ArrayListAligned(usize,null)"** %self, align 8
  %1 = load %"std.array_list.ArrayListAligned(usize,null)"*, %"std.array_list.ArrayListAligned(usize,null)"** %self, align 8
  %2 = getelementptr inbounds %"std.array_list.ArrayListAligned(usize,null)", %"std.array_list.ArrayListAligned(usize,null)"* %1, i32 0, i32 0
  %3 = getelementptr inbounds %"[]usize", %"[]usize"* %2, i32 0, i32 1
  %4 = load i64, i64* %3, align 8
  %5 = load %"std.array_list.ArrayListAligned(usize,null)"*, %"std.array_list.ArrayListAligned(usize,null)"** %self, align 8
  %6 = getelementptr inbounds %"std.array_list.ArrayListAligned(usize,null)", %"std.array_list.ArrayListAligned(usize,null)"* %5, i32 0, i32 1
  %7 = load i64, i64* %6, align 8
  %8 = icmp ult i64 %4, %7
  call fastcc void @std.debug.assert(i1 %8)
  %9 = load %"std.array_list.ArrayListAligned(usize,null)"*, %"std.array_list.ArrayListAligned(usize,null)"** %self, align 8
  %10 = getelementptr inbounds %"std.array_list.ArrayListAligned(usize,null)", %"std.array_list.ArrayListAligned(usize,null)"* %9, i32 0, i32 0
  %11 = getelementptr inbounds %"[]usize", %"[]usize"* %10, i32 0, i32 1
  %12 = load i64, i64* %11, align 8
  %13 = add nuw i64 %12, 1
  store i64 %13, i64* %11, align 8
  %14 = load %"std.array_list.ArrayListAligned(usize,null)"*, %"std.array_list.ArrayListAligned(usize,null)"** %self, align 8
  %15 = getelementptr inbounds %"std.array_list.ArrayListAligned(usize,null)", %"std.array_list.ArrayListAligned(usize,null)"* %14, i32 0, i32 0
  %16 = load %"std.array_list.ArrayListAligned(usize,null)"*, %"std.array_list.ArrayListAligned(usize,null)"** %self, align 8
  %17 = getelementptr inbounds %"std.array_list.ArrayListAligned(usize,null)", %"std.array_list.ArrayListAligned(usize,null)"* %16, i32 0, i32 0
  %18 = getelementptr inbounds %"[]usize", %"[]usize"* %17, i32 0, i32 1
  %19 = load i64, i64* %18, align 8
  %20 = sub nuw i64 %19, 1
  %21 = getelementptr inbounds %"[]usize", %"[]usize"* %15, i32 0, i32 0
  %22 = load i64*, i64** %21, align 8
  %23 = getelementptr inbounds i64, i64* %22, i64 %20
  store i64* %23, i64** %result, align 8
  %24 = load i64*, i64** %result, align 8
  ret i64* %24
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @"std.array_list.ArrayListAligned(usize,null).ensureTotalCapacityPrecise"(%"std.array_list.ArrayListAligned(usize,null)"* nonnull align 8 %0, i64 %1) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %2 = alloca %"[]usize", align 8
  %3 = alloca i64, align 8
  %4 = alloca { %"[]usize", i16 }, align 8
  %new_memory = alloca %"[]usize", align 8
  %self = alloca %"std.array_list.ArrayListAligned(usize,null)"*, align 8
  %new_capacity = alloca i64, align 8
  store %"std.array_list.ArrayListAligned(usize,null)"* %0, %"std.array_list.ArrayListAligned(usize,null)"** %self, align 8
  store i64 %1, i64* %new_capacity, align 8
  %5 = load %"std.array_list.ArrayListAligned(usize,null)"*, %"std.array_list.ArrayListAligned(usize,null)"** %self, align 8
  %6 = getelementptr inbounds %"std.array_list.ArrayListAligned(usize,null)", %"std.array_list.ArrayListAligned(usize,null)"* %5, i32 0, i32 1
  %7 = load i64, i64* %6, align 8
  %8 = load i64, i64* %new_capacity, align 8
  %9 = icmp uge i64 %7, %8
  br i1 %9, label %Then, label %Else

Then:                                             ; preds = %Entry
  store i16 0, i16* %result, align 2
  %10 = load i16, i16* %result, align 2
  ret i16 %10

Else:                                             ; preds = %Entry
  br label %EndIf

EndIf:                                            ; preds = %Else
  %11 = load %"std.array_list.ArrayListAligned(usize,null)"*, %"std.array_list.ArrayListAligned(usize,null)"** %self, align 8
  %12 = getelementptr inbounds %"std.array_list.ArrayListAligned(usize,null)", %"std.array_list.ArrayListAligned(usize,null)"* %11, i32 0, i32 2
  %13 = load %"std.array_list.ArrayListAligned(usize,null)"*, %"std.array_list.ArrayListAligned(usize,null)"** %self, align 8
  call fastcc void @"std.array_list.ArrayListAligned(usize,null).allocatedSlice"(%"[]usize"* sret(%"[]usize") %2, %"std.array_list.ArrayListAligned(usize,null)"* %13)
  %14 = load i64, i64* %new_capacity, align 8
  store i64 %14, i64* %3, align 8
  call fastcc void @std.mem.Allocator.reallocAtLeast.56({ %"[]usize", i16 }* sret({ %"[]usize", i16 }) %4, %std.mem.Allocator* %12, %"[]usize"* %2, i64 %14)
  %15 = getelementptr inbounds { %"[]usize", i16 }, { %"[]usize", i16 }* %4, i32 0, i32 1
  %16 = load i16, i16* %15, align 2
  %17 = icmp ne i16 %16, 0
  br i1 %17, label %ErrRetReturn, label %ErrRetContinue

ErrRetReturn:                                     ; preds = %EndIf
  %18 = getelementptr inbounds { %"[]usize", i16 }, { %"[]usize", i16 }* %4, i32 0, i32 1
  %19 = load i16, i16* %18, align 2
  store i16 %19, i16* %result, align 2
  ret i16 %19

ErrRetContinue:                                   ; preds = %EndIf
  %20 = getelementptr inbounds { %"[]usize", i16 }, { %"[]usize", i16 }* %4, i32 0, i32 0
  %21 = bitcast %"[]usize"* %20 to i8*
  %22 = bitcast %"[]usize"* %new_memory to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %22, i8* align 8 %21, i64 16, i1 false)
  %23 = load %"std.array_list.ArrayListAligned(usize,null)"*, %"std.array_list.ArrayListAligned(usize,null)"** %self, align 8
  %24 = getelementptr inbounds %"std.array_list.ArrayListAligned(usize,null)", %"std.array_list.ArrayListAligned(usize,null)"* %23, i32 0, i32 0
  %25 = getelementptr inbounds %"[]usize", %"[]usize"* %24, i32 0, i32 0
  %26 = getelementptr inbounds %"[]usize", %"[]usize"* %new_memory, i32 0, i32 0
  %27 = load i64*, i64** %26, align 8
  store i64* %27, i64** %25, align 8
  %28 = load %"std.array_list.ArrayListAligned(usize,null)"*, %"std.array_list.ArrayListAligned(usize,null)"** %self, align 8
  %29 = getelementptr inbounds %"std.array_list.ArrayListAligned(usize,null)", %"std.array_list.ArrayListAligned(usize,null)"* %28, i32 0, i32 1
  %30 = getelementptr inbounds %"[]usize", %"[]usize"* %new_memory, i32 0, i32 1
  %31 = load i64, i64* %30, align 8
  store i64 %31, i64* %29, align 8
  store i16 0, i16* %result, align 2
  ret i16 0
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.mem.Allocator.reallocAtLeast.56({ %"[]usize", i16 }* nonnull sret({ %"[]usize", i16 }) %0, %std.mem.Allocator* nonnull readonly align 8 %1, %"[]usize"* nonnull readonly align 8 %2, i64 %3) unnamed_addr #1 {
Entry:
  %4 = alloca %"[]usize", align 8
  %5 = alloca i64, align 8
  %6 = alloca i64, align 8
  %new_n = alloca i64, align 8
  store i64 %3, i64* %new_n, align 8
  %7 = bitcast %"[]usize"* %2 to i8*
  %8 = bitcast %"[]usize"* %4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %8, i8* align 8 %7, i64 16, i1 false)
  %9 = load i64, i64* %new_n, align 8
  store i64 %9, i64* %5, align 8
  %10 = call i8* @llvm.returnaddress(i32 0)
  %11 = ptrtoint i8* %10 to i64
  store i64 %11, i64* %6, align 8
  call fastcc void @std.mem.Allocator.reallocAdvancedWithRetAddr.57({ %"[]usize", i16 }* sret({ %"[]usize", i16 }) %0, %std.mem.Allocator* %1, %"[]usize"* %2, i64 %9, i1 true, i64 %11)
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.mem.Allocator.reallocAdvancedWithRetAddr.57({ %"[]usize", i16 }* nonnull sret({ %"[]usize", i16 }) %0, %std.mem.Allocator* nonnull readonly align 8 %1, %"[]usize"* nonnull readonly align 8 %2, i64 %3, i1 %4, i64 %5) unnamed_addr #1 {
Entry:
  %6 = alloca i64, align 8
  %7 = alloca i1, align 1
  %8 = alloca i64, align 8
  %9 = alloca %"[]usize", align 8
  %10 = alloca %"[]usize", align 8
  %old_byte_slice = alloca %"[]u8", align 8
  %11 = alloca i64, align 8
  %12 = alloca { i64, i16 }, align 8
  %byte_count = alloca i64, align 8
  %len_align = alloca i29, align 4
  %shrunk_len = alloca i64, align 8
  %13 = alloca %"[]u8", align 8
  %14 = alloca %"[]u8", align 8
  %15 = alloca %"?usize", align 8
  %resized_len = alloca i64, align 8
  %16 = alloca %"[]u8", align 8
  %17 = alloca %"[]u8", align 8
  %18 = alloca { %"[]u8", i16 }, align 8
  %19 = alloca { %"[]usize", i16 }, align 8
  %new_mem = alloca %"[]u8", align 8
  %20 = alloca i64, align 8
  %21 = alloca i64, align 8
  %22 = alloca %"[]u8", align 8
  %new_n = alloca i64, align 8
  %exact = alloca i1, align 1
  %return_address = alloca i64, align 8
  store i64 %3, i64* %new_n, align 8
  store i1 %4, i1* %exact, align 1
  store i64 %5, i64* %return_address, align 8
  %23 = getelementptr inbounds %"[]usize", %"[]usize"* %2, i32 0, i32 1
  %24 = load i64, i64* %23, align 8
  %25 = icmp eq i64 %24, 0
  br i1 %25, label %Then, label %Else

Then:                                             ; preds = %Entry
  %26 = load i64, i64* %new_n, align 8
  store i64 %26, i64* %6, align 8
  %27 = load i1, i1* %exact, align 1
  store i1 %27, i1* %7, align 1
  %28 = load i64, i64* %return_address, align 8
  store i64 %28, i64* %8, align 8
  call fastcc void @std.mem.Allocator.allocAdvancedWithRetAddr.85({ %"[]usize", i16 }* sret({ %"[]usize", i16 }) %0, %std.mem.Allocator* %1, i64 %26, i1 %27, i64 %28)
  ret void

Else:                                             ; preds = %Entry
  br label %EndIf

EndIf:                                            ; preds = %Else
  %29 = load i64, i64* %new_n, align 8
  %30 = icmp eq i64 %29, 0
  br i1 %30, label %Then1, label %Else2

Then1:                                            ; preds = %EndIf
  %31 = bitcast %"[]usize"* %2 to i8*
  %32 = bitcast %"[]usize"* %9 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %32, i8* align 8 %31, i64 16, i1 false)
  call fastcc void @std.mem.Allocator.free.54(%std.mem.Allocator* %1, %"[]usize"* %2)
  %33 = getelementptr inbounds { %"[]usize", i16 }, { %"[]usize", i16 }* %0, i32 0, i32 1
  store i16 0, i16* %33, align 2
  %34 = getelementptr inbounds { %"[]usize", i16 }, { %"[]usize", i16 }* %0, i32 0, i32 0
  %35 = bitcast %"[]usize"* %34 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %35, i8* align 8 bitcast (%"[]usize"* @133 to i8*), i64 16, i1 false)
  ret void

Else2:                                            ; preds = %EndIf
  br label %EndIf3

EndIf3:                                           ; preds = %Else2
  %36 = bitcast %"[]usize"* %2 to i8*
  %37 = bitcast %"[]usize"* %10 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %37, i8* align 8 %36, i64 16, i1 false)
  call fastcc void @std.mem.sliceAsBytes.81(%"[]u8"* sret(%"[]u8") %old_byte_slice, %"[]usize"* %2)
  %38 = load i64, i64* %new_n, align 8
  store i64 %38, i64* %11, align 8
  call fastcc void @std.math.mul({ i64, i16 }* sret({ i64, i16 }) %12, i64 8, i64 %38)
  %39 = getelementptr inbounds { i64, i16 }, { i64, i16 }* %12, i32 0, i32 1
  %40 = load i16, i16* %39, align 2
  %41 = icmp ne i16 %40, 0
  br i1 %41, label %UnwrapErrError, label %UnwrapErrOk

UnwrapErrError:                                   ; preds = %EndIf3
  %42 = getelementptr inbounds { %"[]usize", i16 }, { %"[]usize", i16 }* %0, i32 0, i32 1
  store i16 16, i16* %42, align 2
  ret void

UnwrapErrOk:                                      ; preds = %EndIf3
  %43 = getelementptr inbounds { i64, i16 }, { i64, i16 }* %12, i32 0, i32 0
  %44 = load i64, i64* %43, align 8
  store i64 %44, i64* %byte_count, align 8
  br label %UnwrapErrEnd

UnwrapErrEnd:                                     ; preds = %UnwrapErrOk
  %45 = load i1, i1* %exact, align 1
  switch i1 %45, label %SwitchElse [
    i1 false, label %SwitchProng
    i1 true, label %SwitchProng4
  ]

SwitchProng:                                      ; preds = %UnwrapErrEnd
  store i29 0, i29* %len_align, align 4
  br label %SwitchEnd

SwitchProng4:                                     ; preds = %UnwrapErrEnd
  store i29 8, i29* %len_align, align 4
  br label %SwitchEnd

SwitchElse:                                       ; preds = %UnwrapErrEnd
  unreachable

SwitchEnd:                                        ; preds = %SwitchProng4, %SwitchProng
  %46 = getelementptr inbounds %"[]u8", %"[]u8"* %old_byte_slice, i32 0, i32 0
  %47 = load i8*, i8** %46, align 8
  %48 = ptrtoint i8* %47 to i64
  %49 = call fastcc i1 @std.mem.isAligned(i64 %48, i64 8)
  br i1 %49, label %Then5, label %Else9

Then5:                                            ; preds = %SwitchEnd
  %50 = load i64, i64* %byte_count, align 8
  %51 = getelementptr inbounds %"[]u8", %"[]u8"* %old_byte_slice, i32 0, i32 1
  %52 = load i64, i64* %51, align 8
  %53 = icmp ule i64 %50, %52
  br i1 %53, label %Then6, label %Else7

Then6:                                            ; preds = %Then5
  %54 = load i64, i64* %byte_count, align 8
  %55 = load i29, i29* %len_align, align 4
  %56 = load i64, i64* %return_address, align 8
  %57 = call fastcc i64 @std.mem.Allocator.shrinkBytes(%std.mem.Allocator* %1, %"[]u8"* %old_byte_slice, i29 8, i64 %54, i29 %55, i64 %56)
  store i64 %57, i64* %shrunk_len, align 8
  %58 = getelementptr inbounds %"[]u8", %"[]u8"* %old_byte_slice, i32 0, i32 0
  %59 = load i64, i64* %shrunk_len, align 8
  %60 = load i8*, i8** %58, align 8
  %61 = getelementptr inbounds i8, i8* %60, i64 0
  %62 = sub nuw i64 %59, 0
  %63 = getelementptr inbounds %"[]u8", %"[]u8"* %13, i32 0, i32 0
  store i8* %61, i8** %63, align 8
  %64 = getelementptr inbounds %"[]u8", %"[]u8"* %13, i32 0, i32 1
  store i64 %62, i64* %64, align 8
  %65 = bitcast %"[]u8"* %13 to i8*
  %66 = bitcast %"[]u8"* %14 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %66, i8* align 8 %65, i64 16, i1 false)
  %67 = getelementptr inbounds { %"[]usize", i16 }, { %"[]usize", i16 }* %0, i32 0, i32 1
  store i16 0, i16* %67, align 2
  %68 = getelementptr inbounds { %"[]usize", i16 }, { %"[]usize", i16 }* %0, i32 0, i32 0
  call fastcc void @std.mem.bytesAsSlice.86(%"[]usize"* sret(%"[]usize") %68, %"[]u8"* %13)
  ret void

Else7:                                            ; preds = %Then5
  br label %EndIf8

EndIf8:                                           ; preds = %Else7
  %69 = load i64, i64* %byte_count, align 8
  %70 = load i29, i29* %len_align, align 4
  %71 = load i64, i64* %return_address, align 8
  call fastcc void @std.mem.Allocator.rawResize(%"?usize"* sret(%"?usize") %15, %std.mem.Allocator* %1, %"[]u8"* %old_byte_slice, i29 8, i64 %69, i29 %70, i64 %71)
  %72 = getelementptr inbounds %"?usize", %"?usize"* %15, i32 0, i32 1
  %73 = load i1, i1* %72, align 1
  br i1 %73, label %OptionalThen, label %OptionalElse

OptionalThen:                                     ; preds = %EndIf8
  %74 = getelementptr inbounds %"?usize", %"?usize"* %15, i32 0, i32 0
  %75 = load i64, i64* %74, align 8
  store i64 %75, i64* %resized_len, align 8
  %76 = getelementptr inbounds %"[]u8", %"[]u8"* %old_byte_slice, i32 0, i32 0
  %77 = load i8*, i8** %76, align 8
  %78 = load i64, i64* %byte_count, align 8
  %79 = getelementptr inbounds i8, i8* %77, i64 %78
  %80 = load i64, i64* %resized_len, align 8
  %81 = load i64, i64* %byte_count, align 8
  %82 = sub nuw i64 %80, %81
  %83 = getelementptr inbounds %"[]u8", %"[]u8"* %old_byte_slice, i32 0, i32 0
  %84 = load i64, i64* %resized_len, align 8
  %85 = load i8*, i8** %83, align 8
  %86 = getelementptr inbounds i8, i8* %85, i64 0
  %87 = sub nuw i64 %84, 0
  %88 = getelementptr inbounds %"[]u8", %"[]u8"* %16, i32 0, i32 0
  store i8* %86, i8** %88, align 8
  %89 = getelementptr inbounds %"[]u8", %"[]u8"* %16, i32 0, i32 1
  store i64 %87, i64* %89, align 8
  %90 = bitcast %"[]u8"* %16 to i8*
  %91 = bitcast %"[]u8"* %17 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %91, i8* align 8 %90, i64 16, i1 false)
  %92 = getelementptr inbounds { %"[]usize", i16 }, { %"[]usize", i16 }* %0, i32 0, i32 1
  store i16 0, i16* %92, align 2
  %93 = getelementptr inbounds { %"[]usize", i16 }, { %"[]usize", i16 }* %0, i32 0, i32 0
  call fastcc void @std.mem.bytesAsSlice.86(%"[]usize"* sret(%"[]usize") %93, %"[]u8"* %16)
  ret void

OptionalElse:                                     ; preds = %EndIf8
  br label %OptionalEndIf

OptionalEndIf:                                    ; preds = %OptionalElse
  br label %EndIf10

Else9:                                            ; preds = %SwitchEnd
  br label %EndIf10

EndIf10:                                          ; preds = %Else9, %OptionalEndIf
  %94 = load i64, i64* %byte_count, align 8
  %95 = getelementptr inbounds %"[]u8", %"[]u8"* %old_byte_slice, i32 0, i32 1
  %96 = load i64, i64* %95, align 8
  %97 = icmp ule i64 %94, %96
  br i1 %97, label %BoolAndTrue, label %BoolAndFalse

BoolAndTrue:                                      ; preds = %EndIf10
  br label %BoolAndFalse

BoolAndFalse:                                     ; preds = %BoolAndTrue, %EndIf10
  %98 = phi i1 [ %97, %EndIf10 ], [ true, %BoolAndTrue ]
  br i1 %98, label %Then11, label %Else12

Then11:                                           ; preds = %BoolAndFalse
  %99 = getelementptr inbounds { %"[]usize", i16 }, { %"[]usize", i16 }* %0, i32 0, i32 1
  store i16 16, i16* %99, align 2
  ret void

Else12:                                           ; preds = %BoolAndFalse
  br label %EndIf13

EndIf13:                                          ; preds = %Else12
  %100 = load i64, i64* %byte_count, align 8
  %101 = load i29, i29* %len_align, align 4
  %102 = load i64, i64* %return_address, align 8
  call fastcc void @std.mem.Allocator.rawAlloc({ %"[]u8", i16 }* sret({ %"[]u8", i16 }) %18, %std.mem.Allocator* %1, i64 %100, i29 8, i29 %101, i64 %102)
  %103 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %18, i32 0, i32 1
  %104 = load i16, i16* %103, align 2
  %105 = icmp ne i16 %104, 0
  br i1 %105, label %ErrRetReturn, label %ErrRetContinue

ErrRetReturn:                                     ; preds = %EndIf13
  %106 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %18, i32 0, i32 1
  %107 = load i16, i16* %106, align 2
  %108 = getelementptr inbounds { %"[]usize", i16 }, { %"[]usize", i16 }* %0, i32 0, i32 1
  store i16 %107, i16* %108, align 2
  %109 = getelementptr inbounds { %"[]usize", i16 }, { %"[]usize", i16 }* %19, i32 0, i32 1
  store i16 %107, i16* %109, align 2
  ret void

ErrRetContinue:                                   ; preds = %EndIf13
  %110 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %18, i32 0, i32 0
  %111 = bitcast %"[]u8"* %110 to i8*
  %112 = bitcast %"[]u8"* %new_mem to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %112, i8* align 8 %111, i64 16, i1 false)
  %113 = getelementptr inbounds %"[]u8", %"[]u8"* %new_mem, i32 0, i32 0
  %114 = load i8*, i8** %113, align 8
  %115 = getelementptr inbounds %"[]u8", %"[]u8"* %old_byte_slice, i32 0, i32 0
  %116 = load i8*, i8** %115, align 8
  %117 = load i64, i64* %byte_count, align 8
  store i64 %117, i64* %20, align 8
  %118 = getelementptr inbounds %"[]u8", %"[]u8"* %old_byte_slice, i32 0, i32 1
  %119 = load i64, i64* %118, align 8
  store i64 %119, i64* %21, align 8
  %120 = call fastcc i64 @std.math.min.30(i64 %117, i64 %119)
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %114, i8* align 8 %116, i64 %120, i1 false)
  %121 = getelementptr inbounds %"[]u8", %"[]u8"* %old_byte_slice, i32 0, i32 0
  %122 = load i8*, i8** %121, align 8
  %123 = getelementptr inbounds %"[]u8", %"[]u8"* %old_byte_slice, i32 0, i32 1
  %124 = load i64, i64* %123, align 8
  %125 = load i64, i64* %return_address, align 8
  call fastcc void @std.mem.Allocator.rawFree(%std.mem.Allocator* %1, %"[]u8"* %old_byte_slice, i29 8, i64 %125)
  %126 = bitcast %"[]u8"* %new_mem to i8*
  %127 = bitcast %"[]u8"* %22 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %127, i8* align 8 %126, i64 16, i1 false)
  %128 = getelementptr inbounds { %"[]usize", i16 }, { %"[]usize", i16 }* %0, i32 0, i32 1
  store i16 0, i16* %128, align 2
  %129 = getelementptr inbounds { %"[]usize", i16 }, { %"[]usize", i16 }* %0, i32 0, i32 0
  call fastcc void @std.mem.bytesAsSlice.86(%"[]usize"* sret(%"[]usize") %129, %"[]u8"* %new_mem)
  ret void
}

; Function Attrs: nofree nosync nounwind readnone speculatable willreturn
declare { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %0, i64 %1) #9

; Function Attrs: nofree nosync nounwind readnone speculatable willreturn
declare { i64, i1 } @llvm.umul.with.overflow.i64(i64 %0, i64 %1) #9

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.mem.Allocator.allocAdvancedWithRetAddr({ %"[]u8", i16 }* nonnull sret({ %"[]u8", i16 }) %0, %std.mem.Allocator* nonnull readonly align 8 %1, i64 %2, i1 %3, i64 %4) unnamed_addr #1 {
Entry:
  %5 = alloca i64, align 8
  %6 = alloca { i64, i16 }, align 8
  %byte_count = alloca i64, align 8
  %len_align = alloca i29, align 4
  %7 = alloca { %"[]u8", i16 }, align 8
  %8 = alloca { %"[]u8", i16 }, align 8
  %byte_slice = alloca %"[]u8", align 8
  %9 = alloca %"[]u8", align 8
  %n = alloca i64, align 8
  %exact = alloca i1, align 1
  %return_address = alloca i64, align 8
  store i64 %2, i64* %n, align 8
  store i1 %3, i1* %exact, align 1
  store i64 %4, i64* %return_address, align 8
  br label %BlockEnd

BlockEnd:                                         ; preds = %Entry
  %10 = load i64, i64* %n, align 8
  %11 = icmp eq i64 %10, 0
  br i1 %11, label %Then, label %Else

Then:                                             ; preds = %BlockEnd
  %12 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %0, i32 0, i32 1
  store i16 0, i16* %12, align 2
  %13 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %0, i32 0, i32 0
  %14 = bitcast %"[]u8"* %13 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %14, i8* align 8 bitcast (%"[]u8"* @135 to i8*), i64 16, i1 false)
  ret void

Else:                                             ; preds = %BlockEnd
  br label %EndIf

EndIf:                                            ; preds = %Else
  %15 = load i64, i64* %n, align 8
  store i64 %15, i64* %5, align 8
  call fastcc void @std.math.mul({ i64, i16 }* sret({ i64, i16 }) %6, i64 1, i64 %15)
  %16 = getelementptr inbounds { i64, i16 }, { i64, i16 }* %6, i32 0, i32 1
  %17 = load i16, i16* %16, align 2
  %18 = icmp ne i16 %17, 0
  br i1 %18, label %UnwrapErrError, label %UnwrapErrOk

UnwrapErrError:                                   ; preds = %EndIf
  %19 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %0, i32 0, i32 1
  store i16 16, i16* %19, align 2
  ret void

UnwrapErrOk:                                      ; preds = %EndIf
  %20 = getelementptr inbounds { i64, i16 }, { i64, i16 }* %6, i32 0, i32 0
  %21 = load i64, i64* %20, align 8
  store i64 %21, i64* %byte_count, align 8
  br label %UnwrapErrEnd

UnwrapErrEnd:                                     ; preds = %UnwrapErrOk
  %22 = load i1, i1* %exact, align 1
  switch i1 %22, label %SwitchElse [
    i1 false, label %SwitchProng
    i1 true, label %SwitchProng1
  ]

SwitchProng:                                      ; preds = %UnwrapErrEnd
  store i29 0, i29* %len_align, align 4
  br label %SwitchEnd

SwitchProng1:                                     ; preds = %UnwrapErrEnd
  store i29 1, i29* %len_align, align 4
  br label %SwitchEnd

SwitchElse:                                       ; preds = %UnwrapErrEnd
  unreachable

SwitchEnd:                                        ; preds = %SwitchProng1, %SwitchProng
  %23 = load i64, i64* %byte_count, align 8
  %24 = load i29, i29* %len_align, align 4
  %25 = load i64, i64* %return_address, align 8
  call fastcc void @std.mem.Allocator.rawAlloc({ %"[]u8", i16 }* sret({ %"[]u8", i16 }) %7, %std.mem.Allocator* %1, i64 %23, i29 8, i29 %24, i64 %25)
  %26 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %7, i32 0, i32 1
  %27 = load i16, i16* %26, align 2
  %28 = icmp ne i16 %27, 0
  br i1 %28, label %ErrRetReturn, label %ErrRetContinue

ErrRetReturn:                                     ; preds = %SwitchEnd
  %29 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %7, i32 0, i32 1
  %30 = load i16, i16* %29, align 2
  %31 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %0, i32 0, i32 1
  store i16 %30, i16* %31, align 2
  %32 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %8, i32 0, i32 1
  store i16 %30, i16* %32, align 2
  ret void

ErrRetContinue:                                   ; preds = %SwitchEnd
  %33 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %7, i32 0, i32 0
  %34 = bitcast %"[]u8"* %33 to i8*
  %35 = bitcast %"[]u8"* %byte_slice to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %35, i8* align 8 %34, i64 16, i1 false)
  %36 = load i1, i1* %exact, align 1
  switch i1 %36, label %SwitchElse2 [
    i1 false, label %SwitchProng3
    i1 true, label %SwitchProng4
  ]

SwitchElse2:                                      ; preds = %ErrRetContinue
  unreachable

SwitchProng3:                                     ; preds = %ErrRetContinue
  %37 = getelementptr inbounds %"[]u8", %"[]u8"* %byte_slice, i32 0, i32 1
  %38 = load i64, i64* %37, align 8
  %39 = load i64, i64* %byte_count, align 8
  %40 = icmp eq i64 %38, %39
  call fastcc void @std.debug.assert(i1 %40)
  br label %SwitchEnd5

SwitchProng4:                                     ; preds = %ErrRetContinue
  %41 = getelementptr inbounds %"[]u8", %"[]u8"* %byte_slice, i32 0, i32 1
  %42 = load i64, i64* %41, align 8
  %43 = load i64, i64* %byte_count, align 8
  %44 = icmp uge i64 %42, %43
  call fastcc void @std.debug.assert(i1 %44)
  br label %SwitchEnd5

SwitchEnd5:                                       ; preds = %SwitchProng4, %SwitchProng3
  %45 = getelementptr inbounds %"[]u8", %"[]u8"* %byte_slice, i32 0, i32 0
  %46 = load i8*, i8** %45, align 8
  %47 = getelementptr inbounds %"[]u8", %"[]u8"* %byte_slice, i32 0, i32 1
  %48 = load i64, i64* %47, align 8
  %49 = bitcast %"[]u8"* %byte_slice to i8*
  %50 = bitcast %"[]u8"* %9 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %50, i8* align 8 %49, i64 16, i1 false)
  %51 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %0, i32 0, i32 1
  store i16 0, i16* %51, align 2
  %52 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %0, i32 0, i32 0
  call fastcc void @std.mem.bytesAsSlice.87(%"[]u8"* sret(%"[]u8") %52, %"[]u8"* %byte_slice)
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).print.58"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %0, %"std.special.struct:19:57"* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %2 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %3 = alloca %"std.special.struct:19:57", align 8
  %4 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0 to i8*
  %5 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %5, i8* align 4 %4, i64 4, i1 false)
  %6 = bitcast %"std.special.struct:19:57"* %1 to i8*
  %7 = bitcast %"std.special.struct:19:57"* %3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %7, i8* align 8 %6, i64 16, i1 false)
  %8 = call fastcc i16 @std.fmt.format.88(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0, %"std.special.struct:19:57"* %1)
  store i16 %8, i16* %result, align 2
  %9 = load i16, i16* %result, align 2
  ret i16 %9
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i1 @std.os.isatty(i32 %0) unnamed_addr #1 {
Entry:
  %result = alloca i1, align 1
  %wsz = alloca %std.os.linux.winsize, align 2
  %fd = alloca i64, align 8
  %rc = alloca i64, align 8
  %1 = alloca i16, align 2
  %handle = alloca i32, align 4
  store i32 %0, i32* %handle, align 4
  br label %WhileCond

WhileCond:                                        ; preds = %SwitchProng1, %Entry
  br label %WhileBody

WhileBody:                                        ; preds = %WhileCond
  %2 = load i32, i32* %handle, align 4
  %3 = sext i32 %2 to i64
  %4 = sext i32 %2 to i64
  store i64 %4, i64* %fd, align 8
  %5 = sext i32 %2 to i64
  %6 = load i64, i64* %fd, align 8
  %7 = ptrtoint %std.os.linux.winsize* %wsz to i64
  %8 = call fastcc i64 @std.os.linux.x86_64.syscall3(i64 16, i64 %6, i64 21523, i64 %7)
  store i64 %8, i64* %rc, align 8
  %9 = load i64, i64* %rc, align 8
  %10 = call fastcc i16 @std.os.linux.getErrno(i64 %9)
  store i16 %10, i16* %1, align 2
  switch i16 %10, label %SwitchElse [
    i16 0, label %SwitchProng
    i16 4, label %SwitchProng1
  ]

SwitchElse:                                       ; preds = %WhileBody
  store i1 false, i1* %result, align 1
  %11 = load i1, i1* %result, align 1
  ret i1 %11

SwitchProng:                                      ; preds = %WhileBody
  store i1 true, i1* %result, align 1
  %12 = load i1, i1* %result, align 1
  ret i1 %12

SwitchProng1:                                     ; preds = %WhileBody
  br label %WhileCond
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.mem.sliceTo(%"[]u8"* nonnull sret(%"[]u8") %0, i8* nonnull readonly align 1 %1) unnamed_addr #1 {
Entry:
  %2 = alloca i8*, align 8
  %length = alloca i64, align 8
  %ptr = alloca i8*, align 8
  store i8* %1, i8** %ptr, align 8
  %3 = load i8*, i8** %ptr, align 8
  store i8* %3, i8** %2, align 8
  %4 = call fastcc i64 @std.mem.lenSliceTo(i8* %3)
  store i64 %4, i64* %length, align 8
  %5 = load i64, i64* %length, align 8
  %6 = load i8*, i8** %ptr, align 8
  %7 = getelementptr inbounds i8, i8* %6, i64 0
  %8 = sub nuw i64 %5, 0
  %9 = getelementptr inbounds %"[]u8", %"[]u8"* %0, i32 0, i32 0
  store i8* %7, i8** %9, align 8
  %10 = getelementptr inbounds %"[]u8", %"[]u8"* %0, i32 0, i32 1
  store i64 %8, i64* %10, align 8
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.os.getenv(%"?[]const u8"* nonnull sret(%"?[]const u8") %0, %"[]u8"* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %i = alloca i64, align 8
  %ptr = alloca i8*, align 8
  %line_i = alloca i64, align 8
  %this_key = alloca %"[]u8", align 8
  %2 = alloca %"[]u8", align 8
  %3 = alloca %"[]u8", align 8
  %end_i = alloca i64, align 8
  %this_value = alloca %"[]u8", align 8
  store i64 0, i64* %i, align 8
  %4 = load i64, i64* getelementptr inbounds (%"[][*:0]u8", %"[][*:0]u8"* @environ, i32 0, i32 1), align 8
  br label %ForCond

ForCond:                                          ; preds = %Then, %Entry
  %5 = load i64, i64* %i, align 8
  %6 = icmp ult i64 %5, %4
  br i1 %6, label %ForBody, label %ForEnd

ForBody:                                          ; preds = %ForCond
  %7 = load i8**, i8*** getelementptr inbounds (%"[][*:0]u8", %"[][*:0]u8"* @environ, i32 0, i32 0), align 8
  %8 = getelementptr inbounds i8*, i8** %7, i64 %5
  %9 = load i8*, i8** %8, align 8
  store i8* %9, i8** %ptr, align 8
  store i64 0, i64* %line_i, align 8
  br label %WhileCond

WhileCond:                                        ; preds = %WhileBody, %ForBody
  %10 = load i64, i64* %line_i, align 8
  %11 = load i8*, i8** %ptr, align 8
  %12 = getelementptr inbounds i8, i8* %11, i64 %10
  %13 = load i8, i8* %12, align 1
  %14 = icmp ne i8 %13, 0
  br i1 %14, label %BoolAndTrue, label %BoolAndFalse

BoolAndTrue:                                      ; preds = %WhileCond
  %15 = load i64, i64* %line_i, align 8
  %16 = load i8*, i8** %ptr, align 8
  %17 = getelementptr inbounds i8, i8* %16, i64 %15
  %18 = load i8, i8* %17, align 1
  %19 = icmp ne i8 %18, 61
  br label %BoolAndFalse

BoolAndFalse:                                     ; preds = %BoolAndTrue, %WhileCond
  %20 = phi i1 [ %14, %WhileCond ], [ %19, %BoolAndTrue ]
  br i1 %20, label %WhileBody, label %WhileEnd

WhileBody:                                        ; preds = %BoolAndFalse
  %21 = load i64, i64* %line_i, align 8
  %22 = add nuw i64 %21, 1
  store i64 %22, i64* %line_i, align 8
  br label %WhileCond

WhileEnd:                                         ; preds = %BoolAndFalse
  %23 = load i64, i64* %line_i, align 8
  %24 = load i8*, i8** %ptr, align 8
  %25 = getelementptr inbounds i8, i8* %24, i64 0
  %26 = sub nuw i64 %23, 0
  %27 = getelementptr inbounds %"[]u8", %"[]u8"* %this_key, i32 0, i32 0
  store i8* %25, i8** %27, align 8
  %28 = getelementptr inbounds %"[]u8", %"[]u8"* %this_key, i32 0, i32 1
  store i64 %26, i64* %28, align 8
  %29 = bitcast %"[]u8"* %1 to i8*
  %30 = bitcast %"[]u8"* %2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %30, i8* align 8 %29, i64 16, i1 false)
  %31 = bitcast %"[]u8"* %this_key to i8*
  %32 = bitcast %"[]u8"* %3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %32, i8* align 8 %31, i64 16, i1 false)
  %33 = call fastcc i1 @std.mem.eql(%"[]u8"* %1, %"[]u8"* %this_key)
  %34 = icmp eq i1 %33, false
  br i1 %34, label %Then, label %Else

Then:                                             ; preds = %WhileEnd
  %35 = add nuw i64 %5, 1
  store i64 %35, i64* %i, align 8
  br label %ForCond

ForEnd:                                           ; preds = %ForCond
  %36 = bitcast %"?[]const u8"* %0 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %36, i8* align 8 bitcast (%"?[]const u8"* @136 to i8*), i64 24, i1 false)
  ret void

Else:                                             ; preds = %WhileEnd
  br label %EndIf

EndIf:                                            ; preds = %Else
  %37 = load i64, i64* %line_i, align 8
  store i64 %37, i64* %end_i, align 8
  br label %WhileCond1

WhileCond1:                                       ; preds = %WhileBody2, %EndIf
  %38 = load i64, i64* %end_i, align 8
  %39 = load i8*, i8** %ptr, align 8
  %40 = getelementptr inbounds i8, i8* %39, i64 %38
  %41 = load i8, i8* %40, align 1
  %42 = icmp ne i8 %41, 0
  br i1 %42, label %WhileBody2, label %WhileEnd3

WhileBody2:                                       ; preds = %WhileCond1
  %43 = load i64, i64* %end_i, align 8
  %44 = add nuw i64 %43, 1
  store i64 %44, i64* %end_i, align 8
  br label %WhileCond1

WhileEnd3:                                        ; preds = %WhileCond1
  %45 = load i64, i64* %line_i, align 8
  %46 = add nuw i64 %45, 1
  %47 = load i64, i64* %end_i, align 8
  %48 = load i8*, i8** %ptr, align 8
  %49 = getelementptr inbounds i8, i8* %48, i64 %46
  %50 = sub nuw i64 %47, %46
  %51 = getelementptr inbounds %"[]u8", %"[]u8"* %this_value, i32 0, i32 0
  store i8* %49, i8** %51, align 8
  %52 = getelementptr inbounds %"[]u8", %"[]u8"* %this_value, i32 0, i32 1
  store i64 %50, i64* %52, align 8
  %53 = getelementptr inbounds %"?[]const u8", %"?[]const u8"* %0, i32 0, i32 1
  store i1 true, i1* %53, align 1
  %54 = getelementptr inbounds %"?[]const u8", %"?[]const u8"* %0, i32 0, i32 0
  %55 = bitcast %"[]u8"* %this_value to i8*
  %56 = bitcast %"[]u8"* %54 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %56, i8* align 8 %55, i64 16, i1 false)
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i64 @std.os.linux.clock_getres(i32 %0, %std.os.linux.timespec* nonnull align 8 %1) unnamed_addr #1 {
Entry:
  %result = alloca i64, align 8
  %clk_id = alloca i32, align 4
  %tp = alloca %std.os.linux.timespec*, align 8
  store i32 %0, i32* %clk_id, align 4
  store %std.os.linux.timespec* %1, %std.os.linux.timespec** %tp, align 8
  %2 = load i32, i32* %clk_id, align 4
  %3 = sext i32 %2 to i64
  %4 = sext i32 %2 to i64
  %5 = load %std.os.linux.timespec*, %std.os.linux.timespec** %tp, align 8
  %6 = ptrtoint %std.os.linux.timespec* %5 to i64
  %7 = call fastcc i64 @std.os.linux.x86_64.syscall2(i64 229, i64 %4, i64 %6)
  store i64 %7, i64* %result, align 8
  %8 = load i64, i64* %result, align 8
  ret i64 %8
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i64 @std.os.linux.clock_gettime(i32 %0, %std.os.linux.timespec* nonnull align 8 %1) unnamed_addr #1 {
Entry:
  %result = alloca i64, align 8
  %ptr = alloca i8*, align 8
  %fn_ptr = alloca i8*, align 8
  %f = alloca i64 (i32, %std.os.linux.timespec*)*, align 8
  %rc = alloca i64, align 8
  %clk_id = alloca i32, align 4
  %tp = alloca %std.os.linux.timespec*, align 8
  store i32 %0, i32* %clk_id, align 4
  store %std.os.linux.timespec* %1, %std.os.linux.timespec** %tp, align 8
  %2 = load i8*, i8** @vdso_clock_gettime, align 8
  store i8* %2, i8** %ptr, align 8
  %3 = load i8*, i8** %ptr, align 8
  %4 = icmp ne i8* %3, null
  br i1 %4, label %OptionalThen, label %OptionalElse

OptionalThen:                                     ; preds = %Entry
  %5 = load i8*, i8** %ptr, align 8
  store i8* %5, i8** %fn_ptr, align 8
  %6 = load i8*, i8** %fn_ptr, align 8
  %7 = bitcast i8* %6 to i64 (i32, %std.os.linux.timespec*)*
  store i64 (i32, %std.os.linux.timespec*)* %7, i64 (i32, %std.os.linux.timespec*)** %f, align 8
  %8 = load i64 (i32, %std.os.linux.timespec*)*, i64 (i32, %std.os.linux.timespec*)** %f, align 8
  %9 = load i32, i32* %clk_id, align 4
  %10 = load %std.os.linux.timespec*, %std.os.linux.timespec** %tp, align 8
  %11 = call i64 %8(i32 %9, %std.os.linux.timespec* %10)
  store i64 %11, i64* %rc, align 8
  %12 = load i64, i64* %rc, align 8
  switch i64 %12, label %SwitchElse [
    i64 0, label %SwitchProng
    i64 -22, label %SwitchProng
  ]

SwitchProng:                                      ; preds = %OptionalThen, %OptionalThen
  %13 = load i64, i64* %rc, align 8
  store i64 %13, i64* %result, align 8
  %14 = load i64, i64* %result, align 8
  ret i64 %14

SwitchElse:                                       ; preds = %OptionalThen
  br label %SwitchEnd

SwitchEnd:                                        ; preds = %SwitchElse
  br label %OptionalEndIf

OptionalElse:                                     ; preds = %Entry
  br label %OptionalEndIf

OptionalEndIf:                                    ; preds = %OptionalElse, %SwitchEnd
  %15 = load i32, i32* %clk_id, align 4
  %16 = sext i32 %15 to i64
  %17 = sext i32 %15 to i64
  %18 = load %std.os.linux.timespec*, %std.os.linux.timespec** %tp, align 8
  %19 = ptrtoint %std.os.linux.timespec* %18 to i64
  %20 = call fastcc i64 @std.os.linux.x86_64.syscall2(i64 228, i64 %17, i64 %19)
  store i64 %20, i64* %result, align 8
  %21 = load i64, i64* %result, align 8
  ret i64 %21
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i64 @std.hash.wyhash.WyhashStateless.hash(i64 %0, %"[]u8"* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %result = alloca i64, align 8
  %aligned_len = alloca i64, align 8
  %c = alloca %std.hash.wyhash.WyhashStateless, align 8
  %2 = alloca %"[]u8", align 8
  %3 = alloca %"[]u8", align 8
  %seed = alloca i64, align 8
  store i64 %0, i64* %seed, align 8
  %4 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 1
  %5 = load i64, i64* %4, align 8
  %6 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 1
  %7 = load i64, i64* %6, align 8
  %8 = urem i64 %7, 32
  %9 = sub nuw i64 %5, %8
  store i64 %9, i64* %aligned_len, align 8
  %10 = load i64, i64* %seed, align 8
  call fastcc void @std.hash.wyhash.WyhashStateless.init(%std.hash.wyhash.WyhashStateless* sret(%std.hash.wyhash.WyhashStateless) %c, i64 %10)
  %11 = load i64, i64* %aligned_len, align 8
  %12 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 0
  %13 = load i8*, i8** %12, align 8
  %14 = getelementptr inbounds i8, i8* %13, i64 0
  %15 = sub nuw i64 %11, 0
  %16 = getelementptr inbounds %"[]u8", %"[]u8"* %2, i32 0, i32 0
  store i8* %14, i8** %16, align 8
  %17 = getelementptr inbounds %"[]u8", %"[]u8"* %2, i32 0, i32 1
  store i64 %15, i64* %17, align 8
  call fastcc void @std.hash.wyhash.WyhashStateless.update(%std.hash.wyhash.WyhashStateless* %c, %"[]u8"* %2) #10
  %18 = load i64, i64* %aligned_len, align 8
  %19 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 1
  %20 = load i64, i64* %19, align 8
  %21 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 0
  %22 = load i8*, i8** %21, align 8
  %23 = getelementptr inbounds i8, i8* %22, i64 %18
  %24 = sub nuw i64 %20, %18
  %25 = getelementptr inbounds %"[]u8", %"[]u8"* %3, i32 0, i32 0
  store i8* %23, i8** %25, align 8
  %26 = getelementptr inbounds %"[]u8", %"[]u8"* %3, i32 0, i32 1
  store i64 %24, i64* %26, align 8
  %27 = call fastcc i64 @std.hash.wyhash.WyhashStateless.final(%std.hash.wyhash.WyhashStateless* %c, %"[]u8"* %3) #10
  store i64 %27, i64* %result, align 8
  %28 = load i64, i64* %result, align 8
  ret i64 %28
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i1 @std.mem.isAlignedGeneric(i64 %0, i64 %1) unnamed_addr #1 {
Entry:
  %result = alloca i1, align 1
  %2 = alloca i64, align 8
  %3 = alloca i64, align 8
  %addr = alloca i64, align 8
  %alignment = alloca i64, align 8
  store i64 %0, i64* %addr, align 8
  store i64 %1, i64* %alignment, align 8
  %4 = load i64, i64* %addr, align 8
  store i64 %4, i64* %2, align 8
  %5 = load i64, i64* %alignment, align 8
  store i64 %5, i64* %3, align 8
  %6 = call fastcc i64 @std.mem.alignBackwardGeneric.89(i64 %4, i64 %5)
  %7 = load i64, i64* %addr, align 8
  %8 = icmp eq i64 %6, %7
  store i1 %8, i1* %result, align 1
  %9 = load i1, i1* %result, align 1
  ret i1 %9
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.mem.alignPointerOffset(%"?usize"* nonnull sret(%"?usize") %0, i8* nonnull align 4096 %1, i29 %2) unnamed_addr #1 {
Entry:
  %addr = alloca i64, align 8
  %new_addr = alloca i64, align 8
  %delta = alloca i64, align 8
  %ptr = alloca i8*, align 8
  %align_to = alloca i29, align 4
  store i8* %1, i8** %ptr, align 8
  store i29 %2, i29* %align_to, align 4
  %3 = load i29, i29* %align_to, align 4
  %4 = icmp ne i29 %3, 0
  br i1 %4, label %BoolAndTrue, label %BoolAndFalse

BoolAndTrue:                                      ; preds = %Entry
  %5 = load i29, i29* %align_to, align 4
  %6 = call i29 @llvm.ctpop.i29(i29 %5)
  %7 = trunc i29 %6 to i5
  %8 = icmp eq i5 %7, 1
  br label %BoolAndFalse

BoolAndFalse:                                     ; preds = %BoolAndTrue, %Entry
  %9 = phi i1 [ %4, %Entry ], [ %8, %BoolAndTrue ]
  call fastcc void @std.debug.assert(i1 %9)
  %10 = load i29, i29* %align_to, align 4
  %11 = icmp ule i29 %10, 4096
  br i1 %11, label %Then, label %Else

Then:                                             ; preds = %BoolAndFalse
  %12 = getelementptr inbounds %"?usize", %"?usize"* %0, i32 0, i32 1
  store i1 true, i1* %12, align 1
  %13 = getelementptr inbounds %"?usize", %"?usize"* %0, i32 0, i32 0
  store i64 0, i64* %13, align 8
  ret void

Else:                                             ; preds = %BoolAndFalse
  br label %EndIf

EndIf:                                            ; preds = %Else
  %14 = load i8*, i8** %ptr, align 8
  %15 = ptrtoint i8* %14 to i64
  store i64 %15, i64* %addr, align 8
  %16 = load i64, i64* %addr, align 8
  %17 = load i29, i29* %align_to, align 4
  %18 = sub nuw i29 %17, 1
  %19 = zext i29 %18 to i64
  %20 = call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %16, i64 %19)
  %21 = extractvalue { i64, i1 } %20, 0
  %22 = extractvalue { i64, i1 } %20, 1
  store i64 %21, i64* %new_addr, align 8
  br i1 %22, label %Then1, label %Else2

Then1:                                            ; preds = %EndIf
  %23 = bitcast %"?usize"* %0 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %23, i8* align 8 bitcast (%"?usize"* @137 to i8*), i64 16, i1 false)
  ret void

Else2:                                            ; preds = %EndIf
  br label %EndIf3

EndIf3:                                           ; preds = %Else2
  %24 = load i64, i64* %new_addr, align 8
  %25 = load i29, i29* %align_to, align 4
  %26 = sub nuw i29 %25, 1
  %27 = zext i29 %26 to i64
  %28 = xor i64 %27, -1
  %29 = and i64 %24, %28
  store i64 %29, i64* %new_addr, align 8
  %30 = load i64, i64* %new_addr, align 8
  %31 = load i64, i64* %addr, align 8
  %32 = sub nuw i64 %30, %31
  store i64 %32, i64* %delta, align 8
  %33 = load i64, i64* %delta, align 8
  %34 = urem i64 %33, 1
  %35 = icmp ne i64 %34, 0
  br i1 %35, label %Then4, label %Else5

Then4:                                            ; preds = %EndIf3
  %36 = bitcast %"?usize"* %0 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %36, i8* align 8 bitcast (%"?usize"* @138 to i8*), i64 16, i1 false)
  ret void

Else5:                                            ; preds = %EndIf3
  br label %EndIf6

EndIf6:                                           ; preds = %Else5
  %37 = load i64, i64* %delta, align 8
  %38 = udiv i64 %37, 1
  %39 = getelementptr inbounds %"?usize", %"?usize"* %0, i32 0, i32 1
  store i1 true, i1* %39, align 1
  %40 = getelementptr inbounds %"?usize", %"?usize"* %0, i32 0, i32 0
  store i64 %38, i64* %40, align 8
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i64 @std.os.linux.munmap(i8* nonnull readonly align 1 %0, i64 %1) unnamed_addr #1 {
Entry:
  %result = alloca i64, align 8
  %address = alloca i8*, align 8
  %length = alloca i64, align 8
  store i8* %0, i8** %address, align 8
  store i64 %1, i64* %length, align 8
  %2 = load i8*, i8** %address, align 8
  %3 = ptrtoint i8* %2 to i64
  %4 = load i64, i64* %length, align 8
  %5 = call fastcc i64 @std.os.linux.x86_64.syscall2(i64 11, i64 %3, i64 %4)
  store i64 %5, i64* %result, align 8
  %6 = load i64, i64* %result, align 8
  ret i64 %6
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i64 @std.mem.alignAllocLen(i64 %0, i64 %1, i29 %2) unnamed_addr #1 {
Entry:
  %result = alloca i64, align 8
  %adjusted = alloca i64, align 8
  %full_len = alloca i64, align 8
  %alloc_len = alloca i64, align 8
  %len_align = alloca i29, align 4
  store i64 %0, i64* %full_len, align 8
  store i64 %1, i64* %alloc_len, align 8
  store i29 %2, i29* %len_align, align 4
  %3 = load i64, i64* %alloc_len, align 8
  %4 = icmp ugt i64 %3, 0
  call fastcc void @std.debug.assert(i1 %4)
  %5 = load i64, i64* %alloc_len, align 8
  %6 = load i29, i29* %len_align, align 4
  %7 = zext i29 %6 to i64
  %8 = icmp uge i64 %5, %7
  call fastcc void @std.debug.assert(i1 %8)
  %9 = load i64, i64* %full_len, align 8
  %10 = load i64, i64* %alloc_len, align 8
  %11 = icmp uge i64 %9, %10
  call fastcc void @std.debug.assert(i1 %11)
  %12 = load i29, i29* %len_align, align 4
  %13 = icmp eq i29 %12, 0
  br i1 %13, label %Then, label %Else

Then:                                             ; preds = %Entry
  %14 = load i64, i64* %alloc_len, align 8
  store i64 %14, i64* %result, align 8
  %15 = load i64, i64* %result, align 8
  ret i64 %15

Else:                                             ; preds = %Entry
  br label %EndIf

EndIf:                                            ; preds = %Else
  %16 = load i64, i64* %full_len, align 8
  %17 = load i29, i29* %len_align, align 4
  %18 = zext i29 %17 to i64
  %19 = call fastcc i64 @std.mem.alignBackwardAnyAlign(i64 %16, i64 %18)
  store i64 %19, i64* %adjusted, align 8
  %20 = load i64, i64* %adjusted, align 8
  %21 = load i64, i64* %alloc_len, align 8
  %22 = icmp uge i64 %20, %21
  call fastcc void @std.debug.assert(i1 %22)
  %23 = load i64, i64* %adjusted, align 8
  store i64 %23, i64* %result, align 8
  %24 = load i64, i64* %result, align 8
  ret i64 %24
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i1 @std.Thread.Mutex.AtomicMutex.tryLock(%std.Thread.Mutex.AtomicMutex* nonnull align 4 %0) unnamed_addr #1 {
Entry:
  %result = alloca i1, align 1
  %1 = alloca %"?std.Thread.Mutex.State", align 4
  %m = alloca %std.Thread.Mutex.AtomicMutex*, align 8
  store %std.Thread.Mutex.AtomicMutex* %0, %std.Thread.Mutex.AtomicMutex** %m, align 8
  %2 = load %std.Thread.Mutex.AtomicMutex*, %std.Thread.Mutex.AtomicMutex** %m, align 8
  %3 = getelementptr inbounds %std.Thread.Mutex.AtomicMutex, %std.Thread.Mutex.AtomicMutex* %2, i32 0, i32 0
  %4 = cmpxchg i32* %3, i32 0, i32 1 acquire monotonic, align 4
  %5 = extractvalue { i32, i1 } %4, 0
  %6 = getelementptr inbounds %"?std.Thread.Mutex.State", %"?std.Thread.Mutex.State"* %1, i32 0, i32 0
  store i32 %5, i32* %6, align 4
  %7 = extractvalue { i32, i1 } %4, 1
  %8 = xor i1 %7, true
  %9 = getelementptr inbounds %"?std.Thread.Mutex.State", %"?std.Thread.Mutex.State"* %1, i32 0, i32 1
  store i1 %8, i1* %9, align 1
  %10 = getelementptr inbounds %"?std.Thread.Mutex.State", %"?std.Thread.Mutex.State"* %1, i32 0, i32 1
  %11 = load i1, i1* %10, align 1
  %12 = icmp eq i1 %11, false
  store i1 %12, i1* %result, align 1
  %13 = load i1, i1* %result, align 1
  ret i1 %13
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.fmt.bufPrint({ %"[]u8", i16 }* nonnull sret({ %"[]u8", i16 }) %0, %"[]u8"* nonnull readonly align 8 %1, %"std.Progress.struct:202:79"* nonnull readonly align 8 %2) unnamed_addr #1 {
Entry:
  %3 = alloca %"[]u8", align 8
  %fbs = alloca %"std.io.fixed_buffer_stream.FixedBufferStream([]u8)", align 8
  %4 = alloca %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)", align 8
  %5 = alloca %"std.Progress.struct:202:79", align 8
  %6 = alloca i16, align 2
  %7 = alloca { %"[]u8", i16 }, align 8
  %8 = bitcast %"[]u8"* %1 to i8*
  %9 = bitcast %"[]u8"* %3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %9, i8* align 8 %8, i64 16, i1 false)
  call fastcc void @std.io.fixed_buffer_stream.fixedBufferStream(%"std.io.fixed_buffer_stream.FixedBufferStream([]u8)"* sret(%"std.io.fixed_buffer_stream.FixedBufferStream([]u8)") %fbs, %"[]u8"* %1)
  call fastcc void @"std.io.fixed_buffer_stream.FixedBufferStream([]u8).writer"(%"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* sret(%"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)") %4, %"std.io.fixed_buffer_stream.FixedBufferStream([]u8)"* %fbs)
  %10 = bitcast %"std.Progress.struct:202:79"* %2 to i8*
  %11 = bitcast %"std.Progress.struct:202:79"* %5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %11, i8* align 8 %10, i64 8, i1 false)
  %12 = call fastcc i16 @std.fmt.format.90(%"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* %4, %"std.Progress.struct:202:79"* %2)
  store i16 %12, i16* %6, align 2
  %13 = icmp ne i16 %12, 0
  br i1 %13, label %ErrRetReturn, label %ErrRetContinue

ErrRetReturn:                                     ; preds = %Entry
  %14 = load i16, i16* %6, align 2
  %15 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %0, i32 0, i32 1
  store i16 %14, i16* %15, align 2
  %16 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %7, i32 0, i32 1
  store i16 %14, i16* %16, align 2
  ret void

ErrRetContinue:                                   ; preds = %Entry
  %17 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %0, i32 0, i32 1
  store i16 0, i16* %17, align 2
  %18 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %0, i32 0, i32 0
  call fastcc void @"std.io.fixed_buffer_stream.FixedBufferStream([]u8).getWritten"(%"[]u8"* sret(%"[]u8") %18, %"std.io.fixed_buffer_stream.FixedBufferStream([]u8)"* %fbs)
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.fmt.bufPrint.59({ %"[]u8", i16 }* nonnull sret({ %"[]u8", i16 }) %0, %"[]u8"* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %2 = alloca %"[]u8", align 8
  %fbs = alloca %"std.io.fixed_buffer_stream.FixedBufferStream([]u8)", align 8
  %3 = alloca %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)", align 8
  %4 = alloca i16, align 2
  %5 = alloca { %"[]u8", i16 }, align 8
  %6 = bitcast %"[]u8"* %1 to i8*
  %7 = bitcast %"[]u8"* %2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %7, i8* align 8 %6, i64 16, i1 false)
  call fastcc void @std.io.fixed_buffer_stream.fixedBufferStream(%"std.io.fixed_buffer_stream.FixedBufferStream([]u8)"* sret(%"std.io.fixed_buffer_stream.FixedBufferStream([]u8)") %fbs, %"[]u8"* %1)
  call fastcc void @"std.io.fixed_buffer_stream.FixedBufferStream([]u8).writer"(%"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* sret(%"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)") %3, %"std.io.fixed_buffer_stream.FixedBufferStream([]u8)"* %fbs)
  %8 = call fastcc i16 @std.fmt.format.91(%"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* %3)
  store i16 %8, i16* %4, align 2
  %9 = icmp ne i16 %8, 0
  br i1 %9, label %ErrRetReturn, label %ErrRetContinue

ErrRetReturn:                                     ; preds = %Entry
  %10 = load i16, i16* %4, align 2
  %11 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %0, i32 0, i32 1
  store i16 %10, i16* %11, align 2
  %12 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %5, i32 0, i32 1
  store i16 %10, i16* %12, align 2
  ret void

ErrRetContinue:                                   ; preds = %Entry
  %13 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %0, i32 0, i32 1
  store i16 0, i16* %13, align 2
  %14 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %0, i32 0, i32 0
  call fastcc void @"std.io.fixed_buffer_stream.FixedBufferStream([]u8).getWritten"(%"[]u8"* sret(%"[]u8") %14, %"std.io.fixed_buffer_stream.FixedBufferStream([]u8)"* %fbs)
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.Progress.bufWrite(%std.Progress* nonnull align 8 %0, i64* nonnull align 8 %1) unnamed_addr #1 {
Entry:
  %2 = alloca %"[]u8", align 8
  %3 = alloca { %"[]u8", i16 }, align 8
  %written = alloca %"[]u8", align 8
  %amt = alloca i64, align 8
  %err = alloca i16, align 2
  %bytes_needed_for_esc_codes_at_end = alloca i8, align 1
  %max_end = alloca i64, align 8
  %4 = alloca %"[]u8", align 8
  %self = alloca %std.Progress*, align 8
  %end = alloca i64*, align 8
  store %std.Progress* %0, %std.Progress** %self, align 8
  store i64* %1, i64** %end, align 8
  %5 = load %std.Progress*, %std.Progress** %self, align 8
  %6 = getelementptr inbounds %std.Progress, %std.Progress* %5, i32 0, i32 7
  %7 = load i64*, i64** %end, align 8
  %8 = load i64, i64* %7, align 8
  %9 = getelementptr inbounds [100 x i8], [100 x i8]* %6, i64 0, i64 %8
  %10 = sub nuw i64 100, %8
  %11 = getelementptr inbounds %"[]u8", %"[]u8"* %2, i32 0, i32 0
  store i8* %9, i8** %11, align 8
  %12 = getelementptr inbounds %"[]u8", %"[]u8"* %2, i32 0, i32 1
  store i64 %10, i64* %12, align 8
  call fastcc void @std.fmt.bufPrint.92({ %"[]u8", i16 }* sret({ %"[]u8", i16 }) %3, %"[]u8"* %2)
  %13 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %3, i32 0, i32 1
  %14 = load i16, i16* %13, align 2
  %15 = icmp ne i16 %14, 0
  br i1 %15, label %TryElse, label %TryOk

TryElse:                                          ; preds = %Entry
  %16 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %3, i32 0, i32 1
  %17 = load i16, i16* %16, align 2
  store i16 %17, i16* %err, align 2
  %18 = load i16, i16* %err, align 2
  switch i16 %18, label %SwitchElse [
    i16 4, label %SwitchProng
  ]

TryOk:                                            ; preds = %Entry
  %19 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %3, i32 0, i32 0
  %20 = bitcast %"[]u8"* %19 to i8*
  %21 = bitcast %"[]u8"* %written to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %21, i8* align 8 %20, i64 16, i1 false)
  %22 = getelementptr inbounds %"[]u8", %"[]u8"* %written, i32 0, i32 1
  %23 = load i64, i64* %22, align 8
  store i64 %23, i64* %amt, align 8
  %24 = load i64*, i64** %end, align 8
  %25 = load i64, i64* %24, align 8
  %26 = load i64, i64* %amt, align 8
  %27 = add nuw i64 %25, %26
  store i64 %27, i64* %24, align 8
  %28 = load %std.Progress*, %std.Progress** %self, align 8
  %29 = getelementptr inbounds %std.Progress, %std.Progress* %28, i32 0, i32 12
  %30 = load i64, i64* %29, align 8
  %31 = load i64, i64* %amt, align 8
  %32 = add nuw i64 %30, %31
  store i64 %32, i64* %29, align 8
  br label %TryEnd

SwitchProng:                                      ; preds = %TryElse
  %33 = load %std.Progress*, %std.Progress** %self, align 8
  %34 = getelementptr inbounds %std.Progress, %std.Progress* %33, i32 0, i32 12
  %35 = load i64, i64* %34, align 8
  %36 = load %std.Progress*, %std.Progress** %self, align 8
  %37 = load i64*, i64** %end, align 8
  %38 = load i64, i64* %37, align 8
  %39 = sub nuw i64 100, %38
  %40 = add nuw i64 %35, %39
  store i64 %40, i64* %34, align 8
  %41 = load i64*, i64** %end, align 8
  %42 = load %std.Progress*, %std.Progress** %self, align 8
  store i64 100, i64* %41, align 8
  br label %SwitchEnd

SwitchEnd:                                        ; preds = %SwitchProng
  br label %TryEnd

TryEnd:                                           ; preds = %SwitchEnd, %TryOk
  %43 = load %std.Progress*, %std.Progress** %self, align 8
  %44 = getelementptr inbounds %std.Progress, %std.Progress* %43, i32 0, i32 1
  %45 = load i1, i1* %44, align 1
  br i1 %45, label %Then, label %Else

Then:                                             ; preds = %TryEnd
  store i8 0, i8* %bytes_needed_for_esc_codes_at_end, align 1
  br label %EndIf

Else:                                             ; preds = %TryEnd
  store i8 11, i8* %bytes_needed_for_esc_codes_at_end, align 1
  br label %EndIf

EndIf:                                            ; preds = %Else, %Then
  %46 = load %std.Progress*, %std.Progress** %self, align 8
  %47 = load i8, i8* %bytes_needed_for_esc_codes_at_end, align 1
  %48 = zext i8 %47 to i64
  %49 = sub nuw i64 100, %48
  store i64 %49, i64* %max_end, align 8
  %50 = load i64*, i64** %end, align 8
  %51 = load i64, i64* %50, align 8
  %52 = load i64, i64* %max_end, align 8
  %53 = icmp ugt i64 %51, %52
  br i1 %53, label %Then1, label %Else2

Then1:                                            ; preds = %EndIf
  %54 = load %std.Progress*, %std.Progress** %self, align 8
  %55 = getelementptr inbounds %std.Progress, %std.Progress* %54, i32 0, i32 12
  %56 = load %std.Progress*, %std.Progress** %self, align 8
  %57 = getelementptr inbounds %std.Progress, %std.Progress* %56, i32 0, i32 12
  %58 = load i64, i64* %57, align 8
  %59 = load i64*, i64** %end, align 8
  %60 = load i64, i64* %59, align 8
  %61 = load i64, i64* %max_end, align 8
  %62 = sub nuw i64 %60, %61
  %63 = sub nuw i64 %58, %62
  %64 = add nuw i64 %63, 4
  store i64 %64, i64* %55, align 8
  %65 = load %std.Progress*, %std.Progress** %self, align 8
  %66 = getelementptr inbounds %std.Progress, %std.Progress* %65, i32 0, i32 7
  %67 = load i64, i64* %max_end, align 8
  %68 = getelementptr inbounds [100 x i8], [100 x i8]* %66, i64 0, i64 %67
  %69 = sub nuw i64 100, %67
  %70 = getelementptr inbounds %"[]u8", %"[]u8"* %4, i32 0, i32 0
  store i8* %68, i8** %70, align 8
  %71 = getelementptr inbounds %"[]u8", %"[]u8"* %4, i32 0, i32 1
  store i64 %69, i64* %71, align 8
  call fastcc void @std.mem.copy(%"[]u8"* %4, %"[]u8"* @141)
  %72 = load i64*, i64** %end, align 8
  %73 = load i64, i64* %max_end, align 8
  %74 = add nuw i64 %73, 4
  store i64 %74, i64* %72, align 8
  br label %EndIf3

Else2:                                            ; preds = %EndIf
  br label %EndIf3

EndIf3:                                           ; preds = %Else2, %Then1
  ret void

SwitchElse:                                       ; preds = %TryElse
  unreachable
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.Progress.bufWrite.60(%std.Progress* nonnull align 8 %0, i64* nonnull align 8 %1, %"std.Progress.struct:264:49"* nonnull readonly align 8 %2) unnamed_addr #1 {
Entry:
  %3 = alloca %"[]u8", align 8
  %4 = alloca %"std.Progress.struct:264:49", align 8
  %5 = alloca { %"[]u8", i16 }, align 8
  %written = alloca %"[]u8", align 8
  %amt = alloca i64, align 8
  %err = alloca i16, align 2
  %bytes_needed_for_esc_codes_at_end = alloca i8, align 1
  %max_end = alloca i64, align 8
  %6 = alloca %"[]u8", align 8
  %self = alloca %std.Progress*, align 8
  %end = alloca i64*, align 8
  store %std.Progress* %0, %std.Progress** %self, align 8
  store i64* %1, i64** %end, align 8
  %7 = load %std.Progress*, %std.Progress** %self, align 8
  %8 = getelementptr inbounds %std.Progress, %std.Progress* %7, i32 0, i32 7
  %9 = load i64*, i64** %end, align 8
  %10 = load i64, i64* %9, align 8
  %11 = getelementptr inbounds [100 x i8], [100 x i8]* %8, i64 0, i64 %10
  %12 = sub nuw i64 100, %10
  %13 = getelementptr inbounds %"[]u8", %"[]u8"* %3, i32 0, i32 0
  store i8* %11, i8** %13, align 8
  %14 = getelementptr inbounds %"[]u8", %"[]u8"* %3, i32 0, i32 1
  store i64 %12, i64* %14, align 8
  %15 = bitcast %"std.Progress.struct:264:49"* %2 to i8*
  %16 = bitcast %"std.Progress.struct:264:49"* %4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %16, i8* align 8 %15, i64 16, i1 false)
  call fastcc void @std.fmt.bufPrint.93({ %"[]u8", i16 }* sret({ %"[]u8", i16 }) %5, %"[]u8"* %3, %"std.Progress.struct:264:49"* %2)
  %17 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %5, i32 0, i32 1
  %18 = load i16, i16* %17, align 2
  %19 = icmp ne i16 %18, 0
  br i1 %19, label %TryElse, label %TryOk

TryElse:                                          ; preds = %Entry
  %20 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %5, i32 0, i32 1
  %21 = load i16, i16* %20, align 2
  store i16 %21, i16* %err, align 2
  %22 = load i16, i16* %err, align 2
  switch i16 %22, label %SwitchElse [
    i16 4, label %SwitchProng
  ]

TryOk:                                            ; preds = %Entry
  %23 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %5, i32 0, i32 0
  %24 = bitcast %"[]u8"* %23 to i8*
  %25 = bitcast %"[]u8"* %written to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %25, i8* align 8 %24, i64 16, i1 false)
  %26 = getelementptr inbounds %"[]u8", %"[]u8"* %written, i32 0, i32 1
  %27 = load i64, i64* %26, align 8
  store i64 %27, i64* %amt, align 8
  %28 = load i64*, i64** %end, align 8
  %29 = load i64, i64* %28, align 8
  %30 = load i64, i64* %amt, align 8
  %31 = add nuw i64 %29, %30
  store i64 %31, i64* %28, align 8
  %32 = load %std.Progress*, %std.Progress** %self, align 8
  %33 = getelementptr inbounds %std.Progress, %std.Progress* %32, i32 0, i32 12
  %34 = load i64, i64* %33, align 8
  %35 = load i64, i64* %amt, align 8
  %36 = add nuw i64 %34, %35
  store i64 %36, i64* %33, align 8
  br label %TryEnd

SwitchProng:                                      ; preds = %TryElse
  %37 = load %std.Progress*, %std.Progress** %self, align 8
  %38 = getelementptr inbounds %std.Progress, %std.Progress* %37, i32 0, i32 12
  %39 = load i64, i64* %38, align 8
  %40 = load %std.Progress*, %std.Progress** %self, align 8
  %41 = load i64*, i64** %end, align 8
  %42 = load i64, i64* %41, align 8
  %43 = sub nuw i64 100, %42
  %44 = add nuw i64 %39, %43
  store i64 %44, i64* %38, align 8
  %45 = load i64*, i64** %end, align 8
  %46 = load %std.Progress*, %std.Progress** %self, align 8
  store i64 100, i64* %45, align 8
  br label %SwitchEnd

SwitchEnd:                                        ; preds = %SwitchProng
  br label %TryEnd

TryEnd:                                           ; preds = %SwitchEnd, %TryOk
  %47 = load %std.Progress*, %std.Progress** %self, align 8
  %48 = getelementptr inbounds %std.Progress, %std.Progress* %47, i32 0, i32 1
  %49 = load i1, i1* %48, align 1
  br i1 %49, label %Then, label %Else

Then:                                             ; preds = %TryEnd
  store i8 0, i8* %bytes_needed_for_esc_codes_at_end, align 1
  br label %EndIf

Else:                                             ; preds = %TryEnd
  store i8 11, i8* %bytes_needed_for_esc_codes_at_end, align 1
  br label %EndIf

EndIf:                                            ; preds = %Else, %Then
  %50 = load %std.Progress*, %std.Progress** %self, align 8
  %51 = load i8, i8* %bytes_needed_for_esc_codes_at_end, align 1
  %52 = zext i8 %51 to i64
  %53 = sub nuw i64 100, %52
  store i64 %53, i64* %max_end, align 8
  %54 = load i64*, i64** %end, align 8
  %55 = load i64, i64* %54, align 8
  %56 = load i64, i64* %max_end, align 8
  %57 = icmp ugt i64 %55, %56
  br i1 %57, label %Then1, label %Else2

Then1:                                            ; preds = %EndIf
  %58 = load %std.Progress*, %std.Progress** %self, align 8
  %59 = getelementptr inbounds %std.Progress, %std.Progress* %58, i32 0, i32 12
  %60 = load %std.Progress*, %std.Progress** %self, align 8
  %61 = getelementptr inbounds %std.Progress, %std.Progress* %60, i32 0, i32 12
  %62 = load i64, i64* %61, align 8
  %63 = load i64*, i64** %end, align 8
  %64 = load i64, i64* %63, align 8
  %65 = load i64, i64* %max_end, align 8
  %66 = sub nuw i64 %64, %65
  %67 = sub nuw i64 %62, %66
  %68 = add nuw i64 %67, 4
  store i64 %68, i64* %59, align 8
  %69 = load %std.Progress*, %std.Progress** %self, align 8
  %70 = getelementptr inbounds %std.Progress, %std.Progress* %69, i32 0, i32 7
  %71 = load i64, i64* %max_end, align 8
  %72 = getelementptr inbounds [100 x i8], [100 x i8]* %70, i64 0, i64 %71
  %73 = sub nuw i64 100, %71
  %74 = getelementptr inbounds %"[]u8", %"[]u8"* %6, i32 0, i32 0
  store i8* %72, i8** %74, align 8
  %75 = getelementptr inbounds %"[]u8", %"[]u8"* %6, i32 0, i32 1
  store i64 %73, i64* %75, align 8
  call fastcc void @std.mem.copy(%"[]u8"* %6, %"[]u8"* @143)
  %76 = load i64*, i64** %end, align 8
  %77 = load i64, i64* %max_end, align 8
  %78 = add nuw i64 %77, 4
  store i64 %78, i64* %76, align 8
  br label %EndIf3

Else2:                                            ; preds = %EndIf
  br label %EndIf3

EndIf3:                                           ; preds = %Else2, %Then1
  ret void

SwitchElse:                                       ; preds = %TryElse
  unreachable
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.Progress.bufWrite.61(%std.Progress* nonnull align 8 %0, i64* nonnull align 8 %1) unnamed_addr #1 {
Entry:
  %2 = alloca %"[]u8", align 8
  %3 = alloca { %"[]u8", i16 }, align 8
  %written = alloca %"[]u8", align 8
  %amt = alloca i64, align 8
  %err = alloca i16, align 2
  %bytes_needed_for_esc_codes_at_end = alloca i8, align 1
  %max_end = alloca i64, align 8
  %4 = alloca %"[]u8", align 8
  %self = alloca %std.Progress*, align 8
  %end = alloca i64*, align 8
  store %std.Progress* %0, %std.Progress** %self, align 8
  store i64* %1, i64** %end, align 8
  %5 = load %std.Progress*, %std.Progress** %self, align 8
  %6 = getelementptr inbounds %std.Progress, %std.Progress* %5, i32 0, i32 7
  %7 = load i64*, i64** %end, align 8
  %8 = load i64, i64* %7, align 8
  %9 = getelementptr inbounds [100 x i8], [100 x i8]* %6, i64 0, i64 %8
  %10 = sub nuw i64 100, %8
  %11 = getelementptr inbounds %"[]u8", %"[]u8"* %2, i32 0, i32 0
  store i8* %9, i8** %11, align 8
  %12 = getelementptr inbounds %"[]u8", %"[]u8"* %2, i32 0, i32 1
  store i64 %10, i64* %12, align 8
  call fastcc void @std.fmt.bufPrint.94({ %"[]u8", i16 }* sret({ %"[]u8", i16 }) %3, %"[]u8"* %2)
  %13 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %3, i32 0, i32 1
  %14 = load i16, i16* %13, align 2
  %15 = icmp ne i16 %14, 0
  br i1 %15, label %TryElse, label %TryOk

TryElse:                                          ; preds = %Entry
  %16 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %3, i32 0, i32 1
  %17 = load i16, i16* %16, align 2
  store i16 %17, i16* %err, align 2
  %18 = load i16, i16* %err, align 2
  switch i16 %18, label %SwitchElse [
    i16 4, label %SwitchProng
  ]

TryOk:                                            ; preds = %Entry
  %19 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %3, i32 0, i32 0
  %20 = bitcast %"[]u8"* %19 to i8*
  %21 = bitcast %"[]u8"* %written to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %21, i8* align 8 %20, i64 16, i1 false)
  %22 = getelementptr inbounds %"[]u8", %"[]u8"* %written, i32 0, i32 1
  %23 = load i64, i64* %22, align 8
  store i64 %23, i64* %amt, align 8
  %24 = load i64*, i64** %end, align 8
  %25 = load i64, i64* %24, align 8
  %26 = load i64, i64* %amt, align 8
  %27 = add nuw i64 %25, %26
  store i64 %27, i64* %24, align 8
  %28 = load %std.Progress*, %std.Progress** %self, align 8
  %29 = getelementptr inbounds %std.Progress, %std.Progress* %28, i32 0, i32 12
  %30 = load i64, i64* %29, align 8
  %31 = load i64, i64* %amt, align 8
  %32 = add nuw i64 %30, %31
  store i64 %32, i64* %29, align 8
  br label %TryEnd

SwitchProng:                                      ; preds = %TryElse
  %33 = load %std.Progress*, %std.Progress** %self, align 8
  %34 = getelementptr inbounds %std.Progress, %std.Progress* %33, i32 0, i32 12
  %35 = load i64, i64* %34, align 8
  %36 = load %std.Progress*, %std.Progress** %self, align 8
  %37 = load i64*, i64** %end, align 8
  %38 = load i64, i64* %37, align 8
  %39 = sub nuw i64 100, %38
  %40 = add nuw i64 %35, %39
  store i64 %40, i64* %34, align 8
  %41 = load i64*, i64** %end, align 8
  %42 = load %std.Progress*, %std.Progress** %self, align 8
  store i64 100, i64* %41, align 8
  br label %SwitchEnd

SwitchEnd:                                        ; preds = %SwitchProng
  br label %TryEnd

TryEnd:                                           ; preds = %SwitchEnd, %TryOk
  %43 = load %std.Progress*, %std.Progress** %self, align 8
  %44 = getelementptr inbounds %std.Progress, %std.Progress* %43, i32 0, i32 1
  %45 = load i1, i1* %44, align 1
  br i1 %45, label %Then, label %Else

Then:                                             ; preds = %TryEnd
  store i8 0, i8* %bytes_needed_for_esc_codes_at_end, align 1
  br label %EndIf

Else:                                             ; preds = %TryEnd
  store i8 11, i8* %bytes_needed_for_esc_codes_at_end, align 1
  br label %EndIf

EndIf:                                            ; preds = %Else, %Then
  %46 = load %std.Progress*, %std.Progress** %self, align 8
  %47 = load i8, i8* %bytes_needed_for_esc_codes_at_end, align 1
  %48 = zext i8 %47 to i64
  %49 = sub nuw i64 100, %48
  store i64 %49, i64* %max_end, align 8
  %50 = load i64*, i64** %end, align 8
  %51 = load i64, i64* %50, align 8
  %52 = load i64, i64* %max_end, align 8
  %53 = icmp ugt i64 %51, %52
  br i1 %53, label %Then1, label %Else2

Then1:                                            ; preds = %EndIf
  %54 = load %std.Progress*, %std.Progress** %self, align 8
  %55 = getelementptr inbounds %std.Progress, %std.Progress* %54, i32 0, i32 12
  %56 = load %std.Progress*, %std.Progress** %self, align 8
  %57 = getelementptr inbounds %std.Progress, %std.Progress* %56, i32 0, i32 12
  %58 = load i64, i64* %57, align 8
  %59 = load i64*, i64** %end, align 8
  %60 = load i64, i64* %59, align 8
  %61 = load i64, i64* %max_end, align 8
  %62 = sub nuw i64 %60, %61
  %63 = sub nuw i64 %58, %62
  %64 = add nuw i64 %63, 4
  store i64 %64, i64* %55, align 8
  %65 = load %std.Progress*, %std.Progress** %self, align 8
  %66 = getelementptr inbounds %std.Progress, %std.Progress* %65, i32 0, i32 7
  %67 = load i64, i64* %max_end, align 8
  %68 = getelementptr inbounds [100 x i8], [100 x i8]* %66, i64 0, i64 %67
  %69 = sub nuw i64 100, %67
  %70 = getelementptr inbounds %"[]u8", %"[]u8"* %4, i32 0, i32 0
  store i8* %68, i8** %70, align 8
  %71 = getelementptr inbounds %"[]u8", %"[]u8"* %4, i32 0, i32 1
  store i64 %69, i64* %71, align 8
  call fastcc void @std.mem.copy(%"[]u8"* %4, %"[]u8"* @145)
  %72 = load i64*, i64** %end, align 8
  %73 = load i64, i64* %max_end, align 8
  %74 = add nuw i64 %73, 4
  store i64 %74, i64* %72, align 8
  br label %EndIf3

Else2:                                            ; preds = %EndIf
  br label %EndIf3

EndIf3:                                           ; preds = %Else2, %Then1
  ret void

SwitchElse:                                       ; preds = %TryElse
  unreachable
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.Progress.bufWrite.62(%std.Progress* nonnull align 8 %0, i64* nonnull align 8 %1) unnamed_addr #1 {
Entry:
  %2 = alloca %"[]u8", align 8
  %3 = alloca { %"[]u8", i16 }, align 8
  %written = alloca %"[]u8", align 8
  %amt = alloca i64, align 8
  %err = alloca i16, align 2
  %bytes_needed_for_esc_codes_at_end = alloca i8, align 1
  %max_end = alloca i64, align 8
  %4 = alloca %"[]u8", align 8
  %self = alloca %std.Progress*, align 8
  %end = alloca i64*, align 8
  store %std.Progress* %0, %std.Progress** %self, align 8
  store i64* %1, i64** %end, align 8
  %5 = load %std.Progress*, %std.Progress** %self, align 8
  %6 = getelementptr inbounds %std.Progress, %std.Progress* %5, i32 0, i32 7
  %7 = load i64*, i64** %end, align 8
  %8 = load i64, i64* %7, align 8
  %9 = getelementptr inbounds [100 x i8], [100 x i8]* %6, i64 0, i64 %8
  %10 = sub nuw i64 100, %8
  %11 = getelementptr inbounds %"[]u8", %"[]u8"* %2, i32 0, i32 0
  store i8* %9, i8** %11, align 8
  %12 = getelementptr inbounds %"[]u8", %"[]u8"* %2, i32 0, i32 1
  store i64 %10, i64* %12, align 8
  call fastcc void @std.fmt.bufPrint.96({ %"[]u8", i16 }* sret({ %"[]u8", i16 }) %3, %"[]u8"* %2)
  %13 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %3, i32 0, i32 1
  %14 = load i16, i16* %13, align 2
  %15 = icmp ne i16 %14, 0
  br i1 %15, label %TryElse, label %TryOk

TryElse:                                          ; preds = %Entry
  %16 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %3, i32 0, i32 1
  %17 = load i16, i16* %16, align 2
  store i16 %17, i16* %err, align 2
  %18 = load i16, i16* %err, align 2
  switch i16 %18, label %SwitchElse [
    i16 4, label %SwitchProng
  ]

TryOk:                                            ; preds = %Entry
  %19 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %3, i32 0, i32 0
  %20 = bitcast %"[]u8"* %19 to i8*
  %21 = bitcast %"[]u8"* %written to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %21, i8* align 8 %20, i64 16, i1 false)
  %22 = getelementptr inbounds %"[]u8", %"[]u8"* %written, i32 0, i32 1
  %23 = load i64, i64* %22, align 8
  store i64 %23, i64* %amt, align 8
  %24 = load i64*, i64** %end, align 8
  %25 = load i64, i64* %24, align 8
  %26 = load i64, i64* %amt, align 8
  %27 = add nuw i64 %25, %26
  store i64 %27, i64* %24, align 8
  %28 = load %std.Progress*, %std.Progress** %self, align 8
  %29 = getelementptr inbounds %std.Progress, %std.Progress* %28, i32 0, i32 12
  %30 = load i64, i64* %29, align 8
  %31 = load i64, i64* %amt, align 8
  %32 = add nuw i64 %30, %31
  store i64 %32, i64* %29, align 8
  br label %TryEnd

SwitchProng:                                      ; preds = %TryElse
  %33 = load %std.Progress*, %std.Progress** %self, align 8
  %34 = getelementptr inbounds %std.Progress, %std.Progress* %33, i32 0, i32 12
  %35 = load i64, i64* %34, align 8
  %36 = load %std.Progress*, %std.Progress** %self, align 8
  %37 = load i64*, i64** %end, align 8
  %38 = load i64, i64* %37, align 8
  %39 = sub nuw i64 100, %38
  %40 = add nuw i64 %35, %39
  store i64 %40, i64* %34, align 8
  %41 = load i64*, i64** %end, align 8
  %42 = load %std.Progress*, %std.Progress** %self, align 8
  store i64 100, i64* %41, align 8
  br label %SwitchEnd

SwitchEnd:                                        ; preds = %SwitchProng
  br label %TryEnd

TryEnd:                                           ; preds = %SwitchEnd, %TryOk
  %43 = load %std.Progress*, %std.Progress** %self, align 8
  %44 = getelementptr inbounds %std.Progress, %std.Progress* %43, i32 0, i32 1
  %45 = load i1, i1* %44, align 1
  br i1 %45, label %Then, label %Else

Then:                                             ; preds = %TryEnd
  store i8 0, i8* %bytes_needed_for_esc_codes_at_end, align 1
  br label %EndIf

Else:                                             ; preds = %TryEnd
  store i8 11, i8* %bytes_needed_for_esc_codes_at_end, align 1
  br label %EndIf

EndIf:                                            ; preds = %Else, %Then
  %46 = load %std.Progress*, %std.Progress** %self, align 8
  %47 = load i8, i8* %bytes_needed_for_esc_codes_at_end, align 1
  %48 = zext i8 %47 to i64
  %49 = sub nuw i64 100, %48
  store i64 %49, i64* %max_end, align 8
  %50 = load i64*, i64** %end, align 8
  %51 = load i64, i64* %50, align 8
  %52 = load i64, i64* %max_end, align 8
  %53 = icmp ugt i64 %51, %52
  br i1 %53, label %Then1, label %Else2

Then1:                                            ; preds = %EndIf
  %54 = load %std.Progress*, %std.Progress** %self, align 8
  %55 = getelementptr inbounds %std.Progress, %std.Progress* %54, i32 0, i32 12
  %56 = load %std.Progress*, %std.Progress** %self, align 8
  %57 = getelementptr inbounds %std.Progress, %std.Progress* %56, i32 0, i32 12
  %58 = load i64, i64* %57, align 8
  %59 = load i64*, i64** %end, align 8
  %60 = load i64, i64* %59, align 8
  %61 = load i64, i64* %max_end, align 8
  %62 = sub nuw i64 %60, %61
  %63 = sub nuw i64 %58, %62
  %64 = add nuw i64 %63, 4
  store i64 %64, i64* %55, align 8
  %65 = load %std.Progress*, %std.Progress** %self, align 8
  %66 = getelementptr inbounds %std.Progress, %std.Progress* %65, i32 0, i32 7
  %67 = load i64, i64* %max_end, align 8
  %68 = getelementptr inbounds [100 x i8], [100 x i8]* %66, i64 0, i64 %67
  %69 = sub nuw i64 100, %67
  %70 = getelementptr inbounds %"[]u8", %"[]u8"* %4, i32 0, i32 0
  store i8* %68, i8** %70, align 8
  %71 = getelementptr inbounds %"[]u8", %"[]u8"* %4, i32 0, i32 1
  store i64 %69, i64* %71, align 8
  call fastcc void @std.mem.copy(%"[]u8"* %4, %"[]u8"* @149)
  %72 = load i64*, i64** %end, align 8
  %73 = load i64, i64* %max_end, align 8
  %74 = add nuw i64 %73, 4
  store i64 %74, i64* %72, align 8
  br label %EndIf3

Else2:                                            ; preds = %EndIf
  br label %EndIf3

EndIf3:                                           ; preds = %Else2, %Then1
  ret void

SwitchElse:                                       ; preds = %TryElse
  unreachable
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.Progress.bufWrite.63(%std.Progress* nonnull align 8 %0, i64* nonnull align 8 %1, %"std.Progress.struct:269:56"* nonnull readonly align 8 %2) unnamed_addr #1 {
Entry:
  %3 = alloca %"[]u8", align 8
  %4 = alloca %"std.Progress.struct:269:56", align 8
  %5 = alloca { %"[]u8", i16 }, align 8
  %written = alloca %"[]u8", align 8
  %amt = alloca i64, align 8
  %err = alloca i16, align 2
  %bytes_needed_for_esc_codes_at_end = alloca i8, align 1
  %max_end = alloca i64, align 8
  %6 = alloca %"[]u8", align 8
  %self = alloca %std.Progress*, align 8
  %end = alloca i64*, align 8
  store %std.Progress* %0, %std.Progress** %self, align 8
  store i64* %1, i64** %end, align 8
  %7 = load %std.Progress*, %std.Progress** %self, align 8
  %8 = getelementptr inbounds %std.Progress, %std.Progress* %7, i32 0, i32 7
  %9 = load i64*, i64** %end, align 8
  %10 = load i64, i64* %9, align 8
  %11 = getelementptr inbounds [100 x i8], [100 x i8]* %8, i64 0, i64 %10
  %12 = sub nuw i64 100, %10
  %13 = getelementptr inbounds %"[]u8", %"[]u8"* %3, i32 0, i32 0
  store i8* %11, i8** %13, align 8
  %14 = getelementptr inbounds %"[]u8", %"[]u8"* %3, i32 0, i32 1
  store i64 %12, i64* %14, align 8
  %15 = bitcast %"std.Progress.struct:269:56"* %2 to i8*
  %16 = bitcast %"std.Progress.struct:269:56"* %4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %16, i8* align 8 %15, i64 16, i1 false)
  call fastcc void @std.fmt.bufPrint.95({ %"[]u8", i16 }* sret({ %"[]u8", i16 }) %5, %"[]u8"* %3, %"std.Progress.struct:269:56"* %2)
  %17 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %5, i32 0, i32 1
  %18 = load i16, i16* %17, align 2
  %19 = icmp ne i16 %18, 0
  br i1 %19, label %TryElse, label %TryOk

TryElse:                                          ; preds = %Entry
  %20 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %5, i32 0, i32 1
  %21 = load i16, i16* %20, align 2
  store i16 %21, i16* %err, align 2
  %22 = load i16, i16* %err, align 2
  switch i16 %22, label %SwitchElse [
    i16 4, label %SwitchProng
  ]

TryOk:                                            ; preds = %Entry
  %23 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %5, i32 0, i32 0
  %24 = bitcast %"[]u8"* %23 to i8*
  %25 = bitcast %"[]u8"* %written to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %25, i8* align 8 %24, i64 16, i1 false)
  %26 = getelementptr inbounds %"[]u8", %"[]u8"* %written, i32 0, i32 1
  %27 = load i64, i64* %26, align 8
  store i64 %27, i64* %amt, align 8
  %28 = load i64*, i64** %end, align 8
  %29 = load i64, i64* %28, align 8
  %30 = load i64, i64* %amt, align 8
  %31 = add nuw i64 %29, %30
  store i64 %31, i64* %28, align 8
  %32 = load %std.Progress*, %std.Progress** %self, align 8
  %33 = getelementptr inbounds %std.Progress, %std.Progress* %32, i32 0, i32 12
  %34 = load i64, i64* %33, align 8
  %35 = load i64, i64* %amt, align 8
  %36 = add nuw i64 %34, %35
  store i64 %36, i64* %33, align 8
  br label %TryEnd

SwitchProng:                                      ; preds = %TryElse
  %37 = load %std.Progress*, %std.Progress** %self, align 8
  %38 = getelementptr inbounds %std.Progress, %std.Progress* %37, i32 0, i32 12
  %39 = load i64, i64* %38, align 8
  %40 = load %std.Progress*, %std.Progress** %self, align 8
  %41 = load i64*, i64** %end, align 8
  %42 = load i64, i64* %41, align 8
  %43 = sub nuw i64 100, %42
  %44 = add nuw i64 %39, %43
  store i64 %44, i64* %38, align 8
  %45 = load i64*, i64** %end, align 8
  %46 = load %std.Progress*, %std.Progress** %self, align 8
  store i64 100, i64* %45, align 8
  br label %SwitchEnd

SwitchEnd:                                        ; preds = %SwitchProng
  br label %TryEnd

TryEnd:                                           ; preds = %SwitchEnd, %TryOk
  %47 = load %std.Progress*, %std.Progress** %self, align 8
  %48 = getelementptr inbounds %std.Progress, %std.Progress* %47, i32 0, i32 1
  %49 = load i1, i1* %48, align 1
  br i1 %49, label %Then, label %Else

Then:                                             ; preds = %TryEnd
  store i8 0, i8* %bytes_needed_for_esc_codes_at_end, align 1
  br label %EndIf

Else:                                             ; preds = %TryEnd
  store i8 11, i8* %bytes_needed_for_esc_codes_at_end, align 1
  br label %EndIf

EndIf:                                            ; preds = %Else, %Then
  %50 = load %std.Progress*, %std.Progress** %self, align 8
  %51 = load i8, i8* %bytes_needed_for_esc_codes_at_end, align 1
  %52 = zext i8 %51 to i64
  %53 = sub nuw i64 100, %52
  store i64 %53, i64* %max_end, align 8
  %54 = load i64*, i64** %end, align 8
  %55 = load i64, i64* %54, align 8
  %56 = load i64, i64* %max_end, align 8
  %57 = icmp ugt i64 %55, %56
  br i1 %57, label %Then1, label %Else2

Then1:                                            ; preds = %EndIf
  %58 = load %std.Progress*, %std.Progress** %self, align 8
  %59 = getelementptr inbounds %std.Progress, %std.Progress* %58, i32 0, i32 12
  %60 = load %std.Progress*, %std.Progress** %self, align 8
  %61 = getelementptr inbounds %std.Progress, %std.Progress* %60, i32 0, i32 12
  %62 = load i64, i64* %61, align 8
  %63 = load i64*, i64** %end, align 8
  %64 = load i64, i64* %63, align 8
  %65 = load i64, i64* %max_end, align 8
  %66 = sub nuw i64 %64, %65
  %67 = sub nuw i64 %62, %66
  %68 = add nuw i64 %67, 4
  store i64 %68, i64* %59, align 8
  %69 = load %std.Progress*, %std.Progress** %self, align 8
  %70 = getelementptr inbounds %std.Progress, %std.Progress* %69, i32 0, i32 7
  %71 = load i64, i64* %max_end, align 8
  %72 = getelementptr inbounds [100 x i8], [100 x i8]* %70, i64 0, i64 %71
  %73 = sub nuw i64 100, %71
  %74 = getelementptr inbounds %"[]u8", %"[]u8"* %6, i32 0, i32 0
  store i8* %72, i8** %74, align 8
  %75 = getelementptr inbounds %"[]u8", %"[]u8"* %6, i32 0, i32 1
  store i64 %73, i64* %75, align 8
  call fastcc void @std.mem.copy(%"[]u8"* %6, %"[]u8"* @147)
  %76 = load i64*, i64** %end, align 8
  %77 = load i64, i64* %max_end, align 8
  %78 = add nuw i64 %77, 4
  store i64 %78, i64* %76, align 8
  br label %EndIf3

Else2:                                            ; preds = %EndIf
  br label %EndIf3

EndIf3:                                           ; preds = %Else2, %Then1
  ret void

SwitchElse:                                       ; preds = %TryElse
  unreachable
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.Progress.bufWrite.64(%std.Progress* nonnull align 8 %0, i64* nonnull align 8 %1, %"std.Progress.struct:273:52"* nonnull readonly align 8 %2) unnamed_addr #1 {
Entry:
  %3 = alloca %"[]u8", align 8
  %4 = alloca %"std.Progress.struct:273:52", align 8
  %5 = alloca { %"[]u8", i16 }, align 8
  %written = alloca %"[]u8", align 8
  %amt = alloca i64, align 8
  %err = alloca i16, align 2
  %bytes_needed_for_esc_codes_at_end = alloca i8, align 1
  %max_end = alloca i64, align 8
  %6 = alloca %"[]u8", align 8
  %self = alloca %std.Progress*, align 8
  %end = alloca i64*, align 8
  store %std.Progress* %0, %std.Progress** %self, align 8
  store i64* %1, i64** %end, align 8
  %7 = load %std.Progress*, %std.Progress** %self, align 8
  %8 = getelementptr inbounds %std.Progress, %std.Progress* %7, i32 0, i32 7
  %9 = load i64*, i64** %end, align 8
  %10 = load i64, i64* %9, align 8
  %11 = getelementptr inbounds [100 x i8], [100 x i8]* %8, i64 0, i64 %10
  %12 = sub nuw i64 100, %10
  %13 = getelementptr inbounds %"[]u8", %"[]u8"* %3, i32 0, i32 0
  store i8* %11, i8** %13, align 8
  %14 = getelementptr inbounds %"[]u8", %"[]u8"* %3, i32 0, i32 1
  store i64 %12, i64* %14, align 8
  %15 = bitcast %"std.Progress.struct:273:52"* %2 to i8*
  %16 = bitcast %"std.Progress.struct:273:52"* %4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %16, i8* align 8 %15, i64 8, i1 false)
  call fastcc void @std.fmt.bufPrint.97({ %"[]u8", i16 }* sret({ %"[]u8", i16 }) %5, %"[]u8"* %3, %"std.Progress.struct:273:52"* %2)
  %17 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %5, i32 0, i32 1
  %18 = load i16, i16* %17, align 2
  %19 = icmp ne i16 %18, 0
  br i1 %19, label %TryElse, label %TryOk

TryElse:                                          ; preds = %Entry
  %20 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %5, i32 0, i32 1
  %21 = load i16, i16* %20, align 2
  store i16 %21, i16* %err, align 2
  %22 = load i16, i16* %err, align 2
  switch i16 %22, label %SwitchElse [
    i16 4, label %SwitchProng
  ]

TryOk:                                            ; preds = %Entry
  %23 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %5, i32 0, i32 0
  %24 = bitcast %"[]u8"* %23 to i8*
  %25 = bitcast %"[]u8"* %written to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %25, i8* align 8 %24, i64 16, i1 false)
  %26 = getelementptr inbounds %"[]u8", %"[]u8"* %written, i32 0, i32 1
  %27 = load i64, i64* %26, align 8
  store i64 %27, i64* %amt, align 8
  %28 = load i64*, i64** %end, align 8
  %29 = load i64, i64* %28, align 8
  %30 = load i64, i64* %amt, align 8
  %31 = add nuw i64 %29, %30
  store i64 %31, i64* %28, align 8
  %32 = load %std.Progress*, %std.Progress** %self, align 8
  %33 = getelementptr inbounds %std.Progress, %std.Progress* %32, i32 0, i32 12
  %34 = load i64, i64* %33, align 8
  %35 = load i64, i64* %amt, align 8
  %36 = add nuw i64 %34, %35
  store i64 %36, i64* %33, align 8
  br label %TryEnd

SwitchProng:                                      ; preds = %TryElse
  %37 = load %std.Progress*, %std.Progress** %self, align 8
  %38 = getelementptr inbounds %std.Progress, %std.Progress* %37, i32 0, i32 12
  %39 = load i64, i64* %38, align 8
  %40 = load %std.Progress*, %std.Progress** %self, align 8
  %41 = load i64*, i64** %end, align 8
  %42 = load i64, i64* %41, align 8
  %43 = sub nuw i64 100, %42
  %44 = add nuw i64 %39, %43
  store i64 %44, i64* %38, align 8
  %45 = load i64*, i64** %end, align 8
  %46 = load %std.Progress*, %std.Progress** %self, align 8
  store i64 100, i64* %45, align 8
  br label %SwitchEnd

SwitchEnd:                                        ; preds = %SwitchProng
  br label %TryEnd

TryEnd:                                           ; preds = %SwitchEnd, %TryOk
  %47 = load %std.Progress*, %std.Progress** %self, align 8
  %48 = getelementptr inbounds %std.Progress, %std.Progress* %47, i32 0, i32 1
  %49 = load i1, i1* %48, align 1
  br i1 %49, label %Then, label %Else

Then:                                             ; preds = %TryEnd
  store i8 0, i8* %bytes_needed_for_esc_codes_at_end, align 1
  br label %EndIf

Else:                                             ; preds = %TryEnd
  store i8 11, i8* %bytes_needed_for_esc_codes_at_end, align 1
  br label %EndIf

EndIf:                                            ; preds = %Else, %Then
  %50 = load %std.Progress*, %std.Progress** %self, align 8
  %51 = load i8, i8* %bytes_needed_for_esc_codes_at_end, align 1
  %52 = zext i8 %51 to i64
  %53 = sub nuw i64 100, %52
  store i64 %53, i64* %max_end, align 8
  %54 = load i64*, i64** %end, align 8
  %55 = load i64, i64* %54, align 8
  %56 = load i64, i64* %max_end, align 8
  %57 = icmp ugt i64 %55, %56
  br i1 %57, label %Then1, label %Else2

Then1:                                            ; preds = %EndIf
  %58 = load %std.Progress*, %std.Progress** %self, align 8
  %59 = getelementptr inbounds %std.Progress, %std.Progress* %58, i32 0, i32 12
  %60 = load %std.Progress*, %std.Progress** %self, align 8
  %61 = getelementptr inbounds %std.Progress, %std.Progress* %60, i32 0, i32 12
  %62 = load i64, i64* %61, align 8
  %63 = load i64*, i64** %end, align 8
  %64 = load i64, i64* %63, align 8
  %65 = load i64, i64* %max_end, align 8
  %66 = sub nuw i64 %64, %65
  %67 = sub nuw i64 %62, %66
  %68 = add nuw i64 %67, 4
  store i64 %68, i64* %59, align 8
  %69 = load %std.Progress*, %std.Progress** %self, align 8
  %70 = getelementptr inbounds %std.Progress, %std.Progress* %69, i32 0, i32 7
  %71 = load i64, i64* %max_end, align 8
  %72 = getelementptr inbounds [100 x i8], [100 x i8]* %70, i64 0, i64 %71
  %73 = sub nuw i64 100, %71
  %74 = getelementptr inbounds %"[]u8", %"[]u8"* %6, i32 0, i32 0
  store i8* %72, i8** %74, align 8
  %75 = getelementptr inbounds %"[]u8", %"[]u8"* %6, i32 0, i32 1
  store i64 %73, i64* %75, align 8
  call fastcc void @std.mem.copy(%"[]u8"* %6, %"[]u8"* @151)
  %76 = load i64*, i64** %end, align 8
  %77 = load i64, i64* %max_end, align 8
  %78 = add nuw i64 %77, 4
  store i64 %78, i64* %76, align 8
  br label %EndIf3

Else2:                                            ; preds = %EndIf
  br label %EndIf3

EndIf3:                                           ; preds = %Else2, %Then1
  ret void

SwitchElse:                                       ; preds = %TryElse
  unreachable
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.Progress.bufWrite.65(%std.Progress* nonnull align 8 %0, i64* nonnull align 8 %1) unnamed_addr #1 {
Entry:
  %2 = alloca %"[]u8", align 8
  %3 = alloca { %"[]u8", i16 }, align 8
  %written = alloca %"[]u8", align 8
  %amt = alloca i64, align 8
  %err = alloca i16, align 2
  %bytes_needed_for_esc_codes_at_end = alloca i8, align 1
  %max_end = alloca i64, align 8
  %4 = alloca %"[]u8", align 8
  %self = alloca %std.Progress*, align 8
  %end = alloca i64*, align 8
  store %std.Progress* %0, %std.Progress** %self, align 8
  store i64* %1, i64** %end, align 8
  %5 = load %std.Progress*, %std.Progress** %self, align 8
  %6 = getelementptr inbounds %std.Progress, %std.Progress* %5, i32 0, i32 7
  %7 = load i64*, i64** %end, align 8
  %8 = load i64, i64* %7, align 8
  %9 = getelementptr inbounds [100 x i8], [100 x i8]* %6, i64 0, i64 %8
  %10 = sub nuw i64 100, %8
  %11 = getelementptr inbounds %"[]u8", %"[]u8"* %2, i32 0, i32 0
  store i8* %9, i8** %11, align 8
  %12 = getelementptr inbounds %"[]u8", %"[]u8"* %2, i32 0, i32 1
  store i64 %10, i64* %12, align 8
  call fastcc void @std.fmt.bufPrint.98({ %"[]u8", i16 }* sret({ %"[]u8", i16 }) %3, %"[]u8"* %2)
  %13 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %3, i32 0, i32 1
  %14 = load i16, i16* %13, align 2
  %15 = icmp ne i16 %14, 0
  br i1 %15, label %TryElse, label %TryOk

TryElse:                                          ; preds = %Entry
  %16 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %3, i32 0, i32 1
  %17 = load i16, i16* %16, align 2
  store i16 %17, i16* %err, align 2
  %18 = load i16, i16* %err, align 2
  switch i16 %18, label %SwitchElse [
    i16 4, label %SwitchProng
  ]

TryOk:                                            ; preds = %Entry
  %19 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %3, i32 0, i32 0
  %20 = bitcast %"[]u8"* %19 to i8*
  %21 = bitcast %"[]u8"* %written to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %21, i8* align 8 %20, i64 16, i1 false)
  %22 = getelementptr inbounds %"[]u8", %"[]u8"* %written, i32 0, i32 1
  %23 = load i64, i64* %22, align 8
  store i64 %23, i64* %amt, align 8
  %24 = load i64*, i64** %end, align 8
  %25 = load i64, i64* %24, align 8
  %26 = load i64, i64* %amt, align 8
  %27 = add nuw i64 %25, %26
  store i64 %27, i64* %24, align 8
  %28 = load %std.Progress*, %std.Progress** %self, align 8
  %29 = getelementptr inbounds %std.Progress, %std.Progress* %28, i32 0, i32 12
  %30 = load i64, i64* %29, align 8
  %31 = load i64, i64* %amt, align 8
  %32 = add nuw i64 %30, %31
  store i64 %32, i64* %29, align 8
  br label %TryEnd

SwitchProng:                                      ; preds = %TryElse
  %33 = load %std.Progress*, %std.Progress** %self, align 8
  %34 = getelementptr inbounds %std.Progress, %std.Progress* %33, i32 0, i32 12
  %35 = load i64, i64* %34, align 8
  %36 = load %std.Progress*, %std.Progress** %self, align 8
  %37 = load i64*, i64** %end, align 8
  %38 = load i64, i64* %37, align 8
  %39 = sub nuw i64 100, %38
  %40 = add nuw i64 %35, %39
  store i64 %40, i64* %34, align 8
  %41 = load i64*, i64** %end, align 8
  %42 = load %std.Progress*, %std.Progress** %self, align 8
  store i64 100, i64* %41, align 8
  br label %SwitchEnd

SwitchEnd:                                        ; preds = %SwitchProng
  br label %TryEnd

TryEnd:                                           ; preds = %SwitchEnd, %TryOk
  %43 = load %std.Progress*, %std.Progress** %self, align 8
  %44 = getelementptr inbounds %std.Progress, %std.Progress* %43, i32 0, i32 1
  %45 = load i1, i1* %44, align 1
  br i1 %45, label %Then, label %Else

Then:                                             ; preds = %TryEnd
  store i8 0, i8* %bytes_needed_for_esc_codes_at_end, align 1
  br label %EndIf

Else:                                             ; preds = %TryEnd
  store i8 11, i8* %bytes_needed_for_esc_codes_at_end, align 1
  br label %EndIf

EndIf:                                            ; preds = %Else, %Then
  %46 = load %std.Progress*, %std.Progress** %self, align 8
  %47 = load i8, i8* %bytes_needed_for_esc_codes_at_end, align 1
  %48 = zext i8 %47 to i64
  %49 = sub nuw i64 100, %48
  store i64 %49, i64* %max_end, align 8
  %50 = load i64*, i64** %end, align 8
  %51 = load i64, i64* %50, align 8
  %52 = load i64, i64* %max_end, align 8
  %53 = icmp ugt i64 %51, %52
  br i1 %53, label %Then1, label %Else2

Then1:                                            ; preds = %EndIf
  %54 = load %std.Progress*, %std.Progress** %self, align 8
  %55 = getelementptr inbounds %std.Progress, %std.Progress* %54, i32 0, i32 12
  %56 = load %std.Progress*, %std.Progress** %self, align 8
  %57 = getelementptr inbounds %std.Progress, %std.Progress* %56, i32 0, i32 12
  %58 = load i64, i64* %57, align 8
  %59 = load i64*, i64** %end, align 8
  %60 = load i64, i64* %59, align 8
  %61 = load i64, i64* %max_end, align 8
  %62 = sub nuw i64 %60, %61
  %63 = sub nuw i64 %58, %62
  %64 = add nuw i64 %63, 4
  store i64 %64, i64* %55, align 8
  %65 = load %std.Progress*, %std.Progress** %self, align 8
  %66 = getelementptr inbounds %std.Progress, %std.Progress* %65, i32 0, i32 7
  %67 = load i64, i64* %max_end, align 8
  %68 = getelementptr inbounds [100 x i8], [100 x i8]* %66, i64 0, i64 %67
  %69 = sub nuw i64 100, %67
  %70 = getelementptr inbounds %"[]u8", %"[]u8"* %4, i32 0, i32 0
  store i8* %68, i8** %70, align 8
  %71 = getelementptr inbounds %"[]u8", %"[]u8"* %4, i32 0, i32 1
  store i64 %69, i64* %71, align 8
  call fastcc void @std.mem.copy(%"[]u8"* %4, %"[]u8"* @153)
  %72 = load i64*, i64** %end, align 8
  %73 = load i64, i64* %max_end, align 8
  %74 = add nuw i64 %73, 4
  store i64 %74, i64* %72, align 8
  br label %EndIf3

Else2:                                            ; preds = %EndIf
  br label %EndIf3

EndIf3:                                           ; preds = %Else2, %Then1
  ret void

SwitchElse:                                       ; preds = %TryElse
  unreachable
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i64 @std.time.Timer.read(%std.time.Timer* nonnull readonly align 8 %0) unnamed_addr #1 {
Entry:
  %result = alloca i64, align 8
  %clock = alloca i64, align 8
  %1 = call fastcc i64 @std.time.Timer.clockNative()
  %2 = getelementptr inbounds %std.time.Timer, %std.time.Timer* %0, i32 0, i32 1
  %3 = load i64, i64* %2, align 8
  %4 = sub nuw i64 %1, %3
  store i64 %4, i64* %clock, align 8
  %5 = load i64, i64* %clock, align 8
  %6 = call fastcc i64 @std.time.Timer.nativeDurationToNanos(%std.time.Timer* %0, i64 %5)
  store i64 %6, i64* %result, align 8
  %7 = load i64, i64* %result, align 8
  ret i64 %7
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.format.66(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %0, %"std.special.struct:62:49"* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %options = alloca %std.fmt.FormatOptions, align 8
  %2 = alloca i64, align 8
  %3 = alloca %std.fmt.FormatOptions, align 8
  %4 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %5 = alloca i16, align 2
  %6 = alloca i16, align 2
  %7 = alloca i64, align 8
  %8 = alloca %std.fmt.FormatOptions, align 8
  %9 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %10 = alloca i16, align 2
  %11 = alloca i16, align 2
  %12 = alloca %"[]u8", align 8
  %13 = alloca %std.fmt.FormatOptions, align 8
  %14 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %15 = alloca i16, align 2
  %16 = alloca i16, align 2
  %17 = bitcast %std.fmt.FormatOptions* %options to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %17, i8* align 8 bitcast ({ %"?usize", %"?usize", i2, <{ i8, [6 x i8] }> }* @154 to i8*), i64 40, i1 false)
  %18 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 0
  %19 = bitcast %"?usize"* %18 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %19, i8* align 8 bitcast (%"?usize"* @155 to i8*), i64 16, i1 false)
  %20 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 1
  %21 = bitcast %"?usize"* %20 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %21, i8* align 8 bitcast (%"?usize"* @156 to i8*), i64 16, i1 false)
  %22 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 2
  store i2 -2, i2* %22, align 1
  %23 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 3
  store i8 32, i8* %23, align 1
  %24 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 1
  %25 = bitcast %"?usize"* %24 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %25, i8* align 8 bitcast (%"?usize"* @160 to i8*), i64 16, i1 false)
  %26 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 0
  %27 = bitcast %"?usize"* %26 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %27, i8* align 8 bitcast (%"?usize"* @161 to i8*), i64 16, i1 false)
  %28 = getelementptr inbounds %"std.special.struct:62:49", %"std.special.struct:62:49"* %1, i32 0, i32 0
  %29 = load i64, i64* %28, align 8
  store i64 %29, i64* %2, align 8
  %30 = bitcast %std.fmt.FormatOptions* %options to i8*
  %31 = bitcast %std.fmt.FormatOptions* %3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %31, i8* align 8 %30, i64 40, i1 false)
  %32 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0 to i8*
  %33 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %33, i8* align 4 %32, i64 4, i1 false)
  %34 = call fastcc i16 @std.fmt.formatType.99(i64 %29, %std.fmt.FormatOptions* %options, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0, i64 3)
  store i16 %34, i16* %5, align 2
  %35 = icmp ne i16 %34, 0
  br i1 %35, label %ErrRetReturn, label %ErrRetContinue

ErrRetReturn:                                     ; preds = %Entry
  %36 = load i16, i16* %5, align 2
  store i16 %36, i16* %result, align 2
  ret i16 %36

ErrRetContinue:                                   ; preds = %Entry
  %37 = call fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).writeAll"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0, %"[]u8"* @162)
  store i16 %37, i16* %6, align 2
  %38 = icmp ne i16 %37, 0
  br i1 %38, label %ErrRetReturn1, label %ErrRetContinue2

ErrRetReturn1:                                    ; preds = %ErrRetContinue
  %39 = load i16, i16* %6, align 2
  store i16 %39, i16* %result, align 2
  ret i16 %39

ErrRetContinue2:                                  ; preds = %ErrRetContinue
  %40 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 0
  %41 = bitcast %"?usize"* %40 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %41, i8* align 8 bitcast (%"?usize"* @163 to i8*), i64 16, i1 false)
  %42 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 1
  %43 = bitcast %"?usize"* %42 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %43, i8* align 8 bitcast (%"?usize"* @164 to i8*), i64 16, i1 false)
  %44 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 2
  store i2 -2, i2* %44, align 1
  %45 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 3
  store i8 32, i8* %45, align 1
  %46 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 1
  %47 = bitcast %"?usize"* %46 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %47, i8* align 8 bitcast (%"?usize"* @167 to i8*), i64 16, i1 false)
  %48 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 0
  %49 = bitcast %"?usize"* %48 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %49, i8* align 8 bitcast (%"?usize"* @168 to i8*), i64 16, i1 false)
  %50 = getelementptr inbounds %"std.special.struct:62:49", %"std.special.struct:62:49"* %1, i32 0, i32 1
  %51 = load i64, i64* %50, align 8
  store i64 %51, i64* %7, align 8
  %52 = bitcast %std.fmt.FormatOptions* %options to i8*
  %53 = bitcast %std.fmt.FormatOptions* %8 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %53, i8* align 8 %52, i64 40, i1 false)
  %54 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0 to i8*
  %55 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %9 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %55, i8* align 4 %54, i64 4, i1 false)
  %56 = call fastcc i16 @std.fmt.formatType.100(i64 %51, %std.fmt.FormatOptions* %options, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0, i64 3)
  store i16 %56, i16* %10, align 2
  %57 = icmp ne i16 %56, 0
  br i1 %57, label %ErrRetReturn3, label %ErrRetContinue4

ErrRetReturn3:                                    ; preds = %ErrRetContinue2
  %58 = load i16, i16* %10, align 2
  store i16 %58, i16* %result, align 2
  ret i16 %58

ErrRetContinue4:                                  ; preds = %ErrRetContinue2
  %59 = call fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).writeAll"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0, %"[]u8"* @169)
  store i16 %59, i16* %11, align 2
  %60 = icmp ne i16 %59, 0
  br i1 %60, label %ErrRetReturn5, label %ErrRetContinue6

ErrRetReturn5:                                    ; preds = %ErrRetContinue4
  %61 = load i16, i16* %11, align 2
  store i16 %61, i16* %result, align 2
  ret i16 %61

ErrRetContinue6:                                  ; preds = %ErrRetContinue4
  %62 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 0
  %63 = bitcast %"?usize"* %62 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %63, i8* align 8 bitcast (%"?usize"* @170 to i8*), i64 16, i1 false)
  %64 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 1
  %65 = bitcast %"?usize"* %64 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %65, i8* align 8 bitcast (%"?usize"* @171 to i8*), i64 16, i1 false)
  %66 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 2
  store i2 -2, i2* %66, align 1
  %67 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 3
  store i8 32, i8* %67, align 1
  %68 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 1
  %69 = bitcast %"?usize"* %68 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %69, i8* align 8 bitcast (%"?usize"* @174 to i8*), i64 16, i1 false)
  %70 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 0
  %71 = bitcast %"?usize"* %70 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %71, i8* align 8 bitcast (%"?usize"* @175 to i8*), i64 16, i1 false)
  %72 = getelementptr inbounds %"std.special.struct:62:49", %"std.special.struct:62:49"* %1, i32 0, i32 2
  %73 = bitcast %"[]u8"* %72 to i8*
  %74 = bitcast %"[]u8"* %12 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %74, i8* align 8 %73, i64 16, i1 false)
  %75 = bitcast %std.fmt.FormatOptions* %options to i8*
  %76 = bitcast %std.fmt.FormatOptions* %13 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %76, i8* align 8 %75, i64 40, i1 false)
  %77 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0 to i8*
  %78 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %14 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %78, i8* align 4 %77, i64 4, i1 false)
  %79 = call fastcc i16 @std.fmt.formatType.101(%"[]u8"* %72, %std.fmt.FormatOptions* %options, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0, i64 3)
  store i16 %79, i16* %15, align 2
  %80 = icmp ne i16 %79, 0
  br i1 %80, label %ErrRetReturn7, label %ErrRetContinue8

ErrRetReturn7:                                    ; preds = %ErrRetContinue6
  %81 = load i16, i16* %15, align 2
  store i16 %81, i16* %result, align 2
  ret i16 %81

ErrRetContinue8:                                  ; preds = %ErrRetContinue6
  %82 = call fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).writeAll"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0, %"[]u8"* @176)
  store i16 %82, i16* %16, align 2
  %83 = icmp ne i16 %82, 0
  br i1 %83, label %ErrRetReturn9, label %ErrRetContinue10

ErrRetReturn9:                                    ; preds = %ErrRetContinue8
  %84 = load i16, i16* %16, align 2
  store i16 %84, i16* %result, align 2
  ret i16 %84

ErrRetContinue10:                                 ; preds = %ErrRetContinue8
  store i16 0, i16* %result, align 2
  ret i16 0
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.format.67(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %0, %"std.special.struct:76:61"* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %options = alloca %std.fmt.FormatOptions, align 8
  %2 = alloca %"[]u8", align 8
  %3 = alloca %std.fmt.FormatOptions, align 8
  %4 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %5 = alloca i16, align 2
  %6 = alloca i16, align 2
  %7 = bitcast %std.fmt.FormatOptions* %options to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %7, i8* align 8 bitcast ({ %"?usize", %"?usize", i2, <{ i8, [6 x i8] }> }* @181 to i8*), i64 40, i1 false)
  %8 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 0
  %9 = bitcast %"?usize"* %8 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %9, i8* align 8 bitcast (%"?usize"* @182 to i8*), i64 16, i1 false)
  %10 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 1
  %11 = bitcast %"?usize"* %10 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %11, i8* align 8 bitcast (%"?usize"* @183 to i8*), i64 16, i1 false)
  %12 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 2
  store i2 -2, i2* %12, align 1
  %13 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 3
  store i8 32, i8* %13, align 1
  %14 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 1
  %15 = bitcast %"?usize"* %14 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %15, i8* align 8 bitcast (%"?usize"* @187 to i8*), i64 16, i1 false)
  %16 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 0
  %17 = bitcast %"?usize"* %16 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %17, i8* align 8 bitcast (%"?usize"* @188 to i8*), i64 16, i1 false)
  %18 = getelementptr inbounds %"std.special.struct:76:61", %"std.special.struct:76:61"* %1, i32 0, i32 0
  %19 = bitcast %"[]u8"* %18 to i8*
  %20 = bitcast %"[]u8"* %2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %20, i8* align 8 %19, i64 16, i1 false)
  %21 = bitcast %std.fmt.FormatOptions* %options to i8*
  %22 = bitcast %std.fmt.FormatOptions* %3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %22, i8* align 8 %21, i64 40, i1 false)
  %23 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0 to i8*
  %24 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %24, i8* align 4 %23, i64 4, i1 false)
  %25 = call fastcc i16 @std.fmt.formatType.105(%"[]u8"* %18, %std.fmt.FormatOptions* %options, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0, i64 3)
  store i16 %25, i16* %5, align 2
  %26 = icmp ne i16 %25, 0
  br i1 %26, label %ErrRetReturn, label %ErrRetContinue

ErrRetReturn:                                     ; preds = %Entry
  %27 = load i16, i16* %5, align 2
  store i16 %27, i16* %result, align 2
  ret i16 %27

ErrRetContinue:                                   ; preds = %Entry
  %28 = call fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).writeAll"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0, %"[]u8"* @189)
  store i16 %28, i16* %6, align 2
  %29 = icmp ne i16 %28, 0
  br i1 %29, label %ErrRetReturn1, label %ErrRetContinue2

ErrRetReturn1:                                    ; preds = %ErrRetContinue
  %30 = load i16, i16* %6, align 2
  store i16 %30, i16* %result, align 2
  ret i16 %30

ErrRetContinue2:                                  ; preds = %ErrRetContinue
  store i16 0, i16* %result, align 2
  ret i16 0
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.format.68(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %0) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %options = alloca %std.fmt.FormatOptions, align 8
  %1 = alloca i16, align 2
  %2 = bitcast %std.fmt.FormatOptions* %options to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %2, i8* align 8 bitcast ({ %"?usize", %"?usize", i2, <{ i8, [6 x i8] }> }* @192 to i8*), i64 40, i1 false)
  %3 = call fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).writeAll"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0, %"[]u8"* @194)
  store i16 %3, i16* %1, align 2
  %4 = icmp ne i16 %3, 0
  br i1 %4, label %ErrRetReturn, label %ErrRetContinue

ErrRetReturn:                                     ; preds = %Entry
  %5 = load i16, i16* %1, align 2
  store i16 %5, i16* %result, align 2
  ret i16 %5

ErrRetContinue:                                   ; preds = %Entry
  store i16 0, i16* %result, align 2
  ret i16 0
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @"std.hash_map.HashMapUnmanaged(usize,std.heap.general_purpose_allocator.LargeAlloc,std.hash_map.AutoContext(usize),80).deallocate"(%"std.hash_map.HashMapUnmanaged(usize,std.heap.general_purpose_allocator.LargeAlloc,std.hash_map.AutoContext(usize),80)"* nonnull align 8 %0, %std.mem.Allocator* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %cap = alloca i32, align 4
  %meta_size = alloca i32, align 4
  %keys_start = alloca i64, align 8
  %keys_end = alloca i64, align 8
  %vals_start = alloca i64, align 8
  %vals_end = alloca i64, align 8
  %total_size = alloca i64, align 8
  %2 = alloca i8*, align 8
  %slice = alloca %"[]u8", align 8
  %3 = alloca %"[]u8", align 8
  %self = alloca %"std.hash_map.HashMapUnmanaged(usize,std.heap.general_purpose_allocator.LargeAlloc,std.hash_map.AutoContext(usize),80)"*, align 8
  store %"std.hash_map.HashMapUnmanaged(usize,std.heap.general_purpose_allocator.LargeAlloc,std.hash_map.AutoContext(usize),80)"* %0, %"std.hash_map.HashMapUnmanaged(usize,std.heap.general_purpose_allocator.LargeAlloc,std.hash_map.AutoContext(usize),80)"** %self, align 8
  %4 = load %"std.hash_map.HashMapUnmanaged(usize,std.heap.general_purpose_allocator.LargeAlloc,std.hash_map.AutoContext(usize),80)"*, %"std.hash_map.HashMapUnmanaged(usize,std.heap.general_purpose_allocator.LargeAlloc,std.hash_map.AutoContext(usize),80)"** %self, align 8
  %5 = getelementptr inbounds %"std.hash_map.HashMapUnmanaged(usize,std.heap.general_purpose_allocator.LargeAlloc,std.hash_map.AutoContext(usize),80)", %"std.hash_map.HashMapUnmanaged(usize,std.heap.general_purpose_allocator.LargeAlloc,std.hash_map.AutoContext(usize),80)"* %4, i32 0, i32 0
  %6 = load %std.hash_map.Metadata*, %std.hash_map.Metadata** %5, align 8
  %7 = icmp ne %std.hash_map.Metadata* %6, null
  %8 = icmp eq i1 %7, false
  br i1 %8, label %Then, label %Else

Then:                                             ; preds = %Entry
  ret void

Else:                                             ; preds = %Entry
  br label %EndIf

EndIf:                                            ; preds = %Else
  %9 = load %"std.hash_map.HashMapUnmanaged(usize,std.heap.general_purpose_allocator.LargeAlloc,std.hash_map.AutoContext(usize),80)"*, %"std.hash_map.HashMapUnmanaged(usize,std.heap.general_purpose_allocator.LargeAlloc,std.hash_map.AutoContext(usize),80)"** %self, align 8
  %10 = call fastcc i32 @"std.hash_map.HashMapUnmanaged(usize,std.heap.general_purpose_allocator.LargeAlloc,std.hash_map.AutoContext(usize),80).capacity"(%"std.hash_map.HashMapUnmanaged(usize,std.heap.general_purpose_allocator.LargeAlloc,std.hash_map.AutoContext(usize),80)"* %9)
  store i32 %10, i32* %cap, align 4
  %11 = load i32, i32* %cap, align 4
  %12 = mul nuw i32 %11, 1
  %13 = add nuw i32 20, %12
  store i32 %13, i32* %meta_size, align 4
  %14 = load i32, i32* %meta_size, align 4
  %15 = zext i32 %14 to i64
  %16 = call fastcc i64 @std.mem.alignForward(i64 %15, i64 8)
  store i64 %16, i64* %keys_start, align 8
  %17 = load i64, i64* %keys_start, align 8
  %18 = load i32, i32* %cap, align 4
  %19 = mul nuw i32 %18, 8
  %20 = zext i32 %19 to i64
  %21 = add nuw i64 %17, %20
  store i64 %21, i64* %keys_end, align 8
  %22 = load i64, i64* %keys_end, align 8
  %23 = call fastcc i64 @std.mem.alignForward(i64 %22, i64 8)
  store i64 %23, i64* %vals_start, align 8
  %24 = load i64, i64* %vals_start, align 8
  %25 = load i32, i32* %cap, align 4
  %26 = mul nuw i32 %25, 16
  %27 = zext i32 %26 to i64
  %28 = add nuw i64 %24, %27
  store i64 %28, i64* %vals_end, align 8
  %29 = load i64, i64* %vals_end, align 8
  %30 = call fastcc i64 @std.mem.alignForward(i64 %29, i64 8)
  store i64 %30, i64* %total_size, align 8
  %31 = load %"std.hash_map.HashMapUnmanaged(usize,std.heap.general_purpose_allocator.LargeAlloc,std.hash_map.AutoContext(usize),80)"*, %"std.hash_map.HashMapUnmanaged(usize,std.heap.general_purpose_allocator.LargeAlloc,std.hash_map.AutoContext(usize),80)"** %self, align 8
  %32 = call fastcc %std.hash_map.Header* @"std.hash_map.HashMapUnmanaged(usize,std.heap.general_purpose_allocator.LargeAlloc,std.hash_map.AutoContext(usize),80).header"(%"std.hash_map.HashMapUnmanaged(usize,std.heap.general_purpose_allocator.LargeAlloc,std.hash_map.AutoContext(usize),80)"* %31)
  %33 = ptrtoint %std.hash_map.Header* %32 to i64
  %34 = inttoptr i64 %33 to i8*
  store i8* %34, i8** %2, align 8
  %35 = load i64, i64* %total_size, align 8
  %36 = load i8*, i8** %2, align 8
  %37 = getelementptr inbounds i8, i8* %36, i64 0
  %38 = sub nuw i64 %35, 0
  %39 = getelementptr inbounds %"[]u8", %"[]u8"* %slice, i32 0, i32 0
  store i8* %37, i8** %39, align 8
  %40 = getelementptr inbounds %"[]u8", %"[]u8"* %slice, i32 0, i32 1
  store i64 %38, i64* %40, align 8
  %41 = bitcast %"[]u8"* %slice to i8*
  %42 = bitcast %"[]u8"* %3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %42, i8* align 8 %41, i64 16, i1 false)
  call fastcc void @std.mem.Allocator.free.107(%std.mem.Allocator* %1, %"[]u8"* %slice)
  %43 = load %"std.hash_map.HashMapUnmanaged(usize,std.heap.general_purpose_allocator.LargeAlloc,std.hash_map.AutoContext(usize),80)"*, %"std.hash_map.HashMapUnmanaged(usize,std.heap.general_purpose_allocator.LargeAlloc,std.hash_map.AutoContext(usize),80)"** %self, align 8
  %44 = getelementptr inbounds %"std.hash_map.HashMapUnmanaged(usize,std.heap.general_purpose_allocator.LargeAlloc,std.hash_map.AutoContext(usize),80)", %"std.hash_map.HashMapUnmanaged(usize,std.heap.general_purpose_allocator.LargeAlloc,std.hash_map.AutoContext(usize),80)"* %43, i32 0, i32 0
  store %std.hash_map.Metadata* null, %std.hash_map.Metadata** %44, align 8
  %45 = load %"std.hash_map.HashMapUnmanaged(usize,std.heap.general_purpose_allocator.LargeAlloc,std.hash_map.AutoContext(usize),80)"*, %"std.hash_map.HashMapUnmanaged(usize,std.heap.general_purpose_allocator.LargeAlloc,std.hash_map.AutoContext(usize),80)"** %self, align 8
  %46 = getelementptr inbounds %"std.hash_map.HashMapUnmanaged(usize,std.heap.general_purpose_allocator.LargeAlloc,std.hash_map.AutoContext(usize),80)", %"std.hash_map.HashMapUnmanaged(usize,std.heap.general_purpose_allocator.LargeAlloc,std.hash_map.AutoContext(usize),80)"* %45, i32 0, i32 2
  store i32 0, i32* %46, align 4
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.format.69(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %0) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %options = alloca %std.fmt.FormatOptions, align 8
  %1 = alloca i16, align 2
  %2 = bitcast %std.fmt.FormatOptions* %options to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %2, i8* align 8 bitcast ({ %"?usize", %"?usize", i2, <{ i8, [6 x i8] }> }* @195 to i8*), i64 40, i1 false)
  %3 = call fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).writeAll"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0, %"[]u8"* @197)
  store i16 %3, i16* %1, align 2
  %4 = icmp ne i16 %3, 0
  br i1 %4, label %ErrRetReturn, label %ErrRetContinue

ErrRetReturn:                                     ; preds = %Entry
  %5 = load i16, i16* %1, align 2
  store i16 %5, i16* %result, align 2
  ret i16 %5

ErrRetContinue:                                   ; preds = %Entry
  store i16 0, i16* %result, align 2
  ret i16 0
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.format.70(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %0, %"std.special.struct:95:54"* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %options = alloca %std.fmt.FormatOptions, align 8
  %2 = alloca %"[]u8", align 8
  %3 = alloca %std.fmt.FormatOptions, align 8
  %4 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %5 = alloca i16, align 2
  %6 = alloca i16, align 2
  %7 = alloca %"[]u8", align 8
  %8 = alloca %std.fmt.FormatOptions, align 8
  %9 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %10 = alloca i16, align 2
  %11 = alloca i16, align 2
  %12 = bitcast %std.fmt.FormatOptions* %options to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %12, i8* align 8 bitcast ({ %"?usize", %"?usize", i2, <{ i8, [6 x i8] }> }* @198 to i8*), i64 40, i1 false)
  %13 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 0
  %14 = bitcast %"?usize"* %13 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %14, i8* align 8 bitcast (%"?usize"* @199 to i8*), i64 16, i1 false)
  %15 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 1
  %16 = bitcast %"?usize"* %15 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %16, i8* align 8 bitcast (%"?usize"* @200 to i8*), i64 16, i1 false)
  %17 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 2
  store i2 -2, i2* %17, align 1
  %18 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 3
  store i8 32, i8* %18, align 1
  %19 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 1
  %20 = bitcast %"?usize"* %19 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %20, i8* align 8 bitcast (%"?usize"* @204 to i8*), i64 16, i1 false)
  %21 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 0
  %22 = bitcast %"?usize"* %21 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %22, i8* align 8 bitcast (%"?usize"* @205 to i8*), i64 16, i1 false)
  %23 = getelementptr inbounds %"std.special.struct:95:54", %"std.special.struct:95:54"* %1, i32 0, i32 0
  %24 = bitcast %"[]u8"* %23 to i8*
  %25 = bitcast %"[]u8"* %2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %25, i8* align 8 %24, i64 16, i1 false)
  %26 = bitcast %std.fmt.FormatOptions* %options to i8*
  %27 = bitcast %std.fmt.FormatOptions* %3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %27, i8* align 8 %26, i64 40, i1 false)
  %28 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0 to i8*
  %29 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %29, i8* align 4 %28, i64 4, i1 false)
  %30 = call fastcc i16 @std.fmt.formatType.108(%"[]u8"* %23, %std.fmt.FormatOptions* %options, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0, i64 3)
  store i16 %30, i16* %5, align 2
  %31 = icmp ne i16 %30, 0
  br i1 %31, label %ErrRetReturn, label %ErrRetContinue

ErrRetReturn:                                     ; preds = %Entry
  %32 = load i16, i16* %5, align 2
  store i16 %32, i16* %result, align 2
  ret i16 %32

ErrRetContinue:                                   ; preds = %Entry
  %33 = call fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).writeAll"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0, %"[]u8"* @206)
  store i16 %33, i16* %6, align 2
  %34 = icmp ne i16 %33, 0
  br i1 %34, label %ErrRetReturn1, label %ErrRetContinue2

ErrRetReturn1:                                    ; preds = %ErrRetContinue
  %35 = load i16, i16* %6, align 2
  store i16 %35, i16* %result, align 2
  ret i16 %35

ErrRetContinue2:                                  ; preds = %ErrRetContinue
  %36 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 0
  %37 = bitcast %"?usize"* %36 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %37, i8* align 8 bitcast (%"?usize"* @207 to i8*), i64 16, i1 false)
  %38 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 1
  %39 = bitcast %"?usize"* %38 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %39, i8* align 8 bitcast (%"?usize"* @208 to i8*), i64 16, i1 false)
  %40 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 2
  store i2 -2, i2* %40, align 1
  %41 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 3
  store i8 32, i8* %41, align 1
  %42 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 1
  %43 = bitcast %"?usize"* %42 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %43, i8* align 8 bitcast (%"?usize"* @211 to i8*), i64 16, i1 false)
  %44 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 0
  %45 = bitcast %"?usize"* %44 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %45, i8* align 8 bitcast (%"?usize"* @212 to i8*), i64 16, i1 false)
  %46 = getelementptr inbounds %"std.special.struct:95:54", %"std.special.struct:95:54"* %1, i32 0, i32 1
  %47 = bitcast %"[]u8"* %46 to i8*
  %48 = bitcast %"[]u8"* %7 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %48, i8* align 8 %47, i64 16, i1 false)
  %49 = bitcast %std.fmt.FormatOptions* %options to i8*
  %50 = bitcast %std.fmt.FormatOptions* %8 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %50, i8* align 8 %49, i64 40, i1 false)
  %51 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0 to i8*
  %52 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %9 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %52, i8* align 4 %51, i64 4, i1 false)
  %53 = call fastcc i16 @std.fmt.formatType.109(%"[]u8"* %46, %std.fmt.FormatOptions* %options, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0, i64 3)
  store i16 %53, i16* %10, align 2
  %54 = icmp ne i16 %53, 0
  br i1 %54, label %ErrRetReturn3, label %ErrRetContinue4

ErrRetReturn3:                                    ; preds = %ErrRetContinue2
  %55 = load i16, i16* %10, align 2
  store i16 %55, i16* %result, align 2
  ret i16 %55

ErrRetContinue4:                                  ; preds = %ErrRetContinue2
  %56 = call fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).writeAll"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0, %"[]u8"* @213)
  store i16 %56, i16* %11, align 2
  %57 = icmp ne i16 %56, 0
  br i1 %57, label %ErrRetReturn5, label %ErrRetContinue6

ErrRetReturn5:                                    ; preds = %ErrRetContinue4
  %58 = load i16, i16* %11, align 2
  store i16 %58, i16* %result, align 2
  ret i16 %58

ErrRetContinue6:                                  ; preds = %ErrRetContinue4
  store i16 0, i16* %result, align 2
  ret i16 0
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.format.71(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %0, %"std.special.struct:96:65"* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %options = alloca %std.fmt.FormatOptions, align 8
  %2 = alloca i16, align 2
  %3 = alloca %"[]u8", align 8
  %4 = alloca %std.fmt.FormatOptions, align 8
  %5 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %6 = alloca i16, align 2
  %7 = alloca i16, align 2
  %8 = bitcast %std.fmt.FormatOptions* %options to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %8, i8* align 8 bitcast ({ %"?usize", %"?usize", i2, <{ i8, [6 x i8] }> }* @218 to i8*), i64 40, i1 false)
  %9 = call fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).writeAll"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0, %"[]u8"* @220)
  store i16 %9, i16* %2, align 2
  %10 = icmp ne i16 %9, 0
  br i1 %10, label %ErrRetReturn, label %ErrRetContinue

ErrRetReturn:                                     ; preds = %Entry
  %11 = load i16, i16* %2, align 2
  store i16 %11, i16* %result, align 2
  ret i16 %11

ErrRetContinue:                                   ; preds = %Entry
  %12 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 0
  %13 = bitcast %"?usize"* %12 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %13, i8* align 8 bitcast (%"?usize"* @221 to i8*), i64 16, i1 false)
  %14 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 1
  %15 = bitcast %"?usize"* %14 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %15, i8* align 8 bitcast (%"?usize"* @222 to i8*), i64 16, i1 false)
  %16 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 2
  store i2 -2, i2* %16, align 1
  %17 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 3
  store i8 32, i8* %17, align 1
  %18 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 1
  %19 = bitcast %"?usize"* %18 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %19, i8* align 8 bitcast (%"?usize"* @225 to i8*), i64 16, i1 false)
  %20 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 0
  %21 = bitcast %"?usize"* %20 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %21, i8* align 8 bitcast (%"?usize"* @226 to i8*), i64 16, i1 false)
  %22 = getelementptr inbounds %"std.special.struct:96:65", %"std.special.struct:96:65"* %1, i32 0, i32 0
  %23 = bitcast %"[]u8"* %22 to i8*
  %24 = bitcast %"[]u8"* %3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %24, i8* align 8 %23, i64 16, i1 false)
  %25 = bitcast %std.fmt.FormatOptions* %options to i8*
  %26 = bitcast %std.fmt.FormatOptions* %4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %26, i8* align 8 %25, i64 40, i1 false)
  %27 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0 to i8*
  %28 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %28, i8* align 4 %27, i64 4, i1 false)
  %29 = call fastcc i16 @std.fmt.formatType.112(%"[]u8"* %22, %std.fmt.FormatOptions* %options, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0, i64 3)
  store i16 %29, i16* %6, align 2
  %30 = icmp ne i16 %29, 0
  br i1 %30, label %ErrRetReturn1, label %ErrRetContinue2

ErrRetReturn1:                                    ; preds = %ErrRetContinue
  %31 = load i16, i16* %6, align 2
  store i16 %31, i16* %result, align 2
  ret i16 %31

ErrRetContinue2:                                  ; preds = %ErrRetContinue
  %32 = call fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).writeAll"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0, %"[]u8"* @227)
  store i16 %32, i16* %7, align 2
  %33 = icmp ne i16 %32, 0
  br i1 %33, label %ErrRetReturn3, label %ErrRetContinue4

ErrRetReturn3:                                    ; preds = %ErrRetContinue2
  %34 = load i16, i16* %7, align 2
  store i16 %34, i16* %result, align 2
  ret i16 %34

ErrRetContinue4:                                  ; preds = %ErrRetContinue2
  store i16 0, i16* %result, align 2
  ret i16 0
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.format.72(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %0, %"std.special.struct:89:48"* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %options = alloca %std.fmt.FormatOptions, align 8
  %2 = alloca %"[]u8", align 8
  %3 = alloca %std.fmt.FormatOptions, align 8
  %4 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %5 = alloca i16, align 2
  %6 = alloca i16, align 2
  %7 = bitcast %std.fmt.FormatOptions* %options to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %7, i8* align 8 bitcast ({ %"?usize", %"?usize", i2, <{ i8, [6 x i8] }> }* @230 to i8*), i64 40, i1 false)
  %8 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 0
  %9 = bitcast %"?usize"* %8 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %9, i8* align 8 bitcast (%"?usize"* @231 to i8*), i64 16, i1 false)
  %10 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 1
  %11 = bitcast %"?usize"* %10 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %11, i8* align 8 bitcast (%"?usize"* @232 to i8*), i64 16, i1 false)
  %12 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 2
  store i2 -2, i2* %12, align 1
  %13 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 3
  store i8 32, i8* %13, align 1
  %14 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 1
  %15 = bitcast %"?usize"* %14 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %15, i8* align 8 bitcast (%"?usize"* @236 to i8*), i64 16, i1 false)
  %16 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 0
  %17 = bitcast %"?usize"* %16 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %17, i8* align 8 bitcast (%"?usize"* @237 to i8*), i64 16, i1 false)
  %18 = getelementptr inbounds %"std.special.struct:89:48", %"std.special.struct:89:48"* %1, i32 0, i32 0
  %19 = bitcast %"[]u8"* %18 to i8*
  %20 = bitcast %"[]u8"* %2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %20, i8* align 8 %19, i64 16, i1 false)
  %21 = bitcast %std.fmt.FormatOptions* %options to i8*
  %22 = bitcast %std.fmt.FormatOptions* %3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %22, i8* align 8 %21, i64 40, i1 false)
  %23 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0 to i8*
  %24 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %24, i8* align 4 %23, i64 4, i1 false)
  %25 = call fastcc i16 @std.fmt.formatType.114(%"[]u8"* %18, %std.fmt.FormatOptions* %options, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0, i64 3)
  store i16 %25, i16* %5, align 2
  %26 = icmp ne i16 %25, 0
  br i1 %26, label %ErrRetReturn, label %ErrRetContinue

ErrRetReturn:                                     ; preds = %Entry
  %27 = load i16, i16* %5, align 2
  store i16 %27, i16* %result, align 2
  ret i16 %27

ErrRetContinue:                                   ; preds = %Entry
  %28 = call fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).writeAll"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0, %"[]u8"* @238)
  store i16 %28, i16* %6, align 2
  %29 = icmp ne i16 %28, 0
  br i1 %29, label %ErrRetReturn1, label %ErrRetContinue2

ErrRetReturn1:                                    ; preds = %ErrRetContinue
  %30 = load i16, i16* %6, align 2
  store i16 %30, i16* %result, align 2
  ret i16 %30

ErrRetContinue2:                                  ; preds = %ErrRetContinue
  store i16 0, i16* %result, align 2
  ret i16 0
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.format.73(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %0) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %options = alloca %std.fmt.FormatOptions, align 8
  %1 = alloca i16, align 2
  %2 = bitcast %std.fmt.FormatOptions* %options to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %2, i8* align 8 bitcast ({ %"?usize", %"?usize", i2, <{ i8, [6 x i8] }> }* @241 to i8*), i64 40, i1 false)
  %3 = call fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).writeAll"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0, %"[]u8"* @243)
  store i16 %3, i16* %1, align 2
  %4 = icmp ne i16 %3, 0
  br i1 %4, label %ErrRetReturn, label %ErrRetContinue

ErrRetReturn:                                     ; preds = %Entry
  %5 = load i16, i16* %1, align 2
  store i16 %5, i16* %result, align 2
  ret i16 %5

ErrRetContinue:                                   ; preds = %Entry
  store i16 0, i16* %result, align 2
  ret i16 0
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.format.74(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %0, %"std.special.struct:105:53"* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %options = alloca %std.fmt.FormatOptions, align 8
  %2 = alloca i16, align 2
  %3 = alloca i64, align 8
  %4 = alloca %std.fmt.FormatOptions, align 8
  %5 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %6 = alloca i16, align 2
  %7 = alloca i16, align 2
  %8 = bitcast %std.fmt.FormatOptions* %options to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %8, i8* align 8 bitcast ({ %"?usize", %"?usize", i2, <{ i8, [6 x i8] }> }* @244 to i8*), i64 40, i1 false)
  %9 = call fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).writeAll"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0, %"[]u8"* @246)
  store i16 %9, i16* %2, align 2
  %10 = icmp ne i16 %9, 0
  br i1 %10, label %ErrRetReturn, label %ErrRetContinue

ErrRetReturn:                                     ; preds = %Entry
  %11 = load i16, i16* %2, align 2
  store i16 %11, i16* %result, align 2
  ret i16 %11

ErrRetContinue:                                   ; preds = %Entry
  %12 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 0
  %13 = bitcast %"?usize"* %12 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %13, i8* align 8 bitcast (%"?usize"* @247 to i8*), i64 16, i1 false)
  %14 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 1
  %15 = bitcast %"?usize"* %14 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %15, i8* align 8 bitcast (%"?usize"* @248 to i8*), i64 16, i1 false)
  %16 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 2
  store i2 -2, i2* %16, align 1
  %17 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 3
  store i8 32, i8* %17, align 1
  %18 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 1
  %19 = bitcast %"?usize"* %18 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %19, i8* align 8 bitcast (%"?usize"* @251 to i8*), i64 16, i1 false)
  %20 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 0
  %21 = bitcast %"?usize"* %20 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %21, i8* align 8 bitcast (%"?usize"* @252 to i8*), i64 16, i1 false)
  %22 = getelementptr inbounds %"std.special.struct:105:53", %"std.special.struct:105:53"* %1, i32 0, i32 0
  %23 = load i64, i64* %22, align 8
  store i64 %23, i64* %3, align 8
  %24 = bitcast %std.fmt.FormatOptions* %options to i8*
  %25 = bitcast %std.fmt.FormatOptions* %4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %25, i8* align 8 %24, i64 40, i1 false)
  %26 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0 to i8*
  %27 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %27, i8* align 4 %26, i64 4, i1 false)
  %28 = call fastcc i16 @std.fmt.formatType.116(i64 %23, %std.fmt.FormatOptions* %options, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0, i64 3)
  store i16 %28, i16* %6, align 2
  %29 = icmp ne i16 %28, 0
  br i1 %29, label %ErrRetReturn1, label %ErrRetContinue2

ErrRetReturn1:                                    ; preds = %ErrRetContinue
  %30 = load i16, i16* %6, align 2
  store i16 %30, i16* %result, align 2
  ret i16 %30

ErrRetContinue2:                                  ; preds = %ErrRetContinue
  %31 = call fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).writeAll"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0, %"[]u8"* @253)
  store i16 %31, i16* %7, align 2
  %32 = icmp ne i16 %31, 0
  br i1 %32, label %ErrRetReturn3, label %ErrRetContinue4

ErrRetReturn3:                                    ; preds = %ErrRetContinue2
  %33 = load i16, i16* %7, align 2
  store i16 %33, i16* %result, align 2
  ret i16 %33

ErrRetContinue4:                                  ; preds = %ErrRetContinue2
  store i16 0, i16* %result, align 2
  ret i16 0
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.format.75(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %0, %"std.special.struct:107:68"* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %options = alloca %std.fmt.FormatOptions, align 8
  %2 = alloca i64, align 8
  %3 = alloca %std.fmt.FormatOptions, align 8
  %4 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %5 = alloca i16, align 2
  %6 = alloca i16, align 2
  %7 = alloca i64, align 8
  %8 = alloca %std.fmt.FormatOptions, align 8
  %9 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %10 = alloca i16, align 2
  %11 = alloca i16, align 2
  %12 = alloca i64, align 8
  %13 = alloca %std.fmt.FormatOptions, align 8
  %14 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %15 = alloca i16, align 2
  %16 = alloca i16, align 2
  %17 = bitcast %std.fmt.FormatOptions* %options to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %17, i8* align 8 bitcast ({ %"?usize", %"?usize", i2, <{ i8, [6 x i8] }> }* @255 to i8*), i64 40, i1 false)
  %18 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 0
  %19 = bitcast %"?usize"* %18 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %19, i8* align 8 bitcast (%"?usize"* @256 to i8*), i64 16, i1 false)
  %20 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 1
  %21 = bitcast %"?usize"* %20 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %21, i8* align 8 bitcast (%"?usize"* @257 to i8*), i64 16, i1 false)
  %22 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 2
  store i2 -2, i2* %22, align 1
  %23 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 3
  store i8 32, i8* %23, align 1
  %24 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 1
  %25 = bitcast %"?usize"* %24 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %25, i8* align 8 bitcast (%"?usize"* @261 to i8*), i64 16, i1 false)
  %26 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 0
  %27 = bitcast %"?usize"* %26 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %27, i8* align 8 bitcast (%"?usize"* @262 to i8*), i64 16, i1 false)
  %28 = getelementptr inbounds %"std.special.struct:107:68", %"std.special.struct:107:68"* %1, i32 0, i32 0
  %29 = load i64, i64* %28, align 8
  store i64 %29, i64* %2, align 8
  %30 = bitcast %std.fmt.FormatOptions* %options to i8*
  %31 = bitcast %std.fmt.FormatOptions* %3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %31, i8* align 8 %30, i64 40, i1 false)
  %32 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0 to i8*
  %33 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %33, i8* align 4 %32, i64 4, i1 false)
  %34 = call fastcc i16 @std.fmt.formatType.118(i64 %29, %std.fmt.FormatOptions* %options, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0, i64 3)
  store i16 %34, i16* %5, align 2
  %35 = icmp ne i16 %34, 0
  br i1 %35, label %ErrRetReturn, label %ErrRetContinue

ErrRetReturn:                                     ; preds = %Entry
  %36 = load i16, i16* %5, align 2
  store i16 %36, i16* %result, align 2
  ret i16 %36

ErrRetContinue:                                   ; preds = %Entry
  %37 = call fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).writeAll"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0, %"[]u8"* @263)
  store i16 %37, i16* %6, align 2
  %38 = icmp ne i16 %37, 0
  br i1 %38, label %ErrRetReturn1, label %ErrRetContinue2

ErrRetReturn1:                                    ; preds = %ErrRetContinue
  %39 = load i16, i16* %6, align 2
  store i16 %39, i16* %result, align 2
  ret i16 %39

ErrRetContinue2:                                  ; preds = %ErrRetContinue
  %40 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 0
  %41 = bitcast %"?usize"* %40 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %41, i8* align 8 bitcast (%"?usize"* @264 to i8*), i64 16, i1 false)
  %42 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 1
  %43 = bitcast %"?usize"* %42 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %43, i8* align 8 bitcast (%"?usize"* @265 to i8*), i64 16, i1 false)
  %44 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 2
  store i2 -2, i2* %44, align 1
  %45 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 3
  store i8 32, i8* %45, align 1
  %46 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 1
  %47 = bitcast %"?usize"* %46 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %47, i8* align 8 bitcast (%"?usize"* @268 to i8*), i64 16, i1 false)
  %48 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 0
  %49 = bitcast %"?usize"* %48 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %49, i8* align 8 bitcast (%"?usize"* @269 to i8*), i64 16, i1 false)
  %50 = getelementptr inbounds %"std.special.struct:107:68", %"std.special.struct:107:68"* %1, i32 0, i32 1
  %51 = load i64, i64* %50, align 8
  store i64 %51, i64* %7, align 8
  %52 = bitcast %std.fmt.FormatOptions* %options to i8*
  %53 = bitcast %std.fmt.FormatOptions* %8 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %53, i8* align 8 %52, i64 40, i1 false)
  %54 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0 to i8*
  %55 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %9 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %55, i8* align 4 %54, i64 4, i1 false)
  %56 = call fastcc i16 @std.fmt.formatType.119(i64 %51, %std.fmt.FormatOptions* %options, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0, i64 3)
  store i16 %56, i16* %10, align 2
  %57 = icmp ne i16 %56, 0
  br i1 %57, label %ErrRetReturn3, label %ErrRetContinue4

ErrRetReturn3:                                    ; preds = %ErrRetContinue2
  %58 = load i16, i16* %10, align 2
  store i16 %58, i16* %result, align 2
  ret i16 %58

ErrRetContinue4:                                  ; preds = %ErrRetContinue2
  %59 = call fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).writeAll"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0, %"[]u8"* @270)
  store i16 %59, i16* %11, align 2
  %60 = icmp ne i16 %59, 0
  br i1 %60, label %ErrRetReturn5, label %ErrRetContinue6

ErrRetReturn5:                                    ; preds = %ErrRetContinue4
  %61 = load i16, i16* %11, align 2
  store i16 %61, i16* %result, align 2
  ret i16 %61

ErrRetContinue6:                                  ; preds = %ErrRetContinue4
  %62 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 0
  %63 = bitcast %"?usize"* %62 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %63, i8* align 8 bitcast (%"?usize"* @271 to i8*), i64 16, i1 false)
  %64 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 1
  %65 = bitcast %"?usize"* %64 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %65, i8* align 8 bitcast (%"?usize"* @272 to i8*), i64 16, i1 false)
  %66 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 2
  store i2 -2, i2* %66, align 1
  %67 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 3
  store i8 32, i8* %67, align 1
  %68 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 1
  %69 = bitcast %"?usize"* %68 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %69, i8* align 8 bitcast (%"?usize"* @275 to i8*), i64 16, i1 false)
  %70 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 0
  %71 = bitcast %"?usize"* %70 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %71, i8* align 8 bitcast (%"?usize"* @276 to i8*), i64 16, i1 false)
  %72 = getelementptr inbounds %"std.special.struct:107:68", %"std.special.struct:107:68"* %1, i32 0, i32 2
  %73 = load i64, i64* %72, align 8
  store i64 %73, i64* %12, align 8
  %74 = bitcast %std.fmt.FormatOptions* %options to i8*
  %75 = bitcast %std.fmt.FormatOptions* %13 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %75, i8* align 8 %74, i64 40, i1 false)
  %76 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0 to i8*
  %77 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %14 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %77, i8* align 4 %76, i64 4, i1 false)
  %78 = call fastcc i16 @std.fmt.formatType.120(i64 %73, %std.fmt.FormatOptions* %options, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0, i64 3)
  store i16 %78, i16* %15, align 2
  %79 = icmp ne i16 %78, 0
  br i1 %79, label %ErrRetReturn7, label %ErrRetContinue8

ErrRetReturn7:                                    ; preds = %ErrRetContinue6
  %80 = load i16, i16* %15, align 2
  store i16 %80, i16* %result, align 2
  ret i16 %80

ErrRetContinue8:                                  ; preds = %ErrRetContinue6
  %81 = call fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).writeAll"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0, %"[]u8"* @277)
  store i16 %81, i16* %16, align 2
  %82 = icmp ne i16 %81, 0
  br i1 %82, label %ErrRetReturn9, label %ErrRetContinue10

ErrRetReturn9:                                    ; preds = %ErrRetContinue8
  %83 = load i16, i16* %16, align 2
  store i16 %83, i16* %result, align 2
  ret i16 %83

ErrRetContinue10:                                 ; preds = %ErrRetContinue8
  store i16 0, i16* %result, align 2
  ret i16 0
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.format.76(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %0, %"std.special.struct:110:55"* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %options = alloca %std.fmt.FormatOptions, align 8
  %2 = alloca i64, align 8
  %3 = alloca %std.fmt.FormatOptions, align 8
  %4 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %5 = alloca i16, align 2
  %6 = alloca i16, align 2
  %7 = bitcast %std.fmt.FormatOptions* %options to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %7, i8* align 8 bitcast ({ %"?usize", %"?usize", i2, <{ i8, [6 x i8] }> }* @281 to i8*), i64 40, i1 false)
  %8 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 0
  %9 = bitcast %"?usize"* %8 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %9, i8* align 8 bitcast (%"?usize"* @282 to i8*), i64 16, i1 false)
  %10 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 1
  %11 = bitcast %"?usize"* %10 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %11, i8* align 8 bitcast (%"?usize"* @283 to i8*), i64 16, i1 false)
  %12 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 2
  store i2 -2, i2* %12, align 1
  %13 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 3
  store i8 32, i8* %13, align 1
  %14 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 1
  %15 = bitcast %"?usize"* %14 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %15, i8* align 8 bitcast (%"?usize"* @287 to i8*), i64 16, i1 false)
  %16 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 0
  %17 = bitcast %"?usize"* %16 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %17, i8* align 8 bitcast (%"?usize"* @288 to i8*), i64 16, i1 false)
  %18 = getelementptr inbounds %"std.special.struct:110:55", %"std.special.struct:110:55"* %1, i32 0, i32 0
  %19 = load i64, i64* %18, align 8
  store i64 %19, i64* %2, align 8
  %20 = bitcast %std.fmt.FormatOptions* %options to i8*
  %21 = bitcast %std.fmt.FormatOptions* %3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %21, i8* align 8 %20, i64 40, i1 false)
  %22 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0 to i8*
  %23 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %23, i8* align 4 %22, i64 4, i1 false)
  %24 = call fastcc i16 @std.fmt.formatType.124(i64 %19, %std.fmt.FormatOptions* %options, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0, i64 3)
  store i16 %24, i16* %5, align 2
  %25 = icmp ne i16 %24, 0
  br i1 %25, label %ErrRetReturn, label %ErrRetContinue

ErrRetReturn:                                     ; preds = %Entry
  %26 = load i16, i16* %5, align 2
  store i16 %26, i16* %result, align 2
  ret i16 %26

ErrRetContinue:                                   ; preds = %Entry
  %27 = call fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).writeAll"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0, %"[]u8"* @289)
  store i16 %27, i16* %6, align 2
  %28 = icmp ne i16 %27, 0
  br i1 %28, label %ErrRetReturn1, label %ErrRetContinue2

ErrRetReturn1:                                    ; preds = %ErrRetContinue
  %29 = load i16, i16* %6, align 2
  store i16 %29, i16* %result, align 2
  ret i16 %29

ErrRetContinue2:                                  ; preds = %ErrRetContinue
  store i16 0, i16* %result, align 2
  ret i16 0
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.format.77(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %0, %"std.special.struct:113:56"* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %options = alloca %std.fmt.FormatOptions, align 8
  %2 = alloca i64, align 8
  %3 = alloca %std.fmt.FormatOptions, align 8
  %4 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %5 = alloca i16, align 2
  %6 = alloca i16, align 2
  %7 = bitcast %std.fmt.FormatOptions* %options to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %7, i8* align 8 bitcast ({ %"?usize", %"?usize", i2, <{ i8, [6 x i8] }> }* @291 to i8*), i64 40, i1 false)
  %8 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 0
  %9 = bitcast %"?usize"* %8 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %9, i8* align 8 bitcast (%"?usize"* @292 to i8*), i64 16, i1 false)
  %10 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 1
  %11 = bitcast %"?usize"* %10 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %11, i8* align 8 bitcast (%"?usize"* @293 to i8*), i64 16, i1 false)
  %12 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 2
  store i2 -2, i2* %12, align 1
  %13 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 3
  store i8 32, i8* %13, align 1
  %14 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 1
  %15 = bitcast %"?usize"* %14 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %15, i8* align 8 bitcast (%"?usize"* @297 to i8*), i64 16, i1 false)
  %16 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 0
  %17 = bitcast %"?usize"* %16 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %17, i8* align 8 bitcast (%"?usize"* @298 to i8*), i64 16, i1 false)
  %18 = getelementptr inbounds %"std.special.struct:113:56", %"std.special.struct:113:56"* %1, i32 0, i32 0
  %19 = load i64, i64* %18, align 8
  store i64 %19, i64* %2, align 8
  %20 = bitcast %std.fmt.FormatOptions* %options to i8*
  %21 = bitcast %std.fmt.FormatOptions* %3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %21, i8* align 8 %20, i64 40, i1 false)
  %22 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0 to i8*
  %23 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %23, i8* align 4 %22, i64 4, i1 false)
  %24 = call fastcc i16 @std.fmt.formatType.126(i64 %19, %std.fmt.FormatOptions* %options, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0, i64 3)
  store i16 %24, i16* %5, align 2
  %25 = icmp ne i16 %24, 0
  br i1 %25, label %ErrRetReturn, label %ErrRetContinue

ErrRetReturn:                                     ; preds = %Entry
  %26 = load i16, i16* %5, align 2
  store i16 %26, i16* %result, align 2
  ret i16 %26

ErrRetContinue:                                   ; preds = %Entry
  %27 = call fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).writeAll"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0, %"[]u8"* @299)
  store i16 %27, i16* %6, align 2
  %28 = icmp ne i16 %27, 0
  br i1 %28, label %ErrRetReturn1, label %ErrRetContinue2

ErrRetReturn1:                                    ; preds = %ErrRetContinue
  %29 = load i16, i16* %6, align 2
  store i16 %29, i16* %result, align 2
  ret i16 %29

ErrRetContinue2:                                  ; preds = %ErrRetContinue
  store i16 0, i16* %result, align 2
  ret i16 0
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.heap.FixedBufferAllocator.alloc({ %"[]u8", i16 }* nonnull sret({ %"[]u8", i16 }) %0, %std.heap.FixedBufferAllocator* nonnull align 8 %1, i64 %2, i29 %3, i29 %4, i64 %5) unnamed_addr #1 {
Entry:
  %6 = alloca i8*, align 8
  %7 = alloca i29, align 4
  %8 = alloca %"?usize", align 8
  %adjust_off = alloca i64, align 8
  %adjusted_index = alloca i64, align 8
  %new_end_index = alloca i64, align 8
  %result = alloca %"[]u8", align 8
  %self = alloca %std.heap.FixedBufferAllocator*, align 8
  %n = alloca i64, align 8
  %ptr_align = alloca i29, align 4
  %len_align = alloca i29, align 4
  %ra = alloca i64, align 8
  store %std.heap.FixedBufferAllocator* %1, %std.heap.FixedBufferAllocator** %self, align 8
  store i64 %2, i64* %n, align 8
  store i29 %3, i29* %ptr_align, align 4
  store i29 %4, i29* %len_align, align 4
  store i64 %5, i64* %ra, align 8
  %9 = load %std.heap.FixedBufferAllocator*, %std.heap.FixedBufferAllocator** %self, align 8
  %10 = getelementptr inbounds %std.heap.FixedBufferAllocator, %std.heap.FixedBufferAllocator* %9, i32 0, i32 1
  %11 = getelementptr inbounds %"[]u8", %"[]u8"* %10, i32 0, i32 0
  %12 = load i8*, i8** %11, align 8
  %13 = load %std.heap.FixedBufferAllocator*, %std.heap.FixedBufferAllocator** %self, align 8
  %14 = getelementptr inbounds %std.heap.FixedBufferAllocator, %std.heap.FixedBufferAllocator* %13, i32 0, i32 0
  %15 = load i64, i64* %14, align 8
  %16 = getelementptr inbounds i8, i8* %12, i64 %15
  store i8* %16, i8** %6, align 8
  %17 = load i29, i29* %ptr_align, align 4
  store i29 %17, i29* %7, align 4
  call fastcc void @std.mem.alignPointerOffset.78(%"?usize"* sret(%"?usize") %8, i8* %16, i29 %17)
  %18 = getelementptr inbounds %"?usize", %"?usize"* %8, i32 0, i32 1
  %19 = load i1, i1* %18, align 1
  br i1 %19, label %OptionalNonNull, label %OptionalNull

OptionalNull:                                     ; preds = %Entry
  %20 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %0, i32 0, i32 1
  store i16 16, i16* %20, align 2
  ret void

OptionalNonNull:                                  ; preds = %Entry
  %21 = getelementptr inbounds %"?usize", %"?usize"* %8, i32 0, i32 0
  %22 = load i64, i64* %21, align 8
  store i64 %22, i64* %adjust_off, align 8
  br label %OptionalEnd

OptionalEnd:                                      ; preds = %OptionalNonNull
  %23 = load %std.heap.FixedBufferAllocator*, %std.heap.FixedBufferAllocator** %self, align 8
  %24 = getelementptr inbounds %std.heap.FixedBufferAllocator, %std.heap.FixedBufferAllocator* %23, i32 0, i32 0
  %25 = load i64, i64* %24, align 8
  %26 = load i64, i64* %adjust_off, align 8
  %27 = add nuw i64 %25, %26
  store i64 %27, i64* %adjusted_index, align 8
  %28 = load i64, i64* %adjusted_index, align 8
  %29 = load i64, i64* %n, align 8
  %30 = add nuw i64 %28, %29
  store i64 %30, i64* %new_end_index, align 8
  %31 = load i64, i64* %new_end_index, align 8
  %32 = load %std.heap.FixedBufferAllocator*, %std.heap.FixedBufferAllocator** %self, align 8
  %33 = getelementptr inbounds %std.heap.FixedBufferAllocator, %std.heap.FixedBufferAllocator* %32, i32 0, i32 1
  %34 = getelementptr inbounds %"[]u8", %"[]u8"* %33, i32 0, i32 1
  %35 = load i64, i64* %34, align 8
  %36 = icmp ugt i64 %31, %35
  br i1 %36, label %Then, label %Else

Then:                                             ; preds = %OptionalEnd
  %37 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %0, i32 0, i32 1
  store i16 16, i16* %37, align 2
  ret void

Else:                                             ; preds = %OptionalEnd
  br label %EndIf

EndIf:                                            ; preds = %Else
  %38 = load %std.heap.FixedBufferAllocator*, %std.heap.FixedBufferAllocator** %self, align 8
  %39 = getelementptr inbounds %std.heap.FixedBufferAllocator, %std.heap.FixedBufferAllocator* %38, i32 0, i32 1
  %40 = load i64, i64* %adjusted_index, align 8
  %41 = load i64, i64* %new_end_index, align 8
  %42 = getelementptr inbounds %"[]u8", %"[]u8"* %39, i32 0, i32 0
  %43 = load i8*, i8** %42, align 8
  %44 = getelementptr inbounds i8, i8* %43, i64 %40
  %45 = sub nuw i64 %41, %40
  %46 = getelementptr inbounds %"[]u8", %"[]u8"* %result, i32 0, i32 0
  store i8* %44, i8** %46, align 8
  %47 = getelementptr inbounds %"[]u8", %"[]u8"* %result, i32 0, i32 1
  store i64 %45, i64* %47, align 8
  %48 = load %std.heap.FixedBufferAllocator*, %std.heap.FixedBufferAllocator** %self, align 8
  %49 = getelementptr inbounds %std.heap.FixedBufferAllocator, %std.heap.FixedBufferAllocator* %48, i32 0, i32 0
  %50 = load i64, i64* %new_end_index, align 8
  store i64 %50, i64* %49, align 8
  %51 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %0, i32 0, i32 1
  store i16 0, i16* %51, align 2
  %52 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %0, i32 0, i32 0
  %53 = bitcast %"[]u8"* %result to i8*
  %54 = bitcast %"[]u8"* %52 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %54, i8* align 8 %53, i64 16, i1 false)
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.mem.alignPointerOffset.78(%"?usize"* nonnull sret(%"?usize") %0, i8* nonnull align 1 %1, i29 %2) unnamed_addr #1 {
Entry:
  %addr = alloca i64, align 8
  %new_addr = alloca i64, align 8
  %delta = alloca i64, align 8
  %ptr = alloca i8*, align 8
  %align_to = alloca i29, align 4
  store i8* %1, i8** %ptr, align 8
  store i29 %2, i29* %align_to, align 4
  %3 = load i29, i29* %align_to, align 4
  %4 = icmp ne i29 %3, 0
  br i1 %4, label %BoolAndTrue, label %BoolAndFalse

BoolAndTrue:                                      ; preds = %Entry
  %5 = load i29, i29* %align_to, align 4
  %6 = call i29 @llvm.ctpop.i29(i29 %5)
  %7 = trunc i29 %6 to i5
  %8 = icmp eq i5 %7, 1
  br label %BoolAndFalse

BoolAndFalse:                                     ; preds = %BoolAndTrue, %Entry
  %9 = phi i1 [ %4, %Entry ], [ %8, %BoolAndTrue ]
  call fastcc void @std.debug.assert(i1 %9)
  %10 = load i29, i29* %align_to, align 4
  %11 = icmp ule i29 %10, 1
  br i1 %11, label %Then, label %Else

Then:                                             ; preds = %BoolAndFalse
  %12 = getelementptr inbounds %"?usize", %"?usize"* %0, i32 0, i32 1
  store i1 true, i1* %12, align 1
  %13 = getelementptr inbounds %"?usize", %"?usize"* %0, i32 0, i32 0
  store i64 0, i64* %13, align 8
  ret void

Else:                                             ; preds = %BoolAndFalse
  br label %EndIf

EndIf:                                            ; preds = %Else
  %14 = load i8*, i8** %ptr, align 8
  %15 = ptrtoint i8* %14 to i64
  store i64 %15, i64* %addr, align 8
  %16 = load i64, i64* %addr, align 8
  %17 = load i29, i29* %align_to, align 4
  %18 = sub nuw i29 %17, 1
  %19 = zext i29 %18 to i64
  %20 = call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %16, i64 %19)
  %21 = extractvalue { i64, i1 } %20, 0
  %22 = extractvalue { i64, i1 } %20, 1
  store i64 %21, i64* %new_addr, align 8
  br i1 %22, label %Then1, label %Else2

Then1:                                            ; preds = %EndIf
  %23 = bitcast %"?usize"* %0 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %23, i8* align 8 bitcast (%"?usize"* @128 to i8*), i64 16, i1 false)
  ret void

Else2:                                            ; preds = %EndIf
  br label %EndIf3

EndIf3:                                           ; preds = %Else2
  %24 = load i64, i64* %new_addr, align 8
  %25 = load i29, i29* %align_to, align 4
  %26 = sub nuw i29 %25, 1
  %27 = zext i29 %26 to i64
  %28 = xor i64 %27, -1
  %29 = and i64 %24, %28
  store i64 %29, i64* %new_addr, align 8
  %30 = load i64, i64* %new_addr, align 8
  %31 = load i64, i64* %addr, align 8
  %32 = sub nuw i64 %30, %31
  store i64 %32, i64* %delta, align 8
  %33 = load i64, i64* %delta, align 8
  %34 = urem i64 %33, 1
  %35 = icmp ne i64 %34, 0
  br i1 %35, label %Then4, label %Else5

Then4:                                            ; preds = %EndIf3
  %36 = bitcast %"?usize"* %0 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %36, i8* align 8 bitcast (%"?usize"* @129 to i8*), i64 16, i1 false)
  ret void

Else5:                                            ; preds = %EndIf3
  br label %EndIf6

EndIf6:                                           ; preds = %Else5
  %37 = load i64, i64* %delta, align 8
  %38 = udiv i64 %37, 1
  %39 = getelementptr inbounds %"?usize", %"?usize"* %0, i32 0, i32 1
  store i1 true, i1* %39, align 1
  %40 = getelementptr inbounds %"?usize", %"?usize"* %0, i32 0, i32 0
  store i64 %38, i64* %40, align 8
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.heap.FixedBufferAllocator.resize(%"?usize"* nonnull sret(%"?usize") %0, %std.heap.FixedBufferAllocator* nonnull align 8 %1, %"[]u8"* nonnull readonly align 8 %2, i29 %3, i64 %4, i29 %5, i64 %6) unnamed_addr #1 {
Entry:
  %sub = alloca i64, align 8
  %add = alloca i64, align 8
  %self = alloca %std.heap.FixedBufferAllocator*, align 8
  %buf_align = alloca i29, align 4
  %new_size = alloca i64, align 8
  %len_align = alloca i29, align 4
  %return_address = alloca i64, align 8
  store %std.heap.FixedBufferAllocator* %1, %std.heap.FixedBufferAllocator** %self, align 8
  store i29 %3, i29* %buf_align, align 4
  store i64 %4, i64* %new_size, align 8
  store i29 %5, i29* %len_align, align 4
  store i64 %6, i64* %return_address, align 8
  %7 = load %std.heap.FixedBufferAllocator*, %std.heap.FixedBufferAllocator** %self, align 8
  %8 = call fastcc i1 @std.heap.FixedBufferAllocator.ownsSlice(%std.heap.FixedBufferAllocator* %7, %"[]u8"* %2)
  call fastcc void @std.debug.assert(i1 %8)
  %9 = load %std.heap.FixedBufferAllocator*, %std.heap.FixedBufferAllocator** %self, align 8
  %10 = call fastcc i1 @std.heap.FixedBufferAllocator.isLastAllocation(%std.heap.FixedBufferAllocator* %9, %"[]u8"* %2)
  %11 = icmp eq i1 %10, false
  br i1 %11, label %Then, label %Else2

Then:                                             ; preds = %Entry
  %12 = load i64, i64* %new_size, align 8
  %13 = getelementptr inbounds %"[]u8", %"[]u8"* %2, i32 0, i32 1
  %14 = load i64, i64* %13, align 8
  %15 = icmp ugt i64 %12, %14
  br i1 %15, label %Then1, label %Else

Then1:                                            ; preds = %Then
  %16 = bitcast %"?usize"* %0 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %16, i8* align 8 bitcast (%"?usize"* @126 to i8*), i64 16, i1 false)
  ret void

Else:                                             ; preds = %Then
  br label %EndIf

EndIf:                                            ; preds = %Else
  %17 = getelementptr inbounds %"[]u8", %"[]u8"* %2, i32 0, i32 1
  %18 = load i64, i64* %17, align 8
  %19 = load i64, i64* %new_size, align 8
  %20 = load i29, i29* %len_align, align 4
  %21 = call fastcc i64 @std.mem.alignAllocLen(i64 %18, i64 %19, i29 %20)
  %22 = getelementptr inbounds %"?usize", %"?usize"* %0, i32 0, i32 1
  store i1 true, i1* %22, align 1
  %23 = getelementptr inbounds %"?usize", %"?usize"* %0, i32 0, i32 0
  store i64 %21, i64* %23, align 8
  ret void

Else2:                                            ; preds = %Entry
  br label %EndIf3

EndIf3:                                           ; preds = %Else2
  %24 = load i64, i64* %new_size, align 8
  %25 = getelementptr inbounds %"[]u8", %"[]u8"* %2, i32 0, i32 1
  %26 = load i64, i64* %25, align 8
  %27 = icmp ule i64 %24, %26
  br i1 %27, label %Then4, label %Else5

Then4:                                            ; preds = %EndIf3
  %28 = getelementptr inbounds %"[]u8", %"[]u8"* %2, i32 0, i32 1
  %29 = load i64, i64* %28, align 8
  %30 = load i64, i64* %new_size, align 8
  %31 = sub nuw i64 %29, %30
  store i64 %31, i64* %sub, align 8
  %32 = load %std.heap.FixedBufferAllocator*, %std.heap.FixedBufferAllocator** %self, align 8
  %33 = getelementptr inbounds %std.heap.FixedBufferAllocator, %std.heap.FixedBufferAllocator* %32, i32 0, i32 0
  %34 = load i64, i64* %33, align 8
  %35 = load i64, i64* %sub, align 8
  %36 = sub nuw i64 %34, %35
  store i64 %36, i64* %33, align 8
  %37 = getelementptr inbounds %"[]u8", %"[]u8"* %2, i32 0, i32 1
  %38 = load i64, i64* %37, align 8
  %39 = load i64, i64* %sub, align 8
  %40 = sub nuw i64 %38, %39
  %41 = load i64, i64* %new_size, align 8
  %42 = load i29, i29* %len_align, align 4
  %43 = call fastcc i64 @std.mem.alignAllocLen(i64 %40, i64 %41, i29 %42)
  %44 = getelementptr inbounds %"?usize", %"?usize"* %0, i32 0, i32 1
  store i1 true, i1* %44, align 1
  %45 = getelementptr inbounds %"?usize", %"?usize"* %0, i32 0, i32 0
  store i64 %43, i64* %45, align 8
  ret void

Else5:                                            ; preds = %EndIf3
  br label %EndIf6

EndIf6:                                           ; preds = %Else5
  %46 = load i64, i64* %new_size, align 8
  %47 = getelementptr inbounds %"[]u8", %"[]u8"* %2, i32 0, i32 1
  %48 = load i64, i64* %47, align 8
  %49 = sub nuw i64 %46, %48
  store i64 %49, i64* %add, align 8
  %50 = load i64, i64* %add, align 8
  %51 = load %std.heap.FixedBufferAllocator*, %std.heap.FixedBufferAllocator** %self, align 8
  %52 = getelementptr inbounds %std.heap.FixedBufferAllocator, %std.heap.FixedBufferAllocator* %51, i32 0, i32 0
  %53 = load i64, i64* %52, align 8
  %54 = add nuw i64 %50, %53
  %55 = load %std.heap.FixedBufferAllocator*, %std.heap.FixedBufferAllocator** %self, align 8
  %56 = getelementptr inbounds %std.heap.FixedBufferAllocator, %std.heap.FixedBufferAllocator* %55, i32 0, i32 1
  %57 = getelementptr inbounds %"[]u8", %"[]u8"* %56, i32 0, i32 1
  %58 = load i64, i64* %57, align 8
  %59 = icmp ugt i64 %54, %58
  br i1 %59, label %Then7, label %Else8

Then7:                                            ; preds = %EndIf6
  %60 = bitcast %"?usize"* %0 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %60, i8* align 8 bitcast (%"?usize"* @127 to i8*), i64 16, i1 false)
  ret void

Else8:                                            ; preds = %EndIf6
  br label %EndIf9

EndIf9:                                           ; preds = %Else8
  %61 = load %std.heap.FixedBufferAllocator*, %std.heap.FixedBufferAllocator** %self, align 8
  %62 = getelementptr inbounds %std.heap.FixedBufferAllocator, %std.heap.FixedBufferAllocator* %61, i32 0, i32 0
  %63 = load i64, i64* %62, align 8
  %64 = load i64, i64* %add, align 8
  %65 = add nuw i64 %63, %64
  store i64 %65, i64* %62, align 8
  %66 = load i64, i64* %new_size, align 8
  %67 = getelementptr inbounds %"?usize", %"?usize"* %0, i32 0, i32 1
  store i1 true, i1* %67, align 1
  %68 = getelementptr inbounds %"?usize", %"?usize"* %0, i32 0, i32 0
  store i64 %66, i64* %68, align 8
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i1 @std.heap.FixedBufferAllocator.ownsSlice(%std.heap.FixedBufferAllocator* nonnull align 8 %0, %"[]u8"* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %result = alloca i1, align 1
  %self = alloca %std.heap.FixedBufferAllocator*, align 8
  store %std.heap.FixedBufferAllocator* %0, %std.heap.FixedBufferAllocator** %self, align 8
  %2 = load %std.heap.FixedBufferAllocator*, %std.heap.FixedBufferAllocator** %self, align 8
  %3 = getelementptr inbounds %std.heap.FixedBufferAllocator, %std.heap.FixedBufferAllocator* %2, i32 0, i32 1
  %4 = call fastcc i1 @std.heap.sliceContainsSlice(%"[]u8"* %3, %"[]u8"* %1)
  store i1 %4, i1* %result, align 1
  %5 = load i1, i1* %result, align 1
  ret i1 %5
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i1 @std.heap.FixedBufferAllocator.isLastAllocation(%std.heap.FixedBufferAllocator* nonnull align 8 %0, %"[]u8"* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %result = alloca i1, align 1
  %self = alloca %std.heap.FixedBufferAllocator*, align 8
  store %std.heap.FixedBufferAllocator* %0, %std.heap.FixedBufferAllocator** %self, align 8
  %2 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 0
  %3 = load i8*, i8** %2, align 8
  %4 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 1
  %5 = load i64, i64* %4, align 8
  %6 = getelementptr inbounds i8, i8* %3, i64 %5
  %7 = load %std.heap.FixedBufferAllocator*, %std.heap.FixedBufferAllocator** %self, align 8
  %8 = getelementptr inbounds %std.heap.FixedBufferAllocator, %std.heap.FixedBufferAllocator* %7, i32 0, i32 1
  %9 = getelementptr inbounds %"[]u8", %"[]u8"* %8, i32 0, i32 0
  %10 = load i8*, i8** %9, align 8
  %11 = load %std.heap.FixedBufferAllocator*, %std.heap.FixedBufferAllocator** %self, align 8
  %12 = getelementptr inbounds %std.heap.FixedBufferAllocator, %std.heap.FixedBufferAllocator* %11, i32 0, i32 0
  %13 = load i64, i64* %12, align 8
  %14 = getelementptr inbounds i8, i8* %10, i64 %13
  %15 = icmp eq i8* %6, %14
  store i1 %15, i1* %result, align 1
  %16 = load i1, i1* %result, align 1
  ret i1 %16
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.heap.FixedBufferAllocator.free(%std.heap.FixedBufferAllocator* nonnull align 8 %0, %"[]u8"* nonnull readonly align 8 %1, i29 %2, i64 %3) unnamed_addr #1 {
Entry:
  %self = alloca %std.heap.FixedBufferAllocator*, align 8
  %buf_align = alloca i29, align 4
  %return_address = alloca i64, align 8
  store %std.heap.FixedBufferAllocator* %0, %std.heap.FixedBufferAllocator** %self, align 8
  store i29 %2, i29* %buf_align, align 4
  store i64 %3, i64* %return_address, align 8
  %4 = load %std.heap.FixedBufferAllocator*, %std.heap.FixedBufferAllocator** %self, align 8
  %5 = call fastcc i1 @std.heap.FixedBufferAllocator.ownsSlice(%std.heap.FixedBufferAllocator* %4, %"[]u8"* %1)
  call fastcc void @std.debug.assert(i1 %5)
  %6 = load %std.heap.FixedBufferAllocator*, %std.heap.FixedBufferAllocator** %self, align 8
  %7 = call fastcc i1 @std.heap.FixedBufferAllocator.isLastAllocation(%std.heap.FixedBufferAllocator* %6, %"[]u8"* %1)
  br i1 %7, label %Then, label %Else

Then:                                             ; preds = %Entry
  %8 = load %std.heap.FixedBufferAllocator*, %std.heap.FixedBufferAllocator** %self, align 8
  %9 = getelementptr inbounds %std.heap.FixedBufferAllocator, %std.heap.FixedBufferAllocator* %8, i32 0, i32 0
  %10 = load i64, i64* %9, align 8
  %11 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 1
  %12 = load i64, i64* %11, align 8
  %13 = sub nuw i64 %10, %12
  store i64 %13, i64* %9, align 8
  br label %EndIf

Else:                                             ; preds = %Entry
  br label %EndIf

EndIf:                                            ; preds = %Else, %Then
  ret void
}

; Function Attrs: nofree nosync nounwind readnone speculatable willreturn
declare i29 @llvm.ctpop.i29(i29 %0) #9

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.process.ArgIteratorPosix.init(%std.process.ArgIteratorPosix* nonnull sret(%std.process.ArgIteratorPosix) %0) unnamed_addr #1 {
Entry:
  %1 = getelementptr inbounds %std.process.ArgIteratorPosix, %std.process.ArgIteratorPosix* %0, i32 0, i32 0
  store i64 0, i64* %1, align 8
  %2 = getelementptr inbounds %std.process.ArgIteratorPosix, %std.process.ArgIteratorPosix* %0, i32 0, i32 1
  %3 = load i64, i64* getelementptr inbounds (%"[][*:0]u8", %"[][*:0]u8"* @argv, i32 0, i32 1), align 8
  store i64 %3, i64* %2, align 8
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.mem.sliceTo.79(%"[]u8"* nonnull sret(%"[]u8") %0, i8* nonnull align 1 %1) unnamed_addr #1 {
Entry:
  %2 = alloca i8*, align 8
  %length = alloca i64, align 8
  %ptr = alloca i8*, align 8
  store i8* %1, i8** %ptr, align 8
  %3 = load i8*, i8** %ptr, align 8
  store i8* %3, i8** %2, align 8
  %4 = call fastcc i64 @std.mem.lenSliceTo.128(i8* %3)
  store i64 %4, i64* %length, align 8
  %5 = load i64, i64* %length, align 8
  %6 = load i8*, i8** %ptr, align 8
  %7 = getelementptr inbounds i8, i8* %6, i64 0
  %8 = sub nuw i64 %5, 0
  %9 = getelementptr inbounds %"[]u8", %"[]u8"* %0, i32 0, i32 0
  store i8* %7, i8** %9, align 8
  %10 = getelementptr inbounds %"[]u8", %"[]u8"* %0, i32 0, i32 1
  store i64 %8, i64* %10, align 8
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.mem.Allocator.alloc({ %"[]u8", i16 }* nonnull sret({ %"[]u8", i16 }) %0, %std.mem.Allocator* nonnull readonly align 8 %1, i64 %2) unnamed_addr #1 {
Entry:
  %3 = alloca i64, align 8
  %4 = alloca i64, align 8
  %n = alloca i64, align 8
  store i64 %2, i64* %n, align 8
  %5 = load i64, i64* %n, align 8
  store i64 %5, i64* %3, align 8
  %6 = call i8* @llvm.returnaddress(i32 0)
  %7 = ptrtoint i8* %6 to i64
  store i64 %7, i64* %4, align 8
  call fastcc void @std.mem.Allocator.allocAdvancedWithRetAddr.80({ %"[]u8", i16 }* sret({ %"[]u8", i16 }) %0, %std.mem.Allocator* %1, i64 %5, i1 false, i64 %7)
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.mem.Allocator.allocAdvancedWithRetAddr.80({ %"[]u8", i16 }* nonnull sret({ %"[]u8", i16 }) %0, %std.mem.Allocator* nonnull readonly align 8 %1, i64 %2, i1 %3, i64 %4) unnamed_addr #1 {
Entry:
  %5 = alloca i64, align 8
  %6 = alloca { i64, i16 }, align 8
  %byte_count = alloca i64, align 8
  %size_of_T = alloca i29, align 4
  %len_align = alloca i29, align 4
  %7 = alloca { %"[]u8", i16 }, align 8
  %8 = alloca { %"[]u8", i16 }, align 8
  %byte_slice = alloca %"[]u8", align 8
  %9 = alloca i8*, align 8
  %n = alloca i64, align 8
  %exact = alloca i1, align 1
  %return_address = alloca i64, align 8
  store i64 %2, i64* %n, align 8
  store i1 %3, i1* %exact, align 1
  store i64 %4, i64* %return_address, align 8
  %10 = load i64, i64* %n, align 8
  %11 = icmp eq i64 %10, 0
  br i1 %11, label %Then, label %Else

Then:                                             ; preds = %Entry
  %12 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %0, i32 0, i32 1
  store i16 0, i16* %12, align 2
  %13 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %0, i32 0, i32 0
  %14 = bitcast %"[]u8"* %13 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %14, i8* align 8 bitcast (%"[]u8"* @301 to i8*), i64 16, i1 false)
  ret void

Else:                                             ; preds = %Entry
  br label %EndIf

EndIf:                                            ; preds = %Else
  %15 = load i64, i64* %n, align 8
  store i64 %15, i64* %5, align 8
  call fastcc void @std.math.mul({ i64, i16 }* sret({ i64, i16 }) %6, i64 1, i64 %15)
  %16 = getelementptr inbounds { i64, i16 }, { i64, i16 }* %6, i32 0, i32 1
  %17 = load i16, i16* %16, align 2
  %18 = icmp ne i16 %17, 0
  br i1 %18, label %UnwrapErrError, label %UnwrapErrOk

UnwrapErrError:                                   ; preds = %EndIf
  %19 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %0, i32 0, i32 1
  store i16 16, i16* %19, align 2
  ret void

UnwrapErrOk:                                      ; preds = %EndIf
  %20 = getelementptr inbounds { i64, i16 }, { i64, i16 }* %6, i32 0, i32 0
  %21 = load i64, i64* %20, align 8
  store i64 %21, i64* %byte_count, align 8
  br label %UnwrapErrEnd

UnwrapErrEnd:                                     ; preds = %UnwrapErrOk
  %22 = load i64, i64* %byte_count, align 8
  %23 = load i64, i64* %n, align 8
  %24 = udiv exact i64 %22, %23
  %25 = trunc i64 %24 to i29
  store i29 %25, i29* %size_of_T, align 4
  %26 = load i1, i1* %exact, align 1
  switch i1 %26, label %SwitchElse [
    i1 false, label %SwitchProng
    i1 true, label %SwitchProng1
  ]

SwitchProng:                                      ; preds = %UnwrapErrEnd
  store i29 0, i29* %len_align, align 4
  br label %SwitchEnd

SwitchProng1:                                     ; preds = %UnwrapErrEnd
  %27 = load i29, i29* %size_of_T, align 4
  store i29 %27, i29* %len_align, align 4
  br label %SwitchEnd

SwitchElse:                                       ; preds = %UnwrapErrEnd
  unreachable

SwitchEnd:                                        ; preds = %SwitchProng1, %SwitchProng
  %28 = load i64, i64* %byte_count, align 8
  %29 = load i29, i29* %len_align, align 4
  %30 = load i64, i64* %return_address, align 8
  call fastcc void @std.mem.Allocator.rawAlloc({ %"[]u8", i16 }* sret({ %"[]u8", i16 }) %7, %std.mem.Allocator* %1, i64 %28, i29 1, i29 %29, i64 %30)
  %31 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %7, i32 0, i32 1
  %32 = load i16, i16* %31, align 2
  %33 = icmp ne i16 %32, 0
  br i1 %33, label %ErrRetReturn, label %ErrRetContinue

ErrRetReturn:                                     ; preds = %SwitchEnd
  %34 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %7, i32 0, i32 1
  %35 = load i16, i16* %34, align 2
  %36 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %0, i32 0, i32 1
  store i16 %35, i16* %36, align 2
  %37 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %8, i32 0, i32 1
  store i16 %35, i16* %37, align 2
  ret void

ErrRetContinue:                                   ; preds = %SwitchEnd
  %38 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %7, i32 0, i32 0
  %39 = bitcast %"[]u8"* %38 to i8*
  %40 = bitcast %"[]u8"* %byte_slice to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %40, i8* align 8 %39, i64 16, i1 false)
  %41 = load i1, i1* %exact, align 1
  switch i1 %41, label %SwitchElse2 [
    i1 false, label %SwitchProng3
    i1 true, label %SwitchProng4
  ]

SwitchElse2:                                      ; preds = %ErrRetContinue
  unreachable

SwitchProng3:                                     ; preds = %ErrRetContinue
  %42 = getelementptr inbounds %"[]u8", %"[]u8"* %byte_slice, i32 0, i32 1
  %43 = load i64, i64* %42, align 8
  %44 = load i64, i64* %byte_count, align 8
  %45 = icmp eq i64 %43, %44
  call fastcc void @std.debug.assert(i1 %45)
  br label %SwitchEnd5

SwitchProng4:                                     ; preds = %ErrRetContinue
  %46 = getelementptr inbounds %"[]u8", %"[]u8"* %byte_slice, i32 0, i32 1
  %47 = load i64, i64* %46, align 8
  %48 = load i64, i64* %byte_count, align 8
  %49 = icmp uge i64 %47, %48
  call fastcc void @std.debug.assert(i1 %49)
  br label %SwitchEnd5

SwitchEnd5:                                       ; preds = %SwitchProng4, %SwitchProng3
  %50 = getelementptr inbounds %"[]u8", %"[]u8"* %byte_slice, i32 0, i32 0
  %51 = load i8*, i8** %50, align 8
  %52 = getelementptr inbounds %"[]u8", %"[]u8"* %byte_slice, i32 0, i32 1
  %53 = load i64, i64* %52, align 8
  %54 = getelementptr inbounds %"[]u8", %"[]u8"* %byte_slice, i32 0, i32 0
  %55 = load i8*, i8** %54, align 8
  %56 = ptrtoint i8* %55 to i64
  %57 = inttoptr i64 %56 to i8*
  store i8* %57, i8** %9, align 8
  %58 = getelementptr inbounds %"[]u8", %"[]u8"* %byte_slice, i32 0, i32 1
  %59 = load i64, i64* %58, align 8
  %60 = udiv exact i64 %59, 1
  %61 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %0, i32 0, i32 1
  store i16 0, i16* %61, align 2
  %62 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %0, i32 0, i32 0
  %63 = load i8*, i8** %9, align 8
  %64 = getelementptr inbounds i8, i8* %63, i64 0
  %65 = sub nuw i64 %60, 0
  %66 = getelementptr inbounds %"[]u8", %"[]u8"* %62, i32 0, i32 0
  store i8* %64, i8** %66, align 8
  %67 = getelementptr inbounds %"[]u8", %"[]u8"* %62, i32 0, i32 1
  store i64 %65, i64* %67, align 8
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.mem.sliceAsBytes.81(%"[]u8"* nonnull sret(%"[]u8") %0, %"[]usize"* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %2 = alloca i8*, align 8
  %3 = getelementptr inbounds %"[]usize", %"[]usize"* %1, i32 0, i32 1
  %4 = load i64, i64* %3, align 8
  %5 = icmp eq i64 %4, 0
  br i1 %5, label %BoolAndTrue, label %BoolAndFalse

BoolAndTrue:                                      ; preds = %Entry
  br label %BoolAndFalse

BoolAndFalse:                                     ; preds = %BoolAndTrue, %Entry
  %6 = phi i1 [ %5, %Entry ], [ true, %BoolAndTrue ]
  br i1 %6, label %Then, label %Else

Then:                                             ; preds = %BoolAndFalse
  %7 = bitcast %"[]u8"* %0 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %7, i8* align 8 bitcast (%"[]u8"* @302 to i8*), i64 16, i1 false)
  ret void

Else:                                             ; preds = %BoolAndFalse
  br label %EndIf

EndIf:                                            ; preds = %Else
  %8 = getelementptr inbounds %"[]usize", %"[]usize"* %1, i32 0, i32 0
  %9 = load i64*, i64** %8, align 8
  %10 = bitcast i64* %9 to i8*
  store i8* %10, i8** %2, align 8
  %11 = getelementptr inbounds %"[]usize", %"[]usize"* %1, i32 0, i32 1
  %12 = load i64, i64* %11, align 8
  %13 = mul nuw i64 %12, 8
  %14 = load i8*, i8** %2, align 8
  %15 = getelementptr inbounds i8, i8* %14, i64 0
  %16 = sub nuw i64 %13, 0
  %17 = getelementptr inbounds %"[]u8", %"[]u8"* %0, i32 0, i32 0
  store i8* %15, i8** %17, align 8
  %18 = getelementptr inbounds %"[]u8", %"[]u8"* %0, i32 0, i32 1
  store i64 %16, i64* %18, align 8
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.mem.sliceAsBytes.82(%"[]u8"* nonnull sret(%"[]u8") %0, %"[]u8"* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %2 = alloca i8*, align 8
  %3 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 1
  %4 = load i64, i64* %3, align 8
  %5 = icmp eq i64 %4, 0
  br i1 %5, label %BoolAndTrue, label %BoolAndFalse

BoolAndTrue:                                      ; preds = %Entry
  br label %BoolAndFalse

BoolAndFalse:                                     ; preds = %BoolAndTrue, %Entry
  %6 = phi i1 [ %5, %Entry ], [ true, %BoolAndTrue ]
  br i1 %6, label %Then, label %Else

Then:                                             ; preds = %BoolAndFalse
  %7 = bitcast %"[]u8"* %0 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %7, i8* align 8 bitcast (%"[]u8"* @303 to i8*), i64 16, i1 false)
  ret void

Else:                                             ; preds = %BoolAndFalse
  br label %EndIf

EndIf:                                            ; preds = %Else
  %8 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 0
  %9 = load i8*, i8** %8, align 8
  store i8* %9, i8** %2, align 8
  %10 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 1
  %11 = load i64, i64* %10, align 8
  %12 = mul nuw i64 %11, 1
  %13 = load i8*, i8** %2, align 8
  %14 = getelementptr inbounds i8, i8* %13, i64 0
  %15 = sub nuw i64 %12, 0
  %16 = getelementptr inbounds %"[]u8", %"[]u8"* %0, i32 0, i32 0
  store i8* %14, i8** %16, align 8
  %17 = getelementptr inbounds %"[]u8", %"[]u8"* %0, i32 0, i32 1
  store i64 %15, i64* %17, align 8
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.mem.Allocator.allocAdvancedWithRetAddr.83({ %"[]u8", i16 }* nonnull sret({ %"[]u8", i16 }) %0, %std.mem.Allocator* nonnull readonly align 8 %1, i64 %2, i1 %3, i64 %4) unnamed_addr #1 {
Entry:
  %5 = alloca i64, align 8
  %6 = alloca i1, align 1
  %7 = alloca i64, align 8
  %n = alloca i64, align 8
  %exact = alloca i1, align 1
  %return_address = alloca i64, align 8
  store i64 %2, i64* %n, align 8
  store i1 %3, i1* %exact, align 1
  store i64 %4, i64* %return_address, align 8
  %8 = load i64, i64* %n, align 8
  store i64 %8, i64* %5, align 8
  %9 = load i1, i1* %exact, align 1
  store i1 %9, i1* %6, align 1
  %10 = load i64, i64* %return_address, align 8
  store i64 %10, i64* %7, align 8
  call fastcc void @std.mem.Allocator.allocAdvancedWithRetAddr.80({ %"[]u8", i16 }* sret({ %"[]u8", i16 }) %0, %std.mem.Allocator* %1, i64 %8, i1 %9, i64 %10)
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i64 @std.mem.Allocator.shrinkBytes(%std.mem.Allocator* nonnull readonly align 8 %0, %"[]u8"* nonnull readonly align 8 %1, i29 %2, i64 %3, i29 %4, i64 %5) unnamed_addr #1 {
Entry:
  %result = alloca i64, align 8
  %6 = alloca %"?usize", align 8
  %buf_align = alloca i29, align 4
  %new_len = alloca i64, align 8
  %len_align = alloca i29, align 4
  %return_address = alloca i64, align 8
  store i29 %2, i29* %buf_align, align 4
  store i64 %3, i64* %new_len, align 8
  store i29 %4, i29* %len_align, align 4
  store i64 %5, i64* %return_address, align 8
  %7 = load i64, i64* %new_len, align 8
  %8 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 1
  %9 = load i64, i64* %8, align 8
  %10 = icmp ule i64 %7, %9
  call fastcc void @std.debug.assert(i1 %10)
  %11 = load i29, i29* %buf_align, align 4
  %12 = load i64, i64* %new_len, align 8
  %13 = load i29, i29* %len_align, align 4
  %14 = load i64, i64* %return_address, align 8
  call fastcc void @std.mem.Allocator.rawResize(%"?usize"* sret(%"?usize") %6, %std.mem.Allocator* %0, %"[]u8"* %1, i29 %11, i64 %12, i29 %13, i64 %14)
  %15 = getelementptr inbounds %"?usize", %"?usize"* %6, i32 0, i32 1
  %16 = load i1, i1* %15, align 1
  br i1 %16, label %OptionalNonNull, label %OptionalNull

OptionalNull:                                     ; preds = %Entry
  unreachable

OptionalNonNull:                                  ; preds = %Entry
  %17 = getelementptr inbounds %"?usize", %"?usize"* %6, i32 0, i32 0
  %18 = load i64, i64* %17, align 8
  store i64 %18, i64* %result, align 8
  %19 = load i64, i64* %result, align 8
  ret i64 %19
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.mem.bytesAsSlice.84(%"[]u8"* nonnull sret(%"[]u8") %0, %"[]u8"* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %2 = alloca i8*, align 8
  %3 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 1
  %4 = load i64, i64* %3, align 8
  %5 = icmp eq i64 %4, 0
  br i1 %5, label %Then, label %Else

Then:                                             ; preds = %Entry
  %6 = bitcast %"[]u8"* %0 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %6, i8* align 8 bitcast (%"[]u8"* @304 to i8*), i64 16, i1 false)
  ret void

Else:                                             ; preds = %Entry
  br label %EndIf

EndIf:                                            ; preds = %Else
  %7 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 0
  %8 = load i8*, i8** %7, align 8
  store i8* %8, i8** %2, align 8
  %9 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 1
  %10 = load i64, i64* %9, align 8
  %11 = udiv exact i64 %10, 1
  %12 = load i8*, i8** %2, align 8
  %13 = getelementptr inbounds i8, i8* %12, i64 0
  %14 = sub nuw i64 %11, 0
  %15 = getelementptr inbounds %"[]u8", %"[]u8"* %0, i32 0, i32 0
  store i8* %13, i8** %15, align 8
  %16 = getelementptr inbounds %"[]u8", %"[]u8"* %0, i32 0, i32 1
  store i64 %14, i64* %16, align 8
  ret void
}

; Function Attrs: alwaysinline minsize nobuiltin nounwind optsize
define internal fastcc void @std.mem.Allocator.rawResize(%"?usize"* nonnull sret(%"?usize") %0, %std.mem.Allocator* nonnull readonly align 8 %1, %"[]u8"* nonnull readonly align 8 %2, i29 %3, i64 %4, i29 %5, i64 %6) unnamed_addr #7 {
Entry:
  %buf_align = alloca i29, align 4
  %new_len = alloca i64, align 8
  %len_align = alloca i29, align 4
  %ret_addr = alloca i64, align 8
  store i29 %3, i29* %buf_align, align 4
  store i64 %4, i64* %new_len, align 8
  store i29 %5, i29* %len_align, align 4
  store i64 %6, i64* %ret_addr, align 8
  %7 = getelementptr inbounds %std.mem.Allocator, %std.mem.Allocator* %1, i32 0, i32 1
  %8 = load %std.mem.Allocator.VTable*, %std.mem.Allocator.VTable** %7, align 8
  %9 = getelementptr inbounds %std.mem.Allocator.VTable, %std.mem.Allocator.VTable* %8, i32 0, i32 1
  %10 = load void (%"?usize"*, i8*, %"[]u8"*, i29, i64, i29, i64)*, void (%"?usize"*, i8*, %"[]u8"*, i29, i64, i29, i64)** %9, align 8
  %11 = getelementptr inbounds %std.mem.Allocator, %std.mem.Allocator* %1, i32 0, i32 0
  %12 = load i8*, i8** %11, align 8
  %13 = load i29, i29* %buf_align, align 4
  %14 = load i64, i64* %new_len, align 8
  %15 = load i29, i29* %len_align, align 4
  %16 = load i64, i64* %ret_addr, align 8
  call fastcc void %10(%"?usize"* sret(%"?usize") %0, i8* %12, %"[]u8"* %2, i29 %13, i64 %14, i29 %15, i64 %16)
  ret void
}

; Function Attrs: alwaysinline minsize nobuiltin nounwind optsize
define internal fastcc void @std.mem.Allocator.rawAlloc({ %"[]u8", i16 }* nonnull sret({ %"[]u8", i16 }) %0, %std.mem.Allocator* nonnull readonly align 8 %1, i64 %2, i29 %3, i29 %4, i64 %5) unnamed_addr #7 {
Entry:
  %len = alloca i64, align 8
  %ptr_align = alloca i29, align 4
  %len_align = alloca i29, align 4
  %ret_addr = alloca i64, align 8
  store i64 %2, i64* %len, align 8
  store i29 %3, i29* %ptr_align, align 4
  store i29 %4, i29* %len_align, align 4
  store i64 %5, i64* %ret_addr, align 8
  %6 = getelementptr inbounds %std.mem.Allocator, %std.mem.Allocator* %1, i32 0, i32 1
  %7 = load %std.mem.Allocator.VTable*, %std.mem.Allocator.VTable** %6, align 8
  %8 = getelementptr inbounds %std.mem.Allocator.VTable, %std.mem.Allocator.VTable* %7, i32 0, i32 0
  %9 = load void ({ %"[]u8", i16 }*, i8*, i64, i29, i29, i64)*, void ({ %"[]u8", i16 }*, i8*, i64, i29, i29, i64)** %8, align 8
  %10 = getelementptr inbounds %std.mem.Allocator, %std.mem.Allocator* %1, i32 0, i32 0
  %11 = load i8*, i8** %10, align 8
  %12 = load i64, i64* %len, align 8
  %13 = load i29, i29* %ptr_align, align 4
  %14 = load i29, i29* %len_align, align 4
  %15 = load i64, i64* %ret_addr, align 8
  call fastcc void %9({ %"[]u8", i16 }* sret({ %"[]u8", i16 }) %0, i8* %11, i64 %12, i29 %13, i29 %14, i64 %15)
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.mem.Allocator.allocAdvancedWithRetAddr.85({ %"[]usize", i16 }* nonnull sret({ %"[]usize", i16 }) %0, %std.mem.Allocator* nonnull readonly align 8 %1, i64 %2, i1 %3, i64 %4) unnamed_addr #1 {
Entry:
  %5 = alloca i64, align 8
  %6 = alloca i1, align 1
  %7 = alloca i64, align 8
  %n = alloca i64, align 8
  %exact = alloca i1, align 1
  %return_address = alloca i64, align 8
  store i64 %2, i64* %n, align 8
  store i1 %3, i1* %exact, align 1
  store i64 %4, i64* %return_address, align 8
  %8 = load i64, i64* %n, align 8
  store i64 %8, i64* %5, align 8
  %9 = load i1, i1* %exact, align 1
  store i1 %9, i1* %6, align 1
  %10 = load i64, i64* %return_address, align 8
  store i64 %10, i64* %7, align 8
  call fastcc void @std.mem.Allocator.allocAdvancedWithRetAddr.129({ %"[]usize", i16 }* sret({ %"[]usize", i16 }) %0, %std.mem.Allocator* %1, i64 %8, i1 %9, i64 %10)
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.mem.bytesAsSlice.86(%"[]usize"* nonnull sret(%"[]usize") %0, %"[]u8"* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %2 = alloca i64*, align 8
  %3 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 1
  %4 = load i64, i64* %3, align 8
  %5 = icmp eq i64 %4, 0
  br i1 %5, label %Then, label %Else

Then:                                             ; preds = %Entry
  %6 = bitcast %"[]usize"* %0 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %6, i8* align 8 bitcast (%"[]usize"* @305 to i8*), i64 16, i1 false)
  ret void

Else:                                             ; preds = %Entry
  br label %EndIf

EndIf:                                            ; preds = %Else
  %7 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 0
  %8 = load i8*, i8** %7, align 8
  %9 = bitcast i8* %8 to i64*
  store i64* %9, i64** %2, align 8
  %10 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 1
  %11 = load i64, i64* %10, align 8
  %12 = udiv exact i64 %11, 8
  %13 = load i64*, i64** %2, align 8
  %14 = getelementptr inbounds i64, i64* %13, i64 0
  %15 = sub nuw i64 %12, 0
  %16 = getelementptr inbounds %"[]usize", %"[]usize"* %0, i32 0, i32 0
  store i64* %14, i64** %16, align 8
  %17 = getelementptr inbounds %"[]usize", %"[]usize"* %0, i32 0, i32 1
  store i64 %15, i64* %17, align 8
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.mem.bytesAsSlice.87(%"[]u8"* nonnull sret(%"[]u8") %0, %"[]u8"* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %2 = alloca i8*, align 8
  %3 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 1
  %4 = load i64, i64* %3, align 8
  %5 = icmp eq i64 %4, 0
  br i1 %5, label %Then, label %Else

Then:                                             ; preds = %Entry
  %6 = bitcast %"[]u8"* %0 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %6, i8* align 8 bitcast (%"[]u8"* @306 to i8*), i64 16, i1 false)
  ret void

Else:                                             ; preds = %Entry
  br label %EndIf

EndIf:                                            ; preds = %Else
  %7 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 0
  %8 = load i8*, i8** %7, align 8
  store i8* %8, i8** %2, align 8
  %9 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 1
  %10 = load i64, i64* %9, align 8
  %11 = udiv exact i64 %10, 1
  %12 = load i8*, i8** %2, align 8
  %13 = getelementptr inbounds i8, i8* %12, i64 0
  %14 = sub nuw i64 %11, 0
  %15 = getelementptr inbounds %"[]u8", %"[]u8"* %0, i32 0, i32 0
  store i8* %13, i8** %15, align 8
  %16 = getelementptr inbounds %"[]u8", %"[]u8"* %0, i32 0, i32 1
  store i64 %14, i64* %16, align 8
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.format.88(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %0, %"std.special.struct:19:57"* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %options = alloca %std.fmt.FormatOptions, align 8
  %2 = alloca i16, align 2
  %3 = alloca %"[]u8", align 8
  %4 = alloca %std.fmt.FormatOptions, align 8
  %5 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %6 = alloca i16, align 2
  %7 = alloca i16, align 2
  %8 = alloca %std.fmt.FormatOptions, align 8
  %9 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %10 = alloca i16, align 2
  %11 = alloca i16, align 2
  %12 = bitcast %std.fmt.FormatOptions* %options to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %12, i8* align 8 bitcast ({ %"?usize", %"?usize", i2, <{ i8, [6 x i8] }> }* @307 to i8*), i64 40, i1 false)
  %13 = call fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).writeAll"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0, %"[]u8"* @309)
  store i16 %13, i16* %2, align 2
  %14 = icmp ne i16 %13, 0
  br i1 %14, label %ErrRetReturn, label %ErrRetContinue

ErrRetReturn:                                     ; preds = %Entry
  %15 = load i16, i16* %2, align 2
  store i16 %15, i16* %result, align 2
  ret i16 %15

ErrRetContinue:                                   ; preds = %Entry
  %16 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 0
  %17 = bitcast %"?usize"* %16 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %17, i8* align 8 bitcast (%"?usize"* @310 to i8*), i64 16, i1 false)
  %18 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 1
  %19 = bitcast %"?usize"* %18 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %19, i8* align 8 bitcast (%"?usize"* @311 to i8*), i64 16, i1 false)
  %20 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 2
  store i2 -2, i2* %20, align 1
  %21 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 3
  store i8 32, i8* %21, align 1
  %22 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 1
  %23 = bitcast %"?usize"* %22 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %23, i8* align 8 bitcast (%"?usize"* @314 to i8*), i64 16, i1 false)
  %24 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 0
  %25 = bitcast %"?usize"* %24 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %25, i8* align 8 bitcast (%"?usize"* @315 to i8*), i64 16, i1 false)
  %26 = getelementptr inbounds %"std.special.struct:19:57", %"std.special.struct:19:57"* %1, i32 0, i32 0
  %27 = bitcast %"[]u8"* %26 to i8*
  %28 = bitcast %"[]u8"* %3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %28, i8* align 8 %27, i64 16, i1 false)
  %29 = bitcast %std.fmt.FormatOptions* %options to i8*
  %30 = bitcast %std.fmt.FormatOptions* %4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %30, i8* align 8 %29, i64 40, i1 false)
  %31 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0 to i8*
  %32 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %32, i8* align 4 %31, i64 4, i1 false)
  %33 = call fastcc i16 @std.fmt.formatType.130(%"[]u8"* %26, %std.fmt.FormatOptions* %options, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0, i64 3)
  store i16 %33, i16* %6, align 2
  %34 = icmp ne i16 %33, 0
  br i1 %34, label %ErrRetReturn1, label %ErrRetContinue2

ErrRetReturn1:                                    ; preds = %ErrRetContinue
  %35 = load i16, i16* %6, align 2
  store i16 %35, i16* %result, align 2
  ret i16 %35

ErrRetContinue2:                                  ; preds = %ErrRetContinue
  %36 = call fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).writeAll"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0, %"[]u8"* @316)
  store i16 %36, i16* %7, align 2
  %37 = icmp ne i16 %36, 0
  br i1 %37, label %ErrRetReturn3, label %ErrRetContinue4

ErrRetReturn3:                                    ; preds = %ErrRetContinue2
  %38 = load i16, i16* %7, align 2
  store i16 %38, i16* %result, align 2
  ret i16 %38

ErrRetContinue4:                                  ; preds = %ErrRetContinue2
  %39 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 0
  %40 = bitcast %"?usize"* %39 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %40, i8* align 8 bitcast (%"?usize"* @317 to i8*), i64 16, i1 false)
  %41 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 1
  %42 = bitcast %"?usize"* %41 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %42, i8* align 8 bitcast (%"?usize"* @318 to i8*), i64 16, i1 false)
  %43 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 2
  store i2 -2, i2* %43, align 1
  %44 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 3
  store i8 32, i8* %44, align 1
  %45 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 1
  %46 = bitcast %"?usize"* %45 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %46, i8* align 8 bitcast (%"?usize"* @321 to i8*), i64 16, i1 false)
  %47 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 0
  %48 = bitcast %"?usize"* %47 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %48, i8* align 8 bitcast (%"?usize"* @322 to i8*), i64 16, i1 false)
  %49 = bitcast %std.fmt.FormatOptions* %options to i8*
  %50 = bitcast %std.fmt.FormatOptions* %8 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %50, i8* align 8 %49, i64 40, i1 false)
  %51 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0 to i8*
  %52 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %9 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %52, i8* align 4 %51, i64 4, i1 false)
  %53 = call fastcc i16 @std.fmt.formatType.131([1 x i8]* @323, %std.fmt.FormatOptions* %options, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0, i64 3)
  store i16 %53, i16* %10, align 2
  %54 = icmp ne i16 %53, 0
  br i1 %54, label %ErrRetReturn5, label %ErrRetContinue6

ErrRetReturn5:                                    ; preds = %ErrRetContinue4
  %55 = load i16, i16* %10, align 2
  store i16 %55, i16* %result, align 2
  ret i16 %55

ErrRetContinue6:                                  ; preds = %ErrRetContinue4
  %56 = call fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).writeAll"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %0, %"[]u8"* @324)
  store i16 %56, i16* %11, align 2
  %57 = icmp ne i16 %56, 0
  br i1 %57, label %ErrRetReturn7, label %ErrRetContinue8

ErrRetReturn7:                                    ; preds = %ErrRetContinue6
  %58 = load i16, i16* %11, align 2
  store i16 %58, i16* %result, align 2
  ret i16 %58

ErrRetContinue8:                                  ; preds = %ErrRetContinue6
  store i16 0, i16* %result, align 2
  ret i16 0
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i64 @std.mem.lenSliceTo(i8* nonnull readonly align 1 %0) unnamed_addr #1 {
Entry:
  %result = alloca i64, align 8
  %i = alloca i64, align 8
  %ptr = alloca i8*, align 8
  store i8* %0, i8** %ptr, align 8
  store i64 0, i64* %i, align 8
  br label %WhileCond

WhileCond:                                        ; preds = %WhileBody, %Entry
  %1 = load i64, i64* %i, align 8
  %2 = load i8*, i8** %ptr, align 8
  %3 = getelementptr inbounds i8, i8* %2, i64 %1
  %4 = load i8, i8* %3, align 1
  %5 = icmp ne i8 %4, 0
  br i1 %5, label %BoolAndTrue, label %BoolAndFalse

BoolAndTrue:                                      ; preds = %WhileCond
  %6 = load i64, i64* %i, align 8
  %7 = load i8*, i8** %ptr, align 8
  %8 = getelementptr inbounds i8, i8* %7, i64 %6
  %9 = load i8, i8* %8, align 1
  %10 = icmp ne i8 %9, 0
  br label %BoolAndFalse

BoolAndFalse:                                     ; preds = %BoolAndTrue, %WhileCond
  %11 = phi i1 [ %5, %WhileCond ], [ %10, %BoolAndTrue ]
  br i1 %11, label %WhileBody, label %WhileEnd

WhileBody:                                        ; preds = %BoolAndFalse
  %12 = load i64, i64* %i, align 8
  %13 = add nuw i64 %12, 1
  store i64 %13, i64* %i, align 8
  br label %WhileCond

WhileEnd:                                         ; preds = %BoolAndFalse
  %14 = load i64, i64* %i, align 8
  store i64 %14, i64* %result, align 8
  %15 = load i64, i64* %result, align 8
  ret i64 %15
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.hash.wyhash.WyhashStateless.init(%std.hash.wyhash.WyhashStateless* nonnull sret(%std.hash.wyhash.WyhashStateless) %0, i64 %1) unnamed_addr #1 {
Entry:
  %seed = alloca i64, align 8
  store i64 %1, i64* %seed, align 8
  %2 = getelementptr inbounds %std.hash.wyhash.WyhashStateless, %std.hash.wyhash.WyhashStateless* %0, i32 0, i32 0
  %3 = load i64, i64* %seed, align 8
  store i64 %3, i64* %2, align 8
  %4 = getelementptr inbounds %std.hash.wyhash.WyhashStateless, %std.hash.wyhash.WyhashStateless* %0, i32 0, i32 1
  store i64 0, i64* %4, align 8
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.hash.wyhash.WyhashStateless.update(%std.hash.wyhash.WyhashStateless* nonnull align 8 %0, %"[]u8"* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %off = alloca i64, align 8
  %2 = alloca %"[]u8", align 8
  %self = alloca %std.hash.wyhash.WyhashStateless*, align 8
  store %std.hash.wyhash.WyhashStateless* %0, %std.hash.wyhash.WyhashStateless** %self, align 8
  %3 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 1
  %4 = load i64, i64* %3, align 8
  %5 = urem i64 %4, 32
  %6 = icmp eq i64 %5, 0
  call fastcc void @std.debug.assert(i1 %6)
  store i64 0, i64* %off, align 8
  br label %WhileCond

WhileCond:                                        ; preds = %WhileBody, %Entry
  %7 = load i64, i64* %off, align 8
  %8 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 1
  %9 = load i64, i64* %8, align 8
  %10 = icmp ult i64 %7, %9
  br i1 %10, label %WhileBody, label %WhileEnd

WhileBody:                                        ; preds = %WhileCond
  %11 = load %std.hash.wyhash.WyhashStateless*, %std.hash.wyhash.WyhashStateless** %self, align 8
  %12 = load i64, i64* %off, align 8
  %13 = load i64, i64* %off, align 8
  %14 = add nuw i64 %13, 32
  %15 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 0
  %16 = load i8*, i8** %15, align 8
  %17 = getelementptr inbounds i8, i8* %16, i64 %12
  %18 = sub nuw i64 %14, %12
  %19 = getelementptr inbounds %"[]u8", %"[]u8"* %2, i32 0, i32 0
  store i8* %17, i8** %19, align 8
  %20 = getelementptr inbounds %"[]u8", %"[]u8"* %2, i32 0, i32 1
  store i64 %18, i64* %20, align 8
  call fastcc void @std.hash.wyhash.WyhashStateless.round(%std.hash.wyhash.WyhashStateless* %11, %"[]u8"* %2) #10
  %21 = load i64, i64* %off, align 8
  %22 = add nuw i64 %21, 32
  store i64 %22, i64* %off, align 8
  br label %WhileCond

WhileEnd:                                         ; preds = %WhileCond
  %23 = load %std.hash.wyhash.WyhashStateless*, %std.hash.wyhash.WyhashStateless** %self, align 8
  %24 = getelementptr inbounds %std.hash.wyhash.WyhashStateless, %std.hash.wyhash.WyhashStateless* %23, i32 0, i32 1
  %25 = load i64, i64* %24, align 8
  %26 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 1
  %27 = load i64, i64* %26, align 8
  %28 = add nuw i64 %25, %27
  store i64 %28, i64* %24, align 8
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i64 @std.hash.wyhash.WyhashStateless.final(%std.hash.wyhash.WyhashStateless* nonnull align 8 %0, %"[]u8"* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %result = alloca i64, align 8
  %seed = alloca i64, align 8
  %rem_len = alloca i5, align 1
  %rem_key = alloca %"[]u8", align 8
  %2 = alloca %"[]u8", align 8
  %3 = alloca %"[]u8", align 8
  %4 = alloca %"[]u8", align 8
  %5 = alloca %"[]u8", align 8
  %6 = alloca %"[]u8", align 8
  %7 = alloca %"[]u8", align 8
  %8 = alloca %"[]u8", align 8
  %9 = alloca %"[]u8", align 8
  %10 = alloca %"[]u8", align 8
  %11 = alloca %"[]u8", align 8
  %12 = alloca %"[]u8", align 8
  %13 = alloca %"[]u8", align 8
  %14 = alloca %"[]u8", align 8
  %15 = alloca %"[]u8", align 8
  %16 = alloca %"[]u8", align 8
  %17 = alloca %"[]u8", align 8
  %18 = alloca %"[]u8", align 8
  %19 = alloca %"[]u8", align 8
  %20 = alloca %"[]u8", align 8
  %21 = alloca %"[]u8", align 8
  %22 = alloca %"[]u8", align 8
  %23 = alloca %"[]u8", align 8
  %24 = alloca %"[]u8", align 8
  %25 = alloca %"[]u8", align 8
  %26 = alloca %"[]u8", align 8
  %27 = alloca %"[]u8", align 8
  %28 = alloca %"[]u8", align 8
  %29 = alloca %"[]u8", align 8
  %30 = alloca %"[]u8", align 8
  %31 = alloca %"[]u8", align 8
  %32 = alloca %"[]u8", align 8
  %33 = alloca %"[]u8", align 8
  %34 = alloca %"[]u8", align 8
  %35 = alloca %"[]u8", align 8
  %36 = alloca %"[]u8", align 8
  %37 = alloca %"[]u8", align 8
  %38 = alloca %"[]u8", align 8
  %39 = alloca %"[]u8", align 8
  %40 = alloca %"[]u8", align 8
  %41 = alloca %"[]u8", align 8
  %42 = alloca %"[]u8", align 8
  %43 = alloca %"[]u8", align 8
  %44 = alloca %"[]u8", align 8
  %45 = alloca %"[]u8", align 8
  %46 = alloca %"[]u8", align 8
  %47 = alloca %"[]u8", align 8
  %48 = alloca %"[]u8", align 8
  %49 = alloca %"[]u8", align 8
  %50 = alloca %"[]u8", align 8
  %51 = alloca %"[]u8", align 8
  %52 = alloca %"[]u8", align 8
  %53 = alloca %"[]u8", align 8
  %54 = alloca %"[]u8", align 8
  %55 = alloca %"[]u8", align 8
  %56 = alloca %"[]u8", align 8
  %57 = alloca %"[]u8", align 8
  %58 = alloca %"[]u8", align 8
  %59 = alloca %"[]u8", align 8
  %60 = alloca %"[]u8", align 8
  %61 = alloca %"[]u8", align 8
  %62 = alloca %"[]u8", align 8
  %63 = alloca %"[]u8", align 8
  %64 = alloca %"[]u8", align 8
  %65 = alloca %"[]u8", align 8
  %66 = alloca %"[]u8", align 8
  %67 = alloca %"[]u8", align 8
  %68 = alloca %"[]u8", align 8
  %69 = alloca %"[]u8", align 8
  %70 = alloca %"[]u8", align 8
  %71 = alloca %"[]u8", align 8
  %72 = alloca %"[]u8", align 8
  %73 = alloca %"[]u8", align 8
  %self = alloca %std.hash.wyhash.WyhashStateless*, align 8
  store %std.hash.wyhash.WyhashStateless* %0, %std.hash.wyhash.WyhashStateless** %self, align 8
  %74 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 1
  %75 = load i64, i64* %74, align 8
  %76 = icmp ult i64 %75, 32
  call fastcc void @std.debug.assert(i1 %76)
  %77 = load %std.hash.wyhash.WyhashStateless*, %std.hash.wyhash.WyhashStateless** %self, align 8
  %78 = getelementptr inbounds %std.hash.wyhash.WyhashStateless, %std.hash.wyhash.WyhashStateless* %77, i32 0, i32 0
  %79 = load i64, i64* %78, align 8
  store i64 %79, i64* %seed, align 8
  %80 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 1
  %81 = load i64, i64* %80, align 8
  %82 = trunc i64 %81 to i5
  store i5 %82, i5* %rem_len, align 1
  %83 = load i5, i5* %rem_len, align 1
  %84 = zext i5 %83 to i64
  %85 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 0
  %86 = load i8*, i8** %85, align 8
  %87 = getelementptr inbounds i8, i8* %86, i64 0
  %88 = sub nuw i64 %84, 0
  %89 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 0
  store i8* %87, i8** %89, align 8
  %90 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 1
  store i64 %88, i64* %90, align 8
  %91 = load %std.hash.wyhash.WyhashStateless*, %std.hash.wyhash.WyhashStateless** %self, align 8
  %92 = getelementptr inbounds %std.hash.wyhash.WyhashStateless, %std.hash.wyhash.WyhashStateless* %91, i32 0, i32 0
  %93 = load i5, i5* %rem_len, align 1
  switch i5 %93, label %SwitchElse [
    i5 0, label %SwitchProng
    i5 1, label %SwitchProng1
    i5 2, label %SwitchProng2
    i5 3, label %SwitchProng3
    i5 4, label %SwitchProng4
    i5 5, label %SwitchProng5
    i5 6, label %SwitchProng6
    i5 7, label %SwitchProng7
    i5 8, label %SwitchProng8
    i5 9, label %SwitchProng9
    i5 10, label %SwitchProng10
    i5 11, label %SwitchProng11
    i5 12, label %SwitchProng12
    i5 13, label %SwitchProng13
    i5 14, label %SwitchProng14
    i5 15, label %SwitchProng15
    i5 -16, label %SwitchProng16
    i5 -15, label %SwitchProng17
    i5 -14, label %SwitchProng18
    i5 -13, label %SwitchProng19
    i5 -12, label %SwitchProng20
    i5 -11, label %SwitchProng21
    i5 -10, label %SwitchProng22
    i5 -9, label %SwitchProng23
    i5 -8, label %SwitchProng24
    i5 -7, label %SwitchProng25
    i5 -6, label %SwitchProng26
    i5 -5, label %SwitchProng27
    i5 -4, label %SwitchProng28
    i5 -3, label %SwitchProng29
    i5 -2, label %SwitchProng30
    i5 -1, label %SwitchProng31
  ]

SwitchProng:                                      ; preds = %Entry
  %94 = load i64, i64* %seed, align 8
  store i64 %94, i64* %92, align 8
  br label %SwitchEnd

SwitchProng1:                                     ; preds = %Entry
  %95 = bitcast %"[]u8"* %rem_key to i8*
  %96 = bitcast %"[]u8"* %2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %96, i8* align 8 %95, i64 16, i1 false)
  %97 = call fastcc i64 @std.hash.wyhash.read_bytes(%"[]u8"* %rem_key)
  %98 = load i64, i64* %seed, align 8
  %99 = call fastcc i64 @std.hash.wyhash.mix0(i64 %97, i64 2129725606500045391, i64 %98)
  store i64 %99, i64* %92, align 8
  br label %SwitchEnd

SwitchProng2:                                     ; preds = %Entry
  %100 = bitcast %"[]u8"* %rem_key to i8*
  %101 = bitcast %"[]u8"* %3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %101, i8* align 8 %100, i64 16, i1 false)
  %102 = call fastcc i64 @std.hash.wyhash.read_bytes.134(%"[]u8"* %rem_key)
  %103 = load i64, i64* %seed, align 8
  %104 = call fastcc i64 @std.hash.wyhash.mix0(i64 %102, i64 2129725606500045391, i64 %103)
  store i64 %104, i64* %92, align 8
  br label %SwitchEnd

SwitchProng3:                                     ; preds = %Entry
  %105 = bitcast %"[]u8"* %rem_key to i8*
  %106 = bitcast %"[]u8"* %4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %106, i8* align 8 %105, i64 16, i1 false)
  %107 = call fastcc i64 @std.hash.wyhash.read_bytes.134(%"[]u8"* %rem_key)
  %108 = shl i64 %107, 8
  %109 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 1
  %110 = load i64, i64* %109, align 8
  %111 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 0
  %112 = load i8*, i8** %111, align 8
  %113 = getelementptr inbounds i8, i8* %112, i64 2
  %114 = sub nuw i64 %110, 2
  %115 = getelementptr inbounds %"[]u8", %"[]u8"* %5, i32 0, i32 0
  store i8* %113, i8** %115, align 8
  %116 = getelementptr inbounds %"[]u8", %"[]u8"* %5, i32 0, i32 1
  store i64 %114, i64* %116, align 8
  %117 = call fastcc i64 @std.hash.wyhash.read_bytes(%"[]u8"* %5)
  %118 = or i64 %108, %117
  %119 = load i64, i64* %seed, align 8
  %120 = call fastcc i64 @std.hash.wyhash.mix0(i64 %118, i64 2129725606500045391, i64 %119)
  store i64 %120, i64* %92, align 8
  br label %SwitchEnd

SwitchProng4:                                     ; preds = %Entry
  %121 = bitcast %"[]u8"* %rem_key to i8*
  %122 = bitcast %"[]u8"* %6 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %122, i8* align 8 %121, i64 16, i1 false)
  %123 = call fastcc i64 @std.hash.wyhash.read_bytes.135(%"[]u8"* %rem_key)
  %124 = load i64, i64* %seed, align 8
  %125 = call fastcc i64 @std.hash.wyhash.mix0(i64 %123, i64 2129725606500045391, i64 %124)
  store i64 %125, i64* %92, align 8
  br label %SwitchEnd

SwitchProng5:                                     ; preds = %Entry
  %126 = bitcast %"[]u8"* %rem_key to i8*
  %127 = bitcast %"[]u8"* %7 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %127, i8* align 8 %126, i64 16, i1 false)
  %128 = call fastcc i64 @std.hash.wyhash.read_bytes.135(%"[]u8"* %rem_key)
  %129 = shl i64 %128, 8
  %130 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 1
  %131 = load i64, i64* %130, align 8
  %132 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 0
  %133 = load i8*, i8** %132, align 8
  %134 = getelementptr inbounds i8, i8* %133, i64 4
  %135 = sub nuw i64 %131, 4
  %136 = getelementptr inbounds %"[]u8", %"[]u8"* %8, i32 0, i32 0
  store i8* %134, i8** %136, align 8
  %137 = getelementptr inbounds %"[]u8", %"[]u8"* %8, i32 0, i32 1
  store i64 %135, i64* %137, align 8
  %138 = call fastcc i64 @std.hash.wyhash.read_bytes(%"[]u8"* %8)
  %139 = or i64 %129, %138
  %140 = load i64, i64* %seed, align 8
  %141 = call fastcc i64 @std.hash.wyhash.mix0(i64 %139, i64 2129725606500045391, i64 %140)
  store i64 %141, i64* %92, align 8
  br label %SwitchEnd

SwitchProng6:                                     ; preds = %Entry
  %142 = bitcast %"[]u8"* %rem_key to i8*
  %143 = bitcast %"[]u8"* %9 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %143, i8* align 8 %142, i64 16, i1 false)
  %144 = call fastcc i64 @std.hash.wyhash.read_bytes.135(%"[]u8"* %rem_key)
  %145 = shl i64 %144, 16
  %146 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 1
  %147 = load i64, i64* %146, align 8
  %148 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 0
  %149 = load i8*, i8** %148, align 8
  %150 = getelementptr inbounds i8, i8* %149, i64 4
  %151 = sub nuw i64 %147, 4
  %152 = getelementptr inbounds %"[]u8", %"[]u8"* %10, i32 0, i32 0
  store i8* %150, i8** %152, align 8
  %153 = getelementptr inbounds %"[]u8", %"[]u8"* %10, i32 0, i32 1
  store i64 %151, i64* %153, align 8
  %154 = call fastcc i64 @std.hash.wyhash.read_bytes.134(%"[]u8"* %10)
  %155 = or i64 %145, %154
  %156 = load i64, i64* %seed, align 8
  %157 = call fastcc i64 @std.hash.wyhash.mix0(i64 %155, i64 2129725606500045391, i64 %156)
  store i64 %157, i64* %92, align 8
  br label %SwitchEnd

SwitchProng7:                                     ; preds = %Entry
  %158 = bitcast %"[]u8"* %rem_key to i8*
  %159 = bitcast %"[]u8"* %11 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %159, i8* align 8 %158, i64 16, i1 false)
  %160 = call fastcc i64 @std.hash.wyhash.read_bytes.135(%"[]u8"* %rem_key)
  %161 = shl i64 %160, 24
  %162 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 1
  %163 = load i64, i64* %162, align 8
  %164 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 0
  %165 = load i8*, i8** %164, align 8
  %166 = getelementptr inbounds i8, i8* %165, i64 4
  %167 = sub nuw i64 %163, 4
  %168 = getelementptr inbounds %"[]u8", %"[]u8"* %12, i32 0, i32 0
  store i8* %166, i8** %168, align 8
  %169 = getelementptr inbounds %"[]u8", %"[]u8"* %12, i32 0, i32 1
  store i64 %167, i64* %169, align 8
  %170 = call fastcc i64 @std.hash.wyhash.read_bytes.134(%"[]u8"* %12)
  %171 = shl i64 %170, 8
  %172 = or i64 %161, %171
  %173 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 1
  %174 = load i64, i64* %173, align 8
  %175 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 0
  %176 = load i8*, i8** %175, align 8
  %177 = getelementptr inbounds i8, i8* %176, i64 6
  %178 = sub nuw i64 %174, 6
  %179 = getelementptr inbounds %"[]u8", %"[]u8"* %13, i32 0, i32 0
  store i8* %177, i8** %179, align 8
  %180 = getelementptr inbounds %"[]u8", %"[]u8"* %13, i32 0, i32 1
  store i64 %178, i64* %180, align 8
  %181 = call fastcc i64 @std.hash.wyhash.read_bytes(%"[]u8"* %13)
  %182 = or i64 %172, %181
  %183 = load i64, i64* %seed, align 8
  %184 = call fastcc i64 @std.hash.wyhash.mix0(i64 %182, i64 2129725606500045391, i64 %183)
  store i64 %184, i64* %92, align 8
  br label %SwitchEnd

SwitchProng8:                                     ; preds = %Entry
  %185 = call fastcc i64 @std.hash.wyhash.read_8bytes_swapped(%"[]u8"* %rem_key)
  %186 = load i64, i64* %seed, align 8
  %187 = call fastcc i64 @std.hash.wyhash.mix0(i64 %185, i64 2129725606500045391, i64 %186)
  store i64 %187, i64* %92, align 8
  br label %SwitchEnd

SwitchProng9:                                     ; preds = %Entry
  %188 = call fastcc i64 @std.hash.wyhash.read_8bytes_swapped(%"[]u8"* %rem_key)
  %189 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 1
  %190 = load i64, i64* %189, align 8
  %191 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 0
  %192 = load i8*, i8** %191, align 8
  %193 = getelementptr inbounds i8, i8* %192, i64 8
  %194 = sub nuw i64 %190, 8
  %195 = getelementptr inbounds %"[]u8", %"[]u8"* %14, i32 0, i32 0
  store i8* %193, i8** %195, align 8
  %196 = getelementptr inbounds %"[]u8", %"[]u8"* %14, i32 0, i32 1
  store i64 %194, i64* %196, align 8
  %197 = call fastcc i64 @std.hash.wyhash.read_bytes(%"[]u8"* %14)
  %198 = load i64, i64* %seed, align 8
  %199 = call fastcc i64 @std.hash.wyhash.mix0(i64 %188, i64 %197, i64 %198)
  store i64 %199, i64* %92, align 8
  br label %SwitchEnd

SwitchProng10:                                    ; preds = %Entry
  %200 = call fastcc i64 @std.hash.wyhash.read_8bytes_swapped(%"[]u8"* %rem_key)
  %201 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 1
  %202 = load i64, i64* %201, align 8
  %203 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 0
  %204 = load i8*, i8** %203, align 8
  %205 = getelementptr inbounds i8, i8* %204, i64 8
  %206 = sub nuw i64 %202, 8
  %207 = getelementptr inbounds %"[]u8", %"[]u8"* %15, i32 0, i32 0
  store i8* %205, i8** %207, align 8
  %208 = getelementptr inbounds %"[]u8", %"[]u8"* %15, i32 0, i32 1
  store i64 %206, i64* %208, align 8
  %209 = call fastcc i64 @std.hash.wyhash.read_bytes.134(%"[]u8"* %15)
  %210 = load i64, i64* %seed, align 8
  %211 = call fastcc i64 @std.hash.wyhash.mix0(i64 %200, i64 %209, i64 %210)
  store i64 %211, i64* %92, align 8
  br label %SwitchEnd

SwitchProng11:                                    ; preds = %Entry
  %212 = call fastcc i64 @std.hash.wyhash.read_8bytes_swapped(%"[]u8"* %rem_key)
  %213 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 1
  %214 = load i64, i64* %213, align 8
  %215 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 0
  %216 = load i8*, i8** %215, align 8
  %217 = getelementptr inbounds i8, i8* %216, i64 8
  %218 = sub nuw i64 %214, 8
  %219 = getelementptr inbounds %"[]u8", %"[]u8"* %16, i32 0, i32 0
  store i8* %217, i8** %219, align 8
  %220 = getelementptr inbounds %"[]u8", %"[]u8"* %16, i32 0, i32 1
  store i64 %218, i64* %220, align 8
  %221 = call fastcc i64 @std.hash.wyhash.read_bytes.134(%"[]u8"* %16)
  %222 = shl i64 %221, 8
  %223 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 1
  %224 = load i64, i64* %223, align 8
  %225 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 0
  %226 = load i8*, i8** %225, align 8
  %227 = getelementptr inbounds i8, i8* %226, i64 10
  %228 = sub nuw i64 %224, 10
  %229 = getelementptr inbounds %"[]u8", %"[]u8"* %17, i32 0, i32 0
  store i8* %227, i8** %229, align 8
  %230 = getelementptr inbounds %"[]u8", %"[]u8"* %17, i32 0, i32 1
  store i64 %228, i64* %230, align 8
  %231 = call fastcc i64 @std.hash.wyhash.read_bytes(%"[]u8"* %17)
  %232 = or i64 %222, %231
  %233 = load i64, i64* %seed, align 8
  %234 = call fastcc i64 @std.hash.wyhash.mix0(i64 %212, i64 %232, i64 %233)
  store i64 %234, i64* %92, align 8
  br label %SwitchEnd

SwitchProng12:                                    ; preds = %Entry
  %235 = call fastcc i64 @std.hash.wyhash.read_8bytes_swapped(%"[]u8"* %rem_key)
  %236 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 1
  %237 = load i64, i64* %236, align 8
  %238 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 0
  %239 = load i8*, i8** %238, align 8
  %240 = getelementptr inbounds i8, i8* %239, i64 8
  %241 = sub nuw i64 %237, 8
  %242 = getelementptr inbounds %"[]u8", %"[]u8"* %18, i32 0, i32 0
  store i8* %240, i8** %242, align 8
  %243 = getelementptr inbounds %"[]u8", %"[]u8"* %18, i32 0, i32 1
  store i64 %241, i64* %243, align 8
  %244 = call fastcc i64 @std.hash.wyhash.read_bytes.135(%"[]u8"* %18)
  %245 = load i64, i64* %seed, align 8
  %246 = call fastcc i64 @std.hash.wyhash.mix0(i64 %235, i64 %244, i64 %245)
  store i64 %246, i64* %92, align 8
  br label %SwitchEnd

SwitchProng13:                                    ; preds = %Entry
  %247 = call fastcc i64 @std.hash.wyhash.read_8bytes_swapped(%"[]u8"* %rem_key)
  %248 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 1
  %249 = load i64, i64* %248, align 8
  %250 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 0
  %251 = load i8*, i8** %250, align 8
  %252 = getelementptr inbounds i8, i8* %251, i64 8
  %253 = sub nuw i64 %249, 8
  %254 = getelementptr inbounds %"[]u8", %"[]u8"* %19, i32 0, i32 0
  store i8* %252, i8** %254, align 8
  %255 = getelementptr inbounds %"[]u8", %"[]u8"* %19, i32 0, i32 1
  store i64 %253, i64* %255, align 8
  %256 = call fastcc i64 @std.hash.wyhash.read_bytes.135(%"[]u8"* %19)
  %257 = shl i64 %256, 8
  %258 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 1
  %259 = load i64, i64* %258, align 8
  %260 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 0
  %261 = load i8*, i8** %260, align 8
  %262 = getelementptr inbounds i8, i8* %261, i64 12
  %263 = sub nuw i64 %259, 12
  %264 = getelementptr inbounds %"[]u8", %"[]u8"* %20, i32 0, i32 0
  store i8* %262, i8** %264, align 8
  %265 = getelementptr inbounds %"[]u8", %"[]u8"* %20, i32 0, i32 1
  store i64 %263, i64* %265, align 8
  %266 = call fastcc i64 @std.hash.wyhash.read_bytes(%"[]u8"* %20)
  %267 = or i64 %257, %266
  %268 = load i64, i64* %seed, align 8
  %269 = call fastcc i64 @std.hash.wyhash.mix0(i64 %247, i64 %267, i64 %268)
  store i64 %269, i64* %92, align 8
  br label %SwitchEnd

SwitchProng14:                                    ; preds = %Entry
  %270 = call fastcc i64 @std.hash.wyhash.read_8bytes_swapped(%"[]u8"* %rem_key)
  %271 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 1
  %272 = load i64, i64* %271, align 8
  %273 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 0
  %274 = load i8*, i8** %273, align 8
  %275 = getelementptr inbounds i8, i8* %274, i64 8
  %276 = sub nuw i64 %272, 8
  %277 = getelementptr inbounds %"[]u8", %"[]u8"* %21, i32 0, i32 0
  store i8* %275, i8** %277, align 8
  %278 = getelementptr inbounds %"[]u8", %"[]u8"* %21, i32 0, i32 1
  store i64 %276, i64* %278, align 8
  %279 = call fastcc i64 @std.hash.wyhash.read_bytes.135(%"[]u8"* %21)
  %280 = shl i64 %279, 16
  %281 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 1
  %282 = load i64, i64* %281, align 8
  %283 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 0
  %284 = load i8*, i8** %283, align 8
  %285 = getelementptr inbounds i8, i8* %284, i64 12
  %286 = sub nuw i64 %282, 12
  %287 = getelementptr inbounds %"[]u8", %"[]u8"* %22, i32 0, i32 0
  store i8* %285, i8** %287, align 8
  %288 = getelementptr inbounds %"[]u8", %"[]u8"* %22, i32 0, i32 1
  store i64 %286, i64* %288, align 8
  %289 = call fastcc i64 @std.hash.wyhash.read_bytes.134(%"[]u8"* %22)
  %290 = or i64 %280, %289
  %291 = load i64, i64* %seed, align 8
  %292 = call fastcc i64 @std.hash.wyhash.mix0(i64 %270, i64 %290, i64 %291)
  store i64 %292, i64* %92, align 8
  br label %SwitchEnd

SwitchProng15:                                    ; preds = %Entry
  %293 = call fastcc i64 @std.hash.wyhash.read_8bytes_swapped(%"[]u8"* %rem_key)
  %294 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 1
  %295 = load i64, i64* %294, align 8
  %296 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 0
  %297 = load i8*, i8** %296, align 8
  %298 = getelementptr inbounds i8, i8* %297, i64 8
  %299 = sub nuw i64 %295, 8
  %300 = getelementptr inbounds %"[]u8", %"[]u8"* %23, i32 0, i32 0
  store i8* %298, i8** %300, align 8
  %301 = getelementptr inbounds %"[]u8", %"[]u8"* %23, i32 0, i32 1
  store i64 %299, i64* %301, align 8
  %302 = call fastcc i64 @std.hash.wyhash.read_bytes.135(%"[]u8"* %23)
  %303 = shl i64 %302, 24
  %304 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 1
  %305 = load i64, i64* %304, align 8
  %306 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 0
  %307 = load i8*, i8** %306, align 8
  %308 = getelementptr inbounds i8, i8* %307, i64 12
  %309 = sub nuw i64 %305, 12
  %310 = getelementptr inbounds %"[]u8", %"[]u8"* %24, i32 0, i32 0
  store i8* %308, i8** %310, align 8
  %311 = getelementptr inbounds %"[]u8", %"[]u8"* %24, i32 0, i32 1
  store i64 %309, i64* %311, align 8
  %312 = call fastcc i64 @std.hash.wyhash.read_bytes.134(%"[]u8"* %24)
  %313 = shl i64 %312, 8
  %314 = or i64 %303, %313
  %315 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 1
  %316 = load i64, i64* %315, align 8
  %317 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 0
  %318 = load i8*, i8** %317, align 8
  %319 = getelementptr inbounds i8, i8* %318, i64 14
  %320 = sub nuw i64 %316, 14
  %321 = getelementptr inbounds %"[]u8", %"[]u8"* %25, i32 0, i32 0
  store i8* %319, i8** %321, align 8
  %322 = getelementptr inbounds %"[]u8", %"[]u8"* %25, i32 0, i32 1
  store i64 %320, i64* %322, align 8
  %323 = call fastcc i64 @std.hash.wyhash.read_bytes(%"[]u8"* %25)
  %324 = or i64 %314, %323
  %325 = load i64, i64* %seed, align 8
  %326 = call fastcc i64 @std.hash.wyhash.mix0(i64 %293, i64 %324, i64 %325)
  store i64 %326, i64* %92, align 8
  br label %SwitchEnd

SwitchProng16:                                    ; preds = %Entry
  %327 = call fastcc i64 @std.hash.wyhash.read_8bytes_swapped(%"[]u8"* %rem_key)
  %328 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 1
  %329 = load i64, i64* %328, align 8
  %330 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 0
  %331 = load i8*, i8** %330, align 8
  %332 = getelementptr inbounds i8, i8* %331, i64 8
  %333 = sub nuw i64 %329, 8
  %334 = getelementptr inbounds %"[]u8", %"[]u8"* %26, i32 0, i32 0
  store i8* %332, i8** %334, align 8
  %335 = getelementptr inbounds %"[]u8", %"[]u8"* %26, i32 0, i32 1
  store i64 %333, i64* %335, align 8
  %336 = call fastcc i64 @std.hash.wyhash.read_8bytes_swapped(%"[]u8"* %26)
  %337 = load i64, i64* %seed, align 8
  %338 = call fastcc i64 @std.hash.wyhash.mix0(i64 %327, i64 %336, i64 %337)
  store i64 %338, i64* %92, align 8
  br label %SwitchEnd

SwitchProng17:                                    ; preds = %Entry
  %339 = call fastcc i64 @std.hash.wyhash.read_8bytes_swapped(%"[]u8"* %rem_key)
  %340 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 1
  %341 = load i64, i64* %340, align 8
  %342 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 0
  %343 = load i8*, i8** %342, align 8
  %344 = getelementptr inbounds i8, i8* %343, i64 8
  %345 = sub nuw i64 %341, 8
  %346 = getelementptr inbounds %"[]u8", %"[]u8"* %27, i32 0, i32 0
  store i8* %344, i8** %346, align 8
  %347 = getelementptr inbounds %"[]u8", %"[]u8"* %27, i32 0, i32 1
  store i64 %345, i64* %347, align 8
  %348 = call fastcc i64 @std.hash.wyhash.read_8bytes_swapped(%"[]u8"* %27)
  %349 = load i64, i64* %seed, align 8
  %350 = call fastcc i64 @std.hash.wyhash.mix0(i64 %339, i64 %348, i64 %349)
  %351 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 1
  %352 = load i64, i64* %351, align 8
  %353 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 0
  %354 = load i8*, i8** %353, align 8
  %355 = getelementptr inbounds i8, i8* %354, i64 16
  %356 = sub nuw i64 %352, 16
  %357 = getelementptr inbounds %"[]u8", %"[]u8"* %28, i32 0, i32 0
  store i8* %355, i8** %357, align 8
  %358 = getelementptr inbounds %"[]u8", %"[]u8"* %28, i32 0, i32 1
  store i64 %356, i64* %358, align 8
  %359 = call fastcc i64 @std.hash.wyhash.read_bytes(%"[]u8"* %28)
  %360 = load i64, i64* %seed, align 8
  %361 = call fastcc i64 @std.hash.wyhash.mix1(i64 %359, i64 2129725606500045391, i64 %360)
  %362 = xor i64 %350, %361
  store i64 %362, i64* %92, align 8
  br label %SwitchEnd

SwitchProng18:                                    ; preds = %Entry
  %363 = call fastcc i64 @std.hash.wyhash.read_8bytes_swapped(%"[]u8"* %rem_key)
  %364 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 1
  %365 = load i64, i64* %364, align 8
  %366 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 0
  %367 = load i8*, i8** %366, align 8
  %368 = getelementptr inbounds i8, i8* %367, i64 8
  %369 = sub nuw i64 %365, 8
  %370 = getelementptr inbounds %"[]u8", %"[]u8"* %29, i32 0, i32 0
  store i8* %368, i8** %370, align 8
  %371 = getelementptr inbounds %"[]u8", %"[]u8"* %29, i32 0, i32 1
  store i64 %369, i64* %371, align 8
  %372 = call fastcc i64 @std.hash.wyhash.read_8bytes_swapped(%"[]u8"* %29)
  %373 = load i64, i64* %seed, align 8
  %374 = call fastcc i64 @std.hash.wyhash.mix0(i64 %363, i64 %372, i64 %373)
  %375 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 1
  %376 = load i64, i64* %375, align 8
  %377 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 0
  %378 = load i8*, i8** %377, align 8
  %379 = getelementptr inbounds i8, i8* %378, i64 16
  %380 = sub nuw i64 %376, 16
  %381 = getelementptr inbounds %"[]u8", %"[]u8"* %30, i32 0, i32 0
  store i8* %379, i8** %381, align 8
  %382 = getelementptr inbounds %"[]u8", %"[]u8"* %30, i32 0, i32 1
  store i64 %380, i64* %382, align 8
  %383 = call fastcc i64 @std.hash.wyhash.read_bytes.134(%"[]u8"* %30)
  %384 = load i64, i64* %seed, align 8
  %385 = call fastcc i64 @std.hash.wyhash.mix1(i64 %383, i64 2129725606500045391, i64 %384)
  %386 = xor i64 %374, %385
  store i64 %386, i64* %92, align 8
  br label %SwitchEnd

SwitchProng19:                                    ; preds = %Entry
  %387 = call fastcc i64 @std.hash.wyhash.read_8bytes_swapped(%"[]u8"* %rem_key)
  %388 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 1
  %389 = load i64, i64* %388, align 8
  %390 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 0
  %391 = load i8*, i8** %390, align 8
  %392 = getelementptr inbounds i8, i8* %391, i64 8
  %393 = sub nuw i64 %389, 8
  %394 = getelementptr inbounds %"[]u8", %"[]u8"* %31, i32 0, i32 0
  store i8* %392, i8** %394, align 8
  %395 = getelementptr inbounds %"[]u8", %"[]u8"* %31, i32 0, i32 1
  store i64 %393, i64* %395, align 8
  %396 = call fastcc i64 @std.hash.wyhash.read_8bytes_swapped(%"[]u8"* %31)
  %397 = load i64, i64* %seed, align 8
  %398 = call fastcc i64 @std.hash.wyhash.mix0(i64 %387, i64 %396, i64 %397)
  %399 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 1
  %400 = load i64, i64* %399, align 8
  %401 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 0
  %402 = load i8*, i8** %401, align 8
  %403 = getelementptr inbounds i8, i8* %402, i64 16
  %404 = sub nuw i64 %400, 16
  %405 = getelementptr inbounds %"[]u8", %"[]u8"* %32, i32 0, i32 0
  store i8* %403, i8** %405, align 8
  %406 = getelementptr inbounds %"[]u8", %"[]u8"* %32, i32 0, i32 1
  store i64 %404, i64* %406, align 8
  %407 = call fastcc i64 @std.hash.wyhash.read_bytes.134(%"[]u8"* %32)
  %408 = shl i64 %407, 8
  %409 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 1
  %410 = load i64, i64* %409, align 8
  %411 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 0
  %412 = load i8*, i8** %411, align 8
  %413 = getelementptr inbounds i8, i8* %412, i64 18
  %414 = sub nuw i64 %410, 18
  %415 = getelementptr inbounds %"[]u8", %"[]u8"* %33, i32 0, i32 0
  store i8* %413, i8** %415, align 8
  %416 = getelementptr inbounds %"[]u8", %"[]u8"* %33, i32 0, i32 1
  store i64 %414, i64* %416, align 8
  %417 = call fastcc i64 @std.hash.wyhash.read_bytes(%"[]u8"* %33)
  %418 = or i64 %408, %417
  %419 = load i64, i64* %seed, align 8
  %420 = call fastcc i64 @std.hash.wyhash.mix1(i64 %418, i64 2129725606500045391, i64 %419)
  %421 = xor i64 %398, %420
  store i64 %421, i64* %92, align 8
  br label %SwitchEnd

SwitchProng20:                                    ; preds = %Entry
  %422 = call fastcc i64 @std.hash.wyhash.read_8bytes_swapped(%"[]u8"* %rem_key)
  %423 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 1
  %424 = load i64, i64* %423, align 8
  %425 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 0
  %426 = load i8*, i8** %425, align 8
  %427 = getelementptr inbounds i8, i8* %426, i64 8
  %428 = sub nuw i64 %424, 8
  %429 = getelementptr inbounds %"[]u8", %"[]u8"* %34, i32 0, i32 0
  store i8* %427, i8** %429, align 8
  %430 = getelementptr inbounds %"[]u8", %"[]u8"* %34, i32 0, i32 1
  store i64 %428, i64* %430, align 8
  %431 = call fastcc i64 @std.hash.wyhash.read_8bytes_swapped(%"[]u8"* %34)
  %432 = load i64, i64* %seed, align 8
  %433 = call fastcc i64 @std.hash.wyhash.mix0(i64 %422, i64 %431, i64 %432)
  %434 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 1
  %435 = load i64, i64* %434, align 8
  %436 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 0
  %437 = load i8*, i8** %436, align 8
  %438 = getelementptr inbounds i8, i8* %437, i64 16
  %439 = sub nuw i64 %435, 16
  %440 = getelementptr inbounds %"[]u8", %"[]u8"* %35, i32 0, i32 0
  store i8* %438, i8** %440, align 8
  %441 = getelementptr inbounds %"[]u8", %"[]u8"* %35, i32 0, i32 1
  store i64 %439, i64* %441, align 8
  %442 = call fastcc i64 @std.hash.wyhash.read_bytes.135(%"[]u8"* %35)
  %443 = load i64, i64* %seed, align 8
  %444 = call fastcc i64 @std.hash.wyhash.mix1(i64 %442, i64 2129725606500045391, i64 %443)
  %445 = xor i64 %433, %444
  store i64 %445, i64* %92, align 8
  br label %SwitchEnd

SwitchProng21:                                    ; preds = %Entry
  %446 = call fastcc i64 @std.hash.wyhash.read_8bytes_swapped(%"[]u8"* %rem_key)
  %447 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 1
  %448 = load i64, i64* %447, align 8
  %449 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 0
  %450 = load i8*, i8** %449, align 8
  %451 = getelementptr inbounds i8, i8* %450, i64 8
  %452 = sub nuw i64 %448, 8
  %453 = getelementptr inbounds %"[]u8", %"[]u8"* %36, i32 0, i32 0
  store i8* %451, i8** %453, align 8
  %454 = getelementptr inbounds %"[]u8", %"[]u8"* %36, i32 0, i32 1
  store i64 %452, i64* %454, align 8
  %455 = call fastcc i64 @std.hash.wyhash.read_8bytes_swapped(%"[]u8"* %36)
  %456 = load i64, i64* %seed, align 8
  %457 = call fastcc i64 @std.hash.wyhash.mix0(i64 %446, i64 %455, i64 %456)
  %458 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 1
  %459 = load i64, i64* %458, align 8
  %460 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 0
  %461 = load i8*, i8** %460, align 8
  %462 = getelementptr inbounds i8, i8* %461, i64 16
  %463 = sub nuw i64 %459, 16
  %464 = getelementptr inbounds %"[]u8", %"[]u8"* %37, i32 0, i32 0
  store i8* %462, i8** %464, align 8
  %465 = getelementptr inbounds %"[]u8", %"[]u8"* %37, i32 0, i32 1
  store i64 %463, i64* %465, align 8
  %466 = call fastcc i64 @std.hash.wyhash.read_bytes.135(%"[]u8"* %37)
  %467 = shl i64 %466, 8
  %468 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 1
  %469 = load i64, i64* %468, align 8
  %470 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 0
  %471 = load i8*, i8** %470, align 8
  %472 = getelementptr inbounds i8, i8* %471, i64 20
  %473 = sub nuw i64 %469, 20
  %474 = getelementptr inbounds %"[]u8", %"[]u8"* %38, i32 0, i32 0
  store i8* %472, i8** %474, align 8
  %475 = getelementptr inbounds %"[]u8", %"[]u8"* %38, i32 0, i32 1
  store i64 %473, i64* %475, align 8
  %476 = call fastcc i64 @std.hash.wyhash.read_bytes(%"[]u8"* %38)
  %477 = or i64 %467, %476
  %478 = load i64, i64* %seed, align 8
  %479 = call fastcc i64 @std.hash.wyhash.mix1(i64 %477, i64 2129725606500045391, i64 %478)
  %480 = xor i64 %457, %479
  store i64 %480, i64* %92, align 8
  br label %SwitchEnd

SwitchProng22:                                    ; preds = %Entry
  %481 = call fastcc i64 @std.hash.wyhash.read_8bytes_swapped(%"[]u8"* %rem_key)
  %482 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 1
  %483 = load i64, i64* %482, align 8
  %484 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 0
  %485 = load i8*, i8** %484, align 8
  %486 = getelementptr inbounds i8, i8* %485, i64 8
  %487 = sub nuw i64 %483, 8
  %488 = getelementptr inbounds %"[]u8", %"[]u8"* %39, i32 0, i32 0
  store i8* %486, i8** %488, align 8
  %489 = getelementptr inbounds %"[]u8", %"[]u8"* %39, i32 0, i32 1
  store i64 %487, i64* %489, align 8
  %490 = call fastcc i64 @std.hash.wyhash.read_8bytes_swapped(%"[]u8"* %39)
  %491 = load i64, i64* %seed, align 8
  %492 = call fastcc i64 @std.hash.wyhash.mix0(i64 %481, i64 %490, i64 %491)
  %493 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 1
  %494 = load i64, i64* %493, align 8
  %495 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 0
  %496 = load i8*, i8** %495, align 8
  %497 = getelementptr inbounds i8, i8* %496, i64 16
  %498 = sub nuw i64 %494, 16
  %499 = getelementptr inbounds %"[]u8", %"[]u8"* %40, i32 0, i32 0
  store i8* %497, i8** %499, align 8
  %500 = getelementptr inbounds %"[]u8", %"[]u8"* %40, i32 0, i32 1
  store i64 %498, i64* %500, align 8
  %501 = call fastcc i64 @std.hash.wyhash.read_bytes.135(%"[]u8"* %40)
  %502 = shl i64 %501, 16
  %503 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 1
  %504 = load i64, i64* %503, align 8
  %505 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 0
  %506 = load i8*, i8** %505, align 8
  %507 = getelementptr inbounds i8, i8* %506, i64 20
  %508 = sub nuw i64 %504, 20
  %509 = getelementptr inbounds %"[]u8", %"[]u8"* %41, i32 0, i32 0
  store i8* %507, i8** %509, align 8
  %510 = getelementptr inbounds %"[]u8", %"[]u8"* %41, i32 0, i32 1
  store i64 %508, i64* %510, align 8
  %511 = call fastcc i64 @std.hash.wyhash.read_bytes.134(%"[]u8"* %41)
  %512 = or i64 %502, %511
  %513 = load i64, i64* %seed, align 8
  %514 = call fastcc i64 @std.hash.wyhash.mix1(i64 %512, i64 2129725606500045391, i64 %513)
  %515 = xor i64 %492, %514
  store i64 %515, i64* %92, align 8
  br label %SwitchEnd

SwitchProng23:                                    ; preds = %Entry
  %516 = call fastcc i64 @std.hash.wyhash.read_8bytes_swapped(%"[]u8"* %rem_key)
  %517 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 1
  %518 = load i64, i64* %517, align 8
  %519 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 0
  %520 = load i8*, i8** %519, align 8
  %521 = getelementptr inbounds i8, i8* %520, i64 8
  %522 = sub nuw i64 %518, 8
  %523 = getelementptr inbounds %"[]u8", %"[]u8"* %42, i32 0, i32 0
  store i8* %521, i8** %523, align 8
  %524 = getelementptr inbounds %"[]u8", %"[]u8"* %42, i32 0, i32 1
  store i64 %522, i64* %524, align 8
  %525 = call fastcc i64 @std.hash.wyhash.read_8bytes_swapped(%"[]u8"* %42)
  %526 = load i64, i64* %seed, align 8
  %527 = call fastcc i64 @std.hash.wyhash.mix0(i64 %516, i64 %525, i64 %526)
  %528 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 1
  %529 = load i64, i64* %528, align 8
  %530 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 0
  %531 = load i8*, i8** %530, align 8
  %532 = getelementptr inbounds i8, i8* %531, i64 16
  %533 = sub nuw i64 %529, 16
  %534 = getelementptr inbounds %"[]u8", %"[]u8"* %43, i32 0, i32 0
  store i8* %532, i8** %534, align 8
  %535 = getelementptr inbounds %"[]u8", %"[]u8"* %43, i32 0, i32 1
  store i64 %533, i64* %535, align 8
  %536 = call fastcc i64 @std.hash.wyhash.read_bytes.135(%"[]u8"* %43)
  %537 = shl i64 %536, 24
  %538 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 1
  %539 = load i64, i64* %538, align 8
  %540 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 0
  %541 = load i8*, i8** %540, align 8
  %542 = getelementptr inbounds i8, i8* %541, i64 20
  %543 = sub nuw i64 %539, 20
  %544 = getelementptr inbounds %"[]u8", %"[]u8"* %44, i32 0, i32 0
  store i8* %542, i8** %544, align 8
  %545 = getelementptr inbounds %"[]u8", %"[]u8"* %44, i32 0, i32 1
  store i64 %543, i64* %545, align 8
  %546 = call fastcc i64 @std.hash.wyhash.read_bytes.134(%"[]u8"* %44)
  %547 = shl i64 %546, 8
  %548 = or i64 %537, %547
  %549 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 1
  %550 = load i64, i64* %549, align 8
  %551 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 0
  %552 = load i8*, i8** %551, align 8
  %553 = getelementptr inbounds i8, i8* %552, i64 22
  %554 = sub nuw i64 %550, 22
  %555 = getelementptr inbounds %"[]u8", %"[]u8"* %45, i32 0, i32 0
  store i8* %553, i8** %555, align 8
  %556 = getelementptr inbounds %"[]u8", %"[]u8"* %45, i32 0, i32 1
  store i64 %554, i64* %556, align 8
  %557 = call fastcc i64 @std.hash.wyhash.read_bytes(%"[]u8"* %45)
  %558 = or i64 %548, %557
  %559 = load i64, i64* %seed, align 8
  %560 = call fastcc i64 @std.hash.wyhash.mix1(i64 %558, i64 2129725606500045391, i64 %559)
  %561 = xor i64 %527, %560
  store i64 %561, i64* %92, align 8
  br label %SwitchEnd

SwitchProng24:                                    ; preds = %Entry
  %562 = call fastcc i64 @std.hash.wyhash.read_8bytes_swapped(%"[]u8"* %rem_key)
  %563 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 1
  %564 = load i64, i64* %563, align 8
  %565 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 0
  %566 = load i8*, i8** %565, align 8
  %567 = getelementptr inbounds i8, i8* %566, i64 8
  %568 = sub nuw i64 %564, 8
  %569 = getelementptr inbounds %"[]u8", %"[]u8"* %46, i32 0, i32 0
  store i8* %567, i8** %569, align 8
  %570 = getelementptr inbounds %"[]u8", %"[]u8"* %46, i32 0, i32 1
  store i64 %568, i64* %570, align 8
  %571 = call fastcc i64 @std.hash.wyhash.read_8bytes_swapped(%"[]u8"* %46)
  %572 = load i64, i64* %seed, align 8
  %573 = call fastcc i64 @std.hash.wyhash.mix0(i64 %562, i64 %571, i64 %572)
  %574 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 1
  %575 = load i64, i64* %574, align 8
  %576 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 0
  %577 = load i8*, i8** %576, align 8
  %578 = getelementptr inbounds i8, i8* %577, i64 16
  %579 = sub nuw i64 %575, 16
  %580 = getelementptr inbounds %"[]u8", %"[]u8"* %47, i32 0, i32 0
  store i8* %578, i8** %580, align 8
  %581 = getelementptr inbounds %"[]u8", %"[]u8"* %47, i32 0, i32 1
  store i64 %579, i64* %581, align 8
  %582 = call fastcc i64 @std.hash.wyhash.read_8bytes_swapped(%"[]u8"* %47)
  %583 = load i64, i64* %seed, align 8
  %584 = call fastcc i64 @std.hash.wyhash.mix1(i64 %582, i64 2129725606500045391, i64 %583)
  %585 = xor i64 %573, %584
  store i64 %585, i64* %92, align 8
  br label %SwitchEnd

SwitchProng25:                                    ; preds = %Entry
  %586 = call fastcc i64 @std.hash.wyhash.read_8bytes_swapped(%"[]u8"* %rem_key)
  %587 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 1
  %588 = load i64, i64* %587, align 8
  %589 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 0
  %590 = load i8*, i8** %589, align 8
  %591 = getelementptr inbounds i8, i8* %590, i64 8
  %592 = sub nuw i64 %588, 8
  %593 = getelementptr inbounds %"[]u8", %"[]u8"* %48, i32 0, i32 0
  store i8* %591, i8** %593, align 8
  %594 = getelementptr inbounds %"[]u8", %"[]u8"* %48, i32 0, i32 1
  store i64 %592, i64* %594, align 8
  %595 = call fastcc i64 @std.hash.wyhash.read_8bytes_swapped(%"[]u8"* %48)
  %596 = load i64, i64* %seed, align 8
  %597 = call fastcc i64 @std.hash.wyhash.mix0(i64 %586, i64 %595, i64 %596)
  %598 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 1
  %599 = load i64, i64* %598, align 8
  %600 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 0
  %601 = load i8*, i8** %600, align 8
  %602 = getelementptr inbounds i8, i8* %601, i64 16
  %603 = sub nuw i64 %599, 16
  %604 = getelementptr inbounds %"[]u8", %"[]u8"* %49, i32 0, i32 0
  store i8* %602, i8** %604, align 8
  %605 = getelementptr inbounds %"[]u8", %"[]u8"* %49, i32 0, i32 1
  store i64 %603, i64* %605, align 8
  %606 = call fastcc i64 @std.hash.wyhash.read_8bytes_swapped(%"[]u8"* %49)
  %607 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 1
  %608 = load i64, i64* %607, align 8
  %609 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 0
  %610 = load i8*, i8** %609, align 8
  %611 = getelementptr inbounds i8, i8* %610, i64 24
  %612 = sub nuw i64 %608, 24
  %613 = getelementptr inbounds %"[]u8", %"[]u8"* %50, i32 0, i32 0
  store i8* %611, i8** %613, align 8
  %614 = getelementptr inbounds %"[]u8", %"[]u8"* %50, i32 0, i32 1
  store i64 %612, i64* %614, align 8
  %615 = call fastcc i64 @std.hash.wyhash.read_bytes(%"[]u8"* %50)
  %616 = load i64, i64* %seed, align 8
  %617 = call fastcc i64 @std.hash.wyhash.mix1(i64 %606, i64 %615, i64 %616)
  %618 = xor i64 %597, %617
  store i64 %618, i64* %92, align 8
  br label %SwitchEnd

SwitchProng26:                                    ; preds = %Entry
  %619 = call fastcc i64 @std.hash.wyhash.read_8bytes_swapped(%"[]u8"* %rem_key)
  %620 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 1
  %621 = load i64, i64* %620, align 8
  %622 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 0
  %623 = load i8*, i8** %622, align 8
  %624 = getelementptr inbounds i8, i8* %623, i64 8
  %625 = sub nuw i64 %621, 8
  %626 = getelementptr inbounds %"[]u8", %"[]u8"* %51, i32 0, i32 0
  store i8* %624, i8** %626, align 8
  %627 = getelementptr inbounds %"[]u8", %"[]u8"* %51, i32 0, i32 1
  store i64 %625, i64* %627, align 8
  %628 = call fastcc i64 @std.hash.wyhash.read_8bytes_swapped(%"[]u8"* %51)
  %629 = load i64, i64* %seed, align 8
  %630 = call fastcc i64 @std.hash.wyhash.mix0(i64 %619, i64 %628, i64 %629)
  %631 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 1
  %632 = load i64, i64* %631, align 8
  %633 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 0
  %634 = load i8*, i8** %633, align 8
  %635 = getelementptr inbounds i8, i8* %634, i64 16
  %636 = sub nuw i64 %632, 16
  %637 = getelementptr inbounds %"[]u8", %"[]u8"* %52, i32 0, i32 0
  store i8* %635, i8** %637, align 8
  %638 = getelementptr inbounds %"[]u8", %"[]u8"* %52, i32 0, i32 1
  store i64 %636, i64* %638, align 8
  %639 = call fastcc i64 @std.hash.wyhash.read_8bytes_swapped(%"[]u8"* %52)
  %640 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 1
  %641 = load i64, i64* %640, align 8
  %642 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 0
  %643 = load i8*, i8** %642, align 8
  %644 = getelementptr inbounds i8, i8* %643, i64 24
  %645 = sub nuw i64 %641, 24
  %646 = getelementptr inbounds %"[]u8", %"[]u8"* %53, i32 0, i32 0
  store i8* %644, i8** %646, align 8
  %647 = getelementptr inbounds %"[]u8", %"[]u8"* %53, i32 0, i32 1
  store i64 %645, i64* %647, align 8
  %648 = call fastcc i64 @std.hash.wyhash.read_bytes.134(%"[]u8"* %53)
  %649 = load i64, i64* %seed, align 8
  %650 = call fastcc i64 @std.hash.wyhash.mix1(i64 %639, i64 %648, i64 %649)
  %651 = xor i64 %630, %650
  store i64 %651, i64* %92, align 8
  br label %SwitchEnd

SwitchProng27:                                    ; preds = %Entry
  %652 = call fastcc i64 @std.hash.wyhash.read_8bytes_swapped(%"[]u8"* %rem_key)
  %653 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 1
  %654 = load i64, i64* %653, align 8
  %655 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 0
  %656 = load i8*, i8** %655, align 8
  %657 = getelementptr inbounds i8, i8* %656, i64 8
  %658 = sub nuw i64 %654, 8
  %659 = getelementptr inbounds %"[]u8", %"[]u8"* %54, i32 0, i32 0
  store i8* %657, i8** %659, align 8
  %660 = getelementptr inbounds %"[]u8", %"[]u8"* %54, i32 0, i32 1
  store i64 %658, i64* %660, align 8
  %661 = call fastcc i64 @std.hash.wyhash.read_8bytes_swapped(%"[]u8"* %54)
  %662 = load i64, i64* %seed, align 8
  %663 = call fastcc i64 @std.hash.wyhash.mix0(i64 %652, i64 %661, i64 %662)
  %664 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 1
  %665 = load i64, i64* %664, align 8
  %666 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 0
  %667 = load i8*, i8** %666, align 8
  %668 = getelementptr inbounds i8, i8* %667, i64 16
  %669 = sub nuw i64 %665, 16
  %670 = getelementptr inbounds %"[]u8", %"[]u8"* %55, i32 0, i32 0
  store i8* %668, i8** %670, align 8
  %671 = getelementptr inbounds %"[]u8", %"[]u8"* %55, i32 0, i32 1
  store i64 %669, i64* %671, align 8
  %672 = call fastcc i64 @std.hash.wyhash.read_8bytes_swapped(%"[]u8"* %55)
  %673 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 1
  %674 = load i64, i64* %673, align 8
  %675 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 0
  %676 = load i8*, i8** %675, align 8
  %677 = getelementptr inbounds i8, i8* %676, i64 24
  %678 = sub nuw i64 %674, 24
  %679 = getelementptr inbounds %"[]u8", %"[]u8"* %56, i32 0, i32 0
  store i8* %677, i8** %679, align 8
  %680 = getelementptr inbounds %"[]u8", %"[]u8"* %56, i32 0, i32 1
  store i64 %678, i64* %680, align 8
  %681 = call fastcc i64 @std.hash.wyhash.read_bytes.134(%"[]u8"* %56)
  %682 = shl i64 %681, 8
  %683 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 1
  %684 = load i64, i64* %683, align 8
  %685 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 0
  %686 = load i8*, i8** %685, align 8
  %687 = getelementptr inbounds i8, i8* %686, i64 26
  %688 = sub nuw i64 %684, 26
  %689 = getelementptr inbounds %"[]u8", %"[]u8"* %57, i32 0, i32 0
  store i8* %687, i8** %689, align 8
  %690 = getelementptr inbounds %"[]u8", %"[]u8"* %57, i32 0, i32 1
  store i64 %688, i64* %690, align 8
  %691 = call fastcc i64 @std.hash.wyhash.read_bytes(%"[]u8"* %57)
  %692 = or i64 %682, %691
  %693 = load i64, i64* %seed, align 8
  %694 = call fastcc i64 @std.hash.wyhash.mix1(i64 %672, i64 %692, i64 %693)
  %695 = xor i64 %663, %694
  store i64 %695, i64* %92, align 8
  br label %SwitchEnd

SwitchProng28:                                    ; preds = %Entry
  %696 = call fastcc i64 @std.hash.wyhash.read_8bytes_swapped(%"[]u8"* %rem_key)
  %697 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 1
  %698 = load i64, i64* %697, align 8
  %699 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 0
  %700 = load i8*, i8** %699, align 8
  %701 = getelementptr inbounds i8, i8* %700, i64 8
  %702 = sub nuw i64 %698, 8
  %703 = getelementptr inbounds %"[]u8", %"[]u8"* %58, i32 0, i32 0
  store i8* %701, i8** %703, align 8
  %704 = getelementptr inbounds %"[]u8", %"[]u8"* %58, i32 0, i32 1
  store i64 %702, i64* %704, align 8
  %705 = call fastcc i64 @std.hash.wyhash.read_8bytes_swapped(%"[]u8"* %58)
  %706 = load i64, i64* %seed, align 8
  %707 = call fastcc i64 @std.hash.wyhash.mix0(i64 %696, i64 %705, i64 %706)
  %708 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 1
  %709 = load i64, i64* %708, align 8
  %710 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 0
  %711 = load i8*, i8** %710, align 8
  %712 = getelementptr inbounds i8, i8* %711, i64 16
  %713 = sub nuw i64 %709, 16
  %714 = getelementptr inbounds %"[]u8", %"[]u8"* %59, i32 0, i32 0
  store i8* %712, i8** %714, align 8
  %715 = getelementptr inbounds %"[]u8", %"[]u8"* %59, i32 0, i32 1
  store i64 %713, i64* %715, align 8
  %716 = call fastcc i64 @std.hash.wyhash.read_8bytes_swapped(%"[]u8"* %59)
  %717 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 1
  %718 = load i64, i64* %717, align 8
  %719 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 0
  %720 = load i8*, i8** %719, align 8
  %721 = getelementptr inbounds i8, i8* %720, i64 24
  %722 = sub nuw i64 %718, 24
  %723 = getelementptr inbounds %"[]u8", %"[]u8"* %60, i32 0, i32 0
  store i8* %721, i8** %723, align 8
  %724 = getelementptr inbounds %"[]u8", %"[]u8"* %60, i32 0, i32 1
  store i64 %722, i64* %724, align 8
  %725 = call fastcc i64 @std.hash.wyhash.read_bytes.135(%"[]u8"* %60)
  %726 = load i64, i64* %seed, align 8
  %727 = call fastcc i64 @std.hash.wyhash.mix1(i64 %716, i64 %725, i64 %726)
  %728 = xor i64 %707, %727
  store i64 %728, i64* %92, align 8
  br label %SwitchEnd

SwitchProng29:                                    ; preds = %Entry
  %729 = call fastcc i64 @std.hash.wyhash.read_8bytes_swapped(%"[]u8"* %rem_key)
  %730 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 1
  %731 = load i64, i64* %730, align 8
  %732 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 0
  %733 = load i8*, i8** %732, align 8
  %734 = getelementptr inbounds i8, i8* %733, i64 8
  %735 = sub nuw i64 %731, 8
  %736 = getelementptr inbounds %"[]u8", %"[]u8"* %61, i32 0, i32 0
  store i8* %734, i8** %736, align 8
  %737 = getelementptr inbounds %"[]u8", %"[]u8"* %61, i32 0, i32 1
  store i64 %735, i64* %737, align 8
  %738 = call fastcc i64 @std.hash.wyhash.read_8bytes_swapped(%"[]u8"* %61)
  %739 = load i64, i64* %seed, align 8
  %740 = call fastcc i64 @std.hash.wyhash.mix0(i64 %729, i64 %738, i64 %739)
  %741 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 1
  %742 = load i64, i64* %741, align 8
  %743 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 0
  %744 = load i8*, i8** %743, align 8
  %745 = getelementptr inbounds i8, i8* %744, i64 16
  %746 = sub nuw i64 %742, 16
  %747 = getelementptr inbounds %"[]u8", %"[]u8"* %62, i32 0, i32 0
  store i8* %745, i8** %747, align 8
  %748 = getelementptr inbounds %"[]u8", %"[]u8"* %62, i32 0, i32 1
  store i64 %746, i64* %748, align 8
  %749 = call fastcc i64 @std.hash.wyhash.read_8bytes_swapped(%"[]u8"* %62)
  %750 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 1
  %751 = load i64, i64* %750, align 8
  %752 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 0
  %753 = load i8*, i8** %752, align 8
  %754 = getelementptr inbounds i8, i8* %753, i64 24
  %755 = sub nuw i64 %751, 24
  %756 = getelementptr inbounds %"[]u8", %"[]u8"* %63, i32 0, i32 0
  store i8* %754, i8** %756, align 8
  %757 = getelementptr inbounds %"[]u8", %"[]u8"* %63, i32 0, i32 1
  store i64 %755, i64* %757, align 8
  %758 = call fastcc i64 @std.hash.wyhash.read_bytes.135(%"[]u8"* %63)
  %759 = shl i64 %758, 8
  %760 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 1
  %761 = load i64, i64* %760, align 8
  %762 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 0
  %763 = load i8*, i8** %762, align 8
  %764 = getelementptr inbounds i8, i8* %763, i64 28
  %765 = sub nuw i64 %761, 28
  %766 = getelementptr inbounds %"[]u8", %"[]u8"* %64, i32 0, i32 0
  store i8* %764, i8** %766, align 8
  %767 = getelementptr inbounds %"[]u8", %"[]u8"* %64, i32 0, i32 1
  store i64 %765, i64* %767, align 8
  %768 = call fastcc i64 @std.hash.wyhash.read_bytes(%"[]u8"* %64)
  %769 = or i64 %759, %768
  %770 = load i64, i64* %seed, align 8
  %771 = call fastcc i64 @std.hash.wyhash.mix1(i64 %749, i64 %769, i64 %770)
  %772 = xor i64 %740, %771
  store i64 %772, i64* %92, align 8
  br label %SwitchEnd

SwitchProng30:                                    ; preds = %Entry
  %773 = call fastcc i64 @std.hash.wyhash.read_8bytes_swapped(%"[]u8"* %rem_key)
  %774 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 1
  %775 = load i64, i64* %774, align 8
  %776 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 0
  %777 = load i8*, i8** %776, align 8
  %778 = getelementptr inbounds i8, i8* %777, i64 8
  %779 = sub nuw i64 %775, 8
  %780 = getelementptr inbounds %"[]u8", %"[]u8"* %65, i32 0, i32 0
  store i8* %778, i8** %780, align 8
  %781 = getelementptr inbounds %"[]u8", %"[]u8"* %65, i32 0, i32 1
  store i64 %779, i64* %781, align 8
  %782 = call fastcc i64 @std.hash.wyhash.read_8bytes_swapped(%"[]u8"* %65)
  %783 = load i64, i64* %seed, align 8
  %784 = call fastcc i64 @std.hash.wyhash.mix0(i64 %773, i64 %782, i64 %783)
  %785 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 1
  %786 = load i64, i64* %785, align 8
  %787 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 0
  %788 = load i8*, i8** %787, align 8
  %789 = getelementptr inbounds i8, i8* %788, i64 16
  %790 = sub nuw i64 %786, 16
  %791 = getelementptr inbounds %"[]u8", %"[]u8"* %66, i32 0, i32 0
  store i8* %789, i8** %791, align 8
  %792 = getelementptr inbounds %"[]u8", %"[]u8"* %66, i32 0, i32 1
  store i64 %790, i64* %792, align 8
  %793 = call fastcc i64 @std.hash.wyhash.read_8bytes_swapped(%"[]u8"* %66)
  %794 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 1
  %795 = load i64, i64* %794, align 8
  %796 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 0
  %797 = load i8*, i8** %796, align 8
  %798 = getelementptr inbounds i8, i8* %797, i64 24
  %799 = sub nuw i64 %795, 24
  %800 = getelementptr inbounds %"[]u8", %"[]u8"* %67, i32 0, i32 0
  store i8* %798, i8** %800, align 8
  %801 = getelementptr inbounds %"[]u8", %"[]u8"* %67, i32 0, i32 1
  store i64 %799, i64* %801, align 8
  %802 = call fastcc i64 @std.hash.wyhash.read_bytes.135(%"[]u8"* %67)
  %803 = shl i64 %802, 16
  %804 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 1
  %805 = load i64, i64* %804, align 8
  %806 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 0
  %807 = load i8*, i8** %806, align 8
  %808 = getelementptr inbounds i8, i8* %807, i64 28
  %809 = sub nuw i64 %805, 28
  %810 = getelementptr inbounds %"[]u8", %"[]u8"* %68, i32 0, i32 0
  store i8* %808, i8** %810, align 8
  %811 = getelementptr inbounds %"[]u8", %"[]u8"* %68, i32 0, i32 1
  store i64 %809, i64* %811, align 8
  %812 = call fastcc i64 @std.hash.wyhash.read_bytes.134(%"[]u8"* %68)
  %813 = or i64 %803, %812
  %814 = load i64, i64* %seed, align 8
  %815 = call fastcc i64 @std.hash.wyhash.mix1(i64 %793, i64 %813, i64 %814)
  %816 = xor i64 %784, %815
  store i64 %816, i64* %92, align 8
  br label %SwitchEnd

SwitchProng31:                                    ; preds = %Entry
  %817 = call fastcc i64 @std.hash.wyhash.read_8bytes_swapped(%"[]u8"* %rem_key)
  %818 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 1
  %819 = load i64, i64* %818, align 8
  %820 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 0
  %821 = load i8*, i8** %820, align 8
  %822 = getelementptr inbounds i8, i8* %821, i64 8
  %823 = sub nuw i64 %819, 8
  %824 = getelementptr inbounds %"[]u8", %"[]u8"* %69, i32 0, i32 0
  store i8* %822, i8** %824, align 8
  %825 = getelementptr inbounds %"[]u8", %"[]u8"* %69, i32 0, i32 1
  store i64 %823, i64* %825, align 8
  %826 = call fastcc i64 @std.hash.wyhash.read_8bytes_swapped(%"[]u8"* %69)
  %827 = load i64, i64* %seed, align 8
  %828 = call fastcc i64 @std.hash.wyhash.mix0(i64 %817, i64 %826, i64 %827)
  %829 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 1
  %830 = load i64, i64* %829, align 8
  %831 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 0
  %832 = load i8*, i8** %831, align 8
  %833 = getelementptr inbounds i8, i8* %832, i64 16
  %834 = sub nuw i64 %830, 16
  %835 = getelementptr inbounds %"[]u8", %"[]u8"* %70, i32 0, i32 0
  store i8* %833, i8** %835, align 8
  %836 = getelementptr inbounds %"[]u8", %"[]u8"* %70, i32 0, i32 1
  store i64 %834, i64* %836, align 8
  %837 = call fastcc i64 @std.hash.wyhash.read_8bytes_swapped(%"[]u8"* %70)
  %838 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 1
  %839 = load i64, i64* %838, align 8
  %840 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 0
  %841 = load i8*, i8** %840, align 8
  %842 = getelementptr inbounds i8, i8* %841, i64 24
  %843 = sub nuw i64 %839, 24
  %844 = getelementptr inbounds %"[]u8", %"[]u8"* %71, i32 0, i32 0
  store i8* %842, i8** %844, align 8
  %845 = getelementptr inbounds %"[]u8", %"[]u8"* %71, i32 0, i32 1
  store i64 %843, i64* %845, align 8
  %846 = call fastcc i64 @std.hash.wyhash.read_bytes.135(%"[]u8"* %71)
  %847 = shl i64 %846, 24
  %848 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 1
  %849 = load i64, i64* %848, align 8
  %850 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 0
  %851 = load i8*, i8** %850, align 8
  %852 = getelementptr inbounds i8, i8* %851, i64 28
  %853 = sub nuw i64 %849, 28
  %854 = getelementptr inbounds %"[]u8", %"[]u8"* %72, i32 0, i32 0
  store i8* %852, i8** %854, align 8
  %855 = getelementptr inbounds %"[]u8", %"[]u8"* %72, i32 0, i32 1
  store i64 %853, i64* %855, align 8
  %856 = call fastcc i64 @std.hash.wyhash.read_bytes.134(%"[]u8"* %72)
  %857 = shl i64 %856, 8
  %858 = or i64 %847, %857
  %859 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 1
  %860 = load i64, i64* %859, align 8
  %861 = getelementptr inbounds %"[]u8", %"[]u8"* %rem_key, i32 0, i32 0
  %862 = load i8*, i8** %861, align 8
  %863 = getelementptr inbounds i8, i8* %862, i64 30
  %864 = sub nuw i64 %860, 30
  %865 = getelementptr inbounds %"[]u8", %"[]u8"* %73, i32 0, i32 0
  store i8* %863, i8** %865, align 8
  %866 = getelementptr inbounds %"[]u8", %"[]u8"* %73, i32 0, i32 1
  store i64 %864, i64* %866, align 8
  %867 = call fastcc i64 @std.hash.wyhash.read_bytes(%"[]u8"* %73)
  %868 = or i64 %858, %867
  %869 = load i64, i64* %seed, align 8
  %870 = call fastcc i64 @std.hash.wyhash.mix1(i64 %837, i64 %868, i64 %869)
  %871 = xor i64 %828, %870
  store i64 %871, i64* %92, align 8
  br label %SwitchEnd

SwitchElse:                                       ; preds = %Entry
  unreachable

SwitchEnd:                                        ; preds = %SwitchProng31, %SwitchProng30, %SwitchProng29, %SwitchProng28, %SwitchProng27, %SwitchProng26, %SwitchProng25, %SwitchProng24, %SwitchProng23, %SwitchProng22, %SwitchProng21, %SwitchProng20, %SwitchProng19, %SwitchProng18, %SwitchProng17, %SwitchProng16, %SwitchProng15, %SwitchProng14, %SwitchProng13, %SwitchProng12, %SwitchProng11, %SwitchProng10, %SwitchProng9, %SwitchProng8, %SwitchProng7, %SwitchProng6, %SwitchProng5, %SwitchProng4, %SwitchProng3, %SwitchProng2, %SwitchProng1, %SwitchProng
  %872 = load %std.hash.wyhash.WyhashStateless*, %std.hash.wyhash.WyhashStateless** %self, align 8
  %873 = getelementptr inbounds %std.hash.wyhash.WyhashStateless, %std.hash.wyhash.WyhashStateless* %872, i32 0, i32 1
  %874 = load i64, i64* %873, align 8
  %875 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 1
  %876 = load i64, i64* %875, align 8
  %877 = add nuw i64 %874, %876
  store i64 %877, i64* %873, align 8
  %878 = load %std.hash.wyhash.WyhashStateless*, %std.hash.wyhash.WyhashStateless** %self, align 8
  %879 = getelementptr inbounds %std.hash.wyhash.WyhashStateless, %std.hash.wyhash.WyhashStateless* %878, i32 0, i32 0
  %880 = load i64, i64* %879, align 8
  %881 = load %std.hash.wyhash.WyhashStateless*, %std.hash.wyhash.WyhashStateless** %self, align 8
  %882 = getelementptr inbounds %std.hash.wyhash.WyhashStateless, %std.hash.wyhash.WyhashStateless* %881, i32 0, i32 1
  %883 = load i64, i64* %882, align 8
  %884 = xor i64 %880, %883
  %885 = call fastcc i64 @std.hash.wyhash.mum(i64 %884, i64 2129725606500045391)
  store i64 %885, i64* %result, align 8
  %886 = load i64, i64* %result, align 8
  ret i64 %886
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i64 @std.mem.alignBackwardGeneric.89(i64 %0, i64 %1) unnamed_addr #1 {
Entry:
  %result = alloca i64, align 8
  %addr = alloca i64, align 8
  %alignment = alloca i64, align 8
  store i64 %0, i64* %addr, align 8
  store i64 %1, i64* %alignment, align 8
  %2 = load i64, i64* %alignment, align 8
  %3 = call i64 @llvm.ctpop.i64(i64 %2)
  %4 = trunc i64 %3 to i7
  %5 = icmp eq i7 %4, 1
  call fastcc void @std.debug.assert(i1 %5)
  %6 = load i64, i64* %addr, align 8
  %7 = load i64, i64* %alignment, align 8
  %8 = sub nuw i64 %7, 1
  %9 = xor i64 %8, -1
  %10 = and i64 %6, %9
  store i64 %10, i64* %result, align 8
  %11 = load i64, i64* %result, align 8
  ret i64 %11
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i64 @std.mem.alignBackwardAnyAlign(i64 %0, i64 %1) unnamed_addr #1 {
Entry:
  %result = alloca i64, align 8
  %i = alloca i64, align 8
  %alignment = alloca i64, align 8
  store i64 %0, i64* %i, align 8
  store i64 %1, i64* %alignment, align 8
  %2 = load i64, i64* %alignment, align 8
  %3 = call i64 @llvm.ctpop.i64(i64 %2)
  %4 = trunc i64 %3 to i7
  %5 = icmp eq i7 %4, 1
  br i1 %5, label %Then, label %Else

Then:                                             ; preds = %Entry
  %6 = load i64, i64* %i, align 8
  %7 = load i64, i64* %alignment, align 8
  %8 = call fastcc i64 @std.mem.alignBackward(i64 %6, i64 %7)
  store i64 %8, i64* %result, align 8
  %9 = load i64, i64* %result, align 8
  ret i64 %9

Else:                                             ; preds = %Entry
  br label %EndIf

EndIf:                                            ; preds = %Else
  %10 = load i64, i64* %alignment, align 8
  %11 = icmp ne i64 %10, 0
  call fastcc void @std.debug.assert(i1 %11)
  %12 = load i64, i64* %i, align 8
  %13 = load i64, i64* %i, align 8
  %14 = load i64, i64* %alignment, align 8
  %15 = urem i64 %13, %14
  %16 = sub nuw i64 %12, %15
  store i64 %16, i64* %result, align 8
  %17 = load i64, i64* %result, align 8
  ret i64 %17
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.io.fixed_buffer_stream.fixedBufferStream(%"std.io.fixed_buffer_stream.FixedBufferStream([]u8)"* nonnull sret(%"std.io.fixed_buffer_stream.FixedBufferStream([]u8)") %0, %"[]u8"* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %2 = alloca %"[]u8", align 8
  %3 = getelementptr inbounds %"std.io.fixed_buffer_stream.FixedBufferStream([]u8)", %"std.io.fixed_buffer_stream.FixedBufferStream([]u8)"* %0, i32 0, i32 0
  %4 = bitcast %"[]u8"* %1 to i8*
  %5 = bitcast %"[]u8"* %2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %5, i8* align 8 %4, i64 16, i1 false)
  call fastcc void @std.mem.span(%"[]u8"* sret(%"[]u8") %3, %"[]u8"* %1)
  %6 = getelementptr inbounds %"std.io.fixed_buffer_stream.FixedBufferStream([]u8)", %"std.io.fixed_buffer_stream.FixedBufferStream([]u8)"* %0, i32 0, i32 1
  store i64 0, i64* %6, align 8
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @"std.io.fixed_buffer_stream.FixedBufferStream([]u8).writer"(%"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* nonnull sret(%"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)") %0, %"std.io.fixed_buffer_stream.FixedBufferStream([]u8)"* nonnull align 8 %1) unnamed_addr #1 {
Entry:
  %self = alloca %"std.io.fixed_buffer_stream.FixedBufferStream([]u8)"*, align 8
  store %"std.io.fixed_buffer_stream.FixedBufferStream([]u8)"* %1, %"std.io.fixed_buffer_stream.FixedBufferStream([]u8)"** %self, align 8
  %2 = getelementptr inbounds %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)", %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* %0, i32 0, i32 0
  %3 = load %"std.io.fixed_buffer_stream.FixedBufferStream([]u8)"*, %"std.io.fixed_buffer_stream.FixedBufferStream([]u8)"** %self, align 8
  store %"std.io.fixed_buffer_stream.FixedBufferStream([]u8)"* %3, %"std.io.fixed_buffer_stream.FixedBufferStream([]u8)"** %2, align 8
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.format.90(%"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* nonnull readonly align 8 %0, %"std.Progress.struct:202:79"* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %options = alloca %std.fmt.FormatOptions, align 8
  %2 = alloca i16, align 2
  %3 = alloca i64, align 8
  %4 = alloca %std.fmt.FormatOptions, align 8
  %5 = alloca %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)", align 8
  %6 = alloca i16, align 2
  %7 = alloca i16, align 2
  %8 = bitcast %std.fmt.FormatOptions* %options to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %8, i8* align 8 bitcast ({ %"?usize", %"?usize", i2, <{ i8, [6 x i8] }> }* @331 to i8*), i64 40, i1 false)
  %9 = call fastcc i16 @"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write).writeAll"(%"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* %0, %"[]u8"* @333)
  store i16 %9, i16* %2, align 2
  %10 = icmp ne i16 %9, 0
  br i1 %10, label %ErrRetReturn, label %ErrRetContinue

ErrRetReturn:                                     ; preds = %Entry
  %11 = load i16, i16* %2, align 2
  store i16 %11, i16* %result, align 2
  ret i16 %11

ErrRetContinue:                                   ; preds = %Entry
  %12 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 0
  %13 = bitcast %"?usize"* %12 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %13, i8* align 8 bitcast (%"?usize"* @334 to i8*), i64 16, i1 false)
  %14 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 1
  %15 = bitcast %"?usize"* %14 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %15, i8* align 8 bitcast (%"?usize"* @335 to i8*), i64 16, i1 false)
  %16 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 2
  store i2 -2, i2* %16, align 1
  %17 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 3
  store i8 32, i8* %17, align 1
  %18 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 1
  %19 = bitcast %"?usize"* %18 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %19, i8* align 8 bitcast (%"?usize"* @338 to i8*), i64 16, i1 false)
  %20 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 0
  %21 = bitcast %"?usize"* %20 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %21, i8* align 8 bitcast (%"?usize"* @339 to i8*), i64 16, i1 false)
  %22 = getelementptr inbounds %"std.Progress.struct:202:79", %"std.Progress.struct:202:79"* %1, i32 0, i32 0
  %23 = load i64, i64* %22, align 8
  store i64 %23, i64* %3, align 8
  %24 = bitcast %std.fmt.FormatOptions* %options to i8*
  %25 = bitcast %std.fmt.FormatOptions* %4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %25, i8* align 8 %24, i64 40, i1 false)
  %26 = bitcast %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* %0 to i8*
  %27 = bitcast %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* %5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %27, i8* align 8 %26, i64 8, i1 false)
  %28 = call fastcc i16 @std.fmt.formatType.136(i64 %23, %std.fmt.FormatOptions* %options, %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* %0, i64 3)
  store i16 %28, i16* %6, align 2
  %29 = icmp ne i16 %28, 0
  br i1 %29, label %ErrRetReturn1, label %ErrRetContinue2

ErrRetReturn1:                                    ; preds = %ErrRetContinue
  %30 = load i16, i16* %6, align 2
  store i16 %30, i16* %result, align 2
  ret i16 %30

ErrRetContinue2:                                  ; preds = %ErrRetContinue
  %31 = call fastcc i16 @"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write).writeAll"(%"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* %0, %"[]u8"* @340)
  store i16 %31, i16* %7, align 2
  %32 = icmp ne i16 %31, 0
  br i1 %32, label %ErrRetReturn3, label %ErrRetContinue4

ErrRetReturn3:                                    ; preds = %ErrRetContinue2
  %33 = load i16, i16* %7, align 2
  store i16 %33, i16* %result, align 2
  ret i16 %33

ErrRetContinue4:                                  ; preds = %ErrRetContinue2
  store i16 0, i16* %result, align 2
  ret i16 0
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @"std.io.fixed_buffer_stream.FixedBufferStream([]u8).getWritten"(%"[]u8"* nonnull sret(%"[]u8") %0, %"std.io.fixed_buffer_stream.FixedBufferStream([]u8)"* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %2 = getelementptr inbounds %"std.io.fixed_buffer_stream.FixedBufferStream([]u8)", %"std.io.fixed_buffer_stream.FixedBufferStream([]u8)"* %1, i32 0, i32 0
  %3 = getelementptr inbounds %"std.io.fixed_buffer_stream.FixedBufferStream([]u8)", %"std.io.fixed_buffer_stream.FixedBufferStream([]u8)"* %1, i32 0, i32 1
  %4 = load i64, i64* %3, align 8
  %5 = getelementptr inbounds %"[]u8", %"[]u8"* %2, i32 0, i32 0
  %6 = load i8*, i8** %5, align 8
  %7 = getelementptr inbounds i8, i8* %6, i64 0
  %8 = sub nuw i64 %4, 0
  %9 = getelementptr inbounds %"[]u8", %"[]u8"* %0, i32 0, i32 0
  store i8* %7, i8** %9, align 8
  %10 = getelementptr inbounds %"[]u8", %"[]u8"* %0, i32 0, i32 1
  store i64 %8, i64* %10, align 8
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.format.91(%"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* nonnull readonly align 8 %0) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %options = alloca %std.fmt.FormatOptions, align 8
  %1 = alloca i16, align 2
  %2 = bitcast %std.fmt.FormatOptions* %options to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %2, i8* align 8 bitcast ({ %"?usize", %"?usize", i2, <{ i8, [6 x i8] }> }* @342 to i8*), i64 40, i1 false)
  %3 = call fastcc i16 @"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write).writeAll"(%"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* %0, %"[]u8"* @344)
  store i16 %3, i16* %1, align 2
  %4 = icmp ne i16 %3, 0
  br i1 %4, label %ErrRetReturn, label %ErrRetContinue

ErrRetReturn:                                     ; preds = %Entry
  %5 = load i16, i16* %1, align 2
  store i16 %5, i16* %result, align 2
  ret i16 %5

ErrRetContinue:                                   ; preds = %Entry
  store i16 0, i16* %result, align 2
  ret i16 0
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.fmt.bufPrint.92({ %"[]u8", i16 }* nonnull sret({ %"[]u8", i16 }) %0, %"[]u8"* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %2 = alloca %"[]u8", align 8
  %fbs = alloca %"std.io.fixed_buffer_stream.FixedBufferStream([]u8)", align 8
  %3 = alloca %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)", align 8
  %4 = alloca i16, align 2
  %5 = alloca { %"[]u8", i16 }, align 8
  %6 = bitcast %"[]u8"* %1 to i8*
  %7 = bitcast %"[]u8"* %2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %7, i8* align 8 %6, i64 16, i1 false)
  call fastcc void @std.io.fixed_buffer_stream.fixedBufferStream(%"std.io.fixed_buffer_stream.FixedBufferStream([]u8)"* sret(%"std.io.fixed_buffer_stream.FixedBufferStream([]u8)") %fbs, %"[]u8"* %1)
  call fastcc void @"std.io.fixed_buffer_stream.FixedBufferStream([]u8).writer"(%"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* sret(%"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)") %3, %"std.io.fixed_buffer_stream.FixedBufferStream([]u8)"* %fbs)
  %8 = call fastcc i16 @std.fmt.format.138(%"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* %3)
  store i16 %8, i16* %4, align 2
  %9 = icmp ne i16 %8, 0
  br i1 %9, label %ErrRetReturn, label %ErrRetContinue

ErrRetReturn:                                     ; preds = %Entry
  %10 = load i16, i16* %4, align 2
  %11 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %0, i32 0, i32 1
  store i16 %10, i16* %11, align 2
  %12 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %5, i32 0, i32 1
  store i16 %10, i16* %12, align 2
  ret void

ErrRetContinue:                                   ; preds = %Entry
  %13 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %0, i32 0, i32 1
  store i16 0, i16* %13, align 2
  %14 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %0, i32 0, i32 0
  call fastcc void @"std.io.fixed_buffer_stream.FixedBufferStream([]u8).getWritten"(%"[]u8"* sret(%"[]u8") %14, %"std.io.fixed_buffer_stream.FixedBufferStream([]u8)"* %fbs)
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.fmt.bufPrint.93({ %"[]u8", i16 }* nonnull sret({ %"[]u8", i16 }) %0, %"[]u8"* nonnull readonly align 8 %1, %"std.Progress.struct:264:49"* nonnull readonly align 8 %2) unnamed_addr #1 {
Entry:
  %3 = alloca %"[]u8", align 8
  %fbs = alloca %"std.io.fixed_buffer_stream.FixedBufferStream([]u8)", align 8
  %4 = alloca %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)", align 8
  %5 = alloca %"std.Progress.struct:264:49", align 8
  %6 = alloca i16, align 2
  %7 = alloca { %"[]u8", i16 }, align 8
  %8 = bitcast %"[]u8"* %1 to i8*
  %9 = bitcast %"[]u8"* %3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %9, i8* align 8 %8, i64 16, i1 false)
  call fastcc void @std.io.fixed_buffer_stream.fixedBufferStream(%"std.io.fixed_buffer_stream.FixedBufferStream([]u8)"* sret(%"std.io.fixed_buffer_stream.FixedBufferStream([]u8)") %fbs, %"[]u8"* %1)
  call fastcc void @"std.io.fixed_buffer_stream.FixedBufferStream([]u8).writer"(%"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* sret(%"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)") %4, %"std.io.fixed_buffer_stream.FixedBufferStream([]u8)"* %fbs)
  %10 = bitcast %"std.Progress.struct:264:49"* %2 to i8*
  %11 = bitcast %"std.Progress.struct:264:49"* %5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %11, i8* align 8 %10, i64 16, i1 false)
  %12 = call fastcc i16 @std.fmt.format.139(%"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* %4, %"std.Progress.struct:264:49"* %2)
  store i16 %12, i16* %6, align 2
  %13 = icmp ne i16 %12, 0
  br i1 %13, label %ErrRetReturn, label %ErrRetContinue

ErrRetReturn:                                     ; preds = %Entry
  %14 = load i16, i16* %6, align 2
  %15 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %0, i32 0, i32 1
  store i16 %14, i16* %15, align 2
  %16 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %7, i32 0, i32 1
  store i16 %14, i16* %16, align 2
  ret void

ErrRetContinue:                                   ; preds = %Entry
  %17 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %0, i32 0, i32 1
  store i16 0, i16* %17, align 2
  %18 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %0, i32 0, i32 0
  call fastcc void @"std.io.fixed_buffer_stream.FixedBufferStream([]u8).getWritten"(%"[]u8"* sret(%"[]u8") %18, %"std.io.fixed_buffer_stream.FixedBufferStream([]u8)"* %fbs)
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.fmt.bufPrint.94({ %"[]u8", i16 }* nonnull sret({ %"[]u8", i16 }) %0, %"[]u8"* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %2 = alloca %"[]u8", align 8
  %fbs = alloca %"std.io.fixed_buffer_stream.FixedBufferStream([]u8)", align 8
  %3 = alloca %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)", align 8
  %4 = alloca i16, align 2
  %5 = alloca { %"[]u8", i16 }, align 8
  %6 = bitcast %"[]u8"* %1 to i8*
  %7 = bitcast %"[]u8"* %2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %7, i8* align 8 %6, i64 16, i1 false)
  call fastcc void @std.io.fixed_buffer_stream.fixedBufferStream(%"std.io.fixed_buffer_stream.FixedBufferStream([]u8)"* sret(%"std.io.fixed_buffer_stream.FixedBufferStream([]u8)") %fbs, %"[]u8"* %1)
  call fastcc void @"std.io.fixed_buffer_stream.FixedBufferStream([]u8).writer"(%"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* sret(%"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)") %3, %"std.io.fixed_buffer_stream.FixedBufferStream([]u8)"* %fbs)
  %8 = call fastcc i16 @std.fmt.format.140(%"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* %3)
  store i16 %8, i16* %4, align 2
  %9 = icmp ne i16 %8, 0
  br i1 %9, label %ErrRetReturn, label %ErrRetContinue

ErrRetReturn:                                     ; preds = %Entry
  %10 = load i16, i16* %4, align 2
  %11 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %0, i32 0, i32 1
  store i16 %10, i16* %11, align 2
  %12 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %5, i32 0, i32 1
  store i16 %10, i16* %12, align 2
  ret void

ErrRetContinue:                                   ; preds = %Entry
  %13 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %0, i32 0, i32 1
  store i16 0, i16* %13, align 2
  %14 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %0, i32 0, i32 0
  call fastcc void @"std.io.fixed_buffer_stream.FixedBufferStream([]u8).getWritten"(%"[]u8"* sret(%"[]u8") %14, %"std.io.fixed_buffer_stream.FixedBufferStream([]u8)"* %fbs)
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.fmt.bufPrint.95({ %"[]u8", i16 }* nonnull sret({ %"[]u8", i16 }) %0, %"[]u8"* nonnull readonly align 8 %1, %"std.Progress.struct:269:56"* nonnull readonly align 8 %2) unnamed_addr #1 {
Entry:
  %3 = alloca %"[]u8", align 8
  %fbs = alloca %"std.io.fixed_buffer_stream.FixedBufferStream([]u8)", align 8
  %4 = alloca %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)", align 8
  %5 = alloca %"std.Progress.struct:269:56", align 8
  %6 = alloca i16, align 2
  %7 = alloca { %"[]u8", i16 }, align 8
  %8 = bitcast %"[]u8"* %1 to i8*
  %9 = bitcast %"[]u8"* %3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %9, i8* align 8 %8, i64 16, i1 false)
  call fastcc void @std.io.fixed_buffer_stream.fixedBufferStream(%"std.io.fixed_buffer_stream.FixedBufferStream([]u8)"* sret(%"std.io.fixed_buffer_stream.FixedBufferStream([]u8)") %fbs, %"[]u8"* %1)
  call fastcc void @"std.io.fixed_buffer_stream.FixedBufferStream([]u8).writer"(%"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* sret(%"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)") %4, %"std.io.fixed_buffer_stream.FixedBufferStream([]u8)"* %fbs)
  %10 = bitcast %"std.Progress.struct:269:56"* %2 to i8*
  %11 = bitcast %"std.Progress.struct:269:56"* %5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %11, i8* align 8 %10, i64 16, i1 false)
  %12 = call fastcc i16 @std.fmt.format.141(%"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* %4, %"std.Progress.struct:269:56"* %2)
  store i16 %12, i16* %6, align 2
  %13 = icmp ne i16 %12, 0
  br i1 %13, label %ErrRetReturn, label %ErrRetContinue

ErrRetReturn:                                     ; preds = %Entry
  %14 = load i16, i16* %6, align 2
  %15 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %0, i32 0, i32 1
  store i16 %14, i16* %15, align 2
  %16 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %7, i32 0, i32 1
  store i16 %14, i16* %16, align 2
  ret void

ErrRetContinue:                                   ; preds = %Entry
  %17 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %0, i32 0, i32 1
  store i16 0, i16* %17, align 2
  %18 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %0, i32 0, i32 0
  call fastcc void @"std.io.fixed_buffer_stream.FixedBufferStream([]u8).getWritten"(%"[]u8"* sret(%"[]u8") %18, %"std.io.fixed_buffer_stream.FixedBufferStream([]u8)"* %fbs)
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.fmt.bufPrint.96({ %"[]u8", i16 }* nonnull sret({ %"[]u8", i16 }) %0, %"[]u8"* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %2 = alloca %"[]u8", align 8
  %fbs = alloca %"std.io.fixed_buffer_stream.FixedBufferStream([]u8)", align 8
  %3 = alloca %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)", align 8
  %4 = alloca i16, align 2
  %5 = alloca { %"[]u8", i16 }, align 8
  %6 = bitcast %"[]u8"* %1 to i8*
  %7 = bitcast %"[]u8"* %2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %7, i8* align 8 %6, i64 16, i1 false)
  call fastcc void @std.io.fixed_buffer_stream.fixedBufferStream(%"std.io.fixed_buffer_stream.FixedBufferStream([]u8)"* sret(%"std.io.fixed_buffer_stream.FixedBufferStream([]u8)") %fbs, %"[]u8"* %1)
  call fastcc void @"std.io.fixed_buffer_stream.FixedBufferStream([]u8).writer"(%"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* sret(%"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)") %3, %"std.io.fixed_buffer_stream.FixedBufferStream([]u8)"* %fbs)
  %8 = call fastcc i16 @std.fmt.format.142(%"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* %3)
  store i16 %8, i16* %4, align 2
  %9 = icmp ne i16 %8, 0
  br i1 %9, label %ErrRetReturn, label %ErrRetContinue

ErrRetReturn:                                     ; preds = %Entry
  %10 = load i16, i16* %4, align 2
  %11 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %0, i32 0, i32 1
  store i16 %10, i16* %11, align 2
  %12 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %5, i32 0, i32 1
  store i16 %10, i16* %12, align 2
  ret void

ErrRetContinue:                                   ; preds = %Entry
  %13 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %0, i32 0, i32 1
  store i16 0, i16* %13, align 2
  %14 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %0, i32 0, i32 0
  call fastcc void @"std.io.fixed_buffer_stream.FixedBufferStream([]u8).getWritten"(%"[]u8"* sret(%"[]u8") %14, %"std.io.fixed_buffer_stream.FixedBufferStream([]u8)"* %fbs)
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.fmt.bufPrint.97({ %"[]u8", i16 }* nonnull sret({ %"[]u8", i16 }) %0, %"[]u8"* nonnull readonly align 8 %1, %"std.Progress.struct:273:52"* nonnull readonly align 8 %2) unnamed_addr #1 {
Entry:
  %3 = alloca %"[]u8", align 8
  %fbs = alloca %"std.io.fixed_buffer_stream.FixedBufferStream([]u8)", align 8
  %4 = alloca %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)", align 8
  %5 = alloca %"std.Progress.struct:273:52", align 8
  %6 = alloca i16, align 2
  %7 = alloca { %"[]u8", i16 }, align 8
  %8 = bitcast %"[]u8"* %1 to i8*
  %9 = bitcast %"[]u8"* %3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %9, i8* align 8 %8, i64 16, i1 false)
  call fastcc void @std.io.fixed_buffer_stream.fixedBufferStream(%"std.io.fixed_buffer_stream.FixedBufferStream([]u8)"* sret(%"std.io.fixed_buffer_stream.FixedBufferStream([]u8)") %fbs, %"[]u8"* %1)
  call fastcc void @"std.io.fixed_buffer_stream.FixedBufferStream([]u8).writer"(%"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* sret(%"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)") %4, %"std.io.fixed_buffer_stream.FixedBufferStream([]u8)"* %fbs)
  %10 = bitcast %"std.Progress.struct:273:52"* %2 to i8*
  %11 = bitcast %"std.Progress.struct:273:52"* %5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %11, i8* align 8 %10, i64 8, i1 false)
  %12 = call fastcc i16 @std.fmt.format.143(%"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* %4, %"std.Progress.struct:273:52"* %2)
  store i16 %12, i16* %6, align 2
  %13 = icmp ne i16 %12, 0
  br i1 %13, label %ErrRetReturn, label %ErrRetContinue

ErrRetReturn:                                     ; preds = %Entry
  %14 = load i16, i16* %6, align 2
  %15 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %0, i32 0, i32 1
  store i16 %14, i16* %15, align 2
  %16 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %7, i32 0, i32 1
  store i16 %14, i16* %16, align 2
  ret void

ErrRetContinue:                                   ; preds = %Entry
  %17 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %0, i32 0, i32 1
  store i16 0, i16* %17, align 2
  %18 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %0, i32 0, i32 0
  call fastcc void @"std.io.fixed_buffer_stream.FixedBufferStream([]u8).getWritten"(%"[]u8"* sret(%"[]u8") %18, %"std.io.fixed_buffer_stream.FixedBufferStream([]u8)"* %fbs)
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.fmt.bufPrint.98({ %"[]u8", i16 }* nonnull sret({ %"[]u8", i16 }) %0, %"[]u8"* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %2 = alloca %"[]u8", align 8
  %fbs = alloca %"std.io.fixed_buffer_stream.FixedBufferStream([]u8)", align 8
  %3 = alloca %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)", align 8
  %4 = alloca i16, align 2
  %5 = alloca { %"[]u8", i16 }, align 8
  %6 = bitcast %"[]u8"* %1 to i8*
  %7 = bitcast %"[]u8"* %2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %7, i8* align 8 %6, i64 16, i1 false)
  call fastcc void @std.io.fixed_buffer_stream.fixedBufferStream(%"std.io.fixed_buffer_stream.FixedBufferStream([]u8)"* sret(%"std.io.fixed_buffer_stream.FixedBufferStream([]u8)") %fbs, %"[]u8"* %1)
  call fastcc void @"std.io.fixed_buffer_stream.FixedBufferStream([]u8).writer"(%"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* sret(%"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)") %3, %"std.io.fixed_buffer_stream.FixedBufferStream([]u8)"* %fbs)
  %8 = call fastcc i16 @std.fmt.format.144(%"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* %3)
  store i16 %8, i16* %4, align 2
  %9 = icmp ne i16 %8, 0
  br i1 %9, label %ErrRetReturn, label %ErrRetContinue

ErrRetReturn:                                     ; preds = %Entry
  %10 = load i16, i16* %4, align 2
  %11 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %0, i32 0, i32 1
  store i16 %10, i16* %11, align 2
  %12 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %5, i32 0, i32 1
  store i16 %10, i16* %12, align 2
  ret void

ErrRetContinue:                                   ; preds = %Entry
  %13 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %0, i32 0, i32 1
  store i16 0, i16* %13, align 2
  %14 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %0, i32 0, i32 0
  call fastcc void @"std.io.fixed_buffer_stream.FixedBufferStream([]u8).getWritten"(%"[]u8"* sret(%"[]u8") %14, %"std.io.fixed_buffer_stream.FixedBufferStream([]u8)"* %fbs)
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i64 @std.time.Timer.clockNative() unnamed_addr #1 {
Entry:
  %result = alloca i64, align 8
  %ts = alloca %std.os.linux.timespec, align 8
  %0 = alloca i16, align 2
  %1 = call fastcc i16 @std.os.clock_gettime(i32 1, %std.os.linux.timespec* %ts)
  store i16 %1, i16* %0, align 2
  %2 = getelementptr inbounds %std.os.linux.timespec, %std.os.linux.timespec* %ts, i32 0, i32 0
  %3 = load i64, i64* %2, align 8
  %4 = mul nuw i64 %3, 1000000000
  %5 = getelementptr inbounds %std.os.linux.timespec, %std.os.linux.timespec* %ts, i32 0, i32 1
  %6 = load i64, i64* %5, align 8
  %7 = add nuw i64 %4, %6
  store i64 %7, i64* %result, align 8
  %8 = load i64, i64* %result, align 8
  ret i64 %8
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i64 @std.time.Timer.nativeDurationToNanos(%std.time.Timer* nonnull readonly align 8 %0, i64 %1) unnamed_addr #1 {
Entry:
  %result = alloca i64, align 8
  %duration = alloca i64, align 8
  store i64 %1, i64* %duration, align 8
  %2 = load i64, i64* %duration, align 8
  store i64 %2, i64* %result, align 8
  %3 = load i64, i64* %result, align 8
  ret i64 %3
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.formatType.99(i64 %0, %std.fmt.FormatOptions* nonnull readonly align 8 %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %2, i64 %3) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %4 = alloca i64, align 8
  %5 = alloca %std.fmt.FormatOptions, align 8
  %6 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %value = alloca i64, align 8
  %max_depth = alloca i64, align 8
  store i64 %0, i64* %value, align 8
  store i64 %3, i64* %max_depth, align 8
  %7 = load i64, i64* %value, align 8
  store i64 %7, i64* %4, align 8
  %8 = bitcast %std.fmt.FormatOptions* %1 to i8*
  %9 = bitcast %std.fmt.FormatOptions* %5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %9, i8* align 8 %8, i64 40, i1 false)
  %10 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2 to i8*
  %11 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %6 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %11, i8* align 4 %10, i64 4, i1 false)
  %12 = call fastcc i16 @std.fmt.formatValue.102(i64 %7, %std.fmt.FormatOptions* %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2)
  store i16 %12, i16* %result, align 2
  %13 = load i16, i16* %result, align 2
  ret i16 %13
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.formatType.100(i64 %0, %std.fmt.FormatOptions* nonnull readonly align 8 %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %2, i64 %3) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %4 = alloca i64, align 8
  %5 = alloca %std.fmt.FormatOptions, align 8
  %6 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %value = alloca i64, align 8
  %max_depth = alloca i64, align 8
  store i64 %0, i64* %value, align 8
  store i64 %3, i64* %max_depth, align 8
  %7 = load i64, i64* %value, align 8
  store i64 %7, i64* %4, align 8
  %8 = bitcast %std.fmt.FormatOptions* %1 to i8*
  %9 = bitcast %std.fmt.FormatOptions* %5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %9, i8* align 8 %8, i64 40, i1 false)
  %10 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2 to i8*
  %11 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %6 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %11, i8* align 4 %10, i64 4, i1 false)
  %12 = call fastcc i16 @std.fmt.formatValue.103(i64 %7, %std.fmt.FormatOptions* %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2)
  store i16 %12, i16* %result, align 2
  %13 = load i16, i16* %result, align 2
  ret i16 %13
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.formatType.101(%"[]u8"* nonnull readonly align 8 %0, %std.fmt.FormatOptions* nonnull readonly align 8 %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %2, i64 %3) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %4 = alloca %std.fmt.FormatOptions, align 8
  %5 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %max_depth = alloca i64, align 8
  store i64 %3, i64* %max_depth, align 8
  %6 = load i64, i64* %max_depth, align 8
  %7 = icmp eq i64 %6, 0
  br i1 %7, label %Then, label %Else

Then:                                             ; preds = %Entry
  %8 = call fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).writeAll"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2, %"[]u8"* @180)
  store i16 %8, i16* %result, align 2
  %9 = load i16, i16* %result, align 2
  ret i16 %9

Else:                                             ; preds = %Entry
  br label %EndIf

EndIf:                                            ; preds = %Else
  %10 = bitcast %std.fmt.FormatOptions* %1 to i8*
  %11 = bitcast %std.fmt.FormatOptions* %4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %11, i8* align 8 %10, i64 40, i1 false)
  %12 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2 to i8*
  %13 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %13, i8* align 4 %12, i64 4, i1 false)
  %14 = call fastcc i16 @std.fmt.formatText.104(%"[]u8"* %0, %std.fmt.FormatOptions* %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2)
  store i16 %14, i16* %result, align 2
  %15 = load i16, i16* %result, align 2
  ret i16 %15
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.formatValue.102(i64 %0, %std.fmt.FormatOptions* nonnull readonly align 8 %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %2) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %3 = alloca i64, align 8
  %4 = alloca %std.fmt.FormatOptions, align 8
  %5 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %value = alloca i64, align 8
  store i64 %0, i64* %value, align 8
  %6 = load i64, i64* %value, align 8
  store i64 %6, i64* %3, align 8
  %7 = bitcast %std.fmt.FormatOptions* %1 to i8*
  %8 = bitcast %std.fmt.FormatOptions* %4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %8, i8* align 8 %7, i64 40, i1 false)
  %9 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2 to i8*
  %10 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %10, i8* align 4 %9, i64 4, i1 false)
  %11 = call fastcc i16 @std.fmt.formatIntValue.145(i64 %6, %std.fmt.FormatOptions* %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2)
  store i16 %11, i16* %result, align 2
  %12 = load i16, i16* %result, align 2
  ret i16 %12
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.formatValue.103(i64 %0, %std.fmt.FormatOptions* nonnull readonly align 8 %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %2) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %3 = alloca i64, align 8
  %4 = alloca %std.fmt.FormatOptions, align 8
  %5 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %value = alloca i64, align 8
  store i64 %0, i64* %value, align 8
  %6 = load i64, i64* %value, align 8
  store i64 %6, i64* %3, align 8
  %7 = bitcast %std.fmt.FormatOptions* %1 to i8*
  %8 = bitcast %std.fmt.FormatOptions* %4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %8, i8* align 8 %7, i64 40, i1 false)
  %9 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2 to i8*
  %10 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %10, i8* align 4 %9, i64 4, i1 false)
  %11 = call fastcc i16 @std.fmt.formatIntValue.148(i64 %6, %std.fmt.FormatOptions* %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2)
  store i16 %11, i16* %result, align 2
  %12 = load i16, i16* %result, align 2
  ret i16 %12
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.formatText.104(%"[]u8"* nonnull readonly align 8 %0, %std.fmt.FormatOptions* nonnull readonly align 8 %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %2) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %3 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %4 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2 to i8*
  %5 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %5, i8* align 4 %4, i64 4, i1 false)
  %6 = call fastcc i16 @std.fmt.formatBuf(%"[]u8"* %0, %std.fmt.FormatOptions* %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2)
  store i16 %6, i16* %result, align 2
  %7 = load i16, i16* %result, align 2
  ret i16 %7
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.formatType.105(%"[]u8"* nonnull readonly align 8 %0, %std.fmt.FormatOptions* nonnull readonly align 8 %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %2, i64 %3) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %4 = alloca %std.fmt.FormatOptions, align 8
  %5 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %max_depth = alloca i64, align 8
  store i64 %3, i64* %max_depth, align 8
  %6 = load i64, i64* %max_depth, align 8
  %7 = icmp eq i64 %6, 0
  br i1 %7, label %Then, label %Else

Then:                                             ; preds = %Entry
  %8 = call fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).writeAll"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2, %"[]u8"* @191)
  store i16 %8, i16* %result, align 2
  %9 = load i16, i16* %result, align 2
  ret i16 %9

Else:                                             ; preds = %Entry
  br label %EndIf

EndIf:                                            ; preds = %Else
  %10 = bitcast %std.fmt.FormatOptions* %1 to i8*
  %11 = bitcast %std.fmt.FormatOptions* %4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %11, i8* align 8 %10, i64 40, i1 false)
  %12 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2 to i8*
  %13 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %13, i8* align 4 %12, i64 4, i1 false)
  %14 = call fastcc i16 @std.fmt.formatText.106(%"[]u8"* %0, %std.fmt.FormatOptions* %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2)
  store i16 %14, i16* %result, align 2
  %15 = load i16, i16* %result, align 2
  ret i16 %15
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.formatText.106(%"[]u8"* nonnull readonly align 8 %0, %std.fmt.FormatOptions* nonnull readonly align 8 %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %2) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %3 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %4 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2 to i8*
  %5 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %5, i8* align 4 %4, i64 4, i1 false)
  %6 = call fastcc i16 @std.fmt.formatBuf(%"[]u8"* %0, %std.fmt.FormatOptions* %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2)
  store i16 %6, i16* %result, align 2
  %7 = load i16, i16* %result, align 2
  ret i16 %7
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i32 @"std.hash_map.HashMapUnmanaged(usize,std.heap.general_purpose_allocator.LargeAlloc,std.hash_map.AutoContext(usize),80).capacity"(%"std.hash_map.HashMapUnmanaged(usize,std.heap.general_purpose_allocator.LargeAlloc,std.hash_map.AutoContext(usize),80)"* nonnull readonly align 8 %0) unnamed_addr #1 {
Entry:
  %result = alloca i32, align 4
  %1 = alloca %std.hash_map.Header*, align 8
  %self = alloca %"std.hash_map.HashMapUnmanaged(usize,std.heap.general_purpose_allocator.LargeAlloc,std.hash_map.AutoContext(usize),80)"*, align 8
  store %"std.hash_map.HashMapUnmanaged(usize,std.heap.general_purpose_allocator.LargeAlloc,std.hash_map.AutoContext(usize),80)"* %0, %"std.hash_map.HashMapUnmanaged(usize,std.heap.general_purpose_allocator.LargeAlloc,std.hash_map.AutoContext(usize),80)"** %self, align 8
  %2 = load %"std.hash_map.HashMapUnmanaged(usize,std.heap.general_purpose_allocator.LargeAlloc,std.hash_map.AutoContext(usize),80)"*, %"std.hash_map.HashMapUnmanaged(usize,std.heap.general_purpose_allocator.LargeAlloc,std.hash_map.AutoContext(usize),80)"** %self, align 8
  %3 = getelementptr inbounds %"std.hash_map.HashMapUnmanaged(usize,std.heap.general_purpose_allocator.LargeAlloc,std.hash_map.AutoContext(usize),80)", %"std.hash_map.HashMapUnmanaged(usize,std.heap.general_purpose_allocator.LargeAlloc,std.hash_map.AutoContext(usize),80)"* %2, i32 0, i32 0
  %4 = load %std.hash_map.Metadata*, %std.hash_map.Metadata** %3, align 8
  %5 = icmp ne %std.hash_map.Metadata* %4, null
  %6 = icmp eq i1 %5, false
  br i1 %6, label %Then, label %Else

Then:                                             ; preds = %Entry
  store i32 0, i32* %result, align 4
  %7 = load i32, i32* %result, align 4
  ret i32 %7

Else:                                             ; preds = %Entry
  br label %EndIf

EndIf:                                            ; preds = %Else
  %8 = load %"std.hash_map.HashMapUnmanaged(usize,std.heap.general_purpose_allocator.LargeAlloc,std.hash_map.AutoContext(usize),80)"*, %"std.hash_map.HashMapUnmanaged(usize,std.heap.general_purpose_allocator.LargeAlloc,std.hash_map.AutoContext(usize),80)"** %self, align 8
  %9 = call fastcc %std.hash_map.Header* @"std.hash_map.HashMapUnmanaged(usize,std.heap.general_purpose_allocator.LargeAlloc,std.hash_map.AutoContext(usize),80).header"(%"std.hash_map.HashMapUnmanaged(usize,std.heap.general_purpose_allocator.LargeAlloc,std.hash_map.AutoContext(usize),80)"* %8)
  store %std.hash_map.Header* %9, %std.hash_map.Header** %1, align 8
  %10 = getelementptr inbounds %std.hash_map.Header, %std.hash_map.Header* %9, i32 0, i32 2
  %11 = load i32, i32* %10, align 1
  store i32 %11, i32* %result, align 4
  %12 = load i32, i32* %result, align 4
  ret i32 %12
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc nonnull %std.hash_map.Header* @"std.hash_map.HashMapUnmanaged(usize,std.heap.general_purpose_allocator.LargeAlloc,std.hash_map.AutoContext(usize),80).header"(%"std.hash_map.HashMapUnmanaged(usize,std.heap.general_purpose_allocator.LargeAlloc,std.hash_map.AutoContext(usize),80)"* nonnull readonly align 8 %0) unnamed_addr #1 {
Entry:
  %result = alloca %std.hash_map.Header*, align 8
  %self = alloca %"std.hash_map.HashMapUnmanaged(usize,std.heap.general_purpose_allocator.LargeAlloc,std.hash_map.AutoContext(usize),80)"*, align 8
  store %"std.hash_map.HashMapUnmanaged(usize,std.heap.general_purpose_allocator.LargeAlloc,std.hash_map.AutoContext(usize),80)"* %0, %"std.hash_map.HashMapUnmanaged(usize,std.heap.general_purpose_allocator.LargeAlloc,std.hash_map.AutoContext(usize),80)"** %self, align 8
  %1 = load %"std.hash_map.HashMapUnmanaged(usize,std.heap.general_purpose_allocator.LargeAlloc,std.hash_map.AutoContext(usize),80)"*, %"std.hash_map.HashMapUnmanaged(usize,std.heap.general_purpose_allocator.LargeAlloc,std.hash_map.AutoContext(usize),80)"** %self, align 8
  %2 = getelementptr inbounds %"std.hash_map.HashMapUnmanaged(usize,std.heap.general_purpose_allocator.LargeAlloc,std.hash_map.AutoContext(usize),80)", %"std.hash_map.HashMapUnmanaged(usize,std.heap.general_purpose_allocator.LargeAlloc,std.hash_map.AutoContext(usize),80)"* %1, i32 0, i32 0
  %3 = load %std.hash_map.Metadata*, %std.hash_map.Metadata** %2, align 8
  %4 = bitcast %std.hash_map.Metadata* %3 to %std.hash_map.Header*
  %5 = getelementptr inbounds %std.hash_map.Header, %std.hash_map.Header* %4, i64 -1
  store %std.hash_map.Header* %5, %std.hash_map.Header** %result, align 8
  %6 = load %std.hash_map.Header*, %std.hash_map.Header** %result, align 8
  ret %std.hash_map.Header* %6
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.mem.Allocator.free.107(%std.mem.Allocator* nonnull readonly align 8 %0, %"[]u8"* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %2 = alloca %"[]u8", align 8
  %bytes = alloca %"[]u8", align 8
  %bytes_len = alloca i64, align 8
  %non_const_ptr = alloca i8*, align 8
  %3 = alloca %"[]u8", align 8
  %4 = bitcast %"[]u8"* %1 to i8*
  %5 = bitcast %"[]u8"* %2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %5, i8* align 8 %4, i64 16, i1 false)
  call fastcc void @std.mem.sliceAsBytes.149(%"[]u8"* sret(%"[]u8") %bytes, %"[]u8"* %1)
  %6 = getelementptr inbounds %"[]u8", %"[]u8"* %bytes, i32 0, i32 1
  %7 = load i64, i64* %6, align 8
  %8 = add nuw i64 %7, 0
  store i64 %8, i64* %bytes_len, align 8
  %9 = load i64, i64* %bytes_len, align 8
  %10 = icmp eq i64 %9, 0
  br i1 %10, label %Then, label %Else

Then:                                             ; preds = %Entry
  ret void

Else:                                             ; preds = %Entry
  br label %EndIf

EndIf:                                            ; preds = %Else
  %11 = getelementptr inbounds %"[]u8", %"[]u8"* %bytes, i32 0, i32 0
  %12 = load i8*, i8** %11, align 8
  %13 = ptrtoint i8* %12 to i64
  %14 = inttoptr i64 %13 to i8*
  store i8* %14, i8** %non_const_ptr, align 8
  %15 = load i8*, i8** %non_const_ptr, align 8
  %16 = load i64, i64* %bytes_len, align 8
  %17 = load i64, i64* %bytes_len, align 8
  %18 = load i8*, i8** %non_const_ptr, align 8
  %19 = getelementptr inbounds i8, i8* %18, i64 0
  %20 = sub nuw i64 %17, 0
  %21 = getelementptr inbounds %"[]u8", %"[]u8"* %3, i32 0, i32 0
  store i8* %19, i8** %21, align 8
  %22 = getelementptr inbounds %"[]u8", %"[]u8"* %3, i32 0, i32 1
  store i64 %20, i64* %22, align 8
  %23 = call i8* @llvm.returnaddress(i32 0)
  %24 = ptrtoint i8* %23 to i64
  call fastcc void @std.mem.Allocator.rawFree(%std.mem.Allocator* %0, %"[]u8"* %3, i29 8, i64 %24)
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.formatType.108(%"[]u8"* nonnull readonly align 8 %0, %std.fmt.FormatOptions* nonnull readonly align 8 %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %2, i64 %3) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %4 = alloca %std.fmt.FormatOptions, align 8
  %5 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %max_depth = alloca i64, align 8
  store i64 %3, i64* %max_depth, align 8
  %6 = load i64, i64* %max_depth, align 8
  %7 = icmp eq i64 %6, 0
  br i1 %7, label %Then, label %Else

Then:                                             ; preds = %Entry
  %8 = call fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).writeAll"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2, %"[]u8"* @215)
  store i16 %8, i16* %result, align 2
  %9 = load i16, i16* %result, align 2
  ret i16 %9

Else:                                             ; preds = %Entry
  br label %EndIf

EndIf:                                            ; preds = %Else
  %10 = bitcast %std.fmt.FormatOptions* %1 to i8*
  %11 = bitcast %std.fmt.FormatOptions* %4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %11, i8* align 8 %10, i64 40, i1 false)
  %12 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2 to i8*
  %13 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %13, i8* align 4 %12, i64 4, i1 false)
  %14 = call fastcc i16 @std.fmt.formatText.110(%"[]u8"* %0, %std.fmt.FormatOptions* %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2)
  store i16 %14, i16* %result, align 2
  %15 = load i16, i16* %result, align 2
  ret i16 %15
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.formatType.109(%"[]u8"* nonnull readonly align 8 %0, %std.fmt.FormatOptions* nonnull readonly align 8 %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %2, i64 %3) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %4 = alloca %std.fmt.FormatOptions, align 8
  %5 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %max_depth = alloca i64, align 8
  store i64 %3, i64* %max_depth, align 8
  %6 = load i64, i64* %max_depth, align 8
  %7 = icmp eq i64 %6, 0
  br i1 %7, label %Then, label %Else

Then:                                             ; preds = %Entry
  %8 = call fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).writeAll"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2, %"[]u8"* @217)
  store i16 %8, i16* %result, align 2
  %9 = load i16, i16* %result, align 2
  ret i16 %9

Else:                                             ; preds = %Entry
  br label %EndIf

EndIf:                                            ; preds = %Else
  %10 = bitcast %std.fmt.FormatOptions* %1 to i8*
  %11 = bitcast %std.fmt.FormatOptions* %4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %11, i8* align 8 %10, i64 40, i1 false)
  %12 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2 to i8*
  %13 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %13, i8* align 4 %12, i64 4, i1 false)
  %14 = call fastcc i16 @std.fmt.formatText.111(%"[]u8"* %0, %std.fmt.FormatOptions* %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2)
  store i16 %14, i16* %result, align 2
  %15 = load i16, i16* %result, align 2
  ret i16 %15
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.formatText.110(%"[]u8"* nonnull readonly align 8 %0, %std.fmt.FormatOptions* nonnull readonly align 8 %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %2) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %3 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %4 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2 to i8*
  %5 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %5, i8* align 4 %4, i64 4, i1 false)
  %6 = call fastcc i16 @std.fmt.formatBuf(%"[]u8"* %0, %std.fmt.FormatOptions* %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2)
  store i16 %6, i16* %result, align 2
  %7 = load i16, i16* %result, align 2
  ret i16 %7
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.formatText.111(%"[]u8"* nonnull readonly align 8 %0, %std.fmt.FormatOptions* nonnull readonly align 8 %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %2) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %3 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %4 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2 to i8*
  %5 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %5, i8* align 4 %4, i64 4, i1 false)
  %6 = call fastcc i16 @std.fmt.formatBuf(%"[]u8"* %0, %std.fmt.FormatOptions* %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2)
  store i16 %6, i16* %result, align 2
  %7 = load i16, i16* %result, align 2
  ret i16 %7
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.formatType.112(%"[]u8"* nonnull readonly align 8 %0, %std.fmt.FormatOptions* nonnull readonly align 8 %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %2, i64 %3) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %4 = alloca %std.fmt.FormatOptions, align 8
  %5 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %max_depth = alloca i64, align 8
  store i64 %3, i64* %max_depth, align 8
  %6 = load i64, i64* %max_depth, align 8
  %7 = icmp eq i64 %6, 0
  br i1 %7, label %Then, label %Else

Then:                                             ; preds = %Entry
  %8 = call fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).writeAll"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2, %"[]u8"* @229)
  store i16 %8, i16* %result, align 2
  %9 = load i16, i16* %result, align 2
  ret i16 %9

Else:                                             ; preds = %Entry
  br label %EndIf

EndIf:                                            ; preds = %Else
  %10 = bitcast %std.fmt.FormatOptions* %1 to i8*
  %11 = bitcast %std.fmt.FormatOptions* %4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %11, i8* align 8 %10, i64 40, i1 false)
  %12 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2 to i8*
  %13 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %13, i8* align 4 %12, i64 4, i1 false)
  %14 = call fastcc i16 @std.fmt.formatText.113(%"[]u8"* %0, %std.fmt.FormatOptions* %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2)
  store i16 %14, i16* %result, align 2
  %15 = load i16, i16* %result, align 2
  ret i16 %15
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.formatText.113(%"[]u8"* nonnull readonly align 8 %0, %std.fmt.FormatOptions* nonnull readonly align 8 %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %2) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %3 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %4 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2 to i8*
  %5 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %5, i8* align 4 %4, i64 4, i1 false)
  %6 = call fastcc i16 @std.fmt.formatBuf(%"[]u8"* %0, %std.fmt.FormatOptions* %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2)
  store i16 %6, i16* %result, align 2
  %7 = load i16, i16* %result, align 2
  ret i16 %7
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.formatType.114(%"[]u8"* nonnull readonly align 8 %0, %std.fmt.FormatOptions* nonnull readonly align 8 %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %2, i64 %3) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %4 = alloca %std.fmt.FormatOptions, align 8
  %5 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %max_depth = alloca i64, align 8
  store i64 %3, i64* %max_depth, align 8
  %6 = load i64, i64* %max_depth, align 8
  %7 = icmp eq i64 %6, 0
  br i1 %7, label %Then, label %Else

Then:                                             ; preds = %Entry
  %8 = call fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).writeAll"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2, %"[]u8"* @240)
  store i16 %8, i16* %result, align 2
  %9 = load i16, i16* %result, align 2
  ret i16 %9

Else:                                             ; preds = %Entry
  br label %EndIf

EndIf:                                            ; preds = %Else
  %10 = bitcast %std.fmt.FormatOptions* %1 to i8*
  %11 = bitcast %std.fmt.FormatOptions* %4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %11, i8* align 8 %10, i64 40, i1 false)
  %12 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2 to i8*
  %13 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %13, i8* align 4 %12, i64 4, i1 false)
  %14 = call fastcc i16 @std.fmt.formatText.115(%"[]u8"* %0, %std.fmt.FormatOptions* %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2)
  store i16 %14, i16* %result, align 2
  %15 = load i16, i16* %result, align 2
  ret i16 %15
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.formatText.115(%"[]u8"* nonnull readonly align 8 %0, %std.fmt.FormatOptions* nonnull readonly align 8 %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %2) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %3 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %4 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2 to i8*
  %5 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %5, i8* align 4 %4, i64 4, i1 false)
  %6 = call fastcc i16 @std.fmt.formatBuf(%"[]u8"* %0, %std.fmt.FormatOptions* %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2)
  store i16 %6, i16* %result, align 2
  %7 = load i16, i16* %result, align 2
  ret i16 %7
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.formatType.116(i64 %0, %std.fmt.FormatOptions* nonnull readonly align 8 %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %2, i64 %3) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %4 = alloca i64, align 8
  %5 = alloca %std.fmt.FormatOptions, align 8
  %6 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %value = alloca i64, align 8
  %max_depth = alloca i64, align 8
  store i64 %0, i64* %value, align 8
  store i64 %3, i64* %max_depth, align 8
  %7 = load i64, i64* %value, align 8
  store i64 %7, i64* %4, align 8
  %8 = bitcast %std.fmt.FormatOptions* %1 to i8*
  %9 = bitcast %std.fmt.FormatOptions* %5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %9, i8* align 8 %8, i64 40, i1 false)
  %10 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2 to i8*
  %11 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %6 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %11, i8* align 4 %10, i64 4, i1 false)
  %12 = call fastcc i16 @std.fmt.formatValue.117(i64 %7, %std.fmt.FormatOptions* %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2)
  store i16 %12, i16* %result, align 2
  %13 = load i16, i16* %result, align 2
  ret i16 %13
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.formatValue.117(i64 %0, %std.fmt.FormatOptions* nonnull readonly align 8 %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %2) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %3 = alloca i64, align 8
  %4 = alloca %std.fmt.FormatOptions, align 8
  %5 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %value = alloca i64, align 8
  store i64 %0, i64* %value, align 8
  %6 = load i64, i64* %value, align 8
  store i64 %6, i64* %3, align 8
  %7 = bitcast %std.fmt.FormatOptions* %1 to i8*
  %8 = bitcast %std.fmt.FormatOptions* %4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %8, i8* align 8 %7, i64 40, i1 false)
  %9 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2 to i8*
  %10 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %10, i8* align 4 %9, i64 4, i1 false)
  %11 = call fastcc i16 @std.fmt.formatIntValue.150(i64 %6, %std.fmt.FormatOptions* %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2)
  store i16 %11, i16* %result, align 2
  %12 = load i16, i16* %result, align 2
  ret i16 %12
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.formatType.118(i64 %0, %std.fmt.FormatOptions* nonnull readonly align 8 %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %2, i64 %3) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %4 = alloca i64, align 8
  %5 = alloca %std.fmt.FormatOptions, align 8
  %6 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %value = alloca i64, align 8
  %max_depth = alloca i64, align 8
  store i64 %0, i64* %value, align 8
  store i64 %3, i64* %max_depth, align 8
  %7 = load i64, i64* %value, align 8
  store i64 %7, i64* %4, align 8
  %8 = bitcast %std.fmt.FormatOptions* %1 to i8*
  %9 = bitcast %std.fmt.FormatOptions* %5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %9, i8* align 8 %8, i64 40, i1 false)
  %10 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2 to i8*
  %11 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %6 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %11, i8* align 4 %10, i64 4, i1 false)
  %12 = call fastcc i16 @std.fmt.formatValue.121(i64 %7, %std.fmt.FormatOptions* %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2)
  store i16 %12, i16* %result, align 2
  %13 = load i16, i16* %result, align 2
  ret i16 %13
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.formatType.119(i64 %0, %std.fmt.FormatOptions* nonnull readonly align 8 %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %2, i64 %3) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %4 = alloca i64, align 8
  %5 = alloca %std.fmt.FormatOptions, align 8
  %6 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %value = alloca i64, align 8
  %max_depth = alloca i64, align 8
  store i64 %0, i64* %value, align 8
  store i64 %3, i64* %max_depth, align 8
  %7 = load i64, i64* %value, align 8
  store i64 %7, i64* %4, align 8
  %8 = bitcast %std.fmt.FormatOptions* %1 to i8*
  %9 = bitcast %std.fmt.FormatOptions* %5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %9, i8* align 8 %8, i64 40, i1 false)
  %10 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2 to i8*
  %11 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %6 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %11, i8* align 4 %10, i64 4, i1 false)
  %12 = call fastcc i16 @std.fmt.formatValue.122(i64 %7, %std.fmt.FormatOptions* %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2)
  store i16 %12, i16* %result, align 2
  %13 = load i16, i16* %result, align 2
  ret i16 %13
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.formatType.120(i64 %0, %std.fmt.FormatOptions* nonnull readonly align 8 %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %2, i64 %3) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %4 = alloca i64, align 8
  %5 = alloca %std.fmt.FormatOptions, align 8
  %6 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %value = alloca i64, align 8
  %max_depth = alloca i64, align 8
  store i64 %0, i64* %value, align 8
  store i64 %3, i64* %max_depth, align 8
  %7 = load i64, i64* %value, align 8
  store i64 %7, i64* %4, align 8
  %8 = bitcast %std.fmt.FormatOptions* %1 to i8*
  %9 = bitcast %std.fmt.FormatOptions* %5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %9, i8* align 8 %8, i64 40, i1 false)
  %10 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2 to i8*
  %11 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %6 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %11, i8* align 4 %10, i64 4, i1 false)
  %12 = call fastcc i16 @std.fmt.formatValue.123(i64 %7, %std.fmt.FormatOptions* %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2)
  store i16 %12, i16* %result, align 2
  %13 = load i16, i16* %result, align 2
  ret i16 %13
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.formatValue.121(i64 %0, %std.fmt.FormatOptions* nonnull readonly align 8 %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %2) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %3 = alloca i64, align 8
  %4 = alloca %std.fmt.FormatOptions, align 8
  %5 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %value = alloca i64, align 8
  store i64 %0, i64* %value, align 8
  %6 = load i64, i64* %value, align 8
  store i64 %6, i64* %3, align 8
  %7 = bitcast %std.fmt.FormatOptions* %1 to i8*
  %8 = bitcast %std.fmt.FormatOptions* %4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %8, i8* align 8 %7, i64 40, i1 false)
  %9 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2 to i8*
  %10 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %10, i8* align 4 %9, i64 4, i1 false)
  %11 = call fastcc i16 @std.fmt.formatIntValue.151(i64 %6, %std.fmt.FormatOptions* %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2)
  store i16 %11, i16* %result, align 2
  %12 = load i16, i16* %result, align 2
  ret i16 %12
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.formatValue.122(i64 %0, %std.fmt.FormatOptions* nonnull readonly align 8 %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %2) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %3 = alloca i64, align 8
  %4 = alloca %std.fmt.FormatOptions, align 8
  %5 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %value = alloca i64, align 8
  store i64 %0, i64* %value, align 8
  %6 = load i64, i64* %value, align 8
  store i64 %6, i64* %3, align 8
  %7 = bitcast %std.fmt.FormatOptions* %1 to i8*
  %8 = bitcast %std.fmt.FormatOptions* %4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %8, i8* align 8 %7, i64 40, i1 false)
  %9 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2 to i8*
  %10 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %10, i8* align 4 %9, i64 4, i1 false)
  %11 = call fastcc i16 @std.fmt.formatIntValue.152(i64 %6, %std.fmt.FormatOptions* %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2)
  store i16 %11, i16* %result, align 2
  %12 = load i16, i16* %result, align 2
  ret i16 %12
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.formatValue.123(i64 %0, %std.fmt.FormatOptions* nonnull readonly align 8 %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %2) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %3 = alloca i64, align 8
  %4 = alloca %std.fmt.FormatOptions, align 8
  %5 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %value = alloca i64, align 8
  store i64 %0, i64* %value, align 8
  %6 = load i64, i64* %value, align 8
  store i64 %6, i64* %3, align 8
  %7 = bitcast %std.fmt.FormatOptions* %1 to i8*
  %8 = bitcast %std.fmt.FormatOptions* %4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %8, i8* align 8 %7, i64 40, i1 false)
  %9 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2 to i8*
  %10 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %10, i8* align 4 %9, i64 4, i1 false)
  %11 = call fastcc i16 @std.fmt.formatIntValue.153(i64 %6, %std.fmt.FormatOptions* %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2)
  store i16 %11, i16* %result, align 2
  %12 = load i16, i16* %result, align 2
  ret i16 %12
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.formatType.124(i64 %0, %std.fmt.FormatOptions* nonnull readonly align 8 %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %2, i64 %3) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %4 = alloca i64, align 8
  %5 = alloca %std.fmt.FormatOptions, align 8
  %6 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %value = alloca i64, align 8
  %max_depth = alloca i64, align 8
  store i64 %0, i64* %value, align 8
  store i64 %3, i64* %max_depth, align 8
  %7 = load i64, i64* %value, align 8
  store i64 %7, i64* %4, align 8
  %8 = bitcast %std.fmt.FormatOptions* %1 to i8*
  %9 = bitcast %std.fmt.FormatOptions* %5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %9, i8* align 8 %8, i64 40, i1 false)
  %10 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2 to i8*
  %11 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %6 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %11, i8* align 4 %10, i64 4, i1 false)
  %12 = call fastcc i16 @std.fmt.formatValue.125(i64 %7, %std.fmt.FormatOptions* %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2)
  store i16 %12, i16* %result, align 2
  %13 = load i16, i16* %result, align 2
  ret i16 %13
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.formatValue.125(i64 %0, %std.fmt.FormatOptions* nonnull readonly align 8 %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %2) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %3 = alloca i64, align 8
  %4 = alloca %std.fmt.FormatOptions, align 8
  %5 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %value = alloca i64, align 8
  store i64 %0, i64* %value, align 8
  %6 = load i64, i64* %value, align 8
  store i64 %6, i64* %3, align 8
  %7 = bitcast %std.fmt.FormatOptions* %1 to i8*
  %8 = bitcast %std.fmt.FormatOptions* %4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %8, i8* align 8 %7, i64 40, i1 false)
  %9 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2 to i8*
  %10 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %10, i8* align 4 %9, i64 4, i1 false)
  %11 = call fastcc i16 @std.fmt.formatIntValue.154(i64 %6, %std.fmt.FormatOptions* %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2)
  store i16 %11, i16* %result, align 2
  %12 = load i16, i16* %result, align 2
  ret i16 %12
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.formatType.126(i64 %0, %std.fmt.FormatOptions* nonnull readonly align 8 %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %2, i64 %3) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %4 = alloca i64, align 8
  %5 = alloca %std.fmt.FormatOptions, align 8
  %6 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %value = alloca i64, align 8
  %max_depth = alloca i64, align 8
  store i64 %0, i64* %value, align 8
  store i64 %3, i64* %max_depth, align 8
  %7 = load i64, i64* %value, align 8
  store i64 %7, i64* %4, align 8
  %8 = bitcast %std.fmt.FormatOptions* %1 to i8*
  %9 = bitcast %std.fmt.FormatOptions* %5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %9, i8* align 8 %8, i64 40, i1 false)
  %10 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2 to i8*
  %11 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %6 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %11, i8* align 4 %10, i64 4, i1 false)
  %12 = call fastcc i16 @std.fmt.formatValue.127(i64 %7, %std.fmt.FormatOptions* %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2)
  store i16 %12, i16* %result, align 2
  %13 = load i16, i16* %result, align 2
  ret i16 %13
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.formatValue.127(i64 %0, %std.fmt.FormatOptions* nonnull readonly align 8 %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %2) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %3 = alloca i64, align 8
  %4 = alloca %std.fmt.FormatOptions, align 8
  %5 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %value = alloca i64, align 8
  store i64 %0, i64* %value, align 8
  %6 = load i64, i64* %value, align 8
  store i64 %6, i64* %3, align 8
  %7 = bitcast %std.fmt.FormatOptions* %1 to i8*
  %8 = bitcast %std.fmt.FormatOptions* %4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %8, i8* align 8 %7, i64 40, i1 false)
  %9 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2 to i8*
  %10 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %10, i8* align 4 %9, i64 4, i1 false)
  %11 = call fastcc i16 @std.fmt.formatIntValue.155(i64 %6, %std.fmt.FormatOptions* %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2)
  store i16 %11, i16* %result, align 2
  %12 = load i16, i16* %result, align 2
  ret i16 %12
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i1 @std.heap.sliceContainsSlice(%"[]u8"* nonnull readonly align 8 %0, %"[]u8"* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %result = alloca i1, align 1
  %2 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 0
  %3 = load i8*, i8** %2, align 8
  %4 = ptrtoint i8* %3 to i64
  %5 = getelementptr inbounds %"[]u8", %"[]u8"* %0, i32 0, i32 0
  %6 = load i8*, i8** %5, align 8
  %7 = ptrtoint i8* %6 to i64
  %8 = icmp uge i64 %4, %7
  br i1 %8, label %BoolAndTrue, label %BoolAndFalse

BoolAndTrue:                                      ; preds = %Entry
  %9 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 0
  %10 = load i8*, i8** %9, align 8
  %11 = ptrtoint i8* %10 to i64
  %12 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 1
  %13 = load i64, i64* %12, align 8
  %14 = add nuw i64 %11, %13
  %15 = getelementptr inbounds %"[]u8", %"[]u8"* %0, i32 0, i32 0
  %16 = load i8*, i8** %15, align 8
  %17 = ptrtoint i8* %16 to i64
  %18 = getelementptr inbounds %"[]u8", %"[]u8"* %0, i32 0, i32 1
  %19 = load i64, i64* %18, align 8
  %20 = add nuw i64 %17, %19
  %21 = icmp ule i64 %14, %20
  br label %BoolAndFalse

BoolAndFalse:                                     ; preds = %BoolAndTrue, %Entry
  %22 = phi i1 [ %8, %Entry ], [ %21, %BoolAndTrue ]
  store i1 %22, i1* %result, align 1
  %23 = load i1, i1* %result, align 1
  ret i1 %23
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i64 @std.mem.lenSliceTo.128(i8* nonnull align 1 %0) unnamed_addr #1 {
Entry:
  %result = alloca i64, align 8
  %i = alloca i64, align 8
  %ptr = alloca i8*, align 8
  store i8* %0, i8** %ptr, align 8
  store i64 0, i64* %i, align 8
  br label %WhileCond

WhileCond:                                        ; preds = %WhileBody, %Entry
  %1 = load i64, i64* %i, align 8
  %2 = load i8*, i8** %ptr, align 8
  %3 = getelementptr inbounds i8, i8* %2, i64 %1
  %4 = load i8, i8* %3, align 1
  %5 = icmp ne i8 %4, 0
  br i1 %5, label %BoolAndTrue, label %BoolAndFalse

BoolAndTrue:                                      ; preds = %WhileCond
  %6 = load i64, i64* %i, align 8
  %7 = load i8*, i8** %ptr, align 8
  %8 = getelementptr inbounds i8, i8* %7, i64 %6
  %9 = load i8, i8* %8, align 1
  %10 = icmp ne i8 %9, 0
  br label %BoolAndFalse

BoolAndFalse:                                     ; preds = %BoolAndTrue, %WhileCond
  %11 = phi i1 [ %5, %WhileCond ], [ %10, %BoolAndTrue ]
  br i1 %11, label %WhileBody, label %WhileEnd

WhileBody:                                        ; preds = %BoolAndFalse
  %12 = load i64, i64* %i, align 8
  %13 = add nuw i64 %12, 1
  store i64 %13, i64* %i, align 8
  br label %WhileCond

WhileEnd:                                         ; preds = %BoolAndFalse
  %14 = load i64, i64* %i, align 8
  store i64 %14, i64* %result, align 8
  %15 = load i64, i64* %result, align 8
  ret i64 %15
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.mem.Allocator.allocAdvancedWithRetAddr.129({ %"[]usize", i16 }* nonnull sret({ %"[]usize", i16 }) %0, %std.mem.Allocator* nonnull readonly align 8 %1, i64 %2, i1 %3, i64 %4) unnamed_addr #1 {
Entry:
  %5 = alloca i64, align 8
  %6 = alloca { i64, i16 }, align 8
  %byte_count = alloca i64, align 8
  %size_of_T = alloca i29, align 4
  %len_align = alloca i29, align 4
  %7 = alloca { %"[]u8", i16 }, align 8
  %8 = alloca { %"[]usize", i16 }, align 8
  %byte_slice = alloca %"[]u8", align 8
  %9 = alloca i64*, align 8
  %n = alloca i64, align 8
  %exact = alloca i1, align 1
  %return_address = alloca i64, align 8
  store i64 %2, i64* %n, align 8
  store i1 %3, i1* %exact, align 1
  store i64 %4, i64* %return_address, align 8
  %10 = load i64, i64* %n, align 8
  %11 = icmp eq i64 %10, 0
  br i1 %11, label %Then, label %Else

Then:                                             ; preds = %Entry
  %12 = getelementptr inbounds { %"[]usize", i16 }, { %"[]usize", i16 }* %0, i32 0, i32 1
  store i16 0, i16* %12, align 2
  %13 = getelementptr inbounds { %"[]usize", i16 }, { %"[]usize", i16 }* %0, i32 0, i32 0
  %14 = bitcast %"[]usize"* %13 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %14, i8* align 8 bitcast (%"[]usize"* @345 to i8*), i64 16, i1 false)
  ret void

Else:                                             ; preds = %Entry
  br label %EndIf

EndIf:                                            ; preds = %Else
  %15 = load i64, i64* %n, align 8
  store i64 %15, i64* %5, align 8
  call fastcc void @std.math.mul({ i64, i16 }* sret({ i64, i16 }) %6, i64 8, i64 %15)
  %16 = getelementptr inbounds { i64, i16 }, { i64, i16 }* %6, i32 0, i32 1
  %17 = load i16, i16* %16, align 2
  %18 = icmp ne i16 %17, 0
  br i1 %18, label %UnwrapErrError, label %UnwrapErrOk

UnwrapErrError:                                   ; preds = %EndIf
  %19 = getelementptr inbounds { %"[]usize", i16 }, { %"[]usize", i16 }* %0, i32 0, i32 1
  store i16 16, i16* %19, align 2
  ret void

UnwrapErrOk:                                      ; preds = %EndIf
  %20 = getelementptr inbounds { i64, i16 }, { i64, i16 }* %6, i32 0, i32 0
  %21 = load i64, i64* %20, align 8
  store i64 %21, i64* %byte_count, align 8
  br label %UnwrapErrEnd

UnwrapErrEnd:                                     ; preds = %UnwrapErrOk
  %22 = load i64, i64* %byte_count, align 8
  %23 = load i64, i64* %n, align 8
  %24 = udiv exact i64 %22, %23
  %25 = trunc i64 %24 to i29
  store i29 %25, i29* %size_of_T, align 4
  %26 = load i1, i1* %exact, align 1
  switch i1 %26, label %SwitchElse [
    i1 false, label %SwitchProng
    i1 true, label %SwitchProng1
  ]

SwitchProng:                                      ; preds = %UnwrapErrEnd
  store i29 0, i29* %len_align, align 4
  br label %SwitchEnd

SwitchProng1:                                     ; preds = %UnwrapErrEnd
  %27 = load i29, i29* %size_of_T, align 4
  store i29 %27, i29* %len_align, align 4
  br label %SwitchEnd

SwitchElse:                                       ; preds = %UnwrapErrEnd
  unreachable

SwitchEnd:                                        ; preds = %SwitchProng1, %SwitchProng
  %28 = load i64, i64* %byte_count, align 8
  %29 = load i29, i29* %len_align, align 4
  %30 = load i64, i64* %return_address, align 8
  call fastcc void @std.mem.Allocator.rawAlloc({ %"[]u8", i16 }* sret({ %"[]u8", i16 }) %7, %std.mem.Allocator* %1, i64 %28, i29 8, i29 %29, i64 %30)
  %31 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %7, i32 0, i32 1
  %32 = load i16, i16* %31, align 2
  %33 = icmp ne i16 %32, 0
  br i1 %33, label %ErrRetReturn, label %ErrRetContinue

ErrRetReturn:                                     ; preds = %SwitchEnd
  %34 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %7, i32 0, i32 1
  %35 = load i16, i16* %34, align 2
  %36 = getelementptr inbounds { %"[]usize", i16 }, { %"[]usize", i16 }* %0, i32 0, i32 1
  store i16 %35, i16* %36, align 2
  %37 = getelementptr inbounds { %"[]usize", i16 }, { %"[]usize", i16 }* %8, i32 0, i32 1
  store i16 %35, i16* %37, align 2
  ret void

ErrRetContinue:                                   ; preds = %SwitchEnd
  %38 = getelementptr inbounds { %"[]u8", i16 }, { %"[]u8", i16 }* %7, i32 0, i32 0
  %39 = bitcast %"[]u8"* %38 to i8*
  %40 = bitcast %"[]u8"* %byte_slice to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %40, i8* align 8 %39, i64 16, i1 false)
  %41 = load i1, i1* %exact, align 1
  switch i1 %41, label %SwitchElse2 [
    i1 false, label %SwitchProng3
    i1 true, label %SwitchProng4
  ]

SwitchElse2:                                      ; preds = %ErrRetContinue
  unreachable

SwitchProng3:                                     ; preds = %ErrRetContinue
  %42 = getelementptr inbounds %"[]u8", %"[]u8"* %byte_slice, i32 0, i32 1
  %43 = load i64, i64* %42, align 8
  %44 = load i64, i64* %byte_count, align 8
  %45 = icmp eq i64 %43, %44
  call fastcc void @std.debug.assert(i1 %45)
  br label %SwitchEnd5

SwitchProng4:                                     ; preds = %ErrRetContinue
  %46 = getelementptr inbounds %"[]u8", %"[]u8"* %byte_slice, i32 0, i32 1
  %47 = load i64, i64* %46, align 8
  %48 = load i64, i64* %byte_count, align 8
  %49 = icmp uge i64 %47, %48
  call fastcc void @std.debug.assert(i1 %49)
  br label %SwitchEnd5

SwitchEnd5:                                       ; preds = %SwitchProng4, %SwitchProng3
  %50 = getelementptr inbounds %"[]u8", %"[]u8"* %byte_slice, i32 0, i32 0
  %51 = load i8*, i8** %50, align 8
  %52 = getelementptr inbounds %"[]u8", %"[]u8"* %byte_slice, i32 0, i32 1
  %53 = load i64, i64* %52, align 8
  %54 = getelementptr inbounds %"[]u8", %"[]u8"* %byte_slice, i32 0, i32 0
  %55 = load i8*, i8** %54, align 8
  %56 = ptrtoint i8* %55 to i64
  %57 = inttoptr i64 %56 to i64*
  store i64* %57, i64** %9, align 8
  %58 = getelementptr inbounds %"[]u8", %"[]u8"* %byte_slice, i32 0, i32 1
  %59 = load i64, i64* %58, align 8
  %60 = udiv exact i64 %59, 8
  %61 = getelementptr inbounds { %"[]usize", i16 }, { %"[]usize", i16 }* %0, i32 0, i32 1
  store i16 0, i16* %61, align 2
  %62 = getelementptr inbounds { %"[]usize", i16 }, { %"[]usize", i16 }* %0, i32 0, i32 0
  %63 = load i64*, i64** %9, align 8
  %64 = getelementptr inbounds i64, i64* %63, i64 0
  %65 = sub nuw i64 %60, 0
  %66 = getelementptr inbounds %"[]usize", %"[]usize"* %62, i32 0, i32 0
  store i64* %64, i64** %66, align 8
  %67 = getelementptr inbounds %"[]usize", %"[]usize"* %62, i32 0, i32 1
  store i64 %65, i64* %67, align 8
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.formatType.130(%"[]u8"* nonnull readonly align 8 %0, %std.fmt.FormatOptions* nonnull readonly align 8 %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %2, i64 %3) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %4 = alloca %std.fmt.FormatOptions, align 8
  %5 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %max_depth = alloca i64, align 8
  store i64 %3, i64* %max_depth, align 8
  %6 = load i64, i64* %max_depth, align 8
  %7 = icmp eq i64 %6, 0
  br i1 %7, label %Then, label %Else

Then:                                             ; preds = %Entry
  %8 = call fastcc i16 @"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write).writeAll"(%"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2, %"[]u8"* @326)
  store i16 %8, i16* %result, align 2
  %9 = load i16, i16* %result, align 2
  ret i16 %9

Else:                                             ; preds = %Entry
  br label %EndIf

EndIf:                                            ; preds = %Else
  %10 = bitcast %std.fmt.FormatOptions* %1 to i8*
  %11 = bitcast %std.fmt.FormatOptions* %4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %11, i8* align 8 %10, i64 40, i1 false)
  %12 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2 to i8*
  %13 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %13, i8* align 4 %12, i64 4, i1 false)
  %14 = call fastcc i16 @std.fmt.formatText.132(%"[]u8"* %0, %std.fmt.FormatOptions* %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2)
  store i16 %14, i16* %result, align 2
  %15 = load i16, i16* %result, align 2
  ret i16 %15
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.formatType.131([1 x i8]* nonnull readonly align 1 %0, %std.fmt.FormatOptions* nonnull readonly align 8 %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %2, i64 %3) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %4 = alloca %std.fmt.FormatOptions, align 8
  %5 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %value = alloca [1 x i8]*, align 8
  %max_depth = alloca i64, align 8
  store [1 x i8]* %0, [1 x i8]** %value, align 8
  store i64 %3, i64* %max_depth, align 8
  %6 = bitcast %std.fmt.FormatOptions* %1 to i8*
  %7 = bitcast %std.fmt.FormatOptions* %4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %7, i8* align 8 %6, i64 40, i1 false)
  %8 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2 to i8*
  %9 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %9, i8* align 4 %8, i64 4, i1 false)
  %10 = call fastcc i16 @std.fmt.formatText.133(%"[]u8"* @328, %std.fmt.FormatOptions* %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2)
  store i16 %10, i16* %result, align 2
  %11 = load i16, i16* %result, align 2
  ret i16 %11
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.formatText.132(%"[]u8"* nonnull readonly align 8 %0, %std.fmt.FormatOptions* nonnull readonly align 8 %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %2) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %3 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %4 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2 to i8*
  %5 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %5, i8* align 4 %4, i64 4, i1 false)
  %6 = call fastcc i16 @std.fmt.formatBuf(%"[]u8"* %0, %std.fmt.FormatOptions* %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2)
  store i16 %6, i16* %result, align 2
  %7 = load i16, i16* %result, align 2
  ret i16 %7
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.formatText.133(%"[]u8"* nonnull readonly align 8 %0, %std.fmt.FormatOptions* nonnull readonly align 8 %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %2) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %3 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %4 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2 to i8*
  %5 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %5, i8* align 4 %4, i64 4, i1 false)
  %6 = call fastcc i16 @std.fmt.formatBuf(%"[]u8"* %0, %std.fmt.FormatOptions* %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2)
  store i16 %6, i16* %result, align 2
  %7 = load i16, i16* %result, align 2
  ret i16 %7
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i1 @std.target.Arch.isPPC64(i6 %0) unnamed_addr #1 {
Entry:
  %result = alloca i1, align 1
  %arch = alloca i6, align 1
  store i6 %0, i6* %arch, align 1
  %1 = load i6, i6* %arch, align 1
  switch i6 %1, label %SwitchElse [
    i6 19, label %SwitchProng
    i6 20, label %SwitchProng
  ]

SwitchElse:                                       ; preds = %Entry
  store i1 false, i1* %result, align 1
  br label %SwitchEnd

SwitchProng:                                      ; preds = %Entry, %Entry
  store i1 true, i1* %result, align 1
  br label %SwitchEnd

SwitchEnd:                                        ; preds = %SwitchProng, %SwitchElse
  %2 = load i1, i1* %result, align 1
  ret i1 %2
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i64 @std.os.linux.vdso.lookup(%"[]u8"* nonnull readonly align 8 %0, %"[]u8"* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %result = alloca i64, align 8
  %vdso_addr = alloca i64, align 8
  %eh = alloca %std.elf.Elf64_Ehdr*, align 8
  %ph_addr = alloca i64, align 8
  %maybe_dynv = alloca i64*, align 8
  %base = alloca i64, align 8
  %i = alloca i64, align 8
  %this_ph = alloca %std.elf.Elf64_Phdr*, align 8
  %dynv = alloca i64*, align 8
  %maybe_strings = alloca i8*, align 8
  %maybe_syms = alloca %std.elf.Elf64_Sym*, align 8
  %maybe_hashtab = alloca i32*, align 8
  %maybe_versym = alloca i16*, align 8
  %maybe_verdef = alloca %std.elf.Elf64_Verdef*, align 8
  %i45 = alloca i64, align 8
  %p = alloca i64, align 8
  %strings = alloca i8*, align 8
  %syms = alloca %std.elf.Elf64_Sym*, align 8
  %hashtab = alloca i32*, align 8
  %i46 = alloca i64, align 8
  %2 = alloca i8*, align 8
  %sym_name = alloca i8*, align 8
  %3 = alloca %"[]u8", align 8
  %4 = alloca i8*, align 8
  %5 = alloca %"[]u8", align 8
  %versym = alloca i16*, align 8
  %6 = call fastcc i64 @std.os.linux.getauxval(i64 33)
  store i64 %6, i64* %vdso_addr, align 8
  %7 = load i64, i64* %vdso_addr, align 8
  %8 = icmp eq i64 %7, 0
  br i1 %8, label %Then, label %Else

Then:                                             ; preds = %Entry
  store i64 0, i64* %result, align 8
  %9 = load i64, i64* %result, align 8
  ret i64 %9

Else:                                             ; preds = %Entry
  br label %EndIf

EndIf:                                            ; preds = %Else
  %10 = load i64, i64* %vdso_addr, align 8
  %11 = inttoptr i64 %10 to %std.elf.Elf64_Ehdr*
  store %std.elf.Elf64_Ehdr* %11, %std.elf.Elf64_Ehdr** %eh, align 8
  %12 = load i64, i64* %vdso_addr, align 8
  %13 = load %std.elf.Elf64_Ehdr*, %std.elf.Elf64_Ehdr** %eh, align 8
  %14 = getelementptr inbounds %std.elf.Elf64_Ehdr, %std.elf.Elf64_Ehdr* %13, i32 0, i32 5
  %15 = load i64, i64* %14, align 8
  %16 = add nuw i64 %12, %15
  store i64 %16, i64* %ph_addr, align 8
  store i64* null, i64** %maybe_dynv, align 8
  store i64 -1, i64* %base, align 8
  store i64 0, i64* %i, align 8
  br label %WhileCond

WhileCond:                                        ; preds = %SwitchEnd, %EndIf
  %17 = load i64, i64* %i, align 8
  %18 = load %std.elf.Elf64_Ehdr*, %std.elf.Elf64_Ehdr** %eh, align 8
  %19 = getelementptr inbounds %std.elf.Elf64_Ehdr, %std.elf.Elf64_Ehdr* %18, i32 0, i32 10
  %20 = load i16, i16* %19, align 2
  %21 = zext i16 %20 to i64
  %22 = icmp ult i64 %17, %21
  br i1 %22, label %WhileBody, label %WhileEnd

WhileBody:                                        ; preds = %WhileCond
  %23 = load i64, i64* %ph_addr, align 8
  %24 = inttoptr i64 %23 to %std.elf.Elf64_Phdr*
  store %std.elf.Elf64_Phdr* %24, %std.elf.Elf64_Phdr** %this_ph, align 8
  %25 = load %std.elf.Elf64_Phdr*, %std.elf.Elf64_Phdr** %this_ph, align 8
  %26 = getelementptr inbounds %std.elf.Elf64_Phdr, %std.elf.Elf64_Phdr* %25, i32 0, i32 0
  %27 = load i32, i32* %26, align 4
  switch i32 %27, label %SwitchElse [
    i32 1, label %SwitchProng
    i32 2, label %SwitchProng1
  ]

SwitchElse:                                       ; preds = %WhileBody
  br label %SwitchEnd

SwitchProng:                                      ; preds = %WhileBody
  %28 = load i64, i64* %vdso_addr, align 8
  %29 = load %std.elf.Elf64_Phdr*, %std.elf.Elf64_Phdr** %this_ph, align 8
  %30 = getelementptr inbounds %std.elf.Elf64_Phdr, %std.elf.Elf64_Phdr* %29, i32 0, i32 2
  %31 = load i64, i64* %30, align 8
  %32 = add i64 %28, %31
  %33 = load %std.elf.Elf64_Phdr*, %std.elf.Elf64_Phdr** %this_ph, align 8
  %34 = getelementptr inbounds %std.elf.Elf64_Phdr, %std.elf.Elf64_Phdr* %33, i32 0, i32 3
  %35 = load i64, i64* %34, align 8
  %36 = sub i64 %32, %35
  store i64 %36, i64* %base, align 8
  br label %SwitchEnd

SwitchProng1:                                     ; preds = %WhileBody
  %37 = load i64, i64* %vdso_addr, align 8
  %38 = load %std.elf.Elf64_Phdr*, %std.elf.Elf64_Phdr** %this_ph, align 8
  %39 = getelementptr inbounds %std.elf.Elf64_Phdr, %std.elf.Elf64_Phdr* %38, i32 0, i32 2
  %40 = load i64, i64* %39, align 8
  %41 = add nuw i64 %37, %40
  %42 = inttoptr i64 %41 to i64*
  store i64* %42, i64** %maybe_dynv, align 8
  br label %SwitchEnd

SwitchEnd:                                        ; preds = %SwitchProng1, %SwitchProng, %SwitchElse
  %43 = load i64, i64* %i, align 8
  %44 = add nuw i64 %43, 1
  store i64 %44, i64* %i, align 8
  %45 = load i64, i64* %ph_addr, align 8
  %46 = load %std.elf.Elf64_Ehdr*, %std.elf.Elf64_Ehdr** %eh, align 8
  %47 = getelementptr inbounds %std.elf.Elf64_Ehdr, %std.elf.Elf64_Ehdr* %46, i32 0, i32 9
  %48 = load i16, i16* %47, align 2
  %49 = zext i16 %48 to i64
  %50 = add nuw i64 %45, %49
  store i64 %50, i64* %ph_addr, align 8
  br label %WhileCond

WhileEnd:                                         ; preds = %WhileCond
  %51 = load i64*, i64** %maybe_dynv, align 8
  %52 = icmp ne i64* %51, null
  br i1 %52, label %OptionalNonNull, label %OptionalNull

OptionalNull:                                     ; preds = %WhileEnd
  store i64 0, i64* %result, align 8
  %53 = load i64, i64* %result, align 8
  ret i64 %53

OptionalNonNull:                                  ; preds = %WhileEnd
  %54 = load i64*, i64** %maybe_dynv, align 8
  store i64* %54, i64** %dynv, align 8
  br label %OptionalEnd

OptionalEnd:                                      ; preds = %OptionalNonNull
  %55 = load i64, i64* %base, align 8
  %56 = icmp eq i64 %55, -1
  br i1 %56, label %Then2, label %Else3

Then2:                                            ; preds = %OptionalEnd
  store i64 0, i64* %result, align 8
  %57 = load i64, i64* %result, align 8
  ret i64 %57

Else3:                                            ; preds = %OptionalEnd
  br label %EndIf4

EndIf4:                                           ; preds = %Else3
  store i8* null, i8** %maybe_strings, align 8
  store %std.elf.Elf64_Sym* null, %std.elf.Elf64_Sym** %maybe_syms, align 8
  store i32* null, i32** %maybe_hashtab, align 8
  store i16* null, i16** %maybe_versym, align 8
  store %std.elf.Elf64_Verdef* null, %std.elf.Elf64_Verdef** %maybe_verdef, align 8
  store i64 0, i64* %i45, align 8
  br label %WhileCond5

WhileCond5:                                       ; preds = %SwitchEnd13, %EndIf4
  %58 = load i64, i64* %i45, align 8
  %59 = load i64*, i64** %dynv, align 8
  %60 = getelementptr inbounds i64, i64* %59, i64 %58
  %61 = load i64, i64* %60, align 8
  %62 = icmp ne i64 %61, 0
  br i1 %62, label %WhileBody6, label %WhileEnd14

WhileBody6:                                       ; preds = %WhileCond5
  %63 = load i64, i64* %base, align 8
  %64 = load i64, i64* %i45, align 8
  %65 = add nuw i64 %64, 1
  %66 = load i64*, i64** %dynv, align 8
  %67 = getelementptr inbounds i64, i64* %66, i64 %65
  %68 = load i64, i64* %67, align 8
  %69 = add i64 %63, %68
  store i64 %69, i64* %p, align 8
  %70 = load i64, i64* %i45, align 8
  %71 = load i64*, i64** %dynv, align 8
  %72 = getelementptr inbounds i64, i64* %71, i64 %70
  %73 = load i64, i64* %72, align 8
  switch i64 %73, label %SwitchElse7 [
    i64 5, label %SwitchProng8
    i64 6, label %SwitchProng9
    i64 4, label %SwitchProng10
    i64 1879048176, label %SwitchProng11
    i64 1879048188, label %SwitchProng12
  ]

SwitchElse7:                                      ; preds = %WhileBody6
  br label %SwitchEnd13

SwitchProng8:                                     ; preds = %WhileBody6
  %74 = load i64, i64* %p, align 8
  %75 = inttoptr i64 %74 to i8*
  store i8* %75, i8** %maybe_strings, align 8
  br label %SwitchEnd13

SwitchProng9:                                     ; preds = %WhileBody6
  %76 = load i64, i64* %p, align 8
  %77 = inttoptr i64 %76 to %std.elf.Elf64_Sym*
  store %std.elf.Elf64_Sym* %77, %std.elf.Elf64_Sym** %maybe_syms, align 8
  br label %SwitchEnd13

SwitchProng10:                                    ; preds = %WhileBody6
  %78 = load i64, i64* %p, align 8
  %79 = inttoptr i64 %78 to i32*
  store i32* %79, i32** %maybe_hashtab, align 8
  br label %SwitchEnd13

SwitchProng11:                                    ; preds = %WhileBody6
  %80 = load i64, i64* %p, align 8
  %81 = inttoptr i64 %80 to i16*
  store i16* %81, i16** %maybe_versym, align 8
  br label %SwitchEnd13

SwitchProng12:                                    ; preds = %WhileBody6
  %82 = load i64, i64* %p, align 8
  %83 = inttoptr i64 %82 to %std.elf.Elf64_Verdef*
  store %std.elf.Elf64_Verdef* %83, %std.elf.Elf64_Verdef** %maybe_verdef, align 8
  br label %SwitchEnd13

SwitchEnd13:                                      ; preds = %SwitchProng12, %SwitchProng11, %SwitchProng10, %SwitchProng9, %SwitchProng8, %SwitchElse7
  %84 = load i64, i64* %i45, align 8
  %85 = add nuw i64 %84, 2
  store i64 %85, i64* %i45, align 8
  br label %WhileCond5

WhileEnd14:                                       ; preds = %WhileCond5
  %86 = load i8*, i8** %maybe_strings, align 8
  %87 = icmp ne i8* %86, null
  br i1 %87, label %OptionalNonNull16, label %OptionalNull15

OptionalNull15:                                   ; preds = %WhileEnd14
  store i64 0, i64* %result, align 8
  %88 = load i64, i64* %result, align 8
  ret i64 %88

OptionalNonNull16:                                ; preds = %WhileEnd14
  %89 = load i8*, i8** %maybe_strings, align 8
  store i8* %89, i8** %strings, align 8
  br label %OptionalEnd17

OptionalEnd17:                                    ; preds = %OptionalNonNull16
  %90 = load %std.elf.Elf64_Sym*, %std.elf.Elf64_Sym** %maybe_syms, align 8
  %91 = icmp ne %std.elf.Elf64_Sym* %90, null
  br i1 %91, label %OptionalNonNull19, label %OptionalNull18

OptionalNull18:                                   ; preds = %OptionalEnd17
  store i64 0, i64* %result, align 8
  %92 = load i64, i64* %result, align 8
  ret i64 %92

OptionalNonNull19:                                ; preds = %OptionalEnd17
  %93 = load %std.elf.Elf64_Sym*, %std.elf.Elf64_Sym** %maybe_syms, align 8
  store %std.elf.Elf64_Sym* %93, %std.elf.Elf64_Sym** %syms, align 8
  br label %OptionalEnd20

OptionalEnd20:                                    ; preds = %OptionalNonNull19
  %94 = load i32*, i32** %maybe_hashtab, align 8
  %95 = icmp ne i32* %94, null
  br i1 %95, label %OptionalNonNull22, label %OptionalNull21

OptionalNull21:                                   ; preds = %OptionalEnd20
  store i64 0, i64* %result, align 8
  %96 = load i64, i64* %result, align 8
  ret i64 %96

OptionalNonNull22:                                ; preds = %OptionalEnd20
  %97 = load i32*, i32** %maybe_hashtab, align 8
  store i32* %97, i32** %hashtab, align 8
  br label %OptionalEnd23

OptionalEnd23:                                    ; preds = %OptionalNonNull22
  %98 = load %std.elf.Elf64_Verdef*, %std.elf.Elf64_Verdef** %maybe_verdef, align 8
  %99 = icmp ne %std.elf.Elf64_Verdef* %98, null
  %100 = icmp eq i1 %99, false
  br i1 %100, label %Then24, label %Else25

Then24:                                           ; preds = %OptionalEnd23
  store i16* null, i16** %maybe_versym, align 8
  br label %EndIf26

Else25:                                           ; preds = %OptionalEnd23
  br label %EndIf26

EndIf26:                                          ; preds = %Else25, %Then24
  store i64 0, i64* %i46, align 8
  br label %WhileCond27

WhileCond27:                                      ; preds = %WhileContinue, %EndIf26
  %101 = load i64, i64* %i46, align 8
  %102 = load i32*, i32** %hashtab, align 8
  %103 = getelementptr inbounds i32, i32* %102, i64 1
  %104 = load i32, i32* %103, align 4
  %105 = zext i32 %104 to i64
  %106 = icmp ult i64 %101, %105
  br i1 %106, label %WhileBody28, label %WhileEnd44

WhileBody28:                                      ; preds = %WhileCond27
  %107 = load i64, i64* %i46, align 8
  %108 = load %std.elf.Elf64_Sym*, %std.elf.Elf64_Sym** %syms, align 8
  %109 = getelementptr inbounds %std.elf.Elf64_Sym, %std.elf.Elf64_Sym* %108, i64 %107
  %110 = getelementptr inbounds %std.elf.Elf64_Sym, %std.elf.Elf64_Sym* %109, i32 0, i32 1
  %111 = load i8, i8* %110, align 1
  %112 = and i8 %111, 15
  %113 = trunc i8 %112 to i5
  %114 = zext i5 %113 to i32
  %115 = shl i32 1, %114
  %116 = and i32 %115, 39
  %117 = icmp eq i32 0, %116
  br i1 %117, label %Then29, label %Else30

Then29:                                           ; preds = %WhileBody28
  br label %WhileContinue

Else30:                                           ; preds = %WhileBody28
  br label %EndIf31

EndIf31:                                          ; preds = %Else30
  %118 = load i64, i64* %i46, align 8
  %119 = load %std.elf.Elf64_Sym*, %std.elf.Elf64_Sym** %syms, align 8
  %120 = getelementptr inbounds %std.elf.Elf64_Sym, %std.elf.Elf64_Sym* %119, i64 %118
  %121 = getelementptr inbounds %std.elf.Elf64_Sym, %std.elf.Elf64_Sym* %120, i32 0, i32 1
  %122 = load i8, i8* %121, align 1
  %123 = lshr i8 %122, 4
  %124 = trunc i8 %123 to i5
  %125 = zext i5 %124 to i32
  %126 = shl i32 1, %125
  %127 = and i32 %126, 1030
  %128 = icmp eq i32 0, %127
  br i1 %128, label %Then32, label %Else33

Then32:                                           ; preds = %EndIf31
  br label %WhileContinue

Else33:                                           ; preds = %EndIf31
  br label %EndIf34

EndIf34:                                          ; preds = %Else33
  %129 = load i64, i64* %i46, align 8
  %130 = load %std.elf.Elf64_Sym*, %std.elf.Elf64_Sym** %syms, align 8
  %131 = getelementptr inbounds %std.elf.Elf64_Sym, %std.elf.Elf64_Sym* %130, i64 %129
  %132 = getelementptr inbounds %std.elf.Elf64_Sym, %std.elf.Elf64_Sym* %131, i32 0, i32 3
  %133 = load i16, i16* %132, align 2
  %134 = icmp eq i16 0, %133
  br i1 %134, label %Then35, label %Else36

Then35:                                           ; preds = %EndIf34
  br label %WhileContinue

Else36:                                           ; preds = %EndIf34
  br label %EndIf37

EndIf37:                                          ; preds = %Else36
  %135 = load i8*, i8** %strings, align 8
  %136 = load i64, i64* %i46, align 8
  %137 = load %std.elf.Elf64_Sym*, %std.elf.Elf64_Sym** %syms, align 8
  %138 = getelementptr inbounds %std.elf.Elf64_Sym, %std.elf.Elf64_Sym* %137, i64 %136
  %139 = getelementptr inbounds %std.elf.Elf64_Sym, %std.elf.Elf64_Sym* %138, i32 0, i32 0
  %140 = load i32, i32* %139, align 4
  %141 = zext i32 %140 to i64
  %142 = getelementptr inbounds i8, i8* %135, i64 %141
  store i8* %142, i8** %2, align 8
  %143 = call fastcc i8* @std.meta.assumeSentinel(i8* %142)
  store i8* %143, i8** %sym_name, align 8
  %144 = bitcast %"[]u8"* %1 to i8*
  %145 = bitcast %"[]u8"* %3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %145, i8* align 8 %144, i64 16, i1 false)
  %146 = load i8*, i8** %sym_name, align 8
  store i8* %146, i8** %4, align 8
  call fastcc void @std.mem.sliceTo.79(%"[]u8"* sret(%"[]u8") %5, i8* %146)
  %147 = call fastcc i1 @std.mem.eql(%"[]u8"* %1, %"[]u8"* %5)
  %148 = icmp eq i1 %147, false
  br i1 %148, label %Then38, label %Else39

Then38:                                           ; preds = %EndIf37
  br label %WhileContinue

Else39:                                           ; preds = %EndIf37
  br label %EndIf40

EndIf40:                                          ; preds = %Else39
  %149 = load i16*, i16** %maybe_versym, align 8
  %150 = icmp ne i16* %149, null
  br i1 %150, label %OptionalThen, label %OptionalElse

OptionalThen:                                     ; preds = %EndIf40
  %151 = load i16*, i16** %maybe_versym, align 8
  store i16* %151, i16** %versym, align 8
  %152 = load %std.elf.Elf64_Verdef*, %std.elf.Elf64_Verdef** %maybe_verdef, align 8
  %153 = load i64, i64* %i46, align 8
  %154 = load i16*, i16** %versym, align 8
  %155 = getelementptr inbounds i16, i16* %154, i64 %153
  %156 = load i16, i16* %155, align 2
  %157 = zext i16 %156 to i32
  %158 = load i8*, i8** %strings, align 8
  %159 = call fastcc i1 @std.os.linux.vdso.checkver(%std.elf.Elf64_Verdef* %152, i32 %157, %"[]u8"* %0, i8* %158)
  %160 = icmp eq i1 %159, false
  br i1 %160, label %Then41, label %Else42

Then41:                                           ; preds = %OptionalThen
  br label %WhileContinue

Else42:                                           ; preds = %OptionalThen
  br label %EndIf43

EndIf43:                                          ; preds = %Else42
  br label %OptionalEndIf

OptionalElse:                                     ; preds = %EndIf40
  br label %OptionalEndIf

OptionalEndIf:                                    ; preds = %OptionalElse, %EndIf43
  %161 = load i64, i64* %base, align 8
  %162 = load i64, i64* %i46, align 8
  %163 = load %std.elf.Elf64_Sym*, %std.elf.Elf64_Sym** %syms, align 8
  %164 = getelementptr inbounds %std.elf.Elf64_Sym, %std.elf.Elf64_Sym* %163, i64 %162
  %165 = getelementptr inbounds %std.elf.Elf64_Sym, %std.elf.Elf64_Sym* %164, i32 0, i32 4
  %166 = load i64, i64* %165, align 8
  %167 = add i64 %161, %166
  store i64 %167, i64* %result, align 8
  %168 = load i64, i64* %result, align 8
  ret i64 %168

WhileContinue:                                    ; preds = %Then41, %Then38, %Then35, %Then32, %Then29
  %169 = load i64, i64* %i46, align 8
  %170 = add nuw i64 %169, 1
  store i64 %170, i64* %i46, align 8
  br label %WhileCond27

WhileEnd44:                                       ; preds = %WhileCond27
  store i64 0, i64* %result, align 8
  %171 = load i64, i64* %result, align 8
  ret i64 %171
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.hash.wyhash.WyhashStateless.round(%std.hash.wyhash.WyhashStateless* nonnull align 8 %0, %"[]u8"* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %2 = alloca %"[]u8", align 8
  %3 = alloca %"[]u8", align 8
  %4 = alloca %"[]u8", align 8
  %5 = alloca %"[]u8", align 8
  %self = alloca %std.hash.wyhash.WyhashStateless*, align 8
  store %std.hash.wyhash.WyhashStateless* %0, %std.hash.wyhash.WyhashStateless** %self, align 8
  %6 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 1
  %7 = load i64, i64* %6, align 8
  %8 = icmp eq i64 %7, 32
  call fastcc void @std.debug.assert(i1 %8)
  %9 = load %std.hash.wyhash.WyhashStateless*, %std.hash.wyhash.WyhashStateless** %self, align 8
  %10 = getelementptr inbounds %std.hash.wyhash.WyhashStateless, %std.hash.wyhash.WyhashStateless* %9, i32 0, i32 0
  %11 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 1
  %12 = load i64, i64* %11, align 8
  %13 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 0
  %14 = load i8*, i8** %13, align 8
  %15 = getelementptr inbounds i8, i8* %14, i64 0
  %16 = sub nuw i64 %12, 0
  %17 = getelementptr inbounds %"[]u8", %"[]u8"* %2, i32 0, i32 0
  store i8* %15, i8** %17, align 8
  %18 = getelementptr inbounds %"[]u8", %"[]u8"* %2, i32 0, i32 1
  store i64 %16, i64* %18, align 8
  %19 = call fastcc i64 @std.hash.wyhash.read_bytes.156(%"[]u8"* %2)
  %20 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 1
  %21 = load i64, i64* %20, align 8
  %22 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 0
  %23 = load i8*, i8** %22, align 8
  %24 = getelementptr inbounds i8, i8* %23, i64 8
  %25 = sub nuw i64 %21, 8
  %26 = getelementptr inbounds %"[]u8", %"[]u8"* %3, i32 0, i32 0
  store i8* %24, i8** %26, align 8
  %27 = getelementptr inbounds %"[]u8", %"[]u8"* %3, i32 0, i32 1
  store i64 %25, i64* %27, align 8
  %28 = call fastcc i64 @std.hash.wyhash.read_bytes.156(%"[]u8"* %3)
  %29 = load %std.hash.wyhash.WyhashStateless*, %std.hash.wyhash.WyhashStateless** %self, align 8
  %30 = getelementptr inbounds %std.hash.wyhash.WyhashStateless, %std.hash.wyhash.WyhashStateless* %29, i32 0, i32 0
  %31 = load i64, i64* %30, align 8
  %32 = call fastcc i64 @std.hash.wyhash.mix0(i64 %19, i64 %28, i64 %31)
  %33 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 1
  %34 = load i64, i64* %33, align 8
  %35 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 0
  %36 = load i8*, i8** %35, align 8
  %37 = getelementptr inbounds i8, i8* %36, i64 16
  %38 = sub nuw i64 %34, 16
  %39 = getelementptr inbounds %"[]u8", %"[]u8"* %4, i32 0, i32 0
  store i8* %37, i8** %39, align 8
  %40 = getelementptr inbounds %"[]u8", %"[]u8"* %4, i32 0, i32 1
  store i64 %38, i64* %40, align 8
  %41 = call fastcc i64 @std.hash.wyhash.read_bytes.156(%"[]u8"* %4)
  %42 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 1
  %43 = load i64, i64* %42, align 8
  %44 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 0
  %45 = load i8*, i8** %44, align 8
  %46 = getelementptr inbounds i8, i8* %45, i64 24
  %47 = sub nuw i64 %43, 24
  %48 = getelementptr inbounds %"[]u8", %"[]u8"* %5, i32 0, i32 0
  store i8* %46, i8** %48, align 8
  %49 = getelementptr inbounds %"[]u8", %"[]u8"* %5, i32 0, i32 1
  store i64 %47, i64* %49, align 8
  %50 = call fastcc i64 @std.hash.wyhash.read_bytes.156(%"[]u8"* %5)
  %51 = load %std.hash.wyhash.WyhashStateless*, %std.hash.wyhash.WyhashStateless** %self, align 8
  %52 = getelementptr inbounds %std.hash.wyhash.WyhashStateless, %std.hash.wyhash.WyhashStateless* %51, i32 0, i32 0
  %53 = load i64, i64* %52, align 8
  %54 = call fastcc i64 @std.hash.wyhash.mix1(i64 %41, i64 %50, i64 %53)
  %55 = xor i64 %32, %54
  store i64 %55, i64* %10, align 8
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i64 @std.hash.wyhash.read_bytes(%"[]u8"* nonnull readonly align 8 %0) unnamed_addr #1 {
Entry:
  %result = alloca i64, align 8
  %1 = alloca [1 x i8]*, align 8
  %2 = getelementptr inbounds %"[]u8", %"[]u8"* %0, i32 0, i32 0
  %3 = load i8*, i8** %2, align 8
  %4 = getelementptr inbounds i8, i8* %3, i64 0
  %5 = bitcast i8* %4 to [1 x i8]*
  store [1 x i8]* %5, [1 x i8]** %1, align 8
  %6 = call fastcc i8 @std.mem.readIntNative.157([1 x i8]* %5)
  %7 = zext i8 %6 to i64
  store i64 %7, i64* %result, align 8
  %8 = load i64, i64* %result, align 8
  ret i64 %8
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i64 @std.hash.wyhash.mix0(i64 %0, i64 %1, i64 %2) unnamed_addr #1 {
Entry:
  %result = alloca i64, align 8
  %a = alloca i64, align 8
  %b = alloca i64, align 8
  %seed = alloca i64, align 8
  store i64 %0, i64* %a, align 8
  store i64 %1, i64* %b, align 8
  store i64 %2, i64* %seed, align 8
  %3 = load i64, i64* %a, align 8
  %4 = load i64, i64* %seed, align 8
  %5 = xor i64 %3, %4
  %6 = xor i64 %5, -6884282663029611473
  %7 = load i64, i64* %b, align 8
  %8 = load i64, i64* %seed, align 8
  %9 = xor i64 %7, %8
  %10 = xor i64 %9, -1800455987208640293
  %11 = call fastcc i64 @std.hash.wyhash.mum(i64 %6, i64 %10)
  store i64 %11, i64* %result, align 8
  %12 = load i64, i64* %result, align 8
  ret i64 %12
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i64 @std.hash.wyhash.read_bytes.134(%"[]u8"* nonnull readonly align 8 %0) unnamed_addr #1 {
Entry:
  %result = alloca i64, align 8
  %1 = alloca [2 x i8]*, align 8
  %2 = getelementptr inbounds %"[]u8", %"[]u8"* %0, i32 0, i32 0
  %3 = load i8*, i8** %2, align 8
  %4 = getelementptr inbounds i8, i8* %3, i64 0
  %5 = bitcast i8* %4 to [2 x i8]*
  store [2 x i8]* %5, [2 x i8]** %1, align 8
  %6 = call fastcc i16 @std.mem.readIntNative.158([2 x i8]* %5)
  %7 = zext i16 %6 to i64
  store i64 %7, i64* %result, align 8
  %8 = load i64, i64* %result, align 8
  ret i64 %8
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i64 @std.hash.wyhash.read_bytes.135(%"[]u8"* nonnull readonly align 8 %0) unnamed_addr #1 {
Entry:
  %result = alloca i64, align 8
  %1 = alloca [4 x i8]*, align 8
  %2 = getelementptr inbounds %"[]u8", %"[]u8"* %0, i32 0, i32 0
  %3 = load i8*, i8** %2, align 8
  %4 = getelementptr inbounds i8, i8* %3, i64 0
  %5 = bitcast i8* %4 to [4 x i8]*
  store [4 x i8]* %5, [4 x i8]** %1, align 8
  %6 = call fastcc i32 @std.mem.readIntNative.159([4 x i8]* %5)
  %7 = zext i32 %6 to i64
  store i64 %7, i64* %result, align 8
  %8 = load i64, i64* %result, align 8
  ret i64 %8
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i64 @std.hash.wyhash.read_8bytes_swapped(%"[]u8"* nonnull readonly align 8 %0) unnamed_addr #1 {
Entry:
  %result = alloca i64, align 8
  %1 = alloca %"[]u8", align 8
  %2 = alloca %"[]u8", align 8
  %3 = bitcast %"[]u8"* %0 to i8*
  %4 = bitcast %"[]u8"* %1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %4, i8* align 8 %3, i64 16, i1 false)
  %5 = call fastcc i64 @std.hash.wyhash.read_bytes.135(%"[]u8"* %0)
  %6 = shl i64 %5, 32
  %7 = getelementptr inbounds %"[]u8", %"[]u8"* %0, i32 0, i32 1
  %8 = load i64, i64* %7, align 8
  %9 = getelementptr inbounds %"[]u8", %"[]u8"* %0, i32 0, i32 0
  %10 = load i8*, i8** %9, align 8
  %11 = getelementptr inbounds i8, i8* %10, i64 4
  %12 = sub nuw i64 %8, 4
  %13 = getelementptr inbounds %"[]u8", %"[]u8"* %2, i32 0, i32 0
  store i8* %11, i8** %13, align 8
  %14 = getelementptr inbounds %"[]u8", %"[]u8"* %2, i32 0, i32 1
  store i64 %12, i64* %14, align 8
  %15 = call fastcc i64 @std.hash.wyhash.read_bytes.135(%"[]u8"* %2)
  %16 = or i64 %6, %15
  store i64 %16, i64* %result, align 8
  %17 = load i64, i64* %result, align 8
  ret i64 %17
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i64 @std.hash.wyhash.mix1(i64 %0, i64 %1, i64 %2) unnamed_addr #1 {
Entry:
  %result = alloca i64, align 8
  %a = alloca i64, align 8
  %b = alloca i64, align 8
  %seed = alloca i64, align 8
  store i64 %0, i64* %a, align 8
  store i64 %1, i64* %b, align 8
  store i64 %2, i64* %seed, align 8
  %3 = load i64, i64* %a, align 8
  %4 = load i64, i64* %seed, align 8
  %5 = xor i64 %3, %4
  %6 = xor i64 %5, -8161530843051276573
  %7 = load i64, i64* %b, align 8
  %8 = load i64, i64* %seed, align 8
  %9 = xor i64 %7, %8
  %10 = xor i64 %9, 6384245875588680899
  %11 = call fastcc i64 @std.hash.wyhash.mum(i64 %6, i64 %10)
  store i64 %11, i64* %result, align 8
  %12 = load i64, i64* %result, align 8
  ret i64 %12
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i64 @std.hash.wyhash.mum(i64 %0, i64 %1) unnamed_addr #1 {
Entry:
  %result = alloca i64, align 8
  %2 = alloca i64, align 8
  %3 = alloca i64, align 8
  %r = alloca i128, align 16
  %a = alloca i64, align 8
  %b = alloca i64, align 8
  store i64 %0, i64* %a, align 8
  store i64 %1, i64* %b, align 8
  %4 = load i64, i64* %a, align 8
  store i64 %4, i64* %2, align 8
  %5 = load i64, i64* %b, align 8
  store i64 %5, i64* %3, align 8
  %6 = call fastcc i128 @std.math.mulWide(i64 %4, i64 %5)
  store i128 %6, i128* %r, align 16
  %7 = load i128, i128* %r, align 16
  %8 = lshr i128 %7, 64
  %9 = load i128, i128* %r, align 16
  %10 = xor i128 %8, %9
  store i128 %10, i128* %r, align 16
  %11 = load i128, i128* %r, align 16
  %12 = trunc i128 %11 to i64
  store i64 %12, i64* %result, align 8
  %13 = load i64, i64* %result, align 8
  ret i64 %13
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i64 @std.mem.alignBackward(i64 %0, i64 %1) unnamed_addr #1 {
Entry:
  %result = alloca i64, align 8
  %2 = alloca i64, align 8
  %3 = alloca i64, align 8
  %addr = alloca i64, align 8
  %alignment = alloca i64, align 8
  store i64 %0, i64* %addr, align 8
  store i64 %1, i64* %alignment, align 8
  %4 = load i64, i64* %addr, align 8
  store i64 %4, i64* %2, align 8
  %5 = load i64, i64* %alignment, align 8
  store i64 %5, i64* %3, align 8
  %6 = call fastcc i64 @std.mem.alignBackwardGeneric(i64 %4, i64 %5)
  store i64 %6, i64* %result, align 8
  %7 = load i64, i64* %result, align 8
  ret i64 %7
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.mem.span(%"[]u8"* nonnull sret(%"[]u8") %0, %"[]u8"* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %2 = alloca %"[]u8", align 8
  %l = alloca i64, align 8
  %3 = bitcast %"[]u8"* %1 to i8*
  %4 = bitcast %"[]u8"* %2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %4, i8* align 8 %3, i64 16, i1 false)
  %5 = call fastcc i64 @std.mem.len(%"[]u8"* %1)
  store i64 %5, i64* %l, align 8
  %6 = load i64, i64* %l, align 8
  %7 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 0
  %8 = load i8*, i8** %7, align 8
  %9 = getelementptr inbounds i8, i8* %8, i64 0
  %10 = sub nuw i64 %6, 0
  %11 = getelementptr inbounds %"[]u8", %"[]u8"* %0, i32 0, i32 0
  store i8* %9, i8** %11, align 8
  %12 = getelementptr inbounds %"[]u8", %"[]u8"* %0, i32 0, i32 1
  store i64 %10, i64* %12, align 8
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @"std.io.fixed_buffer_stream.FixedBufferStream([]u8).write"({ i64, i16 }* nonnull sret({ i64, i16 }) %0, %"std.io.fixed_buffer_stream.FixedBufferStream([]u8)"* nonnull align 8 %1, %"[]u8"* nonnull readonly align 8 %2) unnamed_addr #1 {
Entry:
  %n = alloca i64, align 8
  %3 = alloca %"[]u8", align 8
  %4 = alloca %"[]u8", align 8
  %self = alloca %"std.io.fixed_buffer_stream.FixedBufferStream([]u8)"*, align 8
  store %"std.io.fixed_buffer_stream.FixedBufferStream([]u8)"* %1, %"std.io.fixed_buffer_stream.FixedBufferStream([]u8)"** %self, align 8
  %5 = getelementptr inbounds %"[]u8", %"[]u8"* %2, i32 0, i32 1
  %6 = load i64, i64* %5, align 8
  %7 = icmp eq i64 %6, 0
  br i1 %7, label %Then, label %Else

Then:                                             ; preds = %Entry
  %8 = getelementptr inbounds { i64, i16 }, { i64, i16 }* %0, i32 0, i32 1
  store i16 0, i16* %8, align 2
  %9 = getelementptr inbounds { i64, i16 }, { i64, i16 }* %0, i32 0, i32 0
  store i64 0, i64* %9, align 8
  ret void

Else:                                             ; preds = %Entry
  br label %EndIf

EndIf:                                            ; preds = %Else
  %10 = load %"std.io.fixed_buffer_stream.FixedBufferStream([]u8)"*, %"std.io.fixed_buffer_stream.FixedBufferStream([]u8)"** %self, align 8
  %11 = getelementptr inbounds %"std.io.fixed_buffer_stream.FixedBufferStream([]u8)", %"std.io.fixed_buffer_stream.FixedBufferStream([]u8)"* %10, i32 0, i32 1
  %12 = load i64, i64* %11, align 8
  %13 = load %"std.io.fixed_buffer_stream.FixedBufferStream([]u8)"*, %"std.io.fixed_buffer_stream.FixedBufferStream([]u8)"** %self, align 8
  %14 = getelementptr inbounds %"std.io.fixed_buffer_stream.FixedBufferStream([]u8)", %"std.io.fixed_buffer_stream.FixedBufferStream([]u8)"* %13, i32 0, i32 0
  %15 = getelementptr inbounds %"[]u8", %"[]u8"* %14, i32 0, i32 1
  %16 = load i64, i64* %15, align 8
  %17 = icmp uge i64 %12, %16
  br i1 %17, label %Then1, label %Else2

Then1:                                            ; preds = %EndIf
  %18 = getelementptr inbounds { i64, i16 }, { i64, i16 }* %0, i32 0, i32 1
  store i16 4, i16* %18, align 2
  ret void

Else2:                                            ; preds = %EndIf
  br label %EndIf3

EndIf3:                                           ; preds = %Else2
  %19 = load %"std.io.fixed_buffer_stream.FixedBufferStream([]u8)"*, %"std.io.fixed_buffer_stream.FixedBufferStream([]u8)"** %self, align 8
  %20 = getelementptr inbounds %"std.io.fixed_buffer_stream.FixedBufferStream([]u8)", %"std.io.fixed_buffer_stream.FixedBufferStream([]u8)"* %19, i32 0, i32 1
  %21 = load i64, i64* %20, align 8
  %22 = getelementptr inbounds %"[]u8", %"[]u8"* %2, i32 0, i32 1
  %23 = load i64, i64* %22, align 8
  %24 = add nuw i64 %21, %23
  %25 = load %"std.io.fixed_buffer_stream.FixedBufferStream([]u8)"*, %"std.io.fixed_buffer_stream.FixedBufferStream([]u8)"** %self, align 8
  %26 = getelementptr inbounds %"std.io.fixed_buffer_stream.FixedBufferStream([]u8)", %"std.io.fixed_buffer_stream.FixedBufferStream([]u8)"* %25, i32 0, i32 0
  %27 = getelementptr inbounds %"[]u8", %"[]u8"* %26, i32 0, i32 1
  %28 = load i64, i64* %27, align 8
  %29 = icmp ule i64 %24, %28
  br i1 %29, label %Then4, label %Else5

Then4:                                            ; preds = %EndIf3
  %30 = getelementptr inbounds %"[]u8", %"[]u8"* %2, i32 0, i32 1
  %31 = load i64, i64* %30, align 8
  store i64 %31, i64* %n, align 8
  br label %EndIf6

Else5:                                            ; preds = %EndIf3
  %32 = load %"std.io.fixed_buffer_stream.FixedBufferStream([]u8)"*, %"std.io.fixed_buffer_stream.FixedBufferStream([]u8)"** %self, align 8
  %33 = getelementptr inbounds %"std.io.fixed_buffer_stream.FixedBufferStream([]u8)", %"std.io.fixed_buffer_stream.FixedBufferStream([]u8)"* %32, i32 0, i32 0
  %34 = getelementptr inbounds %"[]u8", %"[]u8"* %33, i32 0, i32 1
  %35 = load i64, i64* %34, align 8
  %36 = load %"std.io.fixed_buffer_stream.FixedBufferStream([]u8)"*, %"std.io.fixed_buffer_stream.FixedBufferStream([]u8)"** %self, align 8
  %37 = getelementptr inbounds %"std.io.fixed_buffer_stream.FixedBufferStream([]u8)", %"std.io.fixed_buffer_stream.FixedBufferStream([]u8)"* %36, i32 0, i32 1
  %38 = load i64, i64* %37, align 8
  %39 = sub nuw i64 %35, %38
  store i64 %39, i64* %n, align 8
  br label %EndIf6

EndIf6:                                           ; preds = %Else5, %Then4
  %40 = load %"std.io.fixed_buffer_stream.FixedBufferStream([]u8)"*, %"std.io.fixed_buffer_stream.FixedBufferStream([]u8)"** %self, align 8
  %41 = getelementptr inbounds %"std.io.fixed_buffer_stream.FixedBufferStream([]u8)", %"std.io.fixed_buffer_stream.FixedBufferStream([]u8)"* %40, i32 0, i32 0
  %42 = load %"std.io.fixed_buffer_stream.FixedBufferStream([]u8)"*, %"std.io.fixed_buffer_stream.FixedBufferStream([]u8)"** %self, align 8
  %43 = getelementptr inbounds %"std.io.fixed_buffer_stream.FixedBufferStream([]u8)", %"std.io.fixed_buffer_stream.FixedBufferStream([]u8)"* %42, i32 0, i32 1
  %44 = load i64, i64* %43, align 8
  %45 = load %"std.io.fixed_buffer_stream.FixedBufferStream([]u8)"*, %"std.io.fixed_buffer_stream.FixedBufferStream([]u8)"** %self, align 8
  %46 = getelementptr inbounds %"std.io.fixed_buffer_stream.FixedBufferStream([]u8)", %"std.io.fixed_buffer_stream.FixedBufferStream([]u8)"* %45, i32 0, i32 1
  %47 = load i64, i64* %46, align 8
  %48 = load i64, i64* %n, align 8
  %49 = add nuw i64 %47, %48
  %50 = getelementptr inbounds %"[]u8", %"[]u8"* %41, i32 0, i32 0
  %51 = load i8*, i8** %50, align 8
  %52 = getelementptr inbounds i8, i8* %51, i64 %44
  %53 = sub nuw i64 %49, %44
  %54 = getelementptr inbounds %"[]u8", %"[]u8"* %3, i32 0, i32 0
  store i8* %52, i8** %54, align 8
  %55 = getelementptr inbounds %"[]u8", %"[]u8"* %3, i32 0, i32 1
  store i64 %53, i64* %55, align 8
  %56 = load i64, i64* %n, align 8
  %57 = getelementptr inbounds %"[]u8", %"[]u8"* %2, i32 0, i32 0
  %58 = load i8*, i8** %57, align 8
  %59 = getelementptr inbounds i8, i8* %58, i64 0
  %60 = sub nuw i64 %56, 0
  %61 = getelementptr inbounds %"[]u8", %"[]u8"* %4, i32 0, i32 0
  store i8* %59, i8** %61, align 8
  %62 = getelementptr inbounds %"[]u8", %"[]u8"* %4, i32 0, i32 1
  store i64 %60, i64* %62, align 8
  call fastcc void @std.mem.copy(%"[]u8"* %3, %"[]u8"* %4)
  %63 = load %"std.io.fixed_buffer_stream.FixedBufferStream([]u8)"*, %"std.io.fixed_buffer_stream.FixedBufferStream([]u8)"** %self, align 8
  %64 = getelementptr inbounds %"std.io.fixed_buffer_stream.FixedBufferStream([]u8)", %"std.io.fixed_buffer_stream.FixedBufferStream([]u8)"* %63, i32 0, i32 1
  %65 = load i64, i64* %64, align 8
  %66 = load i64, i64* %n, align 8
  %67 = add nuw i64 %65, %66
  store i64 %67, i64* %64, align 8
  %68 = load i64, i64* %n, align 8
  %69 = icmp eq i64 %68, 0
  br i1 %69, label %Then7, label %Else8

Then7:                                            ; preds = %EndIf6
  %70 = getelementptr inbounds { i64, i16 }, { i64, i16 }* %0, i32 0, i32 1
  store i16 4, i16* %70, align 2
  ret void

Else8:                                            ; preds = %EndIf6
  br label %EndIf9

EndIf9:                                           ; preds = %Else8
  %71 = load i64, i64* %n, align 8
  %72 = getelementptr inbounds { i64, i16 }, { i64, i16 }* %0, i32 0, i32 1
  store i16 0, i16* %72, align 2
  %73 = getelementptr inbounds { i64, i16 }, { i64, i16 }* %0, i32 0, i32 0
  store i64 %71, i64* %73, align 8
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write).writeAll"(%"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* nonnull readonly align 8 %0, %"[]u8"* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %index = alloca i64, align 8
  %2 = alloca %"[]u8", align 8
  %3 = alloca { i64, i16 }, align 8
  store i64 0, i64* %index, align 8
  br label %WhileCond

WhileCond:                                        ; preds = %ErrRetContinue, %Entry
  %4 = load i64, i64* %index, align 8
  %5 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 1
  %6 = load i64, i64* %5, align 8
  %7 = icmp ne i64 %4, %6
  br i1 %7, label %WhileBody, label %WhileEnd

WhileBody:                                        ; preds = %WhileCond
  %8 = load i64, i64* %index, align 8
  %9 = load i64, i64* %index, align 8
  %10 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 1
  %11 = load i64, i64* %10, align 8
  %12 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 0
  %13 = load i8*, i8** %12, align 8
  %14 = getelementptr inbounds i8, i8* %13, i64 %9
  %15 = sub nuw i64 %11, %9
  %16 = getelementptr inbounds %"[]u8", %"[]u8"* %2, i32 0, i32 0
  store i8* %14, i8** %16, align 8
  %17 = getelementptr inbounds %"[]u8", %"[]u8"* %2, i32 0, i32 1
  store i64 %15, i64* %17, align 8
  call fastcc void @"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write).write"({ i64, i16 }* sret({ i64, i16 }) %3, %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* %0, %"[]u8"* %2)
  %18 = getelementptr inbounds { i64, i16 }, { i64, i16 }* %3, i32 0, i32 1
  %19 = load i16, i16* %18, align 2
  %20 = icmp ne i16 %19, 0
  br i1 %20, label %ErrRetReturn, label %ErrRetContinue

ErrRetReturn:                                     ; preds = %WhileBody
  %21 = getelementptr inbounds { i64, i16 }, { i64, i16 }* %3, i32 0, i32 1
  %22 = load i16, i16* %21, align 2
  store i16 %22, i16* %result, align 2
  ret i16 %22

ErrRetContinue:                                   ; preds = %WhileBody
  %23 = getelementptr inbounds { i64, i16 }, { i64, i16 }* %3, i32 0, i32 0
  %24 = load i64, i64* %23, align 8
  %25 = add nuw i64 %8, %24
  store i64 %25, i64* %index, align 8
  br label %WhileCond

WhileEnd:                                         ; preds = %WhileCond
  store i16 0, i16* %result, align 2
  ret i16 0
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.formatType.136(i64 %0, %std.fmt.FormatOptions* nonnull readonly align 8 %1, %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* nonnull readonly align 8 %2, i64 %3) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %4 = alloca i64, align 8
  %5 = alloca %std.fmt.FormatOptions, align 8
  %6 = alloca %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)", align 8
  %value = alloca i64, align 8
  %max_depth = alloca i64, align 8
  store i64 %0, i64* %value, align 8
  store i64 %3, i64* %max_depth, align 8
  %7 = load i64, i64* %value, align 8
  store i64 %7, i64* %4, align 8
  %8 = bitcast %std.fmt.FormatOptions* %1 to i8*
  %9 = bitcast %std.fmt.FormatOptions* %5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %9, i8* align 8 %8, i64 40, i1 false)
  %10 = bitcast %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* %2 to i8*
  %11 = bitcast %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* %6 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %11, i8* align 8 %10, i64 8, i1 false)
  %12 = call fastcc i16 @std.fmt.formatValue.137(i64 %7, %std.fmt.FormatOptions* %1, %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* %2)
  store i16 %12, i16* %result, align 2
  %13 = load i16, i16* %result, align 2
  ret i16 %13
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write).write"({ i64, i16 }* nonnull sret({ i64, i16 }) %0, %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* nonnull readonly align 8 %1, %"[]u8"* nonnull readonly align 8 %2) unnamed_addr #1 {
Entry:
  %3 = getelementptr inbounds %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)", %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* %1, i32 0, i32 0
  %4 = load %"std.io.fixed_buffer_stream.FixedBufferStream([]u8)"*, %"std.io.fixed_buffer_stream.FixedBufferStream([]u8)"** %3, align 8
  call fastcc void @"std.io.fixed_buffer_stream.FixedBufferStream([]u8).write"({ i64, i16 }* sret({ i64, i16 }) %0, %"std.io.fixed_buffer_stream.FixedBufferStream([]u8)"* %4, %"[]u8"* %2)
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.formatValue.137(i64 %0, %std.fmt.FormatOptions* nonnull readonly align 8 %1, %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* nonnull readonly align 8 %2) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %3 = alloca i64, align 8
  %4 = alloca %std.fmt.FormatOptions, align 8
  %5 = alloca %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)", align 8
  %value = alloca i64, align 8
  store i64 %0, i64* %value, align 8
  %6 = load i64, i64* %value, align 8
  store i64 %6, i64* %3, align 8
  %7 = bitcast %std.fmt.FormatOptions* %1 to i8*
  %8 = bitcast %std.fmt.FormatOptions* %4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %8, i8* align 8 %7, i64 40, i1 false)
  %9 = bitcast %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* %2 to i8*
  %10 = bitcast %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* %5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %10, i8* align 8 %9, i64 8, i1 false)
  %11 = call fastcc i16 @std.fmt.formatIntValue.160(i64 %6, %std.fmt.FormatOptions* %1, %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* %2)
  store i16 %11, i16* %result, align 2
  %12 = load i16, i16* %result, align 2
  ret i16 %12
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.format.138(%"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* nonnull readonly align 8 %0) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %options = alloca %std.fmt.FormatOptions, align 8
  %1 = alloca i16, align 2
  %2 = bitcast %std.fmt.FormatOptions* %options to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %2, i8* align 8 bitcast ({ %"?usize", %"?usize", i2, <{ i8, [6 x i8] }> }* @346 to i8*), i64 40, i1 false)
  %3 = call fastcc i16 @"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write).writeAll"(%"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* %0, %"[]u8"* @347)
  store i16 %3, i16* %1, align 2
  %4 = icmp ne i16 %3, 0
  br i1 %4, label %ErrRetReturn, label %ErrRetContinue

ErrRetReturn:                                     ; preds = %Entry
  %5 = load i16, i16* %1, align 2
  store i16 %5, i16* %result, align 2
  ret i16 %5

ErrRetContinue:                                   ; preds = %Entry
  store i16 0, i16* %result, align 2
  ret i16 0
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.format.139(%"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* nonnull readonly align 8 %0, %"std.Progress.struct:264:49"* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %options = alloca %std.fmt.FormatOptions, align 8
  %2 = alloca %"[]u8", align 8
  %3 = alloca %std.fmt.FormatOptions, align 8
  %4 = alloca %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)", align 8
  %5 = alloca i16, align 2
  %6 = bitcast %std.fmt.FormatOptions* %options to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %6, i8* align 8 bitcast ({ %"?usize", %"?usize", i2, <{ i8, [6 x i8] }> }* @348 to i8*), i64 40, i1 false)
  %7 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 0
  %8 = bitcast %"?usize"* %7 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %8, i8* align 8 bitcast (%"?usize"* @349 to i8*), i64 16, i1 false)
  %9 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 1
  %10 = bitcast %"?usize"* %9 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %10, i8* align 8 bitcast (%"?usize"* @350 to i8*), i64 16, i1 false)
  %11 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 2
  store i2 -2, i2* %11, align 1
  %12 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 3
  store i8 32, i8* %12, align 1
  %13 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 1
  %14 = bitcast %"?usize"* %13 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %14, i8* align 8 bitcast (%"?usize"* @354 to i8*), i64 16, i1 false)
  %15 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 0
  %16 = bitcast %"?usize"* %15 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %16, i8* align 8 bitcast (%"?usize"* @355 to i8*), i64 16, i1 false)
  %17 = getelementptr inbounds %"std.Progress.struct:264:49", %"std.Progress.struct:264:49"* %1, i32 0, i32 0
  %18 = bitcast %"[]u8"* %17 to i8*
  %19 = bitcast %"[]u8"* %2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %19, i8* align 8 %18, i64 16, i1 false)
  %20 = bitcast %std.fmt.FormatOptions* %options to i8*
  %21 = bitcast %std.fmt.FormatOptions* %3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %21, i8* align 8 %20, i64 40, i1 false)
  %22 = bitcast %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* %0 to i8*
  %23 = bitcast %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* %4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %23, i8* align 8 %22, i64 8, i1 false)
  %24 = call fastcc i16 @std.fmt.formatType.163(%"[]u8"* %17, %std.fmt.FormatOptions* %options, %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* %0, i64 3)
  store i16 %24, i16* %5, align 2
  %25 = icmp ne i16 %24, 0
  br i1 %25, label %ErrRetReturn, label %ErrRetContinue

ErrRetReturn:                                     ; preds = %Entry
  %26 = load i16, i16* %5, align 2
  store i16 %26, i16* %result, align 2
  ret i16 %26

ErrRetContinue:                                   ; preds = %Entry
  store i16 0, i16* %result, align 2
  ret i16 0
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.format.140(%"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* nonnull readonly align 8 %0) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %options = alloca %std.fmt.FormatOptions, align 8
  %1 = alloca i16, align 2
  %2 = bitcast %std.fmt.FormatOptions* %options to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %2, i8* align 8 bitcast ({ %"?usize", %"?usize", i2, <{ i8, [6 x i8] }> }* @358 to i8*), i64 40, i1 false)
  %3 = call fastcc i16 @"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write).writeAll"(%"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* %0, %"[]u8"* @360)
  store i16 %3, i16* %1, align 2
  %4 = icmp ne i16 %3, 0
  br i1 %4, label %ErrRetReturn, label %ErrRetContinue

ErrRetReturn:                                     ; preds = %Entry
  %5 = load i16, i16* %1, align 2
  store i16 %5, i16* %result, align 2
  ret i16 %5

ErrRetContinue:                                   ; preds = %Entry
  store i16 0, i16* %result, align 2
  ret i16 0
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.format.141(%"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* nonnull readonly align 8 %0, %"std.Progress.struct:269:56"* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %options = alloca %std.fmt.FormatOptions, align 8
  %2 = alloca i16, align 2
  %3 = alloca i64, align 8
  %4 = alloca %std.fmt.FormatOptions, align 8
  %5 = alloca %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)", align 8
  %6 = alloca i16, align 2
  %7 = alloca i16, align 2
  %8 = alloca i64, align 8
  %9 = alloca %std.fmt.FormatOptions, align 8
  %10 = alloca %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)", align 8
  %11 = alloca i16, align 2
  %12 = alloca i16, align 2
  %13 = bitcast %std.fmt.FormatOptions* %options to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %13, i8* align 8 bitcast ({ %"?usize", %"?usize", i2, <{ i8, [6 x i8] }> }* @361 to i8*), i64 40, i1 false)
  %14 = call fastcc i16 @"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write).writeAll"(%"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* %0, %"[]u8"* @363)
  store i16 %14, i16* %2, align 2
  %15 = icmp ne i16 %14, 0
  br i1 %15, label %ErrRetReturn, label %ErrRetContinue

ErrRetReturn:                                     ; preds = %Entry
  %16 = load i16, i16* %2, align 2
  store i16 %16, i16* %result, align 2
  ret i16 %16

ErrRetContinue:                                   ; preds = %Entry
  %17 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 0
  %18 = bitcast %"?usize"* %17 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %18, i8* align 8 bitcast (%"?usize"* @364 to i8*), i64 16, i1 false)
  %19 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 1
  %20 = bitcast %"?usize"* %19 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %20, i8* align 8 bitcast (%"?usize"* @365 to i8*), i64 16, i1 false)
  %21 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 2
  store i2 -2, i2* %21, align 1
  %22 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 3
  store i8 32, i8* %22, align 1
  %23 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 1
  %24 = bitcast %"?usize"* %23 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %24, i8* align 8 bitcast (%"?usize"* @368 to i8*), i64 16, i1 false)
  %25 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 0
  %26 = bitcast %"?usize"* %25 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %26, i8* align 8 bitcast (%"?usize"* @369 to i8*), i64 16, i1 false)
  %27 = getelementptr inbounds %"std.Progress.struct:269:56", %"std.Progress.struct:269:56"* %1, i32 0, i32 0
  %28 = load i64, i64* %27, align 8
  store i64 %28, i64* %3, align 8
  %29 = bitcast %std.fmt.FormatOptions* %options to i8*
  %30 = bitcast %std.fmt.FormatOptions* %4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %30, i8* align 8 %29, i64 40, i1 false)
  %31 = bitcast %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* %0 to i8*
  %32 = bitcast %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* %5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %32, i8* align 8 %31, i64 8, i1 false)
  %33 = call fastcc i16 @std.fmt.formatType.165(i64 %28, %std.fmt.FormatOptions* %options, %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* %0, i64 3)
  store i16 %33, i16* %6, align 2
  %34 = icmp ne i16 %33, 0
  br i1 %34, label %ErrRetReturn1, label %ErrRetContinue2

ErrRetReturn1:                                    ; preds = %ErrRetContinue
  %35 = load i16, i16* %6, align 2
  store i16 %35, i16* %result, align 2
  ret i16 %35

ErrRetContinue2:                                  ; preds = %ErrRetContinue
  %36 = call fastcc i16 @"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write).writeAll"(%"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* %0, %"[]u8"* @370)
  store i16 %36, i16* %7, align 2
  %37 = icmp ne i16 %36, 0
  br i1 %37, label %ErrRetReturn3, label %ErrRetContinue4

ErrRetReturn3:                                    ; preds = %ErrRetContinue2
  %38 = load i16, i16* %7, align 2
  store i16 %38, i16* %result, align 2
  ret i16 %38

ErrRetContinue4:                                  ; preds = %ErrRetContinue2
  %39 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 0
  %40 = bitcast %"?usize"* %39 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %40, i8* align 8 bitcast (%"?usize"* @371 to i8*), i64 16, i1 false)
  %41 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 1
  %42 = bitcast %"?usize"* %41 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %42, i8* align 8 bitcast (%"?usize"* @372 to i8*), i64 16, i1 false)
  %43 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 2
  store i2 -2, i2* %43, align 1
  %44 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 3
  store i8 32, i8* %44, align 1
  %45 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 1
  %46 = bitcast %"?usize"* %45 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %46, i8* align 8 bitcast (%"?usize"* @375 to i8*), i64 16, i1 false)
  %47 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 0
  %48 = bitcast %"?usize"* %47 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %48, i8* align 8 bitcast (%"?usize"* @376 to i8*), i64 16, i1 false)
  %49 = getelementptr inbounds %"std.Progress.struct:269:56", %"std.Progress.struct:269:56"* %1, i32 0, i32 1
  %50 = load i64, i64* %49, align 8
  store i64 %50, i64* %8, align 8
  %51 = bitcast %std.fmt.FormatOptions* %options to i8*
  %52 = bitcast %std.fmt.FormatOptions* %9 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %52, i8* align 8 %51, i64 40, i1 false)
  %53 = bitcast %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* %0 to i8*
  %54 = bitcast %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* %10 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %54, i8* align 8 %53, i64 8, i1 false)
  %55 = call fastcc i16 @std.fmt.formatType.166(i64 %50, %std.fmt.FormatOptions* %options, %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* %0, i64 3)
  store i16 %55, i16* %11, align 2
  %56 = icmp ne i16 %55, 0
  br i1 %56, label %ErrRetReturn5, label %ErrRetContinue6

ErrRetReturn5:                                    ; preds = %ErrRetContinue4
  %57 = load i16, i16* %11, align 2
  store i16 %57, i16* %result, align 2
  ret i16 %57

ErrRetContinue6:                                  ; preds = %ErrRetContinue4
  %58 = call fastcc i16 @"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write).writeAll"(%"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* %0, %"[]u8"* @377)
  store i16 %58, i16* %12, align 2
  %59 = icmp ne i16 %58, 0
  br i1 %59, label %ErrRetReturn7, label %ErrRetContinue8

ErrRetReturn7:                                    ; preds = %ErrRetContinue6
  %60 = load i16, i16* %12, align 2
  store i16 %60, i16* %result, align 2
  ret i16 %60

ErrRetContinue8:                                  ; preds = %ErrRetContinue6
  store i16 0, i16* %result, align 2
  ret i16 0
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.format.142(%"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* nonnull readonly align 8 %0) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %options = alloca %std.fmt.FormatOptions, align 8
  %1 = alloca i16, align 2
  %2 = bitcast %std.fmt.FormatOptions* %options to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %2, i8* align 8 bitcast ({ %"?usize", %"?usize", i2, <{ i8, [6 x i8] }> }* @380 to i8*), i64 40, i1 false)
  %3 = call fastcc i16 @"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write).writeAll"(%"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* %0, %"[]u8"* @381)
  store i16 %3, i16* %1, align 2
  %4 = icmp ne i16 %3, 0
  br i1 %4, label %ErrRetReturn, label %ErrRetContinue

ErrRetReturn:                                     ; preds = %Entry
  %5 = load i16, i16* %1, align 2
  store i16 %5, i16* %result, align 2
  ret i16 %5

ErrRetContinue:                                   ; preds = %Entry
  store i16 0, i16* %result, align 2
  ret i16 0
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.format.143(%"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* nonnull readonly align 8 %0, %"std.Progress.struct:273:52"* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %options = alloca %std.fmt.FormatOptions, align 8
  %2 = alloca i16, align 2
  %3 = alloca i64, align 8
  %4 = alloca %std.fmt.FormatOptions, align 8
  %5 = alloca %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)", align 8
  %6 = alloca i16, align 2
  %7 = alloca i16, align 2
  %8 = bitcast %std.fmt.FormatOptions* %options to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %8, i8* align 8 bitcast ({ %"?usize", %"?usize", i2, <{ i8, [6 x i8] }> }* @382 to i8*), i64 40, i1 false)
  %9 = call fastcc i16 @"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write).writeAll"(%"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* %0, %"[]u8"* @384)
  store i16 %9, i16* %2, align 2
  %10 = icmp ne i16 %9, 0
  br i1 %10, label %ErrRetReturn, label %ErrRetContinue

ErrRetReturn:                                     ; preds = %Entry
  %11 = load i16, i16* %2, align 2
  store i16 %11, i16* %result, align 2
  ret i16 %11

ErrRetContinue:                                   ; preds = %Entry
  %12 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 0
  %13 = bitcast %"?usize"* %12 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %13, i8* align 8 bitcast (%"?usize"* @385 to i8*), i64 16, i1 false)
  %14 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 1
  %15 = bitcast %"?usize"* %14 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %15, i8* align 8 bitcast (%"?usize"* @386 to i8*), i64 16, i1 false)
  %16 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 2
  store i2 -2, i2* %16, align 1
  %17 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 3
  store i8 32, i8* %17, align 1
  %18 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 1
  %19 = bitcast %"?usize"* %18 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %19, i8* align 8 bitcast (%"?usize"* @389 to i8*), i64 16, i1 false)
  %20 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %options, i32 0, i32 0
  %21 = bitcast %"?usize"* %20 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %21, i8* align 8 bitcast (%"?usize"* @390 to i8*), i64 16, i1 false)
  %22 = getelementptr inbounds %"std.Progress.struct:273:52", %"std.Progress.struct:273:52"* %1, i32 0, i32 0
  %23 = load i64, i64* %22, align 8
  store i64 %23, i64* %3, align 8
  %24 = bitcast %std.fmt.FormatOptions* %options to i8*
  %25 = bitcast %std.fmt.FormatOptions* %4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %25, i8* align 8 %24, i64 40, i1 false)
  %26 = bitcast %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* %0 to i8*
  %27 = bitcast %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* %5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %27, i8* align 8 %26, i64 8, i1 false)
  %28 = call fastcc i16 @std.fmt.formatType.169(i64 %23, %std.fmt.FormatOptions* %options, %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* %0, i64 3)
  store i16 %28, i16* %6, align 2
  %29 = icmp ne i16 %28, 0
  br i1 %29, label %ErrRetReturn1, label %ErrRetContinue2

ErrRetReturn1:                                    ; preds = %ErrRetContinue
  %30 = load i16, i16* %6, align 2
  store i16 %30, i16* %result, align 2
  ret i16 %30

ErrRetContinue2:                                  ; preds = %ErrRetContinue
  %31 = call fastcc i16 @"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write).writeAll"(%"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* %0, %"[]u8"* @391)
  store i16 %31, i16* %7, align 2
  %32 = icmp ne i16 %31, 0
  br i1 %32, label %ErrRetReturn3, label %ErrRetContinue4

ErrRetReturn3:                                    ; preds = %ErrRetContinue2
  %33 = load i16, i16* %7, align 2
  store i16 %33, i16* %result, align 2
  ret i16 %33

ErrRetContinue4:                                  ; preds = %ErrRetContinue2
  store i16 0, i16* %result, align 2
  ret i16 0
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.format.144(%"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* nonnull readonly align 8 %0) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %options = alloca %std.fmt.FormatOptions, align 8
  %1 = alloca i16, align 2
  %2 = bitcast %std.fmt.FormatOptions* %options to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %2, i8* align 8 bitcast ({ %"?usize", %"?usize", i2, <{ i8, [6 x i8] }> }* @393 to i8*), i64 40, i1 false)
  %3 = call fastcc i16 @"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write).writeAll"(%"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* %0, %"[]u8"* @394)
  store i16 %3, i16* %1, align 2
  %4 = icmp ne i16 %3, 0
  br i1 %4, label %ErrRetReturn, label %ErrRetContinue

ErrRetReturn:                                     ; preds = %Entry
  %5 = load i16, i16* %1, align 2
  store i16 %5, i16* %result, align 2
  ret i16 %5

ErrRetContinue:                                   ; preds = %Entry
  store i16 0, i16* %result, align 2
  ret i16 0
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.formatIntValue.145(i64 %0, %std.fmt.FormatOptions* nonnull readonly align 8 %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %2) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %int_value = alloca i64, align 8
  %3 = alloca i64, align 8
  %4 = alloca %std.fmt.FormatOptions, align 8
  %5 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %value = alloca i64, align 8
  store i64 %0, i64* %value, align 8
  %6 = load i64, i64* %value, align 8
  store i64 %6, i64* %int_value, align 8
  %7 = load i64, i64* %int_value, align 8
  store i64 %7, i64* %3, align 8
  %8 = bitcast %std.fmt.FormatOptions* %1 to i8*
  %9 = bitcast %std.fmt.FormatOptions* %4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %9, i8* align 8 %8, i64 40, i1 false)
  %10 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2 to i8*
  %11 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %11, i8* align 4 %10, i64 4, i1 false)
  %12 = call fastcc i16 @std.fmt.formatInt.146(i64 %7, i8 10, i1 false, %std.fmt.FormatOptions* %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2)
  store i16 %12, i16* %result, align 2
  %13 = load i16, i16* %result, align 2
  ret i16 %13
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.formatInt.146(i64 %0, i8 %1, i1 %2, %std.fmt.FormatOptions* nonnull readonly align 8 %3, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %4) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %int_value = alloca i64, align 8
  %5 = alloca i64, align 8
  %abs_value = alloca i64, align 8
  %buf = alloca [65 x i8], align 1
  %a = alloca i64, align 8
  %index = alloca i64, align 8
  %digit = alloca i64, align 8
  %6 = alloca %"[]u8", align 8
  %7 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %value = alloca i64, align 8
  %base = alloca i8, align 1
  %case = alloca i1, align 1
  store i64 %0, i64* %value, align 8
  store i8 %1, i8* %base, align 1
  store i1 %2, i1* %case, align 1
  %8 = load i8, i8* %base, align 1
  %9 = icmp uge i8 %8, 2
  call fastcc void @std.debug.assert(i1 %9)
  %10 = load i64, i64* %value, align 8
  store i64 %10, i64* %int_value, align 8
  %11 = load i64, i64* %int_value, align 8
  store i64 %11, i64* %5, align 8
  %12 = call fastcc i64 @std.math.absCast.147(i64 %11)
  store i64 %12, i64* %abs_value, align 8
  %13 = load i64, i64* %abs_value, align 8
  store i64 %13, i64* %a, align 8
  store i64 65, i64* %index, align 8
  br label %WhileCond

WhileCond:                                        ; preds = %EndIf, %Entry
  br label %WhileBody

WhileBody:                                        ; preds = %WhileCond
  %14 = load i64, i64* %a, align 8
  %15 = load i8, i8* %base, align 1
  %16 = zext i8 %15 to i64
  %17 = urem i64 %14, %16
  store i64 %17, i64* %digit, align 8
  %18 = load i64, i64* %index, align 8
  %19 = sub nuw i64 %18, 1
  store i64 %19, i64* %index, align 8
  %20 = load i64, i64* %index, align 8
  %21 = getelementptr inbounds [65 x i8], [65 x i8]* %buf, i64 0, i64 %20
  %22 = load i64, i64* %digit, align 8
  %23 = trunc i64 %22 to i8
  %24 = load i1, i1* %case, align 1
  %25 = call fastcc i8 @std.fmt.digitToChar(i8 %23, i1 %24)
  store i8 %25, i8* %21, align 1
  %26 = load i64, i64* %a, align 8
  %27 = load i8, i8* %base, align 1
  %28 = zext i8 %27 to i64
  %29 = udiv i64 %26, %28
  store i64 %29, i64* %a, align 8
  %30 = load i64, i64* %a, align 8
  %31 = icmp eq i64 %30, 0
  br i1 %31, label %Then, label %Else

Then:                                             ; preds = %WhileBody
  br label %WhileEnd

Else:                                             ; preds = %WhileBody
  br label %EndIf

EndIf:                                            ; preds = %Else
  br label %WhileCond

WhileEnd:                                         ; preds = %Then
  %32 = load i64, i64* %index, align 8
  %33 = getelementptr inbounds [65 x i8], [65 x i8]* %buf, i64 0, i64 %32
  %34 = sub nuw i64 65, %32
  %35 = getelementptr inbounds %"[]u8", %"[]u8"* %6, i32 0, i32 0
  store i8* %33, i8** %35, align 8
  %36 = getelementptr inbounds %"[]u8", %"[]u8"* %6, i32 0, i32 1
  store i64 %34, i64* %36, align 8
  %37 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %4 to i8*
  %38 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %7 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %38, i8* align 4 %37, i64 4, i1 false)
  %39 = call fastcc i16 @std.fmt.formatBuf(%"[]u8"* %6, %std.fmt.FormatOptions* %3, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %4)
  store i16 %39, i16* %result, align 2
  %40 = load i16, i16* %result, align 2
  ret i16 %40
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i64 @std.math.absCast.147(i64 %0) unnamed_addr #1 {
Entry:
  %result = alloca i64, align 8
  %x = alloca i64, align 8
  store i64 %0, i64* %x, align 8
  %1 = load i64, i64* %x, align 8
  store i64 %1, i64* %result, align 8
  %2 = load i64, i64* %result, align 8
  ret i64 %2
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.formatIntValue.148(i64 %0, %std.fmt.FormatOptions* nonnull readonly align 8 %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %2) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %int_value = alloca i64, align 8
  %3 = alloca i64, align 8
  %4 = alloca %std.fmt.FormatOptions, align 8
  %5 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %value = alloca i64, align 8
  store i64 %0, i64* %value, align 8
  %6 = load i64, i64* %value, align 8
  store i64 %6, i64* %int_value, align 8
  %7 = load i64, i64* %int_value, align 8
  store i64 %7, i64* %3, align 8
  %8 = bitcast %std.fmt.FormatOptions* %1 to i8*
  %9 = bitcast %std.fmt.FormatOptions* %4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %9, i8* align 8 %8, i64 40, i1 false)
  %10 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2 to i8*
  %11 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %11, i8* align 4 %10, i64 4, i1 false)
  %12 = call fastcc i16 @std.fmt.formatInt.146(i64 %7, i8 10, i1 false, %std.fmt.FormatOptions* %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2)
  store i16 %12, i16* %result, align 2
  %13 = load i16, i16* %result, align 2
  ret i16 %13
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc void @std.mem.sliceAsBytes.149(%"[]u8"* nonnull sret(%"[]u8") %0, %"[]u8"* nonnull readonly align 8 %1) unnamed_addr #1 {
Entry:
  %2 = alloca i8*, align 8
  %3 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 1
  %4 = load i64, i64* %3, align 8
  %5 = icmp eq i64 %4, 0
  br i1 %5, label %BoolAndTrue, label %BoolAndFalse

BoolAndTrue:                                      ; preds = %Entry
  br label %BoolAndFalse

BoolAndFalse:                                     ; preds = %BoolAndTrue, %Entry
  %6 = phi i1 [ %5, %Entry ], [ true, %BoolAndTrue ]
  br i1 %6, label %Then, label %Else

Then:                                             ; preds = %BoolAndFalse
  %7 = bitcast %"[]u8"* %0 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %7, i8* align 8 bitcast (%"[]u8"* @395 to i8*), i64 16, i1 false)
  ret void

Else:                                             ; preds = %BoolAndFalse
  br label %EndIf

EndIf:                                            ; preds = %Else
  %8 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 0
  %9 = load i8*, i8** %8, align 8
  store i8* %9, i8** %2, align 8
  %10 = getelementptr inbounds %"[]u8", %"[]u8"* %1, i32 0, i32 1
  %11 = load i64, i64* %10, align 8
  %12 = mul nuw i64 %11, 1
  %13 = load i8*, i8** %2, align 8
  %14 = getelementptr inbounds i8, i8* %13, i64 0
  %15 = sub nuw i64 %12, 0
  %16 = getelementptr inbounds %"[]u8", %"[]u8"* %0, i32 0, i32 0
  store i8* %14, i8** %16, align 8
  %17 = getelementptr inbounds %"[]u8", %"[]u8"* %0, i32 0, i32 1
  store i64 %15, i64* %17, align 8
  ret void
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.formatIntValue.150(i64 %0, %std.fmt.FormatOptions* nonnull readonly align 8 %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %2) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %int_value = alloca i64, align 8
  %3 = alloca i64, align 8
  %4 = alloca %std.fmt.FormatOptions, align 8
  %5 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %value = alloca i64, align 8
  store i64 %0, i64* %value, align 8
  %6 = load i64, i64* %value, align 8
  store i64 %6, i64* %int_value, align 8
  %7 = load i64, i64* %int_value, align 8
  store i64 %7, i64* %3, align 8
  %8 = bitcast %std.fmt.FormatOptions* %1 to i8*
  %9 = bitcast %std.fmt.FormatOptions* %4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %9, i8* align 8 %8, i64 40, i1 false)
  %10 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2 to i8*
  %11 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %11, i8* align 4 %10, i64 4, i1 false)
  %12 = call fastcc i16 @std.fmt.formatInt.146(i64 %7, i8 10, i1 false, %std.fmt.FormatOptions* %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2)
  store i16 %12, i16* %result, align 2
  %13 = load i16, i16* %result, align 2
  ret i16 %13
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.formatIntValue.151(i64 %0, %std.fmt.FormatOptions* nonnull readonly align 8 %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %2) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %int_value = alloca i64, align 8
  %3 = alloca i64, align 8
  %4 = alloca %std.fmt.FormatOptions, align 8
  %5 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %value = alloca i64, align 8
  store i64 %0, i64* %value, align 8
  %6 = load i64, i64* %value, align 8
  store i64 %6, i64* %int_value, align 8
  %7 = load i64, i64* %int_value, align 8
  store i64 %7, i64* %3, align 8
  %8 = bitcast %std.fmt.FormatOptions* %1 to i8*
  %9 = bitcast %std.fmt.FormatOptions* %4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %9, i8* align 8 %8, i64 40, i1 false)
  %10 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2 to i8*
  %11 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %11, i8* align 4 %10, i64 4, i1 false)
  %12 = call fastcc i16 @std.fmt.formatInt.146(i64 %7, i8 10, i1 false, %std.fmt.FormatOptions* %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2)
  store i16 %12, i16* %result, align 2
  %13 = load i16, i16* %result, align 2
  ret i16 %13
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.formatIntValue.152(i64 %0, %std.fmt.FormatOptions* nonnull readonly align 8 %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %2) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %int_value = alloca i64, align 8
  %3 = alloca i64, align 8
  %4 = alloca %std.fmt.FormatOptions, align 8
  %5 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %value = alloca i64, align 8
  store i64 %0, i64* %value, align 8
  %6 = load i64, i64* %value, align 8
  store i64 %6, i64* %int_value, align 8
  %7 = load i64, i64* %int_value, align 8
  store i64 %7, i64* %3, align 8
  %8 = bitcast %std.fmt.FormatOptions* %1 to i8*
  %9 = bitcast %std.fmt.FormatOptions* %4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %9, i8* align 8 %8, i64 40, i1 false)
  %10 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2 to i8*
  %11 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %11, i8* align 4 %10, i64 4, i1 false)
  %12 = call fastcc i16 @std.fmt.formatInt.146(i64 %7, i8 10, i1 false, %std.fmt.FormatOptions* %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2)
  store i16 %12, i16* %result, align 2
  %13 = load i16, i16* %result, align 2
  ret i16 %13
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.formatIntValue.153(i64 %0, %std.fmt.FormatOptions* nonnull readonly align 8 %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %2) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %int_value = alloca i64, align 8
  %3 = alloca i64, align 8
  %4 = alloca %std.fmt.FormatOptions, align 8
  %5 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %value = alloca i64, align 8
  store i64 %0, i64* %value, align 8
  %6 = load i64, i64* %value, align 8
  store i64 %6, i64* %int_value, align 8
  %7 = load i64, i64* %int_value, align 8
  store i64 %7, i64* %3, align 8
  %8 = bitcast %std.fmt.FormatOptions* %1 to i8*
  %9 = bitcast %std.fmt.FormatOptions* %4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %9, i8* align 8 %8, i64 40, i1 false)
  %10 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2 to i8*
  %11 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %11, i8* align 4 %10, i64 4, i1 false)
  %12 = call fastcc i16 @std.fmt.formatInt.146(i64 %7, i8 10, i1 false, %std.fmt.FormatOptions* %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2)
  store i16 %12, i16* %result, align 2
  %13 = load i16, i16* %result, align 2
  ret i16 %13
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.formatIntValue.154(i64 %0, %std.fmt.FormatOptions* nonnull readonly align 8 %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %2) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %int_value = alloca i64, align 8
  %3 = alloca i64, align 8
  %4 = alloca %std.fmt.FormatOptions, align 8
  %5 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %value = alloca i64, align 8
  store i64 %0, i64* %value, align 8
  %6 = load i64, i64* %value, align 8
  store i64 %6, i64* %int_value, align 8
  %7 = load i64, i64* %int_value, align 8
  store i64 %7, i64* %3, align 8
  %8 = bitcast %std.fmt.FormatOptions* %1 to i8*
  %9 = bitcast %std.fmt.FormatOptions* %4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %9, i8* align 8 %8, i64 40, i1 false)
  %10 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2 to i8*
  %11 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %11, i8* align 4 %10, i64 4, i1 false)
  %12 = call fastcc i16 @std.fmt.formatInt.146(i64 %7, i8 10, i1 false, %std.fmt.FormatOptions* %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2)
  store i16 %12, i16* %result, align 2
  %13 = load i16, i16* %result, align 2
  ret i16 %13
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.formatIntValue.155(i64 %0, %std.fmt.FormatOptions* nonnull readonly align 8 %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* nonnull readonly align 4 %2) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %int_value = alloca i64, align 8
  %3 = alloca i64, align 8
  %4 = alloca %std.fmt.FormatOptions, align 8
  %5 = alloca %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)", align 4
  %value = alloca i64, align 8
  store i64 %0, i64* %value, align 8
  %6 = load i64, i64* %value, align 8
  store i64 %6, i64* %int_value, align 8
  %7 = load i64, i64* %int_value, align 8
  store i64 %7, i64* %3, align 8
  %8 = bitcast %std.fmt.FormatOptions* %1 to i8*
  %9 = bitcast %std.fmt.FormatOptions* %4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %9, i8* align 8 %8, i64 40, i1 false)
  %10 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2 to i8*
  %11 = bitcast %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %11, i8* align 4 %10, i64 4, i1 false)
  %12 = call fastcc i16 @std.fmt.formatInt.146(i64 %7, i8 10, i1 false, %std.fmt.FormatOptions* %1, %"std.io.writer.Writer(std.fs.file.File,std.os.WriteError,std.fs.file.File.write)"* %2)
  store i16 %12, i16* %result, align 2
  %13 = load i16, i16* %result, align 2
  ret i16 %13
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i64 @std.os.linux.getauxval(i64 %0) unnamed_addr #1 {
Entry:
  %result = alloca i64, align 8
  %auxv = alloca %std.elf.Elf64_auxv_t*, align 8
  %i = alloca i64, align 8
  %index = alloca i64, align 8
  store i64 %0, i64* %index, align 8
  %1 = load %std.elf.Elf64_auxv_t*, %std.elf.Elf64_auxv_t** @elf_aux_maybe, align 8
  %2 = icmp ne %std.elf.Elf64_auxv_t* %1, null
  br i1 %2, label %OptionalNonNull, label %OptionalNull

OptionalNull:                                     ; preds = %Entry
  store i64 0, i64* %result, align 8
  %3 = load i64, i64* %result, align 8
  ret i64 %3

OptionalNonNull:                                  ; preds = %Entry
  %4 = load %std.elf.Elf64_auxv_t*, %std.elf.Elf64_auxv_t** @elf_aux_maybe, align 8
  store %std.elf.Elf64_auxv_t* %4, %std.elf.Elf64_auxv_t** %auxv, align 8
  br label %OptionalEnd

OptionalEnd:                                      ; preds = %OptionalNonNull
  store i64 0, i64* %i, align 8
  br label %WhileCond

WhileCond:                                        ; preds = %EndIf, %OptionalEnd
  %5 = load i64, i64* %i, align 8
  %6 = load %std.elf.Elf64_auxv_t*, %std.elf.Elf64_auxv_t** %auxv, align 8
  %7 = getelementptr inbounds %std.elf.Elf64_auxv_t, %std.elf.Elf64_auxv_t* %6, i64 %5
  %8 = getelementptr inbounds %std.elf.Elf64_auxv_t, %std.elf.Elf64_auxv_t* %7, i32 0, i32 0
  %9 = load i64, i64* %8, align 8
  %10 = icmp ne i64 %9, 0
  br i1 %10, label %WhileBody, label %WhileEnd

WhileBody:                                        ; preds = %WhileCond
  %11 = load i64, i64* %i, align 8
  %12 = load %std.elf.Elf64_auxv_t*, %std.elf.Elf64_auxv_t** %auxv, align 8
  %13 = getelementptr inbounds %std.elf.Elf64_auxv_t, %std.elf.Elf64_auxv_t* %12, i64 %11
  %14 = getelementptr inbounds %std.elf.Elf64_auxv_t, %std.elf.Elf64_auxv_t* %13, i32 0, i32 0
  %15 = load i64, i64* %14, align 8
  %16 = load i64, i64* %index, align 8
  %17 = icmp eq i64 %15, %16
  br i1 %17, label %Then, label %Else

Then:                                             ; preds = %WhileBody
  %18 = load i64, i64* %i, align 8
  %19 = load %std.elf.Elf64_auxv_t*, %std.elf.Elf64_auxv_t** %auxv, align 8
  %20 = getelementptr inbounds %std.elf.Elf64_auxv_t, %std.elf.Elf64_auxv_t* %19, i64 %18
  %21 = getelementptr inbounds %std.elf.Elf64_auxv_t, %std.elf.Elf64_auxv_t* %20, i32 0, i32 1
  %22 = getelementptr inbounds %"std.elf.union:790:11", %"std.elf.union:790:11"* %21, i32 0, i32 0
  %23 = load i64, i64* %22, align 8
  store i64 %23, i64* %result, align 8
  %24 = load i64, i64* %result, align 8
  ret i64 %24

Else:                                             ; preds = %WhileBody
  br label %EndIf

EndIf:                                            ; preds = %Else
  %25 = load i64, i64* %i, align 8
  %26 = add nuw i64 %25, 1
  store i64 %26, i64* %i, align 8
  br label %WhileCond

WhileEnd:                                         ; preds = %WhileCond
  store i64 0, i64* %result, align 8
  %27 = load i64, i64* %result, align 8
  ret i64 %27
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc nonnull i8* @std.meta.assumeSentinel(i8* nonnull align 1 %0) unnamed_addr #1 {
Entry:
  %result = alloca i8*, align 8
  %p = alloca i8*, align 8
  store i8* %0, i8** %p, align 8
  %1 = load i8*, i8** %p, align 8
  store i8* %1, i8** %result, align 8
  %2 = load i8*, i8** %result, align 8
  ret i8* %2
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i1 @std.os.linux.vdso.checkver(%std.elf.Elf64_Verdef* nonnull align 4 %0, i32 %1, %"[]u8"* nonnull readonly align 8 %2, i8* nonnull align 1 %3) unnamed_addr #1 {
Entry:
  %result = alloca i1, align 1
  %def = alloca %std.elf.Elf64_Verdef*, align 8
  %vsym = alloca i32, align 4
  %aux = alloca %std.elf.Elf64_Verdaux*, align 8
  %4 = alloca i8*, align 8
  %vda_name = alloca i8*, align 8
  %5 = alloca %"[]u8", align 8
  %6 = alloca i8*, align 8
  %7 = alloca %"[]u8", align 8
  %def_arg = alloca %std.elf.Elf64_Verdef*, align 8
  %vsym_arg = alloca i32, align 4
  %strings = alloca i8*, align 8
  store %std.elf.Elf64_Verdef* %0, %std.elf.Elf64_Verdef** %def_arg, align 8
  store i32 %1, i32* %vsym_arg, align 4
  store i8* %3, i8** %strings, align 8
  %8 = load %std.elf.Elf64_Verdef*, %std.elf.Elf64_Verdef** %def_arg, align 8
  store %std.elf.Elf64_Verdef* %8, %std.elf.Elf64_Verdef** %def, align 8
  %9 = load i32, i32* %vsym_arg, align 4
  %10 = and i32 %9, 32767
  store i32 %10, i32* %vsym, align 4
  br label %WhileCond

WhileCond:                                        ; preds = %EndIf3, %Entry
  br label %WhileBody

WhileBody:                                        ; preds = %WhileCond
  %11 = load %std.elf.Elf64_Verdef*, %std.elf.Elf64_Verdef** %def, align 8
  %12 = getelementptr inbounds %std.elf.Elf64_Verdef, %std.elf.Elf64_Verdef* %11, i32 0, i32 1
  %13 = load i16, i16* %12, align 2
  %14 = and i16 %13, 1
  %15 = icmp eq i16 0, %14
  br i1 %15, label %BoolAndTrue, label %BoolAndFalse

BoolAndTrue:                                      ; preds = %WhileBody
  %16 = load %std.elf.Elf64_Verdef*, %std.elf.Elf64_Verdef** %def, align 8
  %17 = getelementptr inbounds %std.elf.Elf64_Verdef, %std.elf.Elf64_Verdef* %16, i32 0, i32 2
  %18 = load i16, i16* %17, align 2
  %19 = and i16 %18, 32767
  %20 = load i32, i32* %vsym, align 4
  %21 = zext i16 %19 to i32
  %22 = icmp eq i32 %21, %20
  br label %BoolAndFalse

BoolAndFalse:                                     ; preds = %BoolAndTrue, %WhileBody
  %23 = phi i1 [ %15, %WhileBody ], [ %22, %BoolAndTrue ]
  br i1 %23, label %Then, label %Else

Then:                                             ; preds = %BoolAndFalse
  br label %WhileEnd

Else:                                             ; preds = %BoolAndFalse
  br label %EndIf

EndIf:                                            ; preds = %Else
  %24 = load %std.elf.Elf64_Verdef*, %std.elf.Elf64_Verdef** %def, align 8
  %25 = getelementptr inbounds %std.elf.Elf64_Verdef, %std.elf.Elf64_Verdef* %24, i32 0, i32 6
  %26 = load i32, i32* %25, align 4
  %27 = icmp eq i32 %26, 0
  br i1 %27, label %Then1, label %Else2

Then1:                                            ; preds = %EndIf
  store i1 false, i1* %result, align 1
  %28 = load i1, i1* %result, align 1
  ret i1 %28

Else2:                                            ; preds = %EndIf
  br label %EndIf3

EndIf3:                                           ; preds = %Else2
  %29 = load %std.elf.Elf64_Verdef*, %std.elf.Elf64_Verdef** %def, align 8
  %30 = ptrtoint %std.elf.Elf64_Verdef* %29 to i64
  %31 = load %std.elf.Elf64_Verdef*, %std.elf.Elf64_Verdef** %def, align 8
  %32 = getelementptr inbounds %std.elf.Elf64_Verdef, %std.elf.Elf64_Verdef* %31, i32 0, i32 6
  %33 = load i32, i32* %32, align 4
  %34 = zext i32 %33 to i64
  %35 = add nuw i64 %30, %34
  %36 = inttoptr i64 %35 to %std.elf.Elf64_Verdef*
  store %std.elf.Elf64_Verdef* %36, %std.elf.Elf64_Verdef** %def, align 8
  br label %WhileCond

WhileEnd:                                         ; preds = %Then
  %37 = load %std.elf.Elf64_Verdef*, %std.elf.Elf64_Verdef** %def, align 8
  %38 = ptrtoint %std.elf.Elf64_Verdef* %37 to i64
  %39 = load %std.elf.Elf64_Verdef*, %std.elf.Elf64_Verdef** %def, align 8
  %40 = getelementptr inbounds %std.elf.Elf64_Verdef, %std.elf.Elf64_Verdef* %39, i32 0, i32 5
  %41 = load i32, i32* %40, align 4
  %42 = zext i32 %41 to i64
  %43 = add nuw i64 %38, %42
  %44 = inttoptr i64 %43 to %std.elf.Elf64_Verdaux*
  store %std.elf.Elf64_Verdaux* %44, %std.elf.Elf64_Verdaux** %aux, align 8
  %45 = load i8*, i8** %strings, align 8
  %46 = load %std.elf.Elf64_Verdaux*, %std.elf.Elf64_Verdaux** %aux, align 8
  %47 = getelementptr inbounds %std.elf.Elf64_Verdaux, %std.elf.Elf64_Verdaux* %46, i32 0, i32 0
  %48 = load i32, i32* %47, align 4
  %49 = zext i32 %48 to i64
  %50 = getelementptr inbounds i8, i8* %45, i64 %49
  store i8* %50, i8** %4, align 8
  %51 = call fastcc i8* @std.meta.assumeSentinel(i8* %50)
  store i8* %51, i8** %vda_name, align 8
  %52 = bitcast %"[]u8"* %2 to i8*
  %53 = bitcast %"[]u8"* %5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %53, i8* align 8 %52, i64 16, i1 false)
  %54 = load i8*, i8** %vda_name, align 8
  store i8* %54, i8** %6, align 8
  call fastcc void @std.mem.sliceTo.79(%"[]u8"* sret(%"[]u8") %7, i8* %54)
  %55 = call fastcc i1 @std.mem.eql(%"[]u8"* %2, %"[]u8"* %7)
  store i1 %55, i1* %result, align 1
  %56 = load i1, i1* %result, align 1
  ret i1 %56
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i64 @std.hash.wyhash.read_bytes.156(%"[]u8"* nonnull readonly align 8 %0) unnamed_addr #1 {
Entry:
  %result = alloca i64, align 8
  %1 = alloca [8 x i8]*, align 8
  %2 = getelementptr inbounds %"[]u8", %"[]u8"* %0, i32 0, i32 0
  %3 = load i8*, i8** %2, align 8
  %4 = getelementptr inbounds i8, i8* %3, i64 0
  %5 = bitcast i8* %4 to [8 x i8]*
  store [8 x i8]* %5, [8 x i8]** %1, align 8
  %6 = call fastcc i64 @std.mem.readIntNative.171([8 x i8]* %5)
  store i64 %6, i64* %result, align 8
  %7 = load i64, i64* %result, align 8
  ret i64 %7
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i8 @std.mem.readIntNative.157([1 x i8]* nonnull readonly align 1 %0) unnamed_addr #1 {
Entry:
  %result = alloca i8, align 1
  %bytes = alloca [1 x i8]*, align 8
  store [1 x i8]* %0, [1 x i8]** %bytes, align 8
  %1 = load [1 x i8]*, [1 x i8]** %bytes, align 8
  %2 = bitcast [1 x i8]* %1 to i8*
  %3 = load i8, i8* %2, align 1
  store i8 %3, i8* %result, align 1
  %4 = load i8, i8* %result, align 1
  ret i8 %4
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.mem.readIntNative.158([2 x i8]* nonnull readonly align 1 %0) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %bytes = alloca [2 x i8]*, align 8
  store [2 x i8]* %0, [2 x i8]** %bytes, align 8
  %1 = load [2 x i8]*, [2 x i8]** %bytes, align 8
  %2 = bitcast [2 x i8]* %1 to i16*
  %3 = load i16, i16* %2, align 1
  store i16 %3, i16* %result, align 2
  %4 = load i16, i16* %result, align 2
  ret i16 %4
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i32 @std.mem.readIntNative.159([4 x i8]* nonnull readonly align 1 %0) unnamed_addr #1 {
Entry:
  %result = alloca i32, align 4
  %bytes = alloca [4 x i8]*, align 8
  store [4 x i8]* %0, [4 x i8]** %bytes, align 8
  %1 = load [4 x i8]*, [4 x i8]** %bytes, align 8
  %2 = bitcast [4 x i8]* %1 to i32*
  %3 = load i32, i32* %2, align 1
  store i32 %3, i32* %result, align 4
  %4 = load i32, i32* %result, align 4
  ret i32 %4
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i128 @std.math.mulWide(i64 %0, i64 %1) unnamed_addr #1 {
Entry:
  %result = alloca i128, align 16
  %a = alloca i64, align 8
  %b = alloca i64, align 8
  store i64 %0, i64* %a, align 8
  store i64 %1, i64* %b, align 8
  %2 = load i64, i64* %a, align 8
  %3 = zext i64 %2 to i128
  %4 = load i64, i64* %b, align 8
  %5 = zext i64 %4 to i128
  %6 = mul nuw i128 %3, %5
  store i128 %6, i128* %result, align 16
  %7 = load i128, i128* %result, align 8
  ret i128 %7
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i64 @std.mem.len(%"[]u8"* nonnull readonly align 8 %0) unnamed_addr #1 {
Entry:
  %result = alloca i64, align 8
  %1 = getelementptr inbounds %"[]u8", %"[]u8"* %0, i32 0, i32 1
  %2 = load i64, i64* %1, align 8
  store i64 %2, i64* %result, align 8
  store i64 %2, i64* %result, align 8
  %3 = load i64, i64* %result, align 8
  ret i64 %3
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.formatIntValue.160(i64 %0, %std.fmt.FormatOptions* nonnull readonly align 8 %1, %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* nonnull readonly align 8 %2) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %int_value = alloca i64, align 8
  %3 = alloca i64, align 8
  %4 = alloca %std.fmt.FormatOptions, align 8
  %5 = alloca %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)", align 8
  %value = alloca i64, align 8
  store i64 %0, i64* %value, align 8
  %6 = load i64, i64* %value, align 8
  store i64 %6, i64* %int_value, align 8
  %7 = load i64, i64* %int_value, align 8
  store i64 %7, i64* %3, align 8
  %8 = bitcast %std.fmt.FormatOptions* %1 to i8*
  %9 = bitcast %std.fmt.FormatOptions* %4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %9, i8* align 8 %8, i64 40, i1 false)
  %10 = bitcast %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* %2 to i8*
  %11 = bitcast %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* %5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %11, i8* align 8 %10, i64 8, i1 false)
  %12 = call fastcc i16 @std.fmt.formatInt.161(i64 %7, i8 10, i1 false, %std.fmt.FormatOptions* %1, %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* %2)
  store i16 %12, i16* %result, align 2
  %13 = load i16, i16* %result, align 2
  ret i16 %13
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.formatInt.161(i64 %0, i8 %1, i1 %2, %std.fmt.FormatOptions* nonnull readonly align 8 %3, %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* nonnull readonly align 8 %4) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %int_value = alloca i64, align 8
  %5 = alloca i64, align 8
  %abs_value = alloca i64, align 8
  %buf = alloca [65 x i8], align 1
  %a = alloca i64, align 8
  %index = alloca i64, align 8
  %digit = alloca i64, align 8
  %6 = alloca %"[]u8", align 8
  %7 = alloca %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)", align 8
  %value = alloca i64, align 8
  %base = alloca i8, align 1
  %case = alloca i1, align 1
  store i64 %0, i64* %value, align 8
  store i8 %1, i8* %base, align 1
  store i1 %2, i1* %case, align 1
  %8 = load i8, i8* %base, align 1
  %9 = icmp uge i8 %8, 2
  call fastcc void @std.debug.assert(i1 %9)
  %10 = load i64, i64* %value, align 8
  store i64 %10, i64* %int_value, align 8
  %11 = load i64, i64* %int_value, align 8
  store i64 %11, i64* %5, align 8
  %12 = call fastcc i64 @std.math.absCast.147(i64 %11)
  store i64 %12, i64* %abs_value, align 8
  %13 = load i64, i64* %abs_value, align 8
  store i64 %13, i64* %a, align 8
  store i64 65, i64* %index, align 8
  br label %WhileCond

WhileCond:                                        ; preds = %EndIf, %Entry
  br label %WhileBody

WhileBody:                                        ; preds = %WhileCond
  %14 = load i64, i64* %a, align 8
  %15 = load i8, i8* %base, align 1
  %16 = zext i8 %15 to i64
  %17 = urem i64 %14, %16
  store i64 %17, i64* %digit, align 8
  %18 = load i64, i64* %index, align 8
  %19 = sub nuw i64 %18, 1
  store i64 %19, i64* %index, align 8
  %20 = load i64, i64* %index, align 8
  %21 = getelementptr inbounds [65 x i8], [65 x i8]* %buf, i64 0, i64 %20
  %22 = load i64, i64* %digit, align 8
  %23 = trunc i64 %22 to i8
  %24 = load i1, i1* %case, align 1
  %25 = call fastcc i8 @std.fmt.digitToChar(i8 %23, i1 %24)
  store i8 %25, i8* %21, align 1
  %26 = load i64, i64* %a, align 8
  %27 = load i8, i8* %base, align 1
  %28 = zext i8 %27 to i64
  %29 = udiv i64 %26, %28
  store i64 %29, i64* %a, align 8
  %30 = load i64, i64* %a, align 8
  %31 = icmp eq i64 %30, 0
  br i1 %31, label %Then, label %Else

Then:                                             ; preds = %WhileBody
  br label %WhileEnd

Else:                                             ; preds = %WhileBody
  br label %EndIf

EndIf:                                            ; preds = %Else
  br label %WhileCond

WhileEnd:                                         ; preds = %Then
  %32 = load i64, i64* %index, align 8
  %33 = getelementptr inbounds [65 x i8], [65 x i8]* %buf, i64 0, i64 %32
  %34 = sub nuw i64 65, %32
  %35 = getelementptr inbounds %"[]u8", %"[]u8"* %6, i32 0, i32 0
  store i8* %33, i8** %35, align 8
  %36 = getelementptr inbounds %"[]u8", %"[]u8"* %6, i32 0, i32 1
  store i64 %34, i64* %36, align 8
  %37 = bitcast %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* %4 to i8*
  %38 = bitcast %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* %7 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %38, i8* align 8 %37, i64 8, i1 false)
  %39 = call fastcc i16 @std.fmt.formatBuf.162(%"[]u8"* %6, %std.fmt.FormatOptions* %3, %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* %4)
  store i16 %39, i16* %result, align 2
  %40 = load i16, i16* %result, align 2
  ret i16 %40
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.formatBuf.162(%"[]u8"* nonnull readonly align 8 %0, %std.fmt.FormatOptions* nonnull readonly align 8 %1, %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* nonnull readonly align 8 %2) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %min_width = alloca i64, align 8
  %3 = alloca { i64, i16 }, align 8
  %width = alloca i64, align 8
  %padding = alloca i64, align 8
  %4 = alloca i16, align 2
  %5 = alloca i16, align 2
  %left_padding = alloca i64, align 8
  %right_padding = alloca i64, align 8
  %6 = alloca i16, align 2
  %7 = alloca i16, align 2
  %8 = alloca i16, align 2
  %9 = alloca i16, align 2
  %10 = alloca i16, align 2
  %11 = alloca i16, align 2
  %12 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %1, i32 0, i32 1
  %13 = getelementptr inbounds %"?usize", %"?usize"* %12, i32 0, i32 1
  %14 = load i1, i1* %13, align 1
  br i1 %14, label %OptionalThen, label %OptionalElse

OptionalThen:                                     ; preds = %Entry
  %15 = getelementptr inbounds %"?usize", %"?usize"* %12, i32 0, i32 0
  %16 = load i64, i64* %15, align 8
  store i64 %16, i64* %min_width, align 8
  call fastcc void @std.unicode.utf8CountCodepoints({ i64, i16 }* sret({ i64, i16 }) %3, %"[]u8"* %0)
  %17 = getelementptr inbounds { i64, i16 }, { i64, i16 }* %3, i32 0, i32 1
  %18 = load i16, i16* %17, align 2
  %19 = icmp ne i16 %18, 0
  br i1 %19, label %UnwrapErrError, label %UnwrapErrOk

UnwrapErrError:                                   ; preds = %OptionalThen
  %20 = getelementptr inbounds %"[]u8", %"[]u8"* %0, i32 0, i32 1
  %21 = load i64, i64* %20, align 8
  store i64 %21, i64* %width, align 8
  br label %UnwrapErrEnd

UnwrapErrOk:                                      ; preds = %OptionalThen
  %22 = getelementptr inbounds { i64, i16 }, { i64, i16 }* %3, i32 0, i32 0
  %23 = load i64, i64* %22, align 8
  store i64 %23, i64* %width, align 8
  br label %UnwrapErrEnd

UnwrapErrEnd:                                     ; preds = %UnwrapErrOk, %UnwrapErrError
  %24 = load i64, i64* %width, align 8
  %25 = load i64, i64* %min_width, align 8
  %26 = icmp ult i64 %24, %25
  br i1 %26, label %Then, label %Else

Then:                                             ; preds = %UnwrapErrEnd
  %27 = load i64, i64* %min_width, align 8
  %28 = load i64, i64* %width, align 8
  %29 = sub nuw i64 %27, %28
  store i64 %29, i64* %padding, align 8
  br label %EndIf

Else:                                             ; preds = %UnwrapErrEnd
  store i64 0, i64* %padding, align 8
  br label %EndIf

EndIf:                                            ; preds = %Else, %Then
  %30 = load i64, i64* %padding, align 8
  %31 = icmp eq i64 %30, 0
  br i1 %31, label %Then1, label %Else2

Then1:                                            ; preds = %EndIf
  %32 = call fastcc i16 @"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write).writeAll"(%"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* %2, %"[]u8"* %0)
  store i16 %32, i16* %result, align 2
  %33 = load i16, i16* %result, align 2
  ret i16 %33

Else2:                                            ; preds = %EndIf
  br label %EndIf3

EndIf3:                                           ; preds = %Else2
  %34 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %1, i32 0, i32 2
  %35 = load i2, i2* %34, align 1
  switch i2 %35, label %SwitchElse [
    i2 0, label %SwitchProng
    i2 1, label %SwitchProng5
    i2 -2, label %SwitchProng11
  ]

SwitchProng:                                      ; preds = %EndIf3
  %36 = call fastcc i16 @"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write).writeAll"(%"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* %2, %"[]u8"* %0)
  store i16 %36, i16* %4, align 2
  %37 = icmp ne i16 %36, 0
  br i1 %37, label %ErrRetReturn, label %ErrRetContinue

ErrRetReturn:                                     ; preds = %SwitchProng
  %38 = load i16, i16* %4, align 2
  store i16 %38, i16* %result, align 2
  ret i16 %38

ErrRetContinue:                                   ; preds = %SwitchProng
  %39 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %1, i32 0, i32 3
  %40 = load i8, i8* %39, align 1
  %41 = load i64, i64* %padding, align 8
  %42 = call fastcc i16 @"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write).writeByteNTimes"(%"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* %2, i8 %40, i64 %41)
  store i16 %42, i16* %5, align 2
  %43 = icmp ne i16 %42, 0
  br i1 %43, label %ErrRetReturn4, label %ErrRetContinue15

ErrRetReturn4:                                    ; preds = %ErrRetContinue
  %44 = load i16, i16* %5, align 2
  store i16 %44, i16* %result, align 2
  ret i16 %44

SwitchProng5:                                     ; preds = %EndIf3
  %45 = load i64, i64* %padding, align 8
  %46 = udiv i64 %45, 2
  store i64 %46, i64* %left_padding, align 8
  %47 = load i64, i64* %padding, align 8
  %48 = add nuw i64 %47, 1
  %49 = udiv i64 %48, 2
  store i64 %49, i64* %right_padding, align 8
  %50 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %1, i32 0, i32 3
  %51 = load i8, i8* %50, align 1
  %52 = load i64, i64* %left_padding, align 8
  %53 = call fastcc i16 @"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write).writeByteNTimes"(%"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* %2, i8 %51, i64 %52)
  store i16 %53, i16* %6, align 2
  %54 = icmp ne i16 %53, 0
  br i1 %54, label %ErrRetReturn6, label %ErrRetContinue7

ErrRetReturn6:                                    ; preds = %SwitchProng5
  %55 = load i16, i16* %6, align 2
  store i16 %55, i16* %result, align 2
  ret i16 %55

ErrRetContinue7:                                  ; preds = %SwitchProng5
  %56 = call fastcc i16 @"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write).writeAll"(%"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* %2, %"[]u8"* %0)
  store i16 %56, i16* %7, align 2
  %57 = icmp ne i16 %56, 0
  br i1 %57, label %ErrRetReturn8, label %ErrRetContinue9

ErrRetReturn8:                                    ; preds = %ErrRetContinue7
  %58 = load i16, i16* %7, align 2
  store i16 %58, i16* %result, align 2
  ret i16 %58

ErrRetContinue9:                                  ; preds = %ErrRetContinue7
  %59 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %1, i32 0, i32 3
  %60 = load i8, i8* %59, align 1
  %61 = load i64, i64* %right_padding, align 8
  %62 = call fastcc i16 @"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write).writeByteNTimes"(%"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* %2, i8 %60, i64 %61)
  store i16 %62, i16* %8, align 2
  %63 = icmp ne i16 %62, 0
  br i1 %63, label %ErrRetReturn10, label %ErrRetContinue16

ErrRetReturn10:                                   ; preds = %ErrRetContinue9
  %64 = load i16, i16* %8, align 2
  store i16 %64, i16* %result, align 2
  ret i16 %64

SwitchProng11:                                    ; preds = %EndIf3
  %65 = getelementptr inbounds %std.fmt.FormatOptions, %std.fmt.FormatOptions* %1, i32 0, i32 3
  %66 = load i8, i8* %65, align 1
  %67 = load i64, i64* %padding, align 8
  %68 = call fastcc i16 @"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write).writeByteNTimes"(%"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* %2, i8 %66, i64 %67)
  store i16 %68, i16* %9, align 2
  %69 = icmp ne i16 %68, 0
  br i1 %69, label %ErrRetReturn12, label %ErrRetContinue13

ErrRetReturn12:                                   ; preds = %SwitchProng11
  %70 = load i16, i16* %9, align 2
  store i16 %70, i16* %result, align 2
  ret i16 %70

ErrRetContinue13:                                 ; preds = %SwitchProng11
  %71 = call fastcc i16 @"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write).writeAll"(%"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* %2, %"[]u8"* %0)
  store i16 %71, i16* %10, align 2
  %72 = icmp ne i16 %71, 0
  br i1 %72, label %ErrRetReturn14, label %ErrRetContinue17

ErrRetReturn14:                                   ; preds = %ErrRetContinue13
  %73 = load i16, i16* %10, align 2
  store i16 %73, i16* %result, align 2
  ret i16 %73

SwitchElse:                                       ; preds = %EndIf3
  unreachable

ErrRetContinue15:                                 ; preds = %ErrRetContinue
  br label %SwitchEnd

ErrRetContinue16:                                 ; preds = %ErrRetContinue9
  br label %SwitchEnd

ErrRetContinue17:                                 ; preds = %ErrRetContinue13
  br label %SwitchEnd

OptionalElse:                                     ; preds = %Entry
  %74 = call fastcc i16 @"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write).writeAll"(%"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* %2, %"[]u8"* %0)
  store i16 %74, i16* %11, align 2
  %75 = icmp ne i16 %74, 0
  br i1 %75, label %ErrRetReturn18, label %ErrRetContinue19

ErrRetReturn18:                                   ; preds = %OptionalElse
  %76 = load i16, i16* %11, align 2
  store i16 %76, i16* %result, align 2
  ret i16 %76

SwitchEnd:                                        ; preds = %ErrRetContinue17, %ErrRetContinue16, %ErrRetContinue15
  br label %OptionalEndIf

ErrRetContinue19:                                 ; preds = %OptionalElse
  br label %OptionalEndIf

OptionalEndIf:                                    ; preds = %ErrRetContinue19, %SwitchEnd
  store i16 0, i16* %result, align 2
  ret i16 0
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write).writeByteNTimes"(%"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* nonnull readonly align 8 %0, i8 %1, i64 %2) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %bytes = alloca [256 x i8], align 1
  %3 = alloca [256 x i8]*, align 8
  %4 = alloca i8, align 1
  %5 = alloca %"[]u8", align 8
  %remaining = alloca i64, align 8
  %6 = alloca i64, align 8
  %to_write = alloca i64, align 8
  %7 = alloca %"[]u8", align 8
  %8 = alloca i16, align 2
  %byte = alloca i8, align 1
  %n = alloca i64, align 8
  store i8 %1, i8* %byte, align 1
  store i64 %2, i64* %n, align 8
  %9 = getelementptr inbounds [256 x i8], [256 x i8]* %bytes, i64 0, i64 0
  %10 = bitcast i8* %9 to [256 x i8]*
  store [256 x i8]* %10, [256 x i8]** %3, align 8
  %11 = load i8, i8* %byte, align 1
  store i8 %11, i8* %4, align 1
  %12 = getelementptr inbounds %"[]u8", %"[]u8"* %5, i32 0, i32 0
  %13 = getelementptr inbounds [256 x i8], [256 x i8]* %10, i64 0, i64 0
  store i8* %13, i8** %12, align 8
  %14 = getelementptr inbounds %"[]u8", %"[]u8"* %5, i32 0, i32 1
  store i64 256, i64* %14, align 8
  call fastcc void @std.mem.set(%"[]u8"* %5, i8 %11)
  %15 = load i64, i64* %n, align 8
  store i64 %15, i64* %remaining, align 8
  br label %WhileCond

WhileCond:                                        ; preds = %ErrRetContinue, %Entry
  %16 = load i64, i64* %remaining, align 8
  %17 = icmp ugt i64 %16, 0
  br i1 %17, label %WhileBody, label %WhileEnd

WhileBody:                                        ; preds = %WhileCond
  %18 = load i64, i64* %remaining, align 8
  store i64 %18, i64* %6, align 8
  %19 = call fastcc i64 @std.math.min.30(i64 %18, i64 256)
  store i64 %19, i64* %to_write, align 8
  %20 = load i64, i64* %to_write, align 8
  %21 = getelementptr inbounds [256 x i8], [256 x i8]* %bytes, i64 0, i64 0
  %22 = sub nuw i64 %20, 0
  %23 = getelementptr inbounds %"[]u8", %"[]u8"* %7, i32 0, i32 0
  store i8* %21, i8** %23, align 8
  %24 = getelementptr inbounds %"[]u8", %"[]u8"* %7, i32 0, i32 1
  store i64 %22, i64* %24, align 8
  %25 = call fastcc i16 @"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write).writeAll"(%"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* %0, %"[]u8"* %7)
  store i16 %25, i16* %8, align 2
  %26 = icmp ne i16 %25, 0
  br i1 %26, label %ErrRetReturn, label %ErrRetContinue

ErrRetReturn:                                     ; preds = %WhileBody
  %27 = load i16, i16* %8, align 2
  store i16 %27, i16* %result, align 2
  ret i16 %27

ErrRetContinue:                                   ; preds = %WhileBody
  %28 = load i64, i64* %remaining, align 8
  %29 = load i64, i64* %to_write, align 8
  %30 = sub nuw i64 %28, %29
  store i64 %30, i64* %remaining, align 8
  br label %WhileCond

WhileEnd:                                         ; preds = %WhileCond
  store i16 0, i16* %result, align 2
  ret i16 0
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.formatType.163(%"[]u8"* nonnull readonly align 8 %0, %std.fmt.FormatOptions* nonnull readonly align 8 %1, %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* nonnull readonly align 8 %2, i64 %3) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %4 = alloca %std.fmt.FormatOptions, align 8
  %5 = alloca %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)", align 8
  %max_depth = alloca i64, align 8
  store i64 %3, i64* %max_depth, align 8
  %6 = load i64, i64* %max_depth, align 8
  %7 = icmp eq i64 %6, 0
  br i1 %7, label %Then, label %Else

Then:                                             ; preds = %Entry
  %8 = call fastcc i16 @"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write).writeAll"(%"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* %2, %"[]u8"* @357)
  store i16 %8, i16* %result, align 2
  %9 = load i16, i16* %result, align 2
  ret i16 %9

Else:                                             ; preds = %Entry
  br label %EndIf

EndIf:                                            ; preds = %Else
  %10 = bitcast %std.fmt.FormatOptions* %1 to i8*
  %11 = bitcast %std.fmt.FormatOptions* %4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %11, i8* align 8 %10, i64 40, i1 false)
  %12 = bitcast %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* %2 to i8*
  %13 = bitcast %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* %5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %13, i8* align 8 %12, i64 8, i1 false)
  %14 = call fastcc i16 @std.fmt.formatText.164(%"[]u8"* %0, %std.fmt.FormatOptions* %1, %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* %2)
  store i16 %14, i16* %result, align 2
  %15 = load i16, i16* %result, align 2
  ret i16 %15
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.formatText.164(%"[]u8"* nonnull readonly align 8 %0, %std.fmt.FormatOptions* nonnull readonly align 8 %1, %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* nonnull readonly align 8 %2) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %3 = alloca %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)", align 8
  %4 = bitcast %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* %2 to i8*
  %5 = bitcast %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* %3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %5, i8* align 8 %4, i64 8, i1 false)
  %6 = call fastcc i16 @std.fmt.formatBuf.162(%"[]u8"* %0, %std.fmt.FormatOptions* %1, %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* %2)
  store i16 %6, i16* %result, align 2
  %7 = load i16, i16* %result, align 2
  ret i16 %7
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.formatType.165(i64 %0, %std.fmt.FormatOptions* nonnull readonly align 8 %1, %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* nonnull readonly align 8 %2, i64 %3) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %4 = alloca i64, align 8
  %5 = alloca %std.fmt.FormatOptions, align 8
  %6 = alloca %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)", align 8
  %value = alloca i64, align 8
  %max_depth = alloca i64, align 8
  store i64 %0, i64* %value, align 8
  store i64 %3, i64* %max_depth, align 8
  %7 = load i64, i64* %value, align 8
  store i64 %7, i64* %4, align 8
  %8 = bitcast %std.fmt.FormatOptions* %1 to i8*
  %9 = bitcast %std.fmt.FormatOptions* %5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %9, i8* align 8 %8, i64 40, i1 false)
  %10 = bitcast %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* %2 to i8*
  %11 = bitcast %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* %6 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %11, i8* align 8 %10, i64 8, i1 false)
  %12 = call fastcc i16 @std.fmt.formatValue.167(i64 %7, %std.fmt.FormatOptions* %1, %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* %2)
  store i16 %12, i16* %result, align 2
  %13 = load i16, i16* %result, align 2
  ret i16 %13
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.formatType.166(i64 %0, %std.fmt.FormatOptions* nonnull readonly align 8 %1, %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* nonnull readonly align 8 %2, i64 %3) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %4 = alloca i64, align 8
  %5 = alloca %std.fmt.FormatOptions, align 8
  %6 = alloca %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)", align 8
  %value = alloca i64, align 8
  %max_depth = alloca i64, align 8
  store i64 %0, i64* %value, align 8
  store i64 %3, i64* %max_depth, align 8
  %7 = load i64, i64* %value, align 8
  store i64 %7, i64* %4, align 8
  %8 = bitcast %std.fmt.FormatOptions* %1 to i8*
  %9 = bitcast %std.fmt.FormatOptions* %5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %9, i8* align 8 %8, i64 40, i1 false)
  %10 = bitcast %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* %2 to i8*
  %11 = bitcast %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* %6 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %11, i8* align 8 %10, i64 8, i1 false)
  %12 = call fastcc i16 @std.fmt.formatValue.168(i64 %7, %std.fmt.FormatOptions* %1, %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* %2)
  store i16 %12, i16* %result, align 2
  %13 = load i16, i16* %result, align 2
  ret i16 %13
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.formatValue.167(i64 %0, %std.fmt.FormatOptions* nonnull readonly align 8 %1, %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* nonnull readonly align 8 %2) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %3 = alloca i64, align 8
  %4 = alloca %std.fmt.FormatOptions, align 8
  %5 = alloca %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)", align 8
  %value = alloca i64, align 8
  store i64 %0, i64* %value, align 8
  %6 = load i64, i64* %value, align 8
  store i64 %6, i64* %3, align 8
  %7 = bitcast %std.fmt.FormatOptions* %1 to i8*
  %8 = bitcast %std.fmt.FormatOptions* %4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %8, i8* align 8 %7, i64 40, i1 false)
  %9 = bitcast %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* %2 to i8*
  %10 = bitcast %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* %5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %10, i8* align 8 %9, i64 8, i1 false)
  %11 = call fastcc i16 @std.fmt.formatIntValue.172(i64 %6, %std.fmt.FormatOptions* %1, %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* %2)
  store i16 %11, i16* %result, align 2
  %12 = load i16, i16* %result, align 2
  ret i16 %12
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.formatValue.168(i64 %0, %std.fmt.FormatOptions* nonnull readonly align 8 %1, %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* nonnull readonly align 8 %2) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %3 = alloca i64, align 8
  %4 = alloca %std.fmt.FormatOptions, align 8
  %5 = alloca %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)", align 8
  %value = alloca i64, align 8
  store i64 %0, i64* %value, align 8
  %6 = load i64, i64* %value, align 8
  store i64 %6, i64* %3, align 8
  %7 = bitcast %std.fmt.FormatOptions* %1 to i8*
  %8 = bitcast %std.fmt.FormatOptions* %4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %8, i8* align 8 %7, i64 40, i1 false)
  %9 = bitcast %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* %2 to i8*
  %10 = bitcast %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* %5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %10, i8* align 8 %9, i64 8, i1 false)
  %11 = call fastcc i16 @std.fmt.formatIntValue.173(i64 %6, %std.fmt.FormatOptions* %1, %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* %2)
  store i16 %11, i16* %result, align 2
  %12 = load i16, i16* %result, align 2
  ret i16 %12
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.formatType.169(i64 %0, %std.fmt.FormatOptions* nonnull readonly align 8 %1, %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* nonnull readonly align 8 %2, i64 %3) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %4 = alloca i64, align 8
  %5 = alloca %std.fmt.FormatOptions, align 8
  %6 = alloca %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)", align 8
  %value = alloca i64, align 8
  %max_depth = alloca i64, align 8
  store i64 %0, i64* %value, align 8
  store i64 %3, i64* %max_depth, align 8
  %7 = load i64, i64* %value, align 8
  store i64 %7, i64* %4, align 8
  %8 = bitcast %std.fmt.FormatOptions* %1 to i8*
  %9 = bitcast %std.fmt.FormatOptions* %5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %9, i8* align 8 %8, i64 40, i1 false)
  %10 = bitcast %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* %2 to i8*
  %11 = bitcast %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* %6 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %11, i8* align 8 %10, i64 8, i1 false)
  %12 = call fastcc i16 @std.fmt.formatValue.170(i64 %7, %std.fmt.FormatOptions* %1, %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* %2)
  store i16 %12, i16* %result, align 2
  %13 = load i16, i16* %result, align 2
  ret i16 %13
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.formatValue.170(i64 %0, %std.fmt.FormatOptions* nonnull readonly align 8 %1, %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* nonnull readonly align 8 %2) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %3 = alloca i64, align 8
  %4 = alloca %std.fmt.FormatOptions, align 8
  %5 = alloca %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)", align 8
  %value = alloca i64, align 8
  store i64 %0, i64* %value, align 8
  %6 = load i64, i64* %value, align 8
  store i64 %6, i64* %3, align 8
  %7 = bitcast %std.fmt.FormatOptions* %1 to i8*
  %8 = bitcast %std.fmt.FormatOptions* %4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %8, i8* align 8 %7, i64 40, i1 false)
  %9 = bitcast %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* %2 to i8*
  %10 = bitcast %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* %5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %10, i8* align 8 %9, i64 8, i1 false)
  %11 = call fastcc i16 @std.fmt.formatIntValue.174(i64 %6, %std.fmt.FormatOptions* %1, %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* %2)
  store i16 %11, i16* %result, align 2
  %12 = load i16, i16* %result, align 2
  ret i16 %12
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i64 @std.mem.readIntNative.171([8 x i8]* nonnull readonly align 1 %0) unnamed_addr #1 {
Entry:
  %result = alloca i64, align 8
  %bytes = alloca [8 x i8]*, align 8
  store [8 x i8]* %0, [8 x i8]** %bytes, align 8
  %1 = load [8 x i8]*, [8 x i8]** %bytes, align 8
  %2 = bitcast [8 x i8]* %1 to i64*
  %3 = load i64, i64* %2, align 1
  store i64 %3, i64* %result, align 8
  %4 = load i64, i64* %result, align 8
  ret i64 %4
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i1 @std.target.Arch.endian(i6 %0) unnamed_addr #1 {
Entry:
  %result = alloca i1, align 1
  %arch = alloca i6, align 1
  store i6 %0, i6* %arch, align 1
  %1 = load i6, i6* %arch, align 1
  switch i6 %1, label %SwitchElse [
    i6 6, label %SwitchProng
    i6 0, label %SwitchProng
    i6 4, label %SwitchProng
    i6 2, label %SwitchProng
    i6 22, label %SwitchProng
    i6 -24, label %SwitchProng
    i6 -23, label %SwitchProng
    i6 7, label %SwitchProng
    i6 9, label %SwitchProng
    i6 10, label %SwitchProng
    i6 -22, label %SwitchProng
    i6 -21, label %SwitchProng
    i6 -18, label %SwitchProng
    i6 -26, label %SwitchProng
    i6 -25, label %SwitchProng
    i6 13, label %SwitchProng
    i6 15, label %SwitchProng
    i6 16, label %SwitchProng
    i6 -28, label %SwitchProng
    i6 -27, label %SwitchProng
    i6 27, label %SwitchProng
    i6 30, label %SwitchProng
    i6 18, label %SwitchProng
    i6 20, label %SwitchProng
    i6 21, label %SwitchProng
    i6 23, label %SwitchProng
    i6 24, label %SwitchProng
    i6 -31, label %SwitchProng
    i6 -30, label %SwitchProng
    i6 -15, label %SwitchProng
    i6 -14, label %SwitchProng
    i6 -29, label %SwitchProng
    i6 31, label %SwitchProng
    i6 -20, label %SwitchProng
    i6 -19, label %SwitchProng
    i6 -13, label %SwitchProng
    i6 -12, label %SwitchProng
    i6 -17, label %SwitchProng
    i6 -11, label %SwitchProng
    i6 -10, label %SwitchProng
    i6 -9, label %SwitchProng
    i6 -8, label %SwitchProng
    i6 5, label %SwitchProng1
    i6 1, label %SwitchProng1
    i6 3, label %SwitchProng1
    i6 8, label %SwitchProng1
    i6 11, label %SwitchProng1
    i6 12, label %SwitchProng1
    i6 14, label %SwitchProng1
    i6 17, label %SwitchProng1
    i6 19, label %SwitchProng1
    i6 -32, label %SwitchProng1
    i6 25, label %SwitchProng1
    i6 26, label %SwitchProng1
    i6 29, label %SwitchProng1
    i6 -16, label %SwitchProng1
    i6 28, label %SwitchProng1
  ]

SwitchProng:                                      ; preds = %Entry, %Entry, %Entry, %Entry, %Entry, %Entry, %Entry, %Entry, %Entry, %Entry, %Entry, %Entry, %Entry, %Entry, %Entry, %Entry, %Entry, %Entry, %Entry, %Entry, %Entry, %Entry, %Entry, %Entry, %Entry, %Entry, %Entry, %Entry, %Entry, %Entry, %Entry, %Entry, %Entry, %Entry, %Entry, %Entry, %Entry, %Entry, %Entry, %Entry, %Entry, %Entry
  store i1 true, i1* %result, align 1
  br label %SwitchEnd

SwitchProng1:                                     ; preds = %Entry, %Entry, %Entry, %Entry, %Entry, %Entry, %Entry, %Entry, %Entry, %Entry, %Entry, %Entry, %Entry, %Entry, %Entry
  store i1 false, i1* %result, align 1
  br label %SwitchEnd

SwitchElse:                                       ; preds = %Entry
  unreachable

SwitchEnd:                                        ; preds = %SwitchProng1, %SwitchProng
  %2 = load i1, i1* %result, align 1
  ret i1 %2
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.formatIntValue.172(i64 %0, %std.fmt.FormatOptions* nonnull readonly align 8 %1, %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* nonnull readonly align 8 %2) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %int_value = alloca i64, align 8
  %3 = alloca i64, align 8
  %4 = alloca %std.fmt.FormatOptions, align 8
  %5 = alloca %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)", align 8
  %value = alloca i64, align 8
  store i64 %0, i64* %value, align 8
  %6 = load i64, i64* %value, align 8
  store i64 %6, i64* %int_value, align 8
  %7 = load i64, i64* %int_value, align 8
  store i64 %7, i64* %3, align 8
  %8 = bitcast %std.fmt.FormatOptions* %1 to i8*
  %9 = bitcast %std.fmt.FormatOptions* %4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %9, i8* align 8 %8, i64 40, i1 false)
  %10 = bitcast %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* %2 to i8*
  %11 = bitcast %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* %5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %11, i8* align 8 %10, i64 8, i1 false)
  %12 = call fastcc i16 @std.fmt.formatInt.161(i64 %7, i8 10, i1 false, %std.fmt.FormatOptions* %1, %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* %2)
  store i16 %12, i16* %result, align 2
  %13 = load i16, i16* %result, align 2
  ret i16 %13
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.formatIntValue.173(i64 %0, %std.fmt.FormatOptions* nonnull readonly align 8 %1, %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* nonnull readonly align 8 %2) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %int_value = alloca i64, align 8
  %3 = alloca i64, align 8
  %4 = alloca %std.fmt.FormatOptions, align 8
  %5 = alloca %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)", align 8
  %value = alloca i64, align 8
  store i64 %0, i64* %value, align 8
  %6 = load i64, i64* %value, align 8
  store i64 %6, i64* %int_value, align 8
  %7 = load i64, i64* %int_value, align 8
  store i64 %7, i64* %3, align 8
  %8 = bitcast %std.fmt.FormatOptions* %1 to i8*
  %9 = bitcast %std.fmt.FormatOptions* %4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %9, i8* align 8 %8, i64 40, i1 false)
  %10 = bitcast %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* %2 to i8*
  %11 = bitcast %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* %5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %11, i8* align 8 %10, i64 8, i1 false)
  %12 = call fastcc i16 @std.fmt.formatInt.161(i64 %7, i8 10, i1 false, %std.fmt.FormatOptions* %1, %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* %2)
  store i16 %12, i16* %result, align 2
  %13 = load i16, i16* %result, align 2
  ret i16 %13
}

; Function Attrs: minsize nobuiltin nounwind optsize
define internal fastcc i16 @std.fmt.formatIntValue.174(i64 %0, %std.fmt.FormatOptions* nonnull readonly align 8 %1, %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* nonnull readonly align 8 %2) unnamed_addr #1 {
Entry:
  %result = alloca i16, align 2
  %int_value = alloca i64, align 8
  %3 = alloca i64, align 8
  %4 = alloca %std.fmt.FormatOptions, align 8
  %5 = alloca %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)", align 8
  %value = alloca i64, align 8
  store i64 %0, i64* %value, align 8
  %6 = load i64, i64* %value, align 8
  store i64 %6, i64* %int_value, align 8
  %7 = load i64, i64* %int_value, align 8
  store i64 %7, i64* %3, align 8
  %8 = bitcast %std.fmt.FormatOptions* %1 to i8*
  %9 = bitcast %std.fmt.FormatOptions* %4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %9, i8* align 8 %8, i64 40, i1 false)
  %10 = bitcast %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* %2 to i8*
  %11 = bitcast %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* %5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %11, i8* align 8 %10, i64 8, i1 false)
  %12 = call fastcc i16 @std.fmt.formatInt.161(i64 %7, i8 10, i1 false, %std.fmt.FormatOptions* %1, %"std.io.writer.Writer(*std.io.fixed_buffer_stream.FixedBufferStream([]u8),std.io.fixed_buffer_stream.WriteError,std.io.fixed_buffer_stream.FixedBufferStream([]u8).write)"* %2)
  store i16 %12, i16* %result, align 2
  %13 = load i16, i16* %result, align 2
  ret i16 %13
}

attributes #0 = { cold minsize nobuiltin noreturn nounwind optsize "target-cpu"="skylake" "target-features"="-16bit-mode,-32bit-mode,-3dnow,-3dnowa,+64bit,+adx,+aes,-amx-bf16,-amx-int8,-amx-tile,+avx,+avx2,-avx512bf16,-avx512bitalg,-avx512bw,-avx512cd,-avx512dq,-avx512er,-avx512f,-avx512ifma,-avx512pf,-avx512vbmi,-avx512vbmi2,-avx512vl,-avx512vnni,-avx512vp2intersect,-avx512vpopcntdq,-avxvnni,+bmi,+bmi2,-branchfusion,-cldemote,+clflushopt,-clwb,-clzero,+cmov,+cx16,+cx8,-enqcmd,+ermsb,+f16c,-false-deps-lzcnt-tzcnt,+false-deps-popcnt,-fast-11bytenop,+fast-15bytenop,-fast-7bytenop,-fast-bextr,+fast-gather,-fast-hops,-fast-lzcnt,-fast-movbe,+fast-scalar-fsqrt,-fast-scalar-shift-masks,+fast-shld-rotate,+fast-variable-crosslane-shuffle,+fast-variable-perlane-shuffle,+fast-vector-fsqrt,-fast-vector-shift-masks,+fma,-fma4,+fsgsbase,-fsrm,+fxsr,-gfni,-hreset,-idivl-to-divb,+idivq-to-divl,+invpcid,-kl,-lea-sp,-lea-uses-ag,-lvi-cfi,-lvi-load-hardening,-lwp,+lzcnt,+macrofusion,+mmx,+movbe,-movdir64b,-movdiri,-mwaitx,+nopl,-pad-short-functions,+pclmul,-pconfig,-pku,+popcnt,-prefer-128-bit,-prefer-256-bit,-prefer-mask-registers,-prefetchwt1,+prfchw,-ptwrite,-rdpid,+rdrnd,+rdseed,-retpoline,-retpoline-external-thunk,-retpoline-indirect-branches,-retpoline-indirect-calls,+rtm,+sahf,-serialize,-seses,+sgx,-sha,-shstk,+slow-3ops-lea,-slow-incdec,-slow-lea,-slow-pmaddwd,-slow-pmulld,-slow-shld,-slow-two-mem-ops,-slow-unaligned-mem-16,-slow-unaligned-mem-32,-soft-float,+sse,+sse2,+sse3,+sse4.1,+sse4.2,-sse4a,-sse-unaligned-mem,+ssse3,-tbm,-tsxldtrk,-uintr,-use-aa,-use-glm-div-sqrt-costs,-vaes,-vpclmulqdq,+vzeroupper,-waitpkg,-wbnoinvd,-widekl,+x87,-xop,+xsave,+xsavec,+xsaveopt,+xsaves" }
attributes #1 = { minsize nobuiltin nounwind optsize "target-cpu"="skylake" "target-features"="-16bit-mode,-32bit-mode,-3dnow,-3dnowa,+64bit,+adx,+aes,-amx-bf16,-amx-int8,-amx-tile,+avx,+avx2,-avx512bf16,-avx512bitalg,-avx512bw,-avx512cd,-avx512dq,-avx512er,-avx512f,-avx512ifma,-avx512pf,-avx512vbmi,-avx512vbmi2,-avx512vl,-avx512vnni,-avx512vp2intersect,-avx512vpopcntdq,-avxvnni,+bmi,+bmi2,-branchfusion,-cldemote,+clflushopt,-clwb,-clzero,+cmov,+cx16,+cx8,-enqcmd,+ermsb,+f16c,-false-deps-lzcnt-tzcnt,+false-deps-popcnt,-fast-11bytenop,+fast-15bytenop,-fast-7bytenop,-fast-bextr,+fast-gather,-fast-hops,-fast-lzcnt,-fast-movbe,+fast-scalar-fsqrt,-fast-scalar-shift-masks,+fast-shld-rotate,+fast-variable-crosslane-shuffle,+fast-variable-perlane-shuffle,+fast-vector-fsqrt,-fast-vector-shift-masks,+fma,-fma4,+fsgsbase,-fsrm,+fxsr,-gfni,-hreset,-idivl-to-divb,+idivq-to-divl,+invpcid,-kl,-lea-sp,-lea-uses-ag,-lvi-cfi,-lvi-load-hardening,-lwp,+lzcnt,+macrofusion,+mmx,+movbe,-movdir64b,-movdiri,-mwaitx,+nopl,-pad-short-functions,+pclmul,-pconfig,-pku,+popcnt,-prefer-128-bit,-prefer-256-bit,-prefer-mask-registers,-prefetchwt1,+prfchw,-ptwrite,-rdpid,+rdrnd,+rdseed,-retpoline,-retpoline-external-thunk,-retpoline-indirect-branches,-retpoline-indirect-calls,+rtm,+sahf,-serialize,-seses,+sgx,-sha,-shstk,+slow-3ops-lea,-slow-incdec,-slow-lea,-slow-pmaddwd,-slow-pmulld,-slow-shld,-slow-two-mem-ops,-slow-unaligned-mem-16,-slow-unaligned-mem-32,-soft-float,+sse,+sse2,+sse3,+sse4.1,+sse4.2,-sse4a,-sse-unaligned-mem,+ssse3,-tbm,-tsxldtrk,-uintr,-use-aa,-use-glm-div-sqrt-costs,-vaes,-vpclmulqdq,+vzeroupper,-waitpkg,-wbnoinvd,-widekl,+x87,-xop,+xsave,+xsavec,+xsaveopt,+xsaves" }
attributes #2 = { minsize nobuiltin noreturn nounwind optsize "target-cpu"="skylake" "target-features"="-16bit-mode,-32bit-mode,-3dnow,-3dnowa,+64bit,+adx,+aes,-amx-bf16,-amx-int8,-amx-tile,+avx,+avx2,-avx512bf16,-avx512bitalg,-avx512bw,-avx512cd,-avx512dq,-avx512er,-avx512f,-avx512ifma,-avx512pf,-avx512vbmi,-avx512vbmi2,-avx512vl,-avx512vnni,-avx512vp2intersect,-avx512vpopcntdq,-avxvnni,+bmi,+bmi2,-branchfusion,-cldemote,+clflushopt,-clwb,-clzero,+cmov,+cx16,+cx8,-enqcmd,+ermsb,+f16c,-false-deps-lzcnt-tzcnt,+false-deps-popcnt,-fast-11bytenop,+fast-15bytenop,-fast-7bytenop,-fast-bextr,+fast-gather,-fast-hops,-fast-lzcnt,-fast-movbe,+fast-scalar-fsqrt,-fast-scalar-shift-masks,+fast-shld-rotate,+fast-variable-crosslane-shuffle,+fast-variable-perlane-shuffle,+fast-vector-fsqrt,-fast-vector-shift-masks,+fma,-fma4,+fsgsbase,-fsrm,+fxsr,-gfni,-hreset,-idivl-to-divb,+idivq-to-divl,+invpcid,-kl,-lea-sp,-lea-uses-ag,-lvi-cfi,-lvi-load-hardening,-lwp,+lzcnt,+macrofusion,+mmx,+movbe,-movdir64b,-movdiri,-mwaitx,+nopl,-pad-short-functions,+pclmul,-pconfig,-pku,+popcnt,-prefer-128-bit,-prefer-256-bit,-prefer-mask-registers,-prefetchwt1,+prfchw,-ptwrite,-rdpid,+rdrnd,+rdseed,-retpoline,-retpoline-external-thunk,-retpoline-indirect-branches,-retpoline-indirect-calls,+rtm,+sahf,-serialize,-seses,+sgx,-sha,-shstk,+slow-3ops-lea,-slow-incdec,-slow-lea,-slow-pmaddwd,-slow-pmulld,-slow-shld,-slow-two-mem-ops,-slow-unaligned-mem-16,-slow-unaligned-mem-32,-soft-float,+sse,+sse2,+sse3,+sse4.1,+sse4.2,-sse4a,-sse-unaligned-mem,+ssse3,-tbm,-tsxldtrk,-uintr,-use-aa,-use-glm-div-sqrt-costs,-vaes,-vpclmulqdq,+vzeroupper,-waitpkg,-wbnoinvd,-widekl,+x87,-xop,+xsave,+xsavec,+xsaveopt,+xsaves" }
attributes #3 = { nofree nosync nounwind readnone willreturn }
attributes #4 = { argmemonly nofree nounwind willreturn }
attributes #5 = { minsize naked nobuiltin noreturn nounwind optsize "target-cpu"="skylake" "target-features"="-16bit-mode,-32bit-mode,-3dnow,-3dnowa,+64bit,+adx,+aes,-amx-bf16,-amx-int8,-amx-tile,+avx,+avx2,-avx512bf16,-avx512bitalg,-avx512bw,-avx512cd,-avx512dq,-avx512er,-avx512f,-avx512ifma,-avx512pf,-avx512vbmi,-avx512vbmi2,-avx512vl,-avx512vnni,-avx512vp2intersect,-avx512vpopcntdq,-avxvnni,+bmi,+bmi2,-branchfusion,-cldemote,+clflushopt,-clwb,-clzero,+cmov,+cx16,+cx8,-enqcmd,+ermsb,+f16c,-false-deps-lzcnt-tzcnt,+false-deps-popcnt,-fast-11bytenop,+fast-15bytenop,-fast-7bytenop,-fast-bextr,+fast-gather,-fast-hops,-fast-lzcnt,-fast-movbe,+fast-scalar-fsqrt,-fast-scalar-shift-masks,+fast-shld-rotate,+fast-variable-crosslane-shuffle,+fast-variable-perlane-shuffle,+fast-vector-fsqrt,-fast-vector-shift-masks,+fma,-fma4,+fsgsbase,-fsrm,+fxsr,-gfni,-hreset,-idivl-to-divb,+idivq-to-divl,+invpcid,-kl,-lea-sp,-lea-uses-ag,-lvi-cfi,-lvi-load-hardening,-lwp,+lzcnt,+macrofusion,+mmx,+movbe,-movdir64b,-movdiri,-mwaitx,+nopl,-pad-short-functions,+pclmul,-pconfig,-pku,+popcnt,-prefer-128-bit,-prefer-256-bit,-prefer-mask-registers,-prefetchwt1,+prfchw,-ptwrite,-rdpid,+rdrnd,+rdseed,-retpoline,-retpoline-external-thunk,-retpoline-indirect-branches,-retpoline-indirect-calls,+rtm,+sahf,-serialize,-seses,+sgx,-sha,-shstk,+slow-3ops-lea,-slow-incdec,-slow-lea,-slow-pmaddwd,-slow-pmulld,-slow-shld,-slow-two-mem-ops,-slow-unaligned-mem-16,-slow-unaligned-mem-32,-soft-float,+sse,+sse2,+sse3,+sse4.1,+sse4.2,-sse4a,-sse-unaligned-mem,+ssse3,-tbm,-tsxldtrk,-uintr,-use-aa,-use-glm-div-sqrt-costs,-vaes,-vpclmulqdq,+vzeroupper,-waitpkg,-wbnoinvd,-widekl,+x87,-xop,+xsave,+xsavec,+xsaveopt,+xsaves" }
attributes #6 = { minsize nobuiltin noinline noreturn nounwind optsize alignstack=16 "target-cpu"="skylake" "target-features"="-16bit-mode,-32bit-mode,-3dnow,-3dnowa,+64bit,+adx,+aes,-amx-bf16,-amx-int8,-amx-tile,+avx,+avx2,-avx512bf16,-avx512bitalg,-avx512bw,-avx512cd,-avx512dq,-avx512er,-avx512f,-avx512ifma,-avx512pf,-avx512vbmi,-avx512vbmi2,-avx512vl,-avx512vnni,-avx512vp2intersect,-avx512vpopcntdq,-avxvnni,+bmi,+bmi2,-branchfusion,-cldemote,+clflushopt,-clwb,-clzero,+cmov,+cx16,+cx8,-enqcmd,+ermsb,+f16c,-false-deps-lzcnt-tzcnt,+false-deps-popcnt,-fast-11bytenop,+fast-15bytenop,-fast-7bytenop,-fast-bextr,+fast-gather,-fast-hops,-fast-lzcnt,-fast-movbe,+fast-scalar-fsqrt,-fast-scalar-shift-masks,+fast-shld-rotate,+fast-variable-crosslane-shuffle,+fast-variable-perlane-shuffle,+fast-vector-fsqrt,-fast-vector-shift-masks,+fma,-fma4,+fsgsbase,-fsrm,+fxsr,-gfni,-hreset,-idivl-to-divb,+idivq-to-divl,+invpcid,-kl,-lea-sp,-lea-uses-ag,-lvi-cfi,-lvi-load-hardening,-lwp,+lzcnt,+macrofusion,+mmx,+movbe,-movdir64b,-movdiri,-mwaitx,+nopl,-pad-short-functions,+pclmul,-pconfig,-pku,+popcnt,-prefer-128-bit,-prefer-256-bit,-prefer-mask-registers,-prefetchwt1,+prfchw,-ptwrite,-rdpid,+rdrnd,+rdseed,-retpoline,-retpoline-external-thunk,-retpoline-indirect-branches,-retpoline-indirect-calls,+rtm,+sahf,-serialize,-seses,+sgx,-sha,-shstk,+slow-3ops-lea,-slow-incdec,-slow-lea,-slow-pmaddwd,-slow-pmulld,-slow-shld,-slow-two-mem-ops,-slow-unaligned-mem-16,-slow-unaligned-mem-32,-soft-float,+sse,+sse2,+sse3,+sse4.1,+sse4.2,-sse4a,-sse-unaligned-mem,+ssse3,-tbm,-tsxldtrk,-uintr,-use-aa,-use-glm-div-sqrt-costs,-vaes,-vpclmulqdq,+vzeroupper,-waitpkg,-wbnoinvd,-widekl,+x87,-xop,+xsave,+xsavec,+xsaveopt,+xsaves" }
attributes #7 = { alwaysinline minsize nobuiltin nounwind optsize "target-cpu"="skylake" "target-features"="-16bit-mode,-32bit-mode,-3dnow,-3dnowa,+64bit,+adx,+aes,-amx-bf16,-amx-int8,-amx-tile,+avx,+avx2,-avx512bf16,-avx512bitalg,-avx512bw,-avx512cd,-avx512dq,-avx512er,-avx512f,-avx512ifma,-avx512pf,-avx512vbmi,-avx512vbmi2,-avx512vl,-avx512vnni,-avx512vp2intersect,-avx512vpopcntdq,-avxvnni,+bmi,+bmi2,-branchfusion,-cldemote,+clflushopt,-clwb,-clzero,+cmov,+cx16,+cx8,-enqcmd,+ermsb,+f16c,-false-deps-lzcnt-tzcnt,+false-deps-popcnt,-fast-11bytenop,+fast-15bytenop,-fast-7bytenop,-fast-bextr,+fast-gather,-fast-hops,-fast-lzcnt,-fast-movbe,+fast-scalar-fsqrt,-fast-scalar-shift-masks,+fast-shld-rotate,+fast-variable-crosslane-shuffle,+fast-variable-perlane-shuffle,+fast-vector-fsqrt,-fast-vector-shift-masks,+fma,-fma4,+fsgsbase,-fsrm,+fxsr,-gfni,-hreset,-idivl-to-divb,+idivq-to-divl,+invpcid,-kl,-lea-sp,-lea-uses-ag,-lvi-cfi,-lvi-load-hardening,-lwp,+lzcnt,+macrofusion,+mmx,+movbe,-movdir64b,-movdiri,-mwaitx,+nopl,-pad-short-functions,+pclmul,-pconfig,-pku,+popcnt,-prefer-128-bit,-prefer-256-bit,-prefer-mask-registers,-prefetchwt1,+prfchw,-ptwrite,-rdpid,+rdrnd,+rdseed,-retpoline,-retpoline-external-thunk,-retpoline-indirect-branches,-retpoline-indirect-calls,+rtm,+sahf,-serialize,-seses,+sgx,-sha,-shstk,+slow-3ops-lea,-slow-incdec,-slow-lea,-slow-pmaddwd,-slow-pmulld,-slow-shld,-slow-two-mem-ops,-slow-unaligned-mem-16,-slow-unaligned-mem-32,-soft-float,+sse,+sse2,+sse3,+sse4.1,+sse4.2,-sse4a,-sse-unaligned-mem,+ssse3,-tbm,-tsxldtrk,-uintr,-use-aa,-use-glm-div-sqrt-costs,-vaes,-vpclmulqdq,+vzeroupper,-waitpkg,-wbnoinvd,-widekl,+x87,-xop,+xsave,+xsavec,+xsaveopt,+xsaves" }
attributes #8 = { cold minsize nobuiltin nounwind optsize "target-cpu"="skylake" "target-features"="-16bit-mode,-32bit-mode,-3dnow,-3dnowa,+64bit,+adx,+aes,-amx-bf16,-amx-int8,-amx-tile,+avx,+avx2,-avx512bf16,-avx512bitalg,-avx512bw,-avx512cd,-avx512dq,-avx512er,-avx512f,-avx512ifma,-avx512pf,-avx512vbmi,-avx512vbmi2,-avx512vl,-avx512vnni,-avx512vp2intersect,-avx512vpopcntdq,-avxvnni,+bmi,+bmi2,-branchfusion,-cldemote,+clflushopt,-clwb,-clzero,+cmov,+cx16,+cx8,-enqcmd,+ermsb,+f16c,-false-deps-lzcnt-tzcnt,+false-deps-popcnt,-fast-11bytenop,+fast-15bytenop,-fast-7bytenop,-fast-bextr,+fast-gather,-fast-hops,-fast-lzcnt,-fast-movbe,+fast-scalar-fsqrt,-fast-scalar-shift-masks,+fast-shld-rotate,+fast-variable-crosslane-shuffle,+fast-variable-perlane-shuffle,+fast-vector-fsqrt,-fast-vector-shift-masks,+fma,-fma4,+fsgsbase,-fsrm,+fxsr,-gfni,-hreset,-idivl-to-divb,+idivq-to-divl,+invpcid,-kl,-lea-sp,-lea-uses-ag,-lvi-cfi,-lvi-load-hardening,-lwp,+lzcnt,+macrofusion,+mmx,+movbe,-movdir64b,-movdiri,-mwaitx,+nopl,-pad-short-functions,+pclmul,-pconfig,-pku,+popcnt,-prefer-128-bit,-prefer-256-bit,-prefer-mask-registers,-prefetchwt1,+prfchw,-ptwrite,-rdpid,+rdrnd,+rdseed,-retpoline,-retpoline-external-thunk,-retpoline-indirect-branches,-retpoline-indirect-calls,+rtm,+sahf,-serialize,-seses,+sgx,-sha,-shstk,+slow-3ops-lea,-slow-incdec,-slow-lea,-slow-pmaddwd,-slow-pmulld,-slow-shld,-slow-two-mem-ops,-slow-unaligned-mem-16,-slow-unaligned-mem-32,-soft-float,+sse,+sse2,+sse3,+sse4.1,+sse4.2,-sse4a,-sse-unaligned-mem,+ssse3,-tbm,-tsxldtrk,-uintr,-use-aa,-use-glm-div-sqrt-costs,-vaes,-vpclmulqdq,+vzeroupper,-waitpkg,-wbnoinvd,-widekl,+x87,-xop,+xsave,+xsavec,+xsaveopt,+xsaves" }
attributes #9 = { nofree nosync nounwind readnone speculatable willreturn }
attributes #10 = { alwaysinline }
attributes #11 = { noinline }

!llvm.module.flags = !{!0, !1}
!llvm.dbg.cu = !{!2}

!0 = !{i32 2, !"Debug Info Version", i32 3}
!1 = !{i32 2, !"Dwarf Version", i32 4}
!2 = distinct !DICompileUnit(language: DW_LANG_C99, file: !3, producer: "zig 0.10.0", isOptimized: true, runtimeVersion: 0, emissionKind: NoDebug, enums: !4)
!3 = !DIFile(filename: "test", directory: "src")
!4 = !{!5, !12, !57, !79, !225, !284, !290, !315, !322, !328, !482, !487, !849, !855, !861, !911, !926, !930, !937, !941, !946, !950, !970, !976, !981, !985, !990, !997}
!5 = !DICompositeType(tag: DW_TAG_enumeration_type, name: "std.builtin.OutputMode", scope: !6, file: !6, line: 459, baseType: !7, size: 8, align: 8, elements: !8)
!6 = !DIFile(filename: "builtin.zig", directory: "/home/mike/personal/zig/build/lib/zig/std")
!7 = !DIBasicType(name: "u2", size: 8, encoding: DW_ATE_unsigned)
!8 = !{!9, !10, !11}
!9 = !DIEnumerator(name: "Exe", value: 0)
!10 = !DIEnumerator(name: "Lib", value: 1)
!11 = !DIEnumerator(name: "Obj", value: 2)
!12 = !DICompositeType(tag: DW_TAG_enumeration_type, name: "std.target.Tag", scope: !13, file: !13, line: 17, baseType: !14, size: 8, align: 8, elements: !15)
!13 = !DIFile(filename: "target.zig", directory: "/home/mike/personal/zig/build/lib/zig/std")
!14 = !DIBasicType(name: "u6", size: 8, encoding: DW_ATE_unsigned)
!15 = !{!16, !17, !18, !19, !20, !21, !22, !23, !24, !25, !26, !27, !28, !29, !30, !31, !32, !33, !34, !35, !36, !37, !38, !39, !40, !41, !42, !43, !44, !45, !46, !47, !48, !49, !50, !51, !52, !53, !54, !55, !56}
!16 = !DIEnumerator(name: "freestanding", value: 0)
!17 = !DIEnumerator(name: "ananas", value: 1)
!18 = !DIEnumerator(name: "cloudabi", value: 2)
!19 = !DIEnumerator(name: "dragonfly", value: 3)
!20 = !DIEnumerator(name: "freebsd", value: 4)
!21 = !DIEnumerator(name: "fuchsia", value: 5)
!22 = !DIEnumerator(name: "ios", value: 6)
!23 = !DIEnumerator(name: "kfreebsd", value: 7)
!24 = !DIEnumerator(name: "linux", value: 8)
!25 = !DIEnumerator(name: "lv2", value: 9)
!26 = !DIEnumerator(name: "macos", value: 10)
!27 = !DIEnumerator(name: "netbsd", value: 11)
!28 = !DIEnumerator(name: "openbsd", value: 12)
!29 = !DIEnumerator(name: "solaris", value: 13)
!30 = !DIEnumerator(name: "windows", value: 14)
!31 = !DIEnumerator(name: "zos", value: 15)
!32 = !DIEnumerator(name: "haiku", value: 16)
!33 = !DIEnumerator(name: "minix", value: 17)
!34 = !DIEnumerator(name: "rtems", value: 18)
!35 = !DIEnumerator(name: "nacl", value: 19)
!36 = !DIEnumerator(name: "aix", value: 20)
!37 = !DIEnumerator(name: "cuda", value: 21)
!38 = !DIEnumerator(name: "nvcl", value: 22)
!39 = !DIEnumerator(name: "amdhsa", value: 23)
!40 = !DIEnumerator(name: "ps4", value: 24)
!41 = !DIEnumerator(name: "elfiamcu", value: 25)
!42 = !DIEnumerator(name: "tvos", value: 26)
!43 = !DIEnumerator(name: "watchos", value: 27)
!44 = !DIEnumerator(name: "mesa3d", value: 28)
!45 = !DIEnumerator(name: "contiki", value: 29)
!46 = !DIEnumerator(name: "amdpal", value: 30)
!47 = !DIEnumerator(name: "hermit", value: 31)
!48 = !DIEnumerator(name: "hurd", value: 32)
!49 = !DIEnumerator(name: "wasi", value: 33)
!50 = !DIEnumerator(name: "emscripten", value: 34)
!51 = !DIEnumerator(name: "uefi", value: 35)
!52 = !DIEnumerator(name: "opencl", value: 36)
!53 = !DIEnumerator(name: "glsl450", value: 37)
!54 = !DIEnumerator(name: "vulkan", value: 38)
!55 = !DIEnumerator(name: "plan9", value: 39)
!56 = !DIEnumerator(name: "other", value: 40)
!57 = !DICompositeType(tag: DW_TAG_enumeration_type, name: "std.target.WindowsVersion", scope: !13, file: !13, line: 94, baseType: !58, size: 32, align: 32, elements: !59)
!58 = !DIBasicType(name: "u32", size: 32, encoding: DW_ATE_unsigned)
!59 = !{!60, !61, !62, !63, !64, !65, !66, !67, !68, !69, !70, !71, !72, !73, !74, !75, !76, !77, !78}
!60 = !DIEnumerator(name: "nt4", value: 67108864)
!61 = !DIEnumerator(name: "win2k", value: 83886080)
!62 = !DIEnumerator(name: "xp", value: 83951616)
!63 = !DIEnumerator(name: "ws2003", value: 84017152)
!64 = !DIEnumerator(name: "vista", value: 100663296)
!65 = !DIEnumerator(name: "win7", value: 100728832)
!66 = !DIEnumerator(name: "win8", value: 100794368)
!67 = !DIEnumerator(name: "win8_1", value: 100859904)
!68 = !DIEnumerator(name: "win10", value: 167772160)
!69 = !DIEnumerator(name: "win10_th2", value: 167772161)
!70 = !DIEnumerator(name: "win10_rs1", value: 167772162)
!71 = !DIEnumerator(name: "win10_rs2", value: 167772163)
!72 = !DIEnumerator(name: "win10_rs3", value: 167772164)
!73 = !DIEnumerator(name: "win10_rs4", value: 167772165)
!74 = !DIEnumerator(name: "win10_rs5", value: 167772166)
!75 = !DIEnumerator(name: "win10_19h1", value: 167772167)
!76 = !DIEnumerator(name: "win10_vb", value: 167772168)
!77 = !DIEnumerator(name: "win10_mn", value: 167772169)
!78 = !DIEnumerator(name: "win10_fe", value: 167772170)
!79 = !DICompositeType(tag: DW_TAG_enumeration_type, name: "std.target.x86.Feature", scope: !80, file: !80, line: 7, baseType: !81, size: 8, align: 8, elements: !82)
!80 = !DIFile(filename: "x86.zig", directory: "/home/mike/personal/zig/build/lib/zig/std/target")
!81 = !DIBasicType(name: "u8", size: 8, encoding: DW_ATE_unsigned_char)
!82 = !{!83, !84, !85, !86, !87, !88, !89, !90, !91, !92, !93, !94, !95, !96, !97, !98, !99, !100, !101, !102, !103, !104, !105, !106, !107, !108, !109, !110, !111, !112, !113, !114, !115, !116, !117, !118, !119, !120, !121, !122, !123, !124, !125, !126, !127, !128, !129, !130, !131, !132, !133, !134, !135, !136, !137, !138, !139, !140, !141, !142, !143, !144, !145, !146, !147, !148, !149, !150, !151, !152, !153, !154, !155, !156, !157, !158, !159, !160, !161, !162, !163, !164, !165, !166, !167, !168, !169, !170, !171, !172, !173, !174, !175, !176, !177, !178, !179, !180, !181, !182, !183, !184, !185, !186, !187, !188, !189, !190, !191, !192, !193, !194, !195, !196, !197, !198, !199, !200, !201, !202, !203, !204, !205, !206, !207, !208, !209, !210, !211, !212, !213, !214, !215, !216, !217, !218, !219, !220, !221, !222, !223, !224}
!83 = !DIEnumerator(name: "16bit_mode", value: 0)
!84 = !DIEnumerator(name: "32bit_mode", value: 1)
!85 = !DIEnumerator(name: "3dnow", value: 2)
!86 = !DIEnumerator(name: "3dnowa", value: 3)
!87 = !DIEnumerator(name: "64bit", value: 4)
!88 = !DIEnumerator(name: "adx", value: 5)
!89 = !DIEnumerator(name: "aes", value: 6)
!90 = !DIEnumerator(name: "amx_bf16", value: 7)
!91 = !DIEnumerator(name: "amx_int8", value: 8)
!92 = !DIEnumerator(name: "amx_tile", value: 9)
!93 = !DIEnumerator(name: "avx", value: 10)
!94 = !DIEnumerator(name: "avx2", value: 11)
!95 = !DIEnumerator(name: "avx512bf16", value: 12)
!96 = !DIEnumerator(name: "avx512bitalg", value: 13)
!97 = !DIEnumerator(name: "avx512bw", value: 14)
!98 = !DIEnumerator(name: "avx512cd", value: 15)
!99 = !DIEnumerator(name: "avx512dq", value: 16)
!100 = !DIEnumerator(name: "avx512er", value: 17)
!101 = !DIEnumerator(name: "avx512f", value: 18)
!102 = !DIEnumerator(name: "avx512ifma", value: 19)
!103 = !DIEnumerator(name: "avx512pf", value: 20)
!104 = !DIEnumerator(name: "avx512vbmi", value: 21)
!105 = !DIEnumerator(name: "avx512vbmi2", value: 22)
!106 = !DIEnumerator(name: "avx512vl", value: 23)
!107 = !DIEnumerator(name: "avx512vnni", value: 24)
!108 = !DIEnumerator(name: "avx512vp2intersect", value: 25)
!109 = !DIEnumerator(name: "avx512vpopcntdq", value: 26)
!110 = !DIEnumerator(name: "avxvnni", value: 27)
!111 = !DIEnumerator(name: "bmi", value: 28)
!112 = !DIEnumerator(name: "bmi2", value: 29)
!113 = !DIEnumerator(name: "branchfusion", value: 30)
!114 = !DIEnumerator(name: "cldemote", value: 31)
!115 = !DIEnumerator(name: "clflushopt", value: 32)
!116 = !DIEnumerator(name: "clwb", value: 33)
!117 = !DIEnumerator(name: "clzero", value: 34)
!118 = !DIEnumerator(name: "cmov", value: 35)
!119 = !DIEnumerator(name: "cx16", value: 36)
!120 = !DIEnumerator(name: "cx8", value: 37)
!121 = !DIEnumerator(name: "enqcmd", value: 38)
!122 = !DIEnumerator(name: "ermsb", value: 39)
!123 = !DIEnumerator(name: "f16c", value: 40)
!124 = !DIEnumerator(name: "false_deps_lzcnt_tzcnt", value: 41)
!125 = !DIEnumerator(name: "false_deps_popcnt", value: 42)
!126 = !DIEnumerator(name: "fast_11bytenop", value: 43)
!127 = !DIEnumerator(name: "fast_15bytenop", value: 44)
!128 = !DIEnumerator(name: "fast_7bytenop", value: 45)
!129 = !DIEnumerator(name: "fast_bextr", value: 46)
!130 = !DIEnumerator(name: "fast_gather", value: 47)
!131 = !DIEnumerator(name: "fast_hops", value: 48)
!132 = !DIEnumerator(name: "fast_lzcnt", value: 49)
!133 = !DIEnumerator(name: "fast_movbe", value: 50)
!134 = !DIEnumerator(name: "fast_scalar_fsqrt", value: 51)
!135 = !DIEnumerator(name: "fast_scalar_shift_masks", value: 52)
!136 = !DIEnumerator(name: "fast_shld_rotate", value: 53)
!137 = !DIEnumerator(name: "fast_variable_crosslane_shuffle", value: 54)
!138 = !DIEnumerator(name: "fast_variable_perlane_shuffle", value: 55)
!139 = !DIEnumerator(name: "fast_vector_fsqrt", value: 56)
!140 = !DIEnumerator(name: "fast_vector_shift_masks", value: 57)
!141 = !DIEnumerator(name: "fma", value: 58)
!142 = !DIEnumerator(name: "fma4", value: 59)
!143 = !DIEnumerator(name: "fsgsbase", value: 60)
!144 = !DIEnumerator(name: "fsrm", value: 61)
!145 = !DIEnumerator(name: "fxsr", value: 62)
!146 = !DIEnumerator(name: "gfni", value: 63)
!147 = !DIEnumerator(name: "hreset", value: 64)
!148 = !DIEnumerator(name: "idivl_to_divb", value: 65)
!149 = !DIEnumerator(name: "idivq_to_divl", value: 66)
!150 = !DIEnumerator(name: "invpcid", value: 67)
!151 = !DIEnumerator(name: "kl", value: 68)
!152 = !DIEnumerator(name: "lea_sp", value: 69)
!153 = !DIEnumerator(name: "lea_uses_ag", value: 70)
!154 = !DIEnumerator(name: "lvi_cfi", value: 71)
!155 = !DIEnumerator(name: "lvi_load_hardening", value: 72)
!156 = !DIEnumerator(name: "lwp", value: 73)
!157 = !DIEnumerator(name: "lzcnt", value: 74)
!158 = !DIEnumerator(name: "macrofusion", value: 75)
!159 = !DIEnumerator(name: "mmx", value: 76)
!160 = !DIEnumerator(name: "movbe", value: 77)
!161 = !DIEnumerator(name: "movdir64b", value: 78)
!162 = !DIEnumerator(name: "movdiri", value: 79)
!163 = !DIEnumerator(name: "mwaitx", value: 80)
!164 = !DIEnumerator(name: "nopl", value: 81)
!165 = !DIEnumerator(name: "pad_short_functions", value: 82)
!166 = !DIEnumerator(name: "pclmul", value: 83)
!167 = !DIEnumerator(name: "pconfig", value: 84)
!168 = !DIEnumerator(name: "pku", value: 85)
!169 = !DIEnumerator(name: "popcnt", value: 86)
!170 = !DIEnumerator(name: "prefer_128_bit", value: 87)
!171 = !DIEnumerator(name: "prefer_256_bit", value: 88)
!172 = !DIEnumerator(name: "prefer_mask_registers", value: 89)
!173 = !DIEnumerator(name: "prefetchwt1", value: 90)
!174 = !DIEnumerator(name: "prfchw", value: 91)
!175 = !DIEnumerator(name: "ptwrite", value: 92)
!176 = !DIEnumerator(name: "rdpid", value: 93)
!177 = !DIEnumerator(name: "rdrnd", value: 94)
!178 = !DIEnumerator(name: "rdseed", value: 95)
!179 = !DIEnumerator(name: "retpoline", value: 96)
!180 = !DIEnumerator(name: "retpoline_external_thunk", value: 97)
!181 = !DIEnumerator(name: "retpoline_indirect_branches", value: 98)
!182 = !DIEnumerator(name: "retpoline_indirect_calls", value: 99)
!183 = !DIEnumerator(name: "rtm", value: 100)
!184 = !DIEnumerator(name: "sahf", value: 101)
!185 = !DIEnumerator(name: "serialize", value: 102)
!186 = !DIEnumerator(name: "seses", value: 103)
!187 = !DIEnumerator(name: "sgx", value: 104)
!188 = !DIEnumerator(name: "sha", value: 105)
!189 = !DIEnumerator(name: "shstk", value: 106)
!190 = !DIEnumerator(name: "slow_3ops_lea", value: 107)
!191 = !DIEnumerator(name: "slow_incdec", value: 108)
!192 = !DIEnumerator(name: "slow_lea", value: 109)
!193 = !DIEnumerator(name: "slow_pmaddwd", value: 110)
!194 = !DIEnumerator(name: "slow_pmulld", value: 111)
!195 = !DIEnumerator(name: "slow_shld", value: 112)
!196 = !DIEnumerator(name: "slow_two_mem_ops", value: 113)
!197 = !DIEnumerator(name: "slow_unaligned_mem_16", value: 114)
!198 = !DIEnumerator(name: "slow_unaligned_mem_32", value: 115)
!199 = !DIEnumerator(name: "soft_float", value: 116)
!200 = !DIEnumerator(name: "sse", value: 117)
!201 = !DIEnumerator(name: "sse2", value: 118)
!202 = !DIEnumerator(name: "sse3", value: 119)
!203 = !DIEnumerator(name: "sse4_1", value: 120)
!204 = !DIEnumerator(name: "sse4_2", value: 121)
!205 = !DIEnumerator(name: "sse4a", value: 122)
!206 = !DIEnumerator(name: "sse_unaligned_mem", value: 123)
!207 = !DIEnumerator(name: "ssse3", value: 124)
!208 = !DIEnumerator(name: "tbm", value: 125)
!209 = !DIEnumerator(name: "tsxldtrk", value: 126)
!210 = !DIEnumerator(name: "uintr", value: 127)
!211 = !DIEnumerator(name: "use_aa", value: 128)
!212 = !DIEnumerator(name: "use_glm_div_sqrt_costs", value: 129)
!213 = !DIEnumerator(name: "vaes", value: 130)
!214 = !DIEnumerator(name: "vpclmulqdq", value: 131)
!215 = !DIEnumerator(name: "vzeroupper", value: 132)
!216 = !DIEnumerator(name: "waitpkg", value: 133)
!217 = !DIEnumerator(name: "wbnoinvd", value: 134)
!218 = !DIEnumerator(name: "widekl", value: 135)
!219 = !DIEnumerator(name: "x87", value: 136)
!220 = !DIEnumerator(name: "xop", value: 137)
!221 = !DIEnumerator(name: "xsave", value: 138)
!222 = !DIEnumerator(name: "xsavec", value: 139)
!223 = !DIEnumerator(name: "xsaveopt", value: 140)
!224 = !DIEnumerator(name: "xsaves", value: 141)
!225 = !DICompositeType(tag: DW_TAG_enumeration_type, name: "std.target.Arch", scope: !13, file: !13, line: 760, baseType: !14, size: 8, align: 8, elements: !226)
!226 = !{!227, !228, !229, !230, !231, !232, !233, !234, !235, !236, !237, !238, !239, !240, !241, !242, !243, !244, !245, !246, !247, !248, !249, !250, !251, !252, !253, !254, !255, !256, !257, !258, !259, !260, !261, !262, !263, !264, !265, !266, !267, !268, !269, !270, !271, !272, !273, !274, !275, !276, !277, !278, !279, !280, !281, !282, !283}
!227 = !DIEnumerator(name: "arm", value: 0)
!228 = !DIEnumerator(name: "armeb", value: 1)
!229 = !DIEnumerator(name: "aarch64", value: 2)
!230 = !DIEnumerator(name: "aarch64_be", value: 3)
!231 = !DIEnumerator(name: "aarch64_32", value: 4)
!232 = !DIEnumerator(name: "arc", value: 5)
!233 = !DIEnumerator(name: "avr", value: 6)
!234 = !DIEnumerator(name: "bpfel", value: 7)
!235 = !DIEnumerator(name: "bpfeb", value: 8)
!236 = !DIEnumerator(name: "csky", value: 9)
!237 = !DIEnumerator(name: "hexagon", value: 10)
!238 = !DIEnumerator(name: "m68k", value: 11)
!239 = !DIEnumerator(name: "mips", value: 12)
!240 = !DIEnumerator(name: "mipsel", value: 13)
!241 = !DIEnumerator(name: "mips64", value: 14)
!242 = !DIEnumerator(name: "mips64el", value: 15)
!243 = !DIEnumerator(name: "msp430", value: 16)
!244 = !DIEnumerator(name: "powerpc", value: 17)
!245 = !DIEnumerator(name: "powerpcle", value: 18)
!246 = !DIEnumerator(name: "powerpc64", value: 19)
!247 = !DIEnumerator(name: "powerpc64le", value: 20)
!248 = !DIEnumerator(name: "r600", value: 21)
!249 = !DIEnumerator(name: "amdgcn", value: 22)
!250 = !DIEnumerator(name: "riscv32", value: 23)
!251 = !DIEnumerator(name: "riscv64", value: 24)
!252 = !DIEnumerator(name: "sparc", value: 25)
!253 = !DIEnumerator(name: "sparcv9", value: 26)
!254 = !DIEnumerator(name: "sparcel", value: 27)
!255 = !DIEnumerator(name: "s390x", value: 28)
!256 = !DIEnumerator(name: "tce", value: 29)
!257 = !DIEnumerator(name: "tcele", value: 30)
!258 = !DIEnumerator(name: "thumb", value: 31)
!259 = !DIEnumerator(name: "thumbeb", value: 32)
!260 = !DIEnumerator(name: "i386", value: 33)
!261 = !DIEnumerator(name: "x86_64", value: 34)
!262 = !DIEnumerator(name: "xcore", value: 35)
!263 = !DIEnumerator(name: "nvptx", value: 36)
!264 = !DIEnumerator(name: "nvptx64", value: 37)
!265 = !DIEnumerator(name: "le32", value: 38)
!266 = !DIEnumerator(name: "le64", value: 39)
!267 = !DIEnumerator(name: "amdil", value: 40)
!268 = !DIEnumerator(name: "amdil64", value: 41)
!269 = !DIEnumerator(name: "hsail", value: 42)
!270 = !DIEnumerator(name: "hsail64", value: 43)
!271 = !DIEnumerator(name: "spir", value: 44)
!272 = !DIEnumerator(name: "spir64", value: 45)
!273 = !DIEnumerator(name: "kalimba", value: 46)
!274 = !DIEnumerator(name: "shave", value: 47)
!275 = !DIEnumerator(name: "lanai", value: 48)
!276 = !DIEnumerator(name: "wasm32", value: 49)
!277 = !DIEnumerator(name: "wasm64", value: 50)
!278 = !DIEnumerator(name: "renderscript32", value: 51)
!279 = !DIEnumerator(name: "renderscript64", value: 52)
!280 = !DIEnumerator(name: "ve", value: 53)
!281 = !DIEnumerator(name: "spu_2", value: 54)
!282 = !DIEnumerator(name: "spirv32", value: 55)
!283 = !DIEnumerator(name: "spirv64", value: 56)
!284 = !DICompositeType(tag: DW_TAG_enumeration_type, name: "std.builtin.Mode", scope: !6, file: !6, line: 148, baseType: !7, size: 8, align: 8, elements: !285)
!285 = !{!286, !287, !288, !289}
!286 = !DIEnumerator(name: "Debug", value: 0)
!287 = !DIEnumerator(name: "ReleaseSafe", value: 1)
!288 = !DIEnumerator(name: "ReleaseFast", value: 2)
!289 = !DIEnumerator(name: "ReleaseSmall", value: 3)
!290 = !DICompositeType(tag: DW_TAG_enumeration_type, name: "std.target.Abi", scope: !13, file: !13, line: 461, baseType: !291, size: 8, align: 8, elements: !292)
!291 = !DIBasicType(name: "u5", size: 8, encoding: DW_ATE_unsigned)
!292 = !{!293, !294, !295, !296, !297, !298, !299, !300, !301, !302, !303, !304, !305, !306, !307, !308, !309, !310, !311, !312, !313, !314}
!293 = !DIEnumerator(name: "none", value: 0)
!294 = !DIEnumerator(name: "gnu", value: 1)
!295 = !DIEnumerator(name: "gnuabin32", value: 2)
!296 = !DIEnumerator(name: "gnuabi64", value: 3)
!297 = !DIEnumerator(name: "gnueabi", value: 4)
!298 = !DIEnumerator(name: "gnueabihf", value: 5)
!299 = !DIEnumerator(name: "gnux32", value: 6)
!300 = !DIEnumerator(name: "gnuilp32", value: 7)
!301 = !DIEnumerator(name: "code16", value: 8)
!302 = !DIEnumerator(name: "eabi", value: 9)
!303 = !DIEnumerator(name: "eabihf", value: 10)
!304 = !DIEnumerator(name: "android", value: 11)
!305 = !DIEnumerator(name: "musl", value: 12)
!306 = !DIEnumerator(name: "musleabi", value: 13)
!307 = !DIEnumerator(name: "musleabihf", value: 14)
!308 = !DIEnumerator(name: "muslx32", value: 15)
!309 = !DIEnumerator(name: "msvc", value: 16)
!310 = !DIEnumerator(name: "itanium", value: 17)
!311 = !DIEnumerator(name: "cygnus", value: 18)
!312 = !DIEnumerator(name: "coreclr", value: 19)
!313 = !DIEnumerator(name: "simulator", value: 20)
!314 = !DIEnumerator(name: "macabi", value: 21)
!315 = !DICompositeType(tag: DW_TAG_enumeration_type, name: "std.Thread.Mutex.State", scope: !316, file: !316, line: 63, baseType: !317, size: 32, align: 32, elements: !318)
!316 = !DIFile(filename: "Mutex.zig", directory: "/home/mike/personal/zig/build/lib/zig/std/Thread")
!317 = !DIBasicType(name: "i32", size: 32, encoding: DW_ATE_signed)
!318 = !{!319, !320, !321}
!319 = !DIEnumerator(name: "unlocked", value: 0)
!320 = !DIEnumerator(name: "locked", value: 1)
!321 = !DIEnumerator(name: "waiting", value: 2)
!322 = !DICompositeType(tag: DW_TAG_enumeration_type, name: "std.io.Mode", scope: !323, file: !323, line: 15, baseType: !324, size: 8, align: 8, elements: !325)
!323 = !DIFile(filename: "io.zig", directory: "/home/mike/personal/zig/build/lib/zig/std")
!324 = !DIBasicType(name: "u1", size: 8, encoding: DW_ATE_unsigned)
!325 = !{!326, !327}
!326 = !DIEnumerator(name: "blocking", value: 0)
!327 = !DIEnumerator(name: "evented", value: 1)
!328 = !DICompositeType(tag: DW_TAG_enumeration_type, name: "std.os.linux.errno.generic.E", scope: !329, file: !329, line: 1, baseType: !330, size: 16, align: 16, elements: !331)
!329 = !DIFile(filename: "generic.zig", directory: "/home/mike/personal/zig/build/lib/zig/std/os/linux/errno")
!330 = !DIBasicType(name: "u16", size: 16, encoding: DW_ATE_unsigned)
!331 = !{!332, !333, !334, !335, !336, !337, !338, !339, !340, !341, !342, !343, !344, !345, !346, !347, !348, !349, !350, !351, !352, !353, !354, !355, !356, !357, !358, !359, !360, !361, !362, !363, !364, !365, !366, !367, !368, !369, !370, !371, !372, !373, !374, !375, !376, !377, !378, !379, !380, !381, !382, !383, !384, !385, !386, !387, !388, !389, !390, !391, !392, !393, !394, !395, !396, !397, !398, !399, !400, !401, !402, !403, !404, !405, !406, !407, !408, !409, !410, !411, !412, !413, !414, !415, !416, !417, !418, !419, !420, !421, !422, !423, !424, !425, !426, !427, !428, !429, !430, !431, !432, !433, !434, !435, !436, !437, !438, !439, !440, !441, !442, !443, !444, !445, !446, !447, !448, !449, !450, !451, !452, !453, !454, !455, !456, !457, !458, !459, !460, !461, !462, !463, !464, !465, !466, !467, !468, !469, !470, !471, !472, !473, !474, !475, !476, !477, !478, !479, !480, !481}
!332 = !DIEnumerator(name: "SUCCESS", value: 0)
!333 = !DIEnumerator(name: "PERM", value: 1)
!334 = !DIEnumerator(name: "NOENT", value: 2)
!335 = !DIEnumerator(name: "SRCH", value: 3)
!336 = !DIEnumerator(name: "INTR", value: 4)
!337 = !DIEnumerator(name: "IO", value: 5)
!338 = !DIEnumerator(name: "NXIO", value: 6)
!339 = !DIEnumerator(name: "2BIG", value: 7)
!340 = !DIEnumerator(name: "NOEXEC", value: 8)
!341 = !DIEnumerator(name: "BADF", value: 9)
!342 = !DIEnumerator(name: "CHILD", value: 10)
!343 = !DIEnumerator(name: "AGAIN", value: 11)
!344 = !DIEnumerator(name: "NOMEM", value: 12)
!345 = !DIEnumerator(name: "ACCES", value: 13)
!346 = !DIEnumerator(name: "FAULT", value: 14)
!347 = !DIEnumerator(name: "NOTBLK", value: 15)
!348 = !DIEnumerator(name: "BUSY", value: 16)
!349 = !DIEnumerator(name: "EXIST", value: 17)
!350 = !DIEnumerator(name: "XDEV", value: 18)
!351 = !DIEnumerator(name: "NODEV", value: 19)
!352 = !DIEnumerator(name: "NOTDIR", value: 20)
!353 = !DIEnumerator(name: "ISDIR", value: 21)
!354 = !DIEnumerator(name: "INVAL", value: 22)
!355 = !DIEnumerator(name: "NFILE", value: 23)
!356 = !DIEnumerator(name: "MFILE", value: 24)
!357 = !DIEnumerator(name: "NOTTY", value: 25)
!358 = !DIEnumerator(name: "TXTBSY", value: 26)
!359 = !DIEnumerator(name: "FBIG", value: 27)
!360 = !DIEnumerator(name: "NOSPC", value: 28)
!361 = !DIEnumerator(name: "SPIPE", value: 29)
!362 = !DIEnumerator(name: "ROFS", value: 30)
!363 = !DIEnumerator(name: "MLINK", value: 31)
!364 = !DIEnumerator(name: "PIPE", value: 32)
!365 = !DIEnumerator(name: "DOM", value: 33)
!366 = !DIEnumerator(name: "RANGE", value: 34)
!367 = !DIEnumerator(name: "DEADLK", value: 35)
!368 = !DIEnumerator(name: "NAMETOOLONG", value: 36)
!369 = !DIEnumerator(name: "NOLCK", value: 37)
!370 = !DIEnumerator(name: "NOSYS", value: 38)
!371 = !DIEnumerator(name: "NOTEMPTY", value: 39)
!372 = !DIEnumerator(name: "LOOP", value: 40)
!373 = !DIEnumerator(name: "NOMSG", value: 42)
!374 = !DIEnumerator(name: "IDRM", value: 43)
!375 = !DIEnumerator(name: "CHRNG", value: 44)
!376 = !DIEnumerator(name: "L2NSYNC", value: 45)
!377 = !DIEnumerator(name: "L3HLT", value: 46)
!378 = !DIEnumerator(name: "L3RST", value: 47)
!379 = !DIEnumerator(name: "LNRNG", value: 48)
!380 = !DIEnumerator(name: "UNATCH", value: 49)
!381 = !DIEnumerator(name: "NOCSI", value: 50)
!382 = !DIEnumerator(name: "L2HLT", value: 51)
!383 = !DIEnumerator(name: "BADE", value: 52)
!384 = !DIEnumerator(name: "BADR", value: 53)
!385 = !DIEnumerator(name: "XFULL", value: 54)
!386 = !DIEnumerator(name: "NOANO", value: 55)
!387 = !DIEnumerator(name: "BADRQC", value: 56)
!388 = !DIEnumerator(name: "BADSLT", value: 57)
!389 = !DIEnumerator(name: "BFONT", value: 59)
!390 = !DIEnumerator(name: "NOSTR", value: 60)
!391 = !DIEnumerator(name: "NODATA", value: 61)
!392 = !DIEnumerator(name: "TIME", value: 62)
!393 = !DIEnumerator(name: "NOSR", value: 63)
!394 = !DIEnumerator(name: "NONET", value: 64)
!395 = !DIEnumerator(name: "NOPKG", value: 65)
!396 = !DIEnumerator(name: "REMOTE", value: 66)
!397 = !DIEnumerator(name: "NOLINK", value: 67)
!398 = !DIEnumerator(name: "ADV", value: 68)
!399 = !DIEnumerator(name: "SRMNT", value: 69)
!400 = !DIEnumerator(name: "COMM", value: 70)
!401 = !DIEnumerator(name: "PROTO", value: 71)
!402 = !DIEnumerator(name: "MULTIHOP", value: 72)
!403 = !DIEnumerator(name: "DOTDOT", value: 73)
!404 = !DIEnumerator(name: "BADMSG", value: 74)
!405 = !DIEnumerator(name: "OVERFLOW", value: 75)
!406 = !DIEnumerator(name: "NOTUNIQ", value: 76)
!407 = !DIEnumerator(name: "BADFD", value: 77)
!408 = !DIEnumerator(name: "REMCHG", value: 78)
!409 = !DIEnumerator(name: "LIBACC", value: 79)
!410 = !DIEnumerator(name: "LIBBAD", value: 80)
!411 = !DIEnumerator(name: "LIBSCN", value: 81)
!412 = !DIEnumerator(name: "LIBMAX", value: 82)
!413 = !DIEnumerator(name: "LIBEXEC", value: 83)
!414 = !DIEnumerator(name: "ILSEQ", value: 84)
!415 = !DIEnumerator(name: "RESTART", value: 85)
!416 = !DIEnumerator(name: "STRPIPE", value: 86)
!417 = !DIEnumerator(name: "USERS", value: 87)
!418 = !DIEnumerator(name: "NOTSOCK", value: 88)
!419 = !DIEnumerator(name: "DESTADDRREQ", value: 89)
!420 = !DIEnumerator(name: "MSGSIZE", value: 90)
!421 = !DIEnumerator(name: "PROTOTYPE", value: 91)
!422 = !DIEnumerator(name: "NOPROTOOPT", value: 92)
!423 = !DIEnumerator(name: "PROTONOSUPPORT", value: 93)
!424 = !DIEnumerator(name: "SOCKTNOSUPPORT", value: 94)
!425 = !DIEnumerator(name: "OPNOTSUPP", value: 95)
!426 = !DIEnumerator(name: "PFNOSUPPORT", value: 96)
!427 = !DIEnumerator(name: "AFNOSUPPORT", value: 97)
!428 = !DIEnumerator(name: "ADDRINUSE", value: 98)
!429 = !DIEnumerator(name: "ADDRNOTAVAIL", value: 99)
!430 = !DIEnumerator(name: "NETDOWN", value: 100)
!431 = !DIEnumerator(name: "NETUNREACH", value: 101)
!432 = !DIEnumerator(name: "NETRESET", value: 102)
!433 = !DIEnumerator(name: "CONNABORTED", value: 103)
!434 = !DIEnumerator(name: "CONNRESET", value: 104)
!435 = !DIEnumerator(name: "NOBUFS", value: 105)
!436 = !DIEnumerator(name: "ISCONN", value: 106)
!437 = !DIEnumerator(name: "NOTCONN", value: 107)
!438 = !DIEnumerator(name: "SHUTDOWN", value: 108)
!439 = !DIEnumerator(name: "TOOMANYREFS", value: 109)
!440 = !DIEnumerator(name: "TIMEDOUT", value: 110)
!441 = !DIEnumerator(name: "CONNREFUSED", value: 111)
!442 = !DIEnumerator(name: "HOSTDOWN", value: 112)
!443 = !DIEnumerator(name: "HOSTUNREACH", value: 113)
!444 = !DIEnumerator(name: "ALREADY", value: 114)
!445 = !DIEnumerator(name: "INPROGRESS", value: 115)
!446 = !DIEnumerator(name: "STALE", value: 116)
!447 = !DIEnumerator(name: "UCLEAN", value: 117)
!448 = !DIEnumerator(name: "NOTNAM", value: 118)
!449 = !DIEnumerator(name: "NAVAIL", value: 119)
!450 = !DIEnumerator(name: "ISNAM", value: 120)
!451 = !DIEnumerator(name: "REMOTEIO", value: 121)
!452 = !DIEnumerator(name: "DQUOT", value: 122)
!453 = !DIEnumerator(name: "NOMEDIUM", value: 123)
!454 = !DIEnumerator(name: "MEDIUMTYPE", value: 124)
!455 = !DIEnumerator(name: "CANCELED", value: 125)
!456 = !DIEnumerator(name: "NOKEY", value: 126)
!457 = !DIEnumerator(name: "KEYEXPIRED", value: 127)
!458 = !DIEnumerator(name: "KEYREVOKED", value: 128)
!459 = !DIEnumerator(name: "KEYREJECTED", value: 129)
!460 = !DIEnumerator(name: "OWNERDEAD", value: 130)
!461 = !DIEnumerator(name: "NOTRECOVERABLE", value: 131)
!462 = !DIEnumerator(name: "RFKILL", value: 132)
!463 = !DIEnumerator(name: "HWPOISON", value: 133)
!464 = !DIEnumerator(name: "NSRNODATA", value: 160)
!465 = !DIEnumerator(name: "NSRFORMERR", value: 161)
!466 = !DIEnumerator(name: "NSRSERVFAIL", value: 162)
!467 = !DIEnumerator(name: "NSRNOTFOUND", value: 163)
!468 = !DIEnumerator(name: "NSRNOTIMP", value: 164)
!469 = !DIEnumerator(name: "NSRREFUSED", value: 165)
!470 = !DIEnumerator(name: "NSRBADQUERY", value: 166)
!471 = !DIEnumerator(name: "NSRBADNAME", value: 167)
!472 = !DIEnumerator(name: "NSRBADFAMILY", value: 168)
!473 = !DIEnumerator(name: "NSRBADRESP", value: 169)
!474 = !DIEnumerator(name: "NSRCONNREFUSED", value: 170)
!475 = !DIEnumerator(name: "NSRTIMEOUT", value: 171)
!476 = !DIEnumerator(name: "NSROF", value: 172)
!477 = !DIEnumerator(name: "NSRFILE", value: 173)
!478 = !DIEnumerator(name: "NSRNOMEM", value: 174)
!479 = !DIEnumerator(name: "NSRDESTRUCTION", value: 175)
!480 = !DIEnumerator(name: "NSRQUERYDOMAINTOOLONG", value: 176)
!481 = !DIEnumerator(name: "NSRCNAMELOOP", value: 177)
!482 = !DICompositeType(tag: DW_TAG_enumeration_type, name: "std.os.linux.tls.TLSVariant", scope: !483, file: !483, line: 45, baseType: !324, size: 8, align: 8, elements: !484)
!483 = !DIFile(filename: "tls.zig", directory: "/home/mike/personal/zig/build/lib/zig/std/os/linux")
!484 = !{!485, !486}
!485 = !DIEnumerator(name: "VariantI", value: 0)
!486 = !DIEnumerator(name: "VariantII", value: 1)
!487 = !DICompositeType(tag: DW_TAG_enumeration_type, name: "std.os.linux.x86_64.SYS", scope: !488, file: !488, line: 121, baseType: !489, size: 64, align: 64, elements: !490)
!488 = !DIFile(filename: "x86_64.zig", directory: "/home/mike/personal/zig/build/lib/zig/std/os/linux")
!489 = !DIBasicType(name: "usize", size: 64, encoding: DW_ATE_unsigned)
!490 = !{!491, !492, !493, !494, !495, !496, !497, !498, !499, !500, !501, !502, !503, !504, !505, !506, !507, !508, !509, !510, !511, !512, !513, !514, !515, !516, !517, !518, !519, !520, !521, !522, !523, !524, !525, !526, !527, !528, !529, !530, !531, !532, !533, !534, !535, !536, !537, !538, !539, !540, !541, !542, !543, !544, !545, !546, !547, !548, !549, !550, !551, !552, !553, !554, !555, !556, !557, !558, !559, !560, !561, !562, !563, !564, !565, !566, !567, !568, !569, !570, !571, !572, !573, !574, !575, !576, !577, !578, !579, !580, !581, !582, !583, !584, !585, !586, !587, !588, !589, !590, !591, !592, !593, !594, !595, !596, !597, !598, !599, !600, !601, !602, !603, !604, !605, !606, !607, !608, !609, !610, !611, !612, !613, !614, !615, !616, !617, !618, !619, !620, !621, !622, !623, !624, !625, !626, !627, !628, !629, !630, !631, !632, !633, !634, !635, !636, !637, !638, !639, !640, !641, !642, !643, !644, !645, !646, !647, !648, !649, !650, !651, !652, !653, !654, !655, !656, !657, !658, !659, !660, !661, !662, !663, !664, !665, !666, !667, !668, !669, !670, !671, !672, !673, !674, !675, !676, !677, !678, !679, !680, !681, !682, !683, !684, !685, !686, !687, !688, !689, !690, !691, !692, !693, !694, !695, !696, !697, !698, !699, !700, !701, !702, !703, !704, !705, !706, !707, !708, !709, !710, !711, !712, !713, !714, !715, !716, !717, !718, !719, !720, !721, !722, !723, !724, !725, !726, !727, !728, !729, !730, !731, !732, !733, !734, !735, !736, !737, !738, !739, !740, !741, !742, !743, !744, !745, !746, !747, !748, !749, !750, !751, !752, !753, !754, !755, !756, !757, !758, !759, !760, !761, !762, !763, !764, !765, !766, !767, !768, !769, !770, !771, !772, !773, !774, !775, !776, !777, !778, !779, !780, !781, !782, !783, !784, !785, !786, !787, !788, !789, !790, !791, !792, !793, !794, !795, !796, !797, !798, !799, !800, !801, !802, !803, !804, !805, !806, !807, !808, !809, !810, !811, !812, !813, !814, !815, !816, !817, !818, !819, !820, !821, !822, !823, !824, !825, !826, !827, !828, !829, !830, !831, !832, !833, !834, !835, !836, !837, !838, !839, !840, !841, !842, !843, !844, !845, !846, !847, !848}
!491 = !DIEnumerator(name: "read", value: 0)
!492 = !DIEnumerator(name: "write", value: 1)
!493 = !DIEnumerator(name: "open", value: 2)
!494 = !DIEnumerator(name: "close", value: 3)
!495 = !DIEnumerator(name: "stat", value: 4)
!496 = !DIEnumerator(name: "fstat", value: 5)
!497 = !DIEnumerator(name: "lstat", value: 6)
!498 = !DIEnumerator(name: "poll", value: 7)
!499 = !DIEnumerator(name: "lseek", value: 8)
!500 = !DIEnumerator(name: "mmap", value: 9)
!501 = !DIEnumerator(name: "mprotect", value: 10)
!502 = !DIEnumerator(name: "munmap", value: 11)
!503 = !DIEnumerator(name: "brk", value: 12)
!504 = !DIEnumerator(name: "rt_sigaction", value: 13)
!505 = !DIEnumerator(name: "rt_sigprocmask", value: 14)
!506 = !DIEnumerator(name: "rt_sigreturn", value: 15)
!507 = !DIEnumerator(name: "ioctl", value: 16)
!508 = !DIEnumerator(name: "pread", value: 17)
!509 = !DIEnumerator(name: "pwrite", value: 18)
!510 = !DIEnumerator(name: "readv", value: 19)
!511 = !DIEnumerator(name: "writev", value: 20)
!512 = !DIEnumerator(name: "access", value: 21)
!513 = !DIEnumerator(name: "pipe", value: 22)
!514 = !DIEnumerator(name: "select", value: 23)
!515 = !DIEnumerator(name: "sched_yield", value: 24)
!516 = !DIEnumerator(name: "mremap", value: 25)
!517 = !DIEnumerator(name: "msync", value: 26)
!518 = !DIEnumerator(name: "mincore", value: 27)
!519 = !DIEnumerator(name: "madvise", value: 28)
!520 = !DIEnumerator(name: "shmget", value: 29)
!521 = !DIEnumerator(name: "shmat", value: 30)
!522 = !DIEnumerator(name: "shmctl", value: 31)
!523 = !DIEnumerator(name: "dup", value: 32)
!524 = !DIEnumerator(name: "dup2", value: 33)
!525 = !DIEnumerator(name: "pause", value: 34)
!526 = !DIEnumerator(name: "nanosleep", value: 35)
!527 = !DIEnumerator(name: "getitimer", value: 36)
!528 = !DIEnumerator(name: "alarm", value: 37)
!529 = !DIEnumerator(name: "setitimer", value: 38)
!530 = !DIEnumerator(name: "getpid", value: 39)
!531 = !DIEnumerator(name: "sendfile", value: 40)
!532 = !DIEnumerator(name: "socket", value: 41)
!533 = !DIEnumerator(name: "connect", value: 42)
!534 = !DIEnumerator(name: "accept", value: 43)
!535 = !DIEnumerator(name: "sendto", value: 44)
!536 = !DIEnumerator(name: "recvfrom", value: 45)
!537 = !DIEnumerator(name: "sendmsg", value: 46)
!538 = !DIEnumerator(name: "recvmsg", value: 47)
!539 = !DIEnumerator(name: "shutdown", value: 48)
!540 = !DIEnumerator(name: "bind", value: 49)
!541 = !DIEnumerator(name: "listen", value: 50)
!542 = !DIEnumerator(name: "getsockname", value: 51)
!543 = !DIEnumerator(name: "getpeername", value: 52)
!544 = !DIEnumerator(name: "socketpair", value: 53)
!545 = !DIEnumerator(name: "setsockopt", value: 54)
!546 = !DIEnumerator(name: "getsockopt", value: 55)
!547 = !DIEnumerator(name: "clone", value: 56)
!548 = !DIEnumerator(name: "fork", value: 57)
!549 = !DIEnumerator(name: "vfork", value: 58)
!550 = !DIEnumerator(name: "execve", value: 59)
!551 = !DIEnumerator(name: "exit", value: 60)
!552 = !DIEnumerator(name: "wait4", value: 61)
!553 = !DIEnumerator(name: "kill", value: 62)
!554 = !DIEnumerator(name: "uname", value: 63)
!555 = !DIEnumerator(name: "semget", value: 64)
!556 = !DIEnumerator(name: "semop", value: 65)
!557 = !DIEnumerator(name: "semctl", value: 66)
!558 = !DIEnumerator(name: "shmdt", value: 67)
!559 = !DIEnumerator(name: "msgget", value: 68)
!560 = !DIEnumerator(name: "msgsnd", value: 69)
!561 = !DIEnumerator(name: "msgrcv", value: 70)
!562 = !DIEnumerator(name: "msgctl", value: 71)
!563 = !DIEnumerator(name: "fcntl", value: 72)
!564 = !DIEnumerator(name: "flock", value: 73)
!565 = !DIEnumerator(name: "fsync", value: 74)
!566 = !DIEnumerator(name: "fdatasync", value: 75)
!567 = !DIEnumerator(name: "truncate", value: 76)
!568 = !DIEnumerator(name: "ftruncate", value: 77)
!569 = !DIEnumerator(name: "getdents", value: 78)
!570 = !DIEnumerator(name: "getcwd", value: 79)
!571 = !DIEnumerator(name: "chdir", value: 80)
!572 = !DIEnumerator(name: "fchdir", value: 81)
!573 = !DIEnumerator(name: "rename", value: 82)
!574 = !DIEnumerator(name: "mkdir", value: 83)
!575 = !DIEnumerator(name: "rmdir", value: 84)
!576 = !DIEnumerator(name: "creat", value: 85)
!577 = !DIEnumerator(name: "link", value: 86)
!578 = !DIEnumerator(name: "unlink", value: 87)
!579 = !DIEnumerator(name: "symlink", value: 88)
!580 = !DIEnumerator(name: "readlink", value: 89)
!581 = !DIEnumerator(name: "chmod", value: 90)
!582 = !DIEnumerator(name: "fchmod", value: 91)
!583 = !DIEnumerator(name: "chown", value: 92)
!584 = !DIEnumerator(name: "fchown", value: 93)
!585 = !DIEnumerator(name: "lchown", value: 94)
!586 = !DIEnumerator(name: "umask", value: 95)
!587 = !DIEnumerator(name: "gettimeofday", value: 96)
!588 = !DIEnumerator(name: "getrlimit", value: 97)
!589 = !DIEnumerator(name: "getrusage", value: 98)
!590 = !DIEnumerator(name: "sysinfo", value: 99)
!591 = !DIEnumerator(name: "times", value: 100)
!592 = !DIEnumerator(name: "ptrace", value: 101)
!593 = !DIEnumerator(name: "getuid", value: 102)
!594 = !DIEnumerator(name: "syslog", value: 103)
!595 = !DIEnumerator(name: "getgid", value: 104)
!596 = !DIEnumerator(name: "setuid", value: 105)
!597 = !DIEnumerator(name: "setgid", value: 106)
!598 = !DIEnumerator(name: "geteuid", value: 107)
!599 = !DIEnumerator(name: "getegid", value: 108)
!600 = !DIEnumerator(name: "setpgid", value: 109)
!601 = !DIEnumerator(name: "getppid", value: 110)
!602 = !DIEnumerator(name: "getpgrp", value: 111)
!603 = !DIEnumerator(name: "setsid", value: 112)
!604 = !DIEnumerator(name: "setreuid", value: 113)
!605 = !DIEnumerator(name: "setregid", value: 114)
!606 = !DIEnumerator(name: "getgroups", value: 115)
!607 = !DIEnumerator(name: "setgroups", value: 116)
!608 = !DIEnumerator(name: "setresuid", value: 117)
!609 = !DIEnumerator(name: "getresuid", value: 118)
!610 = !DIEnumerator(name: "setresgid", value: 119)
!611 = !DIEnumerator(name: "getresgid", value: 120)
!612 = !DIEnumerator(name: "getpgid", value: 121)
!613 = !DIEnumerator(name: "setfsuid", value: 122)
!614 = !DIEnumerator(name: "setfsgid", value: 123)
!615 = !DIEnumerator(name: "getsid", value: 124)
!616 = !DIEnumerator(name: "capget", value: 125)
!617 = !DIEnumerator(name: "capset", value: 126)
!618 = !DIEnumerator(name: "rt_sigpending", value: 127)
!619 = !DIEnumerator(name: "rt_sigtimedwait", value: 128)
!620 = !DIEnumerator(name: "rt_sigqueueinfo", value: 129)
!621 = !DIEnumerator(name: "rt_sigsuspend", value: 130)
!622 = !DIEnumerator(name: "sigaltstack", value: 131)
!623 = !DIEnumerator(name: "utime", value: 132)
!624 = !DIEnumerator(name: "mknod", value: 133)
!625 = !DIEnumerator(name: "uselib", value: 134)
!626 = !DIEnumerator(name: "personality", value: 135)
!627 = !DIEnumerator(name: "ustat", value: 136)
!628 = !DIEnumerator(name: "statfs", value: 137)
!629 = !DIEnumerator(name: "fstatfs", value: 138)
!630 = !DIEnumerator(name: "sysfs", value: 139)
!631 = !DIEnumerator(name: "getpriority", value: 140)
!632 = !DIEnumerator(name: "setpriority", value: 141)
!633 = !DIEnumerator(name: "sched_setparam", value: 142)
!634 = !DIEnumerator(name: "sched_getparam", value: 143)
!635 = !DIEnumerator(name: "sched_setscheduler", value: 144)
!636 = !DIEnumerator(name: "sched_getscheduler", value: 145)
!637 = !DIEnumerator(name: "sched_get_priority_max", value: 146)
!638 = !DIEnumerator(name: "sched_get_priority_min", value: 147)
!639 = !DIEnumerator(name: "sched_rr_get_interval", value: 148)
!640 = !DIEnumerator(name: "mlock", value: 149)
!641 = !DIEnumerator(name: "munlock", value: 150)
!642 = !DIEnumerator(name: "mlockall", value: 151)
!643 = !DIEnumerator(name: "munlockall", value: 152)
!644 = !DIEnumerator(name: "vhangup", value: 153)
!645 = !DIEnumerator(name: "modify_ldt", value: 154)
!646 = !DIEnumerator(name: "pivot_root", value: 155)
!647 = !DIEnumerator(name: "_sysctl", value: 156)
!648 = !DIEnumerator(name: "prctl", value: 157)
!649 = !DIEnumerator(name: "arch_prctl", value: 158)
!650 = !DIEnumerator(name: "adjtimex", value: 159)
!651 = !DIEnumerator(name: "setrlimit", value: 160)
!652 = !DIEnumerator(name: "chroot", value: 161)
!653 = !DIEnumerator(name: "sync", value: 162)
!654 = !DIEnumerator(name: "acct", value: 163)
!655 = !DIEnumerator(name: "settimeofday", value: 164)
!656 = !DIEnumerator(name: "mount", value: 165)
!657 = !DIEnumerator(name: "umount2", value: 166)
!658 = !DIEnumerator(name: "swapon", value: 167)
!659 = !DIEnumerator(name: "swapoff", value: 168)
!660 = !DIEnumerator(name: "reboot", value: 169)
!661 = !DIEnumerator(name: "sethostname", value: 170)
!662 = !DIEnumerator(name: "setdomainname", value: 171)
!663 = !DIEnumerator(name: "iopl", value: 172)
!664 = !DIEnumerator(name: "ioperm", value: 173)
!665 = !DIEnumerator(name: "create_module", value: 174)
!666 = !DIEnumerator(name: "init_module", value: 175)
!667 = !DIEnumerator(name: "delete_module", value: 176)
!668 = !DIEnumerator(name: "get_kernel_syms", value: 177)
!669 = !DIEnumerator(name: "query_module", value: 178)
!670 = !DIEnumerator(name: "quotactl", value: 179)
!671 = !DIEnumerator(name: "nfsservctl", value: 180)
!672 = !DIEnumerator(name: "getpmsg", value: 181)
!673 = !DIEnumerator(name: "putpmsg", value: 182)
!674 = !DIEnumerator(name: "afs_syscall", value: 183)
!675 = !DIEnumerator(name: "tuxcall", value: 184)
!676 = !DIEnumerator(name: "security", value: 185)
!677 = !DIEnumerator(name: "gettid", value: 186)
!678 = !DIEnumerator(name: "readahead", value: 187)
!679 = !DIEnumerator(name: "setxattr", value: 188)
!680 = !DIEnumerator(name: "lsetxattr", value: 189)
!681 = !DIEnumerator(name: "fsetxattr", value: 190)
!682 = !DIEnumerator(name: "getxattr", value: 191)
!683 = !DIEnumerator(name: "lgetxattr", value: 192)
!684 = !DIEnumerator(name: "fgetxattr", value: 193)
!685 = !DIEnumerator(name: "listxattr", value: 194)
!686 = !DIEnumerator(name: "llistxattr", value: 195)
!687 = !DIEnumerator(name: "flistxattr", value: 196)
!688 = !DIEnumerator(name: "removexattr", value: 197)
!689 = !DIEnumerator(name: "lremovexattr", value: 198)
!690 = !DIEnumerator(name: "fremovexattr", value: 199)
!691 = !DIEnumerator(name: "tkill", value: 200)
!692 = !DIEnumerator(name: "time", value: 201)
!693 = !DIEnumerator(name: "futex", value: 202)
!694 = !DIEnumerator(name: "sched_setaffinity", value: 203)
!695 = !DIEnumerator(name: "sched_getaffinity", value: 204)
!696 = !DIEnumerator(name: "set_thread_area", value: 205)
!697 = !DIEnumerator(name: "io_setup", value: 206)
!698 = !DIEnumerator(name: "io_destroy", value: 207)
!699 = !DIEnumerator(name: "io_getevents", value: 208)
!700 = !DIEnumerator(name: "io_submit", value: 209)
!701 = !DIEnumerator(name: "io_cancel", value: 210)
!702 = !DIEnumerator(name: "get_thread_area", value: 211)
!703 = !DIEnumerator(name: "lookup_dcookie", value: 212)
!704 = !DIEnumerator(name: "epoll_create", value: 213)
!705 = !DIEnumerator(name: "epoll_ctl_old", value: 214)
!706 = !DIEnumerator(name: "epoll_wait_old", value: 215)
!707 = !DIEnumerator(name: "remap_file_pages", value: 216)
!708 = !DIEnumerator(name: "getdents64", value: 217)
!709 = !DIEnumerator(name: "set_tid_address", value: 218)
!710 = !DIEnumerator(name: "restart_syscall", value: 219)
!711 = !DIEnumerator(name: "semtimedop", value: 220)
!712 = !DIEnumerator(name: "fadvise64", value: 221)
!713 = !DIEnumerator(name: "timer_create", value: 222)
!714 = !DIEnumerator(name: "timer_settime", value: 223)
!715 = !DIEnumerator(name: "timer_gettime", value: 224)
!716 = !DIEnumerator(name: "timer_getoverrun", value: 225)
!717 = !DIEnumerator(name: "timer_delete", value: 226)
!718 = !DIEnumerator(name: "clock_settime", value: 227)
!719 = !DIEnumerator(name: "clock_gettime", value: 228)
!720 = !DIEnumerator(name: "clock_getres", value: 229)
!721 = !DIEnumerator(name: "clock_nanosleep", value: 230)
!722 = !DIEnumerator(name: "exit_group", value: 231)
!723 = !DIEnumerator(name: "epoll_wait", value: 232)
!724 = !DIEnumerator(name: "epoll_ctl", value: 233)
!725 = !DIEnumerator(name: "tgkill", value: 234)
!726 = !DIEnumerator(name: "utimes", value: 235)
!727 = !DIEnumerator(name: "vserver", value: 236)
!728 = !DIEnumerator(name: "mbind", value: 237)
!729 = !DIEnumerator(name: "set_mempolicy", value: 238)
!730 = !DIEnumerator(name: "get_mempolicy", value: 239)
!731 = !DIEnumerator(name: "mq_open", value: 240)
!732 = !DIEnumerator(name: "mq_unlink", value: 241)
!733 = !DIEnumerator(name: "mq_timedsend", value: 242)
!734 = !DIEnumerator(name: "mq_timedreceive", value: 243)
!735 = !DIEnumerator(name: "mq_notify", value: 244)
!736 = !DIEnumerator(name: "mq_getsetattr", value: 245)
!737 = !DIEnumerator(name: "kexec_load", value: 246)
!738 = !DIEnumerator(name: "waitid", value: 247)
!739 = !DIEnumerator(name: "add_key", value: 248)
!740 = !DIEnumerator(name: "request_key", value: 249)
!741 = !DIEnumerator(name: "keyctl", value: 250)
!742 = !DIEnumerator(name: "ioprio_set", value: 251)
!743 = !DIEnumerator(name: "ioprio_get", value: 252)
!744 = !DIEnumerator(name: "inotify_init", value: 253)
!745 = !DIEnumerator(name: "inotify_add_watch", value: 254)
!746 = !DIEnumerator(name: "inotify_rm_watch", value: 255)
!747 = !DIEnumerator(name: "migrate_pages", value: 256)
!748 = !DIEnumerator(name: "openat", value: 257)
!749 = !DIEnumerator(name: "mkdirat", value: 258)
!750 = !DIEnumerator(name: "mknodat", value: 259)
!751 = !DIEnumerator(name: "fchownat", value: 260)
!752 = !DIEnumerator(name: "futimesat", value: 261)
!753 = !DIEnumerator(name: "fstatat", value: 262)
!754 = !DIEnumerator(name: "unlinkat", value: 263)
!755 = !DIEnumerator(name: "renameat", value: 264)
!756 = !DIEnumerator(name: "linkat", value: 265)
!757 = !DIEnumerator(name: "symlinkat", value: 266)
!758 = !DIEnumerator(name: "readlinkat", value: 267)
!759 = !DIEnumerator(name: "fchmodat", value: 268)
!760 = !DIEnumerator(name: "faccessat", value: 269)
!761 = !DIEnumerator(name: "pselect6", value: 270)
!762 = !DIEnumerator(name: "ppoll", value: 271)
!763 = !DIEnumerator(name: "unshare", value: 272)
!764 = !DIEnumerator(name: "set_robust_list", value: 273)
!765 = !DIEnumerator(name: "get_robust_list", value: 274)
!766 = !DIEnumerator(name: "splice", value: 275)
!767 = !DIEnumerator(name: "tee", value: 276)
!768 = !DIEnumerator(name: "sync_file_range", value: 277)
!769 = !DIEnumerator(name: "vmsplice", value: 278)
!770 = !DIEnumerator(name: "move_pages", value: 279)
!771 = !DIEnumerator(name: "utimensat", value: 280)
!772 = !DIEnumerator(name: "epoll_pwait", value: 281)
!773 = !DIEnumerator(name: "signalfd", value: 282)
!774 = !DIEnumerator(name: "timerfd_create", value: 283)
!775 = !DIEnumerator(name: "eventfd", value: 284)
!776 = !DIEnumerator(name: "fallocate", value: 285)
!777 = !DIEnumerator(name: "timerfd_settime", value: 286)
!778 = !DIEnumerator(name: "timerfd_gettime", value: 287)
!779 = !DIEnumerator(name: "accept4", value: 288)
!780 = !DIEnumerator(name: "signalfd4", value: 289)
!781 = !DIEnumerator(name: "eventfd2", value: 290)
!782 = !DIEnumerator(name: "epoll_create1", value: 291)
!783 = !DIEnumerator(name: "dup3", value: 292)
!784 = !DIEnumerator(name: "pipe2", value: 293)
!785 = !DIEnumerator(name: "inotify_init1", value: 294)
!786 = !DIEnumerator(name: "preadv", value: 295)
!787 = !DIEnumerator(name: "pwritev", value: 296)
!788 = !DIEnumerator(name: "rt_tgsigqueueinfo", value: 297)
!789 = !DIEnumerator(name: "perf_event_open", value: 298)
!790 = !DIEnumerator(name: "recvmmsg", value: 299)
!791 = !DIEnumerator(name: "fanotify_init", value: 300)
!792 = !DIEnumerator(name: "fanotify_mark", value: 301)
!793 = !DIEnumerator(name: "prlimit64", value: 302)
!794 = !DIEnumerator(name: "name_to_handle_at", value: 303)
!795 = !DIEnumerator(name: "open_by_handle_at", value: 304)
!796 = !DIEnumerator(name: "clock_adjtime", value: 305)
!797 = !DIEnumerator(name: "syncfs", value: 306)
!798 = !DIEnumerator(name: "sendmmsg", value: 307)
!799 = !DIEnumerator(name: "setns", value: 308)
!800 = !DIEnumerator(name: "getcpu", value: 309)
!801 = !DIEnumerator(name: "process_vm_readv", value: 310)
!802 = !DIEnumerator(name: "process_vm_writev", value: 311)
!803 = !DIEnumerator(name: "kcmp", value: 312)
!804 = !DIEnumerator(name: "finit_module", value: 313)
!805 = !DIEnumerator(name: "sched_setattr", value: 314)
!806 = !DIEnumerator(name: "sched_getattr", value: 315)
!807 = !DIEnumerator(name: "renameat2", value: 316)
!808 = !DIEnumerator(name: "seccomp", value: 317)
!809 = !DIEnumerator(name: "getrandom", value: 318)
!810 = !DIEnumerator(name: "memfd_create", value: 319)
!811 = !DIEnumerator(name: "kexec_file_load", value: 320)
!812 = !DIEnumerator(name: "bpf", value: 321)
!813 = !DIEnumerator(name: "execveat", value: 322)
!814 = !DIEnumerator(name: "userfaultfd", value: 323)
!815 = !DIEnumerator(name: "membarrier", value: 324)
!816 = !DIEnumerator(name: "mlock2", value: 325)
!817 = !DIEnumerator(name: "copy_file_range", value: 326)
!818 = !DIEnumerator(name: "preadv2", value: 327)
!819 = !DIEnumerator(name: "pwritev2", value: 328)
!820 = !DIEnumerator(name: "pkey_mprotect", value: 329)
!821 = !DIEnumerator(name: "pkey_alloc", value: 330)
!822 = !DIEnumerator(name: "pkey_free", value: 331)
!823 = !DIEnumerator(name: "statx", value: 332)
!824 = !DIEnumerator(name: "io_pgetevents", value: 333)
!825 = !DIEnumerator(name: "rseq", value: 334)
!826 = !DIEnumerator(name: "pidfd_send_signal", value: 424)
!827 = !DIEnumerator(name: "io_uring_setup", value: 425)
!828 = !DIEnumerator(name: "io_uring_enter", value: 426)
!829 = !DIEnumerator(name: "io_uring_register", value: 427)
!830 = !DIEnumerator(name: "open_tree", value: 428)
!831 = !DIEnumerator(name: "move_mount", value: 429)
!832 = !DIEnumerator(name: "fsopen", value: 430)
!833 = !DIEnumerator(name: "fsconfig", value: 431)
!834 = !DIEnumerator(name: "fsmount", value: 432)
!835 = !DIEnumerator(name: "fspick", value: 433)
!836 = !DIEnumerator(name: "pidfd_open", value: 434)
!837 = !DIEnumerator(name: "clone3", value: 435)
!838 = !DIEnumerator(name: "close_range", value: 436)
!839 = !DIEnumerator(name: "openat2", value: 437)
!840 = !DIEnumerator(name: "pidfd_getfd", value: 438)
!841 = !DIEnumerator(name: "faccessat2", value: 439)
!842 = !DIEnumerator(name: "process_madvise", value: 440)
!843 = !DIEnumerator(name: "epoll_pwait2", value: 441)
!844 = !DIEnumerator(name: "mount_setattr", value: 442)
!845 = !DIEnumerator(name: "landlock_create_ruleset", value: 444)
!846 = !DIEnumerator(name: "landlock_add_rule", value: 445)
!847 = !DIEnumerator(name: "landlock_restrict_self", value: 446)
!848 = !DIEnumerator(name: "memfd_secret", value: 447)
!849 = !DICompositeType(tag: DW_TAG_enumeration_type, name: "std.event.loop.Id", scope: !850, file: !850, line: 64, baseType: !7, size: 8, align: 8, elements: !851)
!850 = !DIFile(filename: "loop.zig", directory: "/home/mike/personal/zig/build/lib/zig/std/event")
!851 = !{!852, !853, !854}
!852 = !DIEnumerator(name: "Basic", value: 0)
!853 = !DIEnumerator(name: "Stop", value: 1)
!854 = !DIEnumerator(name: "EventFd", value: 2)
!855 = !DICompositeType(tag: DW_TAG_enumeration_type, name: "std.Thread.enum:337:27", scope: !856, file: !856, line: 337, baseType: !81, size: 8, align: 8, elements: !857)
!856 = !DIFile(filename: "Thread.zig", directory: "/home/mike/personal/zig/build/lib/zig/std")
!857 = !{!858, !859, !860}
!858 = !DIEnumerator(name: "running", value: 0)
!859 = !DIEnumerator(name: "detached", value: 1)
!860 = !DIEnumerator(name: "completed", value: 2)
!861 = !DICompositeType(tag: DW_TAG_enumeration_type, name: "anyerror", baseType: !330, size: 16, align: 16, elements: !862)
!862 = !{!863, !864, !865, !866, !867, !868, !869, !870, !871, !872, !873, !874, !875, !876, !877, !878, !879, !880, !881, !882, !883, !884, !885, !886, !887, !888, !889, !890, !891, !892, !893, !894, !895, !896, !897, !898, !899, !900, !901, !902, !903, !904, !905, !906, !907, !908, !909, !910}
!863 = !DIEnumerator(name: "(none)", value: 0)
!864 = !DIEnumerator(name: "DiskQuota", value: 1)
!865 = !DIEnumerator(name: "FileTooBig", value: 2)
!866 = !DIEnumerator(name: "InputOutput", value: 3)
!867 = !DIEnumerator(name: "NoSpaceLeft", value: 4)
!868 = !DIEnumerator(name: "AccessDenied", value: 5)
!869 = !DIEnumerator(name: "BrokenPipe", value: 6)
!870 = !DIEnumerator(name: "SystemResources", value: 7)
!871 = !DIEnumerator(name: "OperationAborted", value: 8)
!872 = !DIEnumerator(name: "NotOpenForWriting", value: 9)
!873 = !DIEnumerator(name: "WouldBlock", value: 10)
!874 = !DIEnumerator(name: "ConnectionResetByPeer", value: 11)
!875 = !DIEnumerator(name: "Unexpected", value: 12)
!876 = !DIEnumerator(name: "MemoryMappingNotSupported", value: 13)
!877 = !DIEnumerator(name: "PermissionDenied", value: 14)
!878 = !DIEnumerator(name: "LockedMemoryLimitExceeded", value: 15)
!879 = !DIEnumerator(name: "OutOfMemory", value: 16)
!880 = !DIEnumerator(name: "LimitTooBig", value: 17)
!881 = !DIEnumerator(name: "Utf8InvalidStartByte", value: 18)
!882 = !DIEnumerator(name: "TruncatedInput", value: 19)
!883 = !DIEnumerator(name: "Utf8ExpectedContinuation", value: 20)
!884 = !DIEnumerator(name: "Utf8OverlongEncoding", value: 21)
!885 = !DIEnumerator(name: "Utf8EncodesSurrogateHalf", value: 22)
!886 = !DIEnumerator(name: "Utf8CodepointTooLarge", value: 23)
!887 = !DIEnumerator(name: "IsDir", value: 24)
!888 = !DIEnumerator(name: "ConnectionTimedOut", value: 25)
!889 = !DIEnumerator(name: "NotOpenForReading", value: 26)
!890 = !DIEnumerator(name: "Unseekable", value: 27)
!891 = !DIEnumerator(name: "SymLinkLoop", value: 28)
!892 = !DIEnumerator(name: "ProcessFdQuotaExceeded", value: 29)
!893 = !DIEnumerator(name: "SystemFdQuotaExceeded", value: 30)
!894 = !DIEnumerator(name: "NoDevice", value: 31)
!895 = !DIEnumerator(name: "FileNotFound", value: 32)
!896 = !DIEnumerator(name: "NameTooLong", value: 33)
!897 = !DIEnumerator(name: "NotDir", value: 34)
!898 = !DIEnumerator(name: "PathAlreadyExists", value: 35)
!899 = !DIEnumerator(name: "DeviceBusy", value: 36)
!900 = !DIEnumerator(name: "FileLocksNotSupported", value: 37)
!901 = !DIEnumerator(name: "BadPathName", value: 38)
!902 = !DIEnumerator(name: "InvalidUtf8", value: 39)
!903 = !DIEnumerator(name: "FileBusy", value: 40)
!904 = !DIEnumerator(name: "ReadOnlyFileSystem", value: 41)
!905 = !DIEnumerator(name: "TimedOut", value: 42)
!906 = !DIEnumerator(name: "TimerUnsupported", value: 43)
!907 = !DIEnumerator(name: "SkipZigTest", value: 44)
!908 = !DIEnumerator(name: "InvalidCmdLine", value: 45)
!909 = !DIEnumerator(name: "Overflow", value: 46)
!910 = !DIEnumerator(name: "UnsupportedClock", value: 47)
!911 = !DICompositeType(tag: DW_TAG_enumeration_type, name: "@typeInfo(std.event.loop.Msg).Union.tag_type.?", scope: !850, file: !850, line: 1577, baseType: !912, size: 8, align: 8, elements: !913)
!912 = !DIBasicType(name: "u4", size: 8, encoding: DW_ATE_unsigned)
!913 = !{!491, !914, !915, !916, !917, !918, !919, !920, !921, !922, !923, !924, !925}
!914 = !DIEnumerator(name: "readv", value: 1)
!915 = !DIEnumerator(name: "write", value: 2)
!916 = !DIEnumerator(name: "writev", value: 3)
!917 = !DIEnumerator(name: "pwrite", value: 4)
!918 = !DIEnumerator(name: "pwritev", value: 5)
!919 = !DIEnumerator(name: "pread", value: 6)
!920 = !DIEnumerator(name: "preadv", value: 7)
!921 = !DIEnumerator(name: "open", value: 8)
!922 = !DIEnumerator(name: "openat", value: 9)
!923 = !DIEnumerator(name: "close", value: 10)
!924 = !DIEnumerator(name: "faccessat", value: 11)
!925 = !DIEnumerator(name: "end", value: 12)
!926 = !DICompositeType(tag: DW_TAG_enumeration_type, name: "@typeInfo(std.event.loop.Finish).Union.tag_type.?", scope: !850, file: !850, line: 1572, baseType: !324, size: 8, align: 8, elements: !927)
!927 = !{!928, !929}
!928 = !DIEnumerator(name: "TickNode", value: 0)
!929 = !DIEnumerator(name: "NoAction", value: 1)
!930 = !DICompositeType(tag: DW_TAG_enumeration_type, name: "std.log.Level", scope: !931, file: !931, line: 75, baseType: !7, size: 8, align: 8, elements: !932)
!931 = !DIFile(filename: "log.zig", directory: "/home/mike/personal/zig/build/lib/zig/std")
!932 = !{!933, !934, !935, !936}
!933 = !DIEnumerator(name: "err", value: 0)
!934 = !DIEnumerator(name: "warn", value: 1)
!935 = !DIEnumerator(name: "info", value: 2)
!936 = !DIEnumerator(name: "debug", value: 3)
!937 = !DICompositeType(tag: DW_TAG_enumeration_type, name: "std.builtin.Endian", scope: !6, file: !6, line: 445, baseType: !324, size: 8, align: 8, elements: !938)
!938 = !{!939, !940}
!939 = !DIEnumerator(name: "Big", value: 0)
!940 = !DIEnumerator(name: "Little", value: 1)
!941 = !DICompositeType(tag: DW_TAG_enumeration_type, name: "@typeInfo(Value).Union.tag_type.?", scope: !942, file: !942, line: 6, baseType: !324, size: 8, align: 8, elements: !943)
!942 = !DIFile(filename: "code.zig", directory: "/home/mike/personal/sizr/sizr-format-zig/src")
!943 = !{!944, !945}
!944 = !DIEnumerator(name: "c", value: 0)
!945 = !DIEnumerator(name: "d", value: 1)
!946 = !DICompositeType(tag: DW_TAG_enumeration_type, name: "@typeInfo(Expr).Union.tag_type.?", scope: !942, file: !942, line: 1, baseType: !324, size: 8, align: 8, elements: !947)
!947 = !{!948, !949}
!948 = !DIEnumerator(name: "a", value: 0)
!949 = !DIEnumerator(name: "b", value: 1)
!950 = !DICompositeType(tag: DW_TAG_enumeration_type, name: "std.os.linux.rlimit_resource", scope: !951, file: !951, line: 4209, baseType: !952, size: 32, align: 32, elements: !953)
!951 = !DIFile(filename: "linux.zig", directory: "/home/mike/personal/zig/build/lib/zig/std/os")
!952 = !DIBasicType(name: "c_int", size: 32, encoding: DW_ATE_signed)
!953 = !{!954, !955, !956, !957, !958, !959, !960, !961, !962, !963, !964, !965, !966, !967, !968, !969}
!954 = !DIEnumerator(name: "CPU", value: 0)
!955 = !DIEnumerator(name: "FSIZE", value: 1)
!956 = !DIEnumerator(name: "DATA", value: 2)
!957 = !DIEnumerator(name: "STACK", value: 3)
!958 = !DIEnumerator(name: "CORE", value: 4)
!959 = !DIEnumerator(name: "RSS", value: 5)
!960 = !DIEnumerator(name: "NPROC", value: 6)
!961 = !DIEnumerator(name: "NOFILE", value: 7)
!962 = !DIEnumerator(name: "MEMLOCK", value: 8)
!963 = !DIEnumerator(name: "AS", value: 9)
!964 = !DIEnumerator(name: "LOCKS", value: 10)
!965 = !DIEnumerator(name: "SIGPENDING", value: 11)
!966 = !DIEnumerator(name: "MSGQUEUE", value: 12)
!967 = !DIEnumerator(name: "NICE", value: 13)
!968 = !DIEnumerator(name: "RTPRIO", value: 14)
!969 = !DIEnumerator(name: "RTTIME", value: 15)
!970 = !DICompositeType(tag: DW_TAG_enumeration_type, name: "std.fmt.Alignment", scope: !971, file: !971, line: 14, baseType: !7, size: 8, align: 8, elements: !972)
!971 = !DIFile(filename: "fmt.zig", directory: "/home/mike/personal/zig/build/lib/zig/std")
!972 = !{!973, !974, !975}
!973 = !DIEnumerator(name: "Left", value: 0)
!974 = !DIEnumerator(name: "Center", value: 1)
!975 = !DIEnumerator(name: "Right", value: 2)
!976 = !DICompositeType(tag: DW_TAG_enumeration_type, name: "std.Thread.ResetEvent.TimedWaitResult", scope: !977, file: !977, line: 65, baseType: !324, size: 8, align: 8, elements: !978)
!977 = !DIFile(filename: "ResetEvent.zig", directory: "/home/mike/personal/zig/build/lib/zig/std/Thread")
!978 = !{!979, !980}
!979 = !DIEnumerator(name: "event_set", value: 0)
!980 = !DIEnumerator(name: "timed_out", value: 1)
!981 = !DICompositeType(tag: DW_TAG_enumeration_type, name: "std.fmt.Case", scope: !971, file: !971, line: 735, baseType: !324, size: 8, align: 8, elements: !982)
!982 = !{!983, !984}
!983 = !DIEnumerator(name: "lower", value: 0)
!984 = !DIEnumerator(name: "upper", value: 1)
!985 = !DICompositeType(tag: DW_TAG_enumeration_type, name: "std.mem.Allocator.Exact", scope: !986, file: !986, line: 272, baseType: !324, size: 8, align: 8, elements: !987)
!986 = !DIFile(filename: "Allocator.zig", directory: "/home/mike/personal/zig/build/lib/zig/std/mem")
!987 = !{!988, !989}
!988 = !DIEnumerator(name: "exact", value: 0)
!989 = !DIEnumerator(name: "at_least", value: 1)
!990 = !DICompositeType(tag: DW_TAG_enumeration_type, name: "std.elf.ET", scope: !991, file: !991, line: 309, baseType: !330, size: 16, align: 16, elements: !992)
!991 = !DIFile(filename: "elf.zig", directory: "/home/mike/personal/zig/build/lib/zig/std")
!992 = !{!993, !994, !995, !996, !958}
!993 = !DIEnumerator(name: "NONE", value: 0)
!994 = !DIEnumerator(name: "REL", value: 1)
!995 = !DIEnumerator(name: "EXEC", value: 2)
!996 = !DIEnumerator(name: "DYN", value: 3)
!997 = !DICompositeType(tag: DW_TAG_enumeration_type, name: "std.elf.EM", scope: !991, file: !991, line: 948, baseType: !330, size: 16, align: 16, elements: !998)
!998 = !{!999, !1000, !1001, !1002, !1003, !1004, !1005, !1006, !1007, !1008, !1009, !1010, !1011, !1012, !1013, !1014, !1015, !1016, !1017, !1018, !1019, !1020, !1021, !1022, !1023, !1024, !1025, !1026, !1027, !1028, !1029, !1030, !1031, !1032, !1033, !1034, !1035, !1036, !1037, !1038, !1039, !1040, !1041, !1042, !1043, !1044, !1045, !1046, !1047, !1048, !1049, !1050, !1051, !1052, !1053, !1054, !1055, !1056, !1057, !1058, !1059, !1060, !1061, !1062, !1063, !1064, !1065, !1066, !1067, !1068, !1069, !1070, !1071, !1072, !1073, !1074, !1075, !1076, !1077, !1078, !1079, !1080, !1081, !1082, !1083, !1084, !1085, !1086, !1087, !1088, !1089, !1090, !1091, !1092, !1093, !1094, !1095, !1096, !1097, !1098, !1099, !1100, !1101, !1102, !1103, !1104, !1105, !1106, !1107, !1108, !1109, !1110, !1111, !1112, !1113, !1114, !1115, !1116, !1117, !1118, !1119, !1120, !1121, !1122, !1123, !1124, !1125, !1126, !1127, !1128, !1129, !1130, !1131, !1132, !1133, !1134, !1135, !1136, !1137, !1138, !1139, !1140, !1141, !1142, !1143, !1144, !1145, !1146, !1147, !1148, !1149, !1150, !1151, !1152, !1153, !1154, !1155, !1156, !1157, !1158, !1159, !1160, !1161, !1162, !1163, !1164, !1165, !1166, !1167, !1168, !1169, !1170, !1171, !1172, !1173, !1174, !1175, !1176}
!999 = !DIEnumerator(name: "_NONE", value: 0)
!1000 = !DIEnumerator(name: "_M32", value: 1)
!1001 = !DIEnumerator(name: "_SPARC", value: 2)
!1002 = !DIEnumerator(name: "_386", value: 3)
!1003 = !DIEnumerator(name: "_68K", value: 4)
!1004 = !DIEnumerator(name: "_88K", value: 5)
!1005 = !DIEnumerator(name: "_IAMCU", value: 6)
!1006 = !DIEnumerator(name: "_860", value: 7)
!1007 = !DIEnumerator(name: "_MIPS", value: 8)
!1008 = !DIEnumerator(name: "_S370", value: 9)
!1009 = !DIEnumerator(name: "_MIPS_RS3_LE", value: 10)
!1010 = !DIEnumerator(name: "_SPU_2", value: 13)
!1011 = !DIEnumerator(name: "_PARISC", value: 15)
!1012 = !DIEnumerator(name: "_VPP500", value: 17)
!1013 = !DIEnumerator(name: "_SPARC32PLUS", value: 18)
!1014 = !DIEnumerator(name: "_960", value: 19)
!1015 = !DIEnumerator(name: "_PPC", value: 20)
!1016 = !DIEnumerator(name: "_PPC64", value: 21)
!1017 = !DIEnumerator(name: "_S390", value: 22)
!1018 = !DIEnumerator(name: "_SPU", value: 23)
!1019 = !DIEnumerator(name: "_V800", value: 36)
!1020 = !DIEnumerator(name: "_FR20", value: 37)
!1021 = !DIEnumerator(name: "_RH32", value: 38)
!1022 = !DIEnumerator(name: "_RCE", value: 39)
!1023 = !DIEnumerator(name: "_ARM", value: 40)
!1024 = !DIEnumerator(name: "_ALPHA", value: 41)
!1025 = !DIEnumerator(name: "_SH", value: 42)
!1026 = !DIEnumerator(name: "_SPARCV9", value: 43)
!1027 = !DIEnumerator(name: "_TRICORE", value: 44)
!1028 = !DIEnumerator(name: "_ARC", value: 45)
!1029 = !DIEnumerator(name: "_H8_300", value: 46)
!1030 = !DIEnumerator(name: "_H8_300H", value: 47)
!1031 = !DIEnumerator(name: "_H8S", value: 48)
!1032 = !DIEnumerator(name: "_H8_500", value: 49)
!1033 = !DIEnumerator(name: "_IA_64", value: 50)
!1034 = !DIEnumerator(name: "_MIPS_X", value: 51)
!1035 = !DIEnumerator(name: "_COLDFIRE", value: 52)
!1036 = !DIEnumerator(name: "_68HC12", value: 53)
!1037 = !DIEnumerator(name: "_MMA", value: 54)
!1038 = !DIEnumerator(name: "_PCP", value: 55)
!1039 = !DIEnumerator(name: "_NCPU", value: 56)
!1040 = !DIEnumerator(name: "_NDR1", value: 57)
!1041 = !DIEnumerator(name: "_STARCORE", value: 58)
!1042 = !DIEnumerator(name: "_ME16", value: 59)
!1043 = !DIEnumerator(name: "_ST100", value: 60)
!1044 = !DIEnumerator(name: "_TINYJ", value: 61)
!1045 = !DIEnumerator(name: "_X86_64", value: 62)
!1046 = !DIEnumerator(name: "_PDSP", value: 63)
!1047 = !DIEnumerator(name: "_PDP10", value: 64)
!1048 = !DIEnumerator(name: "_PDP11", value: 65)
!1049 = !DIEnumerator(name: "_FX66", value: 66)
!1050 = !DIEnumerator(name: "_ST9PLUS", value: 67)
!1051 = !DIEnumerator(name: "_ST7", value: 68)
!1052 = !DIEnumerator(name: "_68HC16", value: 69)
!1053 = !DIEnumerator(name: "_68HC11", value: 70)
!1054 = !DIEnumerator(name: "_68HC08", value: 71)
!1055 = !DIEnumerator(name: "_68HC05", value: 72)
!1056 = !DIEnumerator(name: "_SVX", value: 73)
!1057 = !DIEnumerator(name: "_ST19", value: 74)
!1058 = !DIEnumerator(name: "_VAX", value: 75)
!1059 = !DIEnumerator(name: "_CRIS", value: 76)
!1060 = !DIEnumerator(name: "_JAVELIN", value: 77)
!1061 = !DIEnumerator(name: "_FIREPATH", value: 78)
!1062 = !DIEnumerator(name: "_ZSP", value: 79)
!1063 = !DIEnumerator(name: "_MMIX", value: 80)
!1064 = !DIEnumerator(name: "_HUANY", value: 81)
!1065 = !DIEnumerator(name: "_PRISM", value: 82)
!1066 = !DIEnumerator(name: "_AVR", value: 83)
!1067 = !DIEnumerator(name: "_FR30", value: 84)
!1068 = !DIEnumerator(name: "_D10V", value: 85)
!1069 = !DIEnumerator(name: "_D30V", value: 86)
!1070 = !DIEnumerator(name: "_V850", value: 87)
!1071 = !DIEnumerator(name: "_M32R", value: 88)
!1072 = !DIEnumerator(name: "_MN10300", value: 89)
!1073 = !DIEnumerator(name: "_MN10200", value: 90)
!1074 = !DIEnumerator(name: "_PJ", value: 91)
!1075 = !DIEnumerator(name: "_OPENRISC", value: 92)
!1076 = !DIEnumerator(name: "_ARC_COMPACT", value: 93)
!1077 = !DIEnumerator(name: "_XTENSA", value: 94)
!1078 = !DIEnumerator(name: "_VIDEOCORE", value: 95)
!1079 = !DIEnumerator(name: "_TMM_GPP", value: 96)
!1080 = !DIEnumerator(name: "_NS32K", value: 97)
!1081 = !DIEnumerator(name: "_TPC", value: 98)
!1082 = !DIEnumerator(name: "_SNP1K", value: 99)
!1083 = !DIEnumerator(name: "_ST200", value: 100)
!1084 = !DIEnumerator(name: "_IP2K", value: 101)
!1085 = !DIEnumerator(name: "_MAX", value: 102)
!1086 = !DIEnumerator(name: "_CR", value: 103)
!1087 = !DIEnumerator(name: "_F2MC16", value: 104)
!1088 = !DIEnumerator(name: "_MSP430", value: 105)
!1089 = !DIEnumerator(name: "_BLACKFIN", value: 106)
!1090 = !DIEnumerator(name: "_SE_C33", value: 107)
!1091 = !DIEnumerator(name: "_SEP", value: 108)
!1092 = !DIEnumerator(name: "_ARCA", value: 109)
!1093 = !DIEnumerator(name: "_UNICORE", value: 110)
!1094 = !DIEnumerator(name: "_EXCESS", value: 111)
!1095 = !DIEnumerator(name: "_DXP", value: 112)
!1096 = !DIEnumerator(name: "_ALTERA_NIOS2", value: 113)
!1097 = !DIEnumerator(name: "_CRX", value: 114)
!1098 = !DIEnumerator(name: "_XGATE", value: 115)
!1099 = !DIEnumerator(name: "_C166", value: 116)
!1100 = !DIEnumerator(name: "_M16C", value: 117)
!1101 = !DIEnumerator(name: "_DSPIC30F", value: 118)
!1102 = !DIEnumerator(name: "_CE", value: 119)
!1103 = !DIEnumerator(name: "_M32C", value: 120)
!1104 = !DIEnumerator(name: "_TSK3000", value: 131)
!1105 = !DIEnumerator(name: "_RS08", value: 132)
!1106 = !DIEnumerator(name: "_SHARC", value: 133)
!1107 = !DIEnumerator(name: "_ECOG2", value: 134)
!1108 = !DIEnumerator(name: "_SCORE7", value: 135)
!1109 = !DIEnumerator(name: "_DSP24", value: 136)
!1110 = !DIEnumerator(name: "_VIDEOCORE3", value: 137)
!1111 = !DIEnumerator(name: "_LATTICEMICO32", value: 138)
!1112 = !DIEnumerator(name: "_SE_C17", value: 139)
!1113 = !DIEnumerator(name: "_TI_C6000", value: 140)
!1114 = !DIEnumerator(name: "_TI_C2000", value: 141)
!1115 = !DIEnumerator(name: "_TI_C5500", value: 142)
!1116 = !DIEnumerator(name: "_MMDSP_PLUS", value: 160)
!1117 = !DIEnumerator(name: "_CYPRESS_M8C", value: 161)
!1118 = !DIEnumerator(name: "_R32C", value: 162)
!1119 = !DIEnumerator(name: "_TRIMEDIA", value: 163)
!1120 = !DIEnumerator(name: "_HEXAGON", value: 164)
!1121 = !DIEnumerator(name: "_8051", value: 165)
!1122 = !DIEnumerator(name: "_STXP7X", value: 166)
!1123 = !DIEnumerator(name: "_NDS32", value: 167)
!1124 = !DIEnumerator(name: "_ECOG1X", value: 168)
!1125 = !DIEnumerator(name: "_MAXQ30", value: 169)
!1126 = !DIEnumerator(name: "_XIMO16", value: 170)
!1127 = !DIEnumerator(name: "_MANIK", value: 171)
!1128 = !DIEnumerator(name: "_CRAYNV2", value: 172)
!1129 = !DIEnumerator(name: "_RX", value: 173)
!1130 = !DIEnumerator(name: "_METAG", value: 174)
!1131 = !DIEnumerator(name: "_MCST_ELBRUS", value: 175)
!1132 = !DIEnumerator(name: "_ECOG16", value: 176)
!1133 = !DIEnumerator(name: "_CR16", value: 177)
!1134 = !DIEnumerator(name: "_ETPU", value: 178)
!1135 = !DIEnumerator(name: "_SLE9X", value: 179)
!1136 = !DIEnumerator(name: "_L10M", value: 180)
!1137 = !DIEnumerator(name: "_K10M", value: 181)
!1138 = !DIEnumerator(name: "_AARCH64", value: 183)
!1139 = !DIEnumerator(name: "_AVR32", value: 185)
!1140 = !DIEnumerator(name: "_STM8", value: 186)
!1141 = !DIEnumerator(name: "_TILE64", value: 187)
!1142 = !DIEnumerator(name: "_TILEPRO", value: 188)
!1143 = !DIEnumerator(name: "_CUDA", value: 190)
!1144 = !DIEnumerator(name: "_TILEGX", value: 191)
!1145 = !DIEnumerator(name: "_CLOUDSHIELD", value: 192)
!1146 = !DIEnumerator(name: "_COREA_1ST", value: 193)
!1147 = !DIEnumerator(name: "_COREA_2ND", value: 194)
!1148 = !DIEnumerator(name: "_ARC_COMPACT2", value: 195)
!1149 = !DIEnumerator(name: "_OPEN8", value: 196)
!1150 = !DIEnumerator(name: "_RL78", value: 197)
!1151 = !DIEnumerator(name: "_VIDEOCORE5", value: 198)
!1152 = !DIEnumerator(name: "_78KOR", value: 199)
!1153 = !DIEnumerator(name: "_56800EX", value: 200)
!1154 = !DIEnumerator(name: "_BA1", value: 201)
!1155 = !DIEnumerator(name: "_BA2", value: 202)
!1156 = !DIEnumerator(name: "_XCORE", value: 203)
!1157 = !DIEnumerator(name: "_MCHP_PIC", value: 204)
!1158 = !DIEnumerator(name: "_INTEL205", value: 205)
!1159 = !DIEnumerator(name: "_INTEL206", value: 206)
!1160 = !DIEnumerator(name: "_INTEL207", value: 207)
!1161 = !DIEnumerator(name: "_INTEL208", value: 208)
!1162 = !DIEnumerator(name: "_INTEL209", value: 209)
!1163 = !DIEnumerator(name: "_KM32", value: 210)
!1164 = !DIEnumerator(name: "_KMX32", value: 211)
!1165 = !DIEnumerator(name: "_KMX16", value: 212)
!1166 = !DIEnumerator(name: "_KMX8", value: 213)
!1167 = !DIEnumerator(name: "_KVARC", value: 214)
!1168 = !DIEnumerator(name: "_CDP", value: 215)
!1169 = !DIEnumerator(name: "_COGE", value: 216)
!1170 = !DIEnumerator(name: "_COOL", value: 217)
!1171 = !DIEnumerator(name: "_NORC", value: 218)
!1172 = !DIEnumerator(name: "_CSR_KALIMBA", value: 219)
!1173 = !DIEnumerator(name: "_AMDGPU", value: 224)
!1174 = !DIEnumerator(name: "_RISCV", value: 243)
!1175 = !DIEnumerator(name: "_LANAI", value: 244)
!1176 = !DIEnumerator(name: "_BPF", value: 247)

;;; broken LLVM module found: Instruction does not dominate all uses!
;;;   %30 = getelementptr inbounds %"?Value", %"?Value"* %0, i32 0, i32 0
;;;   %34 = getelementptr inbounds %Value, %Value* %30, i32 0, i32 1
;;; Instruction does not dominate all uses!
;;;   %30 = getelementptr inbounds %"?Value", %"?Value"* %0, i32 0, i32 0
;;;   %35 = bitcast %Value* %30 to i8*
;;; Instruction does not dominate all uses!
;;;   %30 = getelementptr inbounds %"?Value", %"?Value"* %0, i32 0, i32 0
;;;   %36 = bitcast %Value* %30 to i8*
;;; Instruction does not dominate all uses!
;;;   %30 = getelementptr inbounds %"?Value", %"?Value"* %0, i32 0, i32 0
;;;   %37 = phi %Value* [ %30, %Then1 ], [ %30, %Else2 ]
;;; Instruction does not dominate all uses!
;;;   %30 = getelementptr inbounds %"?Value", %"?Value"* %0, i32 0, i32 0
;;;   %39 = bitcast %Value* %30 to i8*

;;; This is a bug in the Zig compiler.thread 2162641 panic: 
;;; ???:?:?: 0x5570d88ebad7 in ??? (???)
;;; ???:?:?: 0x5570d9883719 in ??? (???)
;;; ???:?:?: 0x5570d98aa9e9 in ??? (???)
;;; ???:?:?: 0x5570d98afb6f in ??? (???)
;;; ???:?:?: 0x5570d987f273 in ??? (???)
;;; ???:?:?: 0x5570d8ceede4 in ??? (???)
;;; ???:?:?: 0x5570d8caf68a in ??? (???)
;;; ???:?:?: 0x5570d8a83205 in ??? (???)
;;; ???:?:?: 0x5570d8a76432 in ??? (???)
;;; ???:?:?: 0x5570d8a71fd1 in ??? (???)
;;; ???:?:?: 0x5570d8a005ff in ??? (???)
;;; ???:?:?: 0x5570d891a486 in ??? (???)
;;; ???:?:?: 0x5570d88ea316 in ??? (???)
;;; ???:?:?: 0x5570d88e9aa9 in ??? (???)
